   2: title: 'Pascal Compiler 1.1.5 -- Jan 01 ''90';
         
      %
      %  Pascal.ssl
      %
      %  Pascal Compiler for the Amiga, by Steve Rice.
      %
      %  HISTORY
      %    11Sep89   First version, framework of parser.
      %    18Sep89   Added some semantic mechanisms.
      %    21Sep89   Added simple type references; expressions generate code.
      %    22Sep89   Allocate variable addresses as they're declared.
      %    24Sep89   Added arrays, pointers.
      %    27Sep89   Added for statement.
      %    23Oct89   Fixed for statement, so CYCLE goes to next step.
      %    01Jan90   Added string literals
      %    09Sep22   I have returned.  Migrate symbol table to schema, to ease development.
      %    01Oct22   Language: Switch from cycle/exit (Mac Pascal extension) to continue/break (Borland).
      %
      %  NOTES
      %    -  The 'value' of a var symbol is its allocated address.
      %    -  References to vars of intrinsic types, and pointer types,
      %       pushes the value of the var on the expr stack.  Referenecs to
      %       vars of compound types (arrays, records...) pushes the address
      %       on the expr stack.
      %    -  Just as there is only one type table entry for a given (named) type,
      %       there is only one type table entry for a pointer to a named type.
      %       When a pointer type is declared, a field in the TT entry of the
      %       type pointed to will be set to indicate the TT entry of the pointer
      %       to that type (0 means none defined yet).  When evaluating the
      %       expression @x, the type in that field in the entry for the type of x
      %       will be used (unless it's 0, in which case a new TT entry will be
      %       created).
      %
      %
      %  MISSING
      %
      %    - Consider non-ISO extensions.  e.g. 
      %      Dynamic arrays.  Objects.  But, perhaps stick to my old goal, standard Pascal.
      %
      %  PASCAL DOCS
      %      Here's some handy language material:
      %      https://www.freepascal.org/docs-html/ref/ref.html
      %      https://www.freepascal.org/docs-html/prog/prog.html
      %      https://en.wikipedia.org/wiki/Turbo_Pascal
      %      https://en.wikipedia.org/wiki/Pascal_(programming_language)#Standards
      %      http://www.standardpascaline.org/
      %
      
   2: input:
   2:    pIdent
   2:    pIntLit
   2:    pStrLit
   2:    pCharLit
   2:    pAssign       ':='
   2:    pSemiColon    ';'
   2:    pEqual        '='
   2:    pNotEqual     '<>'
   2:    pLess         '<'
   2:    pGreater      '>'
   2:    pLessEqual    '<='
   2:    pGreaterEqual '>='
   2:    pColon        ':'
   2:    pComma        ','
   2:    pLParen       '('
   2:    pRParen       ')'
   2:    pLSquare      '['
   2:    pRSquare      ']'
   2:    pCarat        '^'
   2:    pAt           '@'
   2:    pDot          '.'
   2:    pDotDot       '..'
   2:    pTimes        '*'
   2:    pDivide       '/'
   2:    pPlus         '+'
   2:    pMinus        '-'
   2:    pEof
   2:    pInvalid
      
      %  keywords  (built-in types 'integer', 'byte', 'char', etc, are not keywords,
      %             type constructors 'array', 'record', 'set' are keywords,
      %             pseudo-procedures 'writeln', 'readln' are keywords)
      %
      %             forward/external/name/cdecl appear in method modifiers, in fpc grammar.
      %             I'm making them keywords to simplify parsing, but could reconsider.
      
   2:    pProgram
   2:    pProcedure
   2:    pFunction
   2:    pConst
   2:    pType
   2:    pVar
   2:    pLabel
   2:    pBegin
   2:    pEnd
   2:    pArray
   2:    pRecord
   2:    pSet
   2:    pOf
   2:    pIf
   2:    pThen
   2:    pElse
   2:    pFor
   2:    pTo
   2:    pDownto
   2:    pDo
   2:    pWhile
   2:    pRepeat
   2:    pUntil
   2:    pContinue
   2:    pBreak
   2:    pGoto
   2:    pAnd
   2:    pOr
   2:    pNot
   2:    pUses
   2:    pUnit
   2:    pInterface
   2:    pImplementation
   2:    pInitialization
   2:    pFinalization
   2:    pWriteln
   2:    pWrite
   2:    pReadln
   2:    pRead
      
   2:    pForward
   2:    pExternal
   2:    pName
   2:    pCdecl
   2:    ;
      
      
   2: output:
      
      %  Instructions for a stack machine (all vars are 32-bit integers)
      
   2:    tPushGlobalI      % <ptr> - push int value read from ptr
   2:    tPushGlobalB      % <ptr> - push byte value read from ptr
   2:    tPushGlobalP      % <ptr> - push ptr value read from ptr
   2:    tPushLocalI       % <offset> - push int value read from local var in current scope
   2:    tPushLocalB       % <offset> - push byte value read from local var in current scope
   2:    tPushLocalP       % <offset> - push ptr value read from local var in current scope
   2:    tPushParamI       % <offset> - push int value read from param in current scope
   2:    tPushParamB       % <offset> - push byte value read from param in current scope
   2:    tPushParamP       % <offset> - push ptr value read from param in current scope
   2:    tPushUpLocalI     % <uplevels> <offset> - push int value read from local var in a parent static scope
   2:    tPushUpLocalB     % <uplevels> <offset> - push byte value read from local var in a parent static scope
   2:    tPushUpLocalP     % <uplevels> <offset> - push ptr value read from local var in a parent static scope
   2:    tPushUpParamI     % <uplevels> <offset> - push int value read from param in a parent static scope
   2:    tPushUpParamB     % <uplevels> <offset> - push byte value read from param in a parent static scope
   2:    tPushUpParamP     % <uplevels> <offset> - push ptr value read from param in a parent static scope
   2:    tPushConstI       % <int> - push int value on stack (NOTE, used for BOOLEAN too)
   2:    tPushAddrGlobal   % <offset> - push ptr to global var (same as tPushConstP)
   2:    tPushAddrLocal    % <offset> - push ptr to local var
   2:    tPushAddrParam    % <offset> - push ptr to formal param (used by method to see its param)
   2:    tPushAddrActual   % <offset> - push ptr to actual param, in actuals space (used by caller)
   2:    tPushAddrUpLocal  % <uplevels> <offset> - push ptr to local var in a parent static scope
   2:    tPushAddrUpParam  % <uplevels> <offset> - push ptr to formal param in a parent static scope
   2:    tFetchI           % pop ptr from stack, and push int value it points to
   2:    tFetchB           %    "      "      "     "     byte  "   "    "
   2:    tFetchP           %    "      "      "     "     ptr   "   "    "   
   2:    tAssignI          % assign int value on top of stack to addr under it (pop both)
   2:    tAssignB          %   "    byte   "    "   "  "   "    "    "   "   "
   2:    tAssignP          %   "    ptr    "    "   "  "   "    "    "   "   "
   2:    tCopy             % <#bytes> - copy bytes.  tos=src, 2nd=dest (pop 2)
   2:    tCastBtoI         % zero-extend uint8_t to int32_t
   2:    tCastItoB         % truncate int32_t to uint8_t
   2:    tIncI             % increment int value on top of expr stack
   2:    tDecI             % decrement int value on top of expr stack
   2:    tMultI            % multiply top two integers (replacing with result)
   2:    tDivI
   2:    tAddPI            % add ptr (2nd value) and int (top value), resulting in a ptr
   2:    tAddI
   2:    tSubI
   2:    tNegI             % top entry *= -1
   2:    tNot              % negate top boolean
   2:    tEqualB
   2:    tNotEqualB
   2:    tGreaterB         % B is uint8_t, so these are unsigned comparisons
   2:    tLessB
   2:    tGreaterEqualB
   2:    tLessEqualB
   2:    tEqualI           % top two entries equal? (pop 2, push 1) (true=1)
   2:    tNotEqualI        %    NOTE, these all work for booleans too, but I'm moving to tEqualB etc for those
   2:    tGreaterI         % 2nd entry greater than top entry? (pop 2, push answer)
   2:    tLessI  
   2:    tGreaterEqualI
   2:    tLessEqualI
   2:    tEqualP           % two two pointer values equal? (pop 2, push 1) (true=1)
   2:    tNotEqualP
   2:    tGreaterP
   2:    tLessP
   2:    tGreaterEqualP
   2:    tLessEqualP
   2:    tAllocActuals     % <#bytes> - make space on call stack for actual params (adjusting call stack sp)
   2:    tAllocActualsCdecl  % <#bytes> - starting a call to a cdecl method.  tcode still describes my own calling convention.
   2:    tFreeActuals      % <#bytes> - discard space on call stack allocated by tAllocActuals
   2:    tCall             % <label#>
   2:    tCallCdecl        % <label#> - call a method using native (C) calling convention. Only supported for extern labels.
   2:    tReturn
   2:    tEnter            % <#bytes> - start a stack frame on the call stack, reserving #bytes of local variable space
   2:    tJump             % <label#>
   2:    tJumpTrue         % <label#>  (pops top of stack, jumps if true)
   2:    tJumpFalse        % <label#>  (pops top of stack, jumps if false)
   2:    tLabel            % <label#> - define label# at the current address
   2:    tLabelAlias       % <label#> <aliasToLabel#> - defines label to be an alias of another label
   2:    tLabelExtern      % <label#> <offsetToStrLit> - defines label to mean an extern symbol, whose name is in global data
   2:    tWriteI           % for writeln : write integer on tos, pop
   2:    tWriteBool        %  "     "    : write TRUE/FALSE, pop
   2:    tWriteChar        %  "     "    : write char, pop
   2:    tWriteShortStr    %  "     "    : write ShortString whose addr is on tos, pop
   2:    tWritePChar       %  "     "    : write a null-terminated string whose addr is on tos, pop
   2:    tWriteP           %  "     "    : write ptr var whose addr is on tos, pop
   2:    tWriteEnum        %  "     "    : write enum name.  Name table on tos, value under it, pop both
   2:    tWriteCR          %  "     "    : write cr
      
      %  Other:
      
   2:    tSpace            % emit a hole, to be patched later
   2:    ;
      
   2: error:
   2:    eBadStatement
   2:    eNotConst
   2:    eNotType
   2:    eNotOrdinalType
   2:    eNotVar
   2:    eNotIntVar
   2:    eNotValue
   2:    eNotInteger
   2:    eNotBoolean
   2:    eNotPointer
   2:    eNotArray
   2:    eNotRecord
   2:    eNotRecordField
   2:    eTooManySubscripts
   2:    eTypeMismatch
   2:    eMissingParameter
   2:    eNotImplemented
   2:    eNotAllowed
   2:    eNotInALoop
   2:    eRecordEmpty
   2:    eNotCurrentFunction
   2:    eAlreadyDefined
   2:    eOnlyOneVarCanBeInitialized
   2:    eExternalMethodCannotBeNested
   2:    eCantFindUnitFile
   2:    eInternalScopeMismatch
   2:    eEnumValueNotAscending
   2:    eUsedButNotDefined
   2:    eCantUsePredSuccOnEnumWithValueGaps
   2:    eCantDereference
   2:    ;
      
   2: include 'pascal_schema.ssl'
      
      % Generated automatically by schema
      
   2: type node_type:
   2: 	nINVALID
   2: 	Object
   2: 	nWorkspace
   2: 	nModule
   2: 	nProgram
   2: 	nUnit
   2: 	nUnitImpl
   2: 	nScope
   2: 	nDeclaration
   2: 	nIdent
   2: 	nUnitRef
   2: 	nMethod
   2: 	nProc
   2: 	nFunc
   2: 	nBuiltInFunc
   2: 	nBuiltInProc
   2: 	nConst
   2: 	nEnumValue
   2: 	nTypeDecl
   2: 	nVar
   2: 	nGlobalVar
   2: 	nLocalVar
   2: 	nRecordField
   2: 	nParam
   2: 	nTypedConst
   2: 	nLabel
   2: 	nType
   2: 	nFileType
   2: 	nIntegerType
   2: 	nByteType
   2: 	nBooleanType
   2: 	nBooleanCFType
   2: 	nCharType
   2: 	nPointerType
   2: 	nUniversalPointerType
   2: 	nArrayType
   2: 	nSubrangeType
   2: 	nRecordType
   2: 	nStrLitType
   2: 	nShortStringType
   2: 	nEnumType
   2: 	nSetType
   2: 	;
      
   2: type node_attribute:
   2: 	qINVALID
   2: 	qUnits
   2: 	qProgram
   2: 	qGlobalSize
   2: 	qIdent
   2: 	qUsedUnits
   2: 	qChildScope
   2: 	qMainRoutineScope
   2: 	qImpl
   2: 	qPublicScope
   2: 	qPrivateScope
   2: 	qInitLabel
   2: 	qFinalLabel
   2: 	qInitRoutineScope
   2: 	qLevel
   2: 	qDecls
   2: 	qExtends
   2: 	qSize
   2: 	qAllocMode
   2: 	qInitCode
   2: 	qParentScope
   2: 	qType
   2: 	qValue
   2: 	qParams
   2: 	qBodyDefined
   2: 	qExternal
   2: 	qExternalName
   2: 	qCdecl
   2: 	qUsed
   2: 	qOldParams
   2: 	qOldType
   2: 	qResultOffset
   2: 	qNameOffset
   2: 	qInOut
   2: 	qDefined
   2: 	qPointerType
   2: 	qBaseType
   2: 	qIndexType
   2: 	qLow
   2: 	qHigh
   2: 	qScope
   2: 	qCapacity
   2: 	qNameTable
   2: 	qHasGap
   2: 	;
      
      
   2: type Node:     % A pointer to a node in the schema database (symbol database)
   2:    Null = 0
   2:    ;
      
   2: type NodeIter:   % An iterator over nodes in a list, in the schema database
   2:    NullIter = 0
   2:    ;
      
   2: type NodeVec:  % A pointer to a vector of Node.  See mechanism node_vec_mech
   2:    NullVec = 0
   2:    ;
      
   2: type boolean:
   2:    false    = 0
   2:    true     = 1;
      
      % intrinsic types & type constructs
      
   2: type typ:
   2:    tyNone     = 0    % in ptrTyp field of TT, means no ptr to type defined
   2:    tyInteger
   2:    tyBoolean
   2:    tyChar
   2:    tyString
   2:    tyFile            % tyInteger..tyFile are scalars (types on their own)
   2:    tyPointer         % following are type constructor classes...
   2:    tyArray           %   (they are not type#'s)
   2:    tyRecord
   2:    tyParams          % like record; a collection of proc/func params
   2:    tySet;
      
   2: type Label:
   2:    labelNull = 0;
      
      % An output code stream.
   2: type Code:
   2:    codeNull = 0
   2:    codeDefault = 1
   2:    ;
      
      % A string
   2: type String:
   2:    stringNull = 0
   2:    ;
      
      % allocation modes for oScopeBegin
   2: type AllocMode:
   2:    allocGlobal = 0  % allocate from global data
   2:    allocDown        % allocate down the stack
   2:    allocUp          % allocate up the stack
   2:    ;
      
      % Some general schema node operations.
      % node_type and node_attribute are defined in generated file pascal_schema.ssl included above.
      %
   2: mechanism node_mech:
   2:     oNodeNew (node_type) >> Node         % create new node
   2:     oNodeSet (Node, node_attribute, Node)   % set Node attribute of node
   2:     oNodeSetString (Node, node_attribute, String)
   2:     oNodeSetInt (Node, node_attribute, int) % set int attribute of node
   2:     oNodeSetBoolean (Node, node_attribute, boolean)
   2:     oNodeSetLabel( Node, node_attribute, Label )  % set Label attribute of node
   2:     oNodeSetCode( Node, node_attribute, Code )    % set Code attribute of node
   2:     oNodeAddLast( Node, node_attribute, Node value )  % append to a List attribute of node
   2:     oNodeGet (Node, node_attribute) >> Node    % get Node attribute of node
   2:     oNodeGetString (Node, node_attribute) >> String
   2:     oNodeGetInt (Node, node_attribute) >> int  % get int attribute of node
   2:     oNodeGetBoolean (Node, node_attribute) >> boolean  % get int attribute of node
   2:     oNodeGetLabel (Node, node_attribute) >> Label      % get Label attribute of node
   2:     oNodeGetCode (Node, node_attribute) >> Code        % get code stream attribute of node
   2:     oNodeNull (Node) >> boolean          % is node null?
   2:     oNodeFind (Node, node_attribute listAttr, node_attribute valueAttr, int value) >> Node  % find node with value in list
   2:     oNodeGetIter (Node, node_attribute) >> NodeIter   % get an iterator over nodes in a List attribute
   2:     oNodeGetIterLast (Node, node_attribute) >> NodeIter  % get an iterator over nodes in a List, starting at last
   2:     oNodeIterValue (NodeIter) >> Node             % the node that iter is referring to (NodeNull if no more nodes)
   2:     oNodeIterNext (inout NodeIter)                % advance iterator through list
   2:     oNodeIterPrev (inout NodeIter)                % advance iterator backwards through list
   2:     oNodeType (Node) >> node_type        % return node type of node
   2:     oNodeEqual (Node, Node) >> boolean   % compare two nodes for equality
                                               % (i.e. same node, not just same contents)
   2:     ;
      
      
      % Manipulate a temporary vector of Node
      %
   2: mechanism node_vec_mech:
   2:     oNodeVecNew >> NodeVec
   2:     oNodeVecDelete( NodeVec nv )
   2:     oNodeVecAppend( NodeVec nv, Node n )
   2:     oNodeVecSize( NodeVec nv ) >> int                % how many elements
   2:     oNodeVecElement( NodeVec nv, int idx ) >> Node   % element at index idx (0..size-1)
   2:     ;
      
      
      
   2: mechanism emit_mech:
   2:     oEmitInt( int )              % emit int into the generated code
   2:     oEmitLabel( Label )
   2:     oEmitCode( Code )            % append a code stream to the current code stream
   2:     Here >> int                  % current address in the generated code
                                       %   (only usable in the default code stream)
   2:     oPatch( int addr, int val )  % patch an int into address in the generated code
                                       %   (only usable in the default code stream)
   2:     ;
      
   2: mechanism math:
   2:     inc (inout int)
   2:     dec (inout int)
   2:     negate (int) >> int
   2:     add( int x, int y ) >> int
   2:     subtract( int x, int y ) >> int     % x - y
   2:     multiply( int x, int y ) >> int     % x * y
   2:     equal( int x, int y ) >> boolean
   2:     equal_zero (int) >> boolean
   2:     equal_node( Node, Node ) >> boolean
   2:     equal_string( String, String ) >> boolean
   2:     equal_node_type (node_type, node_type) >> boolean     % Want equal_<type> for every type
   2:     equal_label( Label, Label ) >> boolean
   2:     equal_code( Code, Code ) >> boolean
   2:     greater( int x, int y ) >> boolean
   2:     oMININT >> int    % the minimum 32-bit integer.
   2:     oMAXINT >> int    % the maximum 32-bit integer.
   2:     ;
      
   2: mechanism more_builtins:      % These should be built-in SSL operations
   2:     TOKEN_VALUE >> int        % value of just accepted token, e.g. IntLit token
   2:     LAST_ID >> int            % id number of last accepted identifier
   2:     ID_STRING( int id ) >> String       % text name of identifier with given id
   2:     CURRENT_STRLIT >> String            % text value of just-accepted string literal
   2:     ;
      
   2: mechanism workspace_mech:
   2:     oWorkspaceNew >> Node
   2:     ;
      
   2: mechanism scope_mech:
   2:     oScopeBegin( int level, AllocMode )  % create a new scope. Subsequent declarations will go here.
                                               %  level = static scope depth (0 = globals)
   2:     oScopeEnter( Node scope )            % enter an existing scope.
   2:     oScopeEnd                            % end current scope. Subsequent declarations will go to previous scope.
   2:     oScopeCurrent >> Node                % returns current scope
   2:     oScopeDeclare( Node decl )           % add declaration to current scope.
   2:     oScopeDeclareAlloc( Node decl )      % add declaration to current scope, and allocate space according to its type
   2:     oScopeAllocType( Node theType ) >> int   % allocate space for type in current scope, and return its address
   2:     oScopeAlloc( int size, int align ) >> int % allocate bytes, with given alignment in bytes 
   2:     oScopeFind >> Node                   % find declaration of last accepted identifier.  Returns Null if not found.
   2:     oScopeFindRequire >> Node            % find declaration of last accepted identifier.  Error if not found.
   2:     oScopeFindInCurrentScope >> Node     % find declaration of last accepted identifier, only within the current scope.  Null if not found.
   2:     oScopeFindRequireInScope( Node scope ) >> Node  % find decl of last accepted identifier, only within the given scope.  Error it not found.
   2:     ;
      
   2: mechanism type_mech:
   2:     oTypeAdd( Node node )     % add the given nType to the type table
   2:     ;
      
   2: mechanism type_stack_mech:
   2:     oTypeSPush( Node node )
   2:     oTypeSPop
   2:     oTypeSTop >> Node
   2:     oTypeSNodeType >> node_type          % node_type of the node on top of type stack, skipping subranges
   2:     ;
      
      
   2: mechanism id_mech:
          % adds a predefined id to the scanner's id table, and returns the id code
   2:     oIdAdd_mysystem >> int
   2:     oIdAdd_File >> int
   2:     oIdAdd_Integer >> int
   2:     oIdAdd_Boolean >> int
   2:     oIdAdd_Char >> int
   2:     oIdAdd_Byte >> int
   2:     oIdAdd_Pointer >> int
   2:     oIdAdd_ShortString >> int
   2:     oIdAdd_True >> int
   2:     oIdAdd_False >> int
   2:     oIdAdd_Ord >> int
   2:     oIdAdd_Chr >> int
   2:     oIdAdd_Pred >> int
   2:     oIdAdd_Succ >> int
   2:     oChangeIntLitToLabelIdent    % change current token from pIntLit to pIdent "_label_<intlit>"
   2:     ;
      
      
      
   2: mechanism label_mech:
   2:    oLabelNew >> Label
   2:    ;
      
   2: mechanism code_mech:
   2:    oCodeNew >> Code         % create a new empty code stream
   2:    oCodePush( Code )        % change the current output code stream to the given one
   2:    oCodePop                 % restore the current code stream to the previous one
   2:    ;
      
   2: mechanism include_mech:
   2:    oIncludeUnitFile( int id ) >> boolean  % search for <unit>.pas and include it.
                                                % returns false if can't find.
   2:    oIncludeEnd              % stop including the current file
   2:    ;
      
      
   2: mechanism count :
   2:    oCountPush(int)          % start a new counter, with initial value
   2:    oCountInc
   2:    oCountDec
   2:    oCountIsZero >> boolean
   2:    oCountPop;
      
      
   2: mechanism value :              % value stack, to calc. const expr's
   2:    oValuePush(int)             % push an explicit int lit
   2:    oValueNegate                % negate top value
   2:    oValueTop >> int            % get top value on value stack
   2:    oValuePop;
      
   2: mechanism string :
   2:    oStringAllocLit( String ) >> int      % alloc global space for strlit, return address
   2:    oStringAllocShortStringLit( String ) >> int  % alloc global space for ShortString, return address
   2:    ;
      
      % track labels for the loop we're in, if any
   2: mechanism loop_mech:
   2:    oLoopPush( Label continueLabel, Label breakLabel )
   2:    oLoopContinueLabel >> Label
   2:    oLoopBreakLabel >> Label
   2:    oLoopPop
   2:    ;
      
      % for hacky debugging
   2: mechanism msg_mech:
   2:    oMsg( int num )             % print message "oMsg <num>"
   2:    oMsgTrace( int num )        % print message "oMsg <num>" followed by ssl traceback
   2:    oMsgNode( Node node )       % print node
   2:    oMsgNodeLong( Node node )   % print node with more detail
   2:    oMsgNodeVec( NodeVec vec )  % print node vec
   2:    ;
      
      
   2: rules
      
      % ----------------------------- Global Variables ----------------------------
      
   2: Node    workspace              % root of database
   2: Node    globalScope            % scope for globals in the current module
   2: Node    initScope              % scope for temporaries global var init,
                                     % and program main stmt / unit initialization stmts
      
   2: int     mysystemId               % id of identifier "mysystem"
      
      % built-in nTypes
   2: Node    FileType
   2: Node    IntegerType
   2: Node    BooleanType
   2: Node    BooleanCFType
   2: Node    CharType
   2: Node    PCharType
   2: Node    ByteType
   2: Node    UniversalPointerType
   2: Node    StrLitType
   2: Node    ShortStringType
      
      % nBuiltInFunc
   2: Node    BuiltIn_Ord
   2: Node    BuiltIn_Chr
   2: Node    BuiltIn_Pred
   2: Node    BuiltIn_Succ
      
      
      % -------------------------- Forward Declarations -------------------------
      
   2: Block( node_type varNodeType, Label labelForBody );
   2: BlockDecls( node_type varNodeType );
   2: BlockStmt( Label labelForBody, Node varScope, boolean isMain );
   2: VarDecl( node_type varNodeType );
   2: newType( node_type nt, int size ) >> Node;
   2: newIdent( node_type nt, int id ) >> Node;
   2: EmitValue( Node decl );
   2: TypeRef( out Node theType );
   2: EnumTypeRef( out Node resultType );
   2: PointerTypeTo( Node theType ) >> Node;
   2: OrdinalLow( Node theType ) >> int;
   2: OrdinalHigh( Node theType ) >> int;
   2: AssignStmt( Node decl );
   2: BooleanExprControlFlow( out Label falseLabel );
   2: ExprAllowCF( out Label falseLabel );
   2: BoolExprAllowCF( out Label falseLabel );
   2: BoolTermAllowCF( out Label falseLabel );
   2: BoolFactorAllowCF( out Label falseLabel );
   2: ArithExprAllowCF( out Label falseLabel );
   2: TermAllowCF( out Label falseLabel );
   2: FactorAllowCF( out Label falseLabel );
   2: PrimaryAllowCF( out Label falseLabel );
      
   2: VarExpr( Node decl );
   2: LValueVar( Node decl, boolean writeable );
   2: IncVar( Node decl );
   2: DecVar( Node decl );
      
   2: CFToVal( inout Label falseLabel );
   2: ValToCF( out Label falseLabel );
      
   2: DeclLevel( Node decl ) >> int;
   2: DeclUpLevels( Node decl ) >> int;
      
      % ----------------------------- Declarations ----------------------------
      
   2: Program:
   4:    Node t
      
   4:    workspace = oWorkspaceNew
      
         % root scope is used for builtins e.g. Integer,
         % and is a parent to any used units, and the program's own global scope.
   9:    oScopeBegin( 0, allocGlobal )
  18:    Node rootScope = oScopeCurrent
      
  23:    @installBuiltIns
      
         % Start by calling the main program routine.
      
         % This dummy call to main needs to look like a normal method itself,
         % so jit can align the stack properly.  So we need .tEnter,
         % and .tAllocActuals / .tFreeActuals.
  25:    .tEnter  oEmitInt( 0 )
  33:    Label mainLabel = oLabelNew
      
  38:    .tAllocActuals  oEmitInt( 0 )
  46:    .tCall  oEmitLabel( mainLabel )
  54:    .tFreeActuals  oEmitInt( 0 )
  62:    .tReturn
      
  64:    pProgram
  66:    pIdent
      
  68:    Node program = oNodeNew( nProgram )
  78:    oNodeSetInt( program, qIdent, LAST_ID )
  89:    oNodeSet( workspace, qProgram, program )
      
      
 101:    [
 101:       | '(' :
 103:          pIdent      % input, output files
      
 105:          t = @newIdent( nVar, LAST_ID )
 118:          oNodeSet( t, qType, FileType )
 130:          oScopeDeclareAlloc( t )
               % TO DO: I shouldn't declare the files in root scope.
               %        Should save them for program's global scope.
      
 136:          ','
 138:          pIdent
      
 140:          t = @newIdent( nVar, LAST_ID )
 153:          oNodeSet( t, qType, FileType )
 165:          oScopeDeclareAlloc( t )
      
 171:          ')'
 173:       | * :
 178:    ]
 178:    ';'
      
 180:    @UsesMySystem( program )
         % The uses clause may only appear once, immediately after the program declaration.
 187:    [
 187:       | pUses :  @UsesClause( program )
 196:       | * :
 201:    ]
 201:    @EnterUsedUnits( program )
      
         % Global scope for the program, below any used units.
 208:    oScopeBegin( 0, allocGlobal )
 217:    globalScope = oScopeCurrent
      
         % A new scope just for temporaries in the main routine
         % Create it up front, in case it's needed by variable initialization exprs.
         % But we won't stay in it here.
         % Note we say it extends the global scope, so that during main statement evaluation
         % any user labels declared in the global scope are considered to be part of the current scope.
 222:    oScopeBegin( 0, allocDown )
 231:    oNodeSet( oScopeCurrent, qExtends, globalScope )
 242:    initScope = oScopeCurrent
 247:    oNodeSet( program, qMainRoutineScope, initScope )
 259:    oScopeEnd
      
 260:    @BlockDecls( nGlobalVar )
      
      
 267:    oScopeEnter( initScope )
      
         % The block statement includes a stack frame, and enter/return,
         % even for the main routine.
         % That will be necessary for temporaries allocated in the main routine.
      
         % isMain means we'll generate calls to the unit init/final methods in here too.
         % Alternatively we could do that in a higher level method that calls main.
 273:    boolean isMain = true
 279:    @BlockStmt( mainLabel, globalScope, isMain )
      
 292:    oScopeEnd   % main routine scope
      
 293:    '.'
 295:    @CheckForUndefinedLabels
 297:    oScopeEnd   % global scope
 298:    @EndUsedUnits( program )   % used units scopes
 306:    ;
      
      
      % The uses clause is a list of units required by the user program or unit.
      % We will find and compile the named units (unless already loaded).
      % We do not make the unit interface visible to the user, the caller will do so later.
 306: UsesClause( Node user ):
 308:    {
 308:       pIdent
 310:       @Uses( LAST_ID, user )
 319:       [
 319:          | ',' :
 321:          | * :  >
 328:       ]
 328:    }   
 330:    ';'
 333:    ;
      
      
      % Process an implicit "uses mysystem" in every module, except in the mysystem unit itself.
      % (I'm calling the unit mysystem rather than system, so fpc doesn't use it to replace its own system unit.)
      %
 333: UsesMySystem( Node user ):
 335:    [ equal( oNodeGetInt( user, qIdent ), mysystemId )
 352:       | true :  >>
 354:       | * :
 359:    ]
 359:    @Uses( mysystemId, user )
 370:    ;
      
      
      % The given user module uses a unit with the given id,
      % which may or may not have been loaded already.
      %
 370: Uses( int id, Node user ):
 372:    Node unit = @FindOrCompileUnit( id )
 383:    [ equal_node( unit, Null )
 393:       | false :
 394:          oNodeAddLast( user, qUsedUnits, unit )
      
               % Put a declaration in the current scope, naming the unit and pointing to it.
               % This is to allow references to  <unit>.<identifier_in_unit>
 406:          Node unitRef = oNodeNew( nUnitRef )
 416:          oNodeSetInt( unitRef, qIdent, oNodeGetInt( unit, qIdent ) )
 435:          oNodeSet( unitRef, qPublicScope, oNodeGet( unit, qPublicScope ) )
 454:          oScopeDeclare( unitRef )
 460:       | * :
 465:    ];
      
      
      % If the given decl is for an nUnitRef, the program is using syntax <unit>.<identifier>
      % Parse the rest of that to find the intended decl.
      %
 466: ResolveUnitRef( inout Node decl ):
 468:    [ oNodeType( decl )
 475:       | nUnitRef :
 476:          Node scope = oNodeGet( decl, qPublicScope )
 489:          '.'
 491:          pIdent
 493:          decl = oScopeFindRequireInScope( scope )
 503:       | * :
 508:    ];
      
      
 509: EnterUsedUnits( Node user ):
         % Make the used units' public scopes directly visible.
         % This is done after the units are all compiled, so they don't interfere with each other incorrectly.
         % Units later in the list have priority.
 511:    NodeIter unitIt = oNodeGetIter( user, qUsedUnits )
 524:    {
 524:       Node unit = oNodeIterValue( unitIt )
 534:       [ oNodeNull( unit )
 541:          | false :
 542:             oScopeEnter( oNodeGet( unit, qPublicScope ) )
 555:          | * :
 560:             >
 562:       ]
 562:       oNodeIterNext( unitIt )
 568:    }
 571:    ;
      
 571: EndUsedUnits( Node user ):
         % Leave the units' public scopes, so no longer visible.
 573:    NodeIter unitIt = oNodeGetIterLast( user, qUsedUnits )
 586:    {
 586:       Node unit = oNodeIterValue( unitIt )
 596:       [ oNodeNull( unit )
 603:          | false :
                  % Consistency check.  Make sure our scope enter / end have lined up correctly.
 604:             [ oNodeEqual( oScopeCurrent, oNodeGet( unit, qPublicScope ) )
 620:                | true :
 621:                | false :  #eInternalScopeMismatch
 625:             ]
 633:             oScopeEnd
 634:          | * :
 639:             >
 641:       ]
 641:       oNodeIterPrev( unitIt )
 647:    }
 650:    ;
      
      
 650: FindOrCompileUnit( int id ) >> Node:
         % We might have this unit loaded already
 652:    Node unit = oNodeFind( workspace, qUnits, qIdent, id )
 671:    [ equal_node( unit, Null )
 681:       | false :  >> unit
 685:       | * :
 690:    ]
      
         % If not, search for the source file on disk
 690:    boolean ok = oIncludeUnitFile( id )
 700:    [ ok
 703:       | false :  #eCantFindUnitFile  >> Null
 709:       | * :
 714:    ]
      
         % compile it, adding it into the workspace
         % then return it.
 714:    unit = @Unit
      
         % TO DO: ensure we are at pEof
         % end the include
 720:    oIncludeEnd
 721:    >> unit;
      
      
      
 725: Unit >> Node:
 727:    pUnit
 729:    pIdent
 731:    Node unit = oNodeNew( nUnit )
 741:    oNodeSetInt( unit, qIdent, LAST_ID )
 752:    Node unitImpl = oNodeNew( nUnitImpl )
 762:    oNodeSetInt( unitImpl, qIdent, LAST_ID )
 773:    oNodeSet( unit, qImpl, unitImpl )
 785:    ';'
      
         % mandatory sections
      
 787:    pInterface
 789:    @UsesMySystem( unit )
 796:    [
 796:       | pUses :   @UsesClause( unit )
 805:       | * :
 810:    ]
 810:    @EnterUsedUnits( unit )
      
 817:    oScopeBegin( 0, allocGlobal )
 826:    oNodeSet( unit, qPublicScope, oScopeCurrent )
 837:    globalScope = oScopeCurrent
      
         % A scope for temporaries needed by variable initialization
 842:    oScopeBegin( 0, allocDown )
 851:    initScope = oScopeCurrent
 856:    oNodeSet( unit, qInitRoutineScope, initScope )
 868:    oScopeEnd
      
 869:    @UnitInterface( unit )
 876:    oScopeEnd  % interface scope
      
 877:    pImplementation
 879:    @UsesMySystem( unitImpl )
 886:    [
 886:       | pUses :   @UsesClause( unitImpl )
 895:       | * :
 900:    ]
 900:    @EnterUsedUnits( unitImpl )
         % re-enter interface scope after impl's uses.  interface still has priority.
 907:    oScopeEnter( oNodeGet( unit, qPublicScope ) )
         
 920:    oScopeBegin( 0, allocGlobal )
 929:    oNodeSet( unit, qPrivateScope, oScopeCurrent )
 940:    oNodeSet( oScopeCurrent, qExtends, oNodeGet( unit, qPublicScope ) )
 958:    globalScope = oScopeCurrent
 963:    @UnitImplementation( unit )
      
 970:    [
 970:       | pInitialization :  @UnitInitialization( unit, true )   % init routine with statements from init section
 982:       | * :                @UnitInitialization( unit, false )  % implicit init routine
 997:    ]
 997:    [
 997:       | pFinalization :  @UnitFinalization( unit, true )
1009:       | * :              @UnitFinalization( unit, false )   % implicit final routine, may be handy later
1024:    ]
1024:    pEnd  '.'
      
1028:    oScopeEnd  % impl scope
1029:    oScopeEnd  % interface scope
1030:    @EndUsedUnits( unitImpl )  % used units scopes
1037:    @EndUsedUnits( unit )
1044:    oNodeAddLast( workspace, qUnits, unit )
1056:    >> unit;
      
      
1060: UnitInterface( Node unit ):
1062:    {[
1062:       | pConst :     @ConstDecl
1066:       | pType :      @TypeDecl
1070:       | pVar :       @VarDecl( nGlobalVar )
            % label declaration not allowed in interface
      
1079:       | pProcedure :
1081:          Node decl = @ProcHeaderDecl
               % despite syntax diagrams, fpc does allow external clause on methods in unit interface,
               % even though this clause is an alternative for the body statement.
1087:          [
1087:             | pExternal :
1089:                @ExternalDecl( decl )
1096:                ';'
1098:             | * :
1103:          ]
      
1103:       | pFunction :
1105:          Node decl = @FuncHeaderDecl
1111:          [
1111:             | pExternal :
1113:                @ExternalDecl( decl )
1120:                ';'
1122:             | * :
1127:          ]
      
1127:       | * :          >
1142:    ]}
1145:    ;
      
1145: UnitImplementation( Node unit ):
1147:    @BlockDecls( nGlobalVar )
1155:    ;
      
      
1155: UnitInitialization( Node unit, boolean hasStmts ):
1157:    Label label = oLabelNew
1162:    .tLabel  oEmitLabel( label )
1170:    oNodeSetLabel( unit, qInitLabel, label )
      
1182:    int patchLS
1182:    .tEnter  patchLS = Here  .tSpace
      
         % insert any code for initialization of this unit's variables.
         
1191:    Node scope
1191:    Code initCode
      
1191:    scope = oNodeGet( unit, qPublicScope )
1204:    initCode = oNodeGetCode( scope, qInitCode )
1217:    oEmitCode( initCode )
1223:    oNodeSetCode( scope, qInitCode, codeNull )
      
1235:    scope = oNodeGet( unit, qPrivateScope )
1248:    initCode = oNodeGetCode( scope, qInitCode )
1261:    oEmitCode( initCode )
1267:    oNodeSetCode( scope, qInitCode, codeNull )
      
1279:    oScopeEnter( oNodeGet( unit, qInitRoutineScope ) )
      
1292:    [ hasStmts
1295:       | true :     
1296:          @Statement
1298:          {[
1298:             | ';' :  @Statement
1302:             | * :    >
1309:          ]}
1311:       | * :
1316:    ]
      
1316:    .tReturn
      
1318:    int localSpace = oNodeGetInt( oScopeCurrent, qSize )
1330:    oPatch( patchLS, localSpace )
1339:    oScopeEnd   % init routine scope, for temporaries
1341:    ;
      
      
1341: UnitFinalization( Node unit, boolean hasStmts ):
1343:    Label label = oLabelNew
1348:    .tLabel  oEmitLabel( label )
1356:    oNodeSetLabel( unit, qFinalLabel, label )
      
1368:    int patchLS
1368:    .tEnter  patchLS = Here  .tSpace
      
         % final routine scope, for temporaries
1377:    oScopeBegin( 0, allocDown )
      
1386:    [ hasStmts
1389:       | true :     
1390:          @Statement
1392:          {[
1392:             | ';' :  @Statement
1396:             | * :    >
1403:          ]}
1405:       | * :
1410:    ]
      
1410:    .tReturn
      
1412:    int localSpace = oNodeGetInt( oScopeCurrent, qSize )
1424:    oPatch( patchLS, localSpace )
1433:    oScopeEnd   % final routine scope, for temporaries
1435:    ;
      
      
1435: Block( node_type varNodeType, Label labelForBody ):
1437:    @BlockDecls( varNodeType )
1444:    @BlockStmt( labelForBody, oScopeCurrent, false )
1456:    @CheckForUndefinedLabels
1459:    ;
      
      
1459: BlockDecls( node_type varNodeType ):
1461:    {[
1461:       | pConst :     @ConstDecl
1465:       | pType :      @TypeDecl
1469:       | pVar :       @VarDecl( varNodeType )
1478:       | pLabel :     @LabelDecl
1482:       | pProcedure : @ProcDecl
1486:       | pFunction :  @FuncDecl
1490:       | * :          >
1507:    ]}
1509:    @CheckForUndefinedMethods
1512:    ;
      
      
      % were there any procedures or functions declared in this scope
      % that were never defined?
1512: CheckForUndefinedMethods:
         % TO DO
         % Note: disregard methods marked external
1515:    ;
      
      % were there any labels declared in the current scope, and used,
      % but never defined (as the prefix of a stement)?
      %
1515: CheckForUndefinedLabels:
1517:    NodeIter it = oNodeGetIter( oScopeCurrent, qDecls )
1529:    {
1529:       Node decl = oNodeIterValue( it )
1539:       [ oNodeNull( decl )
1546:          | false :
1547:          | * :  >
1554:       ]
1554:       [ oNodeType( decl )
1561:          | nLabel :
1562:             [ oNodeGetBoolean( decl, qDefined )
1572:                | false :
1573:                   [ oNodeGetBoolean( decl, qUsed )
1583:                      | true :    #eUsedButNotDefined  % TO DO: give the decl in the message
1586:                      | * :
1591:                   ]
1591:                | * :
1596:             ]
1596:          | * :
1601:       ]
1601:       oNodeIterNext( it )
1607:    }
1610:    ;
      
      
1610: InitializeUnits:
         % call init routine of each loaded unit, in the order they were loaded
         % (used directly or indirectly by the main program).
1612:    NodeIter it = oNodeGetIter( workspace, qUnits )
1625:    {
1625:       Node unit = oNodeIterValue( it )
1635:       [ oNodeNull( unit )
1642:          | true :  >
1645:          | false :
1647:             .tAllocActuals  oEmitInt( 0 )  % not sure I need this. maybe for stack alignment.
1655:             .tCall  oEmitLabel( oNodeGetLabel( unit, qInitLabel ) )
1670:             .tFreeActuals  oEmitInt( 0 )
1678:             oNodeIterNext( it )
1684:       ]
1692:    };
      
      
1695: FinalizeUnits:
1697:    NodeIter it = oNodeGetIterLast( workspace, qUnits )
1710:    {
1710:       Node unit = oNodeIterValue( it )
1720:       [ oNodeNull( unit )
1727:          | true :  >
1730:          | false :
1732:             .tAllocActuals  oEmitInt( 0 )  % not sure I need this. maybe for stack alignment.
1740:             .tCall  oEmitLabel( oNodeGetLabel( unit, qFinalLabel ) )
1755:             .tFreeActuals  oEmitInt( 0 )
1763:             oNodeIterPrev( it )
1769:       ]
1777:    };
      
      
      % Given the scope of vars in this block.
      % Usually it's the current scope, but it's a bit different for the main statement.
      %
1780: BlockStmt( Label labelForBody, Node varScope, boolean isMain ):
1782:    .tLabel  oEmitLabel( labelForBody )
      
         % Proc, func, and main routine all start with tEnter
         % to create a stack frame.  This will be used for temporaries
         % (and local vars in the case of proc, func).
      
1790:    int patchLS
1790:    .tEnter  patchLS = Here  .tSpace
      
         % If we're generating the program main method,
         % add in calls to the loaded units' initialization and finalization.
1799:    [ isMain
1802:       | true :  @InitializeUnits
1805:       | * :
1810:    ]
      
         % insert any code for initialization of this scope's variables
1810:    Code initCode = oNodeGetCode( varScope, qInitCode )
1823:    oEmitCode( initCode )
1829:    oNodeSetCode( varScope, qInitCode, codeNull )
      
1841:    @Statement
      
1843:    [ isMain
1846:       | true :  @FinalizeUnits
1849:       | * :
1854:    ]
      
1854:    .tReturn
      
1856:    int localSpace = oNodeGetInt( oScopeCurrent, qSize )
1868:    oPatch( patchLS, localSpace )
1878:    ;
      
      
      % modifers that may appear on a proc/function declaration.
      %
1878: MethodModifiers( Node decl ):
1880:    {[
1880:       | pCdecl :
1882:          oNodeSetBoolean( decl, qCdecl, true )
1894:          ';'
      
1896:       | * : >
1903:    ]}
1906:    ;
      
      
      % We need an initCode code stream for the given scope.
      % Create it if not present yet.  Return it.
      % (This will be used for variable initialization.)
      %
1906: GetOrCreateInitCode( Node scope ) >> Code:
1908:    Code initCode = oNodeGetCode( scope, qInitCode )
1921:    [ equal_code( initCode, codeNull )
1931:       | true :
1932:          initCode = oCodeNew
1937:          oNodeSetCode( scope, qInitCode, initCode )
1949:       | * :
1954:    ]
1954:    >> initCode;
      
      
      % external method resides in an external object file
      % (or in my system, the built-in runtime library).
      % The method has a label, as usual, which callers will use.
      % But we define that label with .tLabelExtern rather than .tLabel.
      %
      % Note, I'll hold off on issuing the .tLabelExtern until we see that
      % the external method is actually called.  Otherwise we'd fill each output file
      % with all the external method names in my included libraries, which seems dumb.
      %
      % Note this is fpc syntax.  I'm not sure about other Pascals.
      %
1958: ExternalDecl( Node decl ):
1960:    [ equal_zero( @DeclLevel( decl ) )
1972:       | false :  #eExternalMethodCannotBeNested
1975:       | * :
1980:    ]
1980:    oNodeSetBoolean( decl, qExternal, true )
1992:    [
1992:       | pStrLit :
               % that was the optional library name containing the method.
               % TO DO: I'm currently ignoring this.
1994:          [
1994:             | pName :
1996:                pStrLit
                     % that was the optional method name defined in that library,
                     % which might differ from the Pascal name.
1998:                oNodeSetString( decl, qExternalName, CURRENT_STRLIT )
2009:             | * :
2014:          ]
2014:       | * :
2019:    ]
2020:    ;
      
      
2020: ProcHeaderDecl >> Node:
2022:    pIdent
      
         % If we already have a forward declaration, we'll modify that decl
         % instead of creating a second symbol table entry.
         % (Alternatively could delete or hide the old entry.)
2024:    boolean redeclaring = false
2030:    Node decl = oScopeFindInCurrentScope
      
2035:    [ oNodeNull( decl )
2042:       | true :
               % first declaration
2043:          decl = @newIdent( nProc, LAST_ID )
2056:          oNodeSetLabel( decl, qValue, oLabelNew )
      
2067:       | false :
               % we already have a declaration.
               % Keep it, and its label.
2069:          redeclaring = true
2075:          [ oNodeGetBoolean( decl, qBodyDefined )
2085:             | true : #eAlreadyDefined
2088:             | * :
2093:          ]
2093:          [ oNodeGetBoolean( decl, qExternal )
2103:             | true : #eAlreadyDefined
2106:             | * :
2111:          ]
2111:          [ oNodeType( decl )
2118:             | nProc :
2119:             | * : #eAlreadyDefined   % wrong kind
2126:          ]
               % Move the existing param scope aside, so we can check that the
               % new one is consistent.  And, the body will want to see the new one
               % since the names might differ.
               % TO DO: If qOldParams already set, we have multiple forward decls,
               % which I believe is supposed to be an error.
2126:          oNodeSet( decl, qOldParams, oNodeGet( decl, qParams ) )
2145:          oNodeSet( decl, qParams, Null )
2157:    ]
      
2165:    int level = @ScopeLevel
2171:    boolean nested = greater( level, 0 )
2184:    inc( level )
2190:    oScopeBegin( level, allocUp )
2199:    Node paramScope = oScopeCurrent
      
         % A nested method has a hidden first param for the parent static scope.
         % This won't appear in the param decls list, just reserve space for it.
         % It's first so the static chain is always at a fixed offset from the frame pointer.
2204:    [ nested
2207:       | true :
2208:          int offset = oScopeAllocType( @PointerTypeTo( IntegerType ) )   % arbitrary ptr type
2223:       | * :
2228:    ]
      
2228:    @FormalArgDecl
2230:    oNodeSet( decl, qParams, paramScope )
2242:    oScopeEnd
2243:    ';'
      
2245:    [ redeclaring
2248:       | false : oScopeDeclare( decl )
2255:       | true :  % TO DO: check that qParams is consistent with qOldParams
2257:    ]
      
2265:    @MethodModifiers( decl )
2272:    >> decl;
      
      
2276: ProcDecl:
2278:    Node decl = @ProcHeaderDecl
      
         % Body may be a statement, "forward", "external".
         % Note, this syntax is based on FPC, and I'm not sure if other Pascals are similar.
         % FPC says that forward, external, cdecl, name, etc are not reserved words -
         % I think this means the user may declare other things with those names, but if so the
         % original meaning is lost.  I'll make them keywords for simplicity, for now
         % (just not too happy about "name").
      
2284:    [
2284:       | pForward :
               % Nothing to do.  We simply won't set qBodyDefined.
      
2286:       | pExternal : @ExternalDecl( decl )
      
2295:       | * :
               % Body statement
      
               % Enter the params scope again, so params are visible in body.
               % TO DO: Perhaps I could mark the scope read-only at this point.
2302:          Node paramScope = oNodeGet( decl, qParams )
2315:          oScopeEnter( paramScope )
      
               % Start scope for declarations within the proc
2321:          int level = oNodeGetInt( paramScope, qLevel )
2334:          oScopeBegin( level, allocDown )
2343:          oNodeSet( decl, qChildScope, oScopeCurrent )
      
2354:          Label label = oNodeGetLabel( decl, qValue )
2367:          @Block( nLocalVar, label )
2377:          oNodeSetBoolean( decl, qBodyDefined, true )
2389:          oScopeEnd
      
2390:          oScopeEnd  % paramScope
2391:    ]
2391:    ';';
      
      
      
2394: FuncHeaderDecl >> Node:
2396:    pIdent
      
         % If we already have a forward declaration, we'll modify that decl
         % instead of creating a second symbol table entry.
         % (Alternatively could delete or hide the old entry.)
2398:    boolean redeclaring = false
2404:    Node decl = oScopeFindInCurrentScope
      
2409:    [ oNodeNull( decl )
2416:       | true :
               % first declaration
2417:          decl = @newIdent( nFunc, LAST_ID )
2430:          oNodeSetLabel( decl, qValue, oLabelNew )
      
2441:       | false :
               % we already have a declaration.
               % Keep it, and its label.
2443:          redeclaring = true
2449:          [ oNodeGetBoolean( decl, qBodyDefined )
2459:             | true : #eAlreadyDefined
2462:             | * :
2467:          ]
2467:          [ oNodeType( decl )
2474:             | nFunc :
2475:             | * : #eAlreadyDefined   % wrong kind
2482:          ]
               % Move the existing param scope and return value aside,
               % so we can check that the new one is consistent.
               % And, the body will want to see the new one since the names might differ.
               % TO DO: If qOldParams already set, we have multiple forward decls,
               % which I believe is supposed to be an error.
2482:          oNodeSet( decl, qOldParams, oNodeGet( decl, qParams ) )
2501:          oNodeSet( decl, qParams, Null )
2513:          oNodeSet( decl, qOldType, oNodeGet( decl, qType ) )
2532:          oNodeSet( decl, qType, Null )
2544:    ]
      
2552:    int level = @ScopeLevel
2558:    boolean nested = greater( level, 0 )
2571:    inc( level )
2577:    oScopeBegin( level, allocUp )
2586:    Node paramScope = oScopeCurrent
      
         % A nested method has a hidden first param for the parent static scope.
         % This won't appear in the param decls list, just reserve space for it.
         % It's first so the static chain is always at a fixed offset from the frame pointer.
2591:    [ nested
2594:       | true :
2595:          int offset = oScopeAllocType( @PointerTypeTo( IntegerType ) )   % arbitrary ptr type
2610:       | * :
2615:    ]
      
2615:    @FormalArgDecl
2617:    oNodeSet( decl, qParams, paramScope )
      
2629:    ':'
      
2631:    Node theType
2631:    @TypeRef( theType )
2638:    oNodeSet( decl, qType, theType )
      
         % The function's param space gets an additional pointer,
         % which will point to a temporary in the caller's scope.
         % This pointer is essentially a VAR param, but I won't create an nParam for it.
      
2650:    Node ptrType = @PointerTypeTo( theType )
2661:    oNodeSetInt( decl, qResultOffset, oScopeAllocType( ptrType ) )
2677:    oScopeEnd
2678:    ';'
      
2680:    [ redeclaring
2683:       | false : oScopeDeclare( decl )
2690:       | true :  % TO DO: check that qParams is consistent with qOldParams
                      % and qType is consistent with qOldType
2692:    ]
      
2700:    @MethodModifiers( decl )
      
2707:    >> decl;
      
      
2711: FuncDecl:
2713:    Node decl = @FuncHeaderDecl
      
         % Body may be a statement, "forward", "external".
2719:    [
2719:       | pForward :
               % Nothing to do.  We simply won't set qBodyDefined.
      
2721:       | pExternal : @ExternalDecl( decl )
      
2730:       | * :
               % Body statement
      
               % Enter the params scope again, so params are visible in body.
               % TO DO: Perhaps I could mark the scope read-only at this point.
2737:          Node paramScope = oNodeGet( decl, qParams )
2750:          oScopeEnter( paramScope )
      
               % Start scope for declarations within the func
2756:          int level = oNodeGetInt( paramScope, qLevel )
2769:          oScopeBegin( level, allocDown )
2778:          oNodeSet( decl, qChildScope, oScopeCurrent )
      
2789:          Label label = oNodeGetLabel( decl, qValue )
2802:          @Block( nLocalVar, label )
2812:          oNodeSetBoolean( decl, qBodyDefined, true )
2824:          oScopeEnd
      
2825:          oScopeEnd  % paramScope
2826:    ]
2826:    ';';
      
      
2829: FormalArgDecl:
2831:    [
2831:       | '(' :
2833:          {
2833:             NodeVec decls = oNodeVecNew
2838:             Node decl
2838:             boolean isInOut = false
      
2844:             [
2844:                | pVar : isInOut = true
2852:                | * :
2857:             ]
      
2857:             {  pIdent
      
2859:                decl = @newIdent( nParam, LAST_ID )
2872:                oNodeSetBoolean( decl, qInOut, isInOut )
2884:                oNodeVecAppend( decls, decl )
      
2893:                [
2893:                   | ':' : >
2897:                   | ',' :
2899:                ]
2907:             }
      
2909:             Node theType
2909:             @TypeRef( theType )
      
                  % VAR param is declared with its given type, but allocated as a pointer.
2916:             Node allocType
2916:             [ isInOut
2919:                | true :   allocType = @PointerTypeTo( theType )
2931:                | * :      allocType = theType
2942:             ]
      
2942:             int i = 0
2948:             {[ equal( i, oNodeVecSize( decls ) )
2962:                | false :
2963:                   decl = oNodeVecElement( decls, i )
      
2976:                   oNodeSet( decl, qType, theType )
2988:                   oScopeDeclare( decl )
2994:                   oNodeSetInt( decl, qValue, oScopeAllocType( allocType ) )
3010:                   inc( i )
3016:                | * :
3021:                   >
3023:             ]}
      
3025:             oNodeVecDelete( decls )
      
3031:             [
3031:                | ')' : >
3035:                | ';' :
3037:             ]
3045:          }
3047:       | * :
3052:    ];
      
      
3053: ConstDecl:
3055:    {[
3055:       | pIdent :
3057:          [
3057:             | ':' :
3059:                @TypedConstDecl
3061:             | * :
3066:                @UntypedConstDecl
3068:          ]
3068:       | * :
3073:          >
3075:    ]};
      
      
      % Parse an untyped const declaration.
      % We've just accepted the identifier.
      %
3078: UntypedConstDecl:
3080:    Node decl = @newIdent( nConst, LAST_ID )
3093:    '='
      
3095:    @ConstExpr
         % TO DO: currently ConstExpr leaves int result on oValue stack
3097:    int val = oValueTop
3102:    oValuePop
3103:    oNodeSetInt( decl, qValue, val )
      
         % TO DO: different types.  Currently assumes int!
         % Untyped const decl is supposed to allow:
         %   ordinal types, set types, pointer types (but only Nil), real types, char, string.
3115:    oNodeSet( decl, qType, IntegerType )
      
3127:    oScopeDeclare( decl )
3133:    ';'
3136:    ;
      
      
      % Parse a typed const declaration.
      % We've just accepted the identifier and ':'
      %
3136: TypedConstDecl:
3138:    Node decl = @newIdent( nTypedConst, LAST_ID )
      
3151:    Node theType
3151:    @TypeRef( theType )
3158:    oNodeSet( decl, qType, theType )
      
         % TO DO: array and record consts are allocated in global memory,
         % with global offset stored as decl value.
         % Scalar consts are not allocated in memory, and their value is
         % stored directly as the decl value.
      
         % TO DO: skip subranges, similar to oTypeSNodeType.
3170:    [ oNodeType( theType )
3177:       | nBooleanType, nByteType, nCharType, nIntegerType, nEnumType:
               % Parse expression and store value in decl
3178:          '='
      
3180:          @ConstExpr
               % TO DO: currently ConstExpr leaves int result on oValue stack
3182:          int val = oValueTop
3187:          oValuePop
3188:          oNodeSetInt( decl, qValue, val )
3200:          oScopeDeclare( decl )
3206:          ';'
      
3208:       | nShortStringType, nFileType, nPointerType, nUniversalPointerType :
3210:          #eNotImplemented
      
3212:       | nArrayType, nRecordType :
               % Allocate global space, store address in decl.
               % Push into global scope init code stream (since we'll be issuing code
               % rather than creating static data, at the moment).
               % Parse expression and store in global memory.
3214:          oScopeEnter( globalScope )
3220:          int addr = oScopeAllocType( theType )
3230:          oScopeEnd
3231:          oCodePush( @GetOrCreateInitCode( globalScope ) )
3242:          oNodeSetInt( decl, qValue, addr )
3254:          '='
3256:          @TypedConstInit( theType, addr )
3266:          oCodePop
3267:          oScopeDeclare( decl )
3273:          ';'
3275:    ]
3302:    ;
      
      
      % Parse the initial value of a constant that's being stored in global memory.
      % (An array or record constant, and recursively all its elements.)
      % Given the type, and the address in global memory for the const value.
      % The caller has already pushed into the global init code stream.
      %
3302: TypedConstInit( Node theType, int addr ):
      
         % TO DO: skip subranges, similar to oTypeSNodeTYpe
3304:    [ oNodeType( theType )
3311:       | nArrayType :
3312:          Node baseType = oNodeGet( theType, qBaseType )
3325:          Node indexType = oNodeGet( theType, qIndexType )
3338:          int low = @OrdinalLow( indexType )
3349:          int high = @OrdinalHigh( indexType )
3360:          int elementSize = oNodeGetInt( baseType, qSize )
      
3373:          '('
               % Loop over elements
3375:          int i = low
3381:          {
3381:             @TypedConstInit( baseType, addr )
3391:             [ equal( i, high )
3401:                | true : >
3404:                | false :
3406:             ]
3414:             ','
3416:             addr = add( addr, elementSize )
3429:             inc( i )
3435:          }
3437:          ')'
      
3439:       | nRecordType :
3441:          '('
3443:          Node fieldScope = oNodeGet( theType, qScope )
               % Loop over zero or more named fields.  It's not necessary to name them all.
               % fpc says the names that are given should be in order, but I'm not requiring that.
               % Since this is global memory, uninitialized fields will be left as 0.
3456:          {
3456:             [
3456:                | pIdent :
3458:                | * :  >
3465:             ]
3465:             Node field = oScopeFindRequireInScope( fieldScope )
3475:             ':'
3477:             Node fieldType = oNodeGet( field, qType )
3490:             int fieldAddr = add( addr, oNodeGetInt( field, qValue ) )
3510:             @TypedConstInit( fieldType, fieldAddr )
3520:             [
3520:                | ';' :
3522:                | * :  >
3529:             ]
3529:          }
3531:          ')'
      
3533:       | nBooleanType, nByteType, nCharType:
3535:          .tPushAddrGlobal  oEmitInt( addr )
3543:          @ConstExpr
3545:          .tPushConstI  oEmitInt( oValueTop )
3552:          oValuePop
3553:          .tAssignB
      
3555:       | nIntegerType, nEnumType:
3557:          .tPushAddrGlobal  oEmitInt( addr )
3565:          @ConstExpr
3567:          .tPushConstI  oEmitInt( oValueTop )
3574:          oValuePop
3575:          .tAssignI
      
3577:       | nShortStringType, nFileType, nPointerType, nUniversalPointerType :
3579:          #eNotImplemented
3581:    ]
3608:    ;
      
      
3608: TypeDecl:
3610:    {[
3610:       | pIdent :
3612:          Node decl = @newIdent( nTypeDecl, LAST_ID )
3625:          '='
3627:          Node theType
3627:          @TypeRef( theType )
3634:          oNodeSet( decl, qType, theType )
3646:          oScopeDeclare( decl )
3652:          ';'
3654:       | * :
3659:          >
3661:    ]};
      
3664: VarDecl( node_type varNodeType ):
3666:    {[
3666:       | pIdent :
3668:          NodeVec decls = oNodeVecNew
3673:          Node decl
3673:          {
3673:             decl = @newIdent( varNodeType, LAST_ID )
3686:             oNodeVecAppend( decls, decl )
3695:             [
3695:                | ',' :
3697:                   pIdent
3699:                | * :
3704:                   >
3706:             ]
3706:          }
3708:          ':'
3710:          Node theType
3710:          @TypeRef( theType )
      
3717:          int i = 0
3723:          {[ equal( i, oNodeVecSize( decls ) )
3737:             | false :
3738:                decl = oNodeVecElement( decls, i )
3751:                oNodeSet( decl, qType, theType )
3763:                oScopeDeclareAlloc( decl )
3769:                inc( i )
3775:             | * :
3780:               >
3782:          ]}
      
               % optional initialization
3784:          [
3784:             | '=' :
3786:                [ oNodeVecSize( decls )
3793:                   | 1 :
3794:                   | * :  #eOnlyOneVarCanBeInitialized
3801:                ]
      
                     % we need an initCode stream for this scope
3801:                Code initCode = @GetOrCreateInitCode( oScopeCurrent )
3811:                oCodePush( initCode )
      
                     % currently the global level has two scopes:
                     % the one for declarations e.g. vars and methods,
                     % and a second one for temporaries needed by the main block stmt.
                     % During evaluation of the init expr, we need to be in the 2nd scope
                     % in case the expression requires temporaries
                     % (so the temporaries get allocated in the right scope).
                     % TO DO: Maybe I should make the global scope the special case, instead.
3817:                boolean changedScope = false
3823:                [ equal_zero( @ScopeLevel )
3830:                   | true : oScopeEnter( initScope )
3837:                            changedScope = true
3843:                   | * :
3848:                ]
                     % generate assignment in initCode stream
3848:                @LValueVar( decl, true )
3858:                @Expr
3860:                @CoerceType
3862:                @Assign
3864:                [ changedScope
3867:                   | true : oScopeEnd
3869:                   | * :
3874:                ]
3874:                oCodePop
                   
3875:             | * :
3880:          ]
      
3880:          oNodeVecDelete( decls )
3886:          ';'
3888:       | * :
3893:          >
3895:    ]};
      
      
      % Parse a list of label declarations.
      % We'll create a tcode label at declaration time, for each user label.
      % If the user label is an integer, we'll record it as _label_<int> in the decl.
      %
3898: LabelDecl:
3900:    {
3900:       Node decl
3900:       [
3900:          | pIdent :
3902:          | pIntLit :
                  % Replace token with identifier "_label_<intlit>"
3904:             oChangeIntLitToLabelIdent
3905:       ]
3913:       decl = @newIdent( nLabel, LAST_ID )
            % TO DO: ensure not already declared in this scope.
            %        Or maybe that can be part of oScopeDeclare.
3926:       Label label = oLabelNew
3931:       oNodeSetLabel( decl, qValue, label )
3943:       oScopeDeclare( decl )
3949:       [
3949:          | ',' :
3951:          | * :
3956:             >
3958:       ]
3958:    }
3960:    ';'
3963:    ;
      
      
      % Parse a type reference, returning the nType.
      % This will add types to the type table, as needed.
      %
      % Style question - at the moment I think callers look clearer if we use
      % an out param here, rather than a return value.
      %
3963: TypeRef( out Node resultType ):
3965:    [
3965:       | pIdent :           % previously named type (including intrinsics)
3967:          Node decl = oScopeFindRequire
3972:          @ResolveUnitRef( decl )
3979:          [ oNodeType( decl )
3986:             | nTypeDecl :
3987:                resultType = oNodeGet( decl, qType )
4000:             | * :
4005:                #eNotType
4007:                resultType = IntegerType
4013:          ]
         
4013:       | pArray :
4015:          '['
      
               % A multi-dimensional array is represented as a chain
               %    array [subrange1] of array [subrange2] of elementType
      
               % First, we build a vector of nArray's, each with one subrange as its index type,
               % but without setting the "of" type or size.
      
4017:          NodeVec dimensions = oNodeVecNew
      
4022:          {
                  % to do: probably should use general subrange parsing, incl minimal size value
                  %   In fact, supposed to parse ordinal_type here.  all ordinal types have a static low, high.
                  %   Not necessary to be a subrange.
      
4022:             Node subrange = oNodeNew( nSubrangeType )
                  % TO DO: currently assuming subrange of integer
4032:             oNodeSet( subrange, qBaseType, IntegerType )
      
                  % TO DO: currently ConstExpr leaves int result on oValue stack
4044:             @ConstExpr
4046:             oNodeSetInt( subrange, qLow, oValueTop )
4057:             oValuePop
4058:             '..'
4060:             @ConstExpr
4062:             oNodeSetInt( subrange, qHigh, oValueTop )
4073:             oValuePop
4074:             oNodeSetInt( subrange, qSize, 4 )   % maybe don't need
      
4086:             oTypeAdd( subrange )
      
4092:             Node a = oNodeNew( nArrayType )
4102:             oNodeSet( a, qIndexType, subrange )
      
4114:             oNodeVecAppend( dimensions, a )
                  % I'll hold off on adding 'a' to the type table since not fully formed yet
      
4123:             [
4123:                | ']' : >
4127:                | ',' :
4129:             ]
4137:          }
      
4139:          pOf
4141:          Node baseType
4141:          @TypeRef( baseType )
      
               % Work backwards through the dimensions,
               % hooking up the 'of' type and calculating the size.
               % At each iteration, baseType is the 'of' type.
      
4148:          int dim = oNodeVecSize( dimensions )
      
4158:          {
4158:              dec(dim)
      
4164:              Node a = oNodeVecElement( dimensions, dim )
      
4177:              oNodeSet( a, qBaseType, baseType )
4189:              Node subrange = oNodeGet( a, qIndexType )
4202:              int width = subtract( oNodeGetInt( subrange, qHigh ), oNodeGetInt( subrange, qLow ) )
4229:              inc( width )
4235:              oNodeSetInt( a, qSize, multiply( width, oNodeGetInt( baseType, qSize ) ) )
      
4261:              oTypeAdd( a )
4267:              baseType = a
      
4273:              [ equal_zero(dim)
4280:                  | true:  >
4283:                  | *:
4288:              ]
4288:          }
      
4290:          resultType = oNodeVecElement( dimensions, 0 )
4303:          oNodeVecDelete( dimensions )
      
4309:       | '^' :
4311:          Node theType
4311:          @TypeRef( theType )
4318:          resultType = @PointerTypeTo( theType )
      
4329:       | pRecord :
4331:          resultType = oNodeNew( nRecordType )
4341:          oScopeBegin( -1, allocUp )    % level is meaningless here
      
4350:          @VarDecl( nRecordField )
      
4357:          int size = oNodeGetInt( oScopeCurrent, qSize )
               % to do: padding
4369:          [ equal_zero( size )
4376:             | true : #eRecordEmpty
4379:             | * :
4384:          ]
      
4384:          pEnd
      
4386:          oNodeSet( resultType, qScope, oScopeCurrent )
4397:          oNodeSetInt( resultType, qSize, size )
4409:          oScopeEnd
4410:          oTypeAdd( resultType )
      
      
4416:       | '(' :
               % An enum type declaration.
4418:          @EnumTypeRef( resultType )
      
      
            % *** TO DO: following type constructors are not implemented *** 
4425:       | pSet :
4427:          pOf
4429:          Node theType
4429:          @TypeRef( theType )
4436:       | * :       % this works for cases except where expr starts with an id
4451:          @ConstExpr '..' @ConstExpr
4457:    ];
      
      
      % Parse an enum type.
      % We've already accepted the '('
      % Returns the new type.
      %
4458: EnumTypeRef( out Node resultType ):
      
4460:    resultType = oNodeNew( nEnumType )
4470:    int value = 0
4476:    int numValues = 0
4482:    boolean first = true
      
         % We'll declare the enum values in two scopes: the current scope, and a scope nested in the enum type.
         % That will let programs use either <val> or <enumType>.<val>
4488:    Node outerScope = oScopeCurrent
4493:    oScopeBegin( -1, allocUp )   % level is meaningless, and we won't use allocate
      
4502:    {
            % TO DO: assert that name not already seen in this scope, i.e. this enum.
            %  And possibly not in the outerScope either, since that probably wouldn't count as shadowing.
            %  It might be in some other higher/used scope.
4502:       pIdent
4504:       Node decl = @newIdent( nEnumValue, LAST_ID )
4517:       Node decl2 = @newIdent( nEnumValue, LAST_ID )
4530:       oNodeSet( decl, qType, resultType )
4542:       oNodeSet( decl2, qType, resultType )
      
            % build up name table, for i/o
4554:       int nameOffset = oStringAllocLit( ID_STRING( LAST_ID ) )
4567:       oNodeSetInt( decl, qNameOffset, nameOffset )
4579:       oNodeSetInt( decl2, qNameOffset, nameOffset )
4591:       [
4591:          | '=', ':=' :
4593:             @ConstExpr
                  % value must be ascending
                  % this obviously doesn't apply to the first value
4595:             [ equal_zero( numValues )
4602:                | false :
4603:                   [ greater( oValueTop, value )
4612:                      | false :   #eEnumValueNotAscending
4615:                      | * :
4620:                   ]
4620:                | * :
4625:             ]
4625:             [ equal( value, oValueTop )
4634:                | false :
                        % The values differ from 0..N-1.  pred/succ may not be used with this type.
4635:                   oNodeSetBoolean( resultType, qHasGap, true )
4647:                | * :
4652:             ]
4652:             value = oValueTop
4657:             oValuePop
4658:          | * :
4665:       ]
4665:       oNodeSetInt( decl, qValue, value )
4677:       oNodeSetInt( decl2, qValue, value )
4689:       oScopeDeclare( decl )
      
4695:       oScopeEnter( outerScope )
4701:       oScopeDeclare( decl2 )
4707:       oScopeEnd
      
4708:       inc( value )
4714:       inc( numValues )
4720:       [
4720:          | ',' :
4722:          | * :    >
4729:       ]
4729:    }
4731:    ')'
      
4733:    oNodeSet( resultType, qScope, oScopeCurrent )
4744:    oNodeSetInt( resultType, qSize, 4 )   % always integer sized
4756:    oScopeEnd
      
         % Finish creation of the name table
         %    struct {
         %      int    value;
         %      int    padding;
         %      char*  name;
         %    } table[ numValues + 1 ];
         %  final entry will have name == nullptr
         %
         % I'll need to generate init code, to store pointers in global data,
         % since I don't have a relocation mechanism for static data at the moment.
4757:    oCodePush( @GetOrCreateInitCode( globalScope ) )
4768:    oScopeEnter( globalScope )
4774:    int size = multiply( add( numValues, 1 ), 16 )
4794:    int addr = oScopeAlloc( size, 8 )
4807:    oScopeEnd
4808:    oNodeSetInt( resultType, qNameTable, addr )
         % loop over enum values
4820:    NodeIter it = oNodeGetIter( oNodeGet( resultType, qScope ), qDecls )
4840:    {
4840:       Node enumValue = oNodeIterValue( it )
4850:       [ oNodeNull( enumValue )
4857:          | true :  >
4860:          | * :
4865:       ]
4865:       .tPushAddrGlobal  oEmitInt( addr )
4873:       .tPushConstI  oEmitInt( oNodeGetInt( enumValue, qValue ) )
4888:       .tAssignI
4890:       addr = add( addr, 8 )
4903:       .tPushAddrGlobal  oEmitInt( addr )
4911:       .tPushAddrGlobal  oEmitInt( oNodeGetInt( enumValue, qNameOffset ) )
4926:       .tAssignP
4928:       addr = add( addr, 8 )
4941:       oNodeIterNext( it )
4947:    }
         % final table entry
4949:    .tPushAddrGlobal  oEmitInt( addr )
4957:    .tPushConstI  oEmitInt( 0 )
4965:    .tAssignI
4967:    addr = add( addr, 8 )
4980:    .tPushAddrGlobal  oEmitInt( addr )
4988:    .tPushConstI  oEmitInt( 0 )
4996:    .tAssignP
4998:    addr = add( addr, 8 )
5011:    oCodePop
      
5012:    oTypeAdd( resultType )
5019:    ;
      
      
      % --------------------------- Const Expressions --------------------------
      
      % Constant expressions: currently, only literal integers or previously
      % named constant integers are supported, possibly with a negation.
      % Constant expressions are evaluated at compile time.
      
5019: ConstExpr:
5021:    [
5021:       | pIntLit :
5023:          oValuePush( TOKEN_VALUE )
5028:       | pIdent :
5030:          Node decl = oScopeFindRequire
5035:          @ResolveUnitRef( decl )
5042:          [ oNodeType( decl )
5049:             | nConst :
5050:                oValuePush( oNodeGetInt( decl, qValue ) )
5063:             | * :
5068:                #eNotConst
5070:                oValuePush( 0 )
5076:          ]
5076:       | pMinus :
5078:          @ConstExpr
5080:          oValueNegate
5081:    ];
      
      
      
      % ------------------------------ Expressions -----------------------------
      
      % There are two wrappers leading into expression parsing:
      %   Expr()
      %   BooleanExprControlFlow( out Label falseLabel )
      %
      % Expr always produces a value on the runtime expr stack,
      % and pushes its type on the type stack.
      %
      % BooleanExprControlFlow always generates control-flow code.
      % It does not push a value on the runtime expr stack.
      % It does not push a type on the type stack.
      % The control flow code ends up at Here if the expr is true,
      % and jumps to falseLabel if the expr is false.
      % This rule allocates falseLabel, and passes it back.
      % The caller will need to define its location.
      %
      % The internal methods of expr parsing may produce a mix of
      % values and control flow, depending on the operators seen.
      % We don't always do one or the other, hoping to be efficient for
      % cases like   "func_call( bool_var1, bool_var2 )"
      % as well as  "if bool_expr1 or bool_expr2 then ...".
      % If a subexpression rule produces control flow, it will allocate a
      % falseLabel and pass it back up.  And it will push the
      % result type as BooleanCFType, to distinguish from BooleanType
      % which corresponds with a boolean value on the expr stack.
      % 
      % Note that my expression parsing is broken into more levels than
      % grammars describe for Pascal precedence levels.  This follows my
      % original parser implementation.  I think my rationale was that
      % operators from the levels that I split up couldn't have been
      % mixed anyway, since they require different data types
      % (e.g. boolean vs int/real).  And splitting them up simplified
      % my code.  But, I should revisit this.
      %
      
      
      % Public entry point:
      %
      % Parse an expression, leaving a value on the runtime expr stack
      % and its type on the type stack.
      %
      % This rule does not export control flow (though it may generate
      % control flow internally for subexpressions).
      %
5092: Expr:
5094:    Label falseLabel = labelNull
      
5100:    @ExprAllowCF( falseLabel )
5107:    @CFToVal( falseLabel );
      
      
      % Public entry point:
      %
      % Parse a Boolean expression, producing control flow code rather than a value.
      % Does not leave a value on the runtime expr stack.
      % Does not leave a type on the type stack.
      %
      % If the expression is true, the code will fall through to the end (Here).
      % If the expression is false, the code will jump to the given falseLabel,
      % which this rule will allocate but not define the location for.
      % The caller must do so.
      %
5115: BooleanExprControlFlow( out Label falseLabel ):
5117:    @ExprAllowCF( falseLabel )
5124:    [ oTypeSNodeType
5126:       | nBooleanCFType :
5127:       | nBooleanType :
               % convert value to control flow
5129:          falseLabel = oLabelNew
5134:          .tJumpFalse  oEmitLabel( falseLabel )
5142:       | * :
5149:          #eNotBoolean
5151:    ]
5151:    oTypeSPop;
      
      
      % If the current expr result is control flow, convert it to a value.
      % falseLabel is the label that had been used by the control flow.
      % On return it will be set to labelNull.
      %
5153: CFToVal( inout Label falseLabel ):
5155:    [ oTypeSNodeType
5157:       | nBooleanCFType :
5158:          Label doneLabel = oLabelNew
5163:          .tPushConstI  oEmitInt( 1 )
5171:          .tJump  oEmitLabel( doneLabel )
5179:          .tLabel  oEmitLabel( falseLabel )
5187:          .tPushConstI  oEmitInt( 0 )
5195:          .tLabel  oEmitLabel( doneLabel )
5203:          oTypeSPop
5204:          oTypeSPush( BooleanType )
5210:          falseLabel = labelNull
5216:       | * :
5221:    ];
      
      
      % If the current expr result is boolean value, convert it to control flow.
      % falseLabel will be allocated by this rule and passed back.
      % The caller must define its location.
      %
5222: ValToCF( out Label falseLabel ):
5224:    [ oTypeSNodeType
5226:       | nBooleanType :
5227:          falseLabel = oLabelNew
5232:          .tJumpFalse  oEmitLabel( falseLabel )
5240:          oTypeSPop
5241:          oTypeSPush( BooleanCFType )
5247:       | * :
5252:    ];
      
      
      % Parse an expression.  It may produce a value on the expr stack,
      % or control flow, depending on what's seen in the expression.
      % Leaves the expression type on the type stack.
      %
      % If the expression produces control flow, the expression type will be
      % nBooleanCFType.  In this case, a true value falls through to Here,
      % and a false value jumps to falseLabel.  This rule will allocate falseLabel
      % and return it, but will not define its location; the caller must do so.
      %
      % If the expression produces a value, the value will be left on the
      % expression stack, and the type will be some type other than nBooleanCFType.
      % In this case, falseLabel is ignored.
      %
5253: ExprAllowCF( out Label falseLabel ):
5255:    @BoolExprAllowCF( falseLabel )
5262:    {[
5262:       | '=' :
5264:          @CFToVal( falseLabel )
5271:          @PromoteToIntOptional
5273:          @BoolExprAllowCF( falseLabel )
5280:          @CFToVal( falseLabel )
5287:          @PromoteToIntOptional
5289:          @MatchTypes
5291:          [ oTypeSNodeType
5293:             | nBooleanType, nCharType :     .tEqualB
5296:             | nIntegerType, nEnumType :     .tEqualI
5300:             | nPointerType, nUniversalPointerType :    .tEqualP
5304:             | nShortStringType, nStrLitType :            #eNotImplemented
5308:             | * :                           #eNotAllowed
5329:          ]
5329:          oTypeSPop
5330:          oTypeSPush( BooleanType )
      
5336:       | '<>' :
5338:          @CFToVal( falseLabel )
5345:          @PromoteToIntOptional
5347:          @BoolExprAllowCF( falseLabel )
5354:          @CFToVal( falseLabel )
5361:          @PromoteToIntOptional
5363:          @MatchTypes
5365:          [ oTypeSNodeType
5367:             | nBooleanType, nCharType :     .tNotEqualB
5370:             | nIntegerType, nEnumType :     .tNotEqualI
5374:             | nPointerType, nUniversalPointerType :    .tNotEqualP
5378:             | nShortStringType, nStrLitType :            #eNotImplemented
5382:             | * :                           #eNotAllowed
5403:          ]
5403:          oTypeSPop
5404:          oTypeSPush( BooleanType )
      
5410:       | '<' :
5412:          @CFToVal( falseLabel )
5419:          @PromoteToIntOptional
5421:          @BoolExprAllowCF( falseLabel )
5428:          @CFToVal( falseLabel )
5435:          @PromoteToIntOptional
5437:          @MatchTypes
5439:          [ oTypeSNodeType
5441:             | nBooleanType, nCharType :     .tLessB
5444:             | nIntegerType, nEnumType :     .tLessI
5448:             | nPointerType, nUniversalPointerType :   .tLessP
5452:             | nShortStringType, nStrLitType :            #eNotImplemented
5456:             | * :                           #eNotAllowed
5477:          ]
5477:          oTypeSPop
5478:          oTypeSPush( BooleanType )
      
5484:       | '>' :
5486:          @CFToVal( falseLabel )
5493:          @PromoteToIntOptional
5495:          @BoolExprAllowCF( falseLabel )
5502:          @CFToVal( falseLabel )
5509:          @PromoteToIntOptional
5511:          @MatchTypes
5513:          [ oTypeSNodeType
5515:             | nBooleanType, nCharType :     .tGreaterB
5518:             | nIntegerType, nEnumType :     .tGreaterI
5522:             | nPointerType, nUniversalPointerType :   .tGreaterP
5526:             | nShortStringType, nStrLitType :            #eNotImplemented
5530:             | * :                           #eNotAllowed
5551:          ]
5551:          oTypeSPop
5552:          oTypeSPush( BooleanType )
      
5558:       | '<=' :
5560:          @CFToVal( falseLabel )
5567:          @PromoteToIntOptional
5569:          @BoolExprAllowCF( falseLabel )
5576:          @CFToVal( falseLabel )
5583:          @PromoteToIntOptional
5585:          @MatchTypes
5587:          [ oTypeSNodeType
5589:             | nBooleanType, nCharType :     .tLessEqualB
5592:             | nIntegerType, nEnumType :     .tLessEqualI
5596:             | nPointerType, nUniversalPointerType :   .tLessEqualP
5600:             | nShortStringType, nStrLitType :            #eNotImplemented
5604:             | * :                           #eNotAllowed
5625:          ]
5625:          oTypeSPop
5626:          oTypeSPush( BooleanType )
      
5632:       | '>=' :
5634:          @CFToVal( falseLabel )
5641:          @PromoteToIntOptional
5643:          @BoolExprAllowCF( falseLabel )
5650:          @CFToVal( falseLabel )
5657:          @PromoteToIntOptional
5659:          @MatchTypes
5661:          [ oTypeSNodeType
5663:             | nBooleanType, nCharType :     .tGreaterEqualB
5666:             | nIntegerType, nEnumType :     .tGreaterEqualI
5670:             | nPointerType, nUniversalPointerType :   .tGreaterEqualP
5674:             | nShortStringType, nStrLitType :            #eNotImplemented
5678:             | * :                           #eNotAllowed
5699:          ]
5699:          oTypeSPop
5700:          oTypeSPush( BooleanType )
      
5706:       | * :
5721:          >
5723:    ]};
      
      
5726: BoolExprAllowCF( out Label falseLabel ):
5728:    Label trueLabel = labelNull
      
5734:    @BoolTermAllowCF( falseLabel )
5741:    {[
5741:       | pOr :
5743:          [ oTypeSNodeType
5745:             | nBooleanCFType :
                     % We are true here. Jump ahead to done
5746:                [ equal_label( trueLabel, labelNull )
5756:                   | true :  trueLabel = oLabelNew
5762:                   | * :
5767:                ]
5767:                .tJump  oEmitLabel( trueLabel )
5775:             | nBooleanType :
5777:                @ValToCF( falseLabel )
                     % We are true here. Jump ahead to done
5784:                [ equal_label( trueLabel, labelNull )
5794:                   | true :  trueLabel = oLabelNew
5800:                   | * :
5805:                ]
5805:                .tJump  oEmitLabel( trueLabel )
5813:             | * : #eNotBoolean
5822:          ]
5822:          oTypeSPop
      
               % false in previous term will jump here, to try this alternative term
5823:          .tLabel  oEmitLabel( falseLabel )
      
               % we'll get a new falseLabel for this term
5831:          falseLabel = labelNull
5837:          @BoolTermAllowCF( falseLabel )
      
5844:          [ oTypeSNodeType
5846:             | nBooleanCFType :
5847:             | nBooleanType :
5849:                @ValToCF( falseLabel )
5856:             | * : #eNotBoolean
5865:          ]
      
5865:          oTypeSPop
5866:          oTypeSPush( BooleanCFType )
      
5872:       | * :
5877:          >
5879:    ]}
      
         % any short-circuit trues jump here to the end
5881:    [ equal_label( trueLabel, labelNull )
5891:       | false :
5892:          .tLabel  oEmitLabel( trueLabel )
5900:       | * :
5905:    ]
5906:    ;
      
      
5906: BoolTermAllowCF( out Label falseLabel ):
5908:    Label overallFalseLabel = labelNull
      
5914:    @BoolFactorAllowCF( falseLabel )
5921:    {[
5921:       | pAnd :
5923:          [ oTypeSNodeType
5925:             | nBooleanCFType :
5926:             | nBooleanType :
5928:                @ValToCF( falseLabel )
5935:             | * :
5942:                #eNotBoolean
5944:          ]
5944:          oTypeSPop
      
               % We're going to have a different falseLabel for each term,
               % because we let each rule allocate its own (rather than accepting labels passed in).
               % And in this case we want them all to go to the same place,
               % to be determined by the caller.
               %
               % I'll allow for label aliases.  This will be more optimal than generating
               % multiple private false-handling code segments, that the true path would have to
               % jump around.  That would be hard to eliminate afterwards.
      
5945:          [ equal_label( overallFalseLabel, labelNull )
5955:             | true :
5956:                overallFalseLabel = oLabelNew
5961:                .tLabelAlias  oEmitLabel( falseLabel )  oEmitLabel( overallFalseLabel )
5975:                falseLabel = overallFalseLabel
5981:             | * :
5986:          ]
      
5986:          Label factorFalseLabel = labelNull
5992:          @BoolFactorAllowCF( factorFalseLabel )
      
5999:          [ oTypeSNodeType
6001:             | nBooleanCFType :
6002:             | nBooleanType :
6004:                @ValToCF( factorFalseLabel )
6011:             | * : #eNotBoolean
6020:          ]
6020:         .tLabelAlias  oEmitLabel( factorFalseLabel )  oEmitLabel( overallFalseLabel )
      
6034:       | * :
6039:          >
6041:    ]};
      
6044: BoolFactorAllowCF( out Label falseLabel ):
6046:    [
6046:       | pNot :
6048:          Label factorFalseLabel = labelNull
      
6054:          @BoolFactorAllowCF( factorFalseLabel )
6061:          [ oTypeSNodeType
6063:             | nBooleanCFType :
                     % We have control flow, and are sitting at the point that has value false.
6064:                falseLabel = oLabelNew
6069:                .tJump  oEmitLabel( falseLabel )
                     % The true path jumps here
6077:                .tLabel  oEmitLabel( factorFalseLabel )
      
6085:             | nBooleanType :
                     % I have a value.  I'll leave it as a value, rather than create control flow.
                     % See how this goes.
6087:                .tNot
      
6089:             | * : #eNotBoolean
6098:          ]
      
6098:       | * :
6103:          @ArithExprAllowCF( falseLabel )
6110:    ];
      
6111: ArithExprAllowCF( out Label falseLabel ):
6113:    @TermAllowCF( falseLabel )
6120:    {[
6120:       | '+' :
6122:          [ oTypeSNodeType
6124:             | nIntegerType, nByteType :
6125:                @PromoteToIntPop
6127:                @TermAllowCF( falseLabel )  % actually not allowing CF, will be caught by type check
6134:                @PromoteToInt
6136:                .tAddI
6138:             | nShortStringType, nStrLitType, nCharType :
                     % String concatenation
6140:                #eNotImplemented
6142:             | nPointerType, nUniversalPointerType :
6144:                Node elementType = oNodeGet( oTypeSTop, qBaseType )
6156:                int elementSize = oNodeGetInt( elementType, qSize )
6169:                @TermAllowCF( falseLabel )  % actually not allowing CF
6176:                @PromoteToIntPop
6178:                [ equal( elementSize, 1 )
6188:                   | false :
6189:                      .tPushConstI  oEmitInt( elementSize )
6197:                      .tMultI
6199:                   | * :
6204:                ]
6204:                .tAddPI
6206:             | * :
6223:                #eNotAllowed
6225:          ]
      
6225:       | '-' :
               % TO DO: pointer arithmetic, as above
      
6227:          @PromoteToIntPop
6229:          @TermAllowCF( falseLabel )
6236:          @PromoteToInt
6238:          .tSubI
6240:       | * :
6247:          >
6249:    ]};
      
6252: TermAllowCF( out Label falseLabel ):
6254:    @FactorAllowCF( falseLabel )
6261:    {[
6261:       | pTimes :
6263:          @PromoteToIntPop
6265:          @FactorAllowCF( falseLabel )  % actually not allowing CF, will be caught by type check
6272:          @PromoteToInt
6274:          .tMultI
6276:       | pDivide :
6278:          @PromoteToIntPop
6280:          @FactorAllowCF( falseLabel )
6287:          @PromoteToInt
6289:          .tDivI
6291:       | * :
6298:          >
6300:    ]};
      
6303: FactorAllowCF( out Label falseLabel ):
6305:    [
6305:       | pPlus :
6307:          @PrimaryAllowCF( falseLabel )  % actually not allowing CF, will be caught by type check
               % TO DO: unary +/- is supposed to leave expression type as-is.
6314:          @PromoteToInt
6316:       | pMinus :
6318:          @PrimaryAllowCF( falseLabel )
               % TO DO: unary +/- is supposed to leave expression type as-is.
6325:          @PromoteToInt
6327:          .tNegI
6329:       | * :
6336:          @PrimaryAllowCF( falseLabel )
6343:    ];
      
6344: PrimaryAllowCF( out Label falseLabel ):
6346:    [
6346:       | pIntLit :
6348:          .tPushConstI  oEmitInt( TOKEN_VALUE )
6355:          oTypeSPush( IntegerType )
      
6361:       | pCharLit :
6363:          .tPushConstI  oEmitInt( TOKEN_VALUE )
6370:          oTypeSPush( CharType )
      
6376:       | '(' :
6378:          @ExprAllowCF( falseLabel )
6385:          ')'
      
6387:       | pStrLit :
6389:          int addr = oStringAllocShortStringLit( CURRENT_STRLIT )     % store in global data
6398:          .tPushAddrGlobal oEmitInt( addr )
               % TO DO: consider defining a ShortString type with the exact capacity used.
               % But, I don't think it should matter here, since nobody should be assigning to this string.
6406:          oTypeSPush( StrLitType )
               % This seems unlikely, but the strlit may be followed by
               % array indexing.  Handle this the same way we would with a variable expression (see VarExpr)
               % First, advance the pointer by index if any
6412:          @LValueIndexes
               % get final value of dereferencing, if any
6414:          @FetchVar
      
6416:       | pIdent :
6418:          Node decl = oScopeFindRequire
6423:          @ResolveUnitRef( decl )
6430:          Node theType
      
6430:          [ oNodeType( decl )
6437:             | nFunc :
6438:                @Call( decl )
      
6445:             | nBuiltInFunc :
6447:                @CallBuiltInFunc( decl )
      
6454:             | nConst, nEnumValue :
6456:                theType = oNodeGet( decl, qType )
6469:                oTypeSPush( theType )
6475:                [ oTypeSNodeType
6477:                   | nIntegerType, nEnumType, nBooleanType :
6478:                      .tPushConstI @EmitValue( decl )
6487:                   | * :
6496:                      #eNotImplemented
6498:                ]
      
6498:             | nGlobalVar, nLocalVar, nParam, nTypedConst :
6500:                @VarExpr( decl )
      
6507:             | * :
6526:                #eNotValue
6528:                oTypeSPush( IntegerType )
6534:          ]
      
6534:       | '@' :        % @var -- pointer to var
6536:          pIdent
      
6538:          Node decl = oScopeFindRequire
6543:          @ResolveUnitRef( decl )
6550:          Node theType
      
               % writeable is false because we're not on the left hand side of an assignment,
               % or passign into a var parameter.  So it's ok to take the address of a typed const.
6550:          @LValueVar( decl, false )
      
               % The above leaves the pointed-to type on type stack.
               % Replace with ptr-to-<type>.
6560:          theType = oTypeSTop
6565:          oTypeSPop
6566:          Node ptrType = @PointerTypeTo( theType )
6577:          oTypeSPush( ptrType )
      
6583:       | * :
6598:          #eNotValue
6600:          oTypeSPush( IntegerType )
6606:    ];
      
      
      % Parse a variable expression, given the declaration of the
      % just-accepted identifier.
      % Leaves the value on the expression stack, and type on the type stack.
      %
6607: VarExpr( Node decl ):
6609:    Node theType = oNodeGet( decl, qType )
         % how many levels up the static scope? Will ignore for globals.
6622:    int uplevels = @DeclUpLevels( decl )
      
6633:    oTypeSPush( theType )
6639:    [ oTypeSNodeType
6641:       | nIntegerType, nEnumType :
6642:          [ oNodeType( decl )
6649:             | nGlobalVar, nTypedConst :   .tPushGlobalI  @EmitValue( decl )
6659:             | nLocalVar :
6661:                [ equal_zero( uplevels )
6668:                   | true :  .tPushLocalI  @EmitValue( decl )
6678:                   | * :     .tPushUpLocalI  oEmitInt( uplevels )  @EmitValue( decl )
6698:                ]
6698:             | nParam :
6700:                [ oNodeGetBoolean( decl, qInOut )
6710:                   | true :    % VAR param points to the var.  Auto dereference.
6711:                      [ equal_zero( uplevels )
6718:                         | true :  .tPushParamP  @EmitValue( decl )
6728:                         | * :     .tPushUpParamP  oEmitInt( uplevels )  @EmitValue( decl )
6748:                      ]
6748:                      .tFetchI
6750:                   | * :
6755:                      [ equal_zero( uplevels )
6762:                         | true :  .tPushParamI  @EmitValue( decl )
6772:                         | * :     .tPushUpParamI  oEmitInt( uplevels )  @EmitValue( decl )
6792:                      ]
6792:                ]
6792:          ]
      
6804:       | nBooleanType, nByteType, nCharType :
6806:          [ oNodeType( decl )
6813:             | nGlobalVar, nTypedConst :   .tPushGlobalB  @EmitValue( decl )
6823:             | nLocalVar :
6825:                [ equal_zero( uplevels )
6832:                   | true :  .tPushLocalB  @EmitValue( decl )
6842:                   | * :     .tPushUpLocalB  oEmitInt( uplevels )  @EmitValue( decl )
6862:                ]
6862:             | nParam :
6864:                [ oNodeGetBoolean( decl, qInOut )
6874:                   | true :    % VAR param points to the var.  Auto dereference.
6875:                      [ equal_zero( uplevels )
6882:                         | true :  .tPushParamP  @EmitValue( decl )
6892:                         | * :     .tPushUpParamP  oEmitInt( uplevels )  @EmitValue( decl )
6912:                      ]
6912:                      .tFetchB
6914:                   | * :
6919:                      [ equal_zero( uplevels )
6926:                         | true :  .tPushParamB  @EmitValue( decl )
6936:                         | * :     .tPushUpParamB  oEmitInt( uplevels )  @EmitValue( decl )
6956:                      ]
6956:                ]
6956:          ]
      
6968:       | nFileType :
6970:          #eNotImplemented
      
6972:       | nPointerType, nUniversalPointerType :
6974:          [ oNodeType( decl )
6981:             | nGlobalVar, nTypedConst :   .tPushGlobalP @EmitValue( decl )
6991:             | nLocalVar :
6993:                [ equal_zero( uplevels )
7000:                   | true :  .tPushLocalP  @EmitValue( decl )
7010:                   | * :     .tPushUpLocalP  oEmitInt( uplevels )  @EmitValue( decl )
7030:                ]
7030:             | nParam :
7032:                [ oNodeGetBoolean( decl, qInOut )
7042:                   | true :    % VAR param points to the var.  Auto dereference.
7043:                      [ equal_zero( uplevels )
7050:                         | true :  .tPushParamP  @EmitValue( decl )
7060:                         | * :     .tPushUpParamP  oEmitInt( uplevels )  @EmitValue( decl )
7080:                      ]
7080:                      .tFetchP
7082:                   | * :
7087:                      [ equal_zero( uplevels )
7094:                         | true :  .tPushParamP  @EmitValue( decl )
7104:                         | * :     .tPushUpParamP  oEmitInt( uplevels )  @EmitValue( decl )
7124:                      ]
7124:                ]               
7124:          ]
7136:          [
7136:             | '^' :             % dereferenced
7138:                oTypeSPop
7139:                oTypeSPush( oNodeGet( theType, qBaseType ) )
7152:                @LValueIndexes
7154:                @FetchVar
7156:             | '[' :             % dereferencing pointer like an array [0..] of baseType
7158:                @PointerArraySubscript
                     % modify addr for any subsequent subscripts, field references, etc
7160:                @LValueIndexes
7162:                @FetchVar
7164:             | * :               % just ptr value alone
7171:          ]
      
7171:       | nArrayType, nRecordType, nShortStringType :
               % compound type
               % first, push addr of start of var
7173:          [ oNodeType( decl )
7180:             | nGlobalVar, nTypedConst :   .tPushAddrGlobal @EmitValue( decl )
7190:             | nLocalVar :
7192:                [ equal_zero( uplevels )
7199:                   | true :  .tPushAddrLocal  @EmitValue( decl )
7209:                   | * :     .tPushAddrUpLocal  oEmitInt( uplevels )  @EmitValue( decl )
7229:                ]
7229:             | nParam :
7231:                [ oNodeGetBoolean( decl, qInOut )
7241:                   | true :    % VAR param points to the var.  Auto dereference.
7242:                      [ equal_zero( uplevels )
7249:                         | true :  .tPushParamP  @EmitValue( decl )
7259:                         | * :     .tPushUpParamP  oEmitInt( uplevels )  @EmitValue( decl )
7279:                      ]
7279:                   | * :
7284:                      [ equal_zero( uplevels )
7291:                         | true :  .tPushAddrParam  @EmitValue( decl )
7301:                         | * :     .tPushAddrUpParam  oEmitInt( uplevels )  @EmitValue( decl )
7321:                      ]
7321:                ]
7321:          ]
               % modify addr for subscripts, field references, etc
7333:          @LValueIndexes
               % get final value
7335:          @FetchVar
7337:    ];
      
      
      % Addr of start of var is on expr stack; type is on type stack.
      % Replace expr stack with value of var.
      % (In the case of compound vars, this remains as the addr of the var).
      
7364: FetchVar:
7366:    [ oTypeSNodeType
7368:       | nIntegerType, nEnumType :  .tFetchI
7371:       | nBooleanType, nByteType, nCharType :  .tFetchB
7375:       | nFileType :   #eNotImplemented
7379:       | nPointerType :             .tFetchP
7383:       | nUniversalPointerType :    #eCantDereference
7387:       | nArrayType, nRecordType, nStrLitType, nShortStringType :  % compound type; leave as addr
7389:    ];
      
      
      % Addr of start of var is already on run stack, and type is on type stack.
      % Read subscripts, record fields, etc, to get final addr on run stack, and final type
      % on type stack.
      
7418: LValueIndexes:
7420:    {[
7420:       | '[' :
7422:          [ oTypeSNodeType
7424:             | nArrayType :    @ArraySubscripts
7427:             | nPointerType :  @PointerArraySubscript
7431:             | nStrLitType, nShortStringType :  @ShortStringArraySubscript
7435:             | * :             #eNotArray
7448:          ]
7448:       | '.' :       @RecordFieldRef
7452:       | '^' :       @PointerDeref   % TO DO: I suspect I don't have logic right here
                                          % about precondition and using .tFetchP
                                          % Ideally this should take over for the ^ in VarExpr too.
7456:       | * :         >
7467:    ]};
      
7470: ArraySubscripts:
7472:    [ oTypeSNodeType
7474:       | nArrayType :
7475:       | * :       #eNotArray
7482:    ]
7482:    {
7482:       [ oTypeSNodeType
7484:          | nArrayType :
7485:          | * :    #eTooManySubscripts
7492:       ]
      
            % low subscript of this dimension
7492:       int low = @OrdinalLow( oNodeGet( oTypeSTop, qIndexType ) )
      
            % replace type stack with next dimension, or OF type
7509:       Node baseType
7509:       baseType = oNodeGet( oTypeSTop, qBaseType )
7521:       oTypeSPop
7522:       oTypeSPush( baseType )
      
7528:       @Expr
7530:       @RequireIntPop
            % adjust for low subscript
7532:       [ equal_zero( low )
7539:          | false :
7540:             .tPushConstI oEmitInt( low ) .tSubI
7550:          | * :
7555:       ]
      
            % multiply by element size
7555:       int size = oNodeGetInt( baseType, qSize )
7568:       [ equal( size, 1 )
7578:          | false :
7579:             .tPushConstI oEmitInt( size ) .tMultI
7589:          | * :
7594:       ]
      
            % update start address
7594:       .tAddPI
7596:       [
7596:          | ']' :  >
7600:          | ',' :
7602:       ]
7610:    };
      
      
      % pointer[index] - similar to array[index] where index counts from 0.
      % On entry, the pointer value is on the stack, and pointer type is on the type stack.
      % We've already accepted the '['.
      % On exit, the address of the pointed-to element is on the stack,
      % and the element type is on the type stack.
      %
7613: PointerArraySubscript:
7615:    [ oTypeSNodeType
7617:       | nPointerType :
7618:       | * :    #eCantDereference
7625:    ]
         % replace type stack with base type
7625:    Node baseType = oNodeGet( oTypeSTop, qBaseType )
7637:    oTypeSPop
7638:    oTypeSPush( baseType )
         
7644:    @Expr
7646:    @RequireIntPop
         % multiply by element size
7648:    int size = oNodeGetInt( baseType, qSize )
7661:    [ equal( size, 1 )
7671:       | false :
7672:          .tPushConstI  oEmitInt( size )  .tMultI
7682:       | * :
7687:    ]
         % update start address
7687:    .tAddPI
7689:    ']';
      
      
      % Specialization of array indexing for ShortString.
      % We treat the starting index as 0 so that str[1] sees the first string char,
      % past the length byte.
      %
7692: ShortStringArraySubscript:
7694:    [ oTypeSNodeType
7696:       | nStrLitType, nShortStringType :
7697:       | * :    #eCantDereference
7706:    ]
7706:    oTypeSPop
7707:    oTypeSPush( CharType )
7713:    @Expr
7715:    @RequireIntPop
7717:    .tAddPI
7719:    ']';
      
      
7722: RecordFieldRef:
7724:    [ oTypeSNodeType
7726:       | nRecordType :
7727:       | * :    #eNotRecord
7734:    ]
7734:    oScopeEnter( oNodeGet( oTypeSTop, qScope ) )
7746:    pIdent
7748:    Node field = oScopeFindRequire
         % oScopeFind searches all open scopes, so make sure we found nRecordField
         % which could only be seen in the local scope we entered above.
7753:    [ oNodeType( field )
7760:       | nRecordField :
7761:       | * :   #eNotRecordField
7768:    ]
7768:    oScopeEnd
7769:    int offset = oNodeGetInt( field, qValue )
7782:    [ equal_zero( offset )
7789:       | false :
7790:          .tPushConstI oEmitInt( offset ) .tAddPI
7800:       | * :
7805:    ]
      
         % replace the type on the type stack, with the field type
7805:    oTypeSPop
7806:    oTypeSPush( oNodeGet( field, qType ) )
7820:    ;
      
      
      % ptr deref on left side, i.e. BEFORE addr of ptr var is on stack,
      %                              AFTER addr of thing pointed to is on stack
7820: PointerDeref:
7822:    [ oTypeSNodeType
7824:       | nPointerType :
7825:       | nUniversalPointerType :   #eCantDereference
7829:       | * :       #eNotPointer
7838:    ]
7838:    .tFetchP           % now addr on stack is addr of what we're pointing to
      
7840:    Node theType = oTypeSTop
7845:    oTypeSPop
7846:    oTypeSPush( oNodeGet( theType, qBaseType ) )
7860:    ;
      
      
      % The expr stack contains a value whose type is on top of the type stack.
      % Generate code to coerce the value to the type under it in the type stack
      % (pop the type stack, leaving only the desired type).
      % This is used for assignment.
      %
7860: CoerceType:
7862:    node_type nt = oTypeSNodeType
7867:    oTypeSPop
7868:    [ equal_node_type( nt, oTypeSNodeType )
7877:       | false :
               % Can we implicitly convert the value to the desired type?
7878:          [ oTypeSNodeType
7880:             | nIntegerType :
7881:                [ nt
7884:                   | nByteType :   .tCastBtoI  >>
7888:                   | * :
7893:                ]
7893:             | nByteType :
7895:                [ nt
7898:                   | nIntegerType :   .tCastItoB  >>
7902:                   | * :
7907:                ]
7907:             | nPointerType :
7909:                [ nt
7912:                   | nUniversalPointerType :  >>
7914:                   | nStrLitType :
7916:                      [ equal_node( oTypeSTop, PCharType )
7925:                         | true :
                                 % PChar := 'strlit' i.e. point at strlit[1]
7926:                            .tPushConstI  oEmitInt(1)  .tAddPI  >>
7937:                         | * :
7942:                      ]
7942:                   | * :
7949:                ]
7949:             | nUniversalPointerType :
7951:                [ nt
7954:                   | nPointerType :  >>
7956:                   | * :
7961:                ]
7961:             | nShortStringType :
7963:                [ nt
7966:                   | nStrLitType :  >>
7968:                   | * :
7973:                ]
7973:             | * :
7986:          ]
7986:          #eTypeMismatch
7988:       | * :
7993:    ];
      
      
      % Called on first use of an extern method
      %
7994: DefineExternLabel( Node method ):
         % The extern name might be given explicitly, otherwise the pascal method name.
7996:    int strAddr
7996:    String externalName = oNodeGetString( method, qExternalName )
8009:    [ equal_string( externalName, stringNull )
8019:       | true :
8020:          strAddr = oStringAllocLit( ID_STRING( oNodeGetInt( method, qIdent ) ) )
8041:       | false :
8043:          strAddr = oStringAllocLit( externalName )
8053:    ]
8061:    .tLabelExtern  @EmitValue( method )  oEmitInt( strAddr )
8077:    ;
      
      
      % Parse a call, given an nProc or nFunc for the just-accepted identifier.
      % If a func, this will also generate the code to push the return value on the expr stack,
      % and push the return type on the type stack.
      %
8077: Call( Node method ):
      
         % Prior to first call, issue extern label for a called method.
         % I don't want to issue .tLabelExtern for unused methods, that seems inefficient.
8079:    [ oNodeGetBoolean( method, qExternal )
8089:       | true :
8090:          [ oNodeGetBoolean( method, qUsed )
8100:             | false :
                     % define the extern label on first use
8101:                @DefineExternLabel( method )
8108:             | * :
8113:          ]
8113:      | * :
8118:    ]
8118:    oNodeSetBoolean( method, qUsed, true )
      
         % If the method has a cdecl modifier, the back end will need to use the native
         % calling convention, instead of my own.  But, the convention varies by platform,
         % so the front end won't assume what it needs.  I'll still generate the normal tcode
         % that copies values into actuals space on the stack.
         % However, to help the back end, I will at least use a different instruction for the
         % allocation of the actuals space, and for the actual call.
         %
         % p.s. I only support cdecl on external methods, because I don't have a way
         % to let my own Pascal methods read params passed in with the cdecl calling convention.
         %
8130:    boolean cdecl = oNodeGetBoolean( method, qCdecl )
      
         % If this is a function, we will allocate a temporary
         % in the current scope, to hold the result value.
         % And pass a pointer to that temporary as an extra parameter.
8143:    Node resultType
8143:    int tempOffset
      
8143:    boolean isFunc = equal_node_type( oNodeType( method ), nFunc )
      
8160:    [ isFunc
8163:       | true :
8164:          resultType = oNodeGet( method, qType )
8177:          tempOffset = oScopeAllocType( resultType )
               % TO DO: we could manage temp allocation, so temp space can be reused
               %        by different code branches.
8187:       | * :
8192:    ]
         
      
8192:    Node paramScope = oNodeGet( method, qParams )
8205:    int actualsSize = oNodeGetInt( paramScope, qSize )
8218:    [ cdecl
8221:       | true : .tAllocActualsCdecl  oEmitInt( actualsSize )
8230:       | false :  .tAllocActuals  oEmitInt( actualsSize )
8240:    ]
      
         % If method is nested, it takes a hidden first parameter:
         % a pointer to the frame of the static scope in which the method is declared.
         % The location of a scope's frame is equivalent to offset 0 in the scope's locals space
         % (since local offsets are relative to the scope's frame pointer).
         %
         % The nested method may be in a higher scope (upLevels > 1),
         % or a sibling of the method we're in (upLevels = 1),
         % or an immediate child of the current method (upLevels = 0).
         %
         % To understand the upLevels computation, remember that a method's declaration
         % and its contents (variables, nested functions, and body statement)
         % are in two different scopes.
      
8248:    [ greater( @DeclLevel( method ), 0 )
8263:       | true :
8264:          .tPushAddrActual  oEmitInt( 0 )    % hidden param is at param offset 0
8272:          .tPushAddrUpLocal  oEmitInt( @DeclUpLevels( method ) )  oEmitInt( 0 )
8291:          .tAssignP
8293:       | * :
8298:    ]
      
      
8298:    NodeIter paramIter = oNodeGetIter( paramScope, qDecls )
8311:    Node param = oNodeIterValue( paramIter )
8321:    [
8321:       | '(' :
            
8323:          {
8323:             [ oNodeNull( param )
8330:                | true : >
8333:                | * :
8338:             ]
      
8338:             int offset = oNodeGetInt( param, qValue )
      
                  % Assign actual value to spot in actuals space
8351:             .tPushAddrActual oEmitInt( offset )
8359:             oTypeSPush( oNodeGet( param, qType ) )
      
8372:             [ oNodeGetBoolean( param, qInOut )
8382:                | true :   % A VAR param.
                                % The actual is a pointer to the value.
                                % The type on the type stack (pushed above) is for the pointed-to value.
      
8383:                           @LValueExpr( true )
                                % Addr of the referenced variable is on the expr stack,
                                % type of the variable is on the type stack.
      
                                % Match types more exactly. It's not sufficient to be assign compatible
                                % since the method will be assigning to the actual using the param type.
                                % Maybe something like type contents must match, incl subrange bounds.
8390:                           @MatchTypes
      
8392:                           .tAssignP
      
8394:                | false :  @Expr
8398:                           @CoerceType
                                
                                % Assign to offset in actuals space
      
8400:                           [ oTypeSNodeType
8402:                              | nIntegerType, nEnumType : .tAssignI
8405:                              | nBooleanType, nByteType, nCharType :  .tAssignB
8409:                              | nFileType :   #eNotImplemented
8413:                              | nPointerType, nUniversalPointerType :  .tAssignP
8417:                              | nArrayType, nRecordType, nShortStringType :
                                       % compound types: copy value into actuals space
8419:                                  int size = oNodeGetInt( oTypeSTop, qSize )
8431:                                  .tCopy  oEmitInt( size )    % multi-word copy
8439:                           ]
8465:             ]
8473:             oTypeSPop
      
8474:             oNodeIterNext( paramIter )
8480:             param = oNodeIterValue( paramIter )
8490:             [ oNodeNull( param )
8497:                | true :  >
8500:                | false :
8502:             ]
      
8510:             ','
8512:          }
      
8514:          ')'
      
8516:       | * :
8521:    ]
      
8521:    [ oNodeNull( param )
8528:       | false :    #eMissingParameter
8531:       | * :
8536:    ]
      
8536:    [ isFunc
8539:       | true :
               % Pass result temp as an additional VAR parameter.
8540:          .tPushAddrActual oEmitInt( oNodeGetInt( method, qResultOffset ) )
8555:          .tPushAddrLocal  oEmitInt( tempOffset )
8563:          .tAssignP
8565:       | * :
8570:    ]
      
8570:    [ cdecl
8573:       | true :
8574:          .tCallCdecl  @EmitValue( method )
8583:       | false :
8585:          .tCall   @EmitValue( method )
8594:    ]
      
8602:    [ isFunc
8605:       | true :
               % push return value from temp
8606:          oTypeSPush( resultType )
      
8612:          [ oTypeSNodeType
8614:             | nIntegerType, nEnumType :   .tPushLocalI  oEmitInt( tempOffset )
8623:             | nBooleanType, nByteType, nCharType :   .tPushLocalB  oEmitInt( tempOffset )
8633:             | nFileType :  #eNotImplemented
8637:             | nPointerType, nUniversalPointerType :   .tPushLocalP  oEmitInt( tempOffset )
8647:             | nArrayType, nRecordType, nShortStringType :   % compound type: push address
8649:                                .tPushAddrLocal  oEmitInt( tempOffset )
8657:          ]
8683:       | * :
8688:    ]
         
8688:    .tFreeActuals  oEmitInt( actualsSize )
8697:    ;
      
      
      % Parse a call to a built-in function, identified by the just-accepted identifier.
      % This will also generate the code to push the return value on the expr stack,
      % and push the return type on the type stack.
      %
8697: CallBuiltInFunc( Node method ):
      
         % Ord(x)
8699:    [ oNodeEqual( method, BuiltIn_Ord )
8709:       | true :
               % parameter is any scalar type (including boolean, enum, char)
               % result is integer
8710:          '('
8712:          @Expr
8714:          [ oTypeSNodeType
8716:             | nIntegerType, nEnumType :
8717:             | nBooleanType, nByteType, nCharType :  .tCastBtoI
8721:             | * :  #eTypeMismatch
8736:          ]
8736:          oTypeSPop
8737:          oTypeSPush( IntegerType )
8743:          ')'
8745:          >>
8746:       | * :
8751:    ]
      
         % Chr(x)
8751:    [ oNodeEqual( method, BuiltIn_Chr )
8761:       | true :
               % parameter is integer
               % result is char
8762:          '('
8764:          @Expr
8766:          [ oTypeSNodeType
8768:             | nIntegerType :    .tCastItoB
8771:             | nByteType :
8773:             | * :  #eTypeMismatch
8782:          ]
8782:          oTypeSPop
8783:          oTypeSPush( CharType )
8789:          ')'
8791:          >>
8792:       | * :
8797:    ]
      
         % Pred(x)
8797:    [ oNodeEqual( method, BuiltIn_Pred )
8807:       | true :
               % parameter is any enum type, as long as it has values 0..N-1
               % result is the same enum type
8808:          '('
8810:          @Expr
8812:          [ oTypeSNodeType
8814:             | nEnumType :
                     % TO DO: does this skip past type aliases?
                     % TO DO: what if using pred/succ on a subrange type?
8815:                [ oNodeGetBoolean( oTypeSTop, qHasGap )
8824:                   | true :   #eCantUsePredSuccOnEnumWithValueGaps
8827:                   | * :
8832:                ]
8832:             | * :  #eTypeMismatch
8839:          ]
8839:          .tDecI
8841:          ')'
8843:          >>
8844:       | * :
8849:    ]
      
         % Succ(x)
8849:    [ oNodeEqual( method, BuiltIn_Succ )
8859:       | true :
               % parameter is any enum type, as long as it has values 0..N-1
               % result is the same enum type
8860:          '('
8862:          @Expr
8864:          [ oTypeSNodeType
8866:             | nEnumType :
                     % TO DO: does this skip past type aliases?
                     % TO DO: what if using pred/succ on a subrange type?
8867:                [ oNodeGetBoolean( oTypeSTop, qHasGap )
8876:                   | true :   #eCantUsePredSuccOnEnumWithValueGaps
8879:                   | * :
8884:                ]
8884:             | * :  #eTypeMismatch
8891:          ]
8891:          .tIncI
8893:          ')'
8895:          >>
8896:       | * :
8901:    ]
      
8901:    #eNotImplemented
8904:    ;
      
      
      % ------------------------------ Statements -----------------------------
      
8904: Statement:
8906:    [
8906:       | pWriteln :     @WritelnStmt
8910:       | pWrite :       @WriteStmt
8914:       | pReadln :      @ReadlnStmt
8918:       | pRead :        @ReadStmt
8922:       | pIf :          @IfStmt
8926:       | pWhile :       @WhileStmt
8930:       | pFor :         @ForStmt
8934:       | pRepeat :      @RepeatStmt
8938:       | pBreak :       @BreakStmt
8942:       | pContinue :    @ContinueStmt
8946:       | pBegin :       @BeginStmt
8950:       | pIdent :       @LabelOrAssignOrCallStmt
8954:       | pGoto :        @GotoStmt
8958:       | pIntLit :      % should be an integer label
8960:                        oChangeIntLitToLabelIdent
8961:                        @LabelOrAssignOrCallStmt
8963:       | * :            % null statement : don't accept any tokens
8994:    ];
      
      
8995: LabelOrAssignOrCallStmt:
8997:    Node decl = oScopeFindRequire
9002:    @ResolveUnitRef( decl )
9009:    [ oNodeType( decl )
9016:       | nLabel :                          @LabelDefinition( decl )
9024:                                           @Statement
9026:       | nProc :                           @Call( decl )
9035:       | nGlobalVar, nLocalVar, nParam :   @AssignStmt( decl )
9044:       | nFunc :                           @AssignResultStmt( decl )
9053:       | * :                               #eBadStatement
9070:    ];
      
      
      % Parse a "label:" prefix in front of a statement.
      %
9071: LabelDefinition( Node decl ):
9073:    [ oNodeGetBoolean( decl, qDefined )
9083:       | true :  #eAlreadyDefined
9086:       | * :
9091:    ]
9091:    .tLabel  oEmitLabel( oNodeGetLabel( decl, qValue ) )
9106:    oNodeSetBoolean( decl, qDefined, true )
9118:    ':'
9121:    ;
      
      
      % Given decl, the just-accepted first identifier on the left hand side.
      %
9121: AssignStmt( Node decl ):
      
9123:    @LValueVar( decl, true )
9133:    ':=' 
9135:    @Expr
9137:    @CoerceType
9139:    @Assign
9142:    ;
      
      
      % Performs a raw assignment.
      % Given lvalue 2nd on stack, and expr value top of stack (already coerced to the lvalue type),
      % and type of both of these on the type stack,
      % perform the assignment and pop the type off the type stack.
      %
9142: Assign:
9144:    [ oTypeSNodeType
9146:       | nIntegerType, nEnumType :  .tAssignI
9149:       | nBooleanType, nByteType, nCharType :  .tAssignB
9153:       | nFileType :   #eNotImplemented
9157:       | nPointerType, nUniversalPointerType :  .tAssignP
            % compound var assigns; addrs of src, dest on stack
9161:       | nArrayType, nRecordType, nShortStringType :
                % TO DO: for ShortString, allow destination to be smaller capacity,
                % and truncate the copied value/length.
9163:           int size = oNodeGetInt( oTypeSTop, qSize )
9175:           .tCopy  oEmitInt( size )    % multi-word copy
9183:    ]
9209:    oTypeSPop
9211:    ;
      
      % Given nFunc for the just-accepted identifier on the left hand side.
      % Parse an assignment that represents assignment of the function result.
      %
9211: AssignResultStmt( Node funcDecl ):
         % Only allowed to assign the result of the immediately enclosing function, I think.
9213:    [ oNodeEqual( oNodeGet( funcDecl, qChildScope ), oScopeCurrent )
9229:       | false :   #eNotCurrentFunction
9232:       | * :
9237:    ]
      
         % Result value is stored in the caller's space, via a hidden VAR parameter.
9237:    .tPushParamP  oEmitInt( oNodeGetInt( funcDecl, qResultOffset ) )
9252:    oTypeSPush( oNodeGet( funcDecl, qType ) )
      
9265:    ':='
9267:    @Expr
9269:    @CoerceType
9271:    [ oTypeSNodeType
9273:       | nIntegerType, nEnumType : .tAssignI
9276:       | nBooleanType, nByteType, nCharType :  .tAssignB
9280:       | nFileType :   #eNotImplemented
9284:       | nPointerType, nUniversalPointerType :  .tAssignP
            % compound var assigns; addrs of src, dest on stack
9288:       | nArrayType, nRecordType, nShortStringType :
9290:           int size = oNodeGetInt( oTypeSTop, qSize )
9302:           .tCopy  oEmitInt( size )    % multi-word copy
9310:    ]
9336:    oTypeSPop
9338:    ;
      
      
      
      % Parse an lvalue expression, from scratch.
      % This is an expression that may appear on the left side of an assignment.
      % Leaves the address of the value on the expr stack,
      % and the type of the value at that address on the type stack.
      % If writeable is false, the expression won't be written to, so may access a
      % typed const.
      %
9338: LValueExpr( boolean writeable ):
         % At the moment, all lvalue expressions start with a variable name.
         % I think there can also be typecasts, not supported yet.  Check standard syntax.
9340:    pIdent
9342:    Node decl = oScopeFindRequire
9347:    @ResolveUnitRef( decl )
9354:    [ oNodeType( decl )
9361:       | nGlobalVar, nLocalVar, nParam, nTypedConst :
9362:       | * :  #eNotVar
9375:    ]
9375:    @LValueVar( decl, writeable )
9386:    ;
      
      
      % Parse an lvalue expression (e.g. left side of an assign statement)
      % that starts with the just-accepted identifier indicated by the given decl.
      % Leaves the lvalue address on the expression stack,
      % and the type of the value at that address on the type stack.
      %
9386: LValueVar( Node decl, boolean writeable ):
9388:    [ oNodeType( decl )
9395:       | nGlobalVar :   .tPushAddrGlobal @EmitValue( decl )
9405:       | nLocalVar :    .tPushAddrLocal @EmitValue( decl )
9416:       | nParam :
9418:          [ oNodeGetBoolean( decl, qInOut )
9428:             | true :   % VAR param points to variable.  No dereference.
9429:                        .tPushParamP @EmitValue( decl )
9438:             | * :      .tPushAddrParam @EmitValue( decl )
9452:          ]
9452:       | nTypedConst :
9454:          [ writeable
9457:             | false :  .tPushAddrGlobal @EmitValue( decl )                       
9467:             | * :      #eNotVar
9474:          ]
9474:       | * :            #eNotVar
9487:    ]
      
9487:    oTypeSPush( oNodeGet( decl, qType ) )
9500:    @LValueIndexes        % handle subscripts, if any
9503:    ;
      
      
9503: IncVar( Node decl ):
9505:    @LValueVar( decl, true )
9515:    @RequireIntPop
9517:    @VarExpr( decl )
9524:    oTypeSPop
9525:    .tIncI
9527:    .tAssignI;
      
9530: DecVar( Node decl ):
9532:    @LValueVar( decl, true )
9542:    @RequireIntPop
9544:    @VarExpr( decl )
9551:    oTypeSPop
9552:    .tDecI
9554:    .tAssignI;
      
      
9557: IfStmt:
9559:    Label falseLabel = labelNull
      
9565:    @BooleanExprControlFlow( falseLabel )
9572:    pThen
9574:    @Statement
9576:    [
9576:       | pElse :
9578:          Label doneLabel = oLabelNew
      
9583:          .tJump  oEmitLabel( doneLabel )
9591:          .tLabel oEmitLabel( falseLabel )
9599:          @Statement
9601:          .tLabel oEmitLabel( doneLabel )
      
9609:       | * :
9614:          .tLabel oEmitLabel( falseLabel )
9622:    ];
      
      
9623: ForStmt:
9625:    pIdent
      
9627:    Node decl = oScopeFindRequire
         % TO DO: disallow use of a compound variable field.
         %        Could do that by disallowing use of LValueIndexes,
         %        or by double-checking the decl's qType here.
         % TO DO: I think I read somewhere that the variable must be in current scope.
9632:    @LValueVar( decl, true )
9642:    @RequireIntPop
      
9644:    ':='
      
9646:    @Expr
9648:    @RequireIntPop
9650:    .tAssignI
      
9652:    Label breakLabel = oLabelNew
      
9657:    Label checkLabel = oLabelNew
9662:    .tJump  oEmitLabel( checkLabel )
      
9670:    Label continueLabel = oLabelNew
9675:    .tLabel  oEmitLabel( continueLabel )
9683:    [
9683:       | pTo :
9685:          @IncVar( decl )
9692:          .tLabel  oEmitLabel( checkLabel )
9700:          @VarExpr( decl )  oTypeSPop
9708:          @Expr
9710:          @RequireIntPop
9712:          .tGreaterI
9714:          .tJumpTrue  oEmitLabel( breakLabel )
9722:       | pDownto :
9724:          @DecVar( decl )
9731:          .tLabel  oEmitLabel( checkLabel )
9739:          @VarExpr( decl )  oTypeSPop
9747:          @Expr
9749:          @RequireIntPop
9751:          .tLessI
9753:          .tJumpTrue  oEmitLabel( breakLabel )
9761:    ]
9769:    oLoopPush( continueLabel, breakLabel )
9778:    pDo
9780:    @Statement
9782:    .tJump  oEmitLabel( continueLabel )
9790:    .tLabel  oEmitLabel( breakLabel )
9798:    oLoopPop;
      
      
9800: RepeatStmt:
9802:    Label continueLabel = oLabelNew
9807:    .tLabel  oEmitLabel( continueLabel )
      
9815:    Label breakLabel = oLabelNew
      
9820:    oLoopPush( continueLabel, breakLabel )
9829:    @Statement
9831:    {[
9831:       | ';' :
9833:          @Statement
9835:       | pUntil :
9837:          Label falseLabel
9837:          @BooleanExprControlFlow( falseLabel )
9844:          .tLabelAlias  oEmitLabel( falseLabel )  oEmitLabel( continueLabel )
9858:          >
9860:    ]}
9870:    .tLabel  oEmitLabel( breakLabel )
9878:    oLoopPop;
      
      
9880: WhileStmt:
9882:    Label continueLabel = oLabelNew
9887:    .tLabel  oEmitLabel( continueLabel )
      
9895:    Label breakLabel
9895:    @BooleanExprControlFlow( breakLabel )
      
9902:    oLoopPush( continueLabel, breakLabel )
9911:    pDo
9913:    @Statement
9915:    .tJump  oEmitLabel( continueLabel )
9923:    .tLabel  oEmitLabel( breakLabel )
9931:    oLoopPop;
      
      
9933: ContinueStmt:                     % NOTE, for repeat..until, skips test (??)
9935:    [ equal_label( oLoopContinueLabel, labelNull )
9944:       | true :
9945:          #eNotInALoop
9947:       | false :
9949:          .tJump  oEmitLabel( oLoopContinueLabel )
9956:    ];
      
      
9965: BreakStmt:
9967:    [ equal_label( oLoopBreakLabel, labelNull )
9976:       | true :
9977:          #eNotInALoop
9979:       | false :
9981:          .tJump  oEmitLabel( oLoopBreakLabel )
9988:    ];
      
      
9997: GotoStmt:
9999:    [
9999:       | pIdent :
10001:       | pIntLit :
               % Replace token with identifier "_label_<intlit>"
10003:          oChangeIntLitToLabelIdent
10004:    ]
      
         % Some pascals have rules about where you can jump (to a sibling statement or
         % higher level statement in the block, but not into a lower lower level statement.)
         % fpc just says "jumping into a nested statement can have strange effects."
         % I'm going to follow that and not prohibit any goto, as long as it's in the same block.
      
         % Label must be declared in the same block (same scope) it is used.
         % Some pascals allow non-local goto, but we do not.
         % That would require more tracking of dynamic scope, to unwind stack.
         % Note: in main program statement, this relies on the temporaries scope extending
         %  the main scope (where a label declaration would occur).
10012:    Node decl = oScopeFindRequireInScope( oScopeCurrent )
10021:    oNodeSetBoolean( decl, qUsed, true )
10033:    .tJump  oEmitLabel( oNodeGetLabel( decl, qValue ) )
10049:    ;
      
      
10049: BeginStmt:
10051:    @Statement
10053:    {[
10053:       | ';' :   @Statement
10057:       | pEnd :  >
10061:    ]};
      
      
10072: WritelnStmt:
10074:    @WriteStmt
10076:    .tWriteCR;
      
      
10079: WriteStmt:
10081:    [
10081:       | '(' :
10083:          {
10083:             @Expr
10085:             [ oTypeSNodeType
10087:                | nIntegerType :             .tWriteI
10090:                | nBooleanType :             .tWriteBool
10094:                | nByteType :                .tCastBtoI  .tWriteI
10100:                | nCharType :                .tWriteChar
10104:                | nShortStringType, nStrLitType :   .tWriteShortStr
10108:                | nFileType :                #eNotImplemented
10112:                | nEnumType :
                        % write name via table lookup
10114:                   .tPushAddrGlobal  oEmitInt( oNodeGetInt( oTypeSTop, qNameTable ) )
10128:                   .tWriteEnum
10130:                | nPointerType :
10132:                   [ equal_node( oTypeSTop, PCharType )
10141:                      | true :               .tWritePChar
10144:                      | * :                  .tWriteP
10151:                   ]
10151:                | nUniversalPointerType :    .tWriteP
10155:                | * :                        #eNotAllowed
10180:             ]
10180:             oTypeSPop
10181:             [
10181:                | ')' : >
10185:                | ',' :
10187:             ]
10195:          }
10197:       | * :
10202:    ];
      
      
10203: ReadlnStmt:      % ***
         % TO DO
10206:    ;
      
10206: ReadStmt:
         % TO DO
10209:    ;
      
      % -------------------------------- Utilities -------------------------------
      
      % Return the static scope level of the current scope
      %
10209: ScopeLevel >> int:
10211:    >> oNodeGetInt( oScopeCurrent, qLevel );
      
      % Return the static scope level of the given declaration
      %
10221: DeclLevel( Node decl ) >> int:
10223:    >> oNodeGetInt( oNodeGet( decl, qParentScope ), qLevel );
         
      
      % How many levels higher is the given declaration from the current scope?
      %
10241: DeclUpLevels( Node decl ) >> int:
10243:    >> subtract( @ScopeLevel, @DeclLevel( decl ) );
      
      
      % Require that the top two types on the type stack are matching (ignoring subranges).
      % Pop one of them, leaving only one.
      %
10259: MatchTypes:
10261:    node_type nt = oTypeSNodeType
10266:    oTypeSPop
10267:    [ equal_node_type( nt, oTypeSNodeType )
10276:       | false :
               % Some implicit conversion is allowed even here
10277:          [ oTypeSNodeType
10279:             | nPointerType :
10280:                [ nt
10283:                   | nUniversalPointerType :  >>
10285:                   | * :
10290:                ]
10290:             | nUniversalPointerType :
10292:                [ nt
10295:                   | nPointerType :  >>
10297:                   | * :
10302:                ]
10302:             | * :
10309:          ]
10309:          #eTypeMismatch
10311:       | * :
10316:    ];
      
      
      % Require that the top type on the type stack is integer (ignoring subranges).
      % Pop it.
      %
10317: RequireIntPop:
10319:    [ oTypeSNodeType
10321:       | nIntegerType :
10322:       | * :          #eNotInteger
10329:    ]
10329:    oTypeSPop;
      
10331: RequireInt:
10333:    [ oTypeSNodeType
10335:       | nIntegerType :
10336:       | * :          #eNotInteger
10343:    ];
      
      
      % Convert the top value to integer (if it isn't already).
      % It must be implicitly convertable to integer.
      % Pop the type stack.
      %
10344: PromoteToIntPop:
10346:    [ oTypeSNodeType
10348:       | nIntegerType :
10349:       | nByteType :        .tCastBtoI
10353:       | * :                #eNotInteger
10362:    ]
10362:    oTypeSPop;
      
      % Convert the top value to integer (if it isn't already).
      % It must be implicitly convertable to integer.
      % Leave integer on the type stack.
      %
10364: PromoteToInt:
10366:    [ oTypeSNodeType
10368:       | nIntegerType :
10369:       | nByteType :        .tCastBtoI
10373:                            oTypeSPop
10374:                            oTypeSPush( IntegerType )
10380:       | * :                #eNotInteger
10389:    ];
      
      
      % If the top value is implicitly convertable to integer, do so.
      % Otherwise leave it as-is.
      %
10390: PromoteToIntOptional:
10392:    [ oTypeSNodeType
10394:       | nByteType :        .tCastBtoI
10397:                            oTypeSPop
10398:                            oTypeSPush( IntegerType )
10404:       | * :
10409:    ];
      
      
      
      
10410: RequireBoolPop:
10412:    [ oTypeSNodeType
10414:       | nBooleanType :
10415:       | * :          #eNotBoolean
10422:    ]
10422:    oTypeSPop;
      
10424: RequireBool:
10426:    [ oTypeSNodeType
10428:       | nBooleanType :
10429:       | * :          #eNotBoolean
10436:    ];
      
      
      % Create and return a new nType of the given node_type, adding it to the type table.
      %
10437: newType( node_type nt, int size ) >> Node:
10439:   Node node = oNodeNew( nt )
10449:   oNodeSetInt( node, qSize, size )
10461:   oTypeAdd( node )
10467:   >> node
10471:   ;
      
      
      % Create and return a new nIdent of the given node_type, with the given ident id.
      % Does not add it to any scope.
      %
10471: newIdent( node_type nt, int id ) >> Node:
10473:   Node t = oNodeNew( nt )
10483:   oNodeSetInt( t, qIdent, id )
10495:   >> t
10499:   ;
      
      
      % Return an nType representing a pointer to the given type.
      % (Creates a new type if necessary.)
      %
10499: PointerTypeTo( Node theType ) >> Node:
10501:    Node ptrType = oNodeGet( theType, qPointerType )
10514:    [ oNodeNull( ptrType )
10521:       | true :
10522:          ptrType = oNodeNew( nPointerType )
10532:          oNodeSet( ptrType, qBaseType, theType )
10544:          oNodeSetInt( ptrType, qSize, 8 )
10556:          oTypeAdd( ptrType )
10562:          oNodeSet( theType, qPointerType, ptrType )
10574:       | * :
10579:    ]
10579:    >> ptrType;
      
      
      % Return the low value of an ordinal type
      %
10583: OrdinalLow( Node theType ) >> int:
10585:    [ oNodeType( theType )
10592:       | nIntegerType :  >> oMININT
10595:       | nBooleanType :  >> 0
10600:       | nCharType :     >> 0
10605:       | nEnumType :
10607:          Node enumScope = oNodeGet( theType, qScope )
10620:          Node first = oNodeIterValue( oNodeGetIter( enumScope, qDecls ) )
10637:          >> oNodeGetInt( first, qValue )
10647:       | nSubrangeType : >> oNodeGetInt( theType, qLow )
10659:       | * :             #eNotOrdinalType
10674:                         >> 0
10677:    ];
      
      
      % Return the high value of an ordinal type
      %
10678: OrdinalHigh( Node theType ) >> int:
10680:    [ oNodeType( theType )
10687:       | nIntegerType :  >> oMAXINT
10690:       | nBooleanType :  >> 1
10695:       | nCharType :     >> 255
10700:       | nEnumType :
10702:          Node enumScope = oNodeGet( theType, qScope )
10715:          Node last = oNodeIterValue( oNodeGetIterLast( enumScope, qDecls ) )
10732:          >> oNodeGetInt( last, qValue )
10742:       | nSubrangeType : >> oNodeGetInt( theType, qHigh )
10754:       | * :             #eNotOrdinalType
10769:                         >> 0
10772:    ];
      
      
      % Emit the value in a declaration.
      % For a constant integer, this is the constant value.
      % For a global variable, this is the global address.
      % For a local variable, this is the local address relative to the call stack frame.
      %
10773: EmitValue( Node decl ):
10775:     oEmitInt( oNodeGetInt( decl, qValue ));
      
      
10789: DeclareBuiltInFunc( int id ) >> Node:
10791:    Node decl = @newIdent( nBuiltInFunc, id )
10805:    oScopeDeclare( decl )
10811:    >> decl;
      
      
10815: installBuiltIns:
      
         % "mysystem" is the name of a unit that will be available everywhere.
         % Add its name to the id table so we can easily spot the name later.
10817:    mysystemId = oIdAdd_mysystem
      
         % install built-in types
10822:    FileType = @newType( nFileType, 4 )
10836:    IntegerType = @newType( nIntegerType, 4 )
10850:    BooleanType = @newType( nBooleanType, 1 )
10864:    BooleanCFType = @newType( nBooleanCFType, 1 )
10878:    CharType = @newType( nCharType, 1 )
10892:    PCharType = @PointerTypeTo( CharType )
10903:    ByteType = @newType( nByteType, 1 )
         % Universal pointer says base type Byte, but this is only for the sake of
         % pointer arithmetic.  It doesn't matter otherwise, because this type cannot be dereferened.
10917:    UniversalPointerType = @newType( nUniversalPointerType, 8 )
10931:    oNodeSet( UniversalPointerType, qBaseType, ByteType )
         % StrLitType is stored with both a length byte and null termination, so it can be assigned to
         % both a ShortString and a PChar.  StrLits longer than 255 characters appear truncated when
         % referenced as a ShortString, but not when referenced as a PChar.
10943:    StrLitType = @newType( nStrLitType, 256 )
         % ShortString is the original Pascal string type: an array of characters, not null-terminated,
         % with the first byte recording the current length.
         % The default ShortString type has capacity for 255 characters.  The user may define
         % additional ShortString types with smaller capacities.
         % The first character can be accessed as myString[1].
10957:    ShortStringType = @newType( nShortStringType, 256 )
10971:    oNodeSetInt( ShortStringType, qCapacity, 255 )
      
         % Declare those type identifiers.
         % SSL doesn't support strings, so need help from operations e.g. oIdAdd_File
      
10983:    Node t
      
10983:    t = @newIdent( nTypeDecl, oIdAdd_File )
10996:    oNodeSet( t, qType, FileType )
11008:    oScopeDeclare( t )
      
11014:    t = @newIdent( nTypeDecl, oIdAdd_Integer )
11027:    oNodeSet( t, qType, IntegerType )
11039:    oScopeDeclare( t )
      
11045:    t = @newIdent( nTypeDecl, oIdAdd_Boolean )
11058:    oNodeSet( t, qType, BooleanType )
11070:    oScopeDeclare( t )
      
11076:    t = @newIdent( nTypeDecl, oIdAdd_Char )
11089:    oNodeSet( t, qType, CharType )
11101:    oScopeDeclare( t )
      
11107:    t = @newIdent( nTypeDecl, oIdAdd_Byte )
11120:    oNodeSet( t, qType, ByteType )
11132:    oScopeDeclare( t )
      
11138:    t = @newIdent( nTypeDecl, oIdAdd_Pointer )
11151:    oNodeSet( t, qType, UniversalPointerType )
11163:    oScopeDeclare( t )
      
11169:    t = @newIdent( nTypeDecl, oIdAdd_ShortString )
11182:    oNodeSet( t, qType, ShortStringType )
11194:    oScopeDeclare( t )
      
         % Built-in constants
      
11200:    t = @newIdent( nConst, oIdAdd_True )
11213:    oNodeSet( t, qType, BooleanType )
11225:    oNodeSetInt( t, qValue, 1 )
11237:    oScopeDeclare( t )
      
11243:    t = @newIdent( nConst, oIdAdd_False )
11256:    oNodeSet( t, qType, BooleanType )
11268:    oNodeSetInt( t, qValue, 0 )
11280:    oScopeDeclare( t )
      
         % Built-in methods
         % These aren't declared like normal methods, because they may have
         % special rules for parameter types (e.g. any scalar type).
         % Calls to these methods will be handled specially by the compiler.
      
11286:    BuiltIn_Ord = @DeclareBuiltInFunc( oIdAdd_Ord )
11296:    BuiltIn_Chr = @DeclareBuiltInFunc( oIdAdd_Chr )
11306:    BuiltIn_Pred = @DeclareBuiltInFunc( oIdAdd_Pred )
11316:    BuiltIn_Succ = @DeclareBuiltInFunc( oIdAdd_Succ )
11327:    ;
      
11327: end
      
11327: 

Generated code:

   0: oGlobalSpace 19
   2: oLocalSpace 5
   4: oGetAddrGlobal 1
   6: oPushResult
   7: oWorkspaceNew
   8: oAssign
   9: oSetResult 0
  11: oPushResult
  12: oSetResult 0
  14: oPushResult
  15: oScopeBegin
  16: oPop 2
  18: oGetAddrLocal 2
  20: oPushResult
  21: oScopeCurrent
  22: oAssign
  23: oCall 10815
  25: oEmit 64
  27: oSetResult 0
  29: oPushResult
  30: oEmitInt
  31: oPop 1
  33: oGetAddrLocal 3
  35: oPushResult
  36: oLabelNew
  37: oAssign
  38: oEmit 58
  40: oSetResult 0
  42: oPushResult
  43: oEmitInt
  44: oPop 1
  46: oEmit 61
  48: oGetLocal 3
  50: oPushResult
  51: oEmitLabel
  52: oPop 1
  54: oEmit 60
  56: oSetResult 0
  58: oPushResult
  59: oEmitInt
  60: oPop 1
  62: oEmit 63
  64: oInput 28
  66: oInput 0
  68: oGetAddrLocal 4
  70: oPushResult
  71: oSetResult 4
  73: oPushResult
  74: oNodeNew
  75: oPop 1
  77: oAssign
  78: oGetLocal 4
  80: oPushResult
  81: oSetResult 4
  83: oPushResult
  84: LAST_ID
  85: oPushResult
  86: oNodeSetInt
  87: oPop 3
  89: oGetGlobal 1
  91: oPushResult
  92: oSetResult 2
  94: oPushResult
  95: oGetLocal 4
  97: oPushResult
  98: oNodeSet
  99: oPop 3
 101: oInputChoice 175
 103: oInput 0
 105: oGetAddrLocal 1
 107: oPushResult
 108: oSetResult 19
 110: oPushResult
 111: LAST_ID
 112: oPushResult
 113: oCall 10471
 115: oPop 2
 117: oAssign
 118: oGetLocal 1
 120: oPushResult
 121: oSetResult 21
 123: oPushResult
 124: oGetGlobal 5
 126: oPushResult
 127: oNodeSet
 128: oPop 3
 130: oGetLocal 1
 132: oPushResult
 133: oScopeDeclareAlloc
 134: oPop 1
 136: oInput 13
 138: oInput 0
 140: oGetAddrLocal 1
 142: oPushResult
 143: oSetResult 19
 145: oPushResult
 146: LAST_ID
 147: oPushResult
 148: oCall 10471
 150: oPop 2
 152: oAssign
 153: oGetLocal 1
 155: oPushResult
 156: oSetResult 21
 158: oPushResult
 159: oGetGlobal 5
 161: oPushResult
 162: oNodeSet
 163: oPop 3
 165: oGetLocal 1
 167: oPushResult
 168: oScopeDeclareAlloc
 169: oPop 1
 171: oInput 15
 173: oJumpForward 178
 175: Choice Lookup Table
          14    103
 178: oInput 5
 180: oGetLocal 4
 182: oPushResult
 183: oCall 333
 185: oPop 1
 187: oInputChoice 198
 189: oGetLocal 4
 191: oPushResult
 192: oCall 306
 194: oPop 1
 196: oJumpForward 201
 198: Choice Lookup Table
          57    189
 201: oGetLocal 4
 203: oPushResult
 204: oCall 509
 206: oPop 1
 208: oSetResult 0
 210: oPushResult
 211: oSetResult 0
 213: oPushResult
 214: oScopeBegin
 215: oPop 2
 217: oGetAddrGlobal 2
 219: oPushResult
 220: oScopeCurrent
 221: oAssign
 222: oSetResult 0
 224: oPushResult
 225: oSetResult 1
 227: oPushResult
 228: oScopeBegin
 229: oPop 2
 231: oScopeCurrent
 232: oPushResult
 233: oSetResult 16
 235: oPushResult
 236: oGetGlobal 2
 238: oPushResult
 239: oNodeSet
 240: oPop 3
 242: oGetAddrGlobal 3
 244: oPushResult
 245: oScopeCurrent
 246: oAssign
 247: oGetLocal 4
 249: oPushResult
 250: oSetResult 7
 252: oPushResult
 253: oGetGlobal 3
 255: oPushResult
 256: oNodeSet
 257: oPop 3
 259: oScopeEnd
 260: oSetResult 20
 262: oPushResult
 263: oCall 1459
 265: oPop 1
 267: oGetGlobal 3
 269: oPushResult
 270: oScopeEnter
 271: oPop 1
 273: oGetAddrLocal 5
 275: oPushResult
 276: oSetResult 1
 278: oAssign
 279: oGetLocal 3
 281: oPushResult
 282: oGetGlobal 2
 284: oPushResult
 285: oGetLocal 5
 287: oPushResult
 288: oCall 1780
 290: oPop 3
 292: oScopeEnd
 293: oInput 20
 295: oCall 1515
 297: oScopeEnd
 298: oGetLocal 4
 300: oPushResult
 301: oCall 571
 303: oPop 1
 305: oReturn
 306: oLocalSpace 0
 308: oInput 0
 310: LAST_ID
 311: oPushResult
 312: oGetParam 1
 314: oPushResult
 315: oCall 370
 317: oPop 2
 319: oInputChoice 323
 321: oJumpForward 328
 323: Choice Lookup Table
          13    321
 326: oJumpForward 330
 328: oJumpBack 308
 330: oInput 5
 332: oReturn
 333: oLocalSpace 0
 335: oGetParam 1
 337: oPushResult
 338: oSetResult 4
 340: oPushResult
 341: oNodeGetInt
 342: oPop 2
 344: oPushResult
 345: oGetGlobal 4
 347: oPushResult
 348: equal
 349: oPop 2
 351: oChoice 356
 353: oReturn
 354: oJumpForward 359
 356: Choice Lookup Table
           1    353
 359: oGetGlobal 4
 361: oPushResult
 362: oGetParam 1
 364: oPushResult
 365: oCall 370
 367: oPop 2
 369: oReturn
 370: oLocalSpace 2
 372: oGetAddrLocal 1
 374: oPushResult
 375: oGetParam 2
 377: oPushResult
 378: oCall 650
 380: oPop 1
 382: oAssign
 383: oGetLocal 1
 385: oPushResult
 386: oSetResult 0
 388: oPushResult
 389: equal_node
 390: oPop 2
 392: oChoice 462
 394: oGetParam 1
 396: oPushResult
 397: oSetResult 5
 399: oPushResult
 400: oGetLocal 1
 402: oPushResult
 403: oNodeAddLast
 404: oPop 3
 406: oGetAddrLocal 2
 408: oPushResult
 409: oSetResult 10
 411: oPushResult
 412: oNodeNew
 413: oPop 1
 415: oAssign
 416: oGetLocal 2
 418: oPushResult
 419: oSetResult 4
 421: oPushResult
 422: oGetLocal 1
 424: oPushResult
 425: oSetResult 4
 427: oPushResult
 428: oNodeGetInt
 429: oPop 2
 431: oPushResult
 432: oNodeSetInt
 433: oPop 3
 435: oGetLocal 2
 437: oPushResult
 438: oSetResult 9
 440: oPushResult
 441: oGetLocal 1
 443: oPushResult
 444: oSetResult 9
 446: oPushResult
 447: oNodeGet
 448: oPop 2
 450: oPushResult
 451: oNodeSet
 452: oPop 3
 454: oGetLocal 2
 456: oPushResult
 457: oScopeDeclare
 458: oPop 1
 460: oJumpForward 465
 462: Choice Lookup Table
           0    394
 465: oReturn
 466: oLocalSpace 1
 468: oGetFromParam 1
 470: oPushResult
 471: oNodeType
 472: oPop 1
 474: oChoice 505
 476: oGetAddrLocal 1
 478: oPushResult
 479: oGetFromParam 1
 481: oPushResult
 482: oSetResult 9
 484: oPushResult
 485: oNodeGet
 486: oPop 2
 488: oAssign
 489: oInput 20
 491: oInput 0
 493: oGetParam 1
 495: oPushResult
 496: oGetLocal 1
 498: oPushResult
 499: oScopeFindRequireInScope
 500: oPop 1
 502: oAssign
 503: oJumpForward 508
 505: Choice Lookup Table
          10    476
 508: oReturn
 509: oLocalSpace 2
 511: oGetAddrLocal 1
 513: oPushResult
 514: oGetParam 1
 516: oPushResult
 517: oSetResult 5
 519: oPushResult
 520: oNodeGetIter
 521: oPop 2
 523: oAssign
 524: oGetAddrLocal 2
 526: oPushResult
 527: oGetLocal 1
 529: oPushResult
 530: oNodeIterValue
 531: oPop 1
 533: oAssign
 534: oGetLocal 2
 536: oPushResult
 537: oNodeNull
 538: oPop 1
 540: oChoice 557
 542: oGetLocal 2
 544: oPushResult
 545: oSetResult 9
 547: oPushResult
 548: oNodeGet
 549: oPop 2
 551: oPushResult
 552: oScopeEnter
 553: oPop 1
 555: oJumpForward 562
 557: Choice Lookup Table
           0    542
 560: oJumpForward 570
 562: oGetAddrLocal 1
 564: oPushResult
 565: oNodeIterNext
 566: oPop 1
 568: oJumpBack 524
 570: oReturn
 571: oLocalSpace 2
 573: oGetAddrLocal 1
 575: oPushResult
 576: oGetParam 1
 578: oPushResult
 579: oSetResult 5
 581: oPushResult
 582: oNodeGetIterLast
 583: oPop 2
 585: oAssign
 586: oGetAddrLocal 2
 588: oPushResult
 589: oGetLocal 1
 591: oPushResult
 592: oNodeIterValue
 593: oPop 1
 595: oAssign
 596: oGetLocal 2
 598: oPushResult
 599: oNodeNull
 600: oPop 1
 602: oChoice 636
 604: oScopeCurrent
 605: oPushResult
 606: oGetLocal 2
 608: oPushResult
 609: oSetResult 9
 611: oPushResult
 612: oNodeGet
 613: oPop 2
 615: oPushResult
 616: oNodeEqual
 617: oPop 2
 619: oChoice 627
 621: oJumpForward 633
 623: oError 25
 625: oJumpForward 633
 627: Choice Lookup Table
           0    623
           1    621
 632: oEndChoice
 633: oScopeEnd
 634: oJumpForward 641
 636: Choice Lookup Table
           0    604
 639: oJumpForward 649
 641: oGetAddrLocal 1
 643: oPushResult
 644: oNodeIterPrev
 645: oPop 1
 647: oJumpBack 586
 649: oReturn
 650: oLocalSpace 2
 652: oGetAddrLocal 1
 654: oPushResult
 655: oGetGlobal 1
 657: oPushResult
 658: oSetResult 1
 660: oPushResult
 661: oSetResult 4
 663: oPushResult
 664: oGetParam 1
 666: oPushResult
 667: oNodeFind
 668: oPop 4
 670: oAssign
 671: oGetLocal 1
 673: oPushResult
 674: oSetResult 0
 676: oPushResult
 677: equal_node
 678: oPop 2
 680: oChoice 687
 682: oGetLocal 1
 684: oReturn
 685: oJumpForward 690
 687: Choice Lookup Table
           0    682
 690: oGetAddrLocal 2
 692: oPushResult
 693: oGetParam 1
 695: oPushResult
 696: oIncludeUnitFile
 697: oPop 1
 699: oAssign
 700: oGetLocal 2
 702: oChoice 711
 704: oError 24
 706: oSetResult 0
 708: oReturn
 709: oJumpForward 714
 711: Choice Lookup Table
           0    704
 714: oGetAddrLocal 1
 716: oPushResult
 717: oCall 725
 719: oAssign
 720: oIncludeEnd
 721: oGetLocal 1
 723: oReturn
 724: oReturn
 725: oLocalSpace 2
 727: oInput 58
 729: oInput 0
 731: oGetAddrLocal 1
 733: oPushResult
 734: oSetResult 5
 736: oPushResult
 737: oNodeNew
 738: oPop 1
 740: oAssign
 741: oGetLocal 1
 743: oPushResult
 744: oSetResult 4
 746: oPushResult
 747: LAST_ID
 748: oPushResult
 749: oNodeSetInt
 750: oPop 3
 752: oGetAddrLocal 2
 754: oPushResult
 755: oSetResult 6
 757: oPushResult
 758: oNodeNew
 759: oPop 1
 761: oAssign
 762: oGetLocal 2
 764: oPushResult
 765: oSetResult 4
 767: oPushResult
 768: LAST_ID
 769: oPushResult
 770: oNodeSetInt
 771: oPop 3
 773: oGetLocal 1
 775: oPushResult
 776: oSetResult 8
 778: oPushResult
 779: oGetLocal 2
 781: oPushResult
 782: oNodeSet
 783: oPop 3
 785: oInput 5
 787: oInput 59
 789: oGetLocal 1
 791: oPushResult
 792: oCall 333
 794: oPop 1
 796: oInputChoice 807
 798: oGetLocal 1
 800: oPushResult
 801: oCall 306
 803: oPop 1
 805: oJumpForward 810
 807: Choice Lookup Table
          57    798
 810: oGetLocal 1
 812: oPushResult
 813: oCall 509
 815: oPop 1
 817: oSetResult 0
 819: oPushResult
 820: oSetResult 0
 822: oPushResult
 823: oScopeBegin
 824: oPop 2
 826: oGetLocal 1
 828: oPushResult
 829: oSetResult 9
 831: oPushResult
 832: oScopeCurrent
 833: oPushResult
 834: oNodeSet
 835: oPop 3
 837: oGetAddrGlobal 2
 839: oPushResult
 840: oScopeCurrent
 841: oAssign
 842: oSetResult 0
 844: oPushResult
 845: oSetResult 1
 847: oPushResult
 848: oScopeBegin
 849: oPop 2
 851: oGetAddrGlobal 3
 853: oPushResult
 854: oScopeCurrent
 855: oAssign
 856: oGetLocal 1
 858: oPushResult
 859: oSetResult 13
 861: oPushResult
 862: oGetGlobal 3
 864: oPushResult
 865: oNodeSet
 866: oPop 3
 868: oScopeEnd
 869: oGetLocal 1
 871: oPushResult
 872: oCall 1060
 874: oPop 1
 876: oScopeEnd
 877: oInput 60
 879: oGetLocal 2
 881: oPushResult
 882: oCall 333
 884: oPop 1
 886: oInputChoice 897
 888: oGetLocal 2
 890: oPushResult
 891: oCall 306
 893: oPop 1
 895: oJumpForward 900
 897: Choice Lookup Table
          57    888
 900: oGetLocal 2
 902: oPushResult
 903: oCall 509
 905: oPop 1
 907: oGetLocal 1
 909: oPushResult
 910: oSetResult 9
 912: oPushResult
 913: oNodeGet
 914: oPop 2
 916: oPushResult
 917: oScopeEnter
 918: oPop 1
 920: oSetResult 0
 922: oPushResult
 923: oSetResult 0
 925: oPushResult
 926: oScopeBegin
 927: oPop 2
 929: oGetLocal 1
 931: oPushResult
 932: oSetResult 10
 934: oPushResult
 935: oScopeCurrent
 936: oPushResult
 937: oNodeSet
 938: oPop 3
 940: oScopeCurrent
 941: oPushResult
 942: oSetResult 16
 944: oPushResult
 945: oGetLocal 1
 947: oPushResult
 948: oSetResult 9
 950: oPushResult
 951: oNodeGet
 952: oPop 2
 954: oPushResult
 955: oNodeSet
 956: oPop 3
 958: oGetAddrGlobal 2
 960: oPushResult
 961: oScopeCurrent
 962: oAssign
 963: oGetLocal 1
 965: oPushResult
 966: oCall 1145
 968: oPop 1
 970: oInputChoice 984
 972: oGetLocal 1
 974: oPushResult
 975: oSetResult 1
 977: oPushResult
 978: oCall 1155
 980: oPop 2
 982: oJumpForward 997
 984: Choice Lookup Table
          61    972
 987: oGetLocal 1
 989: oPushResult
 990: oSetResult 0
 992: oPushResult
 993: oCall 1155
 995: oPop 2
 997: oInputChoice 1011
 999: oGetLocal 1
1001: oPushResult
1002: oSetResult 1
1004: oPushResult
1005: oCall 1341
1007: oPop 2
1009: oJumpForward 1024
1011: Choice Lookup Table
          62    999
1014: oGetLocal 1
1016: oPushResult
1017: oSetResult 0
1019: oPushResult
1020: oCall 1341
1022: oPop 2
1024: oInput 36
1026: oInput 20
1028: oScopeEnd
1029: oScopeEnd
1030: oGetLocal 2
1032: oPushResult
1033: oCall 571
1035: oPop 1
1037: oGetLocal 1
1039: oPushResult
1040: oCall 571
1042: oPop 1
1044: oGetGlobal 1
1046: oPushResult
1047: oSetResult 1
1049: oPushResult
1050: oGetLocal 1
1052: oPushResult
1053: oNodeAddLast
1054: oPop 3
1056: oGetLocal 1
1058: oReturn
1059: oReturn
1060: oLocalSpace 2
1062: oInputChoice 1129
1064: oCall 3053
1066: oJumpForward 1142
1068: oCall 3608
1070: oJumpForward 1142
1072: oSetResult 20
1074: oPushResult
1075: oCall 3664
1077: oPop 1
1079: oJumpForward 1142
1081: oGetAddrLocal 1
1083: oPushResult
1084: oCall 2020
1086: oAssign
1087: oInputChoice 1100
1089: oGetLocal 1
1091: oPushResult
1092: oCall 1958
1094: oPop 1
1096: oInput 5
1098: oJumpForward 1103
1100: Choice Lookup Table
          68   1089
1103: oJumpForward 1142
1105: oGetAddrLocal 2
1107: oPushResult
1108: oCall 2394
1110: oAssign
1111: oInputChoice 1124
1113: oGetLocal 2
1115: oPushResult
1116: oCall 1958
1118: oPop 1
1120: oInput 5
1122: oJumpForward 1127
1124: Choice Lookup Table
          68   1113
1127: oJumpForward 1142
1129: Choice Lookup Table
          30   1105
          29   1081
          33   1072
          32   1068
          31   1064
1140: oJumpForward 1144
1142: oJumpBack 1062
1144: oReturn
1145: oLocalSpace 0
1147: oSetResult 20
1149: oPushResult
1150: oCall 1459
1152: oPop 1
1154: oReturn
1155: oLocalSpace 5
1157: oGetAddrLocal 1
1159: oPushResult
1160: oLabelNew
1161: oAssign
1162: oEmit 68
1164: oGetLocal 1
1166: oPushResult
1167: oEmitLabel
1168: oPop 1
1170: oGetParam 2
1172: oPushResult
1173: oSetResult 11
1175: oPushResult
1176: oGetLocal 1
1178: oPushResult
1179: oNodeSetLabel
1180: oPop 3
1182: oEmit 64
1184: oGetAddrLocal 2
1186: oPushResult
1187: Here
1188: oAssign
1189: oEmit 79
1191: oGetAddrLocal 3
1193: oPushResult
1194: oGetParam 2
1196: oPushResult
1197: oSetResult 9
1199: oPushResult
1200: oNodeGet
1201: oPop 2
1203: oAssign
1204: oGetAddrLocal 4
1206: oPushResult
1207: oGetLocal 3
1209: oPushResult
1210: oSetResult 19
1212: oPushResult
1213: oNodeGetCode
1214: oPop 2
1216: oAssign
1217: oGetLocal 4
1219: oPushResult
1220: oEmitCode
1221: oPop 1
1223: oGetLocal 3
1225: oPushResult
1226: oSetResult 19
1228: oPushResult
1229: oSetResult 0
1231: oPushResult
1232: oNodeSetCode
1233: oPop 3
1235: oGetAddrLocal 3
1237: oPushResult
1238: oGetParam 2
1240: oPushResult
1241: oSetResult 10
1243: oPushResult
1244: oNodeGet
1245: oPop 2
1247: oAssign
1248: oGetAddrLocal 4
1250: oPushResult
1251: oGetLocal 3
1253: oPushResult
1254: oSetResult 19
1256: oPushResult
1257: oNodeGetCode
1258: oPop 2
1260: oAssign
1261: oGetLocal 4
1263: oPushResult
1264: oEmitCode
1265: oPop 1
1267: oGetLocal 3
1269: oPushResult
1270: oSetResult 19
1272: oPushResult
1273: oSetResult 0
1275: oPushResult
1276: oNodeSetCode
1277: oPop 3
1279: oGetParam 2
1281: oPushResult
1282: oSetResult 13
1284: oPushResult
1285: oNodeGet
1286: oPop 2
1288: oPushResult
1289: oScopeEnter
1290: oPop 1
1292: oGetParam 1
1294: oChoice 1313
1296: oCall 8904
1298: oInputChoice 1304
1300: oCall 8904
1302: oJumpForward 1309
1304: Choice Lookup Table
           5   1300
1307: oJumpForward 1311
1309: oJumpBack 1298
1311: oJumpForward 1316
1313: Choice Lookup Table
           1   1296
1316: oEmit 63
1318: oGetAddrLocal 5
1320: oPushResult
1321: oScopeCurrent
1322: oPushResult
1323: oSetResult 17
1325: oPushResult
1326: oNodeGetInt
1327: oPop 2
1329: oAssign
1330: oGetLocal 2
1332: oPushResult
1333: oGetLocal 5
1335: oPushResult
1336: oPatch
1337: oPop 2
1339: oScopeEnd
1340: oReturn
1341: oLocalSpace 3
1343: oGetAddrLocal 1
1345: oPushResult
1346: oLabelNew
1347: oAssign
1348: oEmit 68
1350: oGetLocal 1
1352: oPushResult
1353: oEmitLabel
1354: oPop 1
1356: oGetParam 2
1358: oPushResult
1359: oSetResult 12
1361: oPushResult
1362: oGetLocal 1
1364: oPushResult
1365: oNodeSetLabel
1366: oPop 3
1368: oEmit 64
1370: oGetAddrLocal 2
1372: oPushResult
1373: Here
1374: oAssign
1375: oEmit 79
1377: oSetResult 0
1379: oPushResult
1380: oSetResult 1
1382: oPushResult
1383: oScopeBegin
1384: oPop 2
1386: oGetParam 1
1388: oChoice 1407
1390: oCall 8904
1392: oInputChoice 1398
1394: oCall 8904
1396: oJumpForward 1403
1398: Choice Lookup Table
           5   1394
1401: oJumpForward 1405
1403: oJumpBack 1392
1405: oJumpForward 1410
1407: Choice Lookup Table
           1   1390
1410: oEmit 63
1412: oGetAddrLocal 3
1414: oPushResult
1415: oScopeCurrent
1416: oPushResult
1417: oSetResult 17
1419: oPushResult
1420: oNodeGetInt
1421: oPop 2
1423: oAssign
1424: oGetLocal 2
1426: oPushResult
1427: oGetLocal 3
1429: oPushResult
1430: oPatch
1431: oPop 2
1433: oScopeEnd
1434: oReturn
1435: oLocalSpace 0
1437: oGetParam 2
1439: oPushResult
1440: oCall 1459
1442: oPop 1
1444: oGetParam 1
1446: oPushResult
1447: oScopeCurrent
1448: oPushResult
1449: oSetResult 0
1451: oPushResult
1452: oCall 1780
1454: oPop 3
1456: oCall 1515
1458: oReturn
1459: oLocalSpace 0
1461: oInputChoice 1492
1463: oCall 3053
1465: oJumpForward 1507
1467: oCall 3608
1469: oJumpForward 1507
1471: oGetParam 1
1473: oPushResult
1474: oCall 3664
1476: oPop 1
1478: oJumpForward 1507
1480: oCall 3898
1482: oJumpForward 1507
1484: oCall 2276
1486: oJumpForward 1507
1488: oCall 2711
1490: oJumpForward 1507
1492: Choice Lookup Table
          30   1488
          29   1484
          34   1480
          33   1471
          32   1467
          31   1463
1505: oJumpForward 1509
1507: oJumpBack 1461
1509: oCall 1512
1511: oReturn
1512: oLocalSpace 0
1514: oReturn
1515: oLocalSpace 2
1517: oGetAddrLocal 1
1519: oPushResult
1520: oScopeCurrent
1521: oPushResult
1522: oSetResult 15
1524: oPushResult
1525: oNodeGetIter
1526: oPop 2
1528: oAssign
1529: oGetAddrLocal 2
1531: oPushResult
1532: oGetLocal 1
1534: oPushResult
1535: oNodeIterValue
1536: oPop 1
1538: oAssign
1539: oGetLocal 2
1541: oPushResult
1542: oNodeNull
1543: oPop 1
1545: oChoice 1549
1547: oJumpForward 1554
1549: Choice Lookup Table
           0   1547
1552: oJumpForward 1609
1554: oGetLocal 2
1556: oPushResult
1557: oNodeType
1558: oPop 1
1560: oChoice 1598
1562: oGetLocal 2
1564: oPushResult
1565: oSetResult 34
1567: oPushResult
1568: oNodeGetBoolean
1569: oPop 2
1571: oChoice 1593
1573: oGetLocal 2
1575: oPushResult
1576: oSetResult 28
1578: oPushResult
1579: oNodeGetBoolean
1580: oPop 2
1582: oChoice 1588
1584: oError 27
1586: oJumpForward 1591
1588: Choice Lookup Table
           1   1584
1591: oJumpForward 1596
1593: Choice Lookup Table
           0   1573
1596: oJumpForward 1601
1598: Choice Lookup Table
          25   1562
1601: oGetAddrLocal 1
1603: oPushResult
1604: oNodeIterNext
1605: oPop 1
1607: oJumpBack 1529
1609: oReturn
1610: oLocalSpace 2
1612: oGetAddrLocal 1
1614: oPushResult
1615: oGetGlobal 1
1617: oPushResult
1618: oSetResult 1
1620: oPushResult
1621: oNodeGetIter
1622: oPop 2
1624: oAssign
1625: oGetAddrLocal 2
1627: oPushResult
1628: oGetLocal 1
1630: oPushResult
1631: oNodeIterValue
1632: oPop 1
1634: oAssign
1635: oGetLocal 2
1637: oPushResult
1638: oNodeNull
1639: oPop 1
1641: oChoice 1686
1643: oJumpForward 1694
1645: oJumpForward 1692
1647: oEmit 58
1649: oSetResult 0
1651: oPushResult
1652: oEmitInt
1653: oPop 1
1655: oEmit 61
1657: oGetLocal 2
1659: oPushResult
1660: oSetResult 11
1662: oPushResult
1663: oNodeGetLabel
1664: oPop 2
1666: oPushResult
1667: oEmitLabel
1668: oPop 1
1670: oEmit 60
1672: oSetResult 0
1674: oPushResult
1675: oEmitInt
1676: oPop 1
1678: oGetAddrLocal 1
1680: oPushResult
1681: oNodeIterNext
1682: oPop 1
1684: oJumpForward 1692
1686: Choice Lookup Table
           0   1647
           1   1643
1691: oEndChoice
1692: oJumpBack 1625
1694: oReturn
1695: oLocalSpace 2
1697: oGetAddrLocal 1
1699: oPushResult
1700: oGetGlobal 1
1702: oPushResult
1703: oSetResult 1
1705: oPushResult
1706: oNodeGetIterLast
1707: oPop 2
1709: oAssign
1710: oGetAddrLocal 2
1712: oPushResult
1713: oGetLocal 1
1715: oPushResult
1716: oNodeIterValue
1717: oPop 1
1719: oAssign
1720: oGetLocal 2
1722: oPushResult
1723: oNodeNull
1724: oPop 1
1726: oChoice 1771
1728: oJumpForward 1779
1730: oJumpForward 1777
1732: oEmit 58
1734: oSetResult 0
1736: oPushResult
1737: oEmitInt
1738: oPop 1
1740: oEmit 61
1742: oGetLocal 2
1744: oPushResult
1745: oSetResult 12
1747: oPushResult
1748: oNodeGetLabel
1749: oPop 2
1751: oPushResult
1752: oEmitLabel
1753: oPop 1
1755: oEmit 60
1757: oSetResult 0
1759: oPushResult
1760: oEmitInt
1761: oPop 1
1763: oGetAddrLocal 1
1765: oPushResult
1766: oNodeIterPrev
1767: oPop 1
1769: oJumpForward 1777
1771: Choice Lookup Table
           0   1732
           1   1728
1776: oEndChoice
1777: oJumpBack 1710
1779: oReturn
1780: oLocalSpace 3
1782: oEmit 68
1784: oGetParam 3
1786: oPushResult
1787: oEmitLabel
1788: oPop 1
1790: oEmit 64
1792: oGetAddrLocal 1
1794: oPushResult
1795: Here
1796: oAssign
1797: oEmit 79
1799: oGetParam 1
1801: oChoice 1807
1803: oCall 1610
1805: oJumpForward 1810
1807: Choice Lookup Table
           1   1803
1810: oGetAddrLocal 2
1812: oPushResult
1813: oGetParam 2
1815: oPushResult
1816: oSetResult 19
1818: oPushResult
1819: oNodeGetCode
1820: oPop 2
1822: oAssign
1823: oGetLocal 2
1825: oPushResult
1826: oEmitCode
1827: oPop 1
1829: oGetParam 2
1831: oPushResult
1832: oSetResult 19
1834: oPushResult
1835: oSetResult 0
1837: oPushResult
1838: oNodeSetCode
1839: oPop 3
1841: oCall 8904
1843: oGetParam 1
1845: oChoice 1851
1847: oCall 1695
1849: oJumpForward 1854
1851: Choice Lookup Table
           1   1847
1854: oEmit 63
1856: oGetAddrLocal 3
1858: oPushResult
1859: oScopeCurrent
1860: oPushResult
1861: oSetResult 17
1863: oPushResult
1864: oNodeGetInt
1865: oPop 2
1867: oAssign
1868: oGetLocal 1
1870: oPushResult
1871: oGetLocal 3
1873: oPushResult
1874: oPatch
1875: oPop 2
1877: oReturn
1878: oLocalSpace 0
1880: oInputChoice 1898
1882: oGetParam 1
1884: oPushResult
1885: oSetResult 27
1887: oPushResult
1888: oSetResult 1
1890: oPushResult
1891: oNodeSetBoolean
1892: oPop 3
1894: oInput 5
1896: oJumpForward 1903
1898: Choice Lookup Table
          70   1882
1901: oJumpForward 1905
1903: oJumpBack 1880
1905: oReturn
1906: oLocalSpace 1
1908: oGetAddrLocal 1
1910: oPushResult
1911: oGetParam 1
1913: oPushResult
1914: oSetResult 19
1916: oPushResult
1917: oNodeGetCode
1918: oPop 2
1920: oAssign
1921: oGetLocal 1
1923: oPushResult
1924: oSetResult 0
1926: oPushResult
1927: equal_code
1928: oPop 2
1930: oChoice 1951
1932: oGetAddrLocal 1
1934: oPushResult
1935: oCodeNew
1936: oAssign
1937: oGetParam 1
1939: oPushResult
1940: oSetResult 19
1942: oPushResult
1943: oGetLocal 1
1945: oPushResult
1946: oNodeSetCode
1947: oPop 3
1949: oJumpForward 1954
1951: Choice Lookup Table
           1   1932
1954: oGetLocal 1
1956: oReturn
1957: oReturn
1958: oLocalSpace 0
1960: oGetParam 1
1962: oPushResult
1963: oCall 10221
1965: oPop 1
1967: oPushResult
1968: equal_zero
1969: oPop 1
1971: oChoice 1977
1973: oError 23
1975: oJumpForward 1980
1977: Choice Lookup Table
           0   1973
1980: oGetParam 1
1982: oPushResult
1983: oSetResult 25
1985: oPushResult
1986: oSetResult 1
1988: oPushResult
1989: oNodeSetBoolean
1990: oPop 3
1992: oInputChoice 2016
1994: oInputChoice 2011
1996: oInput 2
1998: oGetParam 1
2000: oPushResult
2001: oSetResult 26
2003: oPushResult
2004: CURRENT_STRLIT
2005: oPushResult
2006: oNodeSetString
2007: oPop 3
2009: oJumpForward 2014
2011: Choice Lookup Table
          69   1996
2014: oJumpForward 2019
2016: Choice Lookup Table
           2   1994
2019: oReturn
2020: oLocalSpace 6
2022: oInput 0
2024: oGetAddrLocal 1
2026: oPushResult
2027: oSetResult 0
2029: oAssign
2030: oGetAddrLocal 2
2032: oPushResult
2033: oScopeFindInCurrentScope
2034: oAssign
2035: oGetLocal 2
2037: oPushResult
2038: oNodeNull
2039: oPop 1
2041: oChoice 2159
2043: oGetAddrLocal 2
2045: oPushResult
2046: oSetResult 12
2048: oPushResult
2049: LAST_ID
2050: oPushResult
2051: oCall 10471
2053: oPop 2
2055: oAssign
2056: oGetLocal 2
2058: oPushResult
2059: oSetResult 22
2061: oPushResult
2062: oLabelNew
2063: oPushResult
2064: oNodeSetLabel
2065: oPop 3
2067: oJumpForward 2165
2069: oGetAddrLocal 1
2071: oPushResult
2072: oSetResult 1
2074: oAssign
2075: oGetLocal 2
2077: oPushResult
2078: oSetResult 24
2080: oPushResult
2081: oNodeGetBoolean
2082: oPop 2
2084: oChoice 2090
2086: oError 21
2088: oJumpForward 2093
2090: Choice Lookup Table
           1   2086
2093: oGetLocal 2
2095: oPushResult
2096: oSetResult 25
2098: oPushResult
2099: oNodeGetBoolean
2100: oPop 2
2102: oChoice 2108
2104: oError 21
2106: oJumpForward 2111
2108: Choice Lookup Table
           1   2104
2111: oGetLocal 2
2113: oPushResult
2114: oNodeType
2115: oPop 1
2117: oChoice 2121
2119: oJumpForward 2126
2121: Choice Lookup Table
          12   2119
2124: oError 21
2126: oGetLocal 2
2128: oPushResult
2129: oSetResult 29
2131: oPushResult
2132: oGetLocal 2
2134: oPushResult
2135: oSetResult 23
2137: oPushResult
2138: oNodeGet
2139: oPop 2
2141: oPushResult
2142: oNodeSet
2143: oPop 3
2145: oGetLocal 2
2147: oPushResult
2148: oSetResult 23
2150: oPushResult
2151: oSetResult 0
2153: oPushResult
2154: oNodeSet
2155: oPop 3
2157: oJumpForward 2165
2159: Choice Lookup Table
           0   2069
           1   2043
2164: oEndChoice
2165: oGetAddrLocal 3
2167: oPushResult
2168: oCall 10209
2170: oAssign
2171: oGetAddrLocal 4
2173: oPushResult
2174: oGetLocal 3
2176: oPushResult
2177: oSetResult 0
2179: oPushResult
2180: greater
2181: oPop 2
2183: oAssign
2184: oGetAddrLocal 3
2186: oPushResult
2187: inc
2188: oPop 1
2190: oGetLocal 3
2192: oPushResult
2193: oSetResult 2
2195: oPushResult
2196: oScopeBegin
2197: oPop 2
2199: oGetAddrLocal 5
2201: oPushResult
2202: oScopeCurrent
2203: oAssign
2204: oGetLocal 4
2206: oChoice 2225
2208: oGetAddrLocal 6
2210: oPushResult
2211: oGetGlobal 6
2213: oPushResult
2214: oCall 10499
2216: oPop 1
2218: oPushResult
2219: oScopeAllocType
2220: oPop 1
2222: oAssign
2223: oJumpForward 2228
2225: Choice Lookup Table
           1   2208
2228: oCall 2829
2230: oGetLocal 2
2232: oPushResult
2233: oSetResult 23
2235: oPushResult
2236: oGetLocal 5
2238: oPushResult
2239: oNodeSet
2240: oPop 3
2242: oScopeEnd
2243: oInput 5
2245: oGetLocal 1
2247: oChoice 2259
2249: oGetLocal 2
2251: oPushResult
2252: oScopeDeclare
2253: oPop 1
2255: oJumpForward 2265
2257: oJumpForward 2265
2259: Choice Lookup Table
           1   2257
           0   2249
2264: oEndChoice
2265: oGetLocal 2
2267: oPushResult
2268: oCall 1878
2270: oPop 1
2272: oGetLocal 2
2274: oReturn
2275: oReturn
2276: oLocalSpace 4
2278: oGetAddrLocal 1
2280: oPushResult
2281: oCall 2020
2283: oAssign
2284: oInputChoice 2297
2286: oJumpForward 2391
2288: oGetLocal 1
2290: oPushResult
2291: oCall 1958
2293: oPop 1
2295: oJumpForward 2391
2297: Choice Lookup Table
          68   2288
          67   2286
2302: oGetAddrLocal 2
2304: oPushResult
2305: oGetLocal 1
2307: oPushResult
2308: oSetResult 23
2310: oPushResult
2311: oNodeGet
2312: oPop 2
2314: oAssign
2315: oGetLocal 2
2317: oPushResult
2318: oScopeEnter
2319: oPop 1
2321: oGetAddrLocal 3
2323: oPushResult
2324: oGetLocal 2
2326: oPushResult
2327: oSetResult 14
2329: oPushResult
2330: oNodeGetInt
2331: oPop 2
2333: oAssign
2334: oGetLocal 3
2336: oPushResult
2337: oSetResult 1
2339: oPushResult
2340: oScopeBegin
2341: oPop 2
2343: oGetLocal 1
2345: oPushResult
2346: oSetResult 6
2348: oPushResult
2349: oScopeCurrent
2350: oPushResult
2351: oNodeSet
2352: oPop 3
2354: oGetAddrLocal 4
2356: oPushResult
2357: oGetLocal 1
2359: oPushResult
2360: oSetResult 22
2362: oPushResult
2363: oNodeGetLabel
2364: oPop 2
2366: oAssign
2367: oSetResult 21
2369: oPushResult
2370: oGetLocal 4
2372: oPushResult
2373: oCall 1435
2375: oPop 2
2377: oGetLocal 1
2379: oPushResult
2380: oSetResult 24
2382: oPushResult
2383: oSetResult 1
2385: oPushResult
2386: oNodeSetBoolean
2387: oPop 3
2389: oScopeEnd
2390: oScopeEnd
2391: oInput 5
2393: oReturn
2394: oLocalSpace 8
2396: oInput 0
2398: oGetAddrLocal 1
2400: oPushResult
2401: oSetResult 0
2403: oAssign
2404: oGetAddrLocal 2
2406: oPushResult
2407: oScopeFindInCurrentScope
2408: oAssign
2409: oGetLocal 2
2411: oPushResult
2412: oNodeNull
2413: oPop 1
2415: oChoice 2546
2417: oGetAddrLocal 2
2419: oPushResult
2420: oSetResult 13
2422: oPushResult
2423: LAST_ID
2424: oPushResult
2425: oCall 10471
2427: oPop 2
2429: oAssign
2430: oGetLocal 2
2432: oPushResult
2433: oSetResult 22
2435: oPushResult
2436: oLabelNew
2437: oPushResult
2438: oNodeSetLabel
2439: oPop 3
2441: oJumpForward 2552
2443: oGetAddrLocal 1
2445: oPushResult
2446: oSetResult 1
2448: oAssign
2449: oGetLocal 2
2451: oPushResult
2452: oSetResult 24
2454: oPushResult
2455: oNodeGetBoolean
2456: oPop 2
2458: oChoice 2464
2460: oError 21
2462: oJumpForward 2467
2464: Choice Lookup Table
           1   2460
2467: oGetLocal 2
2469: oPushResult
2470: oNodeType
2471: oPop 1
2473: oChoice 2477
2475: oJumpForward 2482
2477: Choice Lookup Table
          13   2475
2480: oError 21
2482: oGetLocal 2
2484: oPushResult
2485: oSetResult 29
2487: oPushResult
2488: oGetLocal 2
2490: oPushResult
2491: oSetResult 23
2493: oPushResult
2494: oNodeGet
2495: oPop 2
2497: oPushResult
2498: oNodeSet
2499: oPop 3
2501: oGetLocal 2
2503: oPushResult
2504: oSetResult 23
2506: oPushResult
2507: oSetResult 0
2509: oPushResult
2510: oNodeSet
2511: oPop 3
2513: oGetLocal 2
2515: oPushResult
2516: oSetResult 30
2518: oPushResult
2519: oGetLocal 2
2521: oPushResult
2522: oSetResult 21
2524: oPushResult
2525: oNodeGet
2526: oPop 2
2528: oPushResult
2529: oNodeSet
2530: oPop 3
2532: oGetLocal 2
2534: oPushResult
2535: oSetResult 21
2537: oPushResult
2538: oSetResult 0
2540: oPushResult
2541: oNodeSet
2542: oPop 3
2544: oJumpForward 2552
2546: Choice Lookup Table
           0   2443
           1   2417
2551: oEndChoice
2552: oGetAddrLocal 3
2554: oPushResult
2555: oCall 10209
2557: oAssign
2558: oGetAddrLocal 4
2560: oPushResult
2561: oGetLocal 3
2563: oPushResult
2564: oSetResult 0
2566: oPushResult
2567: greater
2568: oPop 2
2570: oAssign
2571: oGetAddrLocal 3
2573: oPushResult
2574: inc
2575: oPop 1
2577: oGetLocal 3
2579: oPushResult
2580: oSetResult 2
2582: oPushResult
2583: oScopeBegin
2584: oPop 2
2586: oGetAddrLocal 5
2588: oPushResult
2589: oScopeCurrent
2590: oAssign
2591: oGetLocal 4
2593: oChoice 2612
2595: oGetAddrLocal 6
2597: oPushResult
2598: oGetGlobal 6
2600: oPushResult
2601: oCall 10499
2603: oPop 1
2605: oPushResult
2606: oScopeAllocType
2607: oPop 1
2609: oAssign
2610: oJumpForward 2615
2612: Choice Lookup Table
           1   2595
2615: oCall 2829
2617: oGetLocal 2
2619: oPushResult
2620: oSetResult 23
2622: oPushResult
2623: oGetLocal 5
2625: oPushResult
2626: oNodeSet
2627: oPop 3
2629: oInput 12
2631: oGetAddrLocal 7
2633: oPushResult
2634: oCall 3963
2636: oPop 1
2638: oGetLocal 2
2640: oPushResult
2641: oSetResult 21
2643: oPushResult
2644: oGetLocal 7
2646: oPushResult
2647: oNodeSet
2648: oPop 3
2650: oGetAddrLocal 8
2652: oPushResult
2653: oGetLocal 7
2655: oPushResult
2656: oCall 10499
2658: oPop 1
2660: oAssign
2661: oGetLocal 2
2663: oPushResult
2664: oSetResult 31
2666: oPushResult
2667: oGetLocal 8
2669: oPushResult
2670: oScopeAllocType
2671: oPop 1
2673: oPushResult
2674: oNodeSetInt
2675: oPop 3
2677: oScopeEnd
2678: oInput 5
2680: oGetLocal 1
2682: oChoice 2694
2684: oGetLocal 2
2686: oPushResult
2687: oScopeDeclare
2688: oPop 1
2690: oJumpForward 2700
2692: oJumpForward 2700
2694: Choice Lookup Table
           1   2692
           0   2684
2699: oEndChoice
2700: oGetLocal 2
2702: oPushResult
2703: oCall 1878
2705: oPop 1
2707: oGetLocal 2
2709: oReturn
2710: oReturn
2711: oLocalSpace 4
2713: oGetAddrLocal 1
2715: oPushResult
2716: oCall 2394
2718: oAssign
2719: oInputChoice 2732
2721: oJumpForward 2826
2723: oGetLocal 1
2725: oPushResult
2726: oCall 1958
2728: oPop 1
2730: oJumpForward 2826
2732: Choice Lookup Table
          68   2723
          67   2721
2737: oGetAddrLocal 2
2739: oPushResult
2740: oGetLocal 1
2742: oPushResult
2743: oSetResult 23
2745: oPushResult
2746: oNodeGet
2747: oPop 2
2749: oAssign
2750: oGetLocal 2
2752: oPushResult
2753: oScopeEnter
2754: oPop 1
2756: oGetAddrLocal 3
2758: oPushResult
2759: oGetLocal 2
2761: oPushResult
2762: oSetResult 14
2764: oPushResult
2765: oNodeGetInt
2766: oPop 2
2768: oAssign
2769: oGetLocal 3
2771: oPushResult
2772: oSetResult 1
2774: oPushResult
2775: oScopeBegin
2776: oPop 2
2778: oGetLocal 1
2780: oPushResult
2781: oSetResult 6
2783: oPushResult
2784: oScopeCurrent
2785: oPushResult
2786: oNodeSet
2787: oPop 3
2789: oGetAddrLocal 4
2791: oPushResult
2792: oGetLocal 1
2794: oPushResult
2795: oSetResult 22
2797: oPushResult
2798: oNodeGetLabel
2799: oPop 2
2801: oAssign
2802: oSetResult 21
2804: oPushResult
2805: oGetLocal 4
2807: oPushResult
2808: oCall 1435
2810: oPop 2
2812: oGetLocal 1
2814: oPushResult
2815: oSetResult 24
2817: oPushResult
2818: oSetResult 1
2820: oPushResult
2821: oNodeSetBoolean
2822: oPop 3
2824: oScopeEnd
2825: oScopeEnd
2826: oInput 5
2828: oReturn
2829: oLocalSpace 6
2831: oInputChoice 3049
2833: oGetAddrLocal 1
2835: oPushResult
2836: oNodeVecNew
2837: oAssign
2838: oGetAddrLocal 3
2840: oPushResult
2841: oSetResult 0
2843: oAssign
2844: oInputChoice 2854
2846: oGetAddrLocal 3
2848: oPushResult
2849: oSetResult 1
2851: oAssign
2852: oJumpForward 2857
2854: Choice Lookup Table
          33   2846
2857: oInput 0
2859: oGetAddrLocal 2
2861: oPushResult
2862: oSetResult 23
2864: oPushResult
2865: LAST_ID
2866: oPushResult
2867: oCall 10471
2869: oPop 2
2871: oAssign
2872: oGetLocal 2
2874: oPushResult
2875: oSetResult 33
2877: oPushResult
2878: oGetLocal 3
2880: oPushResult
2881: oNodeSetBoolean
2882: oPop 3
2884: oGetLocal 1
2886: oPushResult
2887: oGetLocal 2
2889: oPushResult
2890: oNodeVecAppend
2891: oPop 2
2893: oInputChoice 2901
2895: oJumpForward 2909
2897: oJumpForward 2907
2899: oJumpForward 2907
2901: Choice Lookup Table
          13   2899
          12   2895
2906: oEndChoice
2907: oJumpBack 2857
2909: oGetAddrLocal 4
2911: oPushResult
2912: oCall 3963
2914: oPop 1
2916: oGetLocal 3
2918: oChoice 2933
2920: oGetAddrLocal 5
2922: oPushResult
2923: oGetLocal 4
2925: oPushResult
2926: oCall 10499
2928: oPop 1
2930: oAssign
2931: oJumpForward 2942
2933: Choice Lookup Table
           1   2920
2936: oGetAddrLocal 5
2938: oPushResult
2939: oGetLocal 4
2941: oAssign
2942: oGetAddrLocal 6
2944: oPushResult
2945: oSetResult 0
2947: oAssign
2948: oGetLocal 6
2950: oPushResult
2951: oGetLocal 1
2953: oPushResult
2954: oNodeVecSize
2955: oPop 1
2957: oPushResult
2958: equal
2959: oPop 2
2961: oChoice 3018
2963: oGetAddrLocal 2
2965: oPushResult
2966: oGetLocal 1
2968: oPushResult
2969: oGetLocal 6
2971: oPushResult
2972: oNodeVecElement
2973: oPop 2
2975: oAssign
2976: oGetLocal 2
2978: oPushResult
2979: oSetResult 21
2981: oPushResult
2982: oGetLocal 4
2984: oPushResult
2985: oNodeSet
2986: oPop 3
2988: oGetLocal 2
2990: oPushResult
2991: oScopeDeclare
2992: oPop 1
2994: oGetLocal 2
2996: oPushResult
2997: oSetResult 22
2999: oPushResult
3000: oGetLocal 5
3002: oPushResult
3003: oScopeAllocType
3004: oPop 1
3006: oPushResult
3007: oNodeSetInt
3008: oPop 3
3010: oGetAddrLocal 6
3012: oPushResult
3013: inc
3014: oPop 1
3016: oJumpForward 3023
3018: Choice Lookup Table
           0   2963
3021: oJumpForward 3025
3023: oJumpBack 2948
3025: oGetLocal 1
3027: oPushResult
3028: oNodeVecDelete
3029: oPop 1
3031: oInputChoice 3039
3033: oJumpForward 3047
3035: oJumpForward 3045
3037: oJumpForward 3045
3039: Choice Lookup Table
           5   3037
          15   3033
3044: oEndChoice
3045: oJumpBack 2833
3047: oJumpForward 3052
3049: Choice Lookup Table
          14   2833
3052: oReturn
3053: oLocalSpace 0
3055: oInputChoice 3070
3057: oInputChoice 3063
3059: oCall 3136
3061: oJumpForward 3068
3063: Choice Lookup Table
          12   3059
3066: oCall 3078
3068: oJumpForward 3075
3070: Choice Lookup Table
           0   3057
3073: oJumpForward 3077
3075: oJumpBack 3055
3077: oReturn
3078: oLocalSpace 2
3080: oGetAddrLocal 1
3082: oPushResult
3083: oSetResult 16
3085: oPushResult
3086: LAST_ID
3087: oPushResult
3088: oCall 10471
3090: oPop 2
3092: oAssign
3093: oInput 6
3095: oCall 5019
3097: oGetAddrLocal 2
3099: oPushResult
3100: oValueTop
3101: oAssign
3102: oValuePop
3103: oGetLocal 1
3105: oPushResult
3106: oSetResult 22
3108: oPushResult
3109: oGetLocal 2
3111: oPushResult
3112: oNodeSetInt
3113: oPop 3
3115: oGetLocal 1
3117: oPushResult
3118: oSetResult 21
3120: oPushResult
3121: oGetGlobal 6
3123: oPushResult
3124: oNodeSet
3125: oPop 3
3127: oGetLocal 1
3129: oPushResult
3130: oScopeDeclare
3131: oPop 1
3133: oInput 5
3135: oReturn
3136: oLocalSpace 4
3138: oGetAddrLocal 1
3140: oPushResult
3141: oSetResult 24
3143: oPushResult
3144: LAST_ID
3145: oPushResult
3146: oCall 10471
3148: oPop 2
3150: oAssign
3151: oGetAddrLocal 2
3153: oPushResult
3154: oCall 3963
3156: oPop 1
3158: oGetLocal 1
3160: oPushResult
3161: oSetResult 21
3163: oPushResult
3164: oGetLocal 2
3166: oPushResult
3167: oNodeSet
3168: oPop 3
3170: oGetLocal 2
3172: oPushResult
3173: oNodeType
3174: oPop 1
3176: oChoice 3277
3178: oInput 6
3180: oCall 5019
3182: oGetAddrLocal 3
3184: oPushResult
3185: oValueTop
3186: oAssign
3187: oValuePop
3188: oGetLocal 1
3190: oPushResult
3191: oSetResult 22
3193: oPushResult
3194: oGetLocal 3
3196: oPushResult
3197: oNodeSetInt
3198: oPop 3
3200: oGetLocal 1
3202: oPushResult
3203: oScopeDeclare
3204: oPop 1
3206: oInput 5
3208: oJumpForward 3301
3210: oError 16
3212: oJumpForward 3301
3214: oGetGlobal 2
3216: oPushResult
3217: oScopeEnter
3218: oPop 1
3220: oGetAddrLocal 4
3222: oPushResult
3223: oGetLocal 2
3225: oPushResult
3226: oScopeAllocType
3227: oPop 1
3229: oAssign
3230: oScopeEnd
3231: oGetGlobal 2
3233: oPushResult
3234: oCall 1906
3236: oPop 1
3238: oPushResult
3239: oCodePush
3240: oPop 1
3242: oGetLocal 1
3244: oPushResult
3245: oSetResult 22
3247: oPushResult
3248: oGetLocal 4
3250: oPushResult
3251: oNodeSetInt
3252: oPop 3
3254: oInput 6
3256: oGetLocal 2
3258: oPushResult
3259: oGetLocal 4
3261: oPushResult
3262: oCall 3302
3264: oPop 2
3266: oCodePop
3267: oGetLocal 1
3269: oPushResult
3270: oScopeDeclare
3271: oPop 1
3273: oInput 5
3275: oJumpForward 3301
3277: Choice Lookup Table
          37   3214
          35   3214
          34   3210
          33   3210
          27   3210
          39   3210
          40   3178
          28   3178
          32   3178
          29   3178
          30   3178
3300: oEndChoice
3301: oReturn
3302: oLocalSpace 10
3304: oGetParam 2
3306: oPushResult
3307: oNodeType
3308: oPop 1
3310: oChoice 3583
3312: oGetAddrLocal 1
3314: oPushResult
3315: oGetParam 2
3317: oPushResult
3318: oSetResult 36
3320: oPushResult
3321: oNodeGet
3322: oPop 2
3324: oAssign
3325: oGetAddrLocal 2
3327: oPushResult
3328: oGetParam 2
3330: oPushResult
3331: oSetResult 37
3333: oPushResult
3334: oNodeGet
3335: oPop 2
3337: oAssign
3338: oGetAddrLocal 3
3340: oPushResult
3341: oGetLocal 2
3343: oPushResult
3344: oCall 10583
3346: oPop 1
3348: oAssign
3349: oGetAddrLocal 4
3351: oPushResult
3352: oGetLocal 2
3354: oPushResult
3355: oCall 10678
3357: oPop 1
3359: oAssign
3360: oGetAddrLocal 5
3362: oPushResult
3363: oGetLocal 1
3365: oPushResult
3366: oSetResult 17
3368: oPushResult
3369: oNodeGetInt
3370: oPop 2
3372: oAssign
3373: oInput 14
3375: oGetAddrLocal 6
3377: oPushResult
3378: oGetLocal 3
3380: oAssign
3381: oGetLocal 1
3383: oPushResult
3384: oGetParam 1
3386: oPushResult
3387: oCall 3302
3389: oPop 2
3391: oGetLocal 6
3393: oPushResult
3394: oGetLocal 4
3396: oPushResult
3397: equal
3398: oPop 2
3400: oChoice 3408
3402: oJumpForward 3437
3404: oJumpForward 3414
3406: oJumpForward 3414
3408: Choice Lookup Table
           0   3406
           1   3402
3413: oEndChoice
3414: oInput 13
3416: oGetAddrParam 1
3418: oPushResult
3419: oGetParam 1
3421: oPushResult
3422: oGetLocal 5
3424: oPushResult
3425: add
3426: oPop 2
3428: oAssign
3429: oGetAddrLocal 6
3431: oPushResult
3432: inc
3433: oPop 1
3435: oJumpBack 3381
3437: oInput 15
3439: oJumpForward 3607
3441: oInput 14
3443: oGetAddrLocal 7
3445: oPushResult
3446: oGetParam 2
3448: oPushResult
3449: oSetResult 40
3451: oPushResult
3452: oNodeGet
3453: oPop 2
3455: oAssign
3456: oInputChoice 3460
3458: oJumpForward 3465
3460: Choice Lookup Table
           0   3458
3463: oJumpForward 3531
3465: oGetAddrLocal 8
3467: oPushResult
3468: oGetLocal 7
3470: oPushResult
3471: oScopeFindRequireInScope
3472: oPop 1
3474: oAssign
3475: oInput 12
3477: oGetAddrLocal 9
3479: oPushResult
3480: oGetLocal 8
3482: oPushResult
3483: oSetResult 21
3485: oPushResult
3486: oNodeGet
3487: oPop 2
3489: oAssign
3490: oGetAddrLocal 10
3492: oPushResult
3493: oGetParam 1
3495: oPushResult
3496: oGetLocal 8
3498: oPushResult
3499: oSetResult 22
3501: oPushResult
3502: oNodeGetInt
3503: oPop 2
3505: oPushResult
3506: add
3507: oPop 2
3509: oAssign
3510: oGetLocal 9
3512: oPushResult
3513: oGetLocal 10
3515: oPushResult
3516: oCall 3302
3518: oPop 2
3520: oInputChoice 3524
3522: oJumpForward 3529
3524: Choice Lookup Table
           5   3522
3527: oJumpForward 3531
3529: oJumpBack 3456
3531: oInput 15
3533: oJumpForward 3607
3535: oEmit 16
3537: oGetParam 1
3539: oPushResult
3540: oEmitInt
3541: oPop 1
3543: oCall 5019
3545: oEmit 15
3547: oValueTop
3548: oPushResult
3549: oEmitInt
3550: oPop 1
3552: oValuePop
3553: oEmit 26
3555: oJumpForward 3607
3557: oEmit 16
3559: oGetParam 1
3561: oPushResult
3562: oEmitInt
3563: oPop 1
3565: oCall 5019
3567: oEmit 15
3569: oValueTop
3570: oPushResult
3571: oEmitInt
3572: oPop 1
3574: oValuePop
3575: oEmit 25
3577: oJumpForward 3607
3579: oError 16
3581: oJumpForward 3607
3583: Choice Lookup Table
          34   3579
          33   3579
          27   3579
          39   3579
          40   3557
          28   3557
          32   3535
          29   3535
          30   3535
          37   3441
          35   3312
3606: oEndChoice
3607: oReturn
3608: oLocalSpace 2
3610: oInputChoice 3656
3612: oGetAddrLocal 1
3614: oPushResult
3615: oSetResult 18
3617: oPushResult
3618: LAST_ID
3619: oPushResult
3620: oCall 10471
3622: oPop 2
3624: oAssign
3625: oInput 6
3627: oGetAddrLocal 2
3629: oPushResult
3630: oCall 3963
3632: oPop 1
3634: oGetLocal 1
3636: oPushResult
3637: oSetResult 21
3639: oPushResult
3640: oGetLocal 2
3642: oPushResult
3643: oNodeSet
3644: oPop 3
3646: oGetLocal 1
3648: oPushResult
3649: oScopeDeclare
3650: oPop 1
3652: oInput 5
3654: oJumpForward 3661
3656: Choice Lookup Table
           0   3612
3659: oJumpForward 3663
3661: oJumpBack 3610
3663: oReturn
3664: oLocalSpace 6
3666: oInputChoice 3890
3668: oGetAddrLocal 1
3670: oPushResult
3671: oNodeVecNew
3672: oAssign
3673: oGetAddrLocal 2
3675: oPushResult
3676: oGetParam 1
3678: oPushResult
3679: LAST_ID
3680: oPushResult
3681: oCall 10471
3683: oPop 2
3685: oAssign
3686: oGetLocal 1
3688: oPushResult
3689: oGetLocal 2
3691: oPushResult
3692: oNodeVecAppend
3693: oPop 2
3695: oInputChoice 3701
3697: oInput 0
3699: oJumpForward 3706
3701: Choice Lookup Table
          13   3697
3704: oJumpForward 3708
3706: oJumpBack 3673
3708: oInput 12
3710: oGetAddrLocal 3
3712: oPushResult
3713: oCall 3963
3715: oPop 1
3717: oGetAddrLocal 4
3719: oPushResult
3720: oSetResult 0
3722: oAssign
3723: oGetLocal 4
3725: oPushResult
3726: oGetLocal 1
3728: oPushResult
3729: oNodeVecSize
3730: oPop 1
3732: oPushResult
3733: equal
3734: oPop 2
3736: oChoice 3777
3738: oGetAddrLocal 2
3740: oPushResult
3741: oGetLocal 1
3743: oPushResult
3744: oGetLocal 4
3746: oPushResult
3747: oNodeVecElement
3748: oPop 2
3750: oAssign
3751: oGetLocal 2
3753: oPushResult
3754: oSetResult 21
3756: oPushResult
3757: oGetLocal 3
3759: oPushResult
3760: oNodeSet
3761: oPop 3
3763: oGetLocal 2
3765: oPushResult
3766: oScopeDeclareAlloc
3767: oPop 1
3769: oGetAddrLocal 4
3771: oPushResult
3772: inc
3773: oPop 1
3775: oJumpForward 3782
3777: Choice Lookup Table
           0   3738
3780: oJumpForward 3784
3782: oJumpBack 3723
3784: oInputChoice 3877
3786: oGetLocal 1
3788: oPushResult
3789: oNodeVecSize
3790: oPop 1
3792: oChoice 3796
3794: oJumpForward 3801
3796: Choice Lookup Table
           1   3794
3799: oError 22
3801: oGetAddrLocal 5
3803: oPushResult
3804: oScopeCurrent
3805: oPushResult
3806: oCall 1906
3808: oPop 1
3810: oAssign
3811: oGetLocal 5
3813: oPushResult
3814: oCodePush
3815: oPop 1
3817: oGetAddrLocal 6
3819: oPushResult
3820: oSetResult 0
3822: oAssign
3823: oCall 10209
3825: oPushResult
3826: equal_zero
3827: oPop 1
3829: oChoice 3845
3831: oGetGlobal 3
3833: oPushResult
3834: oScopeEnter
3835: oPop 1
3837: oGetAddrLocal 6
3839: oPushResult
3840: oSetResult 1
3842: oAssign
3843: oJumpForward 3848
3845: Choice Lookup Table
           1   3831
3848: oGetLocal 2
3850: oPushResult
3851: oSetResult 1
3853: oPushResult
3854: oCall 9386
3856: oPop 2
3858: oCall 5092
3860: oCall 7860
3862: oCall 9142
3864: oGetLocal 6
3866: oChoice 3871
3868: oScopeEnd
3869: oJumpForward 3874
3871: Choice Lookup Table
           1   3868
3874: oCodePop
3875: oJumpForward 3880
3877: Choice Lookup Table
           6   3786
3880: oGetLocal 1
3882: oPushResult
3883: oNodeVecDelete
3884: oPop 1
3886: oInput 5
3888: oJumpForward 3895
3890: Choice Lookup Table
           0   3668
3893: oJumpForward 3897
3895: oJumpBack 3666
3897: oReturn
3898: oLocalSpace 2
3900: oInputChoice 3907
3902: oJumpForward 3913
3904: oChangeIntLitToLabelIdent
3905: oJumpForward 3913
3907: Choice Lookup Table
           1   3904
           0   3902
3912: oEndChoice
3913: oGetAddrLocal 1
3915: oPushResult
3916: oSetResult 25
3918: oPushResult
3919: LAST_ID
3920: oPushResult
3921: oCall 10471
3923: oPop 2
3925: oAssign
3926: oGetAddrLocal 2
3928: oPushResult
3929: oLabelNew
3930: oAssign
3931: oGetLocal 1
3933: oPushResult
3934: oSetResult 22
3936: oPushResult
3937: oGetLocal 2
3939: oPushResult
3940: oNodeSetLabel
3941: oPop 3
3943: oGetLocal 1
3945: oPushResult
3946: oScopeDeclare
3947: oPop 1
3949: oInputChoice 3953
3951: oJumpForward 3958
3953: Choice Lookup Table
          13   3951
3956: oJumpForward 3960
3958: oJumpBack 3900
3960: oInput 5
3962: oReturn
3963: oLocalSpace 12
3965: oInputChoice 4438
3967: oGetAddrLocal 1
3969: oPushResult
3970: oScopeFindRequire
3971: oAssign
3972: oGetAddrLocal 1
3974: oPushResult
3975: oCall 466
3977: oPop 1
3979: oGetLocal 1
3981: oPushResult
3982: oNodeType
3983: oPop 1
3985: oChoice 4002
3987: oGetParam 1
3989: oPushResult
3990: oGetLocal 1
3992: oPushResult
3993: oSetResult 21
3995: oPushResult
3996: oNodeGet
3997: oPop 2
3999: oAssign
4000: oJumpForward 4013
4002: Choice Lookup Table
          18   3987
4005: oError 2
4007: oGetParam 1
4009: oPushResult
4010: oGetGlobal 6
4012: oAssign
4013: oJumpForward 4457
4015: oInput 16
4017: oGetAddrLocal 2
4019: oPushResult
4020: oNodeVecNew
4021: oAssign
4022: oGetAddrLocal 3
4024: oPushResult
4025: oSetResult 36
4027: oPushResult
4028: oNodeNew
4029: oPop 1
4031: oAssign
4032: oGetLocal 3
4034: oPushResult
4035: oSetResult 36
4037: oPushResult
4038: oGetGlobal 6
4040: oPushResult
4041: oNodeSet
4042: oPop 3
4044: oCall 5019
4046: oGetLocal 3
4048: oPushResult
4049: oSetResult 38
4051: oPushResult
4052: oValueTop
4053: oPushResult
4054: oNodeSetInt
4055: oPop 3
4057: oValuePop
4058: oInput 21
4060: oCall 5019
4062: oGetLocal 3
4064: oPushResult
4065: oSetResult 39
4067: oPushResult
4068: oValueTop
4069: oPushResult
4070: oNodeSetInt
4071: oPop 3
4073: oValuePop
4074: oGetLocal 3
4076: oPushResult
4077: oSetResult 17
4079: oPushResult
4080: oSetResult 4
4082: oPushResult
4083: oNodeSetInt
4084: oPop 3
4086: oGetLocal 3
4088: oPushResult
4089: oTypeAdd
4090: oPop 1
4092: oGetAddrLocal 4
4094: oPushResult
4095: oSetResult 35
4097: oPushResult
4098: oNodeNew
4099: oPop 1
4101: oAssign
4102: oGetLocal 4
4104: oPushResult
4105: oSetResult 37
4107: oPushResult
4108: oGetLocal 3
4110: oPushResult
4111: oNodeSet
4112: oPop 3
4114: oGetLocal 2
4116: oPushResult
4117: oGetLocal 4
4119: oPushResult
4120: oNodeVecAppend
4121: oPop 2
4123: oInputChoice 4131
4125: oJumpForward 4139
4127: oJumpForward 4137
4129: oJumpForward 4137
4131: Choice Lookup Table
          13   4129
          17   4125
4136: oEndChoice
4137: oJumpBack 4022
4139: oInput 40
4141: oGetAddrLocal 5
4143: oPushResult
4144: oCall 3963
4146: oPop 1
4148: oGetAddrLocal 6
4150: oPushResult
4151: oGetLocal 2
4153: oPushResult
4154: oNodeVecSize
4155: oPop 1
4157: oAssign
4158: oGetAddrLocal 6
4160: oPushResult
4161: dec
4162: oPop 1
4164: oGetAddrLocal 7
4166: oPushResult
4167: oGetLocal 2
4169: oPushResult
4170: oGetLocal 6
4172: oPushResult
4173: oNodeVecElement
4174: oPop 2
4176: oAssign
4177: oGetLocal 7
4179: oPushResult
4180: oSetResult 36
4182: oPushResult
4183: oGetLocal 5
4185: oPushResult
4186: oNodeSet
4187: oPop 3
4189: oGetAddrLocal 8
4191: oPushResult
4192: oGetLocal 7
4194: oPushResult
4195: oSetResult 37
4197: oPushResult
4198: oNodeGet
4199: oPop 2
4201: oAssign
4202: oGetAddrLocal 9
4204: oPushResult
4205: oGetLocal 8
4207: oPushResult
4208: oSetResult 39
4210: oPushResult
4211: oNodeGetInt
4212: oPop 2
4214: oPushResult
4215: oGetLocal 8
4217: oPushResult
4218: oSetResult 38
4220: oPushResult
4221: oNodeGetInt
4222: oPop 2
4224: oPushResult
4225: subtract
4226: oPop 2
4228: oAssign
4229: oGetAddrLocal 9
4231: oPushResult
4232: inc
4233: oPop 1
4235: oGetLocal 7
4237: oPushResult
4238: oSetResult 17
4240: oPushResult
4241: oGetLocal 9
4243: oPushResult
4244: oGetLocal 5
4246: oPushResult
4247: oSetResult 17
4249: oPushResult
4250: oNodeGetInt
4251: oPop 2
4253: oPushResult
4254: multiply
4255: oPop 2
4257: oPushResult
4258: oNodeSetInt
4259: oPop 3
4261: oGetLocal 7
4263: oPushResult
4264: oTypeAdd
4265: oPop 1
4267: oGetAddrLocal 5
4269: oPushResult
4270: oGetLocal 7
4272: oAssign
4273: oGetLocal 6
4275: oPushResult
4276: equal_zero
4277: oPop 1
4279: oChoice 4285
4281: oJumpForward 4290
4283: oJumpForward 4288
4285: Choice Lookup Table
           1   4281
4288: oJumpBack 4158
4290: oGetParam 1
4292: oPushResult
4293: oGetLocal 2
4295: oPushResult
4296: oSetResult 0
4298: oPushResult
4299: oNodeVecElement
4300: oPop 2
4302: oAssign
4303: oGetLocal 2
4305: oPushResult
4306: oNodeVecDelete
4307: oPop 1
4309: oJumpForward 4457
4311: oGetAddrLocal 10
4313: oPushResult
4314: oCall 3963
4316: oPop 1
4318: oGetParam 1
4320: oPushResult
4321: oGetLocal 10
4323: oPushResult
4324: oCall 10499
4326: oPop 1
4328: oAssign
4329: oJumpForward 4457
4331: oGetParam 1
4333: oPushResult
4334: oSetResult 37
4336: oPushResult
4337: oNodeNew
4338: oPop 1
4340: oAssign
4341: oSetResult -1
4343: oPushResult
4344: oSetResult 2
4346: oPushResult
4347: oScopeBegin
4348: oPop 2
4350: oSetResult 22
4352: oPushResult
4353: oCall 3664
4355: oPop 1
4357: oGetAddrLocal 11
4359: oPushResult
4360: oScopeCurrent
4361: oPushResult
4362: oSetResult 17
4364: oPushResult
4365: oNodeGetInt
4366: oPop 2
4368: oAssign
4369: oGetLocal 11
4371: oPushResult
4372: equal_zero
4373: oPop 1
4375: oChoice 4381
4377: oError 19
4379: oJumpForward 4384
4381: Choice Lookup Table
           1   4377
4384: oInput 36
4386: oGetFromParam 1
4388: oPushResult
4389: oSetResult 40
4391: oPushResult
4392: oScopeCurrent
4393: oPushResult
4394: oNodeSet
4395: oPop 3
4397: oGetFromParam 1
4399: oPushResult
4400: oSetResult 17
4402: oPushResult
4403: oGetLocal 11
4405: oPushResult
4406: oNodeSetInt
4407: oPop 3
4409: oScopeEnd
4410: oGetFromParam 1
4412: oPushResult
4413: oTypeAdd
4414: oPop 1
4416: oJumpForward 4457
4418: oGetParam 1
4420: oPushResult
4421: oCall 4458
4423: oPop 1
4425: oJumpForward 4457
4427: oInput 40
4429: oGetAddrLocal 12
4431: oPushResult
4432: oCall 3963
4434: oPop 1
4436: oJumpForward 4457
4438: Choice Lookup Table
          39   4427
          14   4418
          38   4331
          18   4311
          37   4015
           0   3967
4451: oCall 5019
4453: oInput 21
4455: oCall 5019
4457: oReturn
4458: oLocalSpace 11
4460: oGetParam 1
4462: oPushResult
4463: oSetResult 40
4465: oPushResult
4466: oNodeNew
4467: oPop 1
4469: oAssign
4470: oGetAddrLocal 1
4472: oPushResult
4473: oSetResult 0
4475: oAssign
4476: oGetAddrLocal 2
4478: oPushResult
4479: oSetResult 0
4481: oAssign
4482: oGetAddrLocal 3
4484: oPushResult
4485: oSetResult 1
4487: oAssign
4488: oGetAddrLocal 4
4490: oPushResult
4491: oScopeCurrent
4492: oAssign
4493: oSetResult -1
4495: oPushResult
4496: oSetResult 2
4498: oPushResult
4499: oScopeBegin
4500: oPop 2
4502: oInput 0
4504: oGetAddrLocal 5
4506: oPushResult
4507: oSetResult 17
4509: oPushResult
4510: LAST_ID
4511: oPushResult
4512: oCall 10471
4514: oPop 2
4516: oAssign
4517: oGetAddrLocal 6
4519: oPushResult
4520: oSetResult 17
4522: oPushResult
4523: LAST_ID
4524: oPushResult
4525: oCall 10471
4527: oPop 2
4529: oAssign
4530: oGetLocal 5
4532: oPushResult
4533: oSetResult 21
4535: oPushResult
4536: oGetFromParam 1
4538: oPushResult
4539: oNodeSet
4540: oPop 3
4542: oGetLocal 6
4544: oPushResult
4545: oSetResult 21
4547: oPushResult
4548: oGetFromParam 1
4550: oPushResult
4551: oNodeSet
4552: oPop 3
4554: oGetAddrLocal 7
4556: oPushResult
4557: LAST_ID
4558: oPushResult
4559: ID_STRING
4560: oPop 1
4562: oPushResult
4563: oStringAllocLit
4564: oPop 1
4566: oAssign
4567: oGetLocal 5
4569: oPushResult
4570: oSetResult 32
4572: oPushResult
4573: oGetLocal 7
4575: oPushResult
4576: oNodeSetInt
4577: oPop 3
4579: oGetLocal 6
4581: oPushResult
4582: oSetResult 32
4584: oPushResult
4585: oGetLocal 7
4587: oPushResult
4588: oNodeSetInt
4589: oPop 3
4591: oInputChoice 4660
4593: oCall 5019
4595: oGetLocal 2
4597: oPushResult
4598: equal_zero
4599: oPop 1
4601: oChoice 4622
4603: oValueTop
4604: oPushResult
4605: oGetLocal 1
4607: oPushResult
4608: greater
4609: oPop 2
4611: oChoice 4617
4613: oError 26
4615: oJumpForward 4620
4617: Choice Lookup Table
           0   4613
4620: oJumpForward 4625
4622: Choice Lookup Table
           0   4603
4625: oGetLocal 1
4627: oPushResult
4628: oValueTop
4629: oPushResult
4630: equal
4631: oPop 2
4633: oChoice 4649
4635: oGetFromParam 1
4637: oPushResult
4638: oSetResult 43
4640: oPushResult
4641: oSetResult 1
4643: oPushResult
4644: oNodeSetBoolean
4645: oPop 3
4647: oJumpForward 4652
4649: Choice Lookup Table
           0   4635
4652: oGetAddrLocal 1
4654: oPushResult
4655: oValueTop
4656: oAssign
4657: oValuePop
4658: oJumpForward 4665
4660: Choice Lookup Table
           4   4593
           6   4593
4665: oGetLocal 5
4667: oPushResult
4668: oSetResult 22
4670: oPushResult
4671: oGetLocal 1
4673: oPushResult
4674: oNodeSetInt
4675: oPop 3
4677: oGetLocal 6
4679: oPushResult
4680: oSetResult 22
4682: oPushResult
4683: oGetLocal 1
4685: oPushResult
4686: oNodeSetInt
4687: oPop 3
4689: oGetLocal 5
4691: oPushResult
4692: oScopeDeclare
4693: oPop 1
4695: oGetLocal 4
4697: oPushResult
4698: oScopeEnter
4699: oPop 1
4701: oGetLocal 6
4703: oPushResult
4704: oScopeDeclare
4705: oPop 1
4707: oScopeEnd
4708: oGetAddrLocal 1
4710: oPushResult
4711: inc
4712: oPop 1
4714: oGetAddrLocal 2
4716: oPushResult
4717: inc
4718: oPop 1
4720: oInputChoice 4724
4722: oJumpForward 4729
4724: Choice Lookup Table
          13   4722
4727: oJumpForward 4731
4729: oJumpBack 4502
4731: oInput 15
4733: oGetFromParam 1
4735: oPushResult
4736: oSetResult 40
4738: oPushResult
4739: oScopeCurrent
4740: oPushResult
4741: oNodeSet
4742: oPop 3
4744: oGetFromParam 1
4746: oPushResult
4747: oSetResult 17
4749: oPushResult
4750: oSetResult 4
4752: oPushResult
4753: oNodeSetInt
4754: oPop 3
4756: oScopeEnd
4757: oGetGlobal 2
4759: oPushResult
4760: oCall 1906
4762: oPop 1
4764: oPushResult
4765: oCodePush
4766: oPop 1
4768: oGetGlobal 2
4770: oPushResult
4771: oScopeEnter
4772: oPop 1
4774: oGetAddrLocal 8
4776: oPushResult
4777: oGetLocal 2
4779: oPushResult
4780: oSetResult 1
4782: oPushResult
4783: add
4784: oPop 2
4786: oPushResult
4787: oSetResult 16
4789: oPushResult
4790: multiply
4791: oPop 2
4793: oAssign
4794: oGetAddrLocal 9
4796: oPushResult
4797: oGetLocal 8
4799: oPushResult
4800: oSetResult 8
4802: oPushResult
4803: oScopeAlloc
4804: oPop 2
4806: oAssign
4807: oScopeEnd
4808: oGetFromParam 1
4810: oPushResult
4811: oSetResult 42
4813: oPushResult
4814: oGetLocal 9
4816: oPushResult
4817: oNodeSetInt
4818: oPop 3
4820: oGetAddrLocal 10
4822: oPushResult
4823: oGetFromParam 1
4825: oPushResult
4826: oSetResult 40
4828: oPushResult
4829: oNodeGet
4830: oPop 2
4832: oPushResult
4833: oSetResult 15
4835: oPushResult
4836: oNodeGetIter
4837: oPop 2
4839: oAssign
4840: oGetAddrLocal 11
4842: oPushResult
4843: oGetLocal 10
4845: oPushResult
4846: oNodeIterValue
4847: oPop 1
4849: oAssign
4850: oGetLocal 11
4852: oPushResult
4853: oNodeNull
4854: oPop 1
4856: oChoice 4862
4858: oJumpForward 4949
4860: oJumpForward 4865
4862: Choice Lookup Table
           1   4858
4865: oEmit 16
4867: oGetLocal 9
4869: oPushResult
4870: oEmitInt
4871: oPop 1
4873: oEmit 15
4875: oGetLocal 11
4877: oPushResult
4878: oSetResult 22
4880: oPushResult
4881: oNodeGetInt
4882: oPop 2
4884: oPushResult
4885: oEmitInt
4886: oPop 1
4888: oEmit 25
4890: oGetAddrLocal 9
4892: oPushResult
4893: oGetLocal 9
4895: oPushResult
4896: oSetResult 8
4898: oPushResult
4899: add
4900: oPop 2
4902: oAssign
4903: oEmit 16
4905: oGetLocal 9
4907: oPushResult
4908: oEmitInt
4909: oPop 1
4911: oEmit 16
4913: oGetLocal 11
4915: oPushResult
4916: oSetResult 32
4918: oPushResult
4919: oNodeGetInt
4920: oPop 2
4922: oPushResult
4923: oEmitInt
4924: oPop 1
4926: oEmit 27
4928: oGetAddrLocal 9
4930: oPushResult
4931: oGetLocal 9
4933: oPushResult
4934: oSetResult 8
4936: oPushResult
4937: add
4938: oPop 2
4940: oAssign
4941: oGetAddrLocal 10
4943: oPushResult
4944: oNodeIterNext
4945: oPop 1
4947: oJumpBack 4840
4949: oEmit 16
4951: oGetLocal 9
4953: oPushResult
4954: oEmitInt
4955: oPop 1
4957: oEmit 15
4959: oSetResult 0
4961: oPushResult
4962: oEmitInt
4963: oPop 1
4965: oEmit 25
4967: oGetAddrLocal 9
4969: oPushResult
4970: oGetLocal 9
4972: oPushResult
4973: oSetResult 8
4975: oPushResult
4976: add
4977: oPop 2
4979: oAssign
4980: oEmit 16
4982: oGetLocal 9
4984: oPushResult
4985: oEmitInt
4986: oPop 1
4988: oEmit 15
4990: oSetResult 0
4992: oPushResult
4993: oEmitInt
4994: oPop 1
4996: oEmit 27
4998: oGetAddrLocal 9
5000: oPushResult
5001: oGetLocal 9
5003: oPushResult
5004: oSetResult 8
5006: oPushResult
5007: add
5008: oPop 2
5010: oAssign
5011: oCodePop
5012: oGetFromParam 1
5014: oPushResult
5015: oTypeAdd
5016: oPop 1
5018: oReturn
5019: oLocalSpace 1
5021: oInputChoice 5083
5023: TOKEN_VALUE
5024: oPushResult
5025: oValuePush
5026: oPop 1
5028: oJumpForward 5091
5030: oGetAddrLocal 1
5032: oPushResult
5033: oScopeFindRequire
5034: oAssign
5035: oGetAddrLocal 1
5037: oPushResult
5038: oCall 466
5040: oPop 1
5042: oGetLocal 1
5044: oPushResult
5045: oNodeType
5046: oPop 1
5048: oChoice 5065
5050: oGetLocal 1
5052: oPushResult
5053: oSetResult 22
5055: oPushResult
5056: oNodeGetInt
5057: oPop 2
5059: oPushResult
5060: oValuePush
5061: oPop 1
5063: oJumpForward 5076
5065: Choice Lookup Table
          16   5050
5068: oError 1
5070: oSetResult 0
5072: oPushResult
5073: oValuePush
5074: oPop 1
5076: oJumpForward 5091
5078: oCall 5019
5080: oValueNegate
5081: oJumpForward 5091
5083: Choice Lookup Table
          25   5078
           0   5030
           1   5023
5090: oEndChoice
5091: oReturn
5092: oLocalSpace 1
5094: oGetAddrLocal 1
5096: oPushResult
5097: oSetResult 0
5099: oAssign
5100: oGetAddrLocal 1
5102: oPushResult
5103: oCall 5253
5105: oPop 1
5107: oGetAddrLocal 1
5109: oPushResult
5110: oCall 5153
5112: oPop 1
5114: oReturn
5115: oLocalSpace 0
5117: oGetParam 1
5119: oPushResult
5120: oCall 5253
5122: oPop 1
5124: oTypeSNodeType
5125: oChoice 5144
5127: oJumpForward 5151
5129: oGetParam 1
5131: oPushResult
5132: oLabelNew
5133: oAssign
5134: oEmit 67
5136: oGetFromParam 1
5138: oPushResult
5139: oEmitLabel
5140: oPop 1
5142: oJumpForward 5151
5144: Choice Lookup Table
          30   5129
          31   5127
5149: oError 8
5151: oTypeSPop
5152: oReturn
5153: oLocalSpace 1
5155: oTypeSNodeType
5156: oChoice 5218
5158: oGetAddrLocal 1
5160: oPushResult
5161: oLabelNew
5162: oAssign
5163: oEmit 15
5165: oSetResult 1
5167: oPushResult
5168: oEmitInt
5169: oPop 1
5171: oEmit 65
5173: oGetLocal 1
5175: oPushResult
5176: oEmitLabel
5177: oPop 1
5179: oEmit 68
5181: oGetFromParam 1
5183: oPushResult
5184: oEmitLabel
5185: oPop 1
5187: oEmit 15
5189: oSetResult 0
5191: oPushResult
5192: oEmitInt
5193: oPop 1
5195: oEmit 68
5197: oGetLocal 1
5199: oPushResult
5200: oEmitLabel
5201: oPop 1
5203: oTypeSPop
5204: oGetGlobal 7
5206: oPushResult
5207: oTypeSPush
5208: oPop 1
5210: oGetParam 1
5212: oPushResult
5213: oSetResult 0
5215: oAssign
5216: oJumpForward 5221
5218: Choice Lookup Table
          31   5158
5221: oReturn
5222: oLocalSpace 0
5224: oTypeSNodeType
5225: oChoice 5249
5227: oGetParam 1
5229: oPushResult
5230: oLabelNew
5231: oAssign
5232: oEmit 67
5234: oGetFromParam 1
5236: oPushResult
5237: oEmitLabel
5238: oPop 1
5240: oTypeSPop
5241: oGetGlobal 8
5243: oPushResult
5244: oTypeSPush
5245: oPop 1
5247: oJumpForward 5252
5249: Choice Lookup Table
          30   5227
5252: oReturn
5253: oLocalSpace 0
5255: oGetParam 1
5257: oPushResult
5258: oCall 5726
5260: oPop 1
5262: oInputChoice 5708
5264: oGetParam 1
5266: oPushResult
5267: oCall 5153
5269: oPop 1
5271: oCall 10390
5273: oGetParam 1
5275: oPushResult
5276: oCall 5726
5278: oPop 1
5280: oGetParam 1
5282: oPushResult
5283: oCall 5153
5285: oPop 1
5287: oCall 10390
5289: oCall 10259
5291: oTypeSNodeType
5292: oChoice 5310
5294: oEmit 40
5296: oJumpForward 5329
5298: oEmit 46
5300: oJumpForward 5329
5302: oEmit 52
5304: oJumpForward 5329
5306: oError 16
5308: oJumpForward 5329
5310: Choice Lookup Table
          38   5306
          39   5306
          34   5302
          33   5302
          40   5298
          28   5298
          32   5294
          30   5294
5327: oError 17
5329: oTypeSPop
5330: oGetGlobal 7
5332: oPushResult
5333: oTypeSPush
5334: oPop 1
5336: oJumpForward 5723
5338: oGetParam 1
5340: oPushResult
5341: oCall 5153
5343: oPop 1
5345: oCall 10390
5347: oGetParam 1
5349: oPushResult
5350: oCall 5726
5352: oPop 1
5354: oGetParam 1
5356: oPushResult
5357: oCall 5153
5359: oPop 1
5361: oCall 10390
5363: oCall 10259
5365: oTypeSNodeType
5366: oChoice 5384
5368: oEmit 41
5370: oJumpForward 5403
5372: oEmit 47
5374: oJumpForward 5403
5376: oEmit 53
5378: oJumpForward 5403
5380: oError 16
5382: oJumpForward 5403
5384: Choice Lookup Table
          38   5380
          39   5380
          34   5376
          33   5376
          40   5372
          28   5372
          32   5368
          30   5368
5401: oError 17
5403: oTypeSPop
5404: oGetGlobal 7
5406: oPushResult
5407: oTypeSPush
5408: oPop 1
5410: oJumpForward 5723
5412: oGetParam 1
5414: oPushResult
5415: oCall 5153
5417: oPop 1
5419: oCall 10390
5421: oGetParam 1
5423: oPushResult
5424: oCall 5726
5426: oPop 1
5428: oGetParam 1
5430: oPushResult
5431: oCall 5153
5433: oPop 1
5435: oCall 10390
5437: oCall 10259
5439: oTypeSNodeType
5440: oChoice 5458
5442: oEmit 43
5444: oJumpForward 5477
5446: oEmit 49
5448: oJumpForward 5477
5450: oEmit 55
5452: oJumpForward 5477
5454: oError 16
5456: oJumpForward 5477
5458: Choice Lookup Table
          38   5454
          39   5454
          34   5450
          33   5450
          40   5446
          28   5446
          32   5442
          30   5442
5475: oError 17
5477: oTypeSPop
5478: oGetGlobal 7
5480: oPushResult
5481: oTypeSPush
5482: oPop 1
5484: oJumpForward 5723
5486: oGetParam 1
5488: oPushResult
5489: oCall 5153
5491: oPop 1
5493: oCall 10390
5495: oGetParam 1
5497: oPushResult
5498: oCall 5726
5500: oPop 1
5502: oGetParam 1
5504: oPushResult
5505: oCall 5153
5507: oPop 1
5509: oCall 10390
5511: oCall 10259
5513: oTypeSNodeType
5514: oChoice 5532
5516: oEmit 42
5518: oJumpForward 5551
5520: oEmit 48
5522: oJumpForward 5551
5524: oEmit 54
5526: oJumpForward 5551
5528: oError 16
5530: oJumpForward 5551
5532: Choice Lookup Table
          38   5528
          39   5528
          34   5524
          33   5524
          40   5520
          28   5520
          32   5516
          30   5516
5549: oError 17
5551: oTypeSPop
5552: oGetGlobal 7
5554: oPushResult
5555: oTypeSPush
5556: oPop 1
5558: oJumpForward 5723
5560: oGetParam 1
5562: oPushResult
5563: oCall 5153
5565: oPop 1
5567: oCall 10390
5569: oGetParam 1
5571: oPushResult
5572: oCall 5726
5574: oPop 1
5576: oGetParam 1
5578: oPushResult
5579: oCall 5153
5581: oPop 1
5583: oCall 10390
5585: oCall 10259
5587: oTypeSNodeType
5588: oChoice 5606
5590: oEmit 45
5592: oJumpForward 5625
5594: oEmit 51
5596: oJumpForward 5625
5598: oEmit 57
5600: oJumpForward 5625
5602: oError 16
5604: oJumpForward 5625
5606: Choice Lookup Table
          38   5602
          39   5602
          34   5598
          33   5598
          40   5594
          28   5594
          32   5590
          30   5590
5623: oError 17
5625: oTypeSPop
5626: oGetGlobal 7
5628: oPushResult
5629: oTypeSPush
5630: oPop 1
5632: oJumpForward 5723
5634: oGetParam 1
5636: oPushResult
5637: oCall 5153
5639: oPop 1
5641: oCall 10390
5643: oGetParam 1
5645: oPushResult
5646: oCall 5726
5648: oPop 1
5650: oGetParam 1
5652: oPushResult
5653: oCall 5153
5655: oPop 1
5657: oCall 10390
5659: oCall 10259
5661: oTypeSNodeType
5662: oChoice 5680
5664: oEmit 44
5666: oJumpForward 5699
5668: oEmit 50
5670: oJumpForward 5699
5672: oEmit 56
5674: oJumpForward 5699
5676: oError 16
5678: oJumpForward 5699
5680: Choice Lookup Table
          38   5676
          39   5676
          34   5672
          33   5672
          40   5668
          28   5668
          32   5664
          30   5664
5697: oError 17
5699: oTypeSPop
5700: oGetGlobal 7
5702: oPushResult
5703: oTypeSPush
5704: oPop 1
5706: oJumpForward 5723
5708: Choice Lookup Table
          11   5634
          10   5560
           9   5486
           8   5412
           7   5338
           6   5264
5721: oJumpForward 5725
5723: oJumpBack 5262
5725: oReturn
5726: oLocalSpace 1
5728: oGetAddrLocal 1
5730: oPushResult
5731: oSetResult 0
5733: oAssign
5734: oGetParam 1
5736: oPushResult
5737: oCall 5906
5739: oPop 1
5741: oInputChoice 5874
5743: oTypeSNodeType
5744: oChoice 5815
5746: oGetLocal 1
5748: oPushResult
5749: oSetResult 0
5751: oPushResult
5752: equal_label
5753: oPop 2
5755: oChoice 5764
5757: oGetAddrLocal 1
5759: oPushResult
5760: oLabelNew
5761: oAssign
5762: oJumpForward 5767
5764: Choice Lookup Table
           1   5757
5767: oEmit 65
5769: oGetLocal 1
5771: oPushResult
5772: oEmitLabel
5773: oPop 1
5775: oJumpForward 5822
5777: oGetParam 1
5779: oPushResult
5780: oCall 5222
5782: oPop 1
5784: oGetLocal 1
5786: oPushResult
5787: oSetResult 0
5789: oPushResult
5790: equal_label
5791: oPop 2
5793: oChoice 5802
5795: oGetAddrLocal 1
5797: oPushResult
5798: oLabelNew
5799: oAssign
5800: oJumpForward 5805
5802: Choice Lookup Table
           1   5795
5805: oEmit 65
5807: oGetLocal 1
5809: oPushResult
5810: oEmitLabel
5811: oPop 1
5813: oJumpForward 5822
5815: Choice Lookup Table
          30   5777
          31   5746
5820: oError 8
5822: oTypeSPop
5823: oEmit 68
5825: oGetFromParam 1
5827: oPushResult
5828: oEmitLabel
5829: oPop 1
5831: oGetParam 1
5833: oPushResult
5834: oSetResult 0
5836: oAssign
5837: oGetParam 1
5839: oPushResult
5840: oCall 5906
5842: oPop 1
5844: oTypeSNodeType
5845: oChoice 5858
5847: oJumpForward 5865
5849: oGetParam 1
5851: oPushResult
5852: oCall 5222
5854: oPop 1
5856: oJumpForward 5865
5858: Choice Lookup Table
          30   5849
          31   5847
5863: oError 8
5865: oTypeSPop
5866: oGetGlobal 8
5868: oPushResult
5869: oTypeSPush
5870: oPop 1
5872: oJumpForward 5879
5874: Choice Lookup Table
          55   5743
5877: oJumpForward 5881
5879: oJumpBack 5741
5881: oGetLocal 1
5883: oPushResult
5884: oSetResult 0
5886: oPushResult
5887: equal_label
5888: oPop 2
5890: oChoice 5902
5892: oEmit 68
5894: oGetLocal 1
5896: oPushResult
5897: oEmitLabel
5898: oPop 1
5900: oJumpForward 5905
5902: Choice Lookup Table
           0   5892
5905: oReturn
5906: oLocalSpace 2
5908: oGetAddrLocal 1
5910: oPushResult
5911: oSetResult 0
5913: oAssign
5914: oGetParam 1
5916: oPushResult
5917: oCall 6044
5919: oPop 1
5921: oInputChoice 6036
5923: oTypeSNodeType
5924: oChoice 5937
5926: oJumpForward 5944
5928: oGetParam 1
5930: oPushResult
5931: oCall 5222
5933: oPop 1
5935: oJumpForward 5944
5937: Choice Lookup Table
          30   5928
          31   5926
5942: oError 8
5944: oTypeSPop
5945: oGetLocal 1
5947: oPushResult
5948: oSetResult 0
5950: oPushResult
5951: equal_label
5952: oPop 2
5954: oChoice 5983
5956: oGetAddrLocal 1
5958: oPushResult
5959: oLabelNew
5960: oAssign
5961: oEmit 69
5963: oGetFromParam 1
5965: oPushResult
5966: oEmitLabel
5967: oPop 1
5969: oGetLocal 1
5971: oPushResult
5972: oEmitLabel
5973: oPop 1
5975: oGetParam 1
5977: oPushResult
5978: oGetLocal 1
5980: oAssign
5981: oJumpForward 5986
5983: Choice Lookup Table
           1   5956
5986: oGetAddrLocal 2
5988: oPushResult
5989: oSetResult 0
5991: oAssign
5992: oGetAddrLocal 2
5994: oPushResult
5995: oCall 6044
5997: oPop 1
5999: oTypeSNodeType
6000: oChoice 6013
6002: oJumpForward 6020
6004: oGetAddrLocal 2
6006: oPushResult
6007: oCall 5222
6009: oPop 1
6011: oJumpForward 6020
6013: Choice Lookup Table
          30   6004
          31   6002
6018: oError 8
6020: oEmit 69
6022: oGetLocal 2
6024: oPushResult
6025: oEmitLabel
6026: oPop 1
6028: oGetLocal 1
6030: oPushResult
6031: oEmitLabel
6032: oPop 1
6034: oJumpForward 6041
6036: Choice Lookup Table
          54   5923
6039: oJumpForward 6043
6041: oJumpBack 5921
6043: oReturn
6044: oLocalSpace 1
6046: oInputChoice 6100
6048: oGetAddrLocal 1
6050: oPushResult
6051: oSetResult 0
6053: oAssign
6054: oGetAddrLocal 1
6056: oPushResult
6057: oCall 6044
6059: oPop 1
6061: oTypeSNodeType
6062: oChoice 6091
6064: oGetParam 1
6066: oPushResult
6067: oLabelNew
6068: oAssign
6069: oEmit 65
6071: oGetFromParam 1
6073: oPushResult
6074: oEmitLabel
6075: oPop 1
6077: oEmit 68
6079: oGetLocal 1
6081: oPushResult
6082: oEmitLabel
6083: oPop 1
6085: oJumpForward 6098
6087: oEmit 39
6089: oJumpForward 6098
6091: Choice Lookup Table
          30   6087
          31   6064
6096: oError 8
6098: oJumpForward 6110
6100: Choice Lookup Table
          56   6048
6103: oGetParam 1
6105: oPushResult
6106: oCall 6111
6108: oPop 1
6110: oReturn
6111: oLocalSpace 2
6113: oGetParam 1
6115: oPushResult
6116: oCall 6252
6118: oPop 1
6120: oInputChoice 6242
6122: oTypeSNodeType
6123: oChoice 6208
6125: oCall 10344
6127: oGetParam 1
6129: oPushResult
6130: oCall 6252
6132: oPop 1
6134: oCall 10364
6136: oEmit 36
6138: oJumpForward 6225
6140: oError 16
6142: oJumpForward 6225
6144: oGetAddrLocal 1
6146: oPushResult
6147: oTypeSTop
6148: oPushResult
6149: oSetResult 36
6151: oPushResult
6152: oNodeGet
6153: oPop 2
6155: oAssign
6156: oGetAddrLocal 2
6158: oPushResult
6159: oGetLocal 1
6161: oPushResult
6162: oSetResult 17
6164: oPushResult
6165: oNodeGetInt
6166: oPop 2
6168: oAssign
6169: oGetParam 1
6171: oPushResult
6172: oCall 6252
6174: oPop 1
6176: oCall 10344
6178: oGetLocal 2
6180: oPushResult
6181: oSetResult 1
6183: oPushResult
6184: equal
6185: oPop 2
6187: oChoice 6201
6189: oEmit 15
6191: oGetLocal 2
6193: oPushResult
6194: oEmitInt
6195: oPop 1
6197: oEmit 33
6199: oJumpForward 6204
6201: Choice Lookup Table
           0   6189
6204: oEmit 35
6206: oJumpForward 6225
6208: Choice Lookup Table
          34   6144
          33   6144
          32   6140
          38   6140
          39   6140
          29   6125
          28   6125
6223: oError 17
6225: oJumpForward 6249
6227: oCall 10344
6229: oGetParam 1
6231: oPushResult
6232: oCall 6252
6234: oPop 1
6236: oCall 10364
6238: oEmit 37
6240: oJumpForward 6249
6242: Choice Lookup Table
          25   6227
          24   6122
6247: oJumpForward 6251
6249: oJumpBack 6120
6251: oReturn
6252: oLocalSpace 0
6254: oGetParam 1
6256: oPushResult
6257: oCall 6303
6259: oPop 1
6261: oInputChoice 6293
6263: oCall 10344
6265: oGetParam 1
6267: oPushResult
6268: oCall 6303
6270: oPop 1
6272: oCall 10364
6274: oEmit 33
6276: oJumpForward 6300
6278: oCall 10344
6280: oGetParam 1
6282: oPushResult
6283: oCall 6303
6285: oPop 1
6287: oCall 10364
6289: oEmit 34
6291: oJumpForward 6300
6293: Choice Lookup Table
          23   6278
          22   6263
6298: oJumpForward 6302
6300: oJumpBack 6261
6302: oReturn
6303: oLocalSpace 0
6305: oInputChoice 6331
6307: oGetParam 1
6309: oPushResult
6310: oCall 6344
6312: oPop 1
6314: oCall 10364
6316: oJumpForward 6343
6318: oGetParam 1
6320: oPushResult
6321: oCall 6344
6323: oPop 1
6325: oCall 10364
6327: oEmit 38
6329: oJumpForward 6343
6331: Choice Lookup Table
          25   6318
          24   6307
6336: oGetParam 1
6338: oPushResult
6339: oCall 6344
6341: oPop 1
6343: oReturn
6344: oLocalSpace 6
6346: oInputChoice 6585
6348: oEmit 15
6350: TOKEN_VALUE
6351: oPushResult
6352: oEmitInt
6353: oPop 1
6355: oGetGlobal 6
6357: oPushResult
6358: oTypeSPush
6359: oPop 1
6361: oJumpForward 6606
6363: oEmit 15
6365: TOKEN_VALUE
6366: oPushResult
6367: oEmitInt
6368: oPop 1
6370: oGetGlobal 9
6372: oPushResult
6373: oTypeSPush
6374: oPop 1
6376: oJumpForward 6606
6378: oGetParam 1
6380: oPushResult
6381: oCall 5253
6383: oPop 1
6385: oInput 15
6387: oJumpForward 6606
6389: oGetAddrLocal 1
6391: oPushResult
6392: CURRENT_STRLIT
6393: oPushResult
6394: oStringAllocShortStringLit
6395: oPop 1
6397: oAssign
6398: oEmit 16
6400: oGetLocal 1
6402: oPushResult
6403: oEmitInt
6404: oPop 1
6406: oGetGlobal 13
6408: oPushResult
6409: oTypeSPush
6410: oPop 1
6412: oCall 7418
6414: oCall 7364
6416: oJumpForward 6606
6418: oGetAddrLocal 2
6420: oPushResult
6421: oScopeFindRequire
6422: oAssign
6423: oGetAddrLocal 2
6425: oPushResult
6426: oCall 466
6428: oPop 1
6430: oGetLocal 2
6432: oPushResult
6433: oNodeType
6434: oPop 1
6436: oChoice 6509
6438: oGetLocal 2
6440: oPushResult
6441: oCall 8077
6443: oPop 1
6445: oJumpForward 6534
6447: oGetLocal 2
6449: oPushResult
6450: oCall 8697
6452: oPop 1
6454: oJumpForward 6534
6456: oGetAddrLocal 3
6458: oPushResult
6459: oGetLocal 2
6461: oPushResult
6462: oSetResult 21
6464: oPushResult
6465: oNodeGet
6466: oPop 2
6468: oAssign
6469: oGetLocal 3
6471: oPushResult
6472: oTypeSPush
6473: oPop 1
6475: oTypeSNodeType
6476: oChoice 6489
6478: oEmit 15
6480: oGetLocal 2
6482: oPushResult
6483: oCall 10773
6485: oPop 1
6487: oJumpForward 6498
6489: Choice Lookup Table
          30   6478
          40   6478
          28   6478
6496: oError 16
6498: oJumpForward 6534
6500: oGetLocal 2
6502: oPushResult
6503: oCall 6607
6505: oPop 1
6507: oJumpForward 6534
6509: Choice Lookup Table
          24   6500
          23   6500
          21   6500
          20   6500
          17   6456
          16   6456
          14   6447
          13   6438
6526: oError 6
6528: oGetGlobal 6
6530: oPushResult
6531: oTypeSPush
6532: oPop 1
6534: oJumpForward 6606
6536: oInput 0
6538: oGetAddrLocal 4
6540: oPushResult
6541: oScopeFindRequire
6542: oAssign
6543: oGetAddrLocal 4
6545: oPushResult
6546: oCall 466
6548: oPop 1
6550: oGetLocal 4
6552: oPushResult
6553: oSetResult 0
6555: oPushResult
6556: oCall 9386
6558: oPop 2
6560: oGetAddrLocal 5
6562: oPushResult
6563: oTypeSTop
6564: oAssign
6565: oTypeSPop
6566: oGetAddrLocal 6
6568: oPushResult
6569: oGetLocal 5
6571: oPushResult
6572: oCall 10499
6574: oPop 1
6576: oAssign
6577: oGetLocal 6
6579: oPushResult
6580: oTypeSPush
6581: oPop 1
6583: oJumpForward 6606
6585: Choice Lookup Table
          19   6536
           0   6418
           2   6389
          14   6378
           3   6363
           1   6348
6598: oError 6
6600: oGetGlobal 6
6602: oPushResult
6603: oTypeSPush
6604: oPop 1
6606: oReturn
6607: oLocalSpace 2
6609: oGetAddrLocal 1
6611: oPushResult
6612: oGetParam 1
6614: oPushResult
6615: oSetResult 21
6617: oPushResult
6618: oNodeGet
6619: oPop 2
6621: oAssign
6622: oGetAddrLocal 2
6624: oPushResult
6625: oGetParam 1
6627: oPushResult
6628: oCall 10241
6630: oPop 1
6632: oAssign
6633: oGetLocal 1
6635: oPushResult
6636: oTypeSPush
6637: oPop 1
6639: oTypeSNodeType
6640: oChoice 7339
6642: oGetParam 1
6644: oPushResult
6645: oNodeType
6646: oPop 1
6648: oChoice 6794
6650: oEmit 0
6652: oGetParam 1
6654: oPushResult
6655: oCall 10773
6657: oPop 1
6659: oJumpForward 6804
6661: oGetLocal 2
6663: oPushResult
6664: equal_zero
6665: oPop 1
6667: oChoice 6680
6669: oEmit 3
6671: oGetParam 1
6673: oPushResult
6674: oCall 10773
6676: oPop 1
6678: oJumpForward 6698
6680: Choice Lookup Table
           1   6669
6683: oEmit 9
6685: oGetLocal 2
6687: oPushResult
6688: oEmitInt
6689: oPop 1
6691: oGetParam 1
6693: oPushResult
6694: oCall 10773
6696: oPop 1
6698: oJumpForward 6804
6700: oGetParam 1
6702: oPushResult
6703: oSetResult 33
6705: oPushResult
6706: oNodeGetBoolean
6707: oPop 2
6709: oChoice 6752
6711: oGetLocal 2
6713: oPushResult
6714: equal_zero
6715: oPop 1
6717: oChoice 6730
6719: oEmit 8
6721: oGetParam 1
6723: oPushResult
6724: oCall 10773
6726: oPop 1
6728: oJumpForward 6748
6730: Choice Lookup Table
           1   6719
6733: oEmit 14
6735: oGetLocal 2
6737: oPushResult
6738: oEmitInt
6739: oPop 1
6741: oGetParam 1
6743: oPushResult
6744: oCall 10773
6746: oPop 1
6748: oEmit 22
6750: oJumpForward 6792
6752: Choice Lookup Table
           1   6711
6755: oGetLocal 2
6757: oPushResult
6758: equal_zero
6759: oPop 1
6761: oChoice 6774
6763: oEmit 6
6765: oGetParam 1
6767: oPushResult
6768: oCall 10773
6770: oPop 1
6772: oJumpForward 6792
6774: Choice Lookup Table
           1   6763
6777: oEmit 12
6779: oGetLocal 2
6781: oPushResult
6782: oEmitInt
6783: oPop 1
6785: oGetParam 1
6787: oPushResult
6788: oCall 10773
6790: oPop 1
6792: oJumpForward 6804
6794: Choice Lookup Table
          23   6700
          21   6661
          24   6650
          20   6650
6803: oEndChoice
6804: oJumpForward 7363
6806: oGetParam 1
6808: oPushResult
6809: oNodeType
6810: oPop 1
6812: oChoice 6958
6814: oEmit 1
6816: oGetParam 1
6818: oPushResult
6819: oCall 10773
6821: oPop 1
6823: oJumpForward 6968
6825: oGetLocal 2
6827: oPushResult
6828: equal_zero
6829: oPop 1
6831: oChoice 6844
6833: oEmit 4
6835: oGetParam 1
6837: oPushResult
6838: oCall 10773
6840: oPop 1
6842: oJumpForward 6862
6844: Choice Lookup Table
           1   6833
6847: oEmit 10
6849: oGetLocal 2
6851: oPushResult
6852: oEmitInt
6853: oPop 1
6855: oGetParam 1
6857: oPushResult
6858: oCall 10773
6860: oPop 1
6862: oJumpForward 6968
6864: oGetParam 1
6866: oPushResult
6867: oSetResult 33
6869: oPushResult
6870: oNodeGetBoolean
6871: oPop 2
6873: oChoice 6916
6875: oGetLocal 2
6877: oPushResult
6878: equal_zero
6879: oPop 1
6881: oChoice 6894
6883: oEmit 8
6885: oGetParam 1
6887: oPushResult
6888: oCall 10773
6890: oPop 1
6892: oJumpForward 6912
6894: Choice Lookup Table
           1   6883
6897: oEmit 14
6899: oGetLocal 2
6901: oPushResult
6902: oEmitInt
6903: oPop 1
6905: oGetParam 1
6907: oPushResult
6908: oCall 10773
6910: oPop 1
6912: oEmit 23
6914: oJumpForward 6956
6916: Choice Lookup Table
           1   6875
6919: oGetLocal 2
6921: oPushResult
6922: equal_zero
6923: oPop 1
6925: oChoice 6938
6927: oEmit 7
6929: oGetParam 1
6931: oPushResult
6932: oCall 10773
6934: oPop 1
6936: oJumpForward 6956
6938: Choice Lookup Table
           1   6927
6941: oEmit 13
6943: oGetLocal 2
6945: oPushResult
6946: oEmitInt
6947: oPop 1
6949: oGetParam 1
6951: oPushResult
6952: oCall 10773
6954: oPop 1
6956: oJumpForward 6968
6958: Choice Lookup Table
          23   6864
          21   6825
          24   6814
          20   6814
6967: oEndChoice
6968: oJumpForward 7363
6970: oError 16
6972: oJumpForward 7363
6974: oGetParam 1
6976: oPushResult
6977: oNodeType
6978: oPop 1
6980: oChoice 7126
6982: oEmit 2
6984: oGetParam 1
6986: oPushResult
6987: oCall 10773
6989: oPop 1
6991: oJumpForward 7136
6993: oGetLocal 2
6995: oPushResult
6996: equal_zero
6997: oPop 1
6999: oChoice 7012
7001: oEmit 5
7003: oGetParam 1
7005: oPushResult
7006: oCall 10773
7008: oPop 1
7010: oJumpForward 7030
7012: Choice Lookup Table
           1   7001
7015: oEmit 11
7017: oGetLocal 2
7019: oPushResult
7020: oEmitInt
7021: oPop 1
7023: oGetParam 1
7025: oPushResult
7026: oCall 10773
7028: oPop 1
7030: oJumpForward 7136
7032: oGetParam 1
7034: oPushResult
7035: oSetResult 33
7037: oPushResult
7038: oNodeGetBoolean
7039: oPop 2
7041: oChoice 7084
7043: oGetLocal 2
7045: oPushResult
7046: equal_zero
7047: oPop 1
7049: oChoice 7062
7051: oEmit 8
7053: oGetParam 1
7055: oPushResult
7056: oCall 10773
7058: oPop 1
7060: oJumpForward 7080
7062: Choice Lookup Table
           1   7051
7065: oEmit 14
7067: oGetLocal 2
7069: oPushResult
7070: oEmitInt
7071: oPop 1
7073: oGetParam 1
7075: oPushResult
7076: oCall 10773
7078: oPop 1
7080: oEmit 24
7082: oJumpForward 7124
7084: Choice Lookup Table
           1   7043
7087: oGetLocal 2
7089: oPushResult
7090: equal_zero
7091: oPop 1
7093: oChoice 7106
7095: oEmit 8
7097: oGetParam 1
7099: oPushResult
7100: oCall 10773
7102: oPop 1
7104: oJumpForward 7124
7106: Choice Lookup Table
           1   7095
7109: oEmit 14
7111: oGetLocal 2
7113: oPushResult
7114: oEmitInt
7115: oPop 1
7117: oGetParam 1
7119: oPushResult
7120: oCall 10773
7122: oPop 1
7124: oJumpForward 7136
7126: Choice Lookup Table
          23   7032
          21   6993
          24   6982
          20   6982
7135: oEndChoice
7136: oInputChoice 7166
7138: oTypeSPop
7139: oGetLocal 1
7141: oPushResult
7142: oSetResult 36
7144: oPushResult
7145: oNodeGet
7146: oPop 2
7148: oPushResult
7149: oTypeSPush
7150: oPop 1
7152: oCall 7418
7154: oCall 7364
7156: oJumpForward 7171
7158: oCall 7613
7160: oCall 7418
7162: oCall 7364
7164: oJumpForward 7171
7166: Choice Lookup Table
          16   7158
          18   7138
7171: oJumpForward 7363
7173: oGetParam 1
7175: oPushResult
7176: oNodeType
7177: oPop 1
7179: oChoice 7323
7181: oEmit 16
7183: oGetParam 1
7185: oPushResult
7186: oCall 10773
7188: oPop 1
7190: oJumpForward 7333
7192: oGetLocal 2
7194: oPushResult
7195: equal_zero
7196: oPop 1
7198: oChoice 7211
7200: oEmit 17
7202: oGetParam 1
7204: oPushResult
7205: oCall 10773
7207: oPop 1
7209: oJumpForward 7229
7211: Choice Lookup Table
           1   7200
7214: oEmit 20
7216: oGetLocal 2
7218: oPushResult
7219: oEmitInt
7220: oPop 1
7222: oGetParam 1
7224: oPushResult
7225: oCall 10773
7227: oPop 1
7229: oJumpForward 7333
7231: oGetParam 1
7233: oPushResult
7234: oSetResult 33
7236: oPushResult
7237: oNodeGetBoolean
7238: oPop 2
7240: oChoice 7281
7242: oGetLocal 2
7244: oPushResult
7245: equal_zero
7246: oPop 1
7248: oChoice 7261
7250: oEmit 8
7252: oGetParam 1
7254: oPushResult
7255: oCall 10773
7257: oPop 1
7259: oJumpForward 7279
7261: Choice Lookup Table
           1   7250
7264: oEmit 14
7266: oGetLocal 2
7268: oPushResult
7269: oEmitInt
7270: oPop 1
7272: oGetParam 1
7274: oPushResult
7275: oCall 10773
7277: oPop 1
7279: oJumpForward 7321
7281: Choice Lookup Table
           1   7242
7284: oGetLocal 2
7286: oPushResult
7287: equal_zero
7288: oPop 1
7290: oChoice 7303
7292: oEmit 18
7294: oGetParam 1
7296: oPushResult
7297: oCall 10773
7299: oPop 1
7301: oJumpForward 7321
7303: Choice Lookup Table
           1   7292
7306: oEmit 21
7308: oGetLocal 2
7310: oPushResult
7311: oEmitInt
7312: oPop 1
7314: oGetParam 1
7316: oPushResult
7317: oCall 10773
7319: oPop 1
7321: oJumpForward 7333
7323: Choice Lookup Table
          23   7231
          21   7192
          24   7181
          20   7181
7332: oEndChoice
7333: oCall 7418
7335: oCall 7364
7337: oJumpForward 7363
7339: Choice Lookup Table
          39   7173
          37   7173
          35   7173
          34   6974
          33   6974
          27   6970
          32   6806
          29   6806
          30   6806
          40   6642
          28   6642
7362: oEndChoice
7363: oReturn
7364: oLocalSpace 0
7366: oTypeSNodeType
7367: oChoice 7391
7369: oEmit 22
7371: oJumpForward 7417
7373: oEmit 23
7375: oJumpForward 7417
7377: oError 16
7379: oJumpForward 7417
7381: oEmit 24
7383: oJumpForward 7417
7385: oError 29
7387: oJumpForward 7417
7389: oJumpForward 7417
7391: Choice Lookup Table
          39   7389
          38   7389
          37   7389
          35   7389
          34   7385
          33   7381
          27   7377
          32   7373
          29   7373
          30   7373
          40   7369
          28   7369
7416: oEndChoice
7417: oReturn
7418: oLocalSpace 0
7420: oInputChoice 7458
7422: oTypeSNodeType
7423: oChoice 7437
7425: oCall 7470
7427: oJumpForward 7448
7429: oCall 7613
7431: oJumpForward 7448
7433: oCall 7692
7435: oJumpForward 7448
7437: Choice Lookup Table
          39   7433
          38   7433
          33   7429
          35   7425
7446: oError 10
7448: oJumpForward 7467
7450: oCall 7722
7452: oJumpForward 7467
7454: oCall 7820
7456: oJumpForward 7467
7458: Choice Lookup Table
          18   7454
          20   7450
          16   7422
7465: oJumpForward 7469
7467: oJumpBack 7420
7469: oReturn
7470: oLocalSpace 3
7472: oTypeSNodeType
7473: oChoice 7477
7475: oJumpForward 7482
7477: Choice Lookup Table
          35   7475
7480: oError 10
7482: oTypeSNodeType
7483: oChoice 7487
7485: oJumpForward 7492
7487: Choice Lookup Table
          35   7485
7490: oError 13
7492: oGetAddrLocal 1
7494: oPushResult
7495: oTypeSTop
7496: oPushResult
7497: oSetResult 37
7499: oPushResult
7500: oNodeGet
7501: oPop 2
7503: oPushResult
7504: oCall 10583
7506: oPop 1
7508: oAssign
7509: oGetAddrLocal 2
7511: oPushResult
7512: oTypeSTop
7513: oPushResult
7514: oSetResult 36
7516: oPushResult
7517: oNodeGet
7518: oPop 2
7520: oAssign
7521: oTypeSPop
7522: oGetLocal 2
7524: oPushResult
7525: oTypeSPush
7526: oPop 1
7528: oCall 5092
7530: oCall 10317
7532: oGetLocal 1
7534: oPushResult
7535: equal_zero
7536: oPop 1
7538: oChoice 7552
7540: oEmit 15
7542: oGetLocal 1
7544: oPushResult
7545: oEmitInt
7546: oPop 1
7548: oEmit 37
7550: oJumpForward 7555
7552: Choice Lookup Table
           0   7540
7555: oGetAddrLocal 3
7557: oPushResult
7558: oGetLocal 2
7560: oPushResult
7561: oSetResult 17
7563: oPushResult
7564: oNodeGetInt
7565: oPop 2
7567: oAssign
7568: oGetLocal 3
7570: oPushResult
7571: oSetResult 1
7573: oPushResult
7574: equal
7575: oPop 2
7577: oChoice 7591
7579: oEmit 15
7581: oGetLocal 3
7583: oPushResult
7584: oEmitInt
7585: oPop 1
7587: oEmit 33
7589: oJumpForward 7594
7591: Choice Lookup Table
           0   7579
7594: oEmit 35
7596: oInputChoice 7604
7598: oJumpForward 7612
7600: oJumpForward 7610
7602: oJumpForward 7610
7604: Choice Lookup Table
          13   7602
          17   7598
7609: oEndChoice
7610: oJumpBack 7482
7612: oReturn
7613: oLocalSpace 2
7615: oTypeSNodeType
7616: oChoice 7620
7618: oJumpForward 7625
7620: Choice Lookup Table
          33   7618
7623: oError 29
7625: oGetAddrLocal 1
7627: oPushResult
7628: oTypeSTop
7629: oPushResult
7630: oSetResult 36
7632: oPushResult
7633: oNodeGet
7634: oPop 2
7636: oAssign
7637: oTypeSPop
7638: oGetLocal 1
7640: oPushResult
7641: oTypeSPush
7642: oPop 1
7644: oCall 5092
7646: oCall 10317
7648: oGetAddrLocal 2
7650: oPushResult
7651: oGetLocal 1
7653: oPushResult
7654: oSetResult 17
7656: oPushResult
7657: oNodeGetInt
7658: oPop 2
7660: oAssign
7661: oGetLocal 2
7663: oPushResult
7664: oSetResult 1
7666: oPushResult
7667: equal
7668: oPop 2
7670: oChoice 7684
7672: oEmit 15
7674: oGetLocal 2
7676: oPushResult
7677: oEmitInt
7678: oPop 1
7680: oEmit 33
7682: oJumpForward 7687
7684: Choice Lookup Table
           0   7672
7687: oEmit 35
7689: oInput 17
7691: oReturn
7692: oLocalSpace 0
7694: oTypeSNodeType
7695: oChoice 7699
7697: oJumpForward 7706
7699: Choice Lookup Table
          39   7697
          38   7697
7704: oError 29
7706: oTypeSPop
7707: oGetGlobal 9
7709: oPushResult
7710: oTypeSPush
7711: oPop 1
7713: oCall 5092
7715: oCall 10317
7717: oEmit 35
7719: oInput 17
7721: oReturn
7722: oLocalSpace 2
7724: oTypeSNodeType
7725: oChoice 7729
7727: oJumpForward 7734
7729: Choice Lookup Table
          37   7727
7732: oError 11
7734: oTypeSTop
7735: oPushResult
7736: oSetResult 40
7738: oPushResult
7739: oNodeGet
7740: oPop 2
7742: oPushResult
7743: oScopeEnter
7744: oPop 1
7746: oInput 0
7748: oGetAddrLocal 1
7750: oPushResult
7751: oScopeFindRequire
7752: oAssign
7753: oGetLocal 1
7755: oPushResult
7756: oNodeType
7757: oPop 1
7759: oChoice 7763
7761: oJumpForward 7768
7763: Choice Lookup Table
          22   7761
7766: oError 12
7768: oScopeEnd
7769: oGetAddrLocal 2
7771: oPushResult
7772: oGetLocal 1
7774: oPushResult
7775: oSetResult 22
7777: oPushResult
7778: oNodeGetInt
7779: oPop 2
7781: oAssign
7782: oGetLocal 2
7784: oPushResult
7785: equal_zero
7786: oPop 1
7788: oChoice 7802
7790: oEmit 15
7792: oGetLocal 2
7794: oPushResult
7795: oEmitInt
7796: oPop 1
7798: oEmit 35
7800: oJumpForward 7805
7802: Choice Lookup Table
           0   7790
7805: oTypeSPop
7806: oGetLocal 1
7808: oPushResult
7809: oSetResult 21
7811: oPushResult
7812: oNodeGet
7813: oPop 2
7815: oPushResult
7816: oTypeSPush
7817: oPop 1
7819: oReturn
7820: oLocalSpace 1
7822: oTypeSNodeType
7823: oChoice 7831
7825: oJumpForward 7838
7827: oError 29
7829: oJumpForward 7838
7831: Choice Lookup Table
          34   7827
          33   7825
7836: oError 9
7838: oEmit 24
7840: oGetAddrLocal 1
7842: oPushResult
7843: oTypeSTop
7844: oAssign
7845: oTypeSPop
7846: oGetLocal 1
7848: oPushResult
7849: oSetResult 36
7851: oPushResult
7852: oNodeGet
7853: oPop 2
7855: oPushResult
7856: oTypeSPush
7857: oPop 1
7859: oReturn
7860: oLocalSpace 1
7862: oGetAddrLocal 1
7864: oPushResult
7865: oTypeSNodeType
7866: oAssign
7867: oTypeSPop
7868: oGetLocal 1
7870: oPushResult
7871: oTypeSNodeType
7872: oPushResult
7873: equal_node_type
7874: oPop 2
7876: oChoice 7990
7878: oTypeSNodeType
7879: oChoice 7975
7881: oGetLocal 1
7883: oChoice 7890
7885: oEmit 29
7887: oReturn
7888: oJumpForward 7893
7890: Choice Lookup Table
          29   7885
7893: oJumpForward 7986
7895: oGetLocal 1
7897: oChoice 7904
7899: oEmit 30
7901: oReturn
7902: oJumpForward 7907
7904: Choice Lookup Table
          28   7899
7907: oJumpForward 7986
7909: oGetLocal 1
7911: oChoice 7944
7913: oReturn
7914: oJumpForward 7949
7916: oTypeSTop
7917: oPushResult
7918: oGetGlobal 10
7920: oPushResult
7921: equal_node
7922: oPop 2
7924: oChoice 7939
7926: oEmit 15
7928: oSetResult 1
7930: oPushResult
7931: oEmitInt
7932: oPop 1
7934: oEmit 35
7936: oReturn
7937: oJumpForward 7942
7939: Choice Lookup Table
           1   7926
7942: oJumpForward 7949
7944: Choice Lookup Table
          38   7916
          34   7913
7949: oJumpForward 7986
7951: oGetLocal 1
7953: oChoice 7958
7955: oReturn
7956: oJumpForward 7961
7958: Choice Lookup Table
          33   7955
7961: oJumpForward 7986
7963: oGetLocal 1
7965: oChoice 7970
7967: oReturn
7968: oJumpForward 7973
7970: Choice Lookup Table
          38   7967
7973: oJumpForward 7986
7975: Choice Lookup Table
          39   7963
          34   7951
          33   7909
          29   7895
          28   7881
7986: oError 14
7988: oJumpForward 7993
7990: Choice Lookup Table
           0   7878
7993: oReturn
7994: oLocalSpace 2
7996: oGetAddrLocal 2
7998: oPushResult
7999: oGetParam 1
8001: oPushResult
8002: oSetResult 26
8004: oPushResult
8005: oNodeGetString
8006: oPop 2
8008: oAssign
8009: oGetLocal 2
8011: oPushResult
8012: oSetResult 0
8014: oPushResult
8015: equal_string
8016: oPop 2
8018: oChoice 8055
8020: oGetAddrLocal 1
8022: oPushResult
8023: oGetParam 1
8025: oPushResult
8026: oSetResult 4
8028: oPushResult
8029: oNodeGetInt
8030: oPop 2
8032: oPushResult
8033: ID_STRING
8034: oPop 1
8036: oPushResult
8037: oStringAllocLit
8038: oPop 1
8040: oAssign
8041: oJumpForward 8061
8043: oGetAddrLocal 1
8045: oPushResult
8046: oGetLocal 2
8048: oPushResult
8049: oStringAllocLit
8050: oPop 1
8052: oAssign
8053: oJumpForward 8061
8055: Choice Lookup Table
           0   8043
           1   8020
8060: oEndChoice
8061: oEmit 70
8063: oGetParam 1
8065: oPushResult
8066: oCall 10773
8068: oPop 1
8070: oGetLocal 1
8072: oPushResult
8073: oEmitInt
8074: oPop 1
8076: oReturn
8077: oLocalSpace 10
8079: oGetParam 1
8081: oPushResult
8082: oSetResult 25
8084: oPushResult
8085: oNodeGetBoolean
8086: oPop 2
8088: oChoice 8115
8090: oGetParam 1
8092: oPushResult
8093: oSetResult 28
8095: oPushResult
8096: oNodeGetBoolean
8097: oPop 2
8099: oChoice 8110
8101: oGetParam 1
8103: oPushResult
8104: oCall 7994
8106: oPop 1
8108: oJumpForward 8113
8110: Choice Lookup Table
           0   8101
8113: oJumpForward 8118
8115: Choice Lookup Table
           1   8090
8118: oGetParam 1
8120: oPushResult
8121: oSetResult 28
8123: oPushResult
8124: oSetResult 1
8126: oPushResult
8127: oNodeSetBoolean
8128: oPop 3
8130: oGetAddrLocal 1
8132: oPushResult
8133: oGetParam 1
8135: oPushResult
8136: oSetResult 27
8138: oPushResult
8139: oNodeGetBoolean
8140: oPop 2
8142: oAssign
8143: oGetAddrLocal 4
8145: oPushResult
8146: oGetParam 1
8148: oPushResult
8149: oNodeType
8150: oPop 1
8152: oPushResult
8153: oSetResult 13
8155: oPushResult
8156: equal_node_type
8157: oPop 2
8159: oAssign
8160: oGetLocal 4
8162: oChoice 8189
8164: oGetAddrLocal 2
8166: oPushResult
8167: oGetParam 1
8169: oPushResult
8170: oSetResult 21
8172: oPushResult
8173: oNodeGet
8174: oPop 2
8176: oAssign
8177: oGetAddrLocal 3
8179: oPushResult
8180: oGetLocal 2
8182: oPushResult
8183: oScopeAllocType
8184: oPop 1
8186: oAssign
8187: oJumpForward 8192
8189: Choice Lookup Table
           1   8164
8192: oGetAddrLocal 5
8194: oPushResult
8195: oGetParam 1
8197: oPushResult
8198: oSetResult 23
8200: oPushResult
8201: oNodeGet
8202: oPop 2
8204: oAssign
8205: oGetAddrLocal 6
8207: oPushResult
8208: oGetLocal 5
8210: oPushResult
8211: oSetResult 17
8213: oPushResult
8214: oNodeGetInt
8215: oPop 2
8217: oAssign
8218: oGetLocal 1
8220: oChoice 8242
8222: oEmit 59
8224: oGetLocal 6
8226: oPushResult
8227: oEmitInt
8228: oPop 1
8230: oJumpForward 8248
8232: oEmit 58
8234: oGetLocal 6
8236: oPushResult
8237: oEmitInt
8238: oPop 1
8240: oJumpForward 8248
8242: Choice Lookup Table
           0   8232
           1   8222
8247: oEndChoice
8248: oGetParam 1
8250: oPushResult
8251: oCall 10221
8253: oPop 1
8255: oPushResult
8256: oSetResult 0
8258: oPushResult
8259: greater
8260: oPop 2
8262: oChoice 8295
8264: oEmit 19
8266: oSetResult 0
8268: oPushResult
8269: oEmitInt
8270: oPop 1
8272: oEmit 20
8274: oGetParam 1
8276: oPushResult
8277: oCall 10241
8279: oPop 1
8281: oPushResult
8282: oEmitInt
8283: oPop 1
8285: oSetResult 0
8287: oPushResult
8288: oEmitInt
8289: oPop 1
8291: oEmit 27
8293: oJumpForward 8298
8295: Choice Lookup Table
           1   8264
8298: oGetAddrLocal 7
8300: oPushResult
8301: oGetLocal 5
8303: oPushResult
8304: oSetResult 15
8306: oPushResult
8307: oNodeGetIter
8308: oPop 2
8310: oAssign
8311: oGetAddrLocal 8
8313: oPushResult
8314: oGetLocal 7
8316: oPushResult
8317: oNodeIterValue
8318: oPop 1
8320: oAssign
8321: oInputChoice 8518
8323: oGetLocal 8
8325: oPushResult
8326: oNodeNull
8327: oPop 1
8329: oChoice 8335
8331: oJumpForward 8514
8333: oJumpForward 8338
8335: Choice Lookup Table
           1   8331
8338: oGetAddrLocal 9
8340: oPushResult
8341: oGetLocal 8
8343: oPushResult
8344: oSetResult 22
8346: oPushResult
8347: oNodeGetInt
8348: oPop 2
8350: oAssign
8351: oEmit 19
8353: oGetLocal 9
8355: oPushResult
8356: oEmitInt
8357: oPop 1
8359: oGetLocal 8
8361: oPushResult
8362: oSetResult 21
8364: oPushResult
8365: oNodeGet
8366: oPop 2
8368: oPushResult
8369: oTypeSPush
8370: oPop 1
8372: oGetLocal 8
8374: oPushResult
8375: oSetResult 33
8377: oPushResult
8378: oNodeGetBoolean
8379: oPop 2
8381: oChoice 8467
8383: oSetResult 1
8385: oPushResult
8386: oCall 9338
8388: oPop 1
8390: oCall 10259
8392: oEmit 27
8394: oJumpForward 8473
8396: oCall 5092
8398: oCall 7860
8400: oTypeSNodeType
8401: oChoice 8441
8403: oEmit 25
8405: oJumpForward 8465
8407: oEmit 26
8409: oJumpForward 8465
8411: oError 16
8413: oJumpForward 8465
8415: oEmit 27
8417: oJumpForward 8465
8419: oGetAddrLocal 10
8421: oPushResult
8422: oTypeSTop
8423: oPushResult
8424: oSetResult 17
8426: oPushResult
8427: oNodeGetInt
8428: oPop 2
8430: oAssign
8431: oEmit 28
8433: oGetLocal 10
8435: oPushResult
8436: oEmitInt
8437: oPop 1
8439: oJumpForward 8465
8441: Choice Lookup Table
          39   8419
          37   8419
          35   8419
          34   8415
          33   8415
          27   8411
          32   8407
          29   8407
          30   8407
          40   8403
          28   8403
8464: oEndChoice
8465: oJumpForward 8473
8467: Choice Lookup Table
           0   8396
           1   8383
8472: oEndChoice
8473: oTypeSPop
8474: oGetAddrLocal 7
8476: oPushResult
8477: oNodeIterNext
8478: oPop 1
8480: oGetAddrLocal 8
8482: oPushResult
8483: oGetLocal 7
8485: oPushResult
8486: oNodeIterValue
8487: oPop 1
8489: oAssign
8490: oGetLocal 8
8492: oPushResult
8493: oNodeNull
8494: oPop 1
8496: oChoice 8504
8498: oJumpForward 8514
8500: oJumpForward 8510
8502: oJumpForward 8510
8504: Choice Lookup Table
           0   8502
           1   8498
8509: oEndChoice
8510: oInput 13
8512: oJumpBack 8323
8514: oInput 15
8516: oJumpForward 8521
8518: Choice Lookup Table
          14   8323
8521: oGetLocal 8
8523: oPushResult
8524: oNodeNull
8525: oPop 1
8527: oChoice 8533
8529: oError 15
8531: oJumpForward 8536
8533: Choice Lookup Table
           0   8529
8536: oGetLocal 4
8538: oChoice 8567
8540: oEmit 19
8542: oGetParam 1
8544: oPushResult
8545: oSetResult 31
8547: oPushResult
8548: oNodeGetInt
8549: oPop 2
8551: oPushResult
8552: oEmitInt
8553: oPop 1
8555: oEmit 17
8557: oGetLocal 3
8559: oPushResult
8560: oEmitInt
8561: oPop 1
8563: oEmit 27
8565: oJumpForward 8570
8567: Choice Lookup Table
           1   8540
8570: oGetLocal 1
8572: oChoice 8596
8574: oEmit 62
8576: oGetParam 1
8578: oPushResult
8579: oCall 10773
8581: oPop 1
8583: oJumpForward 8602
8585: oEmit 61
8587: oGetParam 1
8589: oPushResult
8590: oCall 10773
8592: oPop 1
8594: oJumpForward 8602
8596: Choice Lookup Table
           0   8585
           1   8574
8601: oEndChoice
8602: oGetLocal 4
8604: oChoice 8685
8606: oGetLocal 2
8608: oPushResult
8609: oTypeSPush
8610: oPop 1
8612: oTypeSNodeType
8613: oChoice 8659
8615: oEmit 3
8617: oGetLocal 3
8619: oPushResult
8620: oEmitInt
8621: oPop 1
8623: oJumpForward 8683
8625: oEmit 4
8627: oGetLocal 3
8629: oPushResult
8630: oEmitInt
8631: oPop 1
8633: oJumpForward 8683
8635: oError 16
8637: oJumpForward 8683
8639: oEmit 5
8641: oGetLocal 3
8643: oPushResult
8644: oEmitInt
8645: oPop 1
8647: oJumpForward 8683
8649: oEmit 17
8651: oGetLocal 3
8653: oPushResult
8654: oEmitInt
8655: oPop 1
8657: oJumpForward 8683
8659: Choice Lookup Table
          39   8649
          37   8649
          35   8649
          34   8639
          33   8639
          27   8635
          32   8625
          29   8625
          30   8625
          40   8615
          28   8615
8682: oEndChoice
8683: oJumpForward 8688
8685: Choice Lookup Table
           1   8606
8688: oEmit 60
8690: oGetLocal 6
8692: oPushResult
8693: oEmitInt
8694: oPop 1
8696: oReturn
8697: oLocalSpace 0
8699: oGetParam 1
8701: oPushResult
8702: oGetGlobal 15
8704: oPushResult
8705: oNodeEqual
8706: oPop 2
8708: oChoice 8748
8710: oInput 14
8712: oCall 5092
8714: oTypeSNodeType
8715: oChoice 8723
8717: oJumpForward 8736
8719: oEmit 29
8721: oJumpForward 8736
8723: Choice Lookup Table
          32   8719
          29   8719
          30   8719
          40   8717
          28   8717
8734: oError 14
8736: oTypeSPop
8737: oGetGlobal 6
8739: oPushResult
8740: oTypeSPush
8741: oPop 1
8743: oInput 15
8745: oReturn
8746: oJumpForward 8751
8748: Choice Lookup Table
           1   8710
8751: oGetParam 1
8753: oPushResult
8754: oGetGlobal 16
8756: oPushResult
8757: oNodeEqual
8758: oPop 2
8760: oChoice 8794
8762: oInput 14
8764: oCall 5092
8766: oTypeSNodeType
8767: oChoice 8775
8769: oEmit 30
8771: oJumpForward 8782
8773: oJumpForward 8782
8775: Choice Lookup Table
          29   8773
          28   8769
8780: oError 14
8782: oTypeSPop
8783: oGetGlobal 9
8785: oPushResult
8786: oTypeSPush
8787: oPop 1
8789: oInput 15
8791: oReturn
8792: oJumpForward 8797
8794: Choice Lookup Table
           1   8762
8797: oGetParam 1
8799: oPushResult
8800: oGetGlobal 17
8802: oPushResult
8803: oNodeEqual
8804: oPop 2
8806: oChoice 8846
8808: oInput 14
8810: oCall 5092
8812: oTypeSNodeType
8813: oChoice 8834
8815: oTypeSTop
8816: oPushResult
8817: oSetResult 43
8819: oPushResult
8820: oNodeGetBoolean
8821: oPop 2
8823: oChoice 8829
8825: oError 28
8827: oJumpForward 8832
8829: Choice Lookup Table
           1   8825
8832: oJumpForward 8839
8834: Choice Lookup Table
          40   8815
8837: oError 14
8839: oEmit 32
8841: oInput 15
8843: oReturn
8844: oJumpForward 8849
8846: Choice Lookup Table
           1   8808
8849: oGetParam 1
8851: oPushResult
8852: oGetGlobal 18
8854: oPushResult
8855: oNodeEqual
8856: oPop 2
8858: oChoice 8898
8860: oInput 14
8862: oCall 5092
8864: oTypeSNodeType
8865: oChoice 8886
8867: oTypeSTop
8868: oPushResult
8869: oSetResult 43
8871: oPushResult
8872: oNodeGetBoolean
8873: oPop 2
8875: oChoice 8881
8877: oError 28
8879: oJumpForward 8884
8881: Choice Lookup Table
           1   8877
8884: oJumpForward 8891
8886: Choice Lookup Table
          40   8867
8889: oError 14
8891: oEmit 31
8893: oInput 15
8895: oReturn
8896: oJumpForward 8901
8898: Choice Lookup Table
           1   8860
8901: oError 16
8903: oReturn
8904: oLocalSpace 0
8906: oInputChoice 8965
8908: oCall 10072
8910: oJumpForward 8994
8912: oCall 10079
8914: oJumpForward 8994
8916: oCall 10203
8918: oJumpForward 8994
8920: oCall 10206
8922: oJumpForward 8994
8924: oCall 9557
8926: oJumpForward 8994
8928: oCall 9880
8930: oJumpForward 8994
8932: oCall 9623
8934: oJumpForward 8994
8936: oCall 9800
8938: oJumpForward 8994
8940: oCall 9965
8942: oJumpForward 8994
8944: oCall 9933
8946: oJumpForward 8994
8948: oCall 10049
8950: oJumpForward 8994
8952: oCall 8995
8954: oJumpForward 8994
8956: oCall 9997
8958: oJumpForward 8994
8960: oChangeIntLitToLabelIdent
8961: oCall 8995
8963: oJumpForward 8994
8965: Choice Lookup Table
           1   8960
          53   8956
           0   8952
          35   8948
          51   8944
          52   8940
          49   8936
          44   8932
          48   8928
          41   8924
          66   8920
          65   8916
          64   8912
          63   8908
8994: oReturn
8995: oLocalSpace 1
8997: oGetAddrLocal 1
8999: oPushResult
9000: oScopeFindRequire
9001: oAssign
9002: oGetAddrLocal 1
9004: oPushResult
9005: oCall 466
9007: oPop 1
9009: oGetLocal 1
9011: oPushResult
9012: oNodeType
9013: oPop 1
9015: oChoice 9055
9017: oGetLocal 1
9019: oPushResult
9020: oCall 9071
9022: oPop 1
9024: oCall 8904
9026: oJumpForward 9070
9028: oGetLocal 1
9030: oPushResult
9031: oCall 8077
9033: oPop 1
9035: oJumpForward 9070
9037: oGetLocal 1
9039: oPushResult
9040: oCall 9121
9042: oPop 1
9044: oJumpForward 9070
9046: oGetLocal 1
9048: oPushResult
9049: oCall 9211
9051: oPop 1
9053: oJumpForward 9070
9055: Choice Lookup Table
          13   9046
          23   9037
          21   9037
          20   9037
          12   9028
          25   9017
9068: oError 0
9070: oReturn
9071: oLocalSpace 0
9073: oGetParam 1
9075: oPushResult
9076: oSetResult 34
9078: oPushResult
9079: oNodeGetBoolean
9080: oPop 2
9082: oChoice 9088
9084: oError 21
9086: oJumpForward 9091
9088: Choice Lookup Table
           1   9084
9091: oEmit 68
9093: oGetParam 1
9095: oPushResult
9096: oSetResult 22
9098: oPushResult
9099: oNodeGetLabel
9100: oPop 2
9102: oPushResult
9103: oEmitLabel
9104: oPop 1
9106: oGetParam 1
9108: oPushResult
9109: oSetResult 34
9111: oPushResult
9112: oSetResult 1
9114: oPushResult
9115: oNodeSetBoolean
9116: oPop 3
9118: oInput 12
9120: oReturn
9121: oLocalSpace 0
9123: oGetParam 1
9125: oPushResult
9126: oSetResult 1
9128: oPushResult
9129: oCall 9386
9131: oPop 2
9133: oInput 4
9135: oCall 5092
9137: oCall 7860
9139: oCall 9142
9141: oReturn
9142: oLocalSpace 1
9144: oTypeSNodeType
9145: oChoice 9185
9147: oEmit 25
9149: oJumpForward 9209
9151: oEmit 26
9153: oJumpForward 9209
9155: oError 16
9157: oJumpForward 9209
9159: oEmit 27
9161: oJumpForward 9209
9163: oGetAddrLocal 1
9165: oPushResult
9166: oTypeSTop
9167: oPushResult
9168: oSetResult 17
9170: oPushResult
9171: oNodeGetInt
9172: oPop 2
9174: oAssign
9175: oEmit 28
9177: oGetLocal 1
9179: oPushResult
9180: oEmitInt
9181: oPop 1
9183: oJumpForward 9209
9185: Choice Lookup Table
          39   9163
          37   9163
          35   9163
          34   9159
          33   9159
          27   9155
          32   9151
          29   9151
          30   9151
          40   9147
          28   9147
9208: oEndChoice
9209: oTypeSPop
9210: oReturn
9211: oLocalSpace 1
9213: oGetParam 1
9215: oPushResult
9216: oSetResult 6
9218: oPushResult
9219: oNodeGet
9220: oPop 2
9222: oPushResult
9223: oScopeCurrent
9224: oPushResult
9225: oNodeEqual
9226: oPop 2
9228: oChoice 9234
9230: oError 20
9232: oJumpForward 9237
9234: Choice Lookup Table
           0   9230
9237: oEmit 8
9239: oGetParam 1
9241: oPushResult
9242: oSetResult 31
9244: oPushResult
9245: oNodeGetInt
9246: oPop 2
9248: oPushResult
9249: oEmitInt
9250: oPop 1
9252: oGetParam 1
9254: oPushResult
9255: oSetResult 21
9257: oPushResult
9258: oNodeGet
9259: oPop 2
9261: oPushResult
9262: oTypeSPush
9263: oPop 1
9265: oInput 4
9267: oCall 5092
9269: oCall 7860
9271: oTypeSNodeType
9272: oChoice 9312
9274: oEmit 25
9276: oJumpForward 9336
9278: oEmit 26
9280: oJumpForward 9336
9282: oError 16
9284: oJumpForward 9336
9286: oEmit 27
9288: oJumpForward 9336
9290: oGetAddrLocal 1
9292: oPushResult
9293: oTypeSTop
9294: oPushResult
9295: oSetResult 17
9297: oPushResult
9298: oNodeGetInt
9299: oPop 2
9301: oAssign
9302: oEmit 28
9304: oGetLocal 1
9306: oPushResult
9307: oEmitInt
9308: oPop 1
9310: oJumpForward 9336
9312: Choice Lookup Table
          39   9290
          37   9290
          35   9290
          34   9286
          33   9286
          27   9282
          32   9278
          29   9278
          30   9278
          40   9274
          28   9274
9335: oEndChoice
9336: oTypeSPop
9337: oReturn
9338: oLocalSpace 1
9340: oInput 0
9342: oGetAddrLocal 1
9344: oPushResult
9345: oScopeFindRequire
9346: oAssign
9347: oGetAddrLocal 1
9349: oPushResult
9350: oCall 466
9352: oPop 1
9354: oGetLocal 1
9356: oPushResult
9357: oNodeType
9358: oPop 1
9360: oChoice 9364
9362: oJumpForward 9375
9364: Choice Lookup Table
          24   9362
          23   9362
          21   9362
          20   9362
9373: oError 4
9375: oGetLocal 1
9377: oPushResult
9378: oGetParam 1
9380: oPushResult
9381: oCall 9386
9383: oPop 2
9385: oReturn
9386: oLocalSpace 0
9388: oGetParam 2
9390: oPushResult
9391: oNodeType
9392: oPop 1
9394: oChoice 9476
9396: oEmit 16
9398: oGetParam 2
9400: oPushResult
9401: oCall 10773
9403: oPop 1
9405: oJumpForward 9487
9407: oEmit 17
9409: oGetParam 2
9411: oPushResult
9412: oCall 10773
9414: oPop 1
9416: oJumpForward 9487
9418: oGetParam 2
9420: oPushResult
9421: oSetResult 33
9423: oPushResult
9424: oNodeGetBoolean
9425: oPop 2
9427: oChoice 9440
9429: oEmit 8
9431: oGetParam 2
9433: oPushResult
9434: oCall 10773
9436: oPop 1
9438: oJumpForward 9452
9440: Choice Lookup Table
           1   9429
9443: oEmit 18
9445: oGetParam 2
9447: oPushResult
9448: oCall 10773
9450: oPop 1
9452: oJumpForward 9487
9454: oGetParam 1
9456: oChoice 9469
9458: oEmit 16
9460: oGetParam 2
9462: oPushResult
9463: oCall 10773
9465: oPop 1
9467: oJumpForward 9474
9469: Choice Lookup Table
           0   9458
9472: oError 4
9474: oJumpForward 9487
9476: Choice Lookup Table
          24   9454
          23   9418
          21   9407
          20   9396
9485: oError 4
9487: oGetParam 2
9489: oPushResult
9490: oSetResult 21
9492: oPushResult
9493: oNodeGet
9494: oPop 2
9496: oPushResult
9497: oTypeSPush
9498: oPop 1
9500: oCall 7418
9502: oReturn
9503: oLocalSpace 0
9505: oGetParam 1
9507: oPushResult
9508: oSetResult 1
9510: oPushResult
9511: oCall 9386
9513: oPop 2
9515: oCall 10317
9517: oGetParam 1
9519: oPushResult
9520: oCall 6607
9522: oPop 1
9524: oTypeSPop
9525: oEmit 31
9527: oEmit 25
9529: oReturn
9530: oLocalSpace 0
9532: oGetParam 1
9534: oPushResult
9535: oSetResult 1
9537: oPushResult
9538: oCall 9386
9540: oPop 2
9542: oCall 10317
9544: oGetParam 1
9546: oPushResult
9547: oCall 6607
9549: oPop 1
9551: oTypeSPop
9552: oEmit 32
9554: oEmit 25
9556: oReturn
9557: oLocalSpace 2
9559: oGetAddrLocal 1
9561: oPushResult
9562: oSetResult 0
9564: oAssign
9565: oGetAddrLocal 1
9567: oPushResult
9568: oCall 5115
9570: oPop 1
9572: oInput 42
9574: oCall 8904
9576: oInputChoice 9611
9578: oGetAddrLocal 2
9580: oPushResult
9581: oLabelNew
9582: oAssign
9583: oEmit 65
9585: oGetLocal 2
9587: oPushResult
9588: oEmitLabel
9589: oPop 1
9591: oEmit 68
9593: oGetLocal 1
9595: oPushResult
9596: oEmitLabel
9597: oPop 1
9599: oCall 8904
9601: oEmit 68
9603: oGetLocal 2
9605: oPushResult
9606: oEmitLabel
9607: oPop 1
9609: oJumpForward 9622
9611: Choice Lookup Table
          43   9578
9614: oEmit 68
9616: oGetLocal 1
9618: oPushResult
9619: oEmitLabel
9620: oPop 1
9622: oReturn
9623: oLocalSpace 4
9625: oInput 0
9627: oGetAddrLocal 1
9629: oPushResult
9630: oScopeFindRequire
9631: oAssign
9632: oGetLocal 1
9634: oPushResult
9635: oSetResult 1
9637: oPushResult
9638: oCall 9386
9640: oPop 2
9642: oCall 10317
9644: oInput 4
9646: oCall 5092
9648: oCall 10317
9650: oEmit 25
9652: oGetAddrLocal 2
9654: oPushResult
9655: oLabelNew
9656: oAssign
9657: oGetAddrLocal 3
9659: oPushResult
9660: oLabelNew
9661: oAssign
9662: oEmit 65
9664: oGetLocal 3
9666: oPushResult
9667: oEmitLabel
9668: oPop 1
9670: oGetAddrLocal 4
9672: oPushResult
9673: oLabelNew
9674: oAssign
9675: oEmit 68
9677: oGetLocal 4
9679: oPushResult
9680: oEmitLabel
9681: oPop 1
9683: oInputChoice 9763
9685: oGetLocal 1
9687: oPushResult
9688: oCall 9503
9690: oPop 1
9692: oEmit 68
9694: oGetLocal 3
9696: oPushResult
9697: oEmitLabel
9698: oPop 1
9700: oGetLocal 1
9702: oPushResult
9703: oCall 6607
9705: oPop 1
9707: oTypeSPop
9708: oCall 5092
9710: oCall 10317
9712: oEmit 48
9714: oEmit 66
9716: oGetLocal 2
9718: oPushResult
9719: oEmitLabel
9720: oPop 1
9722: oJumpForward 9769
9724: oGetLocal 1
9726: oPushResult
9727: oCall 9530
9729: oPop 1
9731: oEmit 68
9733: oGetLocal 3
9735: oPushResult
9736: oEmitLabel
9737: oPop 1
9739: oGetLocal 1
9741: oPushResult
9742: oCall 6607
9744: oPop 1
9746: oTypeSPop
9747: oCall 5092
9749: oCall 10317
9751: oEmit 49
9753: oEmit 66
9755: oGetLocal 2
9757: oPushResult
9758: oEmitLabel
9759: oPop 1
9761: oJumpForward 9769
9763: Choice Lookup Table
          46   9724
          45   9685
9768: oEndChoice
9769: oGetLocal 4
9771: oPushResult
9772: oGetLocal 2
9774: oPushResult
9775: oLoopPush
9776: oPop 2
9778: oInput 47
9780: oCall 8904
9782: oEmit 65
9784: oGetLocal 4
9786: oPushResult
9787: oEmitLabel
9788: oPop 1
9790: oEmit 68
9792: oGetLocal 2
9794: oPushResult
9795: oEmitLabel
9796: oPop 1
9798: oLoopPop
9799: oReturn
9800: oLocalSpace 3
9802: oGetAddrLocal 1
9804: oPushResult
9805: oLabelNew
9806: oAssign
9807: oEmit 68
9809: oGetLocal 1
9811: oPushResult
9812: oEmitLabel
9813: oPop 1
9815: oGetAddrLocal 2
9817: oPushResult
9818: oLabelNew
9819: oAssign
9820: oGetLocal 1
9822: oPushResult
9823: oGetLocal 2
9825: oPushResult
9826: oLoopPush
9827: oPop 2
9829: oCall 8904
9831: oInputChoice 9862
9833: oCall 8904
9835: oJumpForward 9868
9837: oGetAddrLocal 3
9839: oPushResult
9840: oCall 5115
9842: oPop 1
9844: oEmit 69
9846: oGetLocal 3
9848: oPushResult
9849: oEmitLabel
9850: oPop 1
9852: oGetLocal 1
9854: oPushResult
9855: oEmitLabel
9856: oPop 1
9858: oJumpForward 9870
9860: oJumpForward 9868
9862: Choice Lookup Table
          50   9837
           5   9833
9867: oEndChoice
9868: oJumpBack 9831
9870: oEmit 68
9872: oGetLocal 2
9874: oPushResult
9875: oEmitLabel
9876: oPop 1
9878: oLoopPop
9879: oReturn
9880: oLocalSpace 2
9882: oGetAddrLocal 1
9884: oPushResult
9885: oLabelNew
9886: oAssign
9887: oEmit 68
9889: oGetLocal 1
9891: oPushResult
9892: oEmitLabel
9893: oPop 1
9895: oGetAddrLocal 2
9897: oPushResult
9898: oCall 5115
9900: oPop 1
9902: oGetLocal 1
9904: oPushResult
9905: oGetLocal 2
9907: oPushResult
9908: oLoopPush
9909: oPop 2
9911: oInput 47
9913: oCall 8904
9915: oEmit 65
9917: oGetLocal 1
9919: oPushResult
9920: oEmitLabel
9921: oPop 1
9923: oEmit 68
9925: oGetLocal 2
9927: oPushResult
9928: oEmitLabel
9929: oPop 1
9931: oLoopPop
9932: oReturn
9933: oLocalSpace 0
9935: oLoopContinueLabel
9936: oPushResult
9937: oSetResult 0
9939: oPushResult
9940: equal_label
9941: oPop 2
9943: oChoice 9958
9945: oError 18
9947: oJumpForward 9964
9949: oEmit 65
9951: oLoopContinueLabel
9952: oPushResult
9953: oEmitLabel
9954: oPop 1
9956: oJumpForward 9964
9958: Choice Lookup Table
           0   9949
           1   9945
9963: oEndChoice
9964: oReturn
9965: oLocalSpace 0
9967: oLoopBreakLabel
9968: oPushResult
9969: oSetResult 0
9971: oPushResult
9972: equal_label
9973: oPop 2
9975: oChoice 9990
9977: oError 18
9979: oJumpForward 9996
9981: oEmit 65
9983: oLoopBreakLabel
9984: oPushResult
9985: oEmitLabel
9986: oPop 1
9988: oJumpForward 9996
9990: Choice Lookup Table
           0   9981
           1   9977
9995: oEndChoice
9996: oReturn
9997: oLocalSpace 1
9999: oInputChoice 10006
10001: oJumpForward 10012
10003: oChangeIntLitToLabelIdent
10004: oJumpForward 10012
10006: Choice Lookup Table
           1   10003
           0   10001
10011: oEndChoice
10012: oGetAddrLocal 1
10014: oPushResult
10015: oScopeCurrent
10016: oPushResult
10017: oScopeFindRequireInScope
10018: oPop 1
10020: oAssign
10021: oGetLocal 1
10023: oPushResult
10024: oSetResult 28
10026: oPushResult
10027: oSetResult 1
10029: oPushResult
10030: oNodeSetBoolean
10031: oPop 3
10033: oEmit 65
10035: oGetLocal 1
10037: oPushResult
10038: oSetResult 22
10040: oPushResult
10041: oNodeGetLabel
10042: oPop 2
10044: oPushResult
10045: oEmitLabel
10046: oPop 1
10048: oReturn
10049: oLocalSpace 0
10051: oCall 8904
10053: oInputChoice 10063
10055: oCall 8904
10057: oJumpForward 10069
10059: oJumpForward 10071
10061: oJumpForward 10069
10063: Choice Lookup Table
          36   10059
           5   10055
10068: oEndChoice
10069: oJumpBack 10053
10071: oReturn
10072: oLocalSpace 0
10074: oCall 10079
10076: oEmit 78
10078: oReturn
10079: oLocalSpace 0
10081: oInputChoice 10199
10083: oCall 5092
10085: oTypeSNodeType
10086: oChoice 10157
10088: oEmit 71
10090: oJumpForward 10180
10092: oEmit 72
10094: oJumpForward 10180
10096: oEmit 29
10098: oEmit 71
10100: oJumpForward 10180
10102: oEmit 73
10104: oJumpForward 10180
10106: oEmit 74
10108: oJumpForward 10180
10110: oError 16
10112: oJumpForward 10180
10114: oEmit 16
10116: oTypeSTop
10117: oPushResult
10118: oSetResult 42
10120: oPushResult
10121: oNodeGetInt
10122: oPop 2
10124: oPushResult
10125: oEmitInt
10126: oPop 1
10128: oEmit 77
10130: oJumpForward 10180
10132: oTypeSTop
10133: oPushResult
10134: oGetGlobal 10
10136: oPushResult
10137: equal_node
10138: oPop 2
10140: oChoice 10146
10142: oEmit 75
10144: oJumpForward 10151
10146: Choice Lookup Table
           1   10142
10149: oEmit 76
10151: oJumpForward 10180
10153: oEmit 76
10155: oJumpForward 10180
10157: Choice Lookup Table
          34   10153
          33   10132
          40   10114
          27   10110
          38   10106
          39   10106
          32   10102
          29   10096
          30   10092
          28   10088
10178: oError 17
10180: oTypeSPop
10181: oInputChoice 10189
10183: oJumpForward 10197
10185: oJumpForward 10195
10187: oJumpForward 10195
10189: Choice Lookup Table
          13   10187
          15   10183
10194: oEndChoice
10195: oJumpBack 10083
10197: oJumpForward 10202
10199: Choice Lookup Table
          14   10083
10202: oReturn
10203: oLocalSpace 0
10205: oReturn
10206: oLocalSpace 0
10208: oReturn
10209: oLocalSpace 0
10211: oScopeCurrent
10212: oPushResult
10213: oSetResult 14
10215: oPushResult
10216: oNodeGetInt
10217: oPop 2
10219: oReturn
10220: oReturn
10221: oLocalSpace 0
10223: oGetParam 1
10225: oPushResult
10226: oSetResult 20
10228: oPushResult
10229: oNodeGet
10230: oPop 2
10232: oPushResult
10233: oSetResult 14
10235: oPushResult
10236: oNodeGetInt
10237: oPop 2
10239: oReturn
10240: oReturn
10241: oLocalSpace 0
10243: oCall 10209
10245: oPushResult
10246: oGetParam 1
10248: oPushResult
10249: oCall 10221
10251: oPop 1
10253: oPushResult
10254: subtract
10255: oPop 2
10257: oReturn
10258: oReturn
10259: oLocalSpace 1
10261: oGetAddrLocal 1
10263: oPushResult
10264: oTypeSNodeType
10265: oAssign
10266: oTypeSPop
10267: oGetLocal 1
10269: oPushResult
10270: oTypeSNodeType
10271: oPushResult
10272: equal_node_type
10273: oPop 2
10275: oChoice 10313
10277: oTypeSNodeType
10278: oChoice 10304
10280: oGetLocal 1
10282: oChoice 10287
10284: oReturn
10285: oJumpForward 10290
10287: Choice Lookup Table
          34   10284
10290: oJumpForward 10309
10292: oGetLocal 1
10294: oChoice 10299
10296: oReturn
10297: oJumpForward 10302
10299: Choice Lookup Table
          33   10296
10302: oJumpForward 10309
10304: Choice Lookup Table
          34   10292
          33   10280
10309: oError 14
10311: oJumpForward 10316
10313: Choice Lookup Table
           0   10277
10316: oReturn
10317: oLocalSpace 0
10319: oTypeSNodeType
10320: oChoice 10324
10322: oJumpForward 10329
10324: Choice Lookup Table
          28   10322
10327: oError 7
10329: oTypeSPop
10330: oReturn
10331: oLocalSpace 0
10333: oTypeSNodeType
10334: oChoice 10338
10336: oJumpForward 10343
10338: Choice Lookup Table
          28   10336
10341: oError 7
10343: oReturn
10344: oLocalSpace 0
10346: oTypeSNodeType
10347: oChoice 10355
10349: oJumpForward 10362
10351: oEmit 29
10353: oJumpForward 10362
10355: Choice Lookup Table
          29   10351
          28   10349
10360: oError 7
10362: oTypeSPop
10363: oReturn
10364: oLocalSpace 0
10366: oTypeSNodeType
10367: oChoice 10382
10369: oJumpForward 10389
10371: oEmit 29
10373: oTypeSPop
10374: oGetGlobal 6
10376: oPushResult
10377: oTypeSPush
10378: oPop 1
10380: oJumpForward 10389
10382: Choice Lookup Table
          29   10371
          28   10369
10387: oError 7
10389: oReturn
10390: oLocalSpace 0
10392: oTypeSNodeType
10393: oChoice 10406
10395: oEmit 29
10397: oTypeSPop
10398: oGetGlobal 6
10400: oPushResult
10401: oTypeSPush
10402: oPop 1
10404: oJumpForward 10409
10406: Choice Lookup Table
          29   10395
10409: oReturn
10410: oLocalSpace 0
10412: oTypeSNodeType
10413: oChoice 10417
10415: oJumpForward 10422
10417: Choice Lookup Table
          30   10415
10420: oError 8
10422: oTypeSPop
10423: oReturn
10424: oLocalSpace 0
10426: oTypeSNodeType
10427: oChoice 10431
10429: oJumpForward 10436
10431: Choice Lookup Table
          30   10429
10434: oError 8
10436: oReturn
10437: oLocalSpace 1
10439: oGetAddrLocal 1
10441: oPushResult
10442: oGetParam 2
10444: oPushResult
10445: oNodeNew
10446: oPop 1
10448: oAssign
10449: oGetLocal 1
10451: oPushResult
10452: oSetResult 17
10454: oPushResult
10455: oGetParam 1
10457: oPushResult
10458: oNodeSetInt
10459: oPop 3
10461: oGetLocal 1
10463: oPushResult
10464: oTypeAdd
10465: oPop 1
10467: oGetLocal 1
10469: oReturn
10470: oReturn
10471: oLocalSpace 1
10473: oGetAddrLocal 1
10475: oPushResult
10476: oGetParam 2
10478: oPushResult
10479: oNodeNew
10480: oPop 1
10482: oAssign
10483: oGetLocal 1
10485: oPushResult
10486: oSetResult 4
10488: oPushResult
10489: oGetParam 1
10491: oPushResult
10492: oNodeSetInt
10493: oPop 3
10495: oGetLocal 1
10497: oReturn
10498: oReturn
10499: oLocalSpace 1
10501: oGetAddrLocal 1
10503: oPushResult
10504: oGetParam 1
10506: oPushResult
10507: oSetResult 35
10509: oPushResult
10510: oNodeGet
10511: oPop 2
10513: oAssign
10514: oGetLocal 1
10516: oPushResult
10517: oNodeNull
10518: oPop 1
10520: oChoice 10576
10522: oGetAddrLocal 1
10524: oPushResult
10525: oSetResult 33
10527: oPushResult
10528: oNodeNew
10529: oPop 1
10531: oAssign
10532: oGetLocal 1
10534: oPushResult
10535: oSetResult 36
10537: oPushResult
10538: oGetParam 1
10540: oPushResult
10541: oNodeSet
10542: oPop 3
10544: oGetLocal 1
10546: oPushResult
10547: oSetResult 17
10549: oPushResult
10550: oSetResult 8
10552: oPushResult
10553: oNodeSetInt
10554: oPop 3
10556: oGetLocal 1
10558: oPushResult
10559: oTypeAdd
10560: oPop 1
10562: oGetParam 1
10564: oPushResult
10565: oSetResult 35
10567: oPushResult
10568: oGetLocal 1
10570: oPushResult
10571: oNodeSet
10572: oPop 3
10574: oJumpForward 10579
10576: Choice Lookup Table
           1   10522
10579: oGetLocal 1
10581: oReturn
10582: oReturn
10583: oLocalSpace 2
10585: oGetParam 1
10587: oPushResult
10588: oNodeType
10589: oPop 1
10591: oChoice 10661
10593: oMININT
10594: oReturn
10595: oJumpForward 10677
10597: oSetResult 0
10599: oReturn
10600: oJumpForward 10677
10602: oSetResult 0
10604: oReturn
10605: oJumpForward 10677
10607: oGetAddrLocal 1
10609: oPushResult
10610: oGetParam 1
10612: oPushResult
10613: oSetResult 40
10615: oPushResult
10616: oNodeGet
10617: oPop 2
10619: oAssign
10620: oGetAddrLocal 2
10622: oPushResult
10623: oGetLocal 1
10625: oPushResult
10626: oSetResult 15
10628: oPushResult
10629: oNodeGetIter
10630: oPop 2
10632: oPushResult
10633: oNodeIterValue
10634: oPop 1
10636: oAssign
10637: oGetLocal 2
10639: oPushResult
10640: oSetResult 22
10642: oPushResult
10643: oNodeGetInt
10644: oPop 2
10646: oReturn
10647: oJumpForward 10677
10649: oGetParam 1
10651: oPushResult
10652: oSetResult 38
10654: oPushResult
10655: oNodeGetInt
10656: oPop 2
10658: oReturn
10659: oJumpForward 10677
10661: Choice Lookup Table
          36   10649
          40   10607
          32   10602
          30   10597
          28   10593
10672: oError 3
10674: oSetResult 0
10676: oReturn
10677: oReturn
10678: oLocalSpace 2
10680: oGetParam 1
10682: oPushResult
10683: oNodeType
10684: oPop 1
10686: oChoice 10756
10688: oMAXINT
10689: oReturn
10690: oJumpForward 10772
10692: oSetResult 1
10694: oReturn
10695: oJumpForward 10772
10697: oSetResult 255
10699: oReturn
10700: oJumpForward 10772
10702: oGetAddrLocal 1
10704: oPushResult
10705: oGetParam 1
10707: oPushResult
10708: oSetResult 40
10710: oPushResult
10711: oNodeGet
10712: oPop 2
10714: oAssign
10715: oGetAddrLocal 2
10717: oPushResult
10718: oGetLocal 1
10720: oPushResult
10721: oSetResult 15
10723: oPushResult
10724: oNodeGetIterLast
10725: oPop 2
10727: oPushResult
10728: oNodeIterValue
10729: oPop 1
10731: oAssign
10732: oGetLocal 2
10734: oPushResult
10735: oSetResult 22
10737: oPushResult
10738: oNodeGetInt
10739: oPop 2
10741: oReturn
10742: oJumpForward 10772
10744: oGetParam 1
10746: oPushResult
10747: oSetResult 39
10749: oPushResult
10750: oNodeGetInt
10751: oPop 2
10753: oReturn
10754: oJumpForward 10772
10756: Choice Lookup Table
          36   10744
          40   10702
          32   10697
          30   10692
          28   10688
10767: oError 3
10769: oSetResult 0
10771: oReturn
10772: oReturn
10773: oLocalSpace 0
10775: oGetParam 1
10777: oPushResult
10778: oSetResult 22
10780: oPushResult
10781: oNodeGetInt
10782: oPop 2
10784: oPushResult
10785: oEmitInt
10786: oPop 1
10788: oReturn
10789: oLocalSpace 1
10791: oGetAddrLocal 1
10793: oPushResult
10794: oSetResult 14
10796: oPushResult
10797: oGetParam 1
10799: oPushResult
10800: oCall 10471
10802: oPop 2
10804: oAssign
10805: oGetLocal 1
10807: oPushResult
10808: oScopeDeclare
10809: oPop 1
10811: oGetLocal 1
10813: oReturn
10814: oReturn
10815: oLocalSpace 1
10817: oGetAddrGlobal 4
10819: oPushResult
10820: oIdAdd_mysystem
10821: oAssign
10822: oGetAddrGlobal 5
10824: oPushResult
10825: oSetResult 27
10827: oPushResult
10828: oSetResult 4
10830: oPushResult
10831: oCall 10437
10833: oPop 2
10835: oAssign
10836: oGetAddrGlobal 6
10838: oPushResult
10839: oSetResult 28
10841: oPushResult
10842: oSetResult 4
10844: oPushResult
10845: oCall 10437
10847: oPop 2
10849: oAssign
10850: oGetAddrGlobal 7
10852: oPushResult
10853: oSetResult 30
10855: oPushResult
10856: oSetResult 1
10858: oPushResult
10859: oCall 10437
10861: oPop 2
10863: oAssign
10864: oGetAddrGlobal 8
10866: oPushResult
10867: oSetResult 31
10869: oPushResult
10870: oSetResult 1
10872: oPushResult
10873: oCall 10437
10875: oPop 2
10877: oAssign
10878: oGetAddrGlobal 9
10880: oPushResult
10881: oSetResult 32
10883: oPushResult
10884: oSetResult 1
10886: oPushResult
10887: oCall 10437
10889: oPop 2
10891: oAssign
10892: oGetAddrGlobal 10
10894: oPushResult
10895: oGetGlobal 9
10897: oPushResult
10898: oCall 10499
10900: oPop 1
10902: oAssign
10903: oGetAddrGlobal 11
10905: oPushResult
10906: oSetResult 29
10908: oPushResult
10909: oSetResult 1
10911: oPushResult
10912: oCall 10437
10914: oPop 2
10916: oAssign
10917: oGetAddrGlobal 12
10919: oPushResult
10920: oSetResult 34
10922: oPushResult
10923: oSetResult 8
10925: oPushResult
10926: oCall 10437
10928: oPop 2
10930: oAssign
10931: oGetGlobal 12
10933: oPushResult
10934: oSetResult 36
10936: oPushResult
10937: oGetGlobal 11
10939: oPushResult
10940: oNodeSet
10941: oPop 3
10943: oGetAddrGlobal 13
10945: oPushResult
10946: oSetResult 38
10948: oPushResult
10949: oSetResult 256
10951: oPushResult
10952: oCall 10437
10954: oPop 2
10956: oAssign
10957: oGetAddrGlobal 14
10959: oPushResult
10960: oSetResult 39
10962: oPushResult
10963: oSetResult 256
10965: oPushResult
10966: oCall 10437
10968: oPop 2
10970: oAssign
10971: oGetGlobal 14
10973: oPushResult
10974: oSetResult 41
10976: oPushResult
10977: oSetResult 255
10979: oPushResult
10980: oNodeSetInt
10981: oPop 3
10983: oGetAddrLocal 1
10985: oPushResult
10986: oSetResult 18
10988: oPushResult
10989: oIdAdd_File
10990: oPushResult
10991: oCall 10471
10993: oPop 2
10995: oAssign
10996: oGetLocal 1
10998: oPushResult
10999: oSetResult 21
11001: oPushResult
11002: oGetGlobal 5
11004: oPushResult
11005: oNodeSet
11006: oPop 3
11008: oGetLocal 1
11010: oPushResult
11011: oScopeDeclare
11012: oPop 1
11014: oGetAddrLocal 1
11016: oPushResult
11017: oSetResult 18
11019: oPushResult
11020: oIdAdd_Integer
11021: oPushResult
11022: oCall 10471
11024: oPop 2
11026: oAssign
11027: oGetLocal 1
11029: oPushResult
11030: oSetResult 21
11032: oPushResult
11033: oGetGlobal 6
11035: oPushResult
11036: oNodeSet
11037: oPop 3
11039: oGetLocal 1
11041: oPushResult
11042: oScopeDeclare
11043: oPop 1
11045: oGetAddrLocal 1
11047: oPushResult
11048: oSetResult 18
11050: oPushResult
11051: oIdAdd_Boolean
11052: oPushResult
11053: oCall 10471
11055: oPop 2
11057: oAssign
11058: oGetLocal 1
11060: oPushResult
11061: oSetResult 21
11063: oPushResult
11064: oGetGlobal 7
11066: oPushResult
11067: oNodeSet
11068: oPop 3
11070: oGetLocal 1
11072: oPushResult
11073: oScopeDeclare
11074: oPop 1
11076: oGetAddrLocal 1
11078: oPushResult
11079: oSetResult 18
11081: oPushResult
11082: oIdAdd_Char
11083: oPushResult
11084: oCall 10471
11086: oPop 2
11088: oAssign
11089: oGetLocal 1
11091: oPushResult
11092: oSetResult 21
11094: oPushResult
11095: oGetGlobal 9
11097: oPushResult
11098: oNodeSet
11099: oPop 3
11101: oGetLocal 1
11103: oPushResult
11104: oScopeDeclare
11105: oPop 1
11107: oGetAddrLocal 1
11109: oPushResult
11110: oSetResult 18
11112: oPushResult
11113: oIdAdd_Byte
11114: oPushResult
11115: oCall 10471
11117: oPop 2
11119: oAssign
11120: oGetLocal 1
11122: oPushResult
11123: oSetResult 21
11125: oPushResult
11126: oGetGlobal 11
11128: oPushResult
11129: oNodeSet
11130: oPop 3
11132: oGetLocal 1
11134: oPushResult
11135: oScopeDeclare
11136: oPop 1
11138: oGetAddrLocal 1
11140: oPushResult
11141: oSetResult 18
11143: oPushResult
11144: oIdAdd_Pointer
11145: oPushResult
11146: oCall 10471
11148: oPop 2
11150: oAssign
11151: oGetLocal 1
11153: oPushResult
11154: oSetResult 21
11156: oPushResult
11157: oGetGlobal 12
11159: oPushResult
11160: oNodeSet
11161: oPop 3
11163: oGetLocal 1
11165: oPushResult
11166: oScopeDeclare
11167: oPop 1
11169: oGetAddrLocal 1
11171: oPushResult
11172: oSetResult 18
11174: oPushResult
11175: oIdAdd_ShortString
11176: oPushResult
11177: oCall 10471
11179: oPop 2
11181: oAssign
11182: oGetLocal 1
11184: oPushResult
11185: oSetResult 21
11187: oPushResult
11188: oGetGlobal 14
11190: oPushResult
11191: oNodeSet
11192: oPop 3
11194: oGetLocal 1
11196: oPushResult
11197: oScopeDeclare
11198: oPop 1
11200: oGetAddrLocal 1
11202: oPushResult
11203: oSetResult 16
11205: oPushResult
11206: oIdAdd_True
11207: oPushResult
11208: oCall 10471
11210: oPop 2
11212: oAssign
11213: oGetLocal 1
11215: oPushResult
11216: oSetResult 21
11218: oPushResult
11219: oGetGlobal 7
11221: oPushResult
11222: oNodeSet
11223: oPop 3
11225: oGetLocal 1
11227: oPushResult
11228: oSetResult 22
11230: oPushResult
11231: oSetResult 1
11233: oPushResult
11234: oNodeSetInt
11235: oPop 3
11237: oGetLocal 1
11239: oPushResult
11240: oScopeDeclare
11241: oPop 1
11243: oGetAddrLocal 1
11245: oPushResult
11246: oSetResult 16
11248: oPushResult
11249: oIdAdd_False
11250: oPushResult
11251: oCall 10471
11253: oPop 2
11255: oAssign
11256: oGetLocal 1
11258: oPushResult
11259: oSetResult 21
11261: oPushResult
11262: oGetGlobal 7
11264: oPushResult
11265: oNodeSet
11266: oPop 3
11268: oGetLocal 1
11270: oPushResult
11271: oSetResult 22
11273: oPushResult
11274: oSetResult 0
11276: oPushResult
11277: oNodeSetInt
11278: oPop 3
11280: oGetLocal 1
11282: oPushResult
11283: oScopeDeclare
11284: oPop 1
11286: oGetAddrGlobal 15
11288: oPushResult
11289: oIdAdd_Ord
11290: oPushResult
11291: oCall 10789
11293: oPop 1
11295: oAssign
11296: oGetAddrGlobal 16
11298: oPushResult
11299: oIdAdd_Chr
11300: oPushResult
11301: oCall 10789
11303: oPop 1
11305: oAssign
11306: oGetAddrGlobal 17
11308: oPushResult
11309: oIdAdd_Pred
11310: oPushResult
11311: oCall 10789
11313: oPop 1
11315: oAssign
11316: oGetAddrGlobal 18
11318: oPushResult
11319: oIdAdd_Succ
11320: oPushResult
11321: oCall 10789
11323: oPop 1
11325: oAssign
11326: oReturn
