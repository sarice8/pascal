   2: title: 'Pascal Compiler 1.1.5 -- Jan 01 ''90';
         
      %
      %  Pascal.ssl
      %
      %  Pascal Compiler for the Amiga, by Steve Rice.
      %
      %  HISTORY
      %    11Sep89   First version, framework of parser.
      %    18Sep89   Added some semantic mechanisms.
      %    21Sep89   Added simple type references; expressions generate code.
      %    22Sep89   Allocate variable addresses as they're declared.
      %    24Sep89   Added arrays, pointers.
      %    27Sep89   Added for statement.
      %    23Oct89   Fixed for statement, so CYCLE goes to next step.
      %    01Jan90   Added string literals
      %    09Sep22   I have returned.  Migrate symbol table to schema, to ease development.
      %    01Oct22   Language: Switch from cycle/exit (Mac Pascal extension) to continue/break (Borland).
      %
      %  NOTES
      %    -  The 'value' of a var symbol is its allocated address.
      %    -  References to vars of intrinsic types, and pointer types,
      %       pushes the value of the var on the expr stack.  Referenecs to
      %       vars of compound types (arrays, records...) pushes the address
      %       on the expr stack.
      %    -  Just as there is only one type table entry for a given (named) type,
      %       there is only one type table entry for a pointer to a named type.
      %       When a pointer type is declared, a field in the TT entry of the
      %       type pointed to will be set to indicate the TT entry of the pointer
      %       to that type (0 means none defined yet).  When evaluating the
      %       expression @x, the type in that field in the entry for the type of x
      %       will be used (unless it's 0, in which case a new TT entry will be
      %       created).
      %
      %
      %  MISSING
      %
      %    - Consider non-ISO extensions.  e.g. 
      %      Dynamic arrays.  Objects.  But, perhaps stick to my old goal, standard Pascal.
      %
      %  PASCAL DOCS
      %      Here's some handy language material:
      %      https://www.freepascal.org/docs-html/ref/ref.html
      %      https://www.freepascal.org/docs-html/prog/prog.html
      %      https://en.wikipedia.org/wiki/Turbo_Pascal
      %      https://en.wikipedia.org/wiki/Pascal_(programming_language)#Standards
      %      http://www.standardpascaline.org/
      %
      
   2: input:
   2:    pIdent
   2:    pIntLit
   2:    pDoubleLit
   2:    pStrLit
   2:    pCharLit
   2:    pAssign       ':='
   2:    pSemiColon    ';'
   2:    pEqual        '='
   2:    pNotEqual     '<>'
   2:    pLess         '<'
   2:    pGreater      '>'
   2:    pLessEqual    '<='
   2:    pGreaterEqual '>='
   2:    pColon        ':'
   2:    pComma        ','
   2:    pLParen       '('
   2:    pRParen       ')'
   2:    pLSquare      '['
   2:    pRSquare      ']'
   2:    pCarat        '^'
   2:    pAt           '@'
   2:    pDot          '.'
   2:    pDotDot       '..'
   2:    pTimes        '*'
   2:    pDivide       '/'
   2:    pPlus         '+'
   2:    pMinus        '-'
   2:    pEof
   2:    pInvalid
      
      %  keywords  (built-in types 'integer', 'byte', 'char', etc, are not keywords,
      %             type constructors 'array', 'record', 'set' are keywords,
      %             pseudo-procedures 'writeln', 'readln' are keywords)
      %
      %             forward/external/name/cdecl appear in method modifiers, in fpc grammar.
      %             I'm making them keywords to simplify parsing, but could reconsider.
      
   2:    pProgram
   2:    pProcedure
   2:    pFunction
   2:    pConst
   2:    pType
   2:    pVar
   2:    pLabel
   2:    pBegin
   2:    pEnd
   2:    pArray
   2:    pRecord
   2:    pSet
   2:    pOf
   2:    pIf
   2:    pThen
   2:    pElse
   2:    pFor
   2:    pTo
   2:    pDownto
   2:    pDo
   2:    pWhile
   2:    pRepeat
   2:    pUntil
   2:    pContinue
   2:    pBreak
   2:    pCase
   2:    pOtherwise
   2:    pGoto
   2:    pAnd
   2:    pOr
   2:    pNot
   2:    pUses
   2:    pUnit
   2:    pInterface
   2:    pImplementation
   2:    pInitialization
   2:    pFinalization
   2:    pWriteln
   2:    pWrite
   2:    pReadln
   2:    pRead
      
   2:    pForward
   2:    pExternal
   2:    pName
   2:    pCdecl
   2:    ;
      
      
   2: output:
      
      %  Instructions for a stack machine (all vars are 32-bit integers)
      
   2:    tPushGlobalI      % <ptr> - push int value read from ptr
   2:    tPushGlobalB      % <ptr> - push byte value read from ptr
   2:    tPushGlobalP      % <ptr> - push ptr value read from ptr
   2:    tPushLocalI       % <offset> - push int value read from local var in current scope
   2:    tPushLocalB       % <offset> - push byte value read from local var in current scope
   2:    tPushLocalP       % <offset> - push ptr value read from local var in current scope
   2:    tPushParamI       % <offset> - push int value read from param in current scope
   2:    tPushParamB       % <offset> - push byte value read from param in current scope
   2:    tPushParamP       % <offset> - push ptr value read from param in current scope
   2:    tPushUpLocalI     % <uplevels> <offset> - push int value read from local var in a parent static scope
   2:    tPushUpLocalB     % <uplevels> <offset> - push byte value read from local var in a parent static scope
   2:    tPushUpLocalP     % <uplevels> <offset> - push ptr value read from local var in a parent static scope
   2:    tPushUpParamI     % <uplevels> <offset> - push int value read from param in a parent static scope
   2:    tPushUpParamB     % <uplevels> <offset> - push byte value read from param in a parent static scope
   2:    tPushUpParamP     % <uplevels> <offset> - push ptr value read from param in a parent static scope
   2:    tPushConstI       % <int> - push int value on stack (NOTE, used for BOOLEAN too)
   2:    tPushConstD       % <double> - push double value on stack
   2:    tPushAddrGlobal   % <offset> - push ptr to global var
   2:    tPushAddrLocal    % <offset> - push ptr to local var
   2:    tPushAddrParam    % <offset> - push ptr to formal param (used by method to see its param)
   2:    tPushAddrActual   % <offset> - push ptr to actual param, in actuals space (used by caller)
   2:    tPushAddrUpLocal  % <uplevels> <offset> - push ptr to local var in a parent static scope
   2:    tPushAddrUpParam  % <uplevels> <offset> - push ptr to formal param in a parent static scope
   2:    tSwap             % swap the top two entries on the stack
   2:    tFetchI           % pop ptr from stack, and push int value it points to
   2:    tFetchB           %    "      "      "     "     byte  "   "    "
   2:    tFetchP           %    "      "      "     "     ptr   "   "    "   
   2:    tAssignI          % assign int value on top of stack to addr under it (pop both)
   2:    tAssignB          %   "    byte   "    "   "  "   "    "    "   "   "
   2:    tAssignP          %   "    ptr    "    "   "  "   "    "    "   "   "
   2:    tAssignD          %   "    double "    "   "  "   "    "    "   "   "
   2:    tCopy             % <#bytes> - copy bytes.  tos=src, 2nd=dest (pop 2)
   2:    tCastBtoI         % zero-extend uint8_t to int32_t
   2:    tCastItoB         % truncate int32_t to uint8_t
   2:    tCastItoD         % convert int32_t to double
   2:    tIncI             % increment int value on top of expr stack
   2:    tDecI             % decrement int value on top of expr stack
   2:    tMultI            % multiply top two integers (replacing with result)
   2:    tDivI
   2:    tAddPI            % add ptr (2nd value) and int (top value), resulting in a ptr
   2:    tAddI
   2:    tSubP
   2:    tSubPI
   2:    tSubI
   2:    tNegI             % top entry *= -1
   2:    tMultD            % operations on double-precision floating point values
   2:    tDivD
   2:    tAddD
   2:    tSubD
   2:    tNegD
   2:    tNot              % negate top boolean
   2:    tEqualB
   2:    tNotEqualB
   2:    tGreaterB         % B is uint8_t, so these are unsigned comparisons
   2:    tLessB
   2:    tGreaterEqualB
   2:    tLessEqualB
   2:    tEqualI           % top two entries equal? (pop 2, push 1) (true=1)
   2:    tNotEqualI        %    NOTE, these all work for booleans too, but I'm moving to tEqualB etc for those
   2:    tGreaterI         % 2nd entry greater than top entry? (pop 2, push answer)
   2:    tLessI  
   2:    tGreaterEqualI
   2:    tLessEqualI
   2:    tEqualP           % two two pointer values equal? (pop 2, push 1) (true=1)
   2:    tNotEqualP
   2:    tGreaterP
   2:    tLessP
   2:    tGreaterEqualP
   2:    tLessEqualP
   2:    tEqualD           % double comparisions
   2:    tNotEqualD
   2:    tGreaterD
   2:    tLessD
   2:    tGreaterEqualD
   2:    tLessEqualD
   2:    tAllocActuals     % <#bytes> - make space on call stack for actual params (adjusting call stack sp)
   2:    tAllocActualsCdecl  % <#bytes> - starting a call to a cdecl method.  tcode still describes my own calling convention.
   2:    tFreeActuals      % <#bytes> - discard space on call stack allocated by tAllocActuals
   2:    tCall             % <label#>
   2:    tCallCdecl        % <label#> - call a method using native (C) calling convention. Only supported for extern labels.
   2:    tReturn
   2:    tEnter            % <#bytes> - start a stack frame on the call stack, reserving #bytes of local variable space
   2:    tJump             % <label#>
   2:    tJumpTrue         % <label#>  (pops top of stack, jumps if true)
   2:    tJumpFalse        % <label#>  (pops top of stack, jumps if false)
   2:    tJumpCaseB        % <label#>  pops uint8_t, jumps to case indicated by table at label (consisting of tCase, tCaseRange, tCaseEnd)
   2:    tJumpCaseI        % <label#>  pops integer, jumps to case indicated by table at label
   2:    tJumpCaseS        % <label#>  pops pointer to ShortString, jumps to case indicated by table at label
   2:    tCase             % <int> <label#>  - case table entry: if match int, goto label.  For tJumpCaseS, int is offset into global data.
   2:    tCaseRange        % <lowint> <highint> <label#>  - case table entry: if lowint <= value <= highint, goto label.  For tJumpCaseS, offsets into global.
   2:    tCaseEnd          % <label#> - end of case table.  Label points to no-match code (otherwise clause or end of statement).
   2:    tLabel            % <label#> - define label# at the current address
   2:    tLabelAlias       % <label#> <aliasToLabel#> - defines label to be an alias of another label
   2:    tLabelExtern      % <label#> <offsetToStrLit> - defines label to mean an extern symbol, whose name is in global data
   2:    tWriteI           % for writeln : write integer on tos, pop
   2:    tWriteBool        %  "     "    : write TRUE/FALSE, pop
   2:    tWriteChar        %  "     "    : write char, pop
   2:    tWriteShortStr    %  "     "    : write ShortString whose addr is on tos, pop
   2:    tWritePChar       %  "     "    : write a null-terminated string whose addr is on tos, pop
   2:    tWriteP           %  "     "    : write ptr var whose addr is on tos, pop
   2:    tWriteEnum        %  "     "    : write enum name.  Name table on tos, value under it, pop both
   2:    tWriteD           %  "     "    : write double-precision floating point value on tos, pop
   2:    tWriteCR          %  "     "    : write cr
   2:    tReadI            % for readln : pointer to integer on tos.  Assign read value to it, and pop
   2:    tReadChar         %  "     "   : pointer to char on tos.  Asign read value to it, and pop
   2:    tReadShortStr     % <capacity>  "     "   : pointer to ShortString on tos, and given max capacity.  Assign read value to it, and pop
   2:    tReadCR           %  "     "   : read the end-of-line.  Will accept any platform's eoln sequence.
   2:    tFile             % <file#> - pascal source file id, for debugging.  I haven't decided yet how I will communicate the corresponding filename.
   2:    tLine             % <line#> - pascal source line number, for debugging
      
      %  Other:
      
   2:    tSpace            % emit a hole, to be patched later
   2:    ;
      
   2: error:
   2:    eBadStatement
   2:    eNotConst
   2:    eNotType
   2:    eNotOrdinalType
   2:    eNotVar
   2:    eNotIntVar
   2:    eNotValue
   2:    eNotInteger
   2:    eNotBoolean
   2:    eNotDouble
   2:    eNotPointer
   2:    eNotArray
   2:    eNotRecord
   2:    eNotRecordField
   2:    eTooManySubscripts
   2:    eTypeMismatch
   2:    eMissingParameter
   2:    eNotImplemented
   2:    eNotAllowed
   2:    eNotInALoop
   2:    eRecordEmpty
   2:    eNotCurrentFunction
   2:    eAlreadyDefined
   2:    eOnlyOneVarCanBeInitialized
   2:    eExternalMethodCannotBeNested
   2:    eExternalMethodMustBeCdecl
   2:    eCantFindUnitFile
   2:    eInternalScopeMismatch
   2:    eEnumValueNotAscending
   2:    eUsedButNotDefined
   2:    eCantUsePredSuccOnEnumWithValueGaps
   2:    eCantDereference
   2:    eSizeMismatch
   2:    eTypeNameNotAllowedHere
   2:    ;
      
   2: include 'pascal_schema.ssl'
      
      % Generated automatically by schema
      
   2: type node_type:
   2: 	nINVALID
   2: 	Object
   2: 	nWorkspace
   2: 	nModule
   2: 	nProgram
   2: 	nUnit
   2: 	nUnitImpl
   2: 	nScope
   2: 	nDeclaration
   2: 	nIdent
   2: 	nUnitRef
   2: 	nMethod
   2: 	nProc
   2: 	nFunc
   2: 	nBuiltInFunc
   2: 	nBuiltInProc
   2: 	nConst
   2: 	nEnumValue
   2: 	nConstStr
   2: 	nConstDouble
   2: 	nTypeDecl
   2: 	nVar
   2: 	nGlobalVar
   2: 	nLocalVar
   2: 	nRecordField
   2: 	nParam
   2: 	nTypedConst
   2: 	nLabel
   2: 	nType
   2: 	nFileType
   2: 	nByteType
   2: 	nIntegerType
   2: 	nSingleType
   2: 	nDoubleType
   2: 	nBooleanType
   2: 	nBooleanFlowType
   2: 	nCharType
   2: 	nPointerType
   2: 	nUniversalPointerType
   2: 	nArrayType
   2: 	nSubrangeType
   2: 	nRecordType
   2: 	nStrLitType
   2: 	nShortStringType
   2: 	nEnumType
   2: 	nSetType
   2: 	;
      
   2: type node_attribute:
   2: 	qINVALID
   2: 	qUnits
   2: 	qProgram
   2: 	qGlobalSize
   2: 	qIdent
   2: 	qUsedUnits
   2: 	qChildScope
   2: 	qMainRoutineScope
   2: 	qImpl
   2: 	qPublicScope
   2: 	qPrivateScope
   2: 	qInitLabel
   2: 	qFinalLabel
   2: 	qInitRoutineScope
   2: 	qLevel
   2: 	qDecls
   2: 	qExtends
   2: 	qSize
   2: 	qAllocMode
   2: 	qInitCode
   2: 	qParentScope
   2: 	qType
   2: 	qValue
   2: 	qParams
   2: 	qBodyDefined
   2: 	qExternal
   2: 	qExternalName
   2: 	qCdecl
   2: 	qUsed
   2: 	qOldParams
   2: 	qOldType
   2: 	qResultOffset
   2: 	qNameOffset
   2: 	qValueStr
   2: 	qValueDouble
   2: 	qInOut
   2: 	qDefined
   2: 	qPointerType
   2: 	qBaseType
   2: 	qIndexType
   2: 	qLow
   2: 	qHigh
   2: 	qScope
   2: 	qCapacity
   2: 	qNameTable
   2: 	qHasGap
   2: 	;
      
      
   2: type Node:     % A pointer to a node in the schema database (symbol database)
   2:    Null = 0
   2:    ;
      
   2: type NodeIter:   % An iterator over nodes in a list, in the schema database
   2:    NullIter = 0
   2:    ;
      
   2: type NodeVec:  % A pointer to a vector of Node.  See mechanism node_vec_mech
   2:    NullVec = 0
   2:    ;
      
   2: type boolean:
   2:    false    = 0
   2:    true     = 1;
      
   2: type double:
   2:    doubleZero = 0
   2:    ;
      
   2: type Label:
   2:    labelNull = 0;
      
      % An output code stream.
   2: type Code:
   2:    codeNull = 0
   2:    codeDefault = 1
   2:    ;
      
      % A string
   2: type String:
   2:    stringNull = 0
   2:    ;
      
      % allocation modes for oScopeBegin
   2: type AllocMode:
   2:    allocGlobal = 0  % allocate from global data
   2:    allocDown        % allocate down the stack
   2:    allocUp          % allocate up the stack
   2:    ;
      
      % Some general schema node operations.
      % node_type and node_attribute are defined in generated file pascal_schema.ssl included above.
      %
   2: mechanism node_mech:
   2:     oNodeNew (node_type) >> Node         % create new node
   2:     oNodeSet (Node, node_attribute, Node)   % set Node attribute of node
   2:     oNodeSetDouble (Node, node_attribute, double)   % set double attribute
   2:     oNodeSetString (Node, node_attribute, String)
   2:     oNodeSetInt (Node, node_attribute, int) % set int attribute of node
   2:     oNodeSetBoolean (Node, node_attribute, boolean)
   2:     oNodeSetLabel( Node, node_attribute, Label )  % set Label attribute of node
   2:     oNodeSetCode( Node, node_attribute, Code )    % set Code attribute of node
   2:     oNodeAddLast( Node, node_attribute, Node value )  % append to a List attribute of node
   2:     oNodeGet (Node, node_attribute) >> Node    % get Node attribute of node
   2:     oNodeGetDouble (Node, node_attribute) >> double
   2:     oNodeGetString (Node, node_attribute) >> String
   2:     oNodeGetInt (Node, node_attribute) >> int  % get int attribute of node
   2:     oNodeGetBoolean (Node, node_attribute) >> boolean  % get int attribute of node
   2:     oNodeGetLabel (Node, node_attribute) >> Label      % get Label attribute of node
   2:     oNodeGetCode (Node, node_attribute) >> Code        % get code stream attribute of node
   2:     oNodeNull (Node) >> boolean          % is node null?
   2:     oNodeFind (Node, node_attribute listAttr, node_attribute valueAttr, int value) >> Node  % find node with value in list
   2:     oNodeGetIter (Node, node_attribute) >> NodeIter   % get an iterator over nodes in a List attribute
   2:     oNodeGetIterLast (Node, node_attribute) >> NodeIter  % get an iterator over nodes in a List, starting at last
   2:     oNodeIterValue (NodeIter) >> Node             % the node that iter is referring to (NodeNull if no more nodes)
   2:     oNodeIterNext (inout NodeIter)                % advance iterator through list
   2:     oNodeIterPrev (inout NodeIter)                % advance iterator backwards through list
   2:     oNodeType (Node) >> node_type        % return node type of node
   2:     oNodeEqual (Node, Node) >> boolean   % compare two nodes for equality
                                               % (i.e. same node, not just same contents)
   2:     ;
      
      
      % Manipulate a temporary vector of Node
      %
   2: mechanism node_vec_mech:
   2:     oNodeVecNew >> NodeVec
   2:     oNodeVecDelete( NodeVec nv )
   2:     oNodeVecAppend( NodeVec nv, Node n )
   2:     oNodeVecSize( NodeVec nv ) >> int                % how many elements
   2:     oNodeVecElement( NodeVec nv, int idx ) >> Node   % element at index idx (0..size-1)
   2:     ;
      
      
      
   2: mechanism emit_mech:
   2:     oEmitInt( int )              % emit int into the generated code
   2:     oEmitDouble( double )        % emit double into the generated code
   2:     oEmitLabel( Label )
   2:     oEmitCode( Code )            % append a code stream to the current code stream
   2:     Here >> int                  % current address in the generated code
                                       %   (only usable in the default code stream)
   2:     oPatch( int addr, int val )  % patch an int into address in the generated code
                                       %   (only usable in the default code stream)
   2:     ;
      
   2: mechanism math:
   2:     inc (inout int)
   2:     dec (inout int)
   2:     negate (int) >> int
   2:     add( int x, int y ) >> int
   2:     subtract( int x, int y ) >> int     % x - y
   2:     multiply( int x, int y ) >> int     % x * y
   2:     equal( int x, int y ) >> boolean
   2:     equal_zero (int) >> boolean
   2:     equal_node( Node, Node ) >> boolean
   2:     equal_string( String, String ) >> boolean
   2:     equal_node_type (node_type, node_type) >> boolean     % Want equal_<type> for every type
   2:     equal_label( Label, Label ) >> boolean
   2:     equal_code( Code, Code ) >> boolean
   2:     greater( int x, int y ) >> boolean
   2:     oMININT >> int    % the minimum 32-bit integer.
   2:     oMAXINT >> int    % the maximum 32-bit integer.
   2:     ;
      
   2: mechanism more_builtins:      % These should be built-in SSL operations
   2:     TOKEN_VALUE >> int        % value of just accepted token, e.g. IntLit token
   2:     TOKEN_VALUE_DOUBLE >> double
   2:     LAST_ID >> int            % id number of last accepted identifier
   2:     ID_STRING( int id ) >> String       % text name of identifier with given id
   2:     CURRENT_STRLIT >> String            % text value of just-accepted string literal
   2:     UNACCEPT_TOKEN            % Unaccept the last accepted token.  The next input, inputchoice will see it again.
   2:     ;
      
   2: mechanism workspace_mech:
   2:     oWorkspaceNew >> Node
   2:     ;
      
   2: mechanism scope_mech:
   2:     oScopeBegin( int level, AllocMode )  % create a new scope. Subsequent declarations will go here.
                                               %  level = static scope depth (0 = globals)
   2:     oScopeEnter( Node scope )            % enter an existing scope.
   2:     oScopeEnd                            % end current scope. Subsequent declarations will go to previous scope.
   2:     oScopeCurrent >> Node                % returns current scope
   2:     oScopeDeclare( Node decl )           % add declaration to current scope.
   2:     oScopeDeclareAlloc( Node decl )      % add declaration to current scope, and allocate space according to its type
   2:     oScopeAllocType( Node theType ) >> int   % allocate space for type in current scope, and return its address
   2:     oScopeAlloc( int size, int align ) >> int % allocate bytes, with given alignment in bytes 
   2:     oScopeFind >> Node                   % find declaration of last accepted identifier.  Returns Null if not found.
   2:     oScopeFindRequire >> Node            % find declaration of last accepted identifier.  Error if not found.
   2:     oScopeFindInCurrentScope >> Node     % find declaration of last accepted identifier, only within the current scope.  Null if not found.
   2:     oScopeFindRequireInScope( Node scope ) >> Node  % find decl of last accepted identifier, only within the given scope.  Error it not found.
   2:     ;
      
   2: mechanism type_mech:
   2:     oTypeAdd( Node node )     % add the given nType to the type table
   2:     ;
      
   2: mechanism type_stack_mech:
   2:     oTypeSPush( Node node )
   2:     oTypeSPop
   2:     oTypeSTop >> Node
   2:     oTypeSNodeType >> node_type          % node_type of the node on top of type stack, skipping subranges
   2:     ;
      
      
   2: mechanism id_mech:
          % gets/adds a predefined id to the scanner's id table, and returns the id code
   2:     oId_mysystem >> int
   2:     oId_ShortStringAppendShortString >> int
   2:     oId_ShortStringAppendChar >> int
   2:     oId_ShortStringCmp >> int
   2:     oId_File >> int
   2:     oId_Integer >> int
   2:     oId_Boolean >> int
   2:     oId_Char >> int
   2:     oId_Byte >> int
   2:     oId_Single >> int
   2:     oId_Double >> int
   2:     oId_Pointer >> int
   2:     oId_ShortString >> int
   2:     oId_True >> int
   2:     oId_False >> int
   2:     oId_Nil >> int
   2:     oId_Ord >> int
   2:     oId_Chr >> int
   2:     oId_Pred >> int
   2:     oId_Succ >> int
   2:     oId_Sizeof >> int
   2:     oChangeIntLitToLabelIdent    % change current token from pIntLit to pIdent "_label_<intlit>"
   2:     ;
      
      
      
   2: mechanism label_mech:
   2:    oLabelNew >> Label
   2:    ;
      
   2: mechanism code_mech:
   2:    oCodeNew >> Code         % create a new empty code stream
   2:    oCodePush( Code )        % change the current output code stream to the given one
   2:    oCodePop                 % restore the current code stream to the previous one
   2:    oCodeDiscard( Code )     % discard the given code stream
   2:    ;
      
   2: mechanism include_mech:
   2:    oIncludeUnitFile( int id ) >> boolean  % search for <unit>.pas and include it.
                                                % returns false if can't find.
   2:    oIncludeEnd              % stop including the current file
   2:    ;
      
      
   2: mechanism count :
   2:    oCountPush(int)          % start a new counter, with initial value
   2:    oCountInc
   2:    oCountDec
   2:    oCountIsZero >> boolean
   2:    oCountPop;
      
      
   2: mechanism value :              % value stack, to calc. const expr's
   2:    oValuePush(int)             % push an explicit int lit
   2:    oValuePushDouble(double)    % push a double onto value stack
   2:    oValuePushString(String)    % push string onto value stack
   2:    oValueTop >> int            % get top value on value stack
   2:    oValueTopDouble >> double
   2:    oValueTopString >> String
   2:    oValueSwap                  % swap top two
   2:    oValuePop
   2:    oValueCharToString          % convert top value from char to string
   2:    oValueIntToDouble
      
   2:    oValueNegate                % negate top numeric value
   2:    oValueEqual
   2:    oValueNotEqual
   2:    oValueLess
   2:    oValueGreater
   2:    oValueLessEqual
   2:    oValueGreaterEqual
      
   2:    oValueNegateD               % operations on double values
   2:    oValueEqualD
   2:    oValueNotEqualD
   2:    oValueLessD
   2:    oValueGreaterD
   2:    oValueLessEqualD
   2:    oValueGreaterEqualD
      
   2:    oValueOr                    % boolean or
   2:    oValueAnd
   2:    oValueNot                   % boolean not
      
   2:    oValueAdd
   2:    oValueSub
   2:    oValueMult
   2:    oValueDiv
      
   2:    oValueAddD
   2:    oValueSubD
   2:    oValueMultD
   2:    oValueDivD
      
   2:    oValueStringCmp             % compare top two strings. replace with negative, 0, or positive
   2:    oValueStringConcat
   2:    ;
      
   2: mechanism string :
   2:    oStringAllocLit( String ) >> int      % alloc global space for strlit, return address
   2:    oStringAllocShortStringLit( String ) >> int  % alloc global space for ShortString, return address
   2:    ;
      
      % track labels for the loop we're in, if any
   2: mechanism loop_mech:
   2:    oLoopPush( Label continueLabel, Label breakLabel )
   2:    oLoopContinueLabel >> Label
   2:    oLoopBreakLabel >> Label
   2:    oLoopPop
   2:    ;
      
      % for hacky debugging
   2: mechanism msg_mech:
   2:    oMsg( int num )             % print message "oMsg <num>"
   2:    oMsgTrace( int num )        % print message "oMsg <num>" followed by ssl traceback
   2:    oMsgNode( Node node )       % print node
   2:    oMsgNodeLong( Node node )   % print node with more detail
   2:    oMsgNodeVec( NodeVec vec )  % print node vec
   2:    ;
      
      
   2: rules
      
      % ----------------------------- Global Variables ----------------------------
      
   2: Node    workspace              % root of database
   2: Node    globalScope            % scope for globals in the current module
   2: Node    initScope              % scope for temporaries global var init,
                                     % and program main stmt / unit initialization stmts
      
   2: int     mysystemId               % id of identifier "mysystem"
      
      % built-in nTypes
   2: Node    FileType
   2: Node    IntegerType
   2: Node    BooleanType
   2: Node    BooleanFlowType
   2: Node    CharType
   2: Node    PCharType
   2: Node    ByteType
   2: Node    SingleType
   2: Node    DoubleType
   2: Node    UniversalPointerType
   2: Node    StrLitType
   2: Node    ShortStringType
      
      % nBuiltInFunc
   2: Node    BuiltIn_Ord
   2: Node    BuiltIn_Chr
   2: Node    BuiltIn_Pred
   2: Node    BuiltIn_Succ
   2: Node    BuiltIn_Sizeof
      
      % Declarations in unit mysystem that the compiler may refer to directly.
      
   2: Node    System_ShortStringAppendShortString
   2: Node    System_ShortStringAppendChar
   2: Node    System_ShortStringCmp
      
      
      % Expr has a corner case flag, needed for sizeof()
   2: boolean flagExprAllowTypeName
      
      
      % -------------------------- Forward Declarations -------------------------
      
   2: Block( node_type varNodeType, Label labelForBody );
   2: BlockDecls( node_type varNodeType );
   2: BlockStmt( Label labelForBody, Node varScope, boolean isMain );
   2: VarDecl( node_type varNodeType );
   2: newType( node_type nt, int size ) >> Node;
   2: newIdent( node_type nt, int id ) >> Node;
   2: EmitValue( Node decl );
   2: TypeRef( out Node theType );
   2: EnumTypeRef( out Node resultType );
   2: PointerTypeTo( Node theType ) >> Node;
   2: OrdinalLow( Node theType ) >> int;
   2: OrdinalHigh( Node theType ) >> int;
   2: AssignStmt( Node decl );
   2: BooleanExprControlFlow( out Label falseLabel );
   2: ExprAllowFlow( out Label falseLabel );
   2: BoolExprAllowFlow( out Label falseLabel );
   2: BoolTermAllowFlow( out Label falseLabel );
   2: BoolFactorAllowFlow( out Label falseLabel );
   2: ArithExprAllowFlow( out Label falseLabel );
   2: TermAllowFlow( out Label falseLabel );
   2: FactorAllowFlow( out Label falseLabel );
   2: PrimaryAllowFlow( out Label falseLabel );
      
   2: VarExpr( Node decl );
   2: LValueFromDecl( Node decl, boolean writeable );
   2: LValueVar( Node decl, boolean writeable );
   2: IncVar( Node decl );
   2: DecVar( Node decl );
      
   2: FlowToVal( inout Label falseLabel );
   2: ValToFlow( out Label falseLabel );
   2: MoveIntoTempShortString >> int;
      
   2: DeclLevel( Node decl ) >> int;
   2: DeclUpLevels( Node decl ) >> int;
      
      % ----------------------------- Start ----------------------------
      
   2: MainRule:
   4:    @Program
   7:    ;
      
   7: include 'pascal_unit.ssl'
      
      %
      %  Pascal Compiler
      %
      
      % ------------------------------ Units -----------------------------
      
      
      % The uses clause is a list of units required by the user program or unit.
      % We will find and compile the named units (unless already loaded).
      % We do not make the unit interface visible to the user, the caller will do so later.
   7: UsesClause( Node user ):
   9:    {
   9:       pIdent
  11:       @Uses( LAST_ID, user )
  20:       [
  20:          | ',' :
  22:          | * :  >
  29:       ]
  29:    }   
  31:    ';'
  34:    ;
      
      
      % Process an implicit "uses mysystem" in every module, except in the mysystem unit itself.
      % (I'm calling the unit mysystem rather than system, so fpc doesn't use it to replace its own system unit.)
      %
  34: UsesMySystem( Node user ):
  36:    [ equal( oNodeGetInt( user, qIdent ), mysystemId )
  53:       | true :  >>
  55:       | * :
  60:    ]
  60:    @Uses( mysystemId, user )
  71:    ;
      
      
      % After processing the mysystem unit interface, grab certain declarations from it
      % that the compiler may want to refer to later.
      %
  71: FindSelectSystemDecls( Node unit ):
  73:    [ equal( oNodeGetInt( unit, qIdent ), mysystemId )
  90:       | true :
  91:          System_ShortStringAppendShortString = oNodeFind( oScopeCurrent, qDecls, qIdent, oId_ShortStringAppendShortString )
 108:          System_ShortStringAppendChar = oNodeFind( oScopeCurrent, qDecls, qIdent, oId_ShortStringAppendChar )
 125:          System_ShortStringCmp = oNodeFind( oScopeCurrent, qDecls, qIdent, oId_ShortStringCmp )
 142:       | * :
 147:    ]
 148:    ;
      
      
      % The given user module uses a unit with the given id,
      % which may or may not have been loaded already.
      %
 148: Uses( int id, Node user ):
 150:    Node unit = @FindOrCompileUnit( id )
 161:    [ equal_node( unit, Null )
 171:       | false :
 172:          oNodeAddLast( user, qUsedUnits, unit )
      
               % Put a declaration in the current scope, naming the unit and pointing to it.
               % This is to allow references to  <unit>.<identifier_in_unit>
 184:          Node unitRef = oNodeNew( nUnitRef )
 194:          oNodeSetInt( unitRef, qIdent, oNodeGetInt( unit, qIdent ) )
 213:          oNodeSet( unitRef, qPublicScope, oNodeGet( unit, qPublicScope ) )
 232:          oScopeDeclare( unitRef )
 238:       | * :
 243:    ];
      
      
      % If the given decl is for an nUnitRef, the program is using syntax <unit>.<identifier>
      % Parse the rest of that to find the intended decl.
      %
 244: ResolveUnitRef( inout Node decl ):
 246:    [ oNodeType( decl )
 253:       | nUnitRef :
 254:          Node scope = oNodeGet( decl, qPublicScope )
 267:          '.'
 269:          pIdent
 271:          decl = oScopeFindRequireInScope( scope )
 281:       | * :
 286:    ];
      
      
 287: EnterUsedUnits( Node user ):
         % Make the used units' public scopes directly visible.
         % This is done after the units are all compiled, so they don't interfere with each other incorrectly.
         % Units later in the list have priority.
 289:    NodeIter unitIt = oNodeGetIter( user, qUsedUnits )
 302:    {
 302:       Node unit = oNodeIterValue( unitIt )
 312:       [ oNodeNull( unit )
 319:          | false :
 320:             oScopeEnter( oNodeGet( unit, qPublicScope ) )
 333:          | * :
 338:             >
 340:       ]
 340:       oNodeIterNext( unitIt )
 346:    }
 349:    ;
      
 349: EndUsedUnits( Node user ):
         % Leave the units' public scopes, so no longer visible.
 351:    NodeIter unitIt = oNodeGetIterLast( user, qUsedUnits )
 364:    {
 364:       Node unit = oNodeIterValue( unitIt )
 374:       [ oNodeNull( unit )
 381:          | false :
                  % Consistency check.  Make sure our scope enter / end have lined up correctly.
 382:             [ oNodeEqual( oScopeCurrent, oNodeGet( unit, qPublicScope ) )
 398:                | true :
 399:                | false :  #eInternalScopeMismatch
 403:             ]
 411:             oScopeEnd
 412:          | * :
 417:             >
 419:       ]
 419:       oNodeIterPrev( unitIt )
 425:    }
 428:    ;
      
      
 428: FindOrCompileUnit( int id ) >> Node:
         % We might have this unit loaded already
 430:    Node unit = oNodeFind( workspace, qUnits, qIdent, id )
 449:    [ equal_node( unit, Null )
 459:       | false :  >> unit
 463:       | * :
 468:    ]
      
         % If not, search for the source file on disk
 468:    boolean ok = oIncludeUnitFile( id )
 478:    [ ok
 481:       | false :  #eCantFindUnitFile  >> Null
 487:       | * :
 492:    ]
      
         % compile it, adding it into the workspace
         % then return it.
 492:    unit = @Unit
      
         % TO DO: ensure we are at pEof
         % end the include
 498:    oIncludeEnd
 499:    >> unit;
      
      
      
 503: Unit >> Node:
 505:    pUnit
 507:    pIdent
 509:    Node unit = oNodeNew( nUnit )
 519:    oNodeSetInt( unit, qIdent, LAST_ID )
 530:    Node unitImpl = oNodeNew( nUnitImpl )
 540:    oNodeSetInt( unitImpl, qIdent, LAST_ID )
 551:    oNodeSet( unit, qImpl, unitImpl )
 563:    ';'
      
         % mandatory sections
      
 565:    pInterface
 567:    @UsesMySystem( unit )
 574:    [
 574:       | pUses :   @UsesClause( unit )
 583:       | * :
 588:    ]
 588:    @EnterUsedUnits( unit )
      
 595:    oScopeBegin( 0, allocGlobal )
 604:    oNodeSet( unit, qPublicScope, oScopeCurrent )
 615:    globalScope = oScopeCurrent
      
         % A scope for temporaries needed by variable initialization
 620:    oScopeBegin( 0, allocDown )
 629:    initScope = oScopeCurrent
 634:    oNodeSet( unit, qInitRoutineScope, initScope )
 646:    oScopeEnd
      
 647:    @UnitInterface( unit )
 654:    oScopeEnd  % interface scope
      
 655:    pImplementation
 657:    @UsesMySystem( unitImpl )
 664:    [
 664:       | pUses :   @UsesClause( unitImpl )
 673:       | * :
 678:    ]
 678:    @EnterUsedUnits( unitImpl )
         % re-enter interface scope after impl's uses.  interface still has priority.
 685:    oScopeEnter( oNodeGet( unit, qPublicScope ) )
         
 698:    oScopeBegin( 0, allocGlobal )
 707:    oNodeSet( unit, qPrivateScope, oScopeCurrent )
 718:    oNodeSet( oScopeCurrent, qExtends, oNodeGet( unit, qPublicScope ) )
 736:    globalScope = oScopeCurrent
 741:    @UnitImplementation( unit )
      
 748:    [
 748:       | pInitialization :  @UnitInitialization( unit, true )   % init routine with statements from init section
 760:       | * :                @UnitInitialization( unit, false )  % implicit init routine
 775:    ]
 775:    [
 775:       | pFinalization :  @UnitFinalization( unit, true )
 787:       | * :              @UnitFinalization( unit, false )   % implicit final routine, may be handy later
 802:    ]
 802:    pEnd  '.'
      
 806:    oScopeEnd  % impl scope
 807:    oScopeEnd  % interface scope
 808:    @EndUsedUnits( unitImpl )  % used units scopes
 815:    @EndUsedUnits( unit )
 822:    oNodeAddLast( workspace, qUnits, unit )
 834:    >> unit;
      
      
 838: UnitInterface( Node unit ):
 840:    {[
 840:       | pConst :     @ConstDecl
 844:       | pType :      @TypeDecl
 848:       | pVar :       @VarDecl( nGlobalVar )
            % label declaration not allowed in interface
      
 857:       | pProcedure :
 859:          Node decl = @ProcHeaderDecl
               % despite syntax diagrams, fpc does allow external clause on methods in unit interface,
               % even though this clause is an alternative for the body statement.
 865:          [
 865:             | pExternal :
 867:                @ExternalDecl( decl )
 874:                ';'
 876:             | * :
 881:          ]
      
 881:       | pFunction :
 883:          Node decl = @FuncHeaderDecl
 889:          [
 889:             | pExternal :
 891:                @ExternalDecl( decl )
 898:                ';'
 900:             | * :
 905:          ]
      
 905:       | * :          >
 920:    ]}
 922:    @FindSelectSystemDecls( unit )
 930:    ;
      
 930: UnitImplementation( Node unit ):
 932:    @BlockDecls( nGlobalVar )
 940:    ;
      
      
 940: UnitInitialization( Node unit, boolean hasStmts ):
 942:    Label label = oLabelNew
 947:    .tLabel  oEmitLabel( label )
 955:    oNodeSetLabel( unit, qInitLabel, label )
      
 967:    int patchLS
 967:    .tEnter  patchLS = Here  .tSpace
      
         % insert any code for initialization of this unit's variables.
         
 976:    Node scope
 976:    Code initCode
      
 976:    scope = oNodeGet( unit, qPublicScope )
 989:    initCode = oNodeGetCode( scope, qInitCode )
1002:    oEmitCode( initCode )
1008:    oNodeSetCode( scope, qInitCode, codeNull )
      
1020:    scope = oNodeGet( unit, qPrivateScope )
1033:    initCode = oNodeGetCode( scope, qInitCode )
1046:    oEmitCode( initCode )
1052:    oNodeSetCode( scope, qInitCode, codeNull )
      
1064:    oScopeEnter( oNodeGet( unit, qInitRoutineScope ) )
      
1077:    [ hasStmts
1080:       | true :     
1081:          @Statement
1083:          {[
1083:             | ';' :  @Statement
1087:             | * :    >
1094:          ]}
1096:       | * :
1101:    ]
      
1101:    .tReturn
      
1103:    int localSpace = oNodeGetInt( oScopeCurrent, qSize )
1115:    oPatch( patchLS, localSpace )
1124:    oScopeEnd   % init routine scope, for temporaries
1126:    ;
      
      
1126: UnitFinalization( Node unit, boolean hasStmts ):
1128:    Label label = oLabelNew
1133:    .tLabel  oEmitLabel( label )
1141:    oNodeSetLabel( unit, qFinalLabel, label )
      
1153:    int patchLS
1153:    .tEnter  patchLS = Here  .tSpace
      
         % final routine scope, for temporaries
1162:    oScopeBegin( 0, allocDown )
      
1171:    [ hasStmts
1174:       | true :     
1175:          @Statement
1177:          {[
1177:             | ';' :  @Statement
1181:             | * :    >
1188:          ]}
1190:       | * :
1195:    ]
      
1195:    .tReturn
      
1197:    int localSpace = oNodeGetInt( oScopeCurrent, qSize )
1209:    oPatch( patchLS, localSpace )
1218:    oScopeEnd   % final routine scope, for temporaries
1220:    ;
      
      
1220: InitializeUnits:
         % call init routine of each loaded unit, in the order they were loaded
         % (used directly or indirectly by the main program).
1222:    NodeIter it = oNodeGetIter( workspace, qUnits )
1235:    {
1235:       Node unit = oNodeIterValue( it )
1245:       [ oNodeNull( unit )
1252:          | true :  >
1255:          | false :
1257:             .tAllocActuals  oEmitInt( 0 )  % not sure I need this. maybe for stack alignment.
1265:             .tCall  oEmitLabel( oNodeGetLabel( unit, qInitLabel ) )
1280:             .tFreeActuals  oEmitInt( 0 )
1288:             oNodeIterNext( it )
1294:       ]
1302:    };
      
      
1305: FinalizeUnits:
1307:    NodeIter it = oNodeGetIterLast( workspace, qUnits )
1320:    {
1320:       Node unit = oNodeIterValue( it )
1330:       [ oNodeNull( unit )
1337:          | true :  >
1340:          | false :
1342:             .tAllocActuals  oEmitInt( 0 )  % not sure I need this. maybe for stack alignment.
1350:             .tCall  oEmitLabel( oNodeGetLabel( unit, qFinalLabel ) )
1365:             .tFreeActuals  oEmitInt( 0 )
1373:             oNodeIterPrev( it )
1379:       ]
1387:    };
      
1390: include 'pascal_decl.ssl'
      %
      % Pascal Compiler
      %
      
      % ----------------------------- Declarations ----------------------------
      
      
      
      % modifers that may appear on a proc/function declaration.
      %
1390: MethodModifiers( Node decl ):
1392:    {[
1392:       | pCdecl :
1394:          oNodeSetBoolean( decl, qCdecl, true )
1406:          ';'
      
1408:       | * : >
1415:    ]}
1418:    ;
      
      
      % external method resides in an external object file
      % (or in my system, the built-in runtime library).
      % The method has a label, as usual, which callers will use.
      % But we define that label with .tLabelExtern rather than .tLabel.
      %
      % Note this is fpc syntax.  I'm not sure about other Pascals.
      %
1418: ExternalDecl( Node decl ):
1420:    [ equal_zero( @DeclLevel( decl ) )
1432:       | false :  #eExternalMethodCannotBeNested
1435:       | * :
1440:    ]
         % For now, only cdecl methods may be declared external
1440:    [ oNodeGetBoolean( decl, qCdecl )
1450:       | false :  #eExternalMethodMustBeCdecl
1453:       | * :
1458:    ]
1458:    oNodeSetBoolean( decl, qExternal, true )
1470:    [
1470:       | pStrLit :
               % that was the optional library name containing the method.
               % TO DO: I'm currently ignoring this.
1472:          [
1472:             | pName :
1474:                pStrLit
                     % that was the optional method name defined in that library,
                     % which might differ from the Pascal name.
1476:                oNodeSetString( decl, qExternalName, CURRENT_STRLIT )
1487:             | * :
1492:          ]
1492:       | * :
1497:    ]
1497:    @DefineExternLabel( decl )
1505:    ;
      
      
1505: ProcHeaderDecl >> Node:
1507:    pIdent
      
         % If we already have a forward declaration, we'll modify that decl
         % instead of creating a second symbol table entry.
         % (Alternatively could delete or hide the old entry.)
1509:    boolean redeclaring = false
1515:    Node decl = oScopeFindInCurrentScope
      
1520:    [ oNodeNull( decl )
1527:       | true :
               % first declaration
1528:          decl = @newIdent( nProc, LAST_ID )
1541:          oNodeSetLabel( decl, qValue, oLabelNew )
      
1552:       | false :
               % we already have a declaration.
               % Keep it, and its label.
1554:          redeclaring = true
1560:          [ oNodeGetBoolean( decl, qBodyDefined )
1570:             | true : #eAlreadyDefined
1573:             | * :
1578:          ]
1578:          [ oNodeGetBoolean( decl, qExternal )
1588:             | true : #eAlreadyDefined
1591:             | * :
1596:          ]
1596:          [ oNodeType( decl )
1603:             | nProc :
1604:             | * : #eAlreadyDefined   % wrong kind
1611:          ]
               % Move the existing param scope aside, so we can check that the
               % new one is consistent.  And, the body will want to see the new one
               % since the names might differ.
               % TO DO: If qOldParams already set, we have multiple forward decls,
               % which I believe is supposed to be an error.
1611:          oNodeSet( decl, qOldParams, oNodeGet( decl, qParams ) )
1630:          oNodeSet( decl, qParams, Null )
1642:    ]
      
1650:    int level = @ScopeLevel
1656:    boolean nested = greater( level, 0 )
1669:    inc( level )
1675:    oScopeBegin( level, allocUp )
1684:    Node paramScope = oScopeCurrent
      
         % A nested method has a hidden first param for the parent static scope.
         % This won't appear in the param decls list, just reserve space for it.
         % It's first so the static chain is always at a fixed offset from the frame pointer.
1689:    [ nested
1692:       | true :
1693:          int offset = oScopeAllocType( @PointerTypeTo( IntegerType ) )   % arbitrary ptr type
1708:       | * :
1713:    ]
      
1713:    @FormalArgDecl
1715:    oNodeSet( decl, qParams, paramScope )
1727:    oScopeEnd
1728:    ';'
      
1730:    [ redeclaring
1733:       | false : oScopeDeclare( decl )
1740:       | true :  % TO DO: check that qParams is consistent with qOldParams
1742:    ]
      
1750:    @MethodModifiers( decl )
1757:    >> decl;
      
      
1761: ProcDecl:
1763:    Node decl = @ProcHeaderDecl
      
         % Body may be a statement, "forward", "external".
         % Note, this syntax is based on FPC, and I'm not sure if other Pascals are similar.
         % FPC says that forward, external, cdecl, name, etc are not reserved words -
         % I think this means the user may declare other things with those names, but if so the
         % original meaning is lost.  I'll make them keywords for simplicity, for now
         % (just not too happy about "name").
      
1769:    [
1769:       | pForward :
               % Nothing to do.  We simply won't set qBodyDefined.
      
1771:       | pExternal : @ExternalDecl( decl )
      
1780:       | * :
               % Body statement
      
               % Enter the params scope again, so params are visible in body.
               % TO DO: Perhaps I could mark the scope read-only at this point.
1787:          Node paramScope = oNodeGet( decl, qParams )
1800:          oScopeEnter( paramScope )
      
               % Start scope for declarations within the proc
1806:          int level = oNodeGetInt( paramScope, qLevel )
1819:          oScopeBegin( level, allocDown )
1828:          oNodeSet( decl, qChildScope, oScopeCurrent )
      
1839:          Label label = oNodeGetLabel( decl, qValue )
1852:          @Block( nLocalVar, label )
1862:          oNodeSetBoolean( decl, qBodyDefined, true )
1874:          oScopeEnd
      
1875:          oScopeEnd  % paramScope
1876:    ]
1876:    ';';
      
      
      
1879: FuncHeaderDecl >> Node:
1881:    pIdent
      
         % If we already have a forward declaration, we'll modify that decl
         % instead of creating a second symbol table entry.
         % (Alternatively could delete or hide the old entry.)
1883:    boolean redeclaring = false
1889:    Node decl = oScopeFindInCurrentScope
      
1894:    [ oNodeNull( decl )
1901:       | true :
               % first declaration
1902:          decl = @newIdent( nFunc, LAST_ID )
1915:          oNodeSetLabel( decl, qValue, oLabelNew )
      
1926:       | false :
               % we already have a declaration.
               % Keep it, and its label.
1928:          redeclaring = true
1934:          [ oNodeGetBoolean( decl, qBodyDefined )
1944:             | true : #eAlreadyDefined
1947:             | * :
1952:          ]
1952:          [ oNodeType( decl )
1959:             | nFunc :
1960:             | * : #eAlreadyDefined   % wrong kind
1967:          ]
               % Move the existing param scope and return value aside,
               % so we can check that the new one is consistent.
               % And, the body will want to see the new one since the names might differ.
               % TO DO: If qOldParams already set, we have multiple forward decls,
               % which I believe is supposed to be an error.
1967:          oNodeSet( decl, qOldParams, oNodeGet( decl, qParams ) )
1986:          oNodeSet( decl, qParams, Null )
1998:          oNodeSet( decl, qOldType, oNodeGet( decl, qType ) )
2017:          oNodeSet( decl, qType, Null )
2029:    ]
      
2037:    int level = @ScopeLevel
2043:    boolean nested = greater( level, 0 )
2056:    inc( level )
2062:    oScopeBegin( level, allocUp )
2071:    Node paramScope = oScopeCurrent
      
         % A nested method has a hidden first param for the parent static scope.
         % This won't appear in the param decls list, just reserve space for it.
         % It's first so the static chain is always at a fixed offset from the frame pointer.
2076:    [ nested
2079:       | true :
2080:          int offset = oScopeAllocType( @PointerTypeTo( IntegerType ) )   % arbitrary ptr type
2095:       | * :
2100:    ]
      
2100:    @FormalArgDecl
2102:    oNodeSet( decl, qParams, paramScope )
      
2114:    ':'
      
2116:    Node theType
2116:    @TypeRef( theType )
2123:    oNodeSet( decl, qType, theType )
      
         % The function's param space gets an additional pointer,
         % which will point to a temporary in the caller's scope.
         % This pointer is essentially a VAR param, but I won't create an nParam for it.
      
2135:    Node ptrType = @PointerTypeTo( theType )
2146:    oNodeSetInt( decl, qResultOffset, oScopeAllocType( ptrType ) )
2162:    oScopeEnd
2163:    ';'
      
2165:    [ redeclaring
2168:       | false : oScopeDeclare( decl )
2175:       | true :  % TO DO: check that qParams is consistent with qOldParams
                      % and qType is consistent with qOldType
2177:    ]
      
2185:    @MethodModifiers( decl )
      
2192:    >> decl;
      
      
2196: FuncDecl:
2198:    Node decl = @FuncHeaderDecl
      
         % Body may be a statement, "forward", "external".
2204:    [
2204:       | pForward :
               % Nothing to do.  We simply won't set qBodyDefined.
      
2206:       | pExternal : @ExternalDecl( decl )
      
2215:       | * :
               % Body statement
      
               % Enter the params scope again, so params are visible in body.
               % TO DO: Perhaps I could mark the scope read-only at this point.
2222:          Node paramScope = oNodeGet( decl, qParams )
2235:          oScopeEnter( paramScope )
      
               % Start scope for declarations within the func
2241:          int level = oNodeGetInt( paramScope, qLevel )
2254:          oScopeBegin( level, allocDown )
2263:          oNodeSet( decl, qChildScope, oScopeCurrent )
      
2274:          Label label = oNodeGetLabel( decl, qValue )
2287:          @Block( nLocalVar, label )
2297:          oNodeSetBoolean( decl, qBodyDefined, true )
2309:          oScopeEnd
      
2310:          oScopeEnd  % paramScope
2311:    ]
2311:    ';';
      
      
2314: FormalArgDecl:
2316:    [
2316:       | '(' :
2318:          {
2318:             NodeVec decls = oNodeVecNew
2323:             Node decl
2323:             boolean isInOut = false
      
2329:             [
2329:                | pVar : isInOut = true
2337:                | * :
2342:             ]
      
2342:             {  pIdent
      
2344:                decl = @newIdent( nParam, LAST_ID )
2357:                oNodeSetBoolean( decl, qInOut, isInOut )
2369:                oNodeVecAppend( decls, decl )
      
2378:                [
2378:                   | ':' : >
2382:                   | ',' :
2384:                ]
2392:             }
      
2394:             Node theType
2394:             @TypeRef( theType )
      
                  % VAR param is declared with its given type, but allocated as a pointer.
2401:             Node allocType
2401:             [ isInOut
2404:                | true :   allocType = @PointerTypeTo( theType )
2416:                | * :      allocType = theType
2427:             ]
      
2427:             int i = 0
2433:             {[ equal( i, oNodeVecSize( decls ) )
2447:                | false :
2448:                   decl = oNodeVecElement( decls, i )
      
2461:                   oNodeSet( decl, qType, theType )
2473:                   oScopeDeclare( decl )
2479:                   oNodeSetInt( decl, qValue, oScopeAllocType( allocType ) )
2495:                   inc( i )
2501:                | * :
2506:                   >
2508:             ]}
      
2510:             oNodeVecDelete( decls )
      
2516:             [
2516:                | ')' : >
2520:                | ';' :
2522:             ]
2530:          }
2532:       | * :
2537:    ];
      
      
2538: ConstDecl:
2540:    {[
2540:       | pIdent :
2542:          [
2542:             | ':' :
2544:                @TypedConstDecl
2546:             | * :
2551:                @TrueConstDecl
2553:          ]
2553:       | * :
2558:          >
2560:    ]};
      
      
      % Parse a true constant declaration (as opposed to a typed const declaration).
      % The "true constant" terminology comes from Delphi docs.  It refers to a const that is
      % evaluated at compile time, rather than at program startup time.
      %
      % We've just accepted the identifier.
      %
2563: TrueConstDecl:
2565:    int id = LAST_ID
2570:    '='
      
2572:    @ConstExpr
      
2574:    Node decl
2574:    [ oTypeSNodeType
2576:       | nBooleanType, nByteType, nCharType, nIntegerType, nEnumType,
2577:         nPointerType, nUniversalPointerType :
2577:          decl = @newIdent( nConst, id )
2591:          oNodeSetInt( decl, qValue, oValueTop )
2602:       | nDoubleType :
2604:          decl = @newIdent( nConstDouble, id )
2618:          oNodeSetDouble( decl, qValueDouble, oValueTopDouble )
2629:       | nStrLitType :
2631:          decl = @newIdent( nConstStr, id )
2645:          oNodeSetString( decl, qValueStr, oValueTopString )
2656:       | * :  #eNotAllowed
2679:    ]
2679:    oValuePop
2680:    oNodeSet( decl, qType, oTypeSTop )
2691:    oTypeSPop
2692:    oScopeDeclare( decl )
2698:    ';'
2701:    ;
      
      
      % Parse a typed const declaration.
      % We've just accepted the identifier and ':'
      %
2701: TypedConstDecl:
2703:    Node decl = @newIdent( nTypedConst, LAST_ID )
      
2716:    Node theType
2716:    @TypeRef( theType )
2723:    oNodeSet( decl, qType, theType )
      
         % Array and record consts are allocated in global memory,
         % with global offset stored as decl value.
         % Scalar consts are not allocated in memory, and their value is
         % stored directly as the decl value, as I do with "true constants".
         %
         % TO DO: I probably should store scalar consts in memory too, in case somebody
         % wants to get a pointer to them.  And anyway, typed constants can't be used in
         % constant expressions, so less need to store value in decl node.
      
         % TO DO: skip subranges, similar to oTypeSNodeType.
2735:    [ oNodeType( theType )
2742:       | nBooleanType, nByteType, nCharType, nIntegerType, nEnumType,
2743:         nPointerType, nUniversalPointerType :
               % Parse expression and store value in decl
2743:          '='
      
2745:          oTypeSPush( theType )
2751:          @ConstExpr
2753:          @ConstCoerceType
      
2755:          oNodeSetInt( decl, qValue, oValueTop )
2766:          oValuePop
2767:          oTypeSPop
2768:          oScopeDeclare( decl )
2774:          ';'
      
2776:       | nShortStringType, nFileType :
2778:          #eNotImplemented
      
2780:       | nArrayType, nRecordType :
               % Allocate global space, store address in decl.
               % Push into global scope init code stream (since we'll be issuing code
               % rather than creating static data, at the moment).
               % Parse expression and store in global memory.
2782:          oScopeEnter( globalScope )
2788:          int addr = oScopeAllocType( theType )
2798:          oScopeEnd
2799:          oCodePush( @GetOrCreateInitCode( globalScope ) )
2810:          oNodeSetInt( decl, qValue, addr )
2822:          '='
2824:          @TypedConstInit( theType, addr )
2834:          oCodePop
2835:          oScopeDeclare( decl )
2841:          ';'
2843:    ]
2870:    ;
      
      
      % Parse the initial value of a constant that's being stored in global memory.
      % (An array or record constant, and recursively all its elements.)
      % Given the type, and the address in global memory for the const value.
      % The caller has already pushed into the global init code stream.
      %
2870: TypedConstInit( Node theType, int addr ):
      
         % TO DO: skip subranges, similar to oTypeSNodeTYpe
2872:    [ oNodeType( theType )
2879:       | nArrayType :
2880:          Node baseType = oNodeGet( theType, qBaseType )
2893:          Node indexType = oNodeGet( theType, qIndexType )
2906:          int low = @OrdinalLow( indexType )
2917:          int high = @OrdinalHigh( indexType )
2928:          int elementSize = oNodeGetInt( baseType, qSize )
      
2941:          '('
               % Loop over elements
2943:          int i = low
2949:          {
2949:             @TypedConstInit( baseType, addr )
2959:             [ equal( i, high )
2969:                | true : >
2972:                | false :
2974:             ]
2982:             ','
2984:             addr = add( addr, elementSize )
2997:             inc( i )
3003:          }
3005:          ')'
      
3007:       | nRecordType :
3009:          '('
3011:          Node fieldScope = oNodeGet( theType, qScope )
               % Loop over zero or more named fields.  It's not necessary to name them all.
               % fpc says the names that are given should be in order, but I'm not requiring that.
               % Since this is global memory, uninitialized fields will be left as 0.
3024:          {
3024:             [
3024:                | pIdent :
3026:                | * :  >
3033:             ]
3033:             Node field = oScopeFindRequireInScope( fieldScope )
3043:             ':'
3045:             Node fieldType = oNodeGet( field, qType )
3058:             int fieldAddr = add( addr, oNodeGetInt( field, qValue ) )
3078:             @TypedConstInit( fieldType, fieldAddr )
3088:             [
3088:                | ';' :
3090:                | * :  >
3097:             ]
3097:          }
3099:          ')'
      
3101:       | nBooleanType, nByteType, nCharType:
3103:          .tPushAddrGlobal  oEmitInt( addr )
3111:          oTypeSPush( theType )
3117:          @ConstExpr
3119:          @ConstCoerceType
3121:          .tPushConstI  oEmitInt( oValueTop )
3128:          oValuePop
3129:          oTypeSPop
3130:          .tAssignB
      
3132:       | nIntegerType, nEnumType:
3134:          .tPushAddrGlobal  oEmitInt( addr )
3142:          oTypeSPush( theType )
3148:          @ConstExpr
3150:          @ConstCoerceType
3152:          .tPushConstI  oEmitInt( oValueTop )
3159:          oValuePop
3160:          oTypeSPop
3161:          .tAssignI
      
3163:       | nDoubleType:
3165:          #eNotImplemented
      
3167:       | nPointerType, nUniversalPointerType :
3169:          .tPushAddrGlobal  oEmitInt( addr )
3177:          oTypeSPush( theType )
3183:          @ConstExpr
3185:          @ConstCoerceType
3187:          .tPushConstI  oEmitInt( oValueTop )   % only allowing ptr constant Nil so don't need tPushConstP or link redirection
3194:          oValuePop
3195:          oTypeSPop
3196:          .tAssignP
      
3198:       | nShortStringType, nFileType :
3200:          #eNotImplemented
3202:    ]
3231:    ;
      
      
3231: TypeDecl:
3233:    {[
3233:       | pIdent :
3235:          Node decl = @newIdent( nTypeDecl, LAST_ID )
3248:          '='
3250:          Node theType
3250:          @TypeRef( theType )
3257:          oNodeSet( decl, qType, theType )
3269:          oScopeDeclare( decl )
3275:          ';'
3277:       | * :
3282:          >
3284:    ]};
      
3287: VarDecl( node_type varNodeType ):
3289:    {[
3289:       | pIdent :
3291:          NodeVec decls = oNodeVecNew
3296:          Node decl
3296:          {
3296:             decl = @newIdent( varNodeType, LAST_ID )
3309:             oNodeVecAppend( decls, decl )
3318:             [
3318:                | ',' :
3320:                   pIdent
3322:                | * :
3327:                   >
3329:             ]
3329:          }
3331:          ':'
3333:          Node theType
3333:          @TypeRef( theType )
      
3340:          int i = 0
3346:          {[ equal( i, oNodeVecSize( decls ) )
3360:             | false :
3361:                decl = oNodeVecElement( decls, i )
3374:                oNodeSet( decl, qType, theType )
3386:                oScopeDeclareAlloc( decl )
3392:                inc( i )
3398:             | * :
3403:               >
3405:          ]}
      
               % optional initialization
3407:          [
3407:             | '=' :
3409:                [ oNodeVecSize( decls )
3416:                   | 1 :
3417:                   | * :  #eOnlyOneVarCanBeInitialized
3424:                ]
      
                     % we need an initCode stream for this scope
3424:                Code initCode = @GetOrCreateInitCode( oScopeCurrent )
3434:                oCodePush( initCode )
      
                     % currently the global level has two scopes:
                     % the one for declarations e.g. vars and methods,
                     % and a second one for temporaries needed by the main block stmt.
                     % During evaluation of the init expr, we need to be in the 2nd scope
                     % in case the expression requires temporaries
                     % (so the temporaries get allocated in the right scope).
                     % TO DO: Maybe I should make the global scope the special case, instead.
3440:                boolean changedScope = false
3446:                [ equal_zero( @ScopeLevel )
3453:                   | true : oScopeEnter( initScope )
3460:                            changedScope = true
3466:                   | * :
3471:                ]
                     % generate assignment in initCode stream
3471:                @LValueVar( decl, true )
3481:                @Expr
3483:                @CoerceType
3485:                @Assign
3487:                [ changedScope
3490:                   | true : oScopeEnd
3492:                   | * :
3497:                ]
3497:                oCodePop
                   
3498:             | * :
3503:          ]
      
3503:          oNodeVecDelete( decls )
3509:          ';'
3511:       | * :
3516:          >
3518:    ]};
      
      
      % Parse a list of label declarations.
      % We'll create a tcode label at declaration time, for each user label.
      % If the user label is an integer, we'll record it as _label_<int> in the decl.
      %
3521: LabelDecl:
3523:    {
3523:       Node decl
3523:       [
3523:          | pIdent :
3525:          | pIntLit :
                  % Replace token with identifier "_label_<intlit>"
3527:             oChangeIntLitToLabelIdent
3528:       ]
3536:       decl = @newIdent( nLabel, LAST_ID )
            % TO DO: ensure not already declared in this scope.
            %        Or maybe that can be part of oScopeDeclare.
3549:       Label label = oLabelNew
3554:       oNodeSetLabel( decl, qValue, label )
3566:       oScopeDeclare( decl )
3572:       [
3572:          | ',' :
3574:          | * :
3579:             >
3581:       ]
3581:    }
3583:    ';'
3586:    ;
3586: include 'pascal_constexpr.ssl'
      %
      % Pascal Compiler
      %
      
      % --------------------------- Const Expressions --------------------------
      
      
      % Constant expressions are evaluated at compile time.
      % They are limited to constant literals, declared constants (not including TypedConstants!)
      % and a small selection of built-in functions. 
      %
      % The value of a constant expression is left on the Value Stack.
      % The type is left on the Type Stack.
      
3586: ConstExpr:
3588:    @ConstBoolExpr
3590:    {[
3590:       | '=' :
3592:          @ConstBoolTerm
3594:          @ConstCoerceTypePair
3596:          [ oTypeSNodeType
3598:             | nStrLitType :   oValueStringCmp  oValuePush( 0 )  oValueEqual
3607:             | nDoubleType :   oValueEqualD
3610:             | * :             oValueEqual
3618:          ]
3618:          oTypeSPop  oTypeSPush( BooleanType )
3625:       | '<>' :
3627:          @ConstBoolExpr
3629:          @ConstCoerceTypePair
3631:          [ oTypeSNodeType
3633:             | nStrLitType :   oValueStringCmp  oValuePush( 0 )  oValueNotEqual
3642:             | nDoubleType :   oValueNotEqualD
3645:             | * :             oValueNotEqual
3653:          ]
3653:          oTypeSPop  oTypeSPush( BooleanType )
3660:       | '<' :
3662:          @ConstBoolExpr
3664:          @ConstCoerceTypePair
3666:          [ oTypeSNodeType
3668:             | nStrLitType :   oValueStringCmp  oValuePush( 0 )  oValueLess
3677:             | nDoubleType :   oValueLessD
3680:             | * :             oValueLess
3688:          ]
3688:          oTypeSPop  oTypeSPush( BooleanType )
3695:       | '>' :
3697:          @ConstBoolExpr
3699:          @ConstCoerceTypePair
3701:          [ oTypeSNodeType
3703:             | nStrLitType :   oValueStringCmp  oValuePush( 0 )  oValueGreater
3712:             | nDoubleType :   oValueGreaterD
3715:             | * :             oValueGreater
3723:          ]
3723:          oTypeSPop  oTypeSPush( BooleanType )
3730:       | '<=' :
3732:          @ConstBoolExpr
3734:          @ConstCoerceTypePair
3736:          [ oTypeSNodeType
3738:             | nStrLitType :   oValueStringCmp  oValuePush( 0 )  oValueLessEqual
3747:             | nDoubleType :   oValueLessEqualD
3750:             | * :             oValueLessEqual
3758:          ]
3758:          oTypeSPop  oTypeSPush( BooleanType )
3765:       | '>=' :
3767:          @ConstBoolExpr
3769:          @ConstCoerceTypePair
3771:          [ oTypeSNodeType
3773:             | nStrLitType :   oValueStringCmp  oValuePush( 0 )  oValueGreaterEqual
3782:             | nDoubleType :   oValueGreaterEqualD
3785:             | * :             oValueGreaterEqual
3793:          ]
3793:          oTypeSPop  oTypeSPush( BooleanType )
3800:       | * :  >
3817:    ]};
      
      
      % Same as ConstExpr, but allow a typename as a primary.
      % This is for use within sizeof().
      % The value produced by that primary is bogus, but doesn't matter.
      %
3820: ConstExprAllowTypeName:
3822:    boolean oldAllowTypeName = flagExprAllowTypeName
3828:    flagExprAllowTypeName = true
3834:    @ConstExpr
3836:    flagExprAllowTypeName = oldAllowTypeName
3843:    ;
      
      
3843: ConstBoolExpr:
3845:    @ConstBoolTerm
3847:    {[
3847:       | pOr :
3849:          @ConstRequireBool
3851:          @ConstBoolTerm
3853:          @ConstRequireBoolPop
3855:          oValueOr
3856:       | * :  >
3863:    ]};
      
      
3866: ConstBoolTerm:
3868:    @ConstBoolFactor
3870:    {[
3870:       | pAnd :
3872:          @ConstRequireBool
3874:          @ConstBoolFactor
3876:          @ConstRequireBoolPop
3878:          oValueAnd
3879:       | * :  >
3886:    ]};
      
      
3889: ConstBoolFactor:
3891:    [
3891:       | pNot :
3893:          @ConstBoolFactor
3895:          @ConstRequireBool
3897:          oValueNot
3898:       | * :
3903:          @ConstArithExpr
3905:    ];
      
      
3906: ConstArithExpr:
3908:    @ConstTerm
3910:    {[
3910:       | '+' :
3912:          @ConstTerm
3914:          @ConstCoerceTypePair
3916:          [ oTypeSNodeType
3918:             | nStrLitType :   oValueStringConcat
3920:             | nDoubleType :   oValueAddD
3923:             | * :             oValueAdd
3931:          ]
3931:       | '-' :
3933:          @ConstTerm
3935:          @ConstCoerceTypePair
3937:          [ oTypeSNodeType
3939:             | nStrLitType :   #eNotAllowed
3942:             | nDoubleType :   oValueSubD
3945:             | * :             oValueSub
3953:          ]
3953:       | * :  >
3962:    ]};
      
      
3965: ConstTerm:
3967:    @ConstFactor
3969:    {[
3969:       | pTimes :
3971:          @ConstFactor
3973:          @ConstCoerceTypePair
3975:          [ oTypeSNodeType
3977:             | nStrLitType :   #eNotAllowed
3980:             | nDoubleType :   oValueMultD
3983:             | * :             oValueMult
3991:          ]
3991:       | pDivide :
3993:          @ConstFactor
3995:          @ConstCoerceTypePair
3997:          [ oTypeSNodeType
3999:             | nStrLitType :   #eNotAllowed
4002:             | nDoubleType :   oValueDivD
4005:             | * :             oValueDiv
4013:          ]
4013:       | * :  >
4022:    ]};
      
      
4025: ConstFactor:
4027:    [
4027:       | pPlus :
4029:          @ConstPrimary
4031:       | pMinus :
4033:          @ConstPrimary
4035:          [ oTypeSNodeType
4037:             | nStrLitType :   #eNotAllowed
4040:             | nDoubleType :   oValueNegateD
4043:             | * :             oValueNegate
4051:          ]
4051:       | * :
4058:          @ConstPrimary
4060:    ];
      
      
4061: ConstPrimary:
4063:    [
4063:       | pIntLit :
4065:          oValuePush( TOKEN_VALUE )
4070:          oTypeSPush( IntegerType )
4076:       | pCharLit :
4078:          oValuePush( TOKEN_VALUE )
4083:          oTypeSPush( CharType )
4089:       | pDoubleLit :
4091:          oValuePushDouble( TOKEN_VALUE_DOUBLE )
4096:          oTypeSPush( DoubleType )
4102:       | pStrLit :
4104:          oValuePushString( CURRENT_STRLIT )
4109:          oTypeSPush( StrLitType )
4115:       | '(' :
4117:          @ConstExpr
4119:          ')'
4121:       | pIdent :
4123:          Node decl = oScopeFindRequire
4128:          @ResolveUnitRef( decl )
4135:          [ oNodeType( decl )
4142:             | nBuiltInFunc :
4143:                @ConstBuiltInFunc( decl )
4150:             | nConst :
4152:                oValuePush( oNodeGetInt( decl, qValue ) )
4165:                oTypeSPush( oNodeGet( decl, qType ) )
4178:             | nConstStr :
4180:                oValuePushString( oNodeGetString( decl, qValueStr ) )
4193:                oTypeSPush( oNodeGet( decl, qType ) )
4206:             | nEnumValue :
4208:                oValuePush( oNodeGetInt( decl, qValue ) )
4221:                oTypeSPush( oNodeGet( decl, qType ) )
4234:             | nTypeDecl :
                     % A type cast, or a typename primary when within sizeof()
4236:                oTypeSPush( oNodeGet( decl, qType ) )
4249:                [
4249:                   | '(' :
                           % Type cast
4251:                      @ConstExpr
4253:                      ')'
4255:                      @ConstCastType
                           % Constexprs are not compound types or dereferenceable pointers (I believe)
                           % so no need to check for additional suffixes here as we do in PrimaryAllowCF
4257:                   | * :
                           % Not a type cast
                           % A raw typename is only allowed in expressions within sizeof
4262:                      [ flagExprAllowTypeName
4265:                         | true :
                                 % The value we produce is bogus.  Only the type stack matters.
4266:                            oValuePush( 0 )
4272:                         | * :   #eTypeNameNotAllowedHere
4279:                      ]
4279:                ]
      
4279:             | * :
4292:                #eNotConst
4294:                oValuePush( 0 )
4300:                oTypeSPush( IntegerType )
4306:          ]
4306:       | '@' :
4308:          #eNotImplemented
4310:          oValuePush( 0 )
4316:          oTypeSPush( UniversalPointerType )
4322:       | * :
4339:          #eNotConst
4341:          oValuePush( 0 )
4347:          oTypeSPush( IntegerType )
4353:    ];
      
4354: ConstRequireBoolPop:
4356:    [ oTypeSNodeType
4358:       | nBooleanType :
4359:       | * :          #eNotBoolean
4366:    ]
4366:    oTypeSPop;
      
      
4368: ConstRequireBool:
4370:    [ oTypeSNodeType
4372:       | nBooleanType :
4373:       | * :          #eNotBoolean
4380:    ];
      
      
      % Require that the top two types on the type stack are matching (ignoring subranges).
      % Pop one of them, leaving only one.
      % The types refer to constant values on the Value Stack,
      % so any implicit conversion would occur there, not in code.
      %
      % Some implicit conversion is allowed for either of the types.
      % See also ConstCoerceType where only the top type may change.
      %
4381: ConstMatchTypes:
4383:    node_type nt = oTypeSNodeType
4388:    oTypeSPop
4389:    [ equal_node_type( nt, oTypeSNodeType )
4398:       | false :
               % Some implicit conversion is allowed even here
4399:          [ oTypeSNodeType
4401:             | nPointerType :
4402:                [ nt
4405:                   | nUniversalPointerType :  >>
4407:                   | * :
4412:                ]
4412:             | nUniversalPointerType :
4414:                [ nt
4417:                   | nPointerType :  >>
4419:                   | * :
4424:                ]
4424:             | nStrLitType :
4426:                [ nt
4429:                   | nCharType :
4430:                      oValueCharToString
4431:                      >>
4432:                   | * :
4437:                ]
4437:             | nCharType :
4439:                [ nt
4442:                   | nStrLitType :
4443:                      oValueSwap
4444:                      oValueCharToString
4445:                      oValueSwap
4446:                      oTypeSPop
4447:                      oTypeSPush( StrLitType )
4453:                      >>
4454:                   | * :
4459:                ]
4459:             | * :
4470:          ]
4470:          #eTypeMismatch
4472:       | * :
4477:    ];
      
      
      % Given a constant value on the value stack, its type on the type stack,
      % and the desired type under it on the type stack.
      % Perform any necessary implicit conversions so the value is the desired type.
      % Pop the top type, leaving only the desired type.
      %
4478: ConstCoerceType:
4480:    node_type nt = oTypeSNodeType
4485:    oTypeSPop
4486:    [ equal_node_type( nt, oTypeSNodeType )
4495:       | false :
               % Can we implicitly convert the value to the desired type?
4496:          [ oTypeSNodeType
4498:             | nIntegerType :
4499:                [ nt
4502:                   | nByteType :  >>
4504:                   | * :
4509:                ]
4509:             | nByteType :
4511:                [ nt
4514:                   | nIntegerType :  >>
4516:                   | * :
4521:                ]
4521:             | nPointerType :
4523:                [ nt
4526:                   | nUniversalPointerType :  >>
4528:                   | * :
4533:                ]
4533:             | nUniversalPointerType :
4535:                [ nt
4538:                   | nPointerType :  >>
4540:                   | * :
4545:                ]
4545:             | nStrLitType :
4547:                [ nt
4550:                   | nCharType :
4551:                      oValueCharToString
4552:                      >>
4553:                   | * :
4558:                ]
4558:             | nShortStringType :
4560:                [ nt
4563:                   | nStrLitType :  >>
4565:                   | nCharType :
4567:                      oValueCharToString
4568:                      >>
4569:                   | * :
4576:                ]
4576:             | * :
4591:          ]
4591:          #eTypeMismatch
4593:       | * :
4598:    ];
      
      
      % The value stack contains two const values, and their two types are on the type stack.
      % Typically these are two arguments of an operator; the key is that botrh types are flexible.
      % Coerce one type to match the other.  Generally the smaller type is coerced to the larger.
      % Leave both values on the value stack, and the single common type on the type stack.
      %
4599: ConstCoerceTypePair:
         % TO DO.  For now, require the types to match
4601:    @ConstMatchTypes
4604:    ;
      
      
      % Given a constant value on the value stack, its type on the type stack,
      % and the desired type under it on the type stack.
      % Perform any necessary conversions so the value is cast to the desired type.
      % Pop the top type, leaving only the desired type.
      %
      % This is stronger than ConstCoerceType, since it isn't limited to implicit conversions.
      % There are still going to be limits on what is allowed though.
      %
4604: ConstCastType:
4606:    node_type nt = oTypeSNodeType
4611:    oTypeSPop
4612:    [ equal_node_type( nt, oTypeSNodeType )
4621:       | false :
               % Can we cast the value to the desired type?
4622:          [ oTypeSNodeType
4624:             | nIntegerType, nEnumType :
4625:                [ nt
4628:                   | nByteType, nCharType, nBooleanType :  >>
4630:                   | nIntegerType, nEnumType :  >>
                        % fpc does not allow explicit cast of double to integer.
                        % User must call trunc() / round().
4633:                   | * :
4646:                ]
4646:             | nByteType, nCharType, nBooleanType :
4648:                [ nt
4651:                   | nByteType, nCharType, nBooleanType :  >>
4653:                   | nIntegerType, nEnumType :  >>
4656:                   | * :
4669:                ]
4669:             | nDoubleType :
4671:                [ nt
4674:                   | nByteType, nCharType, nBooleanType, nIntegerType, nEnumType :
4675:                      oValueIntToDouble
4676:                      >>
4677:                   | nDoubleType :  >>
4680:                   | * :
4695:                ]
4695:             | nPointerType :
4697:                [ nt
4700:                   | nUniversalPointerType :  >>
4702:                   | * :
4707:                ]
4707:             | nUniversalPointerType :
4709:                [ nt
4712:                   | nPointerType :  >>
4714:                   | * :
4719:                ]
4719:             | nStrLitType :
4721:                [ nt
4724:                   | nCharType :
4725:                      oValueCharToString
4726:                      >>
4727:                   | * :
4732:                ]
4732:             | nShortStringType :
4734:                [ nt
4737:                   | nStrLitType :  >>
4739:                   | nCharType :
4741:                      oValueCharToString
4742:                      >>
4743:                   | * :
4750:                ]
4750:             | * :
4773:          ]
4773:          #eTypeMismatch
4775:       | * :
4780:    ];
      
      
      % These are the methods that Pascal allows in a constant expression:
      %   Abs( x: integer_or_real ) : integer_or_real
      %   Round( x: real ) : integer
      %   Trunc( x: real ) : integer
      %   Chr( x: integer ) : char
      %   Ord( x: ordinal ) : integer
      %   Length( s: string ) : integer
      %   Pred( x: ordinal ) : ordinal
      %   Succ( x: ordinal ) : ordinal
      %   SizeOf( var, expr, or typename ) : integer
      %   Odd( x: integer ) : boolean  - true if the argument is odd
      %
4781: ConstBuiltInFunc( Node method ):
      
         % Ord(x)
4783:    [ oNodeEqual( method, BuiltIn_Ord )
4793:       | true :
4794:          '('
4796:          @ConstExpr
4798:          ')'
4800:          [ oTypeSNodeType
4802:             | nIntegerType, nEnumType :
4803:             | nBooleanType, nByteType, nCharType :
4805:             | * :  #eTypeMismatch
4820:          ]
4820:          oTypeSPop
4821:          oTypeSPush( IntegerType )
4827:          ')'
4829:          >>
4830:       | * :
4835:    ]
      
         % Chr(x)
4835:    [ oNodeEqual( method, BuiltIn_Chr )
4845:       | true :
4846:          '('
4848:          @ConstExpr
4850:          ')'
4852:          [ oTypeSNodeType
4854:             | nIntegerType :
4855:             | nByteType :
4857:             | * :  #eTypeMismatch
4866:          ]
4866:          oTypeSPop
4867:          oTypeSPush( CharType )
4873:          ')'
4875:          >>
4876:       | * :
4881:    ]
      
         % Pred(x)
4881:    [ oNodeEqual( method, BuiltIn_Pred )
4891:       | true :
4892:          '('
4894:          @ConstExpr
4896:          [ oTypeSNodeType
4898:             | nEnumType :
4899:                [ oNodeGetBoolean( oTypeSTop, qHasGap )
4908:                   | true :   #eCantUsePredSuccOnEnumWithValueGaps
4911:                   | * :
4916:                ]
4916:             | * :  #eTypeMismatch
4923:          ]
4923:          oValuePush( 1 )  oValueSub
4930:          ')'
4932:          >>
4933:       | * :
4938:    ]
      
         % Succ(x)
4938:    [ oNodeEqual( method, BuiltIn_Succ )
4948:       | true :
4949:          '('
4951:          @ConstExpr
4953:          [ oTypeSNodeType
4955:             | nEnumType :
4956:                [ oNodeGetBoolean( oTypeSTop, qHasGap )
4965:                   | true :   #eCantUsePredSuccOnEnumWithValueGaps
4968:                   | * :
4973:                ]
4973:             | * :  #eTypeMismatch
4980:          ]
4980:          oValuePush( 1 )  oValueAdd
4987:          ')'
4989:          >>
4990:       | * :
4995:    ]
      
         % Sizeof(x)
4995:    [ oNodeEqual( method, BuiltIn_Sizeof )
5005:       | true :
5006:          '('
               % Parse expression but only for its type.
               % And, allow use of typename as a primary in the expression.
5008:          @ConstExprAllowTypeName
5010:          oValuePop
5011:          Node theType = oTypeSTop
5016:          oTypeSPop
5017:          oValuePush( oNodeGetInt( theType, qSize ) )
5030:          oTypeSPush( IntegerType )
5036:          ')'
5038:          >>
5039:       | * :
5044:    ]
      
5044:    #eNotImplemented
5047:    ;
      
      
5047: include 'pascal_expr.ssl'
      %
      % Pascal Compiler
      %
      
      
      % ------------------------------ Expressions -----------------------------
      
      
      % There are two wrappers leading into expression parsing:
      %   Expr()
      %   BooleanExprControlFlow( out Label falseLabel )
      %
      % Expr always produces a value on the runtime expr stack,
      % and pushes its type on the type stack.
      %
      % BooleanExprControlFlow always generates control-flow code.
      % It does not push a value on the runtime expr stack.
      % It does not push a type on the type stack.
      % The control flow code ends up at Here if the expr is true,
      % and jumps to falseLabel if the expr is false.
      % This rule allocates falseLabel, and passes it back.
      % The caller will need to define its location.
      %
      % The internal methods of expr parsing may produce a mix of
      % values and control flow, depending on the operators seen.
      % We don't always do one or the other, hoping to be efficient for
      % cases like   "func_call( bool_var1, bool_var2 )"
      % as well as  "if bool_expr1 or bool_expr2 then ...".
      % If a subexpression rule produces control flow, it will allocate a
      % falseLabel and pass it back up.  And it will push the
      % result type as BooleanFlowType, to distinguish from BooleanType
      % which corresponds with a boolean value on the expr stack.
      % 
      % Note that my expression parsing is broken into more levels than
      % grammars describe for Pascal precedence levels.  This follows my
      % original parser implementation.  I think my rationale was that
      % operators from the levels that I split up couldn't have been
      % mixed anyway, since they require different data types
      % (e.g. boolean vs int/real).  And splitting them up simplified
      % my code.  But, I should revisit this.
      %
      
      
      % Public entry point:
      %
      % Parse an expression, leaving a value on the runtime expr stack
      % and its type on the type stack.
      %
      % This rule does not export control flow (though it may generate
      % control flow internally for subexpressions).
      %
5047: Expr:
5049:    Label falseLabel = labelNull
      
5055:    @ExprAllowFlow( falseLabel )
5062:    @FlowToVal( falseLabel );
      
      
      % Public entry point:
      %
      % Parse an expression, just like Expr,
      % but also allows type names as Primary elements of the expression.
      % This is for use by sizeof().
      % The value produced by that primary is bogus, but this is ok because the
      % caller (sizeof) is going to discard all generated code for the expression.
      % It's only interested in the type produced by the expression.
      %
5070: ExprAllowTypeName:
5072:    boolean oldAllowTypeName = flagExprAllowTypeName
5078:    flagExprAllowTypeName = true
5084:    @Expr
5086:    flagExprAllowTypeName = oldAllowTypeName
5093:    ;
      
      
      % Public entry point:
      %
      % Parse a Boolean expression, producing control flow code rather than a value.
      % Does not leave a value on the runtime expr stack.
      % Does not leave a type on the type stack.
      %
      % If the expression is true, the code will fall through to the end (Here).
      % If the expression is false, the code will jump to the given falseLabel,
      % which this rule will allocate but not define the location for.
      % The caller must do so.
      %
5093: BooleanExprControlFlow( out Label falseLabel ):
5095:    @ExprAllowFlow( falseLabel )
5102:    [ oTypeSNodeType
5104:       | nBooleanFlowType :
5105:       | nBooleanType :
               % convert value to control flow
5107:          falseLabel = oLabelNew
5112:          .tJumpFalse  oEmitLabel( falseLabel )
5120:       | * :
5127:          #eNotBoolean
5129:    ]
5129:    oTypeSPop;
      
      
      % If the current expr result is control flow, convert it to a value.
      % falseLabel is the label that had been used by the control flow.
      % On return it will be set to labelNull.
      %
5131: FlowToVal( inout Label falseLabel ):
5133:    [ oTypeSNodeType
5135:       | nBooleanFlowType :
5136:          Label doneLabel = oLabelNew
5141:          .tPushConstI  oEmitInt( 1 )
5149:          .tJump  oEmitLabel( doneLabel )
5157:          .tLabel  oEmitLabel( falseLabel )
5165:          .tPushConstI  oEmitInt( 0 )
5173:          .tLabel  oEmitLabel( doneLabel )
5181:          oTypeSPop
5182:          oTypeSPush( BooleanType )
5188:          falseLabel = labelNull
5194:       | * :
5199:    ];
      
      
      % If the current expr result is boolean value, convert it to control flow.
      % falseLabel will be allocated by this rule and passed back.
      % The caller must define its location.
      %
5200: ValToFlow( out Label falseLabel ):
5202:    [ oTypeSNodeType
5204:       | nBooleanType :
5205:          falseLabel = oLabelNew
5210:          .tJumpFalse  oEmitLabel( falseLabel )
5218:          oTypeSPop
5219:          oTypeSPush( BooleanFlowType )
5225:       | * :
5230:    ];
      
      
      % Parse an expression.  It may produce a value on the expr stack,
      % or control flow, depending on what's seen in the expression.
      % Leaves the expression type on the type stack.
      %
      % If the expression produces control flow, the expression type will be
      % nBooleanFlowType.  In this case, a true value falls through to Here,
      % and a false value jumps to falseLabel.  This rule will allocate falseLabel
      % and return it, but will not define its location; the caller must do so.
      %
      % If the expression produces a value, the value will be left on the
      % expression stack, and the type will be some type other than nBooleanFlowType.
      % In this case, falseLabel is ignored.
      %
5231: ExprAllowFlow( out Label falseLabel ):
5233:    @BoolExprAllowFlow( falseLabel )
5240:    {[
5240:       | '=' :
5242:          @FlowToVal( falseLabel )
5249:          @PromoteToIntOptional
5251:          @BoolExprAllowFlow( falseLabel )
5258:          @FlowToVal( falseLabel )
5265:          @PromoteToIntOptional
5267:          @CoerceTypePair
5269:          [ oTypeSNodeType
5271:             | nBooleanType, nCharType :     .tEqualB
5274:             | nIntegerType, nEnumType :     .tEqualI
5278:             | nDoubleType :                 .tEqualD
5282:             | nPointerType, nUniversalPointerType :    .tEqualP
5286:             | nShortStringType, nStrLitType :
5288:                @ShortStringCmp  .tPushConstI  oEmitInt( 0 )  .tEqualI
5300:             | * :                           #eNotAllowed
5323:          ]
5323:          oTypeSPop
5324:          oTypeSPush( BooleanType )
      
5330:       | '<>' :
5332:          @FlowToVal( falseLabel )
5339:          @PromoteToIntOptional
5341:          @BoolExprAllowFlow( falseLabel )
5348:          @FlowToVal( falseLabel )
5355:          @PromoteToIntOptional
5357:          @CoerceTypePair
5359:          [ oTypeSNodeType
5361:             | nBooleanType, nCharType :     .tNotEqualB
5364:             | nIntegerType, nEnumType :     .tNotEqualI
5368:             | nDoubleType :                 .tNotEqualD
5372:             | nPointerType, nUniversalPointerType :    .tNotEqualP
5376:             | nShortStringType, nStrLitType :
5378:                @ShortStringCmp  .tPushConstI  oEmitInt( 0 )  .tNotEqualI
5390:             | * :                           #eNotAllowed
5413:          ]
5413:          oTypeSPop
5414:          oTypeSPush( BooleanType )
      
5420:       | '<' :
5422:          @FlowToVal( falseLabel )
5429:          @PromoteToIntOptional
5431:          @BoolExprAllowFlow( falseLabel )
5438:          @FlowToVal( falseLabel )
5445:          @PromoteToIntOptional
5447:          @CoerceTypePair
5449:          [ oTypeSNodeType
5451:             | nBooleanType, nCharType :     .tLessB
5454:             | nIntegerType, nEnumType :     .tLessI
5458:             | nDoubleType :                 .tLessD
5462:             | nPointerType, nUniversalPointerType :   .tLessP
5466:             | nShortStringType, nStrLitType :
5468:                @ShortStringCmp  .tPushConstI  oEmitInt( 0 )  .tLessI
5480:             | * :                           #eNotAllowed
5503:          ]
5503:          oTypeSPop
5504:          oTypeSPush( BooleanType )
      
5510:       | '>' :
5512:          @FlowToVal( falseLabel )
5519:          @PromoteToIntOptional
5521:          @BoolExprAllowFlow( falseLabel )
5528:          @FlowToVal( falseLabel )
5535:          @PromoteToIntOptional
5537:          @CoerceTypePair
5539:          [ oTypeSNodeType
5541:             | nBooleanType, nCharType :     .tGreaterB
5544:             | nIntegerType, nEnumType :     .tGreaterI
5548:             | nDoubleType :                 .tGreaterD
5552:             | nPointerType, nUniversalPointerType :   .tGreaterP
5556:             | nShortStringType, nStrLitType :
5558:                @ShortStringCmp  .tPushConstI  oEmitInt( 0 )  .tGreaterI
5570:             | * :                           #eNotAllowed
5593:          ]
5593:          oTypeSPop
5594:          oTypeSPush( BooleanType )
      
5600:       | '<=' :
5602:          @FlowToVal( falseLabel )
5609:          @PromoteToIntOptional
5611:          @BoolExprAllowFlow( falseLabel )
5618:          @FlowToVal( falseLabel )
5625:          @PromoteToIntOptional
5627:          @CoerceTypePair
5629:          [ oTypeSNodeType
5631:             | nBooleanType, nCharType :     .tLessEqualB
5634:             | nIntegerType, nEnumType :     .tLessEqualI
5638:             | nDoubleType :                 .tLessEqualD
5642:             | nPointerType, nUniversalPointerType :   .tLessEqualP
5646:             | nShortStringType, nStrLitType :
5648:                @ShortStringCmp  .tPushConstI  oEmitInt( 0 )  .tLessEqualI
5660:             | * :                           #eNotAllowed
5683:          ]
5683:          oTypeSPop
5684:          oTypeSPush( BooleanType )
      
5690:       | '>=' :
5692:          @FlowToVal( falseLabel )
5699:          @PromoteToIntOptional
5701:          @BoolExprAllowFlow( falseLabel )
5708:          @FlowToVal( falseLabel )
5715:          @PromoteToIntOptional
5717:          @CoerceTypePair
5719:          [ oTypeSNodeType
5721:             | nBooleanType, nCharType :     .tGreaterEqualB
5724:             | nIntegerType, nEnumType :     .tGreaterEqualI
5728:             | nDoubleType :                 .tGreaterEqualD
5732:             | nPointerType, nUniversalPointerType :   .tGreaterEqualP
5736:             | nShortStringType, nStrLitType :
5738:                @ShortStringCmp  .tPushConstI  oEmitInt( 0 )  .tGreaterEqualI
5750:             | * :                           #eNotAllowed
5773:          ]
5773:          oTypeSPop
5774:          oTypeSPush( BooleanType )
      
5780:       | * :
5795:          >
5797:    ]};
      
      
5800: BoolExprAllowFlow( out Label falseLabel ):
5802:    Label trueLabel = labelNull
      
5808:    @BoolTermAllowFlow( falseLabel )
5815:    {[
5815:       | pOr :
5817:          [ oTypeSNodeType
5819:             | nBooleanFlowType :
                     % We are true here. Jump ahead to done
5820:                [ equal_label( trueLabel, labelNull )
5830:                   | true :  trueLabel = oLabelNew
5836:                   | * :
5841:                ]
5841:                .tJump  oEmitLabel( trueLabel )
5849:             | nBooleanType :
5851:                @ValToFlow( falseLabel )
                     % We are true here. Jump ahead to done
5858:                [ equal_label( trueLabel, labelNull )
5868:                   | true :  trueLabel = oLabelNew
5874:                   | * :
5879:                ]
5879:                .tJump  oEmitLabel( trueLabel )
5887:             | * : #eNotBoolean
5896:          ]
5896:          oTypeSPop
      
               % false in previous term will jump here, to try this alternative term
5897:          .tLabel  oEmitLabel( falseLabel )
      
               % we'll get a new falseLabel for this term
5905:          falseLabel = labelNull
5911:          @BoolTermAllowFlow( falseLabel )
      
5918:          [ oTypeSNodeType
5920:             | nBooleanFlowType :
5921:             | nBooleanType :
5923:                @ValToFlow( falseLabel )
5930:             | * : #eNotBoolean
5939:          ]
      
5939:          oTypeSPop
5940:          oTypeSPush( BooleanFlowType )
      
5946:       | * :
5951:          >
5953:    ]}
      
         % any short-circuit trues jump here to the end
5955:    [ equal_label( trueLabel, labelNull )
5965:       | false :
5966:          .tLabel  oEmitLabel( trueLabel )
5974:       | * :
5979:    ]
5980:    ;
      
      
5980: BoolTermAllowFlow( out Label falseLabel ):
5982:    Label overallFalseLabel = labelNull
      
5988:    @BoolFactorAllowFlow( falseLabel )
5995:    {[
5995:       | pAnd :
5997:          [ oTypeSNodeType
5999:             | nBooleanFlowType :
6000:             | nBooleanType :
6002:                @ValToFlow( falseLabel )
6009:             | * :
6016:                #eNotBoolean
6018:          ]
6018:          oTypeSPop
      
               % We're going to have a different falseLabel for each term,
               % because we let each rule allocate its own (rather than accepting labels passed in).
               % And in this case we want them all to go to the same place,
               % to be determined by the caller.
               %
               % I'll allow for label aliases.  This will be more optimal than generating
               % multiple private false-handling code segments, that the true path would have to
               % jump around.  That would be hard to eliminate afterwards.
      
6019:          [ equal_label( overallFalseLabel, labelNull )
6029:             | true :
6030:                overallFalseLabel = oLabelNew
6035:                .tLabelAlias  oEmitLabel( falseLabel )  oEmitLabel( overallFalseLabel )
6049:                falseLabel = overallFalseLabel
6055:             | * :
6060:          ]
      
6060:          Label factorFalseLabel = labelNull
6066:          @BoolFactorAllowFlow( factorFalseLabel )
      
6073:          [ oTypeSNodeType
6075:             | nBooleanFlowType :
6076:             | nBooleanType :
6078:                @ValToFlow( factorFalseLabel )
6085:             | * : #eNotBoolean
6094:          ]
6094:         .tLabelAlias  oEmitLabel( factorFalseLabel )  oEmitLabel( overallFalseLabel )
      
6108:       | * :
6113:          >
6115:    ]};
      
      
6118: BoolFactorAllowFlow( out Label falseLabel ):
6120:    [
6120:       | pNot :
6122:          Label factorFalseLabel = labelNull
      
6128:          @BoolFactorAllowFlow( factorFalseLabel )
6135:          [ oTypeSNodeType
6137:             | nBooleanFlowType :
                     % We have control flow, and are sitting at the point that has value false.
6138:                falseLabel = oLabelNew
6143:                .tJump  oEmitLabel( falseLabel )
                     % The true path jumps here
6151:                .tLabel  oEmitLabel( factorFalseLabel )
      
6159:             | nBooleanType :
                     % I have a value.  I'll leave it as a value, rather than create control flow.
                     % See how this goes.
6161:                .tNot
      
6163:             | * : #eNotBoolean
6172:          ]
      
6172:       | * :
6177:          @ArithExprAllowFlow( falseLabel )
6184:    ];
      
      
6185: ArithExprAllowFlow( out Label falseLabel ):
6187:    boolean first = true
6193:    int tempStrOffset
      
6193:    @TermAllowFlow( falseLabel )
6200:    {[
6200:       | '+' :
6202:          [ oTypeSNodeType
6204:             | nIntegerType, nByteType :
6205:                @PromoteToIntPop
6207:                @TermAllowFlow( falseLabel )  % actually not allowing CF, will be caught by type check
      
6214:                [ oTypeSNodeType
6216:                   | nPointerType, nUniversalPointerType :
                           % int + ptr
6217:                      .tSwap
                           % leave only the ptr type on the type stack (int was already popped above)
6219:                      @PointerAddition
6221:                   | nDoubleType :
                           % int + double
                           % int type was already popped above; leave double on type stack
6223:                      .tSwap
6225:                      .tCastItoD
6227:                      .tAddD
6229:                   | * :
6238:                      @PromoteToInt
6240:                      .tAddI
6242:                ]
      
6242:             | nDoubleType :
6244:                @TermAllowFlow( falseLabel )
6251:                @PromoteToDoublePop
6253:                .tAddD
      
6255:             | nShortStringType, nStrLitType, nCharType :
                     % String concatenation
6257:                [ first
6260:                   | true :  % move into a temp string, so subsequent term(s) can further modify it.
6261:                             tempStrOffset = @MoveIntoTempShortString
6267:                             first = false
6273:                   | * :
6278:                ]
6278:                @TermAllowFlow( falseLabel )  % actually not allowing CF, will be caught by type check
6285:                [ oTypeSNodeType
6287:                   | nShortStringType, nStrLitType :
6288:                      @ShortStringAppendShortString
                           % Have to re-push the temp string.
                           % If we ever have .tDup then the append method could do it and we wouldn't need this
6290:                      .tPushAddrLocal  oEmitInt( tempStrOffset )
6298:                      oTypeSPush( ShortStringType )
6304:                   | nCharType :
6306:                      @ShortStringAppendChar
                           % Have to re-push the temp string.
                           % If we ever have .tDup then the append method could do it and we wouldn't need this
6308:                      .tPushAddrLocal  oEmitInt( tempStrOffset )
6316:                      oTypeSPush( ShortStringType )
6322:                   | * :
6331:                      #eTypeMismatch
6333:                      oTypeSPop
6334:                ]
      
6334:             | nPointerType, nUniversalPointerType :
6336:                @TermAllowFlow( falseLabel )   % actually not allowing CF
6343:                @PromoteToIntPop
6345:                @PointerAddition
      
6347:             | * :
6366:                #eNotAllowed
6368:          ]
      
6368:       | '-' :
6370:          [ oTypeSNodeType
6372:             | nIntegerType, nByteType :
6373:                @PromoteToIntPop
6375:                @TermAllowFlow( falseLabel )
      
6382:                [ oTypeSNodeType
6384:                   | nDoubleType :
                           % int - double
                           % int type was already popped above; leave double on type stack
6385:                      .tSwap
6387:                      .tCastItoD
6389:                      .tSwap
6391:                      .tSubD
6393:                   | * :
6398:                      @PromoteToInt
6400:                      .tSubI
6402:                ]
      
6402:             | nDoubleType :
6404:                @TermAllowFlow( falseLabel )
6411:                @PromoteToDoublePop
6413:                .tSubD
      
6415:             | nPointerType, nUniversalPointerType :
6417:                @TermAllowFlow( falseLabel )
6424:                [ oTypeSNodeType
6426:                   | nIntegerType, nByteType :
6427:                      @PromoteToIntPop
6429:                      @PointerSubInt
6431:                   | nPointerType, nUniversalPointerType :
6433:                      @MatchTypes
6435:                      @PointerSubPointer
6437:                   | * :
6448:                      #eNotAllowed
6450:                ]
      
6450:             | * :  #eNotAllowed
      
6465:          ]
6465:       | * :
6472:          >
6474:    ]};
      
      
6477: TermAllowFlow( out Label falseLabel ):
6479:    @FactorAllowFlow( falseLabel )
6486:    {[
6486:       | '*' :
6488:          [ oTypeSNodeType
6490:             | nIntegerType, nByteType :
6491:                @PromoteToIntPop
6493:                @FactorAllowFlow( falseLabel )  % actually not allowing CF, will be caught by type check
      
6500:                [ oTypeSNodeType
6502:                   | nDoubleType :
                           % int * double
                           % int type was already popped above; leave double on type stack
6503:                      .tSwap
6505:                      .tCastItoD
6507:                      .tMultD
6509:                   | * :
6514:                      @PromoteToInt
6516:                      .tMultI
6518:                ]
      
6518:             | nDoubleType :
6520:                @FactorAllowFlow( falseLabel )
6527:                @PromoteToDoublePop
6529:                .tMultD
      
6531:             | * :
6540:                #eNotAllowed
6542:          ]
      
6542:       | '/' :
6544:          [ oTypeSNodeType
6546:             | nIntegerType, nByteType :
6547:                @PromoteToIntPop
6549:                @FactorAllowFlow( falseLabel )
6556:                [ oTypeSNodeType
6558:                   | nDoubleType :
                           % int / double
                           % int type was already popped above; leave double on type stack
6559:                      .tSwap
6561:                      .tCastItoD
6563:                      .tSwap
6565:                      .tDivD
6567:                   | * :
6572:                      @PromoteToInt
6574:                      .tDivI
6576:                ]
      
6576:             | nDoubleType :
6578:                @FactorAllowFlow( falseLabel )
6585:                @PromoteToDoublePop
6587:                .tDivD
      
6589:             | * :
6598:                #eNotAllowed
6600:          ]
      
6600:       | * :
6607:          >
6609:    ]};
      
      
6612: FactorAllowFlow( out Label falseLabel ):
6614:    [
6614:       | '+' :
6616:          @PrimaryAllowFlow( falseLabel )  % actually not allowing CF, will be caught by type check
6623:          [ oTypeSNodeType
6625:             | nIntegerType, nByteType :
6626:             | nDoubleType :
6628:             | * :
6637:                #eNotAllowed
6639:          ]
6639:       | '-' :
6641:          @PrimaryAllowFlow( falseLabel )
6648:          [ oTypeSNodeType
6650:             | nIntegerType, nByteType :
                     % It's probably fair to promote byte to int, since byte is unsigned
6651:                @PromoteToInt
6653:                .tNegI
6655:             | nDoubleType :
6657:                .tNegD
6659:             | * :
6668:                #eNotAllowed
6670:          ]
6670:       | * :
6677:          @PrimaryAllowFlow( falseLabel )
6684:    ];
      
      
6685: PrimaryAllowFlow( out Label falseLabel ):
6687:    [
6687:       | pIntLit :
6689:          .tPushConstI  oEmitInt( TOKEN_VALUE )
6696:          oTypeSPush( IntegerType )
      
6702:       | pCharLit :
6704:          .tPushConstI  oEmitInt( TOKEN_VALUE )
6711:          oTypeSPush( CharType )
      
6717:       | pDoubleLit :
6719:          .tPushConstD  oEmitDouble( TOKEN_VALUE_DOUBLE )
6726:          oTypeSPush( DoubleType )
      
6732:       | '(' :
6734:          @ExprAllowFlow( falseLabel )
6741:          ')'
      
6743:       | pStrLit :
6745:          int addr = oStringAllocShortStringLit( CURRENT_STRLIT )     % store in global data
6754:          .tPushAddrGlobal oEmitInt( addr )
               % TO DO: consider defining a ShortString type with the exact capacity used.
               % But, I don't think it should matter here, since nobody should be assigning to this string.
6762:          oTypeSPush( StrLitType )
               % This seems unlikely, but the strlit may be followed by
               % array indexing.  Handle this the same way we would with a variable expression (see VarExpr)
               % First, advance the pointer by index if any
6768:          @LValueIndexes
               % get final value of dereferencing, if any
6770:          @FetchVar
      
6772:       | pIdent :
6774:          Node decl = oScopeFindRequire
6779:          @ResolveUnitRef( decl )
6786:          Node theType
      
6786:          [ oNodeType( decl )
6793:             | nFunc :
6794:                @Call( decl )
      
6801:             | nBuiltInFunc :
6803:                @CallBuiltInFunc( decl )
      
6810:             | nConst, nEnumValue :
6812:                theType = oNodeGet( decl, qType )
6825:                oTypeSPush( theType )
6831:                [ oTypeSNodeType
6833:                   | nIntegerType, nEnumType, nBooleanType, nCharType, nByteType :
6834:                      .tPushConstI @EmitValue( decl )
6843:                   | nPointerType, nUniversalPointerType :
                           % We have one pointer const, Nil.  It's pushed as I.
                           % Sign-extending I to P won't hurt since it's 0.
6845:                      .tPushConstI @EmitValue( decl )
6854:                   | * :
6871:                      #eNotImplemented
6873:                ]
      
6873:             | nConstDouble :
6875:                theType = oNodeGet( decl, qType )
6888:                oTypeSPush( theType )
6894:                [ oTypeSNodeType
6896:                   | nDoubleType :
6897:                      .tPushConstD  oEmitDouble( oNodeGetDouble( decl, qValueDouble ) )
6912:                   | * :
6917:                      #eNotImplemented
6919:                ]
                     
6919:             | nConstStr :
                     % This is a non-typed const defined as a strlit.
                     % So far, the value is held in the compiler's symbol table.
                     % Referencing the constant in the code will work the same as directly giving a strlit.
                     % (See pStrLit above).  We store the strlit in global memory, and set expr type to StrLitType.
      
                     % Storage in global memory only happens the first time the const is referenced.
                     % The global offset is stored in qValue.
6921:                int addr = oNodeGetInt( decl, qValue )
6934:                [ equal_zero( addr )
6941:                   | true :
6942:                      addr = oStringAllocShortStringLit( oNodeGetString( decl, qValueStr ) )
6959:                      oNodeSetInt( decl, qValue, addr )
6971:                   | * :
6976:                ]
6976:                .tPushAddrGlobal oEmitInt( addr )
6984:                oTypeSPush( StrLitType )
                     % This seems unlikely, but the strlit may be followed by
                     % array indexing.  Handle this the same way we would with a variable expression (see VarExpr)
                     % First, advance the pointer by index if any
6990:                @LValueIndexes
                     % get final value of dereferencing, if any
6992:                @FetchVar
      
6994:             | nGlobalVar, nLocalVar, nParam, nTypedConst :
6996:                @VarExpr( decl )
      
7003:             | nTypeDecl :
                     % A type name.
                     % This is normally a type cast.
                     % Or, if Expr is running within sizeof(), we do also allow type names as primaries.
7005:                oTypeSPush( oNodeGet( decl, qType ) )
7018:                [
7018:                   | '(' : 
                           % Type cast
7020:                      @Expr
7022:                      ')'
7024:                      @CastType
      
                           % The expression can be further modified after the typecast.
                           % This is taken from VarExpr.  Try to consolidate.
      
7026:                      [ oTypeSNodeType
7028:                         | nPointerType, nUniversalPointerType :
7029:                            [
7029:                               | '^' :             % dereferenced
7031:                                  oTypeSPop
7032:                                  oTypeSPush( oNodeGet( theType, qBaseType ) )
7045:                                  @LValueIndexes
7047:                                  @FetchVar
7049:                               | '[' :             % dereferencing pointer like an array [0..] of baseType
7051:                                  @PointerArraySubscript
                                       % modify addr for any subsequent subscripts, field references, etc
7053:                                  @LValueIndexes
7055:                                  @FetchVar
7057:                               | * :               % just ptr value alone
7064:                            ]
      
7064:                         | nArrayType, nRecordType, nShortStringType :
                                 % So far we would have the addr of the compound value.
                                 % Modify addr for subscripts, field references, etc
7066:                            @LValueIndexes
                                 % get final value, if no longer compound
7068:                            @FetchVar
      
7070:                         | *:
7083:                      ]
      
7083:                   | * :
                           % Not a type cast
                           % A raw typename is only allowed in expressions within sizeof
7088:                      [ flagExprAllowTypeName
7091:                         | true :
                                 % The value we produce is bogus.  The caller will discard all code.
                                 % Only the type stack matters.
7092:                            .tPushConstI  oEmitInt( 0 )
7100:                         | * :    #eTypeNameNotAllowedHere
7107:                      ]
7107:                ]
      
7107:             | * :
7132:                #eNotValue
7134:                oTypeSPush( IntegerType )
7140:          ]
      
7140:       | '@' :        % @var -- pointer to var
7142:          pIdent
      
7144:          Node decl = oScopeFindRequire
7149:          @ResolveUnitRef( decl )
7156:          Node theType
      
               % writeable is false because we're not on the left hand side of an assignment,
               % or passing into a var parameter.  So it's ok to take the address of a typed const.
7156:          @LValueFromDecl( decl, false )
      
               % The above leaves the pointed-to type on type stack.
               % Replace with ptr-to-<type>.
7166:          theType = oTypeSTop
7171:          oTypeSPop
7172:          Node ptrType = @PointerTypeTo( theType )
7183:          oTypeSPush( ptrType )
      
7189:       | * :
7206:          #eNotValue
7208:          oTypeSPush( IntegerType )
7214:    ];
      
      
      % Parse a variable expression, given the declaration of the
      % just-accepted identifier.
      % Leaves the value on the expression stack, and type on the type stack.
      %
7215: VarExpr( Node decl ):
7217:    Node theType = oNodeGet( decl, qType )
         % how many levels up the static scope? Will ignore for globals.
7230:    int uplevels = @DeclUpLevels( decl )
      
7241:    oTypeSPush( theType )
7247:    [ oTypeSNodeType
7249:       | nIntegerType, nEnumType :
7250:          [ oNodeType( decl )
7257:             | nGlobalVar, nTypedConst :   .tPushGlobalI  @EmitValue( decl )
7267:             | nLocalVar :
7269:                [ equal_zero( uplevels )
7276:                   | true :  .tPushLocalI  @EmitValue( decl )
7286:                   | * :     .tPushUpLocalI  oEmitInt( uplevels )  @EmitValue( decl )
7306:                ]
7306:             | nParam :
7308:                [ oNodeGetBoolean( decl, qInOut )
7318:                   | true :    % VAR param points to the var.  Auto dereference.
7319:                      [ equal_zero( uplevels )
7326:                         | true :  .tPushParamP  @EmitValue( decl )
7336:                         | * :     .tPushUpParamP  oEmitInt( uplevels )  @EmitValue( decl )
7356:                      ]
7356:                      .tFetchI
7358:                   | * :
7363:                      [ equal_zero( uplevels )
7370:                         | true :  .tPushParamI  @EmitValue( decl )
7380:                         | * :     .tPushUpParamI  oEmitInt( uplevels )  @EmitValue( decl )
7400:                      ]
7400:                ]
7400:          ]
      
7412:       | nBooleanType, nByteType, nCharType :
7414:          [ oNodeType( decl )
7421:             | nGlobalVar, nTypedConst :   .tPushGlobalB  @EmitValue( decl )
7431:             | nLocalVar :
7433:                [ equal_zero( uplevels )
7440:                   | true :  .tPushLocalB  @EmitValue( decl )
7450:                   | * :     .tPushUpLocalB  oEmitInt( uplevels )  @EmitValue( decl )
7470:                ]
7470:             | nParam :
7472:                [ oNodeGetBoolean( decl, qInOut )
7482:                   | true :    % VAR param points to the var.  Auto dereference.
7483:                      [ equal_zero( uplevels )
7490:                         | true :  .tPushParamP  @EmitValue( decl )
7500:                         | * :     .tPushUpParamP  oEmitInt( uplevels )  @EmitValue( decl )
7520:                      ]
7520:                      .tFetchB
7522:                   | * :
7527:                      [ equal_zero( uplevels )
7534:                         | true :  .tPushParamB  @EmitValue( decl )
7544:                         | * :     .tPushUpParamB  oEmitInt( uplevels )  @EmitValue( decl )
7564:                      ]
7564:                ]
7564:          ]
      
7576:       | nFileType :
7578:          #eNotImplemented
      
7580:       | nPointerType, nUniversalPointerType, nDoubleType :
               % Note we're using this code for reading double vars too.
               % P is the correct size, and no differences are needed at the moment.
7582:          [ oNodeType( decl )
7589:             | nGlobalVar, nTypedConst :   .tPushGlobalP @EmitValue( decl )
7599:             | nLocalVar :
7601:                [ equal_zero( uplevels )
7608:                   | true :  .tPushLocalP  @EmitValue( decl )
7618:                   | * :     .tPushUpLocalP  oEmitInt( uplevels )  @EmitValue( decl )
7638:                ]
7638:             | nParam :
7640:                [ oNodeGetBoolean( decl, qInOut )
7650:                   | true :    % VAR param points to the var.  Auto dereference.
7651:                      [ equal_zero( uplevels )
7658:                         | true :  .tPushParamP  @EmitValue( decl )
7668:                         | * :     .tPushUpParamP  oEmitInt( uplevels )  @EmitValue( decl )
7688:                      ]
7688:                      .tFetchP
7690:                   | * :
7695:                      [ equal_zero( uplevels )
7702:                         | true :  .tPushParamP  @EmitValue( decl )
7712:                         | * :     .tPushUpParamP  oEmitInt( uplevels )  @EmitValue( decl )
7732:                      ]
7732:                ]               
7732:          ]
7744:          [
7744:             | '^' :             % dereferenced
7746:                oTypeSPop
7747:                oTypeSPush( oNodeGet( theType, qBaseType ) )
7760:                @LValueIndexes
7762:                @FetchVar
7764:             | '[' :             % dereferencing pointer like an array [0..] of baseType
7766:                @PointerArraySubscript
                     % modify addr for any subsequent subscripts, field references, etc
7768:                @LValueIndexes
7770:                @FetchVar
7772:             | * :               % just ptr value alone
7779:          ]
      
7779:       | nArrayType, nRecordType, nShortStringType :
               % compound type
               % first, push addr of start of var
7781:          [ oNodeType( decl )
7788:             | nGlobalVar, nTypedConst :   .tPushAddrGlobal @EmitValue( decl )
7798:             | nLocalVar :
7800:                [ equal_zero( uplevels )
7807:                   | true :  .tPushAddrLocal  @EmitValue( decl )
7817:                   | * :     .tPushAddrUpLocal  oEmitInt( uplevels )  @EmitValue( decl )
7837:                ]
7837:             | nParam :
7839:                [ oNodeGetBoolean( decl, qInOut )
7849:                   | true :    % VAR param points to the var.  Auto dereference.
7850:                      [ equal_zero( uplevels )
7857:                         | true :  .tPushParamP  @EmitValue( decl )
7867:                         | * :     .tPushUpParamP  oEmitInt( uplevels )  @EmitValue( decl )
7887:                      ]
7887:                   | * :
7892:                      [ equal_zero( uplevels )
7899:                         | true :  .tPushAddrParam  @EmitValue( decl )
7909:                         | * :     .tPushAddrUpParam  oEmitInt( uplevels )  @EmitValue( decl )
7929:                      ]
7929:                ]
7929:          ]
               % modify addr for subscripts, field references, etc
7941:          @LValueIndexes
               % get final value
7943:          @FetchVar
7945:    ];
      
      
      % Addr of start of var is on expr stack; type is on type stack.
      % Replace expr stack with value of var.
      % (In the case of compound vars, this remains as the addr of the var).
      
7974: FetchVar:
7976:    [ oTypeSNodeType
7978:       | nIntegerType, nEnumType :  .tFetchI
7981:       | nBooleanType, nByteType, nCharType :  .tFetchB
7985:       | nFileType :   #eNotImplemented
7989:       | nPointerType :             .tFetchP
7993:       | nUniversalPointerType :    #eCantDereference
7997:       | nArrayType, nRecordType, nStrLitType, nShortStringType :  % compound type; leave as addr
7999:    ];
      
      
      % Addr of start of var is already on run stack, and type is on type stack.
      % Read subscripts, record fields, etc, to get final addr on run stack, and final type
      % on type stack.
      
8028: LValueIndexes:
8030:    {[
8030:       | '[' :
8032:          [ oTypeSNodeType
8034:             | nArrayType :    @ArraySubscripts
8037:             | nPointerType :  @PointerArraySubscript
8041:             | nStrLitType, nShortStringType :  @ShortStringArraySubscript
8045:             | * :             #eNotArray
8058:          ]
8058:       | '.' :       @RecordFieldRef
8062:       | '^' :       @PointerDeref   % TO DO: I suspect I don't have logic right here
                                          % about precondition and using .tFetchP
                                          % Ideally this should take over for the ^ in VarExpr too.
8066:       | * :         >
8077:    ]};
      
      
8080: ArraySubscripts:
8082:    [ oTypeSNodeType
8084:       | nArrayType :
8085:       | * :       #eNotArray
8092:    ]
8092:    {
8092:       [ oTypeSNodeType
8094:          | nArrayType :
8095:          | * :    #eTooManySubscripts
8102:       ]
      
            % low subscript of this dimension
8102:       int low = @OrdinalLow( oNodeGet( oTypeSTop, qIndexType ) )
      
            % replace type stack with next dimension, or OF type
8119:       Node baseType
8119:       baseType = oNodeGet( oTypeSTop, qBaseType )
8131:       oTypeSPop
8132:       oTypeSPush( baseType )
      
8138:       @Expr
8140:       @RequireIntPop
            % adjust for low subscript
8142:       [ equal_zero( low )
8149:          | false :
8150:             .tPushConstI oEmitInt( low ) .tSubI
8160:          | * :
8165:       ]
      
            % multiply by element size
8165:       int size = oNodeGetInt( baseType, qSize )
8178:       [ equal( size, 1 )
8188:          | false :
8189:             .tPushConstI oEmitInt( size ) .tMultI
8199:          | * :
8204:       ]
      
            % update start address
8204:       .tAddPI
8206:       [
8206:          | ']' :  >
8210:          | ',' :
8212:       ]
8220:    };
      
      
      % pointer[index] - similar to array[index] where index counts from 0.
      % On entry, the pointer value is on the stack, and pointer type is on the type stack.
      % We've already accepted the '['.
      % On exit, the address of the pointed-to element is on the stack,
      % and the element type is on the type stack.
      %
8223: PointerArraySubscript:
8225:    [ oTypeSNodeType
8227:       | nPointerType :
8228:       | * :    #eCantDereference
8235:    ]
         % replace type stack with base type
8235:    Node baseType = oNodeGet( oTypeSTop, qBaseType )
8247:    oTypeSPop
8248:    oTypeSPush( baseType )
         
8254:    @Expr
8256:    @RequireIntPop
         % multiply by element size
8258:    int size = oNodeGetInt( baseType, qSize )
8271:    [ equal( size, 1 )
8281:       | false :
8282:          .tPushConstI  oEmitInt( size )  .tMultI
8292:       | * :
8297:    ]
         % update start address
8297:    .tAddPI
8299:    ']';
      
      
      % Specialization of array indexing for ShortString.
      % We treat the starting index as 0 so that str[1] sees the first string char,
      % past the length byte.
      %
8302: ShortStringArraySubscript:
8304:    [ oTypeSNodeType
8306:       | nStrLitType, nShortStringType :
8307:       | * :    #eCantDereference
8316:    ]
8316:    oTypeSPop
8317:    oTypeSPush( CharType )
8323:    @Expr
8325:    @RequireIntPop
8327:    .tAddPI
8329:    ']';
      
      
8332: RecordFieldRef:
8334:    [ oTypeSNodeType
8336:       | nRecordType :
8337:       | * :    #eNotRecord
8344:    ]
8344:    oScopeEnter( oNodeGet( oTypeSTop, qScope ) )
8356:    pIdent
8358:    Node field = oScopeFindRequire
         % oScopeFind searches all open scopes, so make sure we found nRecordField
         % which could only be seen in the local scope we entered above.
8363:    [ oNodeType( field )
8370:       | nRecordField :
8371:       | * :   #eNotRecordField
8378:    ]
8378:    oScopeEnd
8379:    int offset = oNodeGetInt( field, qValue )
8392:    [ equal_zero( offset )
8399:       | false :
8400:          .tPushConstI oEmitInt( offset ) .tAddPI
8410:       | * :
8415:    ]
      
         % replace the type on the type stack, with the field type
8415:    oTypeSPop
8416:    oTypeSPush( oNodeGet( field, qType ) )
8430:    ;
      
      
      % On entry, expr stack has ptr, and integer index above it.
      % The type stack has just the pointer type.
      % Pop those, and push the ptr advanced to that index
      % (scaled by the pointed-to element size).
      % Leaves the pointer type on the type stack.
      %
8430: PointerAddition:
8432:    Node elementType = oNodeGet( oTypeSTop, qBaseType )
8444:    int elementSize = oNodeGetInt( elementType, qSize )
8457:    [ equal( elementSize, 1 )
8467:       | false :
8468:          .tPushConstI  oEmitInt( elementSize )
8476:          .tMultI
8478:       | * :
8483:    ]
8483:    .tAddPI
8486:    ;
      
      
      % On entry, expr stack has ptr, and integer above it.
      % The type stack has just the pointer type.
      % Pop those, and push the ptr decremented by that integer
      % (scaled by the pointed-to element size).
      % Leaves the pointer type on the type stack.
      %
8486: PointerSubInt:
8488:    Node elementType = oNodeGet( oTypeSTop, qBaseType )
8500:    int elementSize = oNodeGetInt( elementType, qSize )
8513:    [ equal( elementSize, 1 )
8523:       | false :
8524:          .tPushConstI  oEmitInt( elementSize )
8532:          .tMultI
8534:       | * :
8539:    ]
8539:    .tSubPI
8542:    ;
      
      
      % On entry, expr stack has two pointers, P1 and P2 above it.
      % The type stack has the type of P1.  (The type of P2 was already matched to P1.)
      % Replace the pointers on the expression stack with P1 - P2, scaled by the
      % pointed-to element size.  Type stack switched to integer.
      % 
8542: PointerSubPointer:
8544:    .tSubP
8546:    Node elementType = oNodeGet( oTypeSTop, qBaseType )
8558:    int elementSize = oNodeGetInt( elementType, qSize )
8571:    [ equal( elementSize, 1 )
8581:       | false :
8582:          .tPushConstI  oEmitInt( elementSize )
8590:          .tDivI
8592:       | * :
8597:    ]
8597:    oTypeSPop
8598:    oTypeSPush( IntegerType )
8605:    ;
      
      % ptr deref on left side, i.e. BEFORE addr of ptr var is on stack,
      %                              AFTER addr of thing pointed to is on stack
8605: PointerDeref:
8607:    [ oTypeSNodeType
8609:       | nPointerType :
8610:       | nUniversalPointerType :   #eCantDereference
8614:       | * :       #eNotPointer
8623:    ]
8623:    .tFetchP           % now addr on stack is addr of what we're pointing to
      
8625:    Node theType = oTypeSTop
8630:    oTypeSPop
8631:    oTypeSPush( oNodeGet( theType, qBaseType ) )
8645:    ;
      
      
      % The expr stack contains a value whose type is on top of the type stack.
      % Generate code to coerce the value to the type under it in the type stack
      % (pop the type stack, leaving only the desired type).
      % This is used for assignment.
      %
8645: CoerceType:
8647:    node_type nt = oTypeSNodeType
8652:    Node given = oTypeSTop
8657:    oTypeSPop
8658:    [ equal_node_type( nt, oTypeSNodeType )
8667:       | false :
               % Can we implicitly convert the value to the desired type?
8668:          [ oTypeSNodeType
8670:             | nIntegerType :
8671:                [ nt
8674:                   | nByteType :   .tCastBtoI  >>
8678:                   | * :
8683:                ]
8683:             | nByteType :
8685:                [ nt
8688:                   | nIntegerType :   .tCastItoB  >>
8692:                   | * :
8697:                ]
8697:             | nDoubleType :
8699:                [ nt
8702:                   | nIntegerType :   .tCastItoD  >>
8706:                   | * :
8711:                ]
8711:             | nPointerType :
8713:                [ nt
8716:                   | nUniversalPointerType :  >>
8718:                   | nStrLitType :
8720:                      [ equal_node( oTypeSTop, PCharType )
8729:                         | true :
                                 % PChar := 'strlit' i.e. point at strlit[1]
8730:                            .tPushConstI  oEmitInt(1)  .tAddPI  >>
8741:                         | * :
8746:                      ]
8746:                   | * :
8753:                ]
8753:             | nUniversalPointerType :
8755:                [ nt
8758:                   | nPointerType :  >>
8760:                   | * :
8765:                ]
8765:             | nShortStringType :
8767:                [ nt
8770:                   | nStrLitType :  >>
8772:                   | nCharType :
                           % Store char as a temp ShortString.
8774:                      oTypeSPush( CharType )
8780:                      int tempOffset = @MoveIntoTempShortString
8786:                      oTypeSPop
8787:                      >>
8788:                   | * :
8795:                ]
8795:             | * :
8810:          ]
8810:          #eTypeMismatch
8812:       | * :
8817:    ];
      
      
      % The expr stack contains two values, and their two types are on the type stack.
      % Typically these are two arguments of an operator; the key is that both types are flexible
      % (unlike CoerceType, where only the top type is flexible).
      % Coerce one type to match the other.  Generally the smaller type is coerced to the larger.  
      % Leave both values on the expr stack, and the single common type on the type stack. 
      %
8818: CoerceTypePair:
8820:    node_type right_nt = oTypeSNodeType
8825:    Node right = oTypeSTop
8830:    oTypeSPop
8831:    node_type left_nt = oTypeSNodeType
8836:    Node left = oTypeSTop
      
         % Start with assumption that we'll keep left type
8841:    [ equal_node_type( left_nt, right_nt )
8851:       | true :
               % TO DO: BUG: in some cases, need to validate base types match (e.g. enum types, ptr types)
8852:          >>
8853:       | * :
8858:    ]
8858:    [ left_nt
8861:       | nIntegerType :
8862:          [ right_nt
8865:             | nByteType :     .tCastBtoI  >>
8869:             | * :
8874:          ]
8874:       | nDoubleType :
8876:          [ right_nt
8879:             | nByteType :     .tCastBtoI  .tCastItoD  >>
8885:             | nIntegerType :  .tCastItoD  >>
8890:             | * :
8897:          ]
8897:       | nPointerType :
8899:          [ right_nt
8902:             | nUniversalPointerType :   >>
8904:             | * :
8909:          ]
8909:       | nShortStringType :
8911:          [ right_nt
8914:             | nStrLitType :  >>
8916:             | nCharType :
                     % Store char as a temp ShortString
8918:                oTypeSPush( CharType )
8924:                int tempOffset = @MoveIntoTempShortString
8930:                oTypeSPop
8931:                >>
8932:             | * :
8939:          ]
8939:       | * :
8950:    ]  
      
         % See if we can coerce left to right type.
         % If so remember we need to replace the type on the type stack.
8950:    [ right_nt
8953:       | nIntegerType :
8954:          [ left_nt
8957:             | nByteType :
8958:                .tSwap  .tCastBtoI  .tSwap
8964:                oTypeSPop  oTypeSPush( right )
8971:                >>
8972:             | * :
8977:          ]
8977:       | nDoubleType :
8979:          [ left_nt
8982:             | nByteType :
8983:                .tSwap  .tCastBtoI  .tCastItoD  .tSwap
8991:                oTypeSPop  oTypeSPush( right )
8998:                >>
8999:             | nIntegerType :
9001:                .tSwap  .tCastItoD  .tSwap
9007:                oTypeSPop  oTypeSPush( right )
9014:                >>
9015:             | * :
9022:          ]
9022:       | nPointerType :
9024:          [ left_nt
9027:             | nUniversalPointerType :
                     % TO DO: does fpc inherit right type here?
                     %  or stay with left.
9028:                oTypeSPop  oTypeSPush( right )
9035:                >>
9036:             | * :
9041:          ]
9041:       | nShortStringType :
9043:          [ left_nt
9046:             | nStrLitType :
9047:                oTypeSPop  oTypeSPush( right )
9054:                >>
9055:             | nCharType :
9057:                .tSwap
                     % Store char as a temp ShortString
9059:                oTypeSPush( CharType )
9065:                int tempOffset = @MoveIntoTempShortString
9071:                oTypeSPop
9072:                .tSwap
9074:                oTypeSPop  oTypeSPush( right )
9081:                >>
9082:             | * :
9089:          ]
9089:       | * :
9100:    ]
9100:    #eTypeMismatch
9103:    ;
      
      
      % The expr stack contains a value whose type is on top of the type stack.
      % Generate code to cast the value to the type under it in the type stack
      % (pop the type stack, leaving only the desired type).
      %
      % This is stronger than CoerceType, since it isn't limited to implicit conversions.
      % There are still going to be limits on what is allowed though.
      %
9103: CastType:
9105:    node_type nt = oTypeSNodeType
9110:    oTypeSPop
9111:    [ equal_node_type( nt, oTypeSNodeType )
9120:       | false :
               % Can we cast the value to the desired type?
9121:          [ oTypeSNodeType
9123:             | nIntegerType, nEnumType :
9124:                [ nt
9127:                   | nByteType, nCharType, nBooleanType :   .tCastBtoI  >>
9131:                   | nIntegerType, nEnumType :   >>
9134:                   | * :
9147:                ]
9147:             | nByteType, nCharType, nBooleanType :
9149:                [ nt
9152:                   | nByteType, nCharType, nBooleanType :   >>
9154:                   | nIntegerType, nEnumType :   .tCastItoB  >>
9159:                   | * :
9172:                ]
9172:             | nPointerType :
9174:                [ nt
9177:                   | nUniversalPointerType :  >>
9179:                   | nStrLitType :
9181:                      [ equal_node( oTypeSTop, PCharType )
9190:                         | true :
                                 % PChar := 'strlit' i.e. point at strlit[1]
9191:                            .tPushConstI  oEmitInt(1)  .tAddPI  >>
9202:                         | * :
9207:                      ]
9207:                   | * :
9214:                ]
9214:             | nUniversalPointerType :
9216:                [ nt
9219:                   | nPointerType :  >>
9221:                   | * :
9226:                ]
9226:             | nShortStringType :
9228:                [ nt
9231:                   | nStrLitType :  >>
9233:                   | nCharType :
                           % Store char as a temp ShortString.
9235:                      oTypeSPush( CharType )
9241:                      int tempOffset = @MoveIntoTempShortString
9247:                      oTypeSPop
9248:                      >>
9249:                   | * :
9256:                ]
9256:             | * :
9275:          ]
9275:          #eTypeMismatch
9277:       | * :
9282:    ];
      
      
      % Require that the top two types on the type stack are matching (ignoring subranges).
      % Pop one of them, leaving only one.
      %
      % This is used when passing a variable to a VAR parameter, so essentially no coercion
      % can be allowed.  The called method will interact with the actual variable using the
      % formal parameter type, so they must agree.
      %
      % TO DO: BUG: I'm not confirming that enum types are the same type!
      %     Only that they are both enums!
      %     Probably same flaw with record & array types.
      %     Not enough to compare only the node type.
      %
9283: MatchTypes:
9285:    node_type nt = oTypeSNodeType
9290:    oTypeSPop
9291:    [ equal_node_type( nt, oTypeSNodeType )
9300:       | false :
               % Some very minor implicit conversion is allowed even here,
               % but must not affect the value size.
9301:          [ oTypeSNodeType
9303:             | nPointerType :
9304:                [ nt
9307:                   | nUniversalPointerType :  >>
9309:                   | * :
9314:                ]
9314:             | nUniversalPointerType :
9316:                [ nt
9319:                   | nPointerType :  >>
9321:                   | * :
9326:                ]
9326:             | * :
9333:          ]
9333:          #eTypeMismatch
9335:       | * :
9340:    ];
      
      
      % Require that the top type on the type stack is integer (ignoring subranges).
      % Pop it.
      %
9341: RequireIntPop:
9343:    [ oTypeSNodeType
9345:       | nIntegerType :
9346:       | * :          #eNotInteger
9353:    ]
9353:    oTypeSPop;
      
9355: RequireInt:
9357:    [ oTypeSNodeType
9359:       | nIntegerType :
9360:       | * :          #eNotInteger
9367:    ];
      
      
      % Convert the top value to integer (if it isn't already).
      % It must be implicitly convertable to integer.
      % Pop the type stack.
      %
9368: PromoteToIntPop:
9370:    [ oTypeSNodeType
9372:       | nIntegerType :
9373:       | nByteType :        .tCastBtoI
9377:       | * :                #eNotInteger
9386:    ]
9386:    oTypeSPop;
      
      % Convert the top value to integer (if it isn't already).
      % It must be implicitly convertable to integer.
      % Leave integer on the type stack.
      %
9388: PromoteToInt:
9390:    [ oTypeSNodeType
9392:       | nIntegerType :
9393:       | nByteType :        .tCastBtoI
9397:                            oTypeSPop
9398:                            oTypeSPush( IntegerType )
9404:       | * :                #eNotInteger
9413:    ];
      
      
      % If the top value is implicitly convertable to integer, do so.
      % Otherwise leave it as-is.
      %
9414: PromoteToIntOptional:
9416:    [ oTypeSNodeType
9418:       | nByteType :        .tCastBtoI
9421:                            oTypeSPop
9422:                            oTypeSPush( IntegerType )
9428:       | * :
9433:    ];
      
      
      % Convert the top value to double (if it isn't already).
      % It must be implicitly convertable to double.
      % Pop the type stack.
      %
9434: PromoteToDoublePop:
9436:    [ oTypeSNodeType
9438:       | nDoubleType :
9439:       | nIntegerType :     .tCastItoD
9443:                            oTypeSPop
9444:                            oTypeSPush( DoubleType )
9450:       | nByteType :        .tCastBtoI
9454:                            .tCastItoD
9456:                            oTypeSPop
9457:                            oTypeSPush( DoubleType )
9463:       | * :                #eNotDouble
9474:    ]
9474:    oTypeSPop;
      
      
9476: RequireBoolPop:
9478:    [ oTypeSNodeType
9480:       | nBooleanType :
9481:       | * :          #eNotBoolean
9488:    ]
9488:    oTypeSPop;
      
9490: RequireBool:
9492:    [ oTypeSNodeType
9494:       | nBooleanType :
9495:       | * :          #eNotBoolean
9502:    ];
      
      
9503: include 'pascal_stmt.ssl'
      %
      % Pascal Compiler
      %
      
      
      % ------------------------------ Statements -----------------------------
      
9503: Statement:
9505:    [
9505:       | pWriteln :     @WritelnStmt
9509:       | pWrite :       @WriteStmt
9513:       | pReadln :      @ReadlnStmt
9517:       | pRead :        @ReadStmt
9521:       | pIf :          @IfStmt
9525:       | pWhile :       @WhileStmt
9529:       | pFor :         @ForStmt
9533:       | pRepeat :      @RepeatStmt
9537:       | pBreak :       @BreakStmt
9541:       | pContinue :    @ContinueStmt
9545:       | pBegin :       @BeginStmt
9549:       | pIdent :       @LabelOrAssignOrCallStmt
9553:       | pCase :        @CaseStmt
9557:       | pGoto :        @GotoStmt
9561:       | pIntLit :      % should be an integer label
9563:                        oChangeIntLitToLabelIdent
9564:                        @LabelOrAssignOrCallStmt
9566:       | * :            % null statement : don't accept any tokens
9599:    ];
      
      
9600: LabelOrAssignOrCallStmt:
9602:    Node decl = oScopeFindRequire
9607:    @ResolveUnitRef( decl )
9614:    [ oNodeType( decl )
9621:       | nLabel :                          @LabelDefinition( decl )
9629:                                           @Statement
9631:       | nProc :                           @Call( decl )
9640:       | nGlobalVar, nLocalVar, nParam, nTypeDecl :
9642:                                           @AssignStmt( decl )
9649:       | nFunc :                           @AssignResultStmt( decl )
9658:       | * :                               #eBadStatement
9677:    ];
      
      
      % Parse a "label:" prefix in front of a statement.
      %
9678: LabelDefinition( Node decl ):
9680:    [ oNodeGetBoolean( decl, qDefined )
9690:       | true :  #eAlreadyDefined
9693:       | * :
9698:    ]
9698:    .tLabel  oEmitLabel( oNodeGetLabel( decl, qValue ) )
9713:    oNodeSetBoolean( decl, qDefined, true )
9725:    ':'
9728:    ;
      
      
      % Given decl, the just-accepted first identifier on the left hand side.
      %
9728: AssignStmt( Node decl ):
9730:    @LValueFromDecl( decl, true )
9740:    ':=' 
9742:    @Expr
9744:    @CoerceType
9746:    @Assign
9749:    ;
      
      
      % Performs a raw assignment.
      % Given lvalue 2nd on stack, and expr value top of stack (already coerced to the lvalue type),
      % and type of both of these on the type stack,
      % perform the assignment and pop the type off the type stack.
      %
9749: Assign:
9751:    [ oTypeSNodeType
9753:       | nIntegerType, nEnumType :  .tAssignI
9756:       | nBooleanType, nByteType, nCharType :  .tAssignB
9760:       | nDoubleType :  .tAssignD
9764:       | nFileType :   #eNotImplemented
9768:       | nPointerType, nUniversalPointerType :  .tAssignP
            % compound var assigns; addrs of src, dest on stack
9772:       | nArrayType, nRecordType, nShortStringType :
                % TO DO: for ShortString, allow destination to be smaller capacity,
                % and truncate the copied value/length.
9774:           int size = oNodeGetInt( oTypeSTop, qSize )
9786:           .tCopy  oEmitInt( size )    % multi-word copy
9794:    ]
9822:    oTypeSPop
9824:    ;
      
      % Given nFunc for the just-accepted identifier on the left hand side.
      % Parse an assignment that represents assignment of the function result.
      %
9824: AssignResultStmt( Node funcDecl ):
         % Only allowed to assign the result of the immediately enclosing function, I think.
9826:    [ oNodeEqual( oNodeGet( funcDecl, qChildScope ), oScopeCurrent )
9842:       | false :   #eNotCurrentFunction
9845:       | * :
9850:    ]
      
         % Result value is stored in the caller's space, via a hidden VAR parameter.
9850:    .tPushParamP  oEmitInt( oNodeGetInt( funcDecl, qResultOffset ) )
9865:    oTypeSPush( oNodeGet( funcDecl, qType ) )
      
9878:    ':='
9880:    @Expr
9882:    @CoerceType
9884:    [ oTypeSNodeType
9886:       | nIntegerType, nEnumType : .tAssignI
9889:       | nBooleanType, nByteType, nCharType :  .tAssignB
9893:       | nDoubleType :  .tAssignD
9897:       | nFileType :   #eNotImplemented
9901:       | nPointerType, nUniversalPointerType :  .tAssignP
            % compound var assigns; addrs of src, dest on stack
9905:       | nArrayType, nRecordType, nShortStringType :
9907:           int size = oNodeGetInt( oTypeSTop, qSize )
9919:           .tCopy  oEmitInt( size )    % multi-word copy
9927:    ]
9955:    oTypeSPop
9957:    ;
      
      
      
      % Parse an lvalue expression, from scratch.
      % This is an expression that may appear on the left side of an assignment.
      % Leaves the address of the value on the expr stack,
      % and the type of the value at that address on the type stack.
      % If writeable is false, the expression won't be written to, so may access a
      % typed const.
      %
9957: LValueExpr( boolean writeable ):
         % Al lvalue expressions start with a variable name,
         % or a type name (for an lvalue typecast).
9959:    pIdent
9961:    Node decl = oScopeFindRequire
9966:    @ResolveUnitRef( decl )
9973:    @LValueFromDecl( decl, writeable )
9984:    ;
      
      
      % Parse an lvalue expression, starting with the decl of the just accepted identifier.
      % Leaves the address of the value on the expr stack,
      % and the type of the value at that address on the type stack.
      % If writeable is false, the expression won't be written to, so may access a
      % typed const.
      %
9984: LValueFromDecl( Node decl, boolean writeable ):
9986:    [ oNodeType( decl )
9993:       | nGlobalVar, nLocalVar, nParam, nTypedConst :
9994:          @LValueVar( decl, writeable )
      
10004:       | nTypeDecl :
               % lvalue typecast
               % This is only allowed if the provided lvalue we're casting from has the same size.
               % No conversion code occurs, it's just a different interpretation of the same bits.
10006:          oTypeSPush( oNodeGet( decl, qType ) )
10019:          '('
10021:          @LValueExpr( writeable )
10028:          ')'
10030:          @LValueCastType
               % There can be further modifications of the lvalue after the cast.
               % This is taken from LValueVar.  Try to consolidate.
10032:          [ oTypeSNodeType
10034:             | nPointerType :
10035:                [
10035:                   | '[' :
                           % dereference the pointer var first
10037:                      .tFetchP
10039:                      @PointerArraySubscript
10041:                   | * :
10046:                ]
10046:             | * :
10051:          ]
               % additional subscripts, if any
10051:          @LValueIndexes
       
10053:       | * :  #eNotVar
10068:    ]
10069:    ;
      
      
      % An lvalue is on the expression stack.
      % The type of the lvalue is on the type stack.
      % The desired type is under it on the type stack.
      % Perform an lvalue cast to the desired type, leaving just that type.
      %
      % An lvalue cast is allowed only if the data size is the same.
      % No conversion code occurs, it's just a different interpretation of the same bits.
      %
10069: LValueCastType:
10071:    node_type nt = oTypeSNodeType
10076:    oTypeSPop
10077:    [ equal_node_type( nt, oTypeSNodeType )
10086:       | false :
               % Can we cast the value to the desired type?
10087:          [ oTypeSNodeType
10089:             | nIntegerType, nEnumType :
10090:                [ nt
10093:                   | nByteType, nCharType, nBooleanType :  #eSizeMismatch  >>
10097:                   | nIntegerType, nEnumType :   >>
10100:                   | * :
10113:                ]
10113:             | nByteType, nCharType, nBooleanType :
10115:                [ nt
10118:                   | nByteType, nCharType, nBooleanType :   >>
10120:                   | nIntegerType, nEnumType :  #eSizeMismatch  >>
10125:                   | * :
10138:                ]
10138:             | nPointerType :
10140:                [ nt
10143:                   | nUniversalPointerType :  >>
10145:                   | * :
10150:                ]
10150:             | nUniversalPointerType :
10152:                [ nt
10155:                   | nPointerType :  >>
10157:                   | * :
10162:                ]
10162:             | nShortStringType :
10164:                [ nt
10167:                   | nStrLitType :  >>
10169:                   | * :
10174:                ]
10174:             | * :
10193:          ]
10193:          #eTypeMismatch
10195:       | * :
10200:    ];
      
      
      
      % Parse an lvalue expression (e.g. left side of an assign statement)
      % that starts with the just-accepted identifier indicated by the given decl.
      % Leaves the lvalue address on the expression stack,
      % and the type of the value at that address on the type stack.
      %
10201: LValueVar( Node decl, boolean writeable ):
10203:    [ oNodeType( decl )
10210:       | nGlobalVar :   .tPushAddrGlobal @EmitValue( decl )
10220:       | nLocalVar :    .tPushAddrLocal @EmitValue( decl )
10231:       | nParam :
10233:          [ oNodeGetBoolean( decl, qInOut )
10243:             | true :   % VAR param points to variable.  No dereference.
10244:                        .tPushParamP @EmitValue( decl )
10253:             | * :      .tPushAddrParam @EmitValue( decl )
10267:          ]
10267:       | nTypedConst :
10269:          [ writeable
10272:             | false :  .tPushAddrGlobal @EmitValue( decl )                       
10282:             | * :      #eNotVar
10289:          ]
10289:       | * :            #eNotVar
10302:    ]
      
10302:    oTypeSPush( oNodeGet( decl, qType ) )
      
         % handle subscripts, if any.
         % There is one case that I'm not fitting into the pattern nicely, so need to
         % check for specially here:  if lvalue var is a pointer variable, and is
         % followed by [index], we need to dereference the pointer variable before applying
         % the index.  This is different from handling of [index] on an rvalue expression.
         % Right now I have LValueIndexes working for both lvalue and rvalue (composite types)
         % so can't easily add this behavior in there.
         % TO DO: probably I need separate rules LValueIndexes and RValueIndexes.
         %    This might also explain my confusion about handling of deref operator in LValueIndexes vs rvalue expr,
         %    and having separate rules might clear that up better.
      
10315:    [ oTypeSNodeType
10317:       | nPointerType :
10318:          [
10318:             | '[' :
                     % dereference the pointer var first
10320:                .tFetchP
10322:                @PointerArraySubscript
10324:             | * :
10329:          ]
10329:       | * :
10334:    ]
         % additional subscripts, if any
10334:    @LValueIndexes
10337:    ;
      
      
10337: IncVar( Node decl ):
10339:    @LValueVar( decl, true )
10349:    @RequireIntPop
10351:    @VarExpr( decl )
10358:    oTypeSPop
10359:    .tIncI
10361:    .tAssignI;
      
10364: DecVar( Node decl ):
10366:    @LValueVar( decl, true )
10376:    @RequireIntPop
10378:    @VarExpr( decl )
10385:    oTypeSPop
10386:    .tDecI
10388:    .tAssignI;
      
      
10391: IfStmt:
10393:    Label falseLabel = labelNull
      
10399:    @BooleanExprControlFlow( falseLabel )
10406:    pThen
10408:    @Statement
10410:    [
10410:       | pElse :
10412:          Label doneLabel = oLabelNew
      
10417:          .tJump  oEmitLabel( doneLabel )
10425:          .tLabel oEmitLabel( falseLabel )
10433:          @Statement
10435:          .tLabel oEmitLabel( doneLabel )
      
10443:       | * :
10448:          .tLabel oEmitLabel( falseLabel )
10456:    ];
      
      
10457: ForStmt:
10459:    pIdent
      
10461:    Node decl = oScopeFindRequire
         % TO DO: disallow use of a compound variable field.
         %        Could do that by disallowing use of LValueIndexes,
         %        or by double-checking the decl's qType here.
         % TO DO: I think I read somewhere that the variable must be in current scope.
10466:    @LValueVar( decl, true )
10476:    @RequireIntPop
      
10478:    ':='
      
10480:    @Expr
10482:    @RequireIntPop
10484:    .tAssignI
      
10486:    Label breakLabel = oLabelNew
      
10491:    Label checkLabel = oLabelNew
10496:    .tJump  oEmitLabel( checkLabel )
      
10504:    Label continueLabel = oLabelNew
10509:    .tLabel  oEmitLabel( continueLabel )
10517:    [
10517:       | pTo :
10519:          @IncVar( decl )
10526:          .tLabel  oEmitLabel( checkLabel )
10534:          @VarExpr( decl )  oTypeSPop
10542:          @Expr
10544:          @RequireIntPop
10546:          .tGreaterI
10548:          .tJumpTrue  oEmitLabel( breakLabel )
10556:       | pDownto :
10558:          @DecVar( decl )
10565:          .tLabel  oEmitLabel( checkLabel )
10573:          @VarExpr( decl )  oTypeSPop
10581:          @Expr
10583:          @RequireIntPop
10585:          .tLessI
10587:          .tJumpTrue  oEmitLabel( breakLabel )
10595:    ]
10603:    oLoopPush( continueLabel, breakLabel )
10612:    pDo
10614:    @Statement
10616:    .tJump  oEmitLabel( continueLabel )
10624:    .tLabel  oEmitLabel( breakLabel )
10632:    oLoopPop;
      
      
10634: RepeatStmt:
10636:    Label continueLabel = oLabelNew
10641:    .tLabel  oEmitLabel( continueLabel )
      
10649:    Label breakLabel = oLabelNew
      
10654:    oLoopPush( continueLabel, breakLabel )
10663:    @Statement
10665:    {[
10665:       | ';' :
10667:          @Statement
10669:       | pUntil :
10671:          Label falseLabel
10671:          @BooleanExprControlFlow( falseLabel )
10678:          .tLabelAlias  oEmitLabel( falseLabel )  oEmitLabel( continueLabel )
10692:          >
10694:    ]}
10704:    .tLabel  oEmitLabel( breakLabel )
10712:    oLoopPop;
      
      
10714: WhileStmt:
10716:    Label continueLabel = oLabelNew
10721:    .tLabel  oEmitLabel( continueLabel )
      
10729:    Label breakLabel
10729:    @BooleanExprControlFlow( breakLabel )
      
10736:    oLoopPush( continueLabel, breakLabel )
10745:    pDo
10747:    @Statement
10749:    .tJump  oEmitLabel( continueLabel )
10757:    .tLabel  oEmitLabel( breakLabel )
10765:    oLoopPop;
      
      
10767: ContinueStmt:                     % NOTE, for repeat..until, skips test (??)
10769:    [ equal_label( oLoopContinueLabel, labelNull )
10778:       | true :
10779:          #eNotInALoop
10781:       | false :
10783:          .tJump  oEmitLabel( oLoopContinueLabel )
10790:    ];
      
      
10799: BreakStmt:
10801:    [ equal_label( oLoopBreakLabel, labelNull )
10810:       | true :
10811:          #eNotInALoop
10813:       | false :
10815:          .tJump  oEmitLabel( oLoopBreakLabel )
10822:    ];
      
      
10831: CaseStmt:
10833:    Code tableCode = oCodeNew
10838:    Label tableLabel = oLabelNew
10843:    Label doneLabel = oLabelNew
10848:    Label otherwiseLabel = doneLabel
10854:    boolean isString = false
      
10860:    @Expr
         % Leave the expr type on the type stack throughout case statement
10862:    [ oTypeSNodeType
10864:       | nBooleanType, nByteType, nCharType :   .tJumpCaseB  oEmitLabel( tableLabel )
10873:       | nIntegerType, nEnumType :              .tJumpCaseI  oEmitLabel( tableLabel )
10883:       | nShortStringType, nStrLitType :        isString = true
10891:                                                .tJumpCaseS  oEmitLabel( tableLabel )
10899:       | * :     #eNotAllowed
10918:    ]
10918:    pOf
      
10920:    {
10920:       [
10920:          | pOtherwise, pElse :
10922:             otherwiseLabel = oLabelNew
10927:             .tLabel  oEmitLabel( otherwiseLabel )
      
                  % A bit tricky:
                  % The otherwise clause allows multiple statements (unlike other cases).
                  % ';' might be separating statements in the otherwise clause,
                  % or might be an optional trailing ; after the last statement.
                  % I have to watch for End to know when the statements stop.
                  % (Note, the otherwise clause is the last part of the case statement.)
10935:             {[
10935:                | pEnd :  >
10939:                | * :
10944:                   @Statement
10946:                   [
10946:                      | ';' :
10948:                      | * :   pEnd  >
10957:                   ]
10957:             ]}
10959:             >
      
10961:          | pEnd :
                  % Reached end with no otherwise clause
10963:             >
      
10965:          | * :
10974:             Label caseLabel = oLabelNew
10979:             oCodePush( tableCode )
10985:             {
10985:                @ConstExpr
10987:                @ConstCoerceType
10989:                int val
10989:                [ isString
10992:                   | true :    val = oStringAllocShortStringLit( oValueTopString )
11002:                   | false :   val = oValueTop
11009:                ]
11017:                oValuePop
11018:                [
11018:                   | '..' :  @ConstExpr
11022:                             @ConstCoerceType
11024:                             int highval
11024:                             [ isString
11027:                                | true :   highval = oStringAllocShortStringLit( oValueTopString )
11037:                                | false :  highval = oValueTop
11044:                             ]
11052:                             oValuePop
11053:                             .tCaseRange  oEmitInt( val )  oEmitInt( highval )  oEmitLabel( caseLabel )
11073:                   | * :     .tCase  oEmitInt( val )  oEmitLabel( caseLabel )
11092:                ]
11092:                [
11092:                   | ',' :
11094:                   | * :  >
11101:                ]
11101:             }
11103:             oCodePop
11104:             ':'
11106:             .tLabel  oEmitLabel( caseLabel )
11114:             @Statement
11116:             .tJump  oEmitLabel( doneLabel )
                  % Swallow optional trailing ';'
11124:             [
11124:                | ';' :
11126:                | * :
11131:             ]
                  
11131:       ]
         
11131:    }
      
11133:    .tLabel  oEmitLabel( tableLabel )
11141:    oEmitCode( tableCode )
11147:    .tCaseEnd  oEmitLabel( otherwiseLabel )
11155:    .tLabel  oEmitLabel( doneLabel )
11163:    oTypeSPop
11165:    ;
      
      
11165: GotoStmt:
11167:    [
11167:       | pIdent :
11169:       | pIntLit :
               % Replace token with identifier "_label_<intlit>"
11171:          oChangeIntLitToLabelIdent
11172:    ]
      
         % Some pascals have rules about where you can jump (to a sibling statement or
         % higher level statement in the block, but not into a lower lower level statement.)
         % fpc just says "jumping into a nested statement can have strange effects."
         % I'm going to follow that and not prohibit any goto, as long as it's in the same block.
      
         % Label must be declared in the same block (same scope) it is used.
         % Some pascals allow non-local goto, but we do not.
         % That would require more tracking of dynamic scope, to unwind stack.
         % Note: in main program statement, this relies on the temporaries scope extending
         %  the main scope (where a label declaration would occur).
11180:    Node decl = oScopeFindRequireInScope( oScopeCurrent )
11189:    oNodeSetBoolean( decl, qUsed, true )
11201:    .tJump  oEmitLabel( oNodeGetLabel( decl, qValue ) )
11217:    ;
      
      
11217: BeginStmt:
11219:    @Statement
11221:    {[
11221:       | ';' :   @Statement
11225:       | pEnd :  >
11229:    ]};
      
      
11240: WritelnStmt:
11242:    @WriteStmt
11244:    .tWriteCR;
      
      
11247: WriteStmt:
11249:    [
11249:       | '(' :
11251:          {
11251:             @Expr
11253:             [ oTypeSNodeType
11255:                | nIntegerType :             .tWriteI
11258:                | nBooleanType :             .tWriteBool
11262:                | nByteType :                .tCastBtoI  .tWriteI
11268:                | nCharType :                .tWriteChar
11272:                | nDoubleType :              .tWriteD
11276:                | nShortStringType, nStrLitType :   .tWriteShortStr
11280:                | nFileType :                #eNotImplemented
11284:                | nEnumType :
                        % write name via table lookup
11286:                   .tPushAddrGlobal  oEmitInt( oNodeGetInt( oTypeSTop, qNameTable ) )
11300:                   .tWriteEnum
11302:                | nPointerType :
11304:                   [ equal_node( oTypeSTop, PCharType )
11313:                      | true :               .tWritePChar
11316:                      | * :                  .tWriteP
11323:                   ]
11323:                | nUniversalPointerType :    .tWriteP
11327:                | * :                        #eNotAllowed
11354:             ]
11354:             oTypeSPop
11355:             [
11355:                | ')' : >
11359:                | ',' :
11361:             ]
11369:          }
11371:       | * :
11376:    ];
      
      
11377: ReadlnStmt:
11379:    @ReadStmt
11381:    .tReadCR;
      
      
11384: ReadStmt:
11386:    [
11386:       | '(' :
11388:          {
11388:             @LValueExpr( true )
11395:             [ oTypeSNodeType
11397:                | nIntegerType :      .tReadI
11400:                | nCharType :         .tReadChar
11404:                | nShortStringType :  
11406:                    int capacity = subtract( oNodeGetInt( oTypeSTop, qSize ), 1 )
11425:                    .tReadShortStr  oEmitInt( capacity )
11433:                | * :                 #eNotAllowed
11444:             ]
11444:             oTypeSPop
11445:             [
11445:                | ')' : >
11449:                | ',' :
11451:             ]
11459:          }
11461:       | * :
11466:    ];
11467: include 'pascal_str.ssl'
      %
      % Pascal Compiler
      %
      
      % ------------------------------ String Operations -----------------------------
      
      
      % Given a ShortString, StrLit, or Char on the expression stack
      % (and type on the type stack).  Move the value into a new temporary ShortString.
      % Leave that temp string and type on the stacks.
      % Also returns the offset of the temp string.
      %
11467: MoveIntoTempShortString >> int:
11469:    int tempOffset = oScopeAllocType( ShortStringType )
         % copy the value
11479:    [ oTypeSNodeType
11481:       | nShortStringType, nStrLitType :
11482:          .tPushAddrLocal  oEmitInt( tempOffset )
               % put temp addr under value addr
11490:          .tSwap
               % TO DO: we could just copy length + 1, but tCopy takes a fixed #bytes
11492:          .tCopy  oEmitInt( oNodeGetInt( ShortStringType, qSize ) )
11507:       | nCharType :
               % temp[0] = 1
11509:          .tPushAddrLocal  oEmitInt( tempOffset )
11517:          .tPushConstI  oEmitInt( 1 )
11525:          .tAssignB
               % temp[1] = value
11527:          .tPushAddrLocal  oEmitInt( add( tempOffset, 1 ) )
11542:          .tSwap
11544:          .tAssignB
11546:       | * :   #eTypeMismatch
11557:    ]
11557:    oTypeSPop
         % Leave the temp ShortString on the expr stack and type stack
11558:    .tPushAddrLocal  oEmitInt( tempOffset )
11566:    oTypeSPush( ShortStringType )
11572:    >> tempOffset;
      
      
      % Top of expr stack / type stack is ShortString B.
      % Under it is ShortString A.
      % Change A to append the contents of B to it (truncating if necessary).
      % Removes both A and B from the expr stack / type stack.
      %
11576: ShortStringAppendShortString:
         % TO DO: ideally I would do this directly with tcode.  But I think I need some more
         % enhancements for that to work well.   Meanwhile, generate a call to a method.
         % For the moment, I'll implement the method in Pascal, in the mysystem unit.
11578:    .tAllocActuals  oEmitInt( 16 )
11586:    .tPushAddrActual  oEmitInt( 8 )  .tSwap  .tAssignP
11598:    .tPushAddrActual  oEmitInt( 0 )  .tSwap  .tAssignP
11610:    .tCall   @EmitValue( System_ShortStringAppendShortString )
         % TO DO: Ideally I would leave A on the expr stack / type stack.
         %  But I can't really do that without dup, which I hesitate to add.
         %  I'll have the caller push A again themselves.
11619:    .tFreeActuals  oEmitInt( 16 )
11627:    oTypeSPop
11628:    oTypeSPop
11630:    ;
      
      % Top of expr stack / type stack is Char B.
      % Under it is ShortString A.
      % Change A to append char B to it (truncating if necessary).
      % Removes both A and B from the expr stack / type stack.
      %
11630: ShortStringAppendChar:
         % Note at the moment I don't align params
11632:    .tAllocActuals  oEmitInt( 12 )
11640:    .tPushAddrActual  oEmitInt( 8 )  .tSwap  .tAssignB
11652:    .tPushAddrActual  oEmitInt( 0 )  .tSwap  .tAssignP
11664:    .tCall  @EmitValue( System_ShortStringAppendChar )
11673:    .tFreeActuals  oEmitInt( 12 )
11681:    oTypeSPop
11682:    oTypeSPop
11684:    ;
      
      % Expr stack has ShortString A, and ShortString B above it.
      % Type stack has just the type of ShortString A.
      % Replaces the expr stack with the integer value of string comparison:
      % -1 if A < B,  0 if A = B,  1 if A > B
      % Leaves Integer on the type stack.
      %
      % TO DO: kind of annoying that we need to hardcode the fact that the called method is cdecl extern.
      %   It would be nicer if that was noted only in the label.
      %   Alternatively, use a utility method in SSL to generate the appropriate call,
      %   given the method decl.
      %
11684: ShortStringCmp:
11686:    .tAllocActualsCdecl  oEmitInt( 24 )
11694:    .tPushAddrActual  oEmitInt( 8 )  .tSwap  .tAssignP
11706:    .tPushAddrActual  oEmitInt( 0 )  .tSwap  .tAssignP
11718:    int tempOffset = oScopeAllocType( IntegerType )
11728:    .tPushAddrActual  oEmitInt( 16 )  .tPushAddrLocal  oEmitInt( tempOffset )  .tAssignP
11746:    .tCallCdecl  @EmitValue( System_ShortStringCmp )
11755:    .tPushLocalI  oEmitInt( tempOffset )
11763:    .tFreeActuals  oEmitInt( 24 )
11771:    oTypeSPop
11772:    oTypeSPush( IntegerType )
11779:    ;
11779: include 'pascal_call.ssl'
      %
      % Pascal Compiler
      %
      
      % ------------------------------ Method Calls -----------------------------
      
      
      % Parse a call, given an nProc or nFunc for the just-accepted identifier.
      % If a func, this will also generate the code to push the return value on the expr stack,
      % and push the return type on the type stack.
      %
11779: Call( Node method ):
11781:    oNodeSetBoolean( method, qUsed, true )
      
         % If the method has a cdecl modifier, the back end will need to use the native
         % calling convention, instead of my own.  But, the convention varies by platform,
         % so the front end won't assume what it needs.  I'll still generate the normal tcode
         % that copies values into actuals space on the stack.
         % However, to help the back end, I will at least use a different instruction for the
         % allocation of the actuals space, and for the actual call.
         %
         % p.s. I only support cdecl on external methods, because I don't have a way
         % to let my own Pascal methods read params passed in with the cdecl calling convention.
         %
11793:    boolean cdecl = oNodeGetBoolean( method, qCdecl )
      
         % If this is a function, we will allocate a temporary
         % in the current scope, to hold the result value.
         % And pass a pointer to that temporary as an extra parameter.
11806:    Node resultType
11806:    int tempOffset
      
11806:    boolean isFunc = equal_node_type( oNodeType( method ), nFunc )
      
11823:    [ isFunc
11826:       | true :
11827:          resultType = oNodeGet( method, qType )
11840:          tempOffset = oScopeAllocType( resultType )
               % TO DO: we could manage temp allocation, so temp space can be reused
               %        by different code branches.
11850:       | * :
11855:    ]
         
      
11855:    Node paramScope = oNodeGet( method, qParams )
11868:    int actualsSize = oNodeGetInt( paramScope, qSize )
11881:    [ cdecl
11884:       | true : .tAllocActualsCdecl  oEmitInt( actualsSize )
11893:       | false :  .tAllocActuals  oEmitInt( actualsSize )
11903:    ]
      
         % If method is nested, it takes a hidden first parameter:
         % a pointer to the frame of the static scope in which the method is declared.
         % The location of a scope's frame is equivalent to offset 0 in the scope's locals space
         % (since local offsets are relative to the scope's frame pointer).
         %
         % The nested method may be in a higher scope (upLevels > 1),
         % or a sibling of the method we're in (upLevels = 1),
         % or an immediate child of the current method (upLevels = 0).
         %
         % To understand the upLevels computation, remember that a method's declaration
         % and its contents (variables, nested functions, and body statement)
         % are in two different scopes.
      
11911:    [ greater( @DeclLevel( method ), 0 )
11926:       | true :
11927:          .tPushAddrActual  oEmitInt( 0 )    % hidden param is at param offset 0
11935:          .tPushAddrUpLocal  oEmitInt( @DeclUpLevels( method ) )  oEmitInt( 0 )
11954:          .tAssignP
11956:       | * :
11961:    ]
      
      
11961:    NodeIter paramIter = oNodeGetIter( paramScope, qDecls )
11974:    Node param = oNodeIterValue( paramIter )
11984:    [
11984:       | '(' :
            
11986:          {
11986:             [ oNodeNull( param )
11993:                | true : >
11996:                | * :
12001:             ]
      
12001:             int offset = oNodeGetInt( param, qValue )
      
                  % Assign actual value to spot in actuals space
12014:             .tPushAddrActual oEmitInt( offset )
12022:             oTypeSPush( oNodeGet( param, qType ) )
      
12035:             [ oNodeGetBoolean( param, qInOut )
12045:                | true :   % A VAR param.
                                % The actual is a pointer to the value.
                                % The type on the type stack (pushed above) is for the pointed-to value.
      
12046:                           @LValueExpr( true )
                                % Addr of the referenced variable is on the expr stack,
                                % type of the variable is on the type stack.
      
                                % Match types more exactly. It's not sufficient to be assign compatible
                                % since the method will be assigning to the actual using the param type.
                                % Maybe something like type contents must match, incl subrange bounds.
12053:                           @MatchTypes
      
12055:                           .tAssignP
      
12057:                | false :  @Expr
12061:                           @CoerceType
                                
                                % Assign to offset in actuals space
      
12063:                           [ oTypeSNodeType
12065:                              | nIntegerType, nEnumType : .tAssignI
12068:                              | nBooleanType, nByteType, nCharType :  .tAssignB
12072:                              | nDoubleType :  .tAssignD
12076:                              | nFileType :   #eNotImplemented
12080:                              | nPointerType, nUniversalPointerType :  .tAssignP
12084:                              | nArrayType, nRecordType, nShortStringType :
                                       % compound types: copy value into actuals space
12086:                                  int size = oNodeGetInt( oTypeSTop, qSize )
12098:                                  .tCopy  oEmitInt( size )    % multi-word copy
12106:                           ]
12134:             ]
12142:             oTypeSPop
      
12143:             oNodeIterNext( paramIter )
12149:             param = oNodeIterValue( paramIter )
12159:             [ oNodeNull( param )
12166:                | true :  >
12169:                | false :
12171:             ]
      
12179:             ','
12181:          }
      
12183:          ')'
      
12185:       | * :
12190:    ]
      
12190:    [ oNodeNull( param )
12197:       | false :    #eMissingParameter
12200:       | * :
12205:    ]
      
12205:    [ isFunc
12208:       | true :
               % Pass result temp as an additional VAR parameter.
12209:          .tPushAddrActual oEmitInt( oNodeGetInt( method, qResultOffset ) )
12224:          .tPushAddrLocal  oEmitInt( tempOffset )
12232:          .tAssignP
12234:       | * :
12239:    ]
      
12239:    [ cdecl
12242:       | true :
12243:          .tCallCdecl  @EmitValue( method )
12252:       | false :
12254:          .tCall   @EmitValue( method )
12263:    ]
      
12271:    [ isFunc
12274:       | true :
               % push return value from temp
12275:          oTypeSPush( resultType )
      
12281:          [ oTypeSNodeType
12283:             | nIntegerType, nEnumType :   .tPushLocalI  oEmitInt( tempOffset )
12292:             | nBooleanType, nByteType, nCharType :   .tPushLocalB  oEmitInt( tempOffset )
12302:             | nFileType :  #eNotImplemented
12306:             | nPointerType, nUniversalPointerType :   .tPushLocalP  oEmitInt( tempOffset )
12316:             | nArrayType, nRecordType, nShortStringType :   % compound type: push address
12318:                                .tPushAddrLocal  oEmitInt( tempOffset )
12326:          ]
12352:       | * :
12357:    ]
         
12357:    .tFreeActuals  oEmitInt( actualsSize )
12366:    ;
      
      
      
      % Called on first use of an extern method
      %
12366: DefineExternLabel( Node method ):
         % The extern name might be given explicitly, otherwise the pascal method name.
12368:    int strAddr
12368:    String externalName = oNodeGetString( method, qExternalName )
12381:    [ equal_string( externalName, stringNull )
12391:       | true :
12392:          strAddr = oStringAllocLit( ID_STRING( oNodeGetInt( method, qIdent ) ) )
12413:       | false :
12415:          strAddr = oStringAllocLit( externalName )
12425:    ]
12433:    .tLabelExtern  @EmitValue( method )  oEmitInt( strAddr )
12449:    ;
      
      
      
      % Parse a call to a built-in function, identified by the just-accepted identifier.
      % This will also generate the code to push the return value on the expr stack,
      % and push the return type on the type stack.
      %
12449: CallBuiltInFunc( Node method ):
      
         % Ord(x)
12451:    [ oNodeEqual( method, BuiltIn_Ord )
12461:       | true :
               % parameter is any scalar type (including boolean, enum, char)
               % result is integer
12462:          '('
12464:          @Expr
12466:          [ oTypeSNodeType
12468:             | nIntegerType, nEnumType :
12469:             | nBooleanType, nByteType, nCharType :  .tCastBtoI
12473:             | * :  #eTypeMismatch
12488:          ]
12488:          oTypeSPop
12489:          oTypeSPush( IntegerType )
12495:          ')'
12497:          >>
12498:       | * :
12503:    ]
      
         % Chr(x)
12503:    [ oNodeEqual( method, BuiltIn_Chr )
12513:       | true :
               % parameter is integer
               % result is char
12514:          '('
12516:          @Expr
12518:          [ oTypeSNodeType
12520:             | nIntegerType :    .tCastItoB
12523:             | nByteType :
12525:             | * :  #eTypeMismatch
12534:          ]
12534:          oTypeSPop
12535:          oTypeSPush( CharType )
12541:          ')'
12543:          >>
12544:       | * :
12549:    ]
      
         % Pred(x)
12549:    [ oNodeEqual( method, BuiltIn_Pred )
12559:       | true :
               % parameter is any enum type, as long as it has values 0..N-1
               % result is the same enum type
12560:          '('
12562:          @Expr
12564:          [ oTypeSNodeType
12566:             | nEnumType :
                     % TO DO: does this skip past type aliases?
                     % TO DO: what if using pred/succ on a subrange type?
12567:                [ oNodeGetBoolean( oTypeSTop, qHasGap )
12576:                   | true :   #eCantUsePredSuccOnEnumWithValueGaps
12579:                   | * :
12584:                ]
12584:             | * :  #eTypeMismatch
12591:          ]
12591:          .tDecI
12593:          ')'
12595:          >>
12596:       | * :
12601:    ]
      
         % Succ(x)
12601:    [ oNodeEqual( method, BuiltIn_Succ )
12611:       | true :
               % parameter is any enum type, as long as it has values 0..N-1
               % result is the same enum type
12612:          '('
12614:          @Expr
12616:          [ oTypeSNodeType
12618:             | nEnumType :
                     % TO DO: does this skip past type aliases?
                     % TO DO: what if using pred/succ on a subrange type?
12619:                [ oNodeGetBoolean( oTypeSTop, qHasGap )
12628:                   | true :   #eCantUsePredSuccOnEnumWithValueGaps
12631:                   | * :
12636:                ]
12636:             | * :  #eTypeMismatch
12643:          ]
12643:          .tIncI
12645:          ')'
12647:          >>
12648:       | * :
12653:    ]
      
         % Sizeof(x)
12653:    [ oNodeEqual( method, BuiltIn_Sizeof )
12663:       | true :
               % parameter is a type name (cannot be a general type description),
               % or an expression (which is not evaluated).
               %
               % My initial thought was to look at the first token to see if it's a type name,
               % and if not, unaccept it and run @Expr  (with the code stream set to a dummy stream).
               % But that's not completely sufficient.
               % First, the typename might be   unit.name  so unaccepting one token wouldn't be good enough.
               % Also, an expression can start with a typename e.g.  integer(1+2) * 3
               %
               % So, instead of looking for a type name at this level, and going to Expr if not,
               % I'll just go into Expr.  But I'll turn on an option to accept type names in Primary.
               % Since we're discarding the code anyway, I'll have that primary push a bogus value
               % on the expr stack.  The main thing is just to get the type right.
               
12664:          '('
               % Parse expression but don't evaluate its code (so no side effects occur).
               % I'll accomplish that by sending the code to a temp stream that I discard.
12666:          Code dummyCode = oCodeNew
12671:          oCodePush( dummyCode )
12677:          @ExprAllowTypeName
12679:          oCodePop
12680:          oCodeDiscard( dummyCode )
12686:          Node theType = oTypeSTop
12691:          oTypeSPop
12692:          .tPushConstI  oEmitInt( oNodeGetInt( theType, qSize ) )
12707:          oTypeSPush( IntegerType )
12713:          ')'
12715:          >>
      
12716:       | * :
12721:    ]
      
12721:    #eNotImplemented
12724:    ;
      
12724: include 'pascal_type.ssl'
      %
      % Pascal Compiler
      %
      
      % ------------------------------ Types -----------------------------
      
      
      % Create and return a new nType of the given node_type, adding it to the type table.
      %
12724: newType( node_type nt, int size ) >> Node:
12726:   Node node = oNodeNew( nt )
12736:   oNodeSetInt( node, qSize, size )
12748:   oTypeAdd( node )
12754:   >> node
12758:   ;
      
      
      % Parse a type reference, returning the nType.
      % This will add types to the type table, as needed.
      %
      % Style question - at the moment I think callers look clearer if we use
      % an out param here, rather than a return value.
      %
12758: TypeRef( out Node resultType ):
12760:    [
12760:       | pIdent :           % previously named type (including intrinsics)
12762:          Node decl = oScopeFindRequire
12767:          @ResolveUnitRef( decl )
12774:          [ oNodeType( decl )
12781:             | nTypeDecl :
12782:                resultType = oNodeGet( decl, qType )
12795:             | * :
12800:                #eNotType
12802:                resultType = IntegerType
12808:          ]
         
12808:       | pArray :
12810:          '['
      
               % A multi-dimensional array is represented as a chain
               %    array [subrange1] of array [subrange2] of elementType
      
               % First, we build a vector of nArray's, each with one subrange as its index type,
               % but without setting the "of" type or size.
      
12812:          NodeVec dimensions = oNodeVecNew
      
12817:          {
                  % to do: probably should use general subrange parsing, incl minimal size value
                  %   In fact, supposed to parse ordinal_type here.  all ordinal types have a static low, high.
                  %   Not necessary to be a subrange.
      
12817:             Node subrange = oNodeNew( nSubrangeType )
      
12827:             @ConstExpr
12829:             oNodeSetInt( subrange, qLow, oValueTop )
12840:             oValuePop
12841:             '..'
12843:             @ConstExpr
12845:             oNodeSetInt( subrange, qHigh, oValueTop )
12856:             oValuePop
      
12857:             @ConstMatchTypes
12859:             oNodeSet( subrange, qBaseType, oTypeSTop )
12870:             oNodeSetInt( subrange, qSize, oNodeGetInt( oTypeSTop, qSize ) )
12888:             oTypeSPop
12889:             oTypeAdd( subrange )
      
12895:             Node a = oNodeNew( nArrayType )
12905:             oNodeSet( a, qIndexType, subrange )
      
12917:             oNodeVecAppend( dimensions, a )
                  % I'll hold off on adding 'a' to the type table since not fully formed yet
      
12926:             [
12926:                | ']' : >
12930:                | ',' :
12932:             ]
12940:          }
      
12942:          pOf
12944:          Node baseType
12944:          @TypeRef( baseType )
      
               % Work backwards through the dimensions,
               % hooking up the 'of' type and calculating the size.
               % At each iteration, baseType is the 'of' type.
      
12951:          int dim = oNodeVecSize( dimensions )
      
12961:          {
12961:              dec(dim)
      
12967:              Node a = oNodeVecElement( dimensions, dim )
      
12980:              oNodeSet( a, qBaseType, baseType )
12992:              Node subrange = oNodeGet( a, qIndexType )
13005:              int width = subtract( oNodeGetInt( subrange, qHigh ), oNodeGetInt( subrange, qLow ) )
13032:              inc( width )
13038:              oNodeSetInt( a, qSize, multiply( width, oNodeGetInt( baseType, qSize ) ) )
      
13064:              oTypeAdd( a )
13070:              baseType = a
      
13076:              [ equal_zero(dim)
13083:                  | true:  >
13086:                  | *:
13091:              ]
13091:          }
      
13093:          resultType = oNodeVecElement( dimensions, 0 )
13106:          oNodeVecDelete( dimensions )
      
13112:       | '^' :
13114:          Node theType
13114:          @TypeRef( theType )
13121:          resultType = @PointerTypeTo( theType )
      
13132:       | pRecord :
13134:          resultType = oNodeNew( nRecordType )
13144:          oScopeBegin( -1, allocUp )    % level is meaningless here
      
13153:          @VarDecl( nRecordField )
      
13160:          int size = oNodeGetInt( oScopeCurrent, qSize )
               % to do: padding
13172:          [ equal_zero( size )
13179:             | true : #eRecordEmpty
13182:             | * :
13187:          ]
      
13187:          pEnd
      
13189:          oNodeSet( resultType, qScope, oScopeCurrent )
13200:          oNodeSetInt( resultType, qSize, size )
13212:          oScopeEnd
13213:          oTypeAdd( resultType )
      
      
13219:       | '(' :
               % An enum type declaration.
13221:          @EnumTypeRef( resultType )
      
      
            % *** TO DO: following type constructors are not implemented *** 
13228:       | pSet :
13230:          pOf
13232:          Node theType
13232:          @TypeRef( theType )
13239:          #eNotImplemented
13241:       | * :       % this works for cases except where expr starts with an id
13256:          @ConstExpr '..' @ConstExpr
13262:          @ConstMatchTypes
13264:          #eNotImplemented
13266:    ];
      
      
      % Parse an enum type.
      % We've already accepted the '('
      % Returns the new type.
      %
13267: EnumTypeRef( out Node resultType ):
      
13269:    resultType = oNodeNew( nEnumType )
13279:    int value = 0
13285:    int numValues = 0
13291:    boolean first = true
      
         % We'll declare the enum values in two scopes: the current scope, and a scope nested in the enum type.
         % That will let programs use either <val> or <enumType>.<val>
13297:    Node outerScope = oScopeCurrent
13302:    oScopeBegin( -1, allocUp )   % level is meaningless, and we won't use allocate
      
13311:    {
            % TO DO: assert that name not already seen in this scope, i.e. this enum.
            %  And possibly not in the outerScope either, since that probably wouldn't count as shadowing.
            %  It might be in some other higher/used scope.
13311:       pIdent
13313:       Node decl = @newIdent( nEnumValue, LAST_ID )
13326:       Node decl2 = @newIdent( nEnumValue, LAST_ID )
13339:       oNodeSet( decl, qType, resultType )
13351:       oNodeSet( decl2, qType, resultType )
      
            % build up name table, for i/o
13363:       int nameOffset = oStringAllocLit( ID_STRING( LAST_ID ) )
13376:       oNodeSetInt( decl, qNameOffset, nameOffset )
13388:       oNodeSetInt( decl2, qNameOffset, nameOffset )
13400:       [
13400:          | '=', ':=' :
13402:             oTypeSPush( IntegerType )
13408:             @ConstExpr
13410:             @ConstCoerceType
13412:             oTypeSPop
                  % value must be ascending
                  % this obviously doesn't apply to the first value
13413:             [ equal_zero( numValues )
13420:                | false :
13421:                   [ greater( oValueTop, value )
13430:                      | false :   #eEnumValueNotAscending
13433:                      | * :
13438:                   ]
13438:                | * :
13443:             ]
13443:             [ equal( value, oValueTop )
13452:                | false :
                        % The values differ from 0..N-1.  pred/succ may not be used with this type.
13453:                   oNodeSetBoolean( resultType, qHasGap, true )
13465:                | * :
13470:             ]
13470:             value = oValueTop
13475:             oValuePop
13476:          | * :
13483:       ]
13483:       oNodeSetInt( decl, qValue, value )
13495:       oNodeSetInt( decl2, qValue, value )
13507:       oScopeDeclare( decl )
      
13513:       oScopeEnter( outerScope )
13519:       oScopeDeclare( decl2 )
13525:       oScopeEnd
      
13526:       inc( value )
13532:       inc( numValues )
13538:       [
13538:          | ',' :
13540:          | * :    >
13547:       ]
13547:    }
13549:    ')'
      
13551:    oNodeSet( resultType, qScope, oScopeCurrent )
13562:    oNodeSetInt( resultType, qSize, 4 )   % always integer sized
13574:    oScopeEnd
      
         % Finish creation of the name table
         %    struct {
         %      int    value;
         %      int    padding;
         %      char*  name;
         %    } table[ numValues + 1 ];
         %  final entry will have name == nullptr
         %
         % I'll need to generate init code, to store pointers in global data,
         % since I don't have a relocation mechanism for static data at the moment.
13575:    oCodePush( @GetOrCreateInitCode( globalScope ) )
13586:    oScopeEnter( globalScope )
13592:    int size = multiply( add( numValues, 1 ), 16 )
13612:    int addr = oScopeAlloc( size, 8 )
13625:    oScopeEnd
13626:    oNodeSetInt( resultType, qNameTable, addr )
         % loop over enum values
13638:    NodeIter it = oNodeGetIter( oNodeGet( resultType, qScope ), qDecls )
13658:    {
13658:       Node enumValue = oNodeIterValue( it )
13668:       [ oNodeNull( enumValue )
13675:          | true :  >
13678:          | * :
13683:       ]
13683:       .tPushAddrGlobal  oEmitInt( addr )
13691:       .tPushConstI  oEmitInt( oNodeGetInt( enumValue, qValue ) )
13706:       .tAssignI
13708:       addr = add( addr, 8 )
13721:       .tPushAddrGlobal  oEmitInt( addr )
13729:       .tPushAddrGlobal  oEmitInt( oNodeGetInt( enumValue, qNameOffset ) )
13744:       .tAssignP
13746:       addr = add( addr, 8 )
13759:       oNodeIterNext( it )
13765:    }
         % final table entry
13767:    .tPushAddrGlobal  oEmitInt( addr )
13775:    .tPushConstI  oEmitInt( 0 )
13783:    .tAssignI
13785:    addr = add( addr, 8 )
13798:    .tPushAddrGlobal  oEmitInt( addr )
13806:    .tPushConstI  oEmitInt( 0 )
13814:    .tAssignP
13816:    addr = add( addr, 8 )
13829:    oCodePop
      
13830:    oTypeAdd( resultType )
13837:    ;
      
      
      
      % Return an nType representing a pointer to the given type.
      % (Creates a new type if necessary.)
      %
13837: PointerTypeTo( Node theType ) >> Node:
13839:    Node ptrType = oNodeGet( theType, qPointerType )
13852:    [ oNodeNull( ptrType )
13859:       | true :
13860:          ptrType = oNodeNew( nPointerType )
13870:          oNodeSet( ptrType, qBaseType, theType )
13882:          oNodeSetInt( ptrType, qSize, 8 )
13894:          oTypeAdd( ptrType )
13900:          oNodeSet( theType, qPointerType, ptrType )
13912:       | * :
13917:    ]
13917:    >> ptrType;
      
      
      
      % Return the low value of an ordinal type
      %
13921: OrdinalLow( Node theType ) >> int:
13923:    [ oNodeType( theType )
13930:       | nIntegerType :  >> oMININT
13933:       | nBooleanType :  >> 0
13938:       | nCharType :     >> 0
13943:       | nEnumType :
13945:          Node enumScope = oNodeGet( theType, qScope )
13958:          Node first = oNodeIterValue( oNodeGetIter( enumScope, qDecls ) )
13975:          >> oNodeGetInt( first, qValue )
13985:       | nSubrangeType : >> oNodeGetInt( theType, qLow )
13997:       | * :             #eNotOrdinalType
14012:                         >> 0
14015:    ];
      
      
      % Return the high value of an ordinal type
      %
14016: OrdinalHigh( Node theType ) >> int:
14018:    [ oNodeType( theType )
14025:       | nIntegerType :  >> oMAXINT
14028:       | nBooleanType :  >> 1
14033:       | nCharType :     >> 255
14038:       | nEnumType :
14040:          Node enumScope = oNodeGet( theType, qScope )
14053:          Node last = oNodeIterValue( oNodeGetIterLast( enumScope, qDecls ) )
14070:          >> oNodeGetInt( last, qValue )
14080:       | nSubrangeType : >> oNodeGetInt( theType, qHigh )
14092:       | * :             #eNotOrdinalType
14107:                         >> 0
14110:    ];
      
      
      
14111: Program:
14113:    Node t
      
14113:    workspace = oWorkspaceNew
      
         % root scope is used for builtins e.g. Integer,
         % and is a parent to any used units, and the program's own global scope.
14118:    oScopeBegin( 0, allocGlobal )
14127:    Node rootScope = oScopeCurrent
      
14132:    @installBuiltIns
      
         % Start by calling the main program routine.
      
         % This dummy call to main needs to look like a normal method itself,
         % so jit can align the stack properly.  So we need .tEnter,
         % and .tAllocActuals / .tFreeActuals.
14134:    .tEnter  oEmitInt( 0 )
14142:    Label mainLabel = oLabelNew
      
14147:    .tAllocActuals  oEmitInt( 0 )
14155:    .tCall  oEmitLabel( mainLabel )
14163:    .tFreeActuals  oEmitInt( 0 )
14171:    .tReturn
      
14173:    pProgram
14175:    pIdent
      
14177:    Node program = oNodeNew( nProgram )
14187:    oNodeSetInt( program, qIdent, LAST_ID )
14198:    oNodeSet( workspace, qProgram, program )
      
      
14210:    [
14210:       | '(' :
14212:          pIdent      % input, output files
      
14214:          t = @newIdent( nVar, LAST_ID )
14227:          oNodeSet( t, qType, FileType )
14239:          oScopeDeclareAlloc( t )
               % TO DO: I shouldn't declare the files in root scope.
               %        Should save them for program's global scope.
      
14245:          ','
14247:          pIdent
      
14249:          t = @newIdent( nVar, LAST_ID )
14262:          oNodeSet( t, qType, FileType )
14274:          oScopeDeclareAlloc( t )
      
14280:          ')'
14282:       | * :
14287:    ]
14287:    ';'
      
14289:    @UsesMySystem( program )
         % The uses clause may only appear once, immediately after the program declaration.
14296:    [
14296:       | pUses :  @UsesClause( program )
14305:       | * :
14310:    ]
14310:    @EnterUsedUnits( program )
      
         % Global scope for the program, below any used units.
14317:    oScopeBegin( 0, allocGlobal )
14326:    globalScope = oScopeCurrent
      
         % A new scope just for temporaries in the main routine
         % Create it up front, in case it's needed by variable initialization exprs.
         % But we won't stay in it here.
         % Note we say it extends the global scope, so that during main statement evaluation
         % any user labels declared in the global scope are considered to be part of the current scope.
14331:    oScopeBegin( 0, allocDown )
14340:    oNodeSet( oScopeCurrent, qExtends, globalScope )
14351:    initScope = oScopeCurrent
14356:    oNodeSet( program, qMainRoutineScope, initScope )
14368:    oScopeEnd
      
14369:    @BlockDecls( nGlobalVar )
      
      
14376:    oScopeEnter( initScope )
      
         % The block statement includes a stack frame, and enter/return,
         % even for the main routine.
         % That will be necessary for temporaries allocated in the main routine.
      
         % isMain means we'll generate calls to the unit init/final methods in here too.
         % Alternatively we could do that in a higher level method that calls main.
14382:    boolean isMain = true
14388:    @BlockStmt( mainLabel, globalScope, isMain )
      
14401:    oScopeEnd   % main routine scope
      
14402:    '.'
14404:    @CheckForUndefinedLabels
14406:    oScopeEnd   % global scope
14407:    @EndUsedUnits( program )   % used units scopes
14415:    ;
      
      
      
      
14415: Block( node_type varNodeType, Label labelForBody ):
14417:    @BlockDecls( varNodeType )
14424:    @BlockStmt( labelForBody, oScopeCurrent, false )
14436:    @CheckForUndefinedLabels
14439:    ;
      
      
14439: BlockDecls( node_type varNodeType ):
14441:    {[
14441:       | pConst :     @ConstDecl
14445:       | pType :      @TypeDecl
14449:       | pVar :       @VarDecl( varNodeType )
14458:       | pLabel :     @LabelDecl
14462:       | pProcedure : @ProcDecl
14466:       | pFunction :  @FuncDecl
14470:       | * :          >
14487:    ]}
14489:    @CheckForUndefinedMethods
14492:    ;
      
      
      % were there any procedures or functions declared in this scope
      % that were never defined?
14492: CheckForUndefinedMethods:
         % TO DO
         % Note: disregard methods marked external
14495:    ;
      
      % were there any labels declared in the current scope, and used,
      % but never defined (as the prefix of a stement)?
      %
14495: CheckForUndefinedLabels:
14497:    NodeIter it = oNodeGetIter( oScopeCurrent, qDecls )
14509:    {
14509:       Node decl = oNodeIterValue( it )
14519:       [ oNodeNull( decl )
14526:          | false :
14527:          | * :  >
14534:       ]
14534:       [ oNodeType( decl )
14541:          | nLabel :
14542:             [ oNodeGetBoolean( decl, qDefined )
14552:                | false :
14553:                   [ oNodeGetBoolean( decl, qUsed )
14563:                      | true :    #eUsedButNotDefined  % TO DO: give the decl in the message
14566:                      | * :
14571:                   ]
14571:                | * :
14576:             ]
14576:          | * :
14581:       ]
14581:       oNodeIterNext( it )
14587:    }
14590:    ;
      
      
      % Given the scope of vars in this block.
      % Usually it's the current scope, but it's a bit different for the main statement.
      %
14590: BlockStmt( Label labelForBody, Node varScope, boolean isMain ):
14592:    .tLabel  oEmitLabel( labelForBody )
      
         % Proc, func, and main routine all start with tEnter
         % to create a stack frame.  This will be used for temporaries
         % (and local vars in the case of proc, func).
      
14600:    int patchLS
14600:    .tEnter  patchLS = Here  .tSpace
      
         % If we're generating the program main method,
         % add in calls to the loaded units' initialization and finalization.
14609:    [ isMain
14612:       | true :  @InitializeUnits
14615:       | * :
14620:    ]
      
         % insert any code for initialization of this scope's variables
14620:    Code initCode = oNodeGetCode( varScope, qInitCode )
14633:    oEmitCode( initCode )
14639:    oNodeSetCode( varScope, qInitCode, codeNull )
      
14651:    @Statement
      
14653:    [ isMain
14656:       | true :  @FinalizeUnits
14659:       | * :
14664:    ]
      
14664:    .tReturn
      
14666:    int localSpace = oNodeGetInt( oScopeCurrent, qSize )
14678:    oPatch( patchLS, localSpace )
14688:    ;
      
      
      % We need an initCode code stream for the given scope.
      % Create it if not present yet.  Return it.
      % (This will be used for variable initialization.)
      %
14688: GetOrCreateInitCode( Node scope ) >> Code:
14690:    Code initCode = oNodeGetCode( scope, qInitCode )
14703:    [ equal_code( initCode, codeNull )
14713:       | true :
14714:          initCode = oCodeNew
14719:          oNodeSetCode( scope, qInitCode, initCode )
14731:       | * :
14736:    ]
14736:    >> initCode;
      
      
      
      
      
      % -------------------------------- Utilities -------------------------------
      
      % Return the static scope level of the current scope
      %
14740: ScopeLevel >> int:
14742:    >> oNodeGetInt( oScopeCurrent, qLevel );
      
      % Return the static scope level of the given declaration
      %
14752: DeclLevel( Node decl ) >> int:
14754:    >> oNodeGetInt( oNodeGet( decl, qParentScope ), qLevel );
         
      
      % How many levels higher is the given declaration from the current scope?
      %
14772: DeclUpLevels( Node decl ) >> int:
14774:    >> subtract( @ScopeLevel, @DeclLevel( decl ) );
      
      
      
      
      % Create and return a new nIdent of the given node_type, with the given ident id.
      % Does not add it to any scope.
      %
14790: newIdent( node_type nt, int id ) >> Node:
14792:   Node t = oNodeNew( nt )
14802:   oNodeSetInt( t, qIdent, id )
14814:   >> t
14818:   ;
      
      
      % Emit the value in a declaration.
      % For a constant integer, this is the constant value.
      % For a global variable, this is the global address.
      % For a local variable, this is the local address relative to the call stack frame.
      %
14818: EmitValue( Node decl ):
14820:     oEmitInt( oNodeGetInt( decl, qValue ));
      
      
14834: DeclareBuiltInFunc( int id ) >> Node:
14836:    Node decl = @newIdent( nBuiltInFunc, id )
14850:    oScopeDeclare( decl )
14856:    >> decl;
      
      
14860: installBuiltIns:
      
         % initialize some other globals too
14862:    flagExprAllowTypeName = false
      
         % "mysystem" is the name of a unit that will be available everywhere.
         % Add its name to the id table so we can easily spot the name later.
14868:    mysystemId = oId_mysystem
      
         % install built-in types
14873:    FileType = @newType( nFileType, 4 )
14887:    IntegerType = @newType( nIntegerType, 4 )
14901:    BooleanType = @newType( nBooleanType, 1 )
14915:    BooleanFlowType = @newType( nBooleanFlowType, 1 )
14929:    CharType = @newType( nCharType, 1 )
14943:    PCharType = @PointerTypeTo( CharType )
14954:    ByteType = @newType( nByteType, 1 )
14968:    SingleType = @newType( nSingleType, 4 )
14982:    DoubleType = @newType( nDoubleType, 8 )
         % Universal pointer says base type Byte, but this is only for the sake of
         % pointer arithmetic.  It doesn't matter otherwise, because this type cannot be dereferened.
14996:    UniversalPointerType = @newType( nUniversalPointerType, 8 )
15010:    oNodeSet( UniversalPointerType, qBaseType, ByteType )
         % StrLitType is stored with both a length byte and null termination, so it can be assigned to
         % both a ShortString and a PChar.  StrLits longer than 255 characters appear truncated when
         % referenced as a ShortString, but not when referenced as a PChar.
15022:    StrLitType = @newType( nStrLitType, 256 )
         % ShortString is the original Pascal string type: an array of characters, not null-terminated,
         % with the first byte recording the current length.
         % The default ShortString type has capacity for 255 characters.  The user may define
         % additional ShortString types with smaller capacities.
         % The first character can be accessed as myString[1].
15036:    ShortStringType = @newType( nShortStringType, 256 )
15050:    oNodeSetInt( ShortStringType, qCapacity, 255 )
      
         % Declare those type identifiers.
         % SSL doesn't support strings, so need help from operations e.g. oId_File
      
15062:    Node t
      
15062:    t = @newIdent( nTypeDecl, oId_File )
15075:    oNodeSet( t, qType, FileType )
15087:    oScopeDeclare( t )
      
15093:    t = @newIdent( nTypeDecl, oId_Integer )
15106:    oNodeSet( t, qType, IntegerType )
15118:    oScopeDeclare( t )
      
15124:    t = @newIdent( nTypeDecl, oId_Boolean )
15137:    oNodeSet( t, qType, BooleanType )
15149:    oScopeDeclare( t )
      
15155:    t = @newIdent( nTypeDecl, oId_Char )
15168:    oNodeSet( t, qType, CharType )
15180:    oScopeDeclare( t )
      
15186:    t = @newIdent( nTypeDecl, oId_Byte )
15199:    oNodeSet( t, qType, ByteType )
15211:    oScopeDeclare( t )
      
15217:    t = @newIdent( nTypeDecl, oId_Single )
15230:    oNodeSet( t, qType, SingleType )
15242:    oScopeDeclare( t )
      
15248:    t = @newIdent( nTypeDecl, oId_Double )
15261:    oNodeSet( t, qType, DoubleType )
15273:    oScopeDeclare( t )
      
15279:    t = @newIdent( nTypeDecl, oId_Pointer )
15292:    oNodeSet( t, qType, UniversalPointerType )
15304:    oScopeDeclare( t )
      
15310:    t = @newIdent( nTypeDecl, oId_ShortString )
15323:    oNodeSet( t, qType, ShortStringType )
15335:    oScopeDeclare( t )
      
         % Built-in constants
      
15341:    t = @newIdent( nConst, oId_True )
15354:    oNodeSet( t, qType, BooleanType )
15366:    oNodeSetInt( t, qValue, 1 )
15378:    oScopeDeclare( t )
      
15384:    t = @newIdent( nConst, oId_False )
15397:    oNodeSet( t, qType, BooleanType )
15409:    oNodeSetInt( t, qValue, 0 )
15421:    oScopeDeclare( t )
      
15427:    t = @newIdent( nConst, oId_Nil )
15440:    oNodeSet( t, qType, UniversalPointerType )
15452:    oNodeSetInt( t, qValue, 0 )
15464:    oScopeDeclare( t )
      
         % Built-in methods
         % These aren't declared like normal methods, because they may have
         % special rules for parameter types (e.g. any scalar type).
         % Calls to these methods will be handled specially by the compiler.
      
15470:    BuiltIn_Ord = @DeclareBuiltInFunc( oId_Ord )
15480:    BuiltIn_Chr = @DeclareBuiltInFunc( oId_Chr )
15490:    BuiltIn_Pred = @DeclareBuiltInFunc( oId_Pred )
15500:    BuiltIn_Succ = @DeclareBuiltInFunc( oId_Succ )
15510:    BuiltIn_Sizeof = @DeclareBuiltInFunc( oId_Sizeof )
15521:    ;
      
15521: end
      
15521: 

Generated code:

   0: oGlobalSpace 26
   2: oLocalSpace 0
   4: oCall 14111
   6: oReturn
   7: oLocalSpace 0
   9: oInput 0
  11: LAST_ID
  12: oPushResult
  13: oGetParam 1
  15: oPushResult
  16: oCall 148
  18: oPop 2
  20: oInputChoice 24
  22: oJumpForward 29
  24: Choice Lookup Table
          14     22
  27: oJumpForward 31
  29: oJumpBack 9
  31: oInput 6
  33: oReturn
  34: oLocalSpace 0
  36: oGetParam 1
  38: oPushResult
  39: oSetResult 4
  41: oPushResult
  42: oNodeGetInt
  43: oPop 2
  45: oPushResult
  46: oGetGlobal 4
  48: oPushResult
  49: equal
  50: oPop 2
  52: oChoice 57
  54: oReturn
  55: oJumpForward 60
  57: Choice Lookup Table
           1     54
  60: oGetGlobal 4
  62: oPushResult
  63: oGetParam 1
  65: oPushResult
  66: oCall 148
  68: oPop 2
  70: oReturn
  71: oLocalSpace 0
  73: oGetParam 1
  75: oPushResult
  76: oSetResult 4
  78: oPushResult
  79: oNodeGetInt
  80: oPop 2
  82: oPushResult
  83: oGetGlobal 4
  85: oPushResult
  86: equal
  87: oPop 2
  89: oChoice 144
  91: oGetAddrGlobal 22
  93: oPushResult
  94: oScopeCurrent
  95: oPushResult
  96: oSetResult 15
  98: oPushResult
  99: oSetResult 4
 101: oPushResult
 102: oId_ShortStringAppendShortString
 103: oPushResult
 104: oNodeFind
 105: oPop 4
 107: oAssign
 108: oGetAddrGlobal 23
 110: oPushResult
 111: oScopeCurrent
 112: oPushResult
 113: oSetResult 15
 115: oPushResult
 116: oSetResult 4
 118: oPushResult
 119: oId_ShortStringAppendChar
 120: oPushResult
 121: oNodeFind
 122: oPop 4
 124: oAssign
 125: oGetAddrGlobal 24
 127: oPushResult
 128: oScopeCurrent
 129: oPushResult
 130: oSetResult 15
 132: oPushResult
 133: oSetResult 4
 135: oPushResult
 136: oId_ShortStringCmp
 137: oPushResult
 138: oNodeFind
 139: oPop 4
 141: oAssign
 142: oJumpForward 147
 144: Choice Lookup Table
           1     91
 147: oReturn
 148: oLocalSpace 2
 150: oGetAddrLocal 1
 152: oPushResult
 153: oGetParam 2
 155: oPushResult
 156: oCall 428
 158: oPop 1
 160: oAssign
 161: oGetLocal 1
 163: oPushResult
 164: oSetResult 0
 166: oPushResult
 167: equal_node
 168: oPop 2
 170: oChoice 240
 172: oGetParam 1
 174: oPushResult
 175: oSetResult 5
 177: oPushResult
 178: oGetLocal 1
 180: oPushResult
 181: oNodeAddLast
 182: oPop 3
 184: oGetAddrLocal 2
 186: oPushResult
 187: oSetResult 10
 189: oPushResult
 190: oNodeNew
 191: oPop 1
 193: oAssign
 194: oGetLocal 2
 196: oPushResult
 197: oSetResult 4
 199: oPushResult
 200: oGetLocal 1
 202: oPushResult
 203: oSetResult 4
 205: oPushResult
 206: oNodeGetInt
 207: oPop 2
 209: oPushResult
 210: oNodeSetInt
 211: oPop 3
 213: oGetLocal 2
 215: oPushResult
 216: oSetResult 9
 218: oPushResult
 219: oGetLocal 1
 221: oPushResult
 222: oSetResult 9
 224: oPushResult
 225: oNodeGet
 226: oPop 2
 228: oPushResult
 229: oNodeSet
 230: oPop 3
 232: oGetLocal 2
 234: oPushResult
 235: oScopeDeclare
 236: oPop 1
 238: oJumpForward 243
 240: Choice Lookup Table
           0    172
 243: oReturn
 244: oLocalSpace 1
 246: oGetFromParam 1
 248: oPushResult
 249: oNodeType
 250: oPop 1
 252: oChoice 283
 254: oGetAddrLocal 1
 256: oPushResult
 257: oGetFromParam 1
 259: oPushResult
 260: oSetResult 9
 262: oPushResult
 263: oNodeGet
 264: oPop 2
 266: oAssign
 267: oInput 21
 269: oInput 0
 271: oGetParam 1
 273: oPushResult
 274: oGetLocal 1
 276: oPushResult
 277: oScopeFindRequireInScope
 278: oPop 1
 280: oAssign
 281: oJumpForward 286
 283: Choice Lookup Table
          10    254
 286: oReturn
 287: oLocalSpace 2
 289: oGetAddrLocal 1
 291: oPushResult
 292: oGetParam 1
 294: oPushResult
 295: oSetResult 5
 297: oPushResult
 298: oNodeGetIter
 299: oPop 2
 301: oAssign
 302: oGetAddrLocal 2
 304: oPushResult
 305: oGetLocal 1
 307: oPushResult
 308: oNodeIterValue
 309: oPop 1
 311: oAssign
 312: oGetLocal 2
 314: oPushResult
 315: oNodeNull
 316: oPop 1
 318: oChoice 335
 320: oGetLocal 2
 322: oPushResult
 323: oSetResult 9
 325: oPushResult
 326: oNodeGet
 327: oPop 2
 329: oPushResult
 330: oScopeEnter
 331: oPop 1
 333: oJumpForward 340
 335: Choice Lookup Table
           0    320
 338: oJumpForward 348
 340: oGetAddrLocal 1
 342: oPushResult
 343: oNodeIterNext
 344: oPop 1
 346: oJumpBack 302
 348: oReturn
 349: oLocalSpace 2
 351: oGetAddrLocal 1
 353: oPushResult
 354: oGetParam 1
 356: oPushResult
 357: oSetResult 5
 359: oPushResult
 360: oNodeGetIterLast
 361: oPop 2
 363: oAssign
 364: oGetAddrLocal 2
 366: oPushResult
 367: oGetLocal 1
 369: oPushResult
 370: oNodeIterValue
 371: oPop 1
 373: oAssign
 374: oGetLocal 2
 376: oPushResult
 377: oNodeNull
 378: oPop 1
 380: oChoice 414
 382: oScopeCurrent
 383: oPushResult
 384: oGetLocal 2
 386: oPushResult
 387: oSetResult 9
 389: oPushResult
 390: oNodeGet
 391: oPop 2
 393: oPushResult
 394: oNodeEqual
 395: oPop 2
 397: oChoice 405
 399: oJumpForward 411
 401: oError 27
 403: oJumpForward 411
 405: Choice Lookup Table
           0    401
           1    399
 410: oEndChoice
 411: oScopeEnd
 412: oJumpForward 419
 414: Choice Lookup Table
           0    382
 417: oJumpForward 427
 419: oGetAddrLocal 1
 421: oPushResult
 422: oNodeIterPrev
 423: oPop 1
 425: oJumpBack 364
 427: oReturn
 428: oLocalSpace 2
 430: oGetAddrLocal 1
 432: oPushResult
 433: oGetGlobal 1
 435: oPushResult
 436: oSetResult 1
 438: oPushResult
 439: oSetResult 4
 441: oPushResult
 442: oGetParam 1
 444: oPushResult
 445: oNodeFind
 446: oPop 4
 448: oAssign
 449: oGetLocal 1
 451: oPushResult
 452: oSetResult 0
 454: oPushResult
 455: equal_node
 456: oPop 2
 458: oChoice 465
 460: oGetLocal 1
 462: oReturn
 463: oJumpForward 468
 465: Choice Lookup Table
           0    460
 468: oGetAddrLocal 2
 470: oPushResult
 471: oGetParam 1
 473: oPushResult
 474: oIncludeUnitFile
 475: oPop 1
 477: oAssign
 478: oGetLocal 2
 480: oChoice 489
 482: oError 26
 484: oSetResult 0
 486: oReturn
 487: oJumpForward 492
 489: Choice Lookup Table
           0    482
 492: oGetAddrLocal 1
 494: oPushResult
 495: oCall 503
 497: oAssign
 498: oIncludeEnd
 499: oGetLocal 1
 501: oReturn
 502: oReturn
 503: oLocalSpace 2
 505: oInput 61
 507: oInput 0
 509: oGetAddrLocal 1
 511: oPushResult
 512: oSetResult 5
 514: oPushResult
 515: oNodeNew
 516: oPop 1
 518: oAssign
 519: oGetLocal 1
 521: oPushResult
 522: oSetResult 4
 524: oPushResult
 525: LAST_ID
 526: oPushResult
 527: oNodeSetInt
 528: oPop 3
 530: oGetAddrLocal 2
 532: oPushResult
 533: oSetResult 6
 535: oPushResult
 536: oNodeNew
 537: oPop 1
 539: oAssign
 540: oGetLocal 2
 542: oPushResult
 543: oSetResult 4
 545: oPushResult
 546: LAST_ID
 547: oPushResult
 548: oNodeSetInt
 549: oPop 3
 551: oGetLocal 1
 553: oPushResult
 554: oSetResult 8
 556: oPushResult
 557: oGetLocal 2
 559: oPushResult
 560: oNodeSet
 561: oPop 3
 563: oInput 6
 565: oInput 62
 567: oGetLocal 1
 569: oPushResult
 570: oCall 34
 572: oPop 1
 574: oInputChoice 585
 576: oGetLocal 1
 578: oPushResult
 579: oCall 7
 581: oPop 1
 583: oJumpForward 588
 585: Choice Lookup Table
          60    576
 588: oGetLocal 1
 590: oPushResult
 591: oCall 287
 593: oPop 1
 595: oSetResult 0
 597: oPushResult
 598: oSetResult 0
 600: oPushResult
 601: oScopeBegin
 602: oPop 2
 604: oGetLocal 1
 606: oPushResult
 607: oSetResult 9
 609: oPushResult
 610: oScopeCurrent
 611: oPushResult
 612: oNodeSet
 613: oPop 3
 615: oGetAddrGlobal 2
 617: oPushResult
 618: oScopeCurrent
 619: oAssign
 620: oSetResult 0
 622: oPushResult
 623: oSetResult 1
 625: oPushResult
 626: oScopeBegin
 627: oPop 2
 629: oGetAddrGlobal 3
 631: oPushResult
 632: oScopeCurrent
 633: oAssign
 634: oGetLocal 1
 636: oPushResult
 637: oSetResult 13
 639: oPushResult
 640: oGetGlobal 3
 642: oPushResult
 643: oNodeSet
 644: oPop 3
 646: oScopeEnd
 647: oGetLocal 1
 649: oPushResult
 650: oCall 838
 652: oPop 1
 654: oScopeEnd
 655: oInput 63
 657: oGetLocal 2
 659: oPushResult
 660: oCall 34
 662: oPop 1
 664: oInputChoice 675
 666: oGetLocal 2
 668: oPushResult
 669: oCall 7
 671: oPop 1
 673: oJumpForward 678
 675: Choice Lookup Table
          60    666
 678: oGetLocal 2
 680: oPushResult
 681: oCall 287
 683: oPop 1
 685: oGetLocal 1
 687: oPushResult
 688: oSetResult 9
 690: oPushResult
 691: oNodeGet
 692: oPop 2
 694: oPushResult
 695: oScopeEnter
 696: oPop 1
 698: oSetResult 0
 700: oPushResult
 701: oSetResult 0
 703: oPushResult
 704: oScopeBegin
 705: oPop 2
 707: oGetLocal 1
 709: oPushResult
 710: oSetResult 10
 712: oPushResult
 713: oScopeCurrent
 714: oPushResult
 715: oNodeSet
 716: oPop 3
 718: oScopeCurrent
 719: oPushResult
 720: oSetResult 16
 722: oPushResult
 723: oGetLocal 1
 725: oPushResult
 726: oSetResult 9
 728: oPushResult
 729: oNodeGet
 730: oPop 2
 732: oPushResult
 733: oNodeSet
 734: oPop 3
 736: oGetAddrGlobal 2
 738: oPushResult
 739: oScopeCurrent
 740: oAssign
 741: oGetLocal 1
 743: oPushResult
 744: oCall 930
 746: oPop 1
 748: oInputChoice 762
 750: oGetLocal 1
 752: oPushResult
 753: oSetResult 1
 755: oPushResult
 756: oCall 940
 758: oPop 2
 760: oJumpForward 775
 762: Choice Lookup Table
          64    750
 765: oGetLocal 1
 767: oPushResult
 768: oSetResult 0
 770: oPushResult
 771: oCall 940
 773: oPop 2
 775: oInputChoice 789
 777: oGetLocal 1
 779: oPushResult
 780: oSetResult 1
 782: oPushResult
 783: oCall 1126
 785: oPop 2
 787: oJumpForward 802
 789: Choice Lookup Table
          65    777
 792: oGetLocal 1
 794: oPushResult
 795: oSetResult 0
 797: oPushResult
 798: oCall 1126
 800: oPop 2
 802: oInput 37
 804: oInput 21
 806: oScopeEnd
 807: oScopeEnd
 808: oGetLocal 2
 810: oPushResult
 811: oCall 349
 813: oPop 1
 815: oGetLocal 1
 817: oPushResult
 818: oCall 349
 820: oPop 1
 822: oGetGlobal 1
 824: oPushResult
 825: oSetResult 1
 827: oPushResult
 828: oGetLocal 1
 830: oPushResult
 831: oNodeAddLast
 832: oPop 3
 834: oGetLocal 1
 836: oReturn
 837: oReturn
 838: oLocalSpace 2
 840: oInputChoice 907
 842: oCall 2538
 844: oJumpForward 920
 846: oCall 3231
 848: oJumpForward 920
 850: oSetResult 22
 852: oPushResult
 853: oCall 3287
 855: oPop 1
 857: oJumpForward 920
 859: oGetAddrLocal 1
 861: oPushResult
 862: oCall 1505
 864: oAssign
 865: oInputChoice 878
 867: oGetLocal 1
 869: oPushResult
 870: oCall 1418
 872: oPop 1
 874: oInput 6
 876: oJumpForward 881
 878: Choice Lookup Table
          71    867
 881: oJumpForward 920
 883: oGetAddrLocal 2
 885: oPushResult
 886: oCall 1879
 888: oAssign
 889: oInputChoice 902
 891: oGetLocal 2
 893: oPushResult
 894: oCall 1418
 896: oPop 1
 898: oInput 6
 900: oJumpForward 905
 902: Choice Lookup Table
          71    891
 905: oJumpForward 920
 907: Choice Lookup Table
          31    883
          30    859
          34    850
          33    846
          32    842
 918: oJumpForward 922
 920: oJumpBack 840
 922: oGetParam 1
 924: oPushResult
 925: oCall 71
 927: oPop 1
 929: oReturn
 930: oLocalSpace 0
 932: oSetResult 22
 934: oPushResult
 935: oCall 14439
 937: oPop 1
 939: oReturn
 940: oLocalSpace 5
 942: oGetAddrLocal 1
 944: oPushResult
 945: oLabelNew
 946: oAssign
 947: oEmit 91
 949: oGetLocal 1
 951: oPushResult
 952: oEmitLabel
 953: oPop 1
 955: oGetParam 2
 957: oPushResult
 958: oSetResult 11
 960: oPushResult
 961: oGetLocal 1
 963: oPushResult
 964: oNodeSetLabel
 965: oPop 3
 967: oEmit 81
 969: oGetAddrLocal 2
 971: oPushResult
 972: Here
 973: oAssign
 974: oEmit 109
 976: oGetAddrLocal 3
 978: oPushResult
 979: oGetParam 2
 981: oPushResult
 982: oSetResult 9
 984: oPushResult
 985: oNodeGet
 986: oPop 2
 988: oAssign
 989: oGetAddrLocal 4
 991: oPushResult
 992: oGetLocal 3
 994: oPushResult
 995: oSetResult 19
 997: oPushResult
 998: oNodeGetCode
 999: oPop 2
1001: oAssign
1002: oGetLocal 4
1004: oPushResult
1005: oEmitCode
1006: oPop 1
1008: oGetLocal 3
1010: oPushResult
1011: oSetResult 19
1013: oPushResult
1014: oSetResult 0
1016: oPushResult
1017: oNodeSetCode
1018: oPop 3
1020: oGetAddrLocal 3
1022: oPushResult
1023: oGetParam 2
1025: oPushResult
1026: oSetResult 10
1028: oPushResult
1029: oNodeGet
1030: oPop 2
1032: oAssign
1033: oGetAddrLocal 4
1035: oPushResult
1036: oGetLocal 3
1038: oPushResult
1039: oSetResult 19
1041: oPushResult
1042: oNodeGetCode
1043: oPop 2
1045: oAssign
1046: oGetLocal 4
1048: oPushResult
1049: oEmitCode
1050: oPop 1
1052: oGetLocal 3
1054: oPushResult
1055: oSetResult 19
1057: oPushResult
1058: oSetResult 0
1060: oPushResult
1061: oNodeSetCode
1062: oPop 3
1064: oGetParam 2
1066: oPushResult
1067: oSetResult 13
1069: oPushResult
1070: oNodeGet
1071: oPop 2
1073: oPushResult
1074: oScopeEnter
1075: oPop 1
1077: oGetParam 1
1079: oChoice 1098
1081: oCall 9503
1083: oInputChoice 1089
1085: oCall 9503
1087: oJumpForward 1094
1089: Choice Lookup Table
           6   1085
1092: oJumpForward 1096
1094: oJumpBack 1083
1096: oJumpForward 1101
1098: Choice Lookup Table
           1   1081
1101: oEmit 80
1103: oGetAddrLocal 5
1105: oPushResult
1106: oScopeCurrent
1107: oPushResult
1108: oSetResult 17
1110: oPushResult
1111: oNodeGetInt
1112: oPop 2
1114: oAssign
1115: oGetLocal 2
1117: oPushResult
1118: oGetLocal 5
1120: oPushResult
1121: oPatch
1122: oPop 2
1124: oScopeEnd
1125: oReturn
1126: oLocalSpace 3
1128: oGetAddrLocal 1
1130: oPushResult
1131: oLabelNew
1132: oAssign
1133: oEmit 91
1135: oGetLocal 1
1137: oPushResult
1138: oEmitLabel
1139: oPop 1
1141: oGetParam 2
1143: oPushResult
1144: oSetResult 12
1146: oPushResult
1147: oGetLocal 1
1149: oPushResult
1150: oNodeSetLabel
1151: oPop 3
1153: oEmit 81
1155: oGetAddrLocal 2
1157: oPushResult
1158: Here
1159: oAssign
1160: oEmit 109
1162: oSetResult 0
1164: oPushResult
1165: oSetResult 1
1167: oPushResult
1168: oScopeBegin
1169: oPop 2
1171: oGetParam 1
1173: oChoice 1192
1175: oCall 9503
1177: oInputChoice 1183
1179: oCall 9503
1181: oJumpForward 1188
1183: Choice Lookup Table
           6   1179
1186: oJumpForward 1190
1188: oJumpBack 1177
1190: oJumpForward 1195
1192: Choice Lookup Table
           1   1175
1195: oEmit 80
1197: oGetAddrLocal 3
1199: oPushResult
1200: oScopeCurrent
1201: oPushResult
1202: oSetResult 17
1204: oPushResult
1205: oNodeGetInt
1206: oPop 2
1208: oAssign
1209: oGetLocal 2
1211: oPushResult
1212: oGetLocal 3
1214: oPushResult
1215: oPatch
1216: oPop 2
1218: oScopeEnd
1219: oReturn
1220: oLocalSpace 2
1222: oGetAddrLocal 1
1224: oPushResult
1225: oGetGlobal 1
1227: oPushResult
1228: oSetResult 1
1230: oPushResult
1231: oNodeGetIter
1232: oPop 2
1234: oAssign
1235: oGetAddrLocal 2
1237: oPushResult
1238: oGetLocal 1
1240: oPushResult
1241: oNodeIterValue
1242: oPop 1
1244: oAssign
1245: oGetLocal 2
1247: oPushResult
1248: oNodeNull
1249: oPop 1
1251: oChoice 1296
1253: oJumpForward 1304
1255: oJumpForward 1302
1257: oEmit 75
1259: oSetResult 0
1261: oPushResult
1262: oEmitInt
1263: oPop 1
1265: oEmit 78
1267: oGetLocal 2
1269: oPushResult
1270: oSetResult 11
1272: oPushResult
1273: oNodeGetLabel
1274: oPop 2
1276: oPushResult
1277: oEmitLabel
1278: oPop 1
1280: oEmit 77
1282: oSetResult 0
1284: oPushResult
1285: oEmitInt
1286: oPop 1
1288: oGetAddrLocal 1
1290: oPushResult
1291: oNodeIterNext
1292: oPop 1
1294: oJumpForward 1302
1296: Choice Lookup Table
           0   1257
           1   1253
1301: oEndChoice
1302: oJumpBack 1235
1304: oReturn
1305: oLocalSpace 2
1307: oGetAddrLocal 1
1309: oPushResult
1310: oGetGlobal 1
1312: oPushResult
1313: oSetResult 1
1315: oPushResult
1316: oNodeGetIterLast
1317: oPop 2
1319: oAssign
1320: oGetAddrLocal 2
1322: oPushResult
1323: oGetLocal 1
1325: oPushResult
1326: oNodeIterValue
1327: oPop 1
1329: oAssign
1330: oGetLocal 2
1332: oPushResult
1333: oNodeNull
1334: oPop 1
1336: oChoice 1381
1338: oJumpForward 1389
1340: oJumpForward 1387
1342: oEmit 75
1344: oSetResult 0
1346: oPushResult
1347: oEmitInt
1348: oPop 1
1350: oEmit 78
1352: oGetLocal 2
1354: oPushResult
1355: oSetResult 12
1357: oPushResult
1358: oNodeGetLabel
1359: oPop 2
1361: oPushResult
1362: oEmitLabel
1363: oPop 1
1365: oEmit 77
1367: oSetResult 0
1369: oPushResult
1370: oEmitInt
1371: oPop 1
1373: oGetAddrLocal 1
1375: oPushResult
1376: oNodeIterPrev
1377: oPop 1
1379: oJumpForward 1387
1381: Choice Lookup Table
           0   1342
           1   1338
1386: oEndChoice
1387: oJumpBack 1320
1389: oReturn
1390: oLocalSpace 0
1392: oInputChoice 1410
1394: oGetParam 1
1396: oPushResult
1397: oSetResult 27
1399: oPushResult
1400: oSetResult 1
1402: oPushResult
1403: oNodeSetBoolean
1404: oPop 3
1406: oInput 6
1408: oJumpForward 1415
1410: Choice Lookup Table
          73   1394
1413: oJumpForward 1417
1415: oJumpBack 1392
1417: oReturn
1418: oLocalSpace 0
1420: oGetParam 1
1422: oPushResult
1423: oCall 14752
1425: oPop 1
1427: oPushResult
1428: equal_zero
1429: oPop 1
1431: oChoice 1437
1433: oError 24
1435: oJumpForward 1440
1437: Choice Lookup Table
           0   1433
1440: oGetParam 1
1442: oPushResult
1443: oSetResult 27
1445: oPushResult
1446: oNodeGetBoolean
1447: oPop 2
1449: oChoice 1455
1451: oError 25
1453: oJumpForward 1458
1455: Choice Lookup Table
           0   1451
1458: oGetParam 1
1460: oPushResult
1461: oSetResult 25
1463: oPushResult
1464: oSetResult 1
1466: oPushResult
1467: oNodeSetBoolean
1468: oPop 3
1470: oInputChoice 1494
1472: oInputChoice 1489
1474: oInput 3
1476: oGetParam 1
1478: oPushResult
1479: oSetResult 26
1481: oPushResult
1482: CURRENT_STRLIT
1483: oPushResult
1484: oNodeSetString
1485: oPop 3
1487: oJumpForward 1492
1489: Choice Lookup Table
          72   1474
1492: oJumpForward 1497
1494: Choice Lookup Table
           3   1472
1497: oGetParam 1
1499: oPushResult
1500: oCall 12366
1502: oPop 1
1504: oReturn
1505: oLocalSpace 6
1507: oInput 0
1509: oGetAddrLocal 1
1511: oPushResult
1512: oSetResult 0
1514: oAssign
1515: oGetAddrLocal 2
1517: oPushResult
1518: oScopeFindInCurrentScope
1519: oAssign
1520: oGetLocal 2
1522: oPushResult
1523: oNodeNull
1524: oPop 1
1526: oChoice 1644
1528: oGetAddrLocal 2
1530: oPushResult
1531: oSetResult 12
1533: oPushResult
1534: LAST_ID
1535: oPushResult
1536: oCall 14790
1538: oPop 2
1540: oAssign
1541: oGetLocal 2
1543: oPushResult
1544: oSetResult 22
1546: oPushResult
1547: oLabelNew
1548: oPushResult
1549: oNodeSetLabel
1550: oPop 3
1552: oJumpForward 1650
1554: oGetAddrLocal 1
1556: oPushResult
1557: oSetResult 1
1559: oAssign
1560: oGetLocal 2
1562: oPushResult
1563: oSetResult 24
1565: oPushResult
1566: oNodeGetBoolean
1567: oPop 2
1569: oChoice 1575
1571: oError 22
1573: oJumpForward 1578
1575: Choice Lookup Table
           1   1571
1578: oGetLocal 2
1580: oPushResult
1581: oSetResult 25
1583: oPushResult
1584: oNodeGetBoolean
1585: oPop 2
1587: oChoice 1593
1589: oError 22
1591: oJumpForward 1596
1593: Choice Lookup Table
           1   1589
1596: oGetLocal 2
1598: oPushResult
1599: oNodeType
1600: oPop 1
1602: oChoice 1606
1604: oJumpForward 1611
1606: Choice Lookup Table
          12   1604
1609: oError 22
1611: oGetLocal 2
1613: oPushResult
1614: oSetResult 29
1616: oPushResult
1617: oGetLocal 2
1619: oPushResult
1620: oSetResult 23
1622: oPushResult
1623: oNodeGet
1624: oPop 2
1626: oPushResult
1627: oNodeSet
1628: oPop 3
1630: oGetLocal 2
1632: oPushResult
1633: oSetResult 23
1635: oPushResult
1636: oSetResult 0
1638: oPushResult
1639: oNodeSet
1640: oPop 3
1642: oJumpForward 1650
1644: Choice Lookup Table
           0   1554
           1   1528
1649: oEndChoice
1650: oGetAddrLocal 3
1652: oPushResult
1653: oCall 14740
1655: oAssign
1656: oGetAddrLocal 4
1658: oPushResult
1659: oGetLocal 3
1661: oPushResult
1662: oSetResult 0
1664: oPushResult
1665: greater
1666: oPop 2
1668: oAssign
1669: oGetAddrLocal 3
1671: oPushResult
1672: inc
1673: oPop 1
1675: oGetLocal 3
1677: oPushResult
1678: oSetResult 2
1680: oPushResult
1681: oScopeBegin
1682: oPop 2
1684: oGetAddrLocal 5
1686: oPushResult
1687: oScopeCurrent
1688: oAssign
1689: oGetLocal 4
1691: oChoice 1710
1693: oGetAddrLocal 6
1695: oPushResult
1696: oGetGlobal 6
1698: oPushResult
1699: oCall 13837
1701: oPop 1
1703: oPushResult
1704: oScopeAllocType
1705: oPop 1
1707: oAssign
1708: oJumpForward 1713
1710: Choice Lookup Table
           1   1693
1713: oCall 2314
1715: oGetLocal 2
1717: oPushResult
1718: oSetResult 23
1720: oPushResult
1721: oGetLocal 5
1723: oPushResult
1724: oNodeSet
1725: oPop 3
1727: oScopeEnd
1728: oInput 6
1730: oGetLocal 1
1732: oChoice 1744
1734: oGetLocal 2
1736: oPushResult
1737: oScopeDeclare
1738: oPop 1
1740: oJumpForward 1750
1742: oJumpForward 1750
1744: Choice Lookup Table
           1   1742
           0   1734
1749: oEndChoice
1750: oGetLocal 2
1752: oPushResult
1753: oCall 1390
1755: oPop 1
1757: oGetLocal 2
1759: oReturn
1760: oReturn
1761: oLocalSpace 4
1763: oGetAddrLocal 1
1765: oPushResult
1766: oCall 1505
1768: oAssign
1769: oInputChoice 1782
1771: oJumpForward 1876
1773: oGetLocal 1
1775: oPushResult
1776: oCall 1418
1778: oPop 1
1780: oJumpForward 1876
1782: Choice Lookup Table
          71   1773
          70   1771
1787: oGetAddrLocal 2
1789: oPushResult
1790: oGetLocal 1
1792: oPushResult
1793: oSetResult 23
1795: oPushResult
1796: oNodeGet
1797: oPop 2
1799: oAssign
1800: oGetLocal 2
1802: oPushResult
1803: oScopeEnter
1804: oPop 1
1806: oGetAddrLocal 3
1808: oPushResult
1809: oGetLocal 2
1811: oPushResult
1812: oSetResult 14
1814: oPushResult
1815: oNodeGetInt
1816: oPop 2
1818: oAssign
1819: oGetLocal 3
1821: oPushResult
1822: oSetResult 1
1824: oPushResult
1825: oScopeBegin
1826: oPop 2
1828: oGetLocal 1
1830: oPushResult
1831: oSetResult 6
1833: oPushResult
1834: oScopeCurrent
1835: oPushResult
1836: oNodeSet
1837: oPop 3
1839: oGetAddrLocal 4
1841: oPushResult
1842: oGetLocal 1
1844: oPushResult
1845: oSetResult 22
1847: oPushResult
1848: oNodeGetLabel
1849: oPop 2
1851: oAssign
1852: oSetResult 23
1854: oPushResult
1855: oGetLocal 4
1857: oPushResult
1858: oCall 14415
1860: oPop 2
1862: oGetLocal 1
1864: oPushResult
1865: oSetResult 24
1867: oPushResult
1868: oSetResult 1
1870: oPushResult
1871: oNodeSetBoolean
1872: oPop 3
1874: oScopeEnd
1875: oScopeEnd
1876: oInput 6
1878: oReturn
1879: oLocalSpace 8
1881: oInput 0
1883: oGetAddrLocal 1
1885: oPushResult
1886: oSetResult 0
1888: oAssign
1889: oGetAddrLocal 2
1891: oPushResult
1892: oScopeFindInCurrentScope
1893: oAssign
1894: oGetLocal 2
1896: oPushResult
1897: oNodeNull
1898: oPop 1
1900: oChoice 2031
1902: oGetAddrLocal 2
1904: oPushResult
1905: oSetResult 13
1907: oPushResult
1908: LAST_ID
1909: oPushResult
1910: oCall 14790
1912: oPop 2
1914: oAssign
1915: oGetLocal 2
1917: oPushResult
1918: oSetResult 22
1920: oPushResult
1921: oLabelNew
1922: oPushResult
1923: oNodeSetLabel
1924: oPop 3
1926: oJumpForward 2037
1928: oGetAddrLocal 1
1930: oPushResult
1931: oSetResult 1
1933: oAssign
1934: oGetLocal 2
1936: oPushResult
1937: oSetResult 24
1939: oPushResult
1940: oNodeGetBoolean
1941: oPop 2
1943: oChoice 1949
1945: oError 22
1947: oJumpForward 1952
1949: Choice Lookup Table
           1   1945
1952: oGetLocal 2
1954: oPushResult
1955: oNodeType
1956: oPop 1
1958: oChoice 1962
1960: oJumpForward 1967
1962: Choice Lookup Table
          13   1960
1965: oError 22
1967: oGetLocal 2
1969: oPushResult
1970: oSetResult 29
1972: oPushResult
1973: oGetLocal 2
1975: oPushResult
1976: oSetResult 23
1978: oPushResult
1979: oNodeGet
1980: oPop 2
1982: oPushResult
1983: oNodeSet
1984: oPop 3
1986: oGetLocal 2
1988: oPushResult
1989: oSetResult 23
1991: oPushResult
1992: oSetResult 0
1994: oPushResult
1995: oNodeSet
1996: oPop 3
1998: oGetLocal 2
2000: oPushResult
2001: oSetResult 30
2003: oPushResult
2004: oGetLocal 2
2006: oPushResult
2007: oSetResult 21
2009: oPushResult
2010: oNodeGet
2011: oPop 2
2013: oPushResult
2014: oNodeSet
2015: oPop 3
2017: oGetLocal 2
2019: oPushResult
2020: oSetResult 21
2022: oPushResult
2023: oSetResult 0
2025: oPushResult
2026: oNodeSet
2027: oPop 3
2029: oJumpForward 2037
2031: Choice Lookup Table
           0   1928
           1   1902
2036: oEndChoice
2037: oGetAddrLocal 3
2039: oPushResult
2040: oCall 14740
2042: oAssign
2043: oGetAddrLocal 4
2045: oPushResult
2046: oGetLocal 3
2048: oPushResult
2049: oSetResult 0
2051: oPushResult
2052: greater
2053: oPop 2
2055: oAssign
2056: oGetAddrLocal 3
2058: oPushResult
2059: inc
2060: oPop 1
2062: oGetLocal 3
2064: oPushResult
2065: oSetResult 2
2067: oPushResult
2068: oScopeBegin
2069: oPop 2
2071: oGetAddrLocal 5
2073: oPushResult
2074: oScopeCurrent
2075: oAssign
2076: oGetLocal 4
2078: oChoice 2097
2080: oGetAddrLocal 6
2082: oPushResult
2083: oGetGlobal 6
2085: oPushResult
2086: oCall 13837
2088: oPop 1
2090: oPushResult
2091: oScopeAllocType
2092: oPop 1
2094: oAssign
2095: oJumpForward 2100
2097: Choice Lookup Table
           1   2080
2100: oCall 2314
2102: oGetLocal 2
2104: oPushResult
2105: oSetResult 23
2107: oPushResult
2108: oGetLocal 5
2110: oPushResult
2111: oNodeSet
2112: oPop 3
2114: oInput 13
2116: oGetAddrLocal 7
2118: oPushResult
2119: oCall 12758
2121: oPop 1
2123: oGetLocal 2
2125: oPushResult
2126: oSetResult 21
2128: oPushResult
2129: oGetLocal 7
2131: oPushResult
2132: oNodeSet
2133: oPop 3
2135: oGetAddrLocal 8
2137: oPushResult
2138: oGetLocal 7
2140: oPushResult
2141: oCall 13837
2143: oPop 1
2145: oAssign
2146: oGetLocal 2
2148: oPushResult
2149: oSetResult 31
2151: oPushResult
2152: oGetLocal 8
2154: oPushResult
2155: oScopeAllocType
2156: oPop 1
2158: oPushResult
2159: oNodeSetInt
2160: oPop 3
2162: oScopeEnd
2163: oInput 6
2165: oGetLocal 1
2167: oChoice 2179
2169: oGetLocal 2
2171: oPushResult
2172: oScopeDeclare
2173: oPop 1
2175: oJumpForward 2185
2177: oJumpForward 2185
2179: Choice Lookup Table
           1   2177
           0   2169
2184: oEndChoice
2185: oGetLocal 2
2187: oPushResult
2188: oCall 1390
2190: oPop 1
2192: oGetLocal 2
2194: oReturn
2195: oReturn
2196: oLocalSpace 4
2198: oGetAddrLocal 1
2200: oPushResult
2201: oCall 1879
2203: oAssign
2204: oInputChoice 2217
2206: oJumpForward 2311
2208: oGetLocal 1
2210: oPushResult
2211: oCall 1418
2213: oPop 1
2215: oJumpForward 2311
2217: Choice Lookup Table
          71   2208
          70   2206
2222: oGetAddrLocal 2
2224: oPushResult
2225: oGetLocal 1
2227: oPushResult
2228: oSetResult 23
2230: oPushResult
2231: oNodeGet
2232: oPop 2
2234: oAssign
2235: oGetLocal 2
2237: oPushResult
2238: oScopeEnter
2239: oPop 1
2241: oGetAddrLocal 3
2243: oPushResult
2244: oGetLocal 2
2246: oPushResult
2247: oSetResult 14
2249: oPushResult
2250: oNodeGetInt
2251: oPop 2
2253: oAssign
2254: oGetLocal 3
2256: oPushResult
2257: oSetResult 1
2259: oPushResult
2260: oScopeBegin
2261: oPop 2
2263: oGetLocal 1
2265: oPushResult
2266: oSetResult 6
2268: oPushResult
2269: oScopeCurrent
2270: oPushResult
2271: oNodeSet
2272: oPop 3
2274: oGetAddrLocal 4
2276: oPushResult
2277: oGetLocal 1
2279: oPushResult
2280: oSetResult 22
2282: oPushResult
2283: oNodeGetLabel
2284: oPop 2
2286: oAssign
2287: oSetResult 23
2289: oPushResult
2290: oGetLocal 4
2292: oPushResult
2293: oCall 14415
2295: oPop 2
2297: oGetLocal 1
2299: oPushResult
2300: oSetResult 24
2302: oPushResult
2303: oSetResult 1
2305: oPushResult
2306: oNodeSetBoolean
2307: oPop 3
2309: oScopeEnd
2310: oScopeEnd
2311: oInput 6
2313: oReturn
2314: oLocalSpace 6
2316: oInputChoice 2534
2318: oGetAddrLocal 1
2320: oPushResult
2321: oNodeVecNew
2322: oAssign
2323: oGetAddrLocal 3
2325: oPushResult
2326: oSetResult 0
2328: oAssign
2329: oInputChoice 2339
2331: oGetAddrLocal 3
2333: oPushResult
2334: oSetResult 1
2336: oAssign
2337: oJumpForward 2342
2339: Choice Lookup Table
          34   2331
2342: oInput 0
2344: oGetAddrLocal 2
2346: oPushResult
2347: oSetResult 25
2349: oPushResult
2350: LAST_ID
2351: oPushResult
2352: oCall 14790
2354: oPop 2
2356: oAssign
2357: oGetLocal 2
2359: oPushResult
2360: oSetResult 35
2362: oPushResult
2363: oGetLocal 3
2365: oPushResult
2366: oNodeSetBoolean
2367: oPop 3
2369: oGetLocal 1
2371: oPushResult
2372: oGetLocal 2
2374: oPushResult
2375: oNodeVecAppend
2376: oPop 2
2378: oInputChoice 2386
2380: oJumpForward 2394
2382: oJumpForward 2392
2384: oJumpForward 2392
2386: Choice Lookup Table
          14   2384
          13   2380
2391: oEndChoice
2392: oJumpBack 2342
2394: oGetAddrLocal 4
2396: oPushResult
2397: oCall 12758
2399: oPop 1
2401: oGetLocal 3
2403: oChoice 2418
2405: oGetAddrLocal 5
2407: oPushResult
2408: oGetLocal 4
2410: oPushResult
2411: oCall 13837
2413: oPop 1
2415: oAssign
2416: oJumpForward 2427
2418: Choice Lookup Table
           1   2405
2421: oGetAddrLocal 5
2423: oPushResult
2424: oGetLocal 4
2426: oAssign
2427: oGetAddrLocal 6
2429: oPushResult
2430: oSetResult 0
2432: oAssign
2433: oGetLocal 6
2435: oPushResult
2436: oGetLocal 1
2438: oPushResult
2439: oNodeVecSize
2440: oPop 1
2442: oPushResult
2443: equal
2444: oPop 2
2446: oChoice 2503
2448: oGetAddrLocal 2
2450: oPushResult
2451: oGetLocal 1
2453: oPushResult
2454: oGetLocal 6
2456: oPushResult
2457: oNodeVecElement
2458: oPop 2
2460: oAssign
2461: oGetLocal 2
2463: oPushResult
2464: oSetResult 21
2466: oPushResult
2467: oGetLocal 4
2469: oPushResult
2470: oNodeSet
2471: oPop 3
2473: oGetLocal 2
2475: oPushResult
2476: oScopeDeclare
2477: oPop 1
2479: oGetLocal 2
2481: oPushResult
2482: oSetResult 22
2484: oPushResult
2485: oGetLocal 5
2487: oPushResult
2488: oScopeAllocType
2489: oPop 1
2491: oPushResult
2492: oNodeSetInt
2493: oPop 3
2495: oGetAddrLocal 6
2497: oPushResult
2498: inc
2499: oPop 1
2501: oJumpForward 2508
2503: Choice Lookup Table
           0   2448
2506: oJumpForward 2510
2508: oJumpBack 2433
2510: oGetLocal 1
2512: oPushResult
2513: oNodeVecDelete
2514: oPop 1
2516: oInputChoice 2524
2518: oJumpForward 2532
2520: oJumpForward 2530
2522: oJumpForward 2530
2524: Choice Lookup Table
           6   2522
          16   2518
2529: oEndChoice
2530: oJumpBack 2318
2532: oJumpForward 2537
2534: Choice Lookup Table
          15   2318
2537: oReturn
2538: oLocalSpace 0
2540: oInputChoice 2555
2542: oInputChoice 2548
2544: oCall 2701
2546: oJumpForward 2553
2548: Choice Lookup Table
          13   2544
2551: oCall 2563
2553: oJumpForward 2560
2555: Choice Lookup Table
           0   2542
2558: oJumpForward 2562
2560: oJumpBack 2540
2562: oReturn
2563: oLocalSpace 2
2565: oGetAddrLocal 1
2567: oPushResult
2568: LAST_ID
2569: oAssign
2570: oInput 7
2572: oCall 3586
2574: oTypeSNodeType
2575: oChoice 2658
2577: oGetAddrLocal 2
2579: oPushResult
2580: oSetResult 16
2582: oPushResult
2583: oGetLocal 1
2585: oPushResult
2586: oCall 14790
2588: oPop 2
2590: oAssign
2591: oGetLocal 2
2593: oPushResult
2594: oSetResult 22
2596: oPushResult
2597: oValueTop
2598: oPushResult
2599: oNodeSetInt
2600: oPop 3
2602: oJumpForward 2679
2604: oGetAddrLocal 2
2606: oPushResult
2607: oSetResult 19
2609: oPushResult
2610: oGetLocal 1
2612: oPushResult
2613: oCall 14790
2615: oPop 2
2617: oAssign
2618: oGetLocal 2
2620: oPushResult
2621: oSetResult 34
2623: oPushResult
2624: oValueTopDouble
2625: oPushResult
2626: oNodeSetDouble
2627: oPop 3
2629: oJumpForward 2679
2631: oGetAddrLocal 2
2633: oPushResult
2634: oSetResult 18
2636: oPushResult
2637: oGetLocal 1
2639: oPushResult
2640: oCall 14790
2642: oPop 2
2644: oAssign
2645: oGetLocal 2
2647: oPushResult
2648: oSetResult 33
2650: oPushResult
2651: oValueTopString
2652: oPushResult
2653: oNodeSetString
2654: oPop 3
2656: oJumpForward 2679
2658: Choice Lookup Table
          42   2631
          33   2604
          38   2577
          37   2577
          44   2577
          31   2577
          36   2577
          30   2577
          34   2577
2677: oError 18
2679: oValuePop
2680: oGetLocal 2
2682: oPushResult
2683: oSetResult 21
2685: oPushResult
2686: oTypeSTop
2687: oPushResult
2688: oNodeSet
2689: oPop 3
2691: oTypeSPop
2692: oGetLocal 2
2694: oPushResult
2695: oScopeDeclare
2696: oPop 1
2698: oInput 6
2700: oReturn
2701: oLocalSpace 3
2703: oGetAddrLocal 1
2705: oPushResult
2706: oSetResult 26
2708: oPushResult
2709: LAST_ID
2710: oPushResult
2711: oCall 14790
2713: oPop 2
2715: oAssign
2716: oGetAddrLocal 2
2718: oPushResult
2719: oCall 12758
2721: oPop 1
2723: oGetLocal 1
2725: oPushResult
2726: oSetResult 21
2728: oPushResult
2729: oGetLocal 2
2731: oPushResult
2732: oNodeSet
2733: oPop 3
2735: oGetLocal 2
2737: oPushResult
2738: oNodeType
2739: oPop 1
2741: oChoice 2845
2743: oInput 7
2745: oGetLocal 2
2747: oPushResult
2748: oTypeSPush
2749: oPop 1
2751: oCall 3586
2753: oCall 4478
2755: oGetLocal 1
2757: oPushResult
2758: oSetResult 22
2760: oPushResult
2761: oValueTop
2762: oPushResult
2763: oNodeSetInt
2764: oPop 3
2766: oValuePop
2767: oTypeSPop
2768: oGetLocal 1
2770: oPushResult
2771: oScopeDeclare
2772: oPop 1
2774: oInput 6
2776: oJumpForward 2869
2778: oError 17
2780: oJumpForward 2869
2782: oGetGlobal 2
2784: oPushResult
2785: oScopeEnter
2786: oPop 1
2788: oGetAddrLocal 3
2790: oPushResult
2791: oGetLocal 2
2793: oPushResult
2794: oScopeAllocType
2795: oPop 1
2797: oAssign
2798: oScopeEnd
2799: oGetGlobal 2
2801: oPushResult
2802: oCall 14688
2804: oPop 1
2806: oPushResult
2807: oCodePush
2808: oPop 1
2810: oGetLocal 1
2812: oPushResult
2813: oSetResult 22
2815: oPushResult
2816: oGetLocal 3
2818: oPushResult
2819: oNodeSetInt
2820: oPop 3
2822: oInput 7
2824: oGetLocal 2
2826: oPushResult
2827: oGetLocal 3
2829: oPushResult
2830: oCall 2870
2832: oPop 2
2834: oCodePop
2835: oGetLocal 1
2837: oPushResult
2838: oScopeDeclare
2839: oPop 1
2841: oInput 6
2843: oJumpForward 2869
2845: Choice Lookup Table
          41   2782
          39   2782
          29   2778
          43   2778
          38   2743
          37   2743
          44   2743
          31   2743
          36   2743
          30   2743
          34   2743
2868: oEndChoice
2869: oReturn
2870: oLocalSpace 10
2872: oGetParam 2
2874: oPushResult
2875: oNodeType
2876: oPop 1
2878: oChoice 3204
2880: oGetAddrLocal 1
2882: oPushResult
2883: oGetParam 2
2885: oPushResult
2886: oSetResult 38
2888: oPushResult
2889: oNodeGet
2890: oPop 2
2892: oAssign
2893: oGetAddrLocal 2
2895: oPushResult
2896: oGetParam 2
2898: oPushResult
2899: oSetResult 39
2901: oPushResult
2902: oNodeGet
2903: oPop 2
2905: oAssign
2906: oGetAddrLocal 3
2908: oPushResult
2909: oGetLocal 2
2911: oPushResult
2912: oCall 13921
2914: oPop 1
2916: oAssign
2917: oGetAddrLocal 4
2919: oPushResult
2920: oGetLocal 2
2922: oPushResult
2923: oCall 14016
2925: oPop 1
2927: oAssign
2928: oGetAddrLocal 5
2930: oPushResult
2931: oGetLocal 1
2933: oPushResult
2934: oSetResult 17
2936: oPushResult
2937: oNodeGetInt
2938: oPop 2
2940: oAssign
2941: oInput 15
2943: oGetAddrLocal 6
2945: oPushResult
2946: oGetLocal 3
2948: oAssign
2949: oGetLocal 1
2951: oPushResult
2952: oGetParam 1
2954: oPushResult
2955: oCall 2870
2957: oPop 2
2959: oGetLocal 6
2961: oPushResult
2962: oGetLocal 4
2964: oPushResult
2965: equal
2966: oPop 2
2968: oChoice 2976
2970: oJumpForward 3005
2972: oJumpForward 2982
2974: oJumpForward 2982
2976: Choice Lookup Table
           0   2974
           1   2970
2981: oEndChoice
2982: oInput 14
2984: oGetAddrParam 1
2986: oPushResult
2987: oGetParam 1
2989: oPushResult
2990: oGetLocal 5
2992: oPushResult
2993: add
2994: oPop 2
2996: oAssign
2997: oGetAddrLocal 6
2999: oPushResult
3000: inc
3001: oPop 1
3003: oJumpBack 2949
3005: oInput 16
3007: oJumpForward 3230
3009: oInput 15
3011: oGetAddrLocal 7
3013: oPushResult
3014: oGetParam 2
3016: oPushResult
3017: oSetResult 42
3019: oPushResult
3020: oNodeGet
3021: oPop 2
3023: oAssign
3024: oInputChoice 3028
3026: oJumpForward 3033
3028: Choice Lookup Table
           0   3026
3031: oJumpForward 3099
3033: oGetAddrLocal 8
3035: oPushResult
3036: oGetLocal 7
3038: oPushResult
3039: oScopeFindRequireInScope
3040: oPop 1
3042: oAssign
3043: oInput 13
3045: oGetAddrLocal 9
3047: oPushResult
3048: oGetLocal 8
3050: oPushResult
3051: oSetResult 21
3053: oPushResult
3054: oNodeGet
3055: oPop 2
3057: oAssign
3058: oGetAddrLocal 10
3060: oPushResult
3061: oGetParam 1
3063: oPushResult
3064: oGetLocal 8
3066: oPushResult
3067: oSetResult 22
3069: oPushResult
3070: oNodeGetInt
3071: oPop 2
3073: oPushResult
3074: add
3075: oPop 2
3077: oAssign
3078: oGetLocal 9
3080: oPushResult
3081: oGetLocal 10
3083: oPushResult
3084: oCall 2870
3086: oPop 2
3088: oInputChoice 3092
3090: oJumpForward 3097
3092: Choice Lookup Table
           6   3090
3095: oJumpForward 3099
3097: oJumpBack 3024
3099: oInput 16
3101: oJumpForward 3230
3103: oEmit 17
3105: oGetParam 1
3107: oPushResult
3108: oEmitInt
3109: oPop 1
3111: oGetParam 2
3113: oPushResult
3114: oTypeSPush
3115: oPop 1
3117: oCall 3586
3119: oCall 4478
3121: oEmit 15
3123: oValueTop
3124: oPushResult
3125: oEmitInt
3126: oPop 1
3128: oValuePop
3129: oTypeSPop
3130: oEmit 28
3132: oJumpForward 3230
3134: oEmit 17
3136: oGetParam 1
3138: oPushResult
3139: oEmitInt
3140: oPop 1
3142: oGetParam 2
3144: oPushResult
3145: oTypeSPush
3146: oPop 1
3148: oCall 3586
3150: oCall 4478
3152: oEmit 15
3154: oValueTop
3155: oPushResult
3156: oEmitInt
3157: oPop 1
3159: oValuePop
3160: oTypeSPop
3161: oEmit 27
3163: oJumpForward 3230
3165: oError 17
3167: oJumpForward 3230
3169: oEmit 17
3171: oGetParam 1
3173: oPushResult
3174: oEmitInt
3175: oPop 1
3177: oGetParam 2
3179: oPushResult
3180: oTypeSPush
3181: oPop 1
3183: oCall 3586
3185: oCall 4478
3187: oEmit 15
3189: oValueTop
3190: oPushResult
3191: oEmitInt
3192: oPop 1
3194: oValuePop
3195: oTypeSPop
3196: oEmit 29
3198: oJumpForward 3230
3200: oError 17
3202: oJumpForward 3230
3204: Choice Lookup Table
          29   3200
          43   3200
          38   3169
          37   3169
          33   3165
          44   3134
          31   3134
          36   3103
          30   3103
          34   3103
          41   3009
          39   2880
3229: oEndChoice
3230: oReturn
3231: oLocalSpace 2
3233: oInputChoice 3279
3235: oGetAddrLocal 1
3237: oPushResult
3238: oSetResult 20
3240: oPushResult
3241: LAST_ID
3242: oPushResult
3243: oCall 14790
3245: oPop 2
3247: oAssign
3248: oInput 7
3250: oGetAddrLocal 2
3252: oPushResult
3253: oCall 12758
3255: oPop 1
3257: oGetLocal 1
3259: oPushResult
3260: oSetResult 21
3262: oPushResult
3263: oGetLocal 2
3265: oPushResult
3266: oNodeSet
3267: oPop 3
3269: oGetLocal 1
3271: oPushResult
3272: oScopeDeclare
3273: oPop 1
3275: oInput 6
3277: oJumpForward 3284
3279: Choice Lookup Table
           0   3235
3282: oJumpForward 3286
3284: oJumpBack 3233
3286: oReturn
3287: oLocalSpace 6
3289: oInputChoice 3513
3291: oGetAddrLocal 1
3293: oPushResult
3294: oNodeVecNew
3295: oAssign
3296: oGetAddrLocal 2
3298: oPushResult
3299: oGetParam 1
3301: oPushResult
3302: LAST_ID
3303: oPushResult
3304: oCall 14790
3306: oPop 2
3308: oAssign
3309: oGetLocal 1
3311: oPushResult
3312: oGetLocal 2
3314: oPushResult
3315: oNodeVecAppend
3316: oPop 2
3318: oInputChoice 3324
3320: oInput 0
3322: oJumpForward 3329
3324: Choice Lookup Table
          14   3320
3327: oJumpForward 3331
3329: oJumpBack 3296
3331: oInput 13
3333: oGetAddrLocal 3
3335: oPushResult
3336: oCall 12758
3338: oPop 1
3340: oGetAddrLocal 4
3342: oPushResult
3343: oSetResult 0
3345: oAssign
3346: oGetLocal 4
3348: oPushResult
3349: oGetLocal 1
3351: oPushResult
3352: oNodeVecSize
3353: oPop 1
3355: oPushResult
3356: equal
3357: oPop 2
3359: oChoice 3400
3361: oGetAddrLocal 2
3363: oPushResult
3364: oGetLocal 1
3366: oPushResult
3367: oGetLocal 4
3369: oPushResult
3370: oNodeVecElement
3371: oPop 2
3373: oAssign
3374: oGetLocal 2
3376: oPushResult
3377: oSetResult 21
3379: oPushResult
3380: oGetLocal 3
3382: oPushResult
3383: oNodeSet
3384: oPop 3
3386: oGetLocal 2
3388: oPushResult
3389: oScopeDeclareAlloc
3390: oPop 1
3392: oGetAddrLocal 4
3394: oPushResult
3395: inc
3396: oPop 1
3398: oJumpForward 3405
3400: Choice Lookup Table
           0   3361
3403: oJumpForward 3407
3405: oJumpBack 3346
3407: oInputChoice 3500
3409: oGetLocal 1
3411: oPushResult
3412: oNodeVecSize
3413: oPop 1
3415: oChoice 3419
3417: oJumpForward 3424
3419: Choice Lookup Table
           1   3417
3422: oError 23
3424: oGetAddrLocal 5
3426: oPushResult
3427: oScopeCurrent
3428: oPushResult
3429: oCall 14688
3431: oPop 1
3433: oAssign
3434: oGetLocal 5
3436: oPushResult
3437: oCodePush
3438: oPop 1
3440: oGetAddrLocal 6
3442: oPushResult
3443: oSetResult 0
3445: oAssign
3446: oCall 14740
3448: oPushResult
3449: equal_zero
3450: oPop 1
3452: oChoice 3468
3454: oGetGlobal 3
3456: oPushResult
3457: oScopeEnter
3458: oPop 1
3460: oGetAddrLocal 6
3462: oPushResult
3463: oSetResult 1
3465: oAssign
3466: oJumpForward 3471
3468: Choice Lookup Table
           1   3454
3471: oGetLocal 2
3473: oPushResult
3474: oSetResult 1
3476: oPushResult
3477: oCall 10201
3479: oPop 2
3481: oCall 5047
3483: oCall 8645
3485: oCall 9749
3487: oGetLocal 6
3489: oChoice 3494
3491: oScopeEnd
3492: oJumpForward 3497
3494: Choice Lookup Table
           1   3491
3497: oCodePop
3498: oJumpForward 3503
3500: Choice Lookup Table
           7   3409
3503: oGetLocal 1
3505: oPushResult
3506: oNodeVecDelete
3507: oPop 1
3509: oInput 6
3511: oJumpForward 3518
3513: Choice Lookup Table
           0   3291
3516: oJumpForward 3520
3518: oJumpBack 3289
3520: oReturn
3521: oLocalSpace 2
3523: oInputChoice 3530
3525: oJumpForward 3536
3527: oChangeIntLitToLabelIdent
3528: oJumpForward 3536
3530: Choice Lookup Table
           1   3527
           0   3525
3535: oEndChoice
3536: oGetAddrLocal 1
3538: oPushResult
3539: oSetResult 27
3541: oPushResult
3542: LAST_ID
3543: oPushResult
3544: oCall 14790
3546: oPop 2
3548: oAssign
3549: oGetAddrLocal 2
3551: oPushResult
3552: oLabelNew
3553: oAssign
3554: oGetLocal 1
3556: oPushResult
3557: oSetResult 22
3559: oPushResult
3560: oGetLocal 2
3562: oPushResult
3563: oNodeSetLabel
3564: oPop 3
3566: oGetLocal 1
3568: oPushResult
3569: oScopeDeclare
3570: oPop 1
3572: oInputChoice 3576
3574: oJumpForward 3581
3576: Choice Lookup Table
          14   3574
3579: oJumpForward 3583
3581: oJumpBack 3523
3583: oInput 6
3585: oReturn
3586: oLocalSpace 0
3588: oCall 3843
3590: oInputChoice 3802
3592: oCall 3866
3594: oCall 4599
3596: oTypeSNodeType
3597: oChoice 3612
3599: oValueStringCmp
3600: oSetResult 0
3602: oPushResult
3603: oValuePush
3604: oPop 1
3606: oValueEqual
3607: oJumpForward 3618
3609: oValueEqualD
3610: oJumpForward 3618
3612: Choice Lookup Table
          33   3609
          42   3599
3617: oValueEqual
3618: oTypeSPop
3619: oGetGlobal 7
3621: oPushResult
3622: oTypeSPush
3623: oPop 1
3625: oJumpForward 3817
3627: oCall 3843
3629: oCall 4599
3631: oTypeSNodeType
3632: oChoice 3647
3634: oValueStringCmp
3635: oSetResult 0
3637: oPushResult
3638: oValuePush
3639: oPop 1
3641: oValueNotEqual
3642: oJumpForward 3653
3644: oValueNotEqualD
3645: oJumpForward 3653
3647: Choice Lookup Table
          33   3644
          42   3634
3652: oValueNotEqual
3653: oTypeSPop
3654: oGetGlobal 7
3656: oPushResult
3657: oTypeSPush
3658: oPop 1
3660: oJumpForward 3817
3662: oCall 3843
3664: oCall 4599
3666: oTypeSNodeType
3667: oChoice 3682
3669: oValueStringCmp
3670: oSetResult 0
3672: oPushResult
3673: oValuePush
3674: oPop 1
3676: oValueLess
3677: oJumpForward 3688
3679: oValueLessD
3680: oJumpForward 3688
3682: Choice Lookup Table
          33   3679
          42   3669
3687: oValueLess
3688: oTypeSPop
3689: oGetGlobal 7
3691: oPushResult
3692: oTypeSPush
3693: oPop 1
3695: oJumpForward 3817
3697: oCall 3843
3699: oCall 4599
3701: oTypeSNodeType
3702: oChoice 3717
3704: oValueStringCmp
3705: oSetResult 0
3707: oPushResult
3708: oValuePush
3709: oPop 1
3711: oValueGreater
3712: oJumpForward 3723
3714: oValueGreaterD
3715: oJumpForward 3723
3717: Choice Lookup Table
          33   3714
          42   3704
3722: oValueGreater
3723: oTypeSPop
3724: oGetGlobal 7
3726: oPushResult
3727: oTypeSPush
3728: oPop 1
3730: oJumpForward 3817
3732: oCall 3843
3734: oCall 4599
3736: oTypeSNodeType
3737: oChoice 3752
3739: oValueStringCmp
3740: oSetResult 0
3742: oPushResult
3743: oValuePush
3744: oPop 1
3746: oValueLessEqual
3747: oJumpForward 3758
3749: oValueLessEqualD
3750: oJumpForward 3758
3752: Choice Lookup Table
          33   3749
          42   3739
3757: oValueLessEqual
3758: oTypeSPop
3759: oGetGlobal 7
3761: oPushResult
3762: oTypeSPush
3763: oPop 1
3765: oJumpForward 3817
3767: oCall 3843
3769: oCall 4599
3771: oTypeSNodeType
3772: oChoice 3787
3774: oValueStringCmp
3775: oSetResult 0
3777: oPushResult
3778: oValuePush
3779: oPop 1
3781: oValueGreaterEqual
3782: oJumpForward 3793
3784: oValueGreaterEqualD
3785: oJumpForward 3793
3787: Choice Lookup Table
          33   3784
          42   3774
3792: oValueGreaterEqual
3793: oTypeSPop
3794: oGetGlobal 7
3796: oPushResult
3797: oTypeSPush
3798: oPop 1
3800: oJumpForward 3817
3802: Choice Lookup Table
          12   3767
          11   3732
          10   3697
           9   3662
           8   3627
           7   3592
3815: oJumpForward 3819
3817: oJumpBack 3590
3819: oReturn
3820: oLocalSpace 1
3822: oGetAddrLocal 1
3824: oPushResult
3825: oGetGlobal 25
3827: oAssign
3828: oGetAddrGlobal 25
3830: oPushResult
3831: oSetResult 1
3833: oAssign
3834: oCall 3586
3836: oGetAddrGlobal 25
3838: oPushResult
3839: oGetLocal 1
3841: oAssign
3842: oReturn
3843: oLocalSpace 0
3845: oCall 3866
3847: oInputChoice 3858
3849: oCall 4368
3851: oCall 3866
3853: oCall 4354
3855: oValueOr
3856: oJumpForward 3863
3858: Choice Lookup Table
          58   3849
3861: oJumpForward 3865
3863: oJumpBack 3847
3865: oReturn
3866: oLocalSpace 0
3868: oCall 3889
3870: oInputChoice 3881
3872: oCall 4368
3874: oCall 3889
3876: oCall 4354
3878: oValueAnd
3879: oJumpForward 3886
3881: Choice Lookup Table
          57   3872
3884: oJumpForward 3888
3886: oJumpBack 3870
3888: oReturn
3889: oLocalSpace 0
3891: oInputChoice 3900
3893: oCall 3889
3895: oCall 4368
3897: oValueNot
3898: oJumpForward 3905
3900: Choice Lookup Table
          59   3893
3903: oCall 3906
3905: oReturn
3906: oLocalSpace 0
3908: oCall 3965
3910: oInputChoice 3955
3912: oCall 3965
3914: oCall 4599
3916: oTypeSNodeType
3917: oChoice 3925
3919: oValueStringConcat
3920: oJumpForward 3931
3922: oValueAddD
3923: oJumpForward 3931
3925: Choice Lookup Table
          33   3922
          42   3919
3930: oValueAdd
3931: oJumpForward 3962
3933: oCall 3965
3935: oCall 4599
3937: oTypeSNodeType
3938: oChoice 3947
3940: oError 18
3942: oJumpForward 3953
3944: oValueSubD
3945: oJumpForward 3953
3947: Choice Lookup Table
          33   3944
          42   3940
3952: oValueSub
3953: oJumpForward 3962
3955: Choice Lookup Table
          26   3933
          25   3912
3960: oJumpForward 3964
3962: oJumpBack 3910
3964: oReturn
3965: oLocalSpace 0
3967: oCall 4025
3969: oInputChoice 4015
3971: oCall 4025
3973: oCall 4599
3975: oTypeSNodeType
3976: oChoice 3985
3978: oError 18
3980: oJumpForward 3991
3982: oValueMultD
3983: oJumpForward 3991
3985: Choice Lookup Table
          33   3982
          42   3978
3990: oValueMult
3991: oJumpForward 4022
3993: oCall 4025
3995: oCall 4599
3997: oTypeSNodeType
3998: oChoice 4007
4000: oError 18
4002: oJumpForward 4013
4004: oValueDivD
4005: oJumpForward 4013
4007: Choice Lookup Table
          33   4004
          42   4000
4012: oValueDiv
4013: oJumpForward 4022
4015: Choice Lookup Table
          24   3993
          23   3971
4020: oJumpForward 4024
4022: oJumpBack 3969
4024: oReturn
4025: oLocalSpace 0
4027: oInputChoice 4053
4029: oCall 4061
4031: oJumpForward 4060
4033: oCall 4061
4035: oTypeSNodeType
4036: oChoice 4045
4038: oError 18
4040: oJumpForward 4051
4042: oValueNegateD
4043: oJumpForward 4051
4045: Choice Lookup Table
          33   4042
          42   4038
4050: oValueNegate
4051: oJumpForward 4060
4053: Choice Lookup Table
          26   4033
          25   4029
4058: oCall 4061
4060: oReturn
4061: oLocalSpace 1
4063: oInputChoice 4324
4065: TOKEN_VALUE
4066: oPushResult
4067: oValuePush
4068: oPop 1
4070: oGetGlobal 6
4072: oPushResult
4073: oTypeSPush
4074: oPop 1
4076: oJumpForward 4353
4078: TOKEN_VALUE
4079: oPushResult
4080: oValuePush
4081: oPop 1
4083: oGetGlobal 9
4085: oPushResult
4086: oTypeSPush
4087: oPop 1
4089: oJumpForward 4353
4091: TOKEN_VALUE_DOUBLE
4092: oPushResult
4093: oValuePushDouble
4094: oPop 1
4096: oGetGlobal 13
4098: oPushResult
4099: oTypeSPush
4100: oPop 1
4102: oJumpForward 4353
4104: CURRENT_STRLIT
4105: oPushResult
4106: oValuePushString
4107: oPop 1
4109: oGetGlobal 15
4111: oPushResult
4112: oTypeSPush
4113: oPop 1
4115: oJumpForward 4353
4117: oCall 3586
4119: oInput 16
4121: oJumpForward 4353
4123: oGetAddrLocal 1
4125: oPushResult
4126: oScopeFindRequire
4127: oAssign
4128: oGetAddrLocal 1
4130: oPushResult
4131: oCall 244
4133: oPop 1
4135: oGetLocal 1
4137: oPushResult
4138: oNodeType
4139: oPop 1
4141: oChoice 4281
4143: oGetLocal 1
4145: oPushResult
4146: oCall 4781
4148: oPop 1
4150: oJumpForward 4306
4152: oGetLocal 1
4154: oPushResult
4155: oSetResult 22
4157: oPushResult
4158: oNodeGetInt
4159: oPop 2
4161: oPushResult
4162: oValuePush
4163: oPop 1
4165: oGetLocal 1
4167: oPushResult
4168: oSetResult 21
4170: oPushResult
4171: oNodeGet
4172: oPop 2
4174: oPushResult
4175: oTypeSPush
4176: oPop 1
4178: oJumpForward 4306
4180: oGetLocal 1
4182: oPushResult
4183: oSetResult 33
4185: oPushResult
4186: oNodeGetString
4187: oPop 2
4189: oPushResult
4190: oValuePushString
4191: oPop 1
4193: oGetLocal 1
4195: oPushResult
4196: oSetResult 21
4198: oPushResult
4199: oNodeGet
4200: oPop 2
4202: oPushResult
4203: oTypeSPush
4204: oPop 1
4206: oJumpForward 4306
4208: oGetLocal 1
4210: oPushResult
4211: oSetResult 22
4213: oPushResult
4214: oNodeGetInt
4215: oPop 2
4217: oPushResult
4218: oValuePush
4219: oPop 1
4221: oGetLocal 1
4223: oPushResult
4224: oSetResult 21
4226: oPushResult
4227: oNodeGet
4228: oPop 2
4230: oPushResult
4231: oTypeSPush
4232: oPop 1
4234: oJumpForward 4306
4236: oGetLocal 1
4238: oPushResult
4239: oSetResult 21
4241: oPushResult
4242: oNodeGet
4243: oPop 2
4245: oPushResult
4246: oTypeSPush
4247: oPop 1
4249: oInputChoice 4259
4251: oCall 3586
4253: oInput 16
4255: oCall 4604
4257: oJumpForward 4279
4259: Choice Lookup Table
          15   4251
4262: oGetGlobal 25
4264: oChoice 4274
4266: oSetResult 0
4268: oPushResult
4269: oValuePush
4270: oPop 1
4272: oJumpForward 4279
4274: Choice Lookup Table
           1   4266
4277: oError 33
4279: oJumpForward 4306
4281: Choice Lookup Table
          20   4236
          17   4208
          18   4180
          16   4152
          14   4143
4292: oError 1
4294: oSetResult 0
4296: oPushResult
4297: oValuePush
4298: oPop 1
4300: oGetGlobal 6
4302: oPushResult
4303: oTypeSPush
4304: oPop 1
4306: oJumpForward 4353
4308: oError 17
4310: oSetResult 0
4312: oPushResult
4313: oValuePush
4314: oPop 1
4316: oGetGlobal 14
4318: oPushResult
4319: oTypeSPush
4320: oPop 1
4322: oJumpForward 4353
4324: Choice Lookup Table
          20   4308
           0   4123
          15   4117
           3   4104
           2   4091
           4   4078
           1   4065
4339: oError 1
4341: oSetResult 0
4343: oPushResult
4344: oValuePush
4345: oPop 1
4347: oGetGlobal 6
4349: oPushResult
4350: oTypeSPush
4351: oPop 1
4353: oReturn
4354: oLocalSpace 0
4356: oTypeSNodeType
4357: oChoice 4361
4359: oJumpForward 4366
4361: Choice Lookup Table
          34   4359
4364: oError 8
4366: oTypeSPop
4367: oReturn
4368: oLocalSpace 0
4370: oTypeSNodeType
4371: oChoice 4375
4373: oJumpForward 4380
4375: Choice Lookup Table
          34   4373
4378: oError 8
4380: oReturn
4381: oLocalSpace 1
4383: oGetAddrLocal 1
4385: oPushResult
4386: oTypeSNodeType
4387: oAssign
4388: oTypeSPop
4389: oGetLocal 1
4391: oPushResult
4392: oTypeSNodeType
4393: oPushResult
4394: equal_node_type
4395: oPop 2
4397: oChoice 4474
4399: oTypeSNodeType
4400: oChoice 4461
4402: oGetLocal 1
4404: oChoice 4409
4406: oReturn
4407: oJumpForward 4412
4409: Choice Lookup Table
          38   4406
4412: oJumpForward 4470
4414: oGetLocal 1
4416: oChoice 4421
4418: oReturn
4419: oJumpForward 4424
4421: Choice Lookup Table
          37   4418
4424: oJumpForward 4470
4426: oGetLocal 1
4428: oChoice 4434
4430: oValueCharToString
4431: oReturn
4432: oJumpForward 4437
4434: Choice Lookup Table
          36   4430
4437: oJumpForward 4470
4439: oGetLocal 1
4441: oChoice 4456
4443: oValueSwap
4444: oValueCharToString
4445: oValueSwap
4446: oTypeSPop
4447: oGetGlobal 15
4449: oPushResult
4450: oTypeSPush
4451: oPop 1
4453: oReturn
4454: oJumpForward 4459
4456: Choice Lookup Table
          42   4443
4459: oJumpForward 4470
4461: Choice Lookup Table
          36   4439
          42   4426
          38   4414
          37   4402
4470: oError 15
4472: oJumpForward 4477
4474: Choice Lookup Table
           0   4399
4477: oReturn
4478: oLocalSpace 1
4480: oGetAddrLocal 1
4482: oPushResult
4483: oTypeSNodeType
4484: oAssign
4485: oTypeSPop
4486: oGetLocal 1
4488: oPushResult
4489: oTypeSNodeType
4490: oPushResult
4491: equal_node_type
4492: oPop 2
4494: oChoice 4595
4496: oTypeSNodeType
4497: oChoice 4578
4499: oGetLocal 1
4501: oChoice 4506
4503: oReturn
4504: oJumpForward 4509
4506: Choice Lookup Table
          30   4503
4509: oJumpForward 4591
4511: oGetLocal 1
4513: oChoice 4518
4515: oReturn
4516: oJumpForward 4521
4518: Choice Lookup Table
          31   4515
4521: oJumpForward 4591
4523: oGetLocal 1
4525: oChoice 4530
4527: oReturn
4528: oJumpForward 4533
4530: Choice Lookup Table
          38   4527
4533: oJumpForward 4591
4535: oGetLocal 1
4537: oChoice 4542
4539: oReturn
4540: oJumpForward 4545
4542: Choice Lookup Table
          37   4539
4545: oJumpForward 4591
4547: oGetLocal 1
4549: oChoice 4555
4551: oValueCharToString
4552: oReturn
4553: oJumpForward 4558
4555: Choice Lookup Table
          36   4551
4558: oJumpForward 4591
4560: oGetLocal 1
4562: oChoice 4571
4564: oReturn
4565: oJumpForward 4576
4567: oValueCharToString
4568: oReturn
4569: oJumpForward 4576
4571: Choice Lookup Table
          36   4567
          42   4564
4576: oJumpForward 4591
4578: Choice Lookup Table
          43   4560
          42   4547
          38   4535
          37   4523
          30   4511
          31   4499
4591: oError 15
4593: oJumpForward 4598
4595: Choice Lookup Table
           0   4496
4598: oReturn
4599: oLocalSpace 0
4601: oCall 4381
4603: oReturn
4604: oLocalSpace 1
4606: oGetAddrLocal 1
4608: oPushResult
4609: oTypeSNodeType
4610: oAssign
4611: oTypeSPop
4612: oGetLocal 1
4614: oPushResult
4615: oTypeSNodeType
4616: oPushResult
4617: equal_node_type
4618: oPop 2
4620: oChoice 4777
4622: oTypeSNodeType
4623: oChoice 4752
4625: oGetLocal 1
4627: oChoice 4635
4629: oReturn
4630: oJumpForward 4646
4632: oReturn
4633: oJumpForward 4646
4635: Choice Lookup Table
          44   4632
          31   4632
          34   4629
          36   4629
          30   4629
4646: oJumpForward 4773
4648: oGetLocal 1
4650: oChoice 4658
4652: oReturn
4653: oJumpForward 4669
4655: oReturn
4656: oJumpForward 4669
4658: Choice Lookup Table
          44   4655
          31   4655
          34   4652
          36   4652
          30   4652
4669: oJumpForward 4773
4671: oGetLocal 1
4673: oChoice 4682
4675: oValueIntToDouble
4676: oReturn
4677: oJumpForward 4695
4679: oReturn
4680: oJumpForward 4695
4682: Choice Lookup Table
          33   4679
          44   4675
          31   4675
          34   4675
          36   4675
          30   4675
4695: oJumpForward 4773
4697: oGetLocal 1
4699: oChoice 4704
4701: oReturn
4702: oJumpForward 4707
4704: Choice Lookup Table
          38   4701
4707: oJumpForward 4773
4709: oGetLocal 1
4711: oChoice 4716
4713: oReturn
4714: oJumpForward 4719
4716: Choice Lookup Table
          37   4713
4719: oJumpForward 4773
4721: oGetLocal 1
4723: oChoice 4729
4725: oValueCharToString
4726: oReturn
4727: oJumpForward 4732
4729: Choice Lookup Table
          36   4725
4732: oJumpForward 4773
4734: oGetLocal 1
4736: oChoice 4745
4738: oReturn
4739: oJumpForward 4750
4741: oValueCharToString
4742: oReturn
4743: oJumpForward 4750
4745: Choice Lookup Table
          36   4741
          42   4738
4750: oJumpForward 4773
4752: Choice Lookup Table
          43   4734
          42   4721
          38   4709
          37   4697
          33   4671
          34   4648
          36   4648
          30   4648
          44   4625
          31   4625
4773: oError 15
4775: oJumpForward 4780
4777: Choice Lookup Table
           0   4622
4780: oReturn
4781: oLocalSpace 1
4783: oGetParam 1
4785: oPushResult
4786: oGetGlobal 17
4788: oPushResult
4789: oNodeEqual
4790: oPop 2
4792: oChoice 4832
4794: oInput 15
4796: oCall 3586
4798: oInput 16
4800: oTypeSNodeType
4801: oChoice 4807
4803: oJumpForward 4820
4805: oJumpForward 4820
4807: Choice Lookup Table
          36   4805
          30   4805
          34   4805
          44   4803
          31   4803
4818: oError 15
4820: oTypeSPop
4821: oGetGlobal 6
4823: oPushResult
4824: oTypeSPush
4825: oPop 1
4827: oInput 16
4829: oReturn
4830: oJumpForward 4835
4832: Choice Lookup Table
           1   4794
4835: oGetParam 1
4837: oPushResult
4838: oGetGlobal 18
4840: oPushResult
4841: oNodeEqual
4842: oPop 2
4844: oChoice 4878
4846: oInput 15
4848: oCall 3586
4850: oInput 16
4852: oTypeSNodeType
4853: oChoice 4859
4855: oJumpForward 4866
4857: oJumpForward 4866
4859: Choice Lookup Table
          30   4857
          31   4855
4864: oError 15
4866: oTypeSPop
4867: oGetGlobal 9
4869: oPushResult
4870: oTypeSPush
4871: oPop 1
4873: oInput 16
4875: oReturn
4876: oJumpForward 4881
4878: Choice Lookup Table
           1   4846
4881: oGetParam 1
4883: oPushResult
4884: oGetGlobal 19
4886: oPushResult
4887: oNodeEqual
4888: oPop 2
4890: oChoice 4935
4892: oInput 15
4894: oCall 3586
4896: oTypeSNodeType
4897: oChoice 4918
4899: oTypeSTop
4900: oPushResult
4901: oSetResult 45
4903: oPushResult
4904: oNodeGetBoolean
4905: oPop 2
4907: oChoice 4913
4909: oError 30
4911: oJumpForward 4916
4913: Choice Lookup Table
           1   4909
4916: oJumpForward 4923
4918: Choice Lookup Table
          44   4899
4921: oError 15
4923: oSetResult 1
4925: oPushResult
4926: oValuePush
4927: oPop 1
4929: oValueSub
4930: oInput 16
4932: oReturn
4933: oJumpForward 4938
4935: Choice Lookup Table
           1   4892
4938: oGetParam 1
4940: oPushResult
4941: oGetGlobal 20
4943: oPushResult
4944: oNodeEqual
4945: oPop 2
4947: oChoice 4992
4949: oInput 15
4951: oCall 3586
4953: oTypeSNodeType
4954: oChoice 4975
4956: oTypeSTop
4957: oPushResult
4958: oSetResult 45
4960: oPushResult
4961: oNodeGetBoolean
4962: oPop 2
4964: oChoice 4970
4966: oError 30
4968: oJumpForward 4973
4970: Choice Lookup Table
           1   4966
4973: oJumpForward 4980
4975: Choice Lookup Table
          44   4956
4978: oError 15
4980: oSetResult 1
4982: oPushResult
4983: oValuePush
4984: oPop 1
4986: oValueAdd
4987: oInput 16
4989: oReturn
4990: oJumpForward 4995
4992: Choice Lookup Table
           1   4949
4995: oGetParam 1
4997: oPushResult
4998: oGetGlobal 21
5000: oPushResult
5001: oNodeEqual
5002: oPop 2
5004: oChoice 5041
5006: oInput 15
5008: oCall 3820
5010: oValuePop
5011: oGetAddrLocal 1
5013: oPushResult
5014: oTypeSTop
5015: oAssign
5016: oTypeSPop
5017: oGetLocal 1
5019: oPushResult
5020: oSetResult 17
5022: oPushResult
5023: oNodeGetInt
5024: oPop 2
5026: oPushResult
5027: oValuePush
5028: oPop 1
5030: oGetGlobal 6
5032: oPushResult
5033: oTypeSPush
5034: oPop 1
5036: oInput 16
5038: oReturn
5039: oJumpForward 5044
5041: Choice Lookup Table
           1   5006
5044: oError 17
5046: oReturn
5047: oLocalSpace 1
5049: oGetAddrLocal 1
5051: oPushResult
5052: oSetResult 0
5054: oAssign
5055: oGetAddrLocal 1
5057: oPushResult
5058: oCall 5231
5060: oPop 1
5062: oGetAddrLocal 1
5064: oPushResult
5065: oCall 5131
5067: oPop 1
5069: oReturn
5070: oLocalSpace 1
5072: oGetAddrLocal 1
5074: oPushResult
5075: oGetGlobal 25
5077: oAssign
5078: oGetAddrGlobal 25
5080: oPushResult
5081: oSetResult 1
5083: oAssign
5084: oCall 5047
5086: oGetAddrGlobal 25
5088: oPushResult
5089: oGetLocal 1
5091: oAssign
5092: oReturn
5093: oLocalSpace 0
5095: oGetParam 1
5097: oPushResult
5098: oCall 5231
5100: oPop 1
5102: oTypeSNodeType
5103: oChoice 5122
5105: oJumpForward 5129
5107: oGetParam 1
5109: oPushResult
5110: oLabelNew
5111: oAssign
5112: oEmit 84
5114: oGetFromParam 1
5116: oPushResult
5117: oEmitLabel
5118: oPop 1
5120: oJumpForward 5129
5122: Choice Lookup Table
          34   5107
          35   5105
5127: oError 8
5129: oTypeSPop
5130: oReturn
5131: oLocalSpace 1
5133: oTypeSNodeType
5134: oChoice 5196
5136: oGetAddrLocal 1
5138: oPushResult
5139: oLabelNew
5140: oAssign
5141: oEmit 15
5143: oSetResult 1
5145: oPushResult
5146: oEmitInt
5147: oPop 1
5149: oEmit 82
5151: oGetLocal 1
5153: oPushResult
5154: oEmitLabel
5155: oPop 1
5157: oEmit 91
5159: oGetFromParam 1
5161: oPushResult
5162: oEmitLabel
5163: oPop 1
5165: oEmit 15
5167: oSetResult 0
5169: oPushResult
5170: oEmitInt
5171: oPop 1
5173: oEmit 91
5175: oGetLocal 1
5177: oPushResult
5178: oEmitLabel
5179: oPop 1
5181: oTypeSPop
5182: oGetGlobal 7
5184: oPushResult
5185: oTypeSPush
5186: oPop 1
5188: oGetParam 1
5190: oPushResult
5191: oSetResult 0
5193: oAssign
5194: oJumpForward 5199
5196: Choice Lookup Table
          35   5136
5199: oReturn
5200: oLocalSpace 0
5202: oTypeSNodeType
5203: oChoice 5227
5205: oGetParam 1
5207: oPushResult
5208: oLabelNew
5209: oAssign
5210: oEmit 84
5212: oGetFromParam 1
5214: oPushResult
5215: oEmitLabel
5216: oPop 1
5218: oTypeSPop
5219: oGetGlobal 8
5221: oPushResult
5222: oTypeSPush
5223: oPop 1
5225: oJumpForward 5230
5227: Choice Lookup Table
          34   5205
5230: oReturn
5231: oLocalSpace 0
5233: oGetParam 1
5235: oPushResult
5236: oCall 5800
5238: oPop 1
5240: oInputChoice 5782
5242: oGetParam 1
5244: oPushResult
5245: oCall 5131
5247: oPop 1
5249: oCall 9414
5251: oGetParam 1
5253: oPushResult
5254: oCall 5800
5256: oPop 1
5258: oGetParam 1
5260: oPushResult
5261: oCall 5131
5263: oPop 1
5265: oCall 9414
5267: oCall 8818
5269: oTypeSNodeType
5270: oChoice 5302
5272: oEmit 51
5274: oJumpForward 5323
5276: oEmit 57
5278: oJumpForward 5323
5280: oEmit 69
5282: oJumpForward 5323
5284: oEmit 63
5286: oJumpForward 5323
5288: oCall 11684
5290: oEmit 15
5292: oSetResult 0
5294: oPushResult
5295: oEmitInt
5296: oPop 1
5298: oEmit 57
5300: oJumpForward 5323
5302: Choice Lookup Table
          42   5288
          43   5288
          38   5284
          37   5284
          33   5280
          44   5276
          31   5276
          36   5272
          34   5272
5321: oError 18
5323: oTypeSPop
5324: oGetGlobal 7
5326: oPushResult
5327: oTypeSPush
5328: oPop 1
5330: oJumpForward 5797
5332: oGetParam 1
5334: oPushResult
5335: oCall 5131
5337: oPop 1
5339: oCall 9414
5341: oGetParam 1
5343: oPushResult
5344: oCall 5800
5346: oPop 1
5348: oGetParam 1
5350: oPushResult
5351: oCall 5131
5353: oPop 1
5355: oCall 9414
5357: oCall 8818
5359: oTypeSNodeType
5360: oChoice 5392
5362: oEmit 52
5364: oJumpForward 5413
5366: oEmit 58
5368: oJumpForward 5413
5370: oEmit 70
5372: oJumpForward 5413
5374: oEmit 64
5376: oJumpForward 5413
5378: oCall 11684
5380: oEmit 15
5382: oSetResult 0
5384: oPushResult
5385: oEmitInt
5386: oPop 1
5388: oEmit 58
5390: oJumpForward 5413
5392: Choice Lookup Table
          42   5378
          43   5378
          38   5374
          37   5374
          33   5370
          44   5366
          31   5366
          36   5362
          34   5362
5411: oError 18
5413: oTypeSPop
5414: oGetGlobal 7
5416: oPushResult
5417: oTypeSPush
5418: oPop 1
5420: oJumpForward 5797
5422: oGetParam 1
5424: oPushResult
5425: oCall 5131
5427: oPop 1
5429: oCall 9414
5431: oGetParam 1
5433: oPushResult
5434: oCall 5800
5436: oPop 1
5438: oGetParam 1
5440: oPushResult
5441: oCall 5131
5443: oPop 1
5445: oCall 9414
5447: oCall 8818
5449: oTypeSNodeType
5450: oChoice 5482
5452: oEmit 54
5454: oJumpForward 5503
5456: oEmit 60
5458: oJumpForward 5503
5460: oEmit 72
5462: oJumpForward 5503
5464: oEmit 66
5466: oJumpForward 5503
5468: oCall 11684
5470: oEmit 15
5472: oSetResult 0
5474: oPushResult
5475: oEmitInt
5476: oPop 1
5478: oEmit 60
5480: oJumpForward 5503
5482: Choice Lookup Table
          42   5468
          43   5468
          38   5464
          37   5464
          33   5460
          44   5456
          31   5456
          36   5452
          34   5452
5501: oError 18
5503: oTypeSPop
5504: oGetGlobal 7
5506: oPushResult
5507: oTypeSPush
5508: oPop 1
5510: oJumpForward 5797
5512: oGetParam 1
5514: oPushResult
5515: oCall 5131
5517: oPop 1
5519: oCall 9414
5521: oGetParam 1
5523: oPushResult
5524: oCall 5800
5526: oPop 1
5528: oGetParam 1
5530: oPushResult
5531: oCall 5131
5533: oPop 1
5535: oCall 9414
5537: oCall 8818
5539: oTypeSNodeType
5540: oChoice 5572
5542: oEmit 53
5544: oJumpForward 5593
5546: oEmit 59
5548: oJumpForward 5593
5550: oEmit 71
5552: oJumpForward 5593
5554: oEmit 65
5556: oJumpForward 5593
5558: oCall 11684
5560: oEmit 15
5562: oSetResult 0
5564: oPushResult
5565: oEmitInt
5566: oPop 1
5568: oEmit 59
5570: oJumpForward 5593
5572: Choice Lookup Table
          42   5558
          43   5558
          38   5554
          37   5554
          33   5550
          44   5546
          31   5546
          36   5542
          34   5542
5591: oError 18
5593: oTypeSPop
5594: oGetGlobal 7
5596: oPushResult
5597: oTypeSPush
5598: oPop 1
5600: oJumpForward 5797
5602: oGetParam 1
5604: oPushResult
5605: oCall 5131
5607: oPop 1
5609: oCall 9414
5611: oGetParam 1
5613: oPushResult
5614: oCall 5800
5616: oPop 1
5618: oGetParam 1
5620: oPushResult
5621: oCall 5131
5623: oPop 1
5625: oCall 9414
5627: oCall 8818
5629: oTypeSNodeType
5630: oChoice 5662
5632: oEmit 56
5634: oJumpForward 5683
5636: oEmit 62
5638: oJumpForward 5683
5640: oEmit 74
5642: oJumpForward 5683
5644: oEmit 68
5646: oJumpForward 5683
5648: oCall 11684
5650: oEmit 15
5652: oSetResult 0
5654: oPushResult
5655: oEmitInt
5656: oPop 1
5658: oEmit 62
5660: oJumpForward 5683
5662: Choice Lookup Table
          42   5648
          43   5648
          38   5644
          37   5644
          33   5640
          44   5636
          31   5636
          36   5632
          34   5632
5681: oError 18
5683: oTypeSPop
5684: oGetGlobal 7
5686: oPushResult
5687: oTypeSPush
5688: oPop 1
5690: oJumpForward 5797
5692: oGetParam 1
5694: oPushResult
5695: oCall 5131
5697: oPop 1
5699: oCall 9414
5701: oGetParam 1
5703: oPushResult
5704: oCall 5800
5706: oPop 1
5708: oGetParam 1
5710: oPushResult
5711: oCall 5131
5713: oPop 1
5715: oCall 9414
5717: oCall 8818
5719: oTypeSNodeType
5720: oChoice 5752
5722: oEmit 55
5724: oJumpForward 5773
5726: oEmit 61
5728: oJumpForward 5773
5730: oEmit 73
5732: oJumpForward 5773
5734: oEmit 67
5736: oJumpForward 5773
5738: oCall 11684
5740: oEmit 15
5742: oSetResult 0
5744: oPushResult
5745: oEmitInt
5746: oPop 1
5748: oEmit 61
5750: oJumpForward 5773
5752: Choice Lookup Table
          42   5738
          43   5738
          38   5734
          37   5734
          33   5730
          44   5726
          31   5726
          36   5722
          34   5722
5771: oError 18
5773: oTypeSPop
5774: oGetGlobal 7
5776: oPushResult
5777: oTypeSPush
5778: oPop 1
5780: oJumpForward 5797
5782: Choice Lookup Table
          12   5692
          11   5602
          10   5512
           9   5422
           8   5332
           7   5242
5795: oJumpForward 5799
5797: oJumpBack 5240
5799: oReturn
5800: oLocalSpace 1
5802: oGetAddrLocal 1
5804: oPushResult
5805: oSetResult 0
5807: oAssign
5808: oGetParam 1
5810: oPushResult
5811: oCall 5980
5813: oPop 1
5815: oInputChoice 5948
5817: oTypeSNodeType
5818: oChoice 5889
5820: oGetLocal 1
5822: oPushResult
5823: oSetResult 0
5825: oPushResult
5826: equal_label
5827: oPop 2
5829: oChoice 5838
5831: oGetAddrLocal 1
5833: oPushResult
5834: oLabelNew
5835: oAssign
5836: oJumpForward 5841
5838: Choice Lookup Table
           1   5831
5841: oEmit 82
5843: oGetLocal 1
5845: oPushResult
5846: oEmitLabel
5847: oPop 1
5849: oJumpForward 5896
5851: oGetParam 1
5853: oPushResult
5854: oCall 5200
5856: oPop 1
5858: oGetLocal 1
5860: oPushResult
5861: oSetResult 0
5863: oPushResult
5864: equal_label
5865: oPop 2
5867: oChoice 5876
5869: oGetAddrLocal 1
5871: oPushResult
5872: oLabelNew
5873: oAssign
5874: oJumpForward 5879
5876: Choice Lookup Table
           1   5869
5879: oEmit 82
5881: oGetLocal 1
5883: oPushResult
5884: oEmitLabel
5885: oPop 1
5887: oJumpForward 5896
5889: Choice Lookup Table
          34   5851
          35   5820
5894: oError 8
5896: oTypeSPop
5897: oEmit 91
5899: oGetFromParam 1
5901: oPushResult
5902: oEmitLabel
5903: oPop 1
5905: oGetParam 1
5907: oPushResult
5908: oSetResult 0
5910: oAssign
5911: oGetParam 1
5913: oPushResult
5914: oCall 5980
5916: oPop 1
5918: oTypeSNodeType
5919: oChoice 5932
5921: oJumpForward 5939
5923: oGetParam 1
5925: oPushResult
5926: oCall 5200
5928: oPop 1
5930: oJumpForward 5939
5932: Choice Lookup Table
          34   5923
          35   5921
5937: oError 8
5939: oTypeSPop
5940: oGetGlobal 8
5942: oPushResult
5943: oTypeSPush
5944: oPop 1
5946: oJumpForward 5953
5948: Choice Lookup Table
          58   5817
5951: oJumpForward 5955
5953: oJumpBack 5815
5955: oGetLocal 1
5957: oPushResult
5958: oSetResult 0
5960: oPushResult
5961: equal_label
5962: oPop 2
5964: oChoice 5976
5966: oEmit 91
5968: oGetLocal 1
5970: oPushResult
5971: oEmitLabel
5972: oPop 1
5974: oJumpForward 5979
5976: Choice Lookup Table
           0   5966
5979: oReturn
5980: oLocalSpace 2
5982: oGetAddrLocal 1
5984: oPushResult
5985: oSetResult 0
5987: oAssign
5988: oGetParam 1
5990: oPushResult
5991: oCall 6118
5993: oPop 1
5995: oInputChoice 6110
5997: oTypeSNodeType
5998: oChoice 6011
6000: oJumpForward 6018
6002: oGetParam 1
6004: oPushResult
6005: oCall 5200
6007: oPop 1
6009: oJumpForward 6018
6011: Choice Lookup Table
          34   6002
          35   6000
6016: oError 8
6018: oTypeSPop
6019: oGetLocal 1
6021: oPushResult
6022: oSetResult 0
6024: oPushResult
6025: equal_label
6026: oPop 2
6028: oChoice 6057
6030: oGetAddrLocal 1
6032: oPushResult
6033: oLabelNew
6034: oAssign
6035: oEmit 92
6037: oGetFromParam 1
6039: oPushResult
6040: oEmitLabel
6041: oPop 1
6043: oGetLocal 1
6045: oPushResult
6046: oEmitLabel
6047: oPop 1
6049: oGetParam 1
6051: oPushResult
6052: oGetLocal 1
6054: oAssign
6055: oJumpForward 6060
6057: Choice Lookup Table
           1   6030
6060: oGetAddrLocal 2
6062: oPushResult
6063: oSetResult 0
6065: oAssign
6066: oGetAddrLocal 2
6068: oPushResult
6069: oCall 6118
6071: oPop 1
6073: oTypeSNodeType
6074: oChoice 6087
6076: oJumpForward 6094
6078: oGetAddrLocal 2
6080: oPushResult
6081: oCall 5200
6083: oPop 1
6085: oJumpForward 6094
6087: Choice Lookup Table
          34   6078
          35   6076
6092: oError 8
6094: oEmit 92
6096: oGetLocal 2
6098: oPushResult
6099: oEmitLabel
6100: oPop 1
6102: oGetLocal 1
6104: oPushResult
6105: oEmitLabel
6106: oPop 1
6108: oJumpForward 6115
6110: Choice Lookup Table
          57   5997
6113: oJumpForward 6117
6115: oJumpBack 5995
6117: oReturn
6118: oLocalSpace 1
6120: oInputChoice 6174
6122: oGetAddrLocal 1
6124: oPushResult
6125: oSetResult 0
6127: oAssign
6128: oGetAddrLocal 1
6130: oPushResult
6131: oCall 6118
6133: oPop 1
6135: oTypeSNodeType
6136: oChoice 6165
6138: oGetParam 1
6140: oPushResult
6141: oLabelNew
6142: oAssign
6143: oEmit 82
6145: oGetFromParam 1
6147: oPushResult
6148: oEmitLabel
6149: oPop 1
6151: oEmit 91
6153: oGetLocal 1
6155: oPushResult
6156: oEmitLabel
6157: oPop 1
6159: oJumpForward 6172
6161: oEmit 50
6163: oJumpForward 6172
6165: Choice Lookup Table
          34   6161
          35   6138
6170: oError 8
6172: oJumpForward 6184
6174: Choice Lookup Table
          59   6122
6177: oGetParam 1
6179: oPushResult
6180: oCall 6185
6182: oPop 1
6184: oReturn
6185: oLocalSpace 2
6187: oGetAddrLocal 1
6189: oPushResult
6190: oSetResult 1
6192: oAssign
6193: oGetParam 1
6195: oPushResult
6196: oCall 6477
6198: oPop 1
6200: oInputChoice 6467
6202: oTypeSNodeType
6203: oChoice 6349
6205: oCall 9368
6207: oGetParam 1
6209: oPushResult
6210: oCall 6477
6212: oPop 1
6214: oTypeSNodeType
6215: oChoice 6231
6217: oEmit 23
6219: oCall 8430
6221: oJumpForward 6242
6223: oEmit 23
6225: oEmit 34
6227: oEmit 47
6229: oJumpForward 6242
6231: Choice Lookup Table
          33   6223
          38   6217
          37   6217
6238: oCall 9388
6240: oEmit 40
6242: oJumpForward 6368
6244: oGetParam 1
6246: oPushResult
6247: oCall 6477
6249: oPop 1
6251: oCall 9434
6253: oEmit 47
6255: oJumpForward 6368
6257: oGetLocal 1
6259: oChoice 6275
6261: oGetAddrLocal 2
6263: oPushResult
6264: oCall 11467
6266: oAssign
6267: oGetAddrLocal 1
6269: oPushResult
6270: oSetResult 0
6272: oAssign
6273: oJumpForward 6278
6275: Choice Lookup Table
           1   6261
6278: oGetParam 1
6280: oPushResult
6281: oCall 6477
6283: oPop 1
6285: oTypeSNodeType
6286: oChoice 6324
6288: oCall 11576
6290: oEmit 18
6292: oGetLocal 2
6294: oPushResult
6295: oEmitInt
6296: oPop 1
6298: oGetGlobal 16
6300: oPushResult
6301: oTypeSPush
6302: oPop 1
6304: oJumpForward 6334
6306: oCall 11630
6308: oEmit 18
6310: oGetLocal 2
6312: oPushResult
6313: oEmitInt
6314: oPop 1
6316: oGetGlobal 16
6318: oPushResult
6319: oTypeSPush
6320: oPop 1
6322: oJumpForward 6334
6324: Choice Lookup Table
          36   6306
          42   6288
          43   6288
6331: oError 15
6333: oTypeSPop
6334: oJumpForward 6368
6336: oGetParam 1
6338: oPushResult
6339: oCall 6477
6341: oPop 1
6343: oCall 9368
6345: oCall 8430
6347: oJumpForward 6368
6349: Choice Lookup Table
          38   6336
          37   6336
          36   6257
          42   6257
          43   6257
          33   6244
          30   6205
          31   6205
6366: oError 18
6368: oJumpForward 6474
6370: oTypeSNodeType
6371: oChoice 6452
6373: oCall 9368
6375: oGetParam 1
6377: oPushResult
6378: oCall 6477
6380: oPop 1
6382: oTypeSNodeType
6383: oChoice 6395
6385: oEmit 23
6387: oEmit 34
6389: oEmit 23
6391: oEmit 48
6393: oJumpForward 6402
6395: Choice Lookup Table
          33   6385
6398: oCall 9388
6400: oEmit 43
6402: oJumpForward 6465
6404: oGetParam 1
6406: oPushResult
6407: oCall 6477
6409: oPop 1
6411: oCall 9434
6413: oEmit 48
6415: oJumpForward 6465
6417: oGetParam 1
6419: oPushResult
6420: oCall 6477
6422: oPop 1
6424: oTypeSNodeType
6425: oChoice 6439
6427: oCall 9368
6429: oCall 8486
6431: oJumpForward 6450
6433: oCall 9283
6435: oCall 8542
6437: oJumpForward 6450
6439: Choice Lookup Table
          38   6433
          37   6433
          30   6427
          31   6427
6448: oError 18
6450: oJumpForward 6465
6452: Choice Lookup Table
          38   6417
          37   6417
          33   6404
          30   6373
          31   6373
6463: oError 18
6465: oJumpForward 6474
6467: Choice Lookup Table
          26   6370
          25   6202
6472: oJumpForward 6476
6474: oJumpBack 6200
6476: oReturn
6477: oLocalSpace 0
6479: oGetParam 1
6481: oPushResult
6482: oCall 6612
6484: oPop 1
6486: oInputChoice 6602
6488: oTypeSNodeType
6489: oChoice 6533
6491: oCall 9368
6493: oGetParam 1
6495: oPushResult
6496: oCall 6612
6498: oPop 1
6500: oTypeSNodeType
6501: oChoice 6511
6503: oEmit 23
6505: oEmit 34
6507: oEmit 45
6509: oJumpForward 6518
6511: Choice Lookup Table
          33   6503
6514: oCall 9388
6516: oEmit 37
6518: oJumpForward 6542
6520: oGetParam 1
6522: oPushResult
6523: oCall 6612
6525: oPop 1
6527: oCall 9434
6529: oEmit 45
6531: oJumpForward 6542
6533: Choice Lookup Table
          33   6520
          30   6491
          31   6491
6540: oError 18
6542: oJumpForward 6609
6544: oTypeSNodeType
6545: oChoice 6591
6547: oCall 9368
6549: oGetParam 1
6551: oPushResult
6552: oCall 6612
6554: oPop 1
6556: oTypeSNodeType
6557: oChoice 6569
6559: oEmit 23
6561: oEmit 34
6563: oEmit 23
6565: oEmit 46
6567: oJumpForward 6576
6569: Choice Lookup Table
          33   6559
6572: oCall 9388
6574: oEmit 38
6576: oJumpForward 6600
6578: oGetParam 1
6580: oPushResult
6581: oCall 6612
6583: oPop 1
6585: oCall 9434
6587: oEmit 46
6589: oJumpForward 6600
6591: Choice Lookup Table
          33   6578
          30   6547
          31   6547
6598: oError 18
6600: oJumpForward 6609
6602: Choice Lookup Table
          24   6544
          23   6488
6607: oJumpForward 6611
6609: oJumpBack 6486
6611: oReturn
6612: oLocalSpace 0
6614: oInputChoice 6672
6616: oGetParam 1
6618: oPushResult
6619: oCall 6685
6621: oPop 1
6623: oTypeSNodeType
6624: oChoice 6630
6626: oJumpForward 6639
6628: oJumpForward 6639
6630: Choice Lookup Table
          33   6628
          30   6626
          31   6626
6637: oError 18
6639: oJumpForward 6684
6641: oGetParam 1
6643: oPushResult
6644: oCall 6685
6646: oPop 1
6648: oTypeSNodeType
6649: oChoice 6661
6651: oCall 9388
6653: oEmit 44
6655: oJumpForward 6670
6657: oEmit 49
6659: oJumpForward 6670
6661: Choice Lookup Table
          33   6657
          30   6651
          31   6651
6668: oError 18
6670: oJumpForward 6684
6672: Choice Lookup Table
          26   6641
          25   6616
6677: oGetParam 1
6679: oPushResult
6680: oCall 6685
6682: oPop 1
6684: oReturn
6685: oLocalSpace 7
6687: oInputChoice 7191
6689: oEmit 15
6691: TOKEN_VALUE
6692: oPushResult
6693: oEmitInt
6694: oPop 1
6696: oGetGlobal 6
6698: oPushResult
6699: oTypeSPush
6700: oPop 1
6702: oJumpForward 7214
6704: oEmit 15
6706: TOKEN_VALUE
6707: oPushResult
6708: oEmitInt
6709: oPop 1
6711: oGetGlobal 9
6713: oPushResult
6714: oTypeSPush
6715: oPop 1
6717: oJumpForward 7214
6719: oEmit 16
6721: TOKEN_VALUE_DOUBLE
6722: oPushResult
6723: oEmitDouble
6724: oPop 1
6726: oGetGlobal 13
6728: oPushResult
6729: oTypeSPush
6730: oPop 1
6732: oJumpForward 7214
6734: oGetParam 1
6736: oPushResult
6737: oCall 5231
6739: oPop 1
6741: oInput 16
6743: oJumpForward 7214
6745: oGetAddrLocal 1
6747: oPushResult
6748: CURRENT_STRLIT
6749: oPushResult
6750: oStringAllocShortStringLit
6751: oPop 1
6753: oAssign
6754: oEmit 17
6756: oGetLocal 1
6758: oPushResult
6759: oEmitInt
6760: oPop 1
6762: oGetGlobal 15
6764: oPushResult
6765: oTypeSPush
6766: oPop 1
6768: oCall 8028
6770: oCall 7974
6772: oJumpForward 7214
6774: oGetAddrLocal 2
6776: oPushResult
6777: oScopeFindRequire
6778: oAssign
6779: oGetAddrLocal 2
6781: oPushResult
6782: oCall 244
6784: oPop 1
6786: oGetLocal 2
6788: oPushResult
6789: oNodeType
6790: oPop 1
6792: oChoice 7109
6794: oGetLocal 2
6796: oPushResult
6797: oCall 11779
6799: oPop 1
6801: oJumpForward 7140
6803: oGetLocal 2
6805: oPushResult
6806: oCall 12449
6808: oPop 1
6810: oJumpForward 7140
6812: oGetAddrLocal 3
6814: oPushResult
6815: oGetLocal 2
6817: oPushResult
6818: oSetResult 21
6820: oPushResult
6821: oNodeGet
6822: oPop 2
6824: oAssign
6825: oGetLocal 3
6827: oPushResult
6828: oTypeSPush
6829: oPop 1
6831: oTypeSNodeType
6832: oChoice 6856
6834: oEmit 15
6836: oGetLocal 2
6838: oPushResult
6839: oCall 14818
6841: oPop 1
6843: oJumpForward 6873
6845: oEmit 15
6847: oGetLocal 2
6849: oPushResult
6850: oCall 14818
6852: oPop 1
6854: oJumpForward 6873
6856: Choice Lookup Table
          38   6845
          37   6845
          30   6834
          36   6834
          34   6834
          44   6834
          31   6834
6871: oError 17
6873: oJumpForward 7140
6875: oGetAddrLocal 3
6877: oPushResult
6878: oGetLocal 2
6880: oPushResult
6881: oSetResult 21
6883: oPushResult
6884: oNodeGet
6885: oPop 2
6887: oAssign
6888: oGetLocal 3
6890: oPushResult
6891: oTypeSPush
6892: oPop 1
6894: oTypeSNodeType
6895: oChoice 6914
6897: oEmit 16
6899: oGetLocal 2
6901: oPushResult
6902: oSetResult 34
6904: oPushResult
6905: oNodeGetDouble
6906: oPop 2
6908: oPushResult
6909: oEmitDouble
6910: oPop 1
6912: oJumpForward 6919
6914: Choice Lookup Table
          33   6897
6917: oError 17
6919: oJumpForward 7140
6921: oGetAddrLocal 4
6923: oPushResult
6924: oGetLocal 2
6926: oPushResult
6927: oSetResult 22
6929: oPushResult
6930: oNodeGetInt
6931: oPop 2
6933: oAssign
6934: oGetLocal 4
6936: oPushResult
6937: equal_zero
6938: oPop 1
6940: oChoice 6973
6942: oGetAddrLocal 4
6944: oPushResult
6945: oGetLocal 2
6947: oPushResult
6948: oSetResult 33
6950: oPushResult
6951: oNodeGetString
6952: oPop 2
6954: oPushResult
6955: oStringAllocShortStringLit
6956: oPop 1
6958: oAssign
6959: oGetLocal 2
6961: oPushResult
6962: oSetResult 22
6964: oPushResult
6965: oGetLocal 4
6967: oPushResult
6968: oNodeSetInt
6969: oPop 3
6971: oJumpForward 6976
6973: Choice Lookup Table
           1   6942
6976: oEmit 17
6978: oGetLocal 4
6980: oPushResult
6981: oEmitInt
6982: oPop 1
6984: oGetGlobal 15
6986: oPushResult
6987: oTypeSPush
6988: oPop 1
6990: oCall 8028
6992: oCall 7974
6994: oJumpForward 7140
6996: oGetLocal 2
6998: oPushResult
6999: oCall 7215
7001: oPop 1
7003: oJumpForward 7140
7005: oGetLocal 2
7007: oPushResult
7008: oSetResult 21
7010: oPushResult
7011: oNodeGet
7012: oPop 2
7014: oPushResult
7015: oTypeSPush
7016: oPop 1
7018: oInputChoice 7085
7020: oCall 5047
7022: oInput 16
7024: oCall 9103
7026: oTypeSNodeType
7027: oChoice 7072
7029: oInputChoice 7059
7031: oTypeSPop
7032: oGetLocal 3
7034: oPushResult
7035: oSetResult 38
7037: oPushResult
7038: oNodeGet
7039: oPop 2
7041: oPushResult
7042: oTypeSPush
7043: oPop 1
7045: oCall 8028
7047: oCall 7974
7049: oJumpForward 7064
7051: oCall 8223
7053: oCall 8028
7055: oCall 7974
7057: oJumpForward 7064
7059: Choice Lookup Table
          17   7051
          19   7031
7064: oJumpForward 7083
7066: oCall 8028
7068: oCall 7974
7070: oJumpForward 7083
7072: Choice Lookup Table
          43   7066
          41   7066
          39   7066
          38   7029
          37   7029
7083: oJumpForward 7107
7085: Choice Lookup Table
          15   7020
7088: oGetGlobal 25
7090: oChoice 7102
7092: oEmit 15
7094: oSetResult 0
7096: oPushResult
7097: oEmitInt
7098: oPop 1
7100: oJumpForward 7107
7102: Choice Lookup Table
           1   7092
7105: oError 33
7107: oJumpForward 7140
7109: Choice Lookup Table
          20   7005
          26   6996
          25   6996
          23   6996
          22   6996
          18   6921
          19   6875
          17   6812
          16   6812
          14   6803
          13   6794
7132: oError 6
7134: oGetGlobal 6
7136: oPushResult
7137: oTypeSPush
7138: oPop 1
7140: oJumpForward 7214
7142: oInput 0
7144: oGetAddrLocal 5
7146: oPushResult
7147: oScopeFindRequire
7148: oAssign
7149: oGetAddrLocal 5
7151: oPushResult
7152: oCall 244
7154: oPop 1
7156: oGetLocal 5
7158: oPushResult
7159: oSetResult 0
7161: oPushResult
7162: oCall 9984
7164: oPop 2
7166: oGetAddrLocal 6
7168: oPushResult
7169: oTypeSTop
7170: oAssign
7171: oTypeSPop
7172: oGetAddrLocal 7
7174: oPushResult
7175: oGetLocal 6
7177: oPushResult
7178: oCall 13837
7180: oPop 1
7182: oAssign
7183: oGetLocal 7
7185: oPushResult
7186: oTypeSPush
7187: oPop 1
7189: oJumpForward 7214
7191: Choice Lookup Table
          20   7142
           0   6774
           3   6745
          15   6734
           2   6719
           4   6704
           1   6689
7206: oError 6
7208: oGetGlobal 6
7210: oPushResult
7211: oTypeSPush
7212: oPop 1
7214: oReturn
7215: oLocalSpace 2
7217: oGetAddrLocal 1
7219: oPushResult
7220: oGetParam 1
7222: oPushResult
7223: oSetResult 21
7225: oPushResult
7226: oNodeGet
7227: oPop 2
7229: oAssign
7230: oGetAddrLocal 2
7232: oPushResult
7233: oGetParam 1
7235: oPushResult
7236: oCall 14772
7238: oPop 1
7240: oAssign
7241: oGetLocal 1
7243: oPushResult
7244: oTypeSPush
7245: oPop 1
7247: oTypeSNodeType
7248: oChoice 7947
7250: oGetParam 1
7252: oPushResult
7253: oNodeType
7254: oPop 1
7256: oChoice 7402
7258: oEmit 0
7260: oGetParam 1
7262: oPushResult
7263: oCall 14818
7265: oPop 1
7267: oJumpForward 7412
7269: oGetLocal 2
7271: oPushResult
7272: equal_zero
7273: oPop 1
7275: oChoice 7288
7277: oEmit 3
7279: oGetParam 1
7281: oPushResult
7282: oCall 14818
7284: oPop 1
7286: oJumpForward 7306
7288: Choice Lookup Table
           1   7277
7291: oEmit 9
7293: oGetLocal 2
7295: oPushResult
7296: oEmitInt
7297: oPop 1
7299: oGetParam 1
7301: oPushResult
7302: oCall 14818
7304: oPop 1
7306: oJumpForward 7412
7308: oGetParam 1
7310: oPushResult
7311: oSetResult 35
7313: oPushResult
7314: oNodeGetBoolean
7315: oPop 2
7317: oChoice 7360
7319: oGetLocal 2
7321: oPushResult
7322: equal_zero
7323: oPop 1
7325: oChoice 7338
7327: oEmit 8
7329: oGetParam 1
7331: oPushResult
7332: oCall 14818
7334: oPop 1
7336: oJumpForward 7356
7338: Choice Lookup Table
           1   7327
7341: oEmit 14
7343: oGetLocal 2
7345: oPushResult
7346: oEmitInt
7347: oPop 1
7349: oGetParam 1
7351: oPushResult
7352: oCall 14818
7354: oPop 1
7356: oEmit 24
7358: oJumpForward 7400
7360: Choice Lookup Table
           1   7319
7363: oGetLocal 2
7365: oPushResult
7366: equal_zero
7367: oPop 1
7369: oChoice 7382
7371: oEmit 6
7373: oGetParam 1
7375: oPushResult
7376: oCall 14818
7378: oPop 1
7380: oJumpForward 7400
7382: Choice Lookup Table
           1   7371
7385: oEmit 12
7387: oGetLocal 2
7389: oPushResult
7390: oEmitInt
7391: oPop 1
7393: oGetParam 1
7395: oPushResult
7396: oCall 14818
7398: oPop 1
7400: oJumpForward 7412
7402: Choice Lookup Table
          25   7308
          23   7269
          26   7258
          22   7258
7411: oEndChoice
7412: oJumpForward 7973
7414: oGetParam 1
7416: oPushResult
7417: oNodeType
7418: oPop 1
7420: oChoice 7566
7422: oEmit 1
7424: oGetParam 1
7426: oPushResult
7427: oCall 14818
7429: oPop 1
7431: oJumpForward 7576
7433: oGetLocal 2
7435: oPushResult
7436: equal_zero
7437: oPop 1
7439: oChoice 7452
7441: oEmit 4
7443: oGetParam 1
7445: oPushResult
7446: oCall 14818
7448: oPop 1
7450: oJumpForward 7470
7452: Choice Lookup Table
           1   7441
7455: oEmit 10
7457: oGetLocal 2
7459: oPushResult
7460: oEmitInt
7461: oPop 1
7463: oGetParam 1
7465: oPushResult
7466: oCall 14818
7468: oPop 1
7470: oJumpForward 7576
7472: oGetParam 1
7474: oPushResult
7475: oSetResult 35
7477: oPushResult
7478: oNodeGetBoolean
7479: oPop 2
7481: oChoice 7524
7483: oGetLocal 2
7485: oPushResult
7486: equal_zero
7487: oPop 1
7489: oChoice 7502
7491: oEmit 8
7493: oGetParam 1
7495: oPushResult
7496: oCall 14818
7498: oPop 1
7500: oJumpForward 7520
7502: Choice Lookup Table
           1   7491
7505: oEmit 14
7507: oGetLocal 2
7509: oPushResult
7510: oEmitInt
7511: oPop 1
7513: oGetParam 1
7515: oPushResult
7516: oCall 14818
7518: oPop 1
7520: oEmit 25
7522: oJumpForward 7564
7524: Choice Lookup Table
           1   7483
7527: oGetLocal 2
7529: oPushResult
7530: equal_zero
7531: oPop 1
7533: oChoice 7546
7535: oEmit 7
7537: oGetParam 1
7539: oPushResult
7540: oCall 14818
7542: oPop 1
7544: oJumpForward 7564
7546: Choice Lookup Table
           1   7535
7549: oEmit 13
7551: oGetLocal 2
7553: oPushResult
7554: oEmitInt
7555: oPop 1
7557: oGetParam 1
7559: oPushResult
7560: oCall 14818
7562: oPop 1
7564: oJumpForward 7576
7566: Choice Lookup Table
          25   7472
          23   7433
          26   7422
          22   7422
7575: oEndChoice
7576: oJumpForward 7973
7578: oError 17
7580: oJumpForward 7973
7582: oGetParam 1
7584: oPushResult
7585: oNodeType
7586: oPop 1
7588: oChoice 7734
7590: oEmit 2
7592: oGetParam 1
7594: oPushResult
7595: oCall 14818
7597: oPop 1
7599: oJumpForward 7744
7601: oGetLocal 2
7603: oPushResult
7604: equal_zero
7605: oPop 1
7607: oChoice 7620
7609: oEmit 5
7611: oGetParam 1
7613: oPushResult
7614: oCall 14818
7616: oPop 1
7618: oJumpForward 7638
7620: Choice Lookup Table
           1   7609
7623: oEmit 11
7625: oGetLocal 2
7627: oPushResult
7628: oEmitInt
7629: oPop 1
7631: oGetParam 1
7633: oPushResult
7634: oCall 14818
7636: oPop 1
7638: oJumpForward 7744
7640: oGetParam 1
7642: oPushResult
7643: oSetResult 35
7645: oPushResult
7646: oNodeGetBoolean
7647: oPop 2
7649: oChoice 7692
7651: oGetLocal 2
7653: oPushResult
7654: equal_zero
7655: oPop 1
7657: oChoice 7670
7659: oEmit 8
7661: oGetParam 1
7663: oPushResult
7664: oCall 14818
7666: oPop 1
7668: oJumpForward 7688
7670: Choice Lookup Table
           1   7659
7673: oEmit 14
7675: oGetLocal 2
7677: oPushResult
7678: oEmitInt
7679: oPop 1
7681: oGetParam 1
7683: oPushResult
7684: oCall 14818
7686: oPop 1
7688: oEmit 26
7690: oJumpForward 7732
7692: Choice Lookup Table
           1   7651
7695: oGetLocal 2
7697: oPushResult
7698: equal_zero
7699: oPop 1
7701: oChoice 7714
7703: oEmit 8
7705: oGetParam 1
7707: oPushResult
7708: oCall 14818
7710: oPop 1
7712: oJumpForward 7732
7714: Choice Lookup Table
           1   7703
7717: oEmit 14
7719: oGetLocal 2
7721: oPushResult
7722: oEmitInt
7723: oPop 1
7725: oGetParam 1
7727: oPushResult
7728: oCall 14818
7730: oPop 1
7732: oJumpForward 7744
7734: Choice Lookup Table
          25   7640
          23   7601
          26   7590
          22   7590
7743: oEndChoice
7744: oInputChoice 7774
7746: oTypeSPop
7747: oGetLocal 1
7749: oPushResult
7750: oSetResult 38
7752: oPushResult
7753: oNodeGet
7754: oPop 2
7756: oPushResult
7757: oTypeSPush
7758: oPop 1
7760: oCall 8028
7762: oCall 7974
7764: oJumpForward 7779
7766: oCall 8223
7768: oCall 8028
7770: oCall 7974
7772: oJumpForward 7779
7774: Choice Lookup Table
          17   7766
          19   7746
7779: oJumpForward 7973
7781: oGetParam 1
7783: oPushResult
7784: oNodeType
7785: oPop 1
7787: oChoice 7931
7789: oEmit 17
7791: oGetParam 1
7793: oPushResult
7794: oCall 14818
7796: oPop 1
7798: oJumpForward 7941
7800: oGetLocal 2
7802: oPushResult
7803: equal_zero
7804: oPop 1
7806: oChoice 7819
7808: oEmit 18
7810: oGetParam 1
7812: oPushResult
7813: oCall 14818
7815: oPop 1
7817: oJumpForward 7837
7819: Choice Lookup Table
           1   7808
7822: oEmit 21
7824: oGetLocal 2
7826: oPushResult
7827: oEmitInt
7828: oPop 1
7830: oGetParam 1
7832: oPushResult
7833: oCall 14818
7835: oPop 1
7837: oJumpForward 7941
7839: oGetParam 1
7841: oPushResult
7842: oSetResult 35
7844: oPushResult
7845: oNodeGetBoolean
7846: oPop 2
7848: oChoice 7889
7850: oGetLocal 2
7852: oPushResult
7853: equal_zero
7854: oPop 1
7856: oChoice 7869
7858: oEmit 8
7860: oGetParam 1
7862: oPushResult
7863: oCall 14818
7865: oPop 1
7867: oJumpForward 7887
7869: Choice Lookup Table
           1   7858
7872: oEmit 14
7874: oGetLocal 2
7876: oPushResult
7877: oEmitInt
7878: oPop 1
7880: oGetParam 1
7882: oPushResult
7883: oCall 14818
7885: oPop 1
7887: oJumpForward 7929
7889: Choice Lookup Table
           1   7850
7892: oGetLocal 2
7894: oPushResult
7895: equal_zero
7896: oPop 1
7898: oChoice 7911
7900: oEmit 19
7902: oGetParam 1
7904: oPushResult
7905: oCall 14818
7907: oPop 1
7909: oJumpForward 7929
7911: Choice Lookup Table
           1   7900
7914: oEmit 22
7916: oGetLocal 2
7918: oPushResult
7919: oEmitInt
7920: oPop 1
7922: oGetParam 1
7924: oPushResult
7925: oCall 14818
7927: oPop 1
7929: oJumpForward 7941
7931: Choice Lookup Table
          25   7839
          23   7800
          26   7789
          22   7789
7940: oEndChoice
7941: oCall 8028
7943: oCall 7974
7945: oJumpForward 7973
7947: Choice Lookup Table
          43   7781
          41   7781
          39   7781
          33   7582
          38   7582
          37   7582
          29   7578
          36   7414
          30   7414
          34   7414
          44   7250
          31   7250
7972: oEndChoice
7973: oReturn
7974: oLocalSpace 0
7976: oTypeSNodeType
7977: oChoice 8001
7979: oEmit 24
7981: oJumpForward 8027
7983: oEmit 25
7985: oJumpForward 8027
7987: oError 17
7989: oJumpForward 8027
7991: oEmit 26
7993: oJumpForward 8027
7995: oError 31
7997: oJumpForward 8027
7999: oJumpForward 8027
8001: Choice Lookup Table
          43   7999
          42   7999
          41   7999
          39   7999
          38   7995
          37   7991
          29   7987
          36   7983
          30   7983
          34   7983
          44   7979
          31   7979
8026: oEndChoice
8027: oReturn
8028: oLocalSpace 0
8030: oInputChoice 8068
8032: oTypeSNodeType
8033: oChoice 8047
8035: oCall 8080
8037: oJumpForward 8058
8039: oCall 8223
8041: oJumpForward 8058
8043: oCall 8302
8045: oJumpForward 8058
8047: Choice Lookup Table
          43   8043
          42   8043
          37   8039
          39   8035
8056: oError 11
8058: oJumpForward 8077
8060: oCall 8332
8062: oJumpForward 8077
8064: oCall 8605
8066: oJumpForward 8077
8068: Choice Lookup Table
          19   8064
          21   8060
          17   8032
8075: oJumpForward 8079
8077: oJumpBack 8030
8079: oReturn
8080: oLocalSpace 3
8082: oTypeSNodeType
8083: oChoice 8087
8085: oJumpForward 8092
8087: Choice Lookup Table
          39   8085
8090: oError 11
8092: oTypeSNodeType
8093: oChoice 8097
8095: oJumpForward 8102
8097: Choice Lookup Table
          39   8095
8100: oError 14
8102: oGetAddrLocal 1
8104: oPushResult
8105: oTypeSTop
8106: oPushResult
8107: oSetResult 39
8109: oPushResult
8110: oNodeGet
8111: oPop 2
8113: oPushResult
8114: oCall 13921
8116: oPop 1
8118: oAssign
8119: oGetAddrLocal 2
8121: oPushResult
8122: oTypeSTop
8123: oPushResult
8124: oSetResult 38
8126: oPushResult
8127: oNodeGet
8128: oPop 2
8130: oAssign
8131: oTypeSPop
8132: oGetLocal 2
8134: oPushResult
8135: oTypeSPush
8136: oPop 1
8138: oCall 5047
8140: oCall 9341
8142: oGetLocal 1
8144: oPushResult
8145: equal_zero
8146: oPop 1
8148: oChoice 8162
8150: oEmit 15
8152: oGetLocal 1
8154: oPushResult
8155: oEmitInt
8156: oPop 1
8158: oEmit 43
8160: oJumpForward 8165
8162: Choice Lookup Table
           0   8150
8165: oGetAddrLocal 3
8167: oPushResult
8168: oGetLocal 2
8170: oPushResult
8171: oSetResult 17
8173: oPushResult
8174: oNodeGetInt
8175: oPop 2
8177: oAssign
8178: oGetLocal 3
8180: oPushResult
8181: oSetResult 1
8183: oPushResult
8184: equal
8185: oPop 2
8187: oChoice 8201
8189: oEmit 15
8191: oGetLocal 3
8193: oPushResult
8194: oEmitInt
8195: oPop 1
8197: oEmit 37
8199: oJumpForward 8204
8201: Choice Lookup Table
           0   8189
8204: oEmit 39
8206: oInputChoice 8214
8208: oJumpForward 8222
8210: oJumpForward 8220
8212: oJumpForward 8220
8214: Choice Lookup Table
          14   8212
          18   8208
8219: oEndChoice
8220: oJumpBack 8092
8222: oReturn
8223: oLocalSpace 2
8225: oTypeSNodeType
8226: oChoice 8230
8228: oJumpForward 8235
8230: Choice Lookup Table
          37   8228
8233: oError 31
8235: oGetAddrLocal 1
8237: oPushResult
8238: oTypeSTop
8239: oPushResult
8240: oSetResult 38
8242: oPushResult
8243: oNodeGet
8244: oPop 2
8246: oAssign
8247: oTypeSPop
8248: oGetLocal 1
8250: oPushResult
8251: oTypeSPush
8252: oPop 1
8254: oCall 5047
8256: oCall 9341
8258: oGetAddrLocal 2
8260: oPushResult
8261: oGetLocal 1
8263: oPushResult
8264: oSetResult 17
8266: oPushResult
8267: oNodeGetInt
8268: oPop 2
8270: oAssign
8271: oGetLocal 2
8273: oPushResult
8274: oSetResult 1
8276: oPushResult
8277: equal
8278: oPop 2
8280: oChoice 8294
8282: oEmit 15
8284: oGetLocal 2
8286: oPushResult
8287: oEmitInt
8288: oPop 1
8290: oEmit 37
8292: oJumpForward 8297
8294: Choice Lookup Table
           0   8282
8297: oEmit 39
8299: oInput 18
8301: oReturn
8302: oLocalSpace 0
8304: oTypeSNodeType
8305: oChoice 8309
8307: oJumpForward 8316
8309: Choice Lookup Table
          43   8307
          42   8307
8314: oError 31
8316: oTypeSPop
8317: oGetGlobal 9
8319: oPushResult
8320: oTypeSPush
8321: oPop 1
8323: oCall 5047
8325: oCall 9341
8327: oEmit 39
8329: oInput 18
8331: oReturn
8332: oLocalSpace 2
8334: oTypeSNodeType
8335: oChoice 8339
8337: oJumpForward 8344
8339: Choice Lookup Table
          41   8337
8342: oError 12
8344: oTypeSTop
8345: oPushResult
8346: oSetResult 42
8348: oPushResult
8349: oNodeGet
8350: oPop 2
8352: oPushResult
8353: oScopeEnter
8354: oPop 1
8356: oInput 0
8358: oGetAddrLocal 1
8360: oPushResult
8361: oScopeFindRequire
8362: oAssign
8363: oGetLocal 1
8365: oPushResult
8366: oNodeType
8367: oPop 1
8369: oChoice 8373
8371: oJumpForward 8378
8373: Choice Lookup Table
          24   8371
8376: oError 13
8378: oScopeEnd
8379: oGetAddrLocal 2
8381: oPushResult
8382: oGetLocal 1
8384: oPushResult
8385: oSetResult 22
8387: oPushResult
8388: oNodeGetInt
8389: oPop 2
8391: oAssign
8392: oGetLocal 2
8394: oPushResult
8395: equal_zero
8396: oPop 1
8398: oChoice 8412
8400: oEmit 15
8402: oGetLocal 2
8404: oPushResult
8405: oEmitInt
8406: oPop 1
8408: oEmit 39
8410: oJumpForward 8415
8412: Choice Lookup Table
           0   8400
8415: oTypeSPop
8416: oGetLocal 1
8418: oPushResult
8419: oSetResult 21
8421: oPushResult
8422: oNodeGet
8423: oPop 2
8425: oPushResult
8426: oTypeSPush
8427: oPop 1
8429: oReturn
8430: oLocalSpace 2
8432: oGetAddrLocal 1
8434: oPushResult
8435: oTypeSTop
8436: oPushResult
8437: oSetResult 38
8439: oPushResult
8440: oNodeGet
8441: oPop 2
8443: oAssign
8444: oGetAddrLocal 2
8446: oPushResult
8447: oGetLocal 1
8449: oPushResult
8450: oSetResult 17
8452: oPushResult
8453: oNodeGetInt
8454: oPop 2
8456: oAssign
8457: oGetLocal 2
8459: oPushResult
8460: oSetResult 1
8462: oPushResult
8463: equal
8464: oPop 2
8466: oChoice 8480
8468: oEmit 15
8470: oGetLocal 2
8472: oPushResult
8473: oEmitInt
8474: oPop 1
8476: oEmit 37
8478: oJumpForward 8483
8480: Choice Lookup Table
           0   8468
8483: oEmit 39
8485: oReturn
8486: oLocalSpace 2
8488: oGetAddrLocal 1
8490: oPushResult
8491: oTypeSTop
8492: oPushResult
8493: oSetResult 38
8495: oPushResult
8496: oNodeGet
8497: oPop 2
8499: oAssign
8500: oGetAddrLocal 2
8502: oPushResult
8503: oGetLocal 1
8505: oPushResult
8506: oSetResult 17
8508: oPushResult
8509: oNodeGetInt
8510: oPop 2
8512: oAssign
8513: oGetLocal 2
8515: oPushResult
8516: oSetResult 1
8518: oPushResult
8519: equal
8520: oPop 2
8522: oChoice 8536
8524: oEmit 15
8526: oGetLocal 2
8528: oPushResult
8529: oEmitInt
8530: oPop 1
8532: oEmit 37
8534: oJumpForward 8539
8536: Choice Lookup Table
           0   8524
8539: oEmit 42
8541: oReturn
8542: oLocalSpace 2
8544: oEmit 41
8546: oGetAddrLocal 1
8548: oPushResult
8549: oTypeSTop
8550: oPushResult
8551: oSetResult 38
8553: oPushResult
8554: oNodeGet
8555: oPop 2
8557: oAssign
8558: oGetAddrLocal 2
8560: oPushResult
8561: oGetLocal 1
8563: oPushResult
8564: oSetResult 17
8566: oPushResult
8567: oNodeGetInt
8568: oPop 2
8570: oAssign
8571: oGetLocal 2
8573: oPushResult
8574: oSetResult 1
8576: oPushResult
8577: equal
8578: oPop 2
8580: oChoice 8594
8582: oEmit 15
8584: oGetLocal 2
8586: oPushResult
8587: oEmitInt
8588: oPop 1
8590: oEmit 38
8592: oJumpForward 8597
8594: Choice Lookup Table
           0   8582
8597: oTypeSPop
8598: oGetGlobal 6
8600: oPushResult
8601: oTypeSPush
8602: oPop 1
8604: oReturn
8605: oLocalSpace 1
8607: oTypeSNodeType
8608: oChoice 8616
8610: oJumpForward 8623
8612: oError 31
8614: oJumpForward 8623
8616: Choice Lookup Table
          38   8612
          37   8610
8621: oError 10
8623: oEmit 26
8625: oGetAddrLocal 1
8627: oPushResult
8628: oTypeSTop
8629: oAssign
8630: oTypeSPop
8631: oGetLocal 1
8633: oPushResult
8634: oSetResult 38
8636: oPushResult
8637: oNodeGet
8638: oPop 2
8640: oPushResult
8641: oTypeSPush
8642: oPop 1
8644: oReturn
8645: oLocalSpace 3
8647: oGetAddrLocal 1
8649: oPushResult
8650: oTypeSNodeType
8651: oAssign
8652: oGetAddrLocal 2
8654: oPushResult
8655: oTypeSTop
8656: oAssign
8657: oTypeSPop
8658: oGetLocal 1
8660: oPushResult
8661: oTypeSNodeType
8662: oPushResult
8663: equal_node_type
8664: oPop 2
8666: oChoice 8814
8668: oTypeSNodeType
8669: oChoice 8797
8671: oGetLocal 1
8673: oChoice 8680
8675: oEmit 32
8677: oReturn
8678: oJumpForward 8683
8680: Choice Lookup Table
          30   8675
8683: oJumpForward 8810
8685: oGetLocal 1
8687: oChoice 8694
8689: oEmit 33
8691: oReturn
8692: oJumpForward 8697
8694: Choice Lookup Table
          31   8689
8697: oJumpForward 8810
8699: oGetLocal 1
8701: oChoice 8708
8703: oEmit 34
8705: oReturn
8706: oJumpForward 8711
8708: Choice Lookup Table
          31   8703
8711: oJumpForward 8810
8713: oGetLocal 1
8715: oChoice 8748
8717: oReturn
8718: oJumpForward 8753
8720: oTypeSTop
8721: oPushResult
8722: oGetGlobal 10
8724: oPushResult
8725: equal_node
8726: oPop 2
8728: oChoice 8743
8730: oEmit 15
8732: oSetResult 1
8734: oPushResult
8735: oEmitInt
8736: oPop 1
8738: oEmit 39
8740: oReturn
8741: oJumpForward 8746
8743: Choice Lookup Table
           1   8730
8746: oJumpForward 8753
8748: Choice Lookup Table
          42   8720
          38   8717
8753: oJumpForward 8810
8755: oGetLocal 1
8757: oChoice 8762
8759: oReturn
8760: oJumpForward 8765
8762: Choice Lookup Table
          37   8759
8765: oJumpForward 8810
8767: oGetLocal 1
8769: oChoice 8790
8771: oReturn
8772: oJumpForward 8795
8774: oGetGlobal 9
8776: oPushResult
8777: oTypeSPush
8778: oPop 1
8780: oGetAddrLocal 3
8782: oPushResult
8783: oCall 11467
8785: oAssign
8786: oTypeSPop
8787: oReturn
8788: oJumpForward 8795
8790: Choice Lookup Table
          36   8774
          42   8771
8795: oJumpForward 8810
8797: Choice Lookup Table
          43   8767
          38   8755
          37   8713
          33   8699
          30   8685
          31   8671
8810: oError 15
8812: oJumpForward 8817
8814: Choice Lookup Table
           0   8668
8817: oReturn
8818: oLocalSpace 6
8820: oGetAddrLocal 1
8822: oPushResult
8823: oTypeSNodeType
8824: oAssign
8825: oGetAddrLocal 2
8827: oPushResult
8828: oTypeSTop
8829: oAssign
8830: oTypeSPop
8831: oGetAddrLocal 3
8833: oPushResult
8834: oTypeSNodeType
8835: oAssign
8836: oGetAddrLocal 4
8838: oPushResult
8839: oTypeSTop
8840: oAssign
8841: oGetLocal 3
8843: oPushResult
8844: oGetLocal 1
8846: oPushResult
8847: equal_node_type
8848: oPop 2
8850: oChoice 8855
8852: oReturn
8853: oJumpForward 8858
8855: Choice Lookup Table
           1   8852
8858: oGetLocal 3
8860: oChoice 8941
8862: oGetLocal 1
8864: oChoice 8871
8866: oEmit 32
8868: oReturn
8869: oJumpForward 8874
8871: Choice Lookup Table
          30   8866
8874: oJumpForward 8950
8876: oGetLocal 1
8878: oChoice 8892
8880: oEmit 32
8882: oEmit 34
8884: oReturn
8885: oJumpForward 8897
8887: oEmit 34
8889: oReturn
8890: oJumpForward 8897
8892: Choice Lookup Table
          31   8887
          30   8880
8897: oJumpForward 8950
8899: oGetLocal 1
8901: oChoice 8906
8903: oReturn
8904: oJumpForward 8909
8906: Choice Lookup Table
          38   8903
8909: oJumpForward 8950
8911: oGetLocal 1
8913: oChoice 8934
8915: oReturn
8916: oJumpForward 8939
8918: oGetGlobal 9
8920: oPushResult
8921: oTypeSPush
8922: oPop 1
8924: oGetAddrLocal 5
8926: oPushResult
8927: oCall 11467
8929: oAssign
8930: oTypeSPop
8931: oReturn
8932: oJumpForward 8939
8934: Choice Lookup Table
          36   8918
          42   8915
8939: oJumpForward 8950
8941: Choice Lookup Table
          43   8911
          37   8899
          33   8876
          31   8862
8950: oGetLocal 1
8952: oChoice 9091
8954: oGetLocal 3
8956: oChoice 8974
8958: oEmit 23
8960: oEmit 32
8962: oEmit 23
8964: oTypeSPop
8965: oGetLocal 2
8967: oPushResult
8968: oTypeSPush
8969: oPop 1
8971: oReturn
8972: oJumpForward 8977
8974: Choice Lookup Table
          30   8958
8977: oJumpForward 9100
8979: oGetLocal 3
8981: oChoice 9017
8983: oEmit 23
8985: oEmit 32
8987: oEmit 34
8989: oEmit 23
8991: oTypeSPop
8992: oGetLocal 2
8994: oPushResult
8995: oTypeSPush
8996: oPop 1
8998: oReturn
8999: oJumpForward 9022
9001: oEmit 23
9003: oEmit 34
9005: oEmit 23
9007: oTypeSPop
9008: oGetLocal 2
9010: oPushResult
9011: oTypeSPush
9012: oPop 1
9014: oReturn
9015: oJumpForward 9022
9017: Choice Lookup Table
          31   9001
          30   8983
9022: oJumpForward 9100
9024: oGetLocal 3
9026: oChoice 9038
9028: oTypeSPop
9029: oGetLocal 2
9031: oPushResult
9032: oTypeSPush
9033: oPop 1
9035: oReturn
9036: oJumpForward 9041
9038: Choice Lookup Table
          38   9028
9041: oJumpForward 9100
9043: oGetLocal 3
9045: oChoice 9084
9047: oTypeSPop
9048: oGetLocal 2
9050: oPushResult
9051: oTypeSPush
9052: oPop 1
9054: oReturn
9055: oJumpForward 9089
9057: oEmit 23
9059: oGetGlobal 9
9061: oPushResult
9062: oTypeSPush
9063: oPop 1
9065: oGetAddrLocal 6
9067: oPushResult
9068: oCall 11467
9070: oAssign
9071: oTypeSPop
9072: oEmit 23
9074: oTypeSPop
9075: oGetLocal 2
9077: oPushResult
9078: oTypeSPush
9079: oPop 1
9081: oReturn
9082: oJumpForward 9089
9084: Choice Lookup Table
          36   9057
          42   9047
9089: oJumpForward 9100
9091: Choice Lookup Table
          43   9043
          37   9024
          33   8979
          31   8954
9100: oError 15
9102: oReturn
9103: oLocalSpace 2
9105: oGetAddrLocal 1
9107: oPushResult
9108: oTypeSNodeType
9109: oAssign
9110: oTypeSPop
9111: oGetLocal 1
9113: oPushResult
9114: oTypeSNodeType
9115: oPushResult
9116: equal_node_type
9117: oPop 2
9119: oChoice 9279
9121: oTypeSNodeType
9122: oChoice 9258
9124: oGetLocal 1
9126: oChoice 9136
9128: oEmit 32
9130: oReturn
9131: oJumpForward 9147
9133: oReturn
9134: oJumpForward 9147
9136: Choice Lookup Table
          44   9133
          31   9133
          34   9128
          36   9128
          30   9128
9147: oJumpForward 9275
9149: oGetLocal 1
9151: oChoice 9161
9153: oReturn
9154: oJumpForward 9172
9156: oEmit 33
9158: oReturn
9159: oJumpForward 9172
9161: Choice Lookup Table
          44   9156
          31   9156
          34   9153
          36   9153
          30   9153
9172: oJumpForward 9275
9174: oGetLocal 1
9176: oChoice 9209
9178: oReturn
9179: oJumpForward 9214
9181: oTypeSTop
9182: oPushResult
9183: oGetGlobal 10
9185: oPushResult
9186: equal_node
9187: oPop 2
9189: oChoice 9204
9191: oEmit 15
9193: oSetResult 1
9195: oPushResult
9196: oEmitInt
9197: oPop 1
9199: oEmit 39
9201: oReturn
9202: oJumpForward 9207
9204: Choice Lookup Table
           1   9191
9207: oJumpForward 9214
9209: Choice Lookup Table
          42   9181
          38   9178
9214: oJumpForward 9275
9216: oGetLocal 1
9218: oChoice 9223
9220: oReturn
9221: oJumpForward 9226
9223: Choice Lookup Table
          37   9220
9226: oJumpForward 9275
9228: oGetLocal 1
9230: oChoice 9251
9232: oReturn
9233: oJumpForward 9256
9235: oGetGlobal 9
9237: oPushResult
9238: oTypeSPush
9239: oPop 1
9241: oGetAddrLocal 2
9243: oPushResult
9244: oCall 11467
9246: oAssign
9247: oTypeSPop
9248: oReturn
9249: oJumpForward 9256
9251: Choice Lookup Table
          36   9235
          42   9232
9256: oJumpForward 9275
9258: Choice Lookup Table
          43   9228
          38   9216
          37   9174
          34   9149
          36   9149
          30   9149
          44   9124
          31   9124
9275: oError 15
9277: oJumpForward 9282
9279: Choice Lookup Table
           0   9121
9282: oReturn
9283: oLocalSpace 1
9285: oGetAddrLocal 1
9287: oPushResult
9288: oTypeSNodeType
9289: oAssign
9290: oTypeSPop
9291: oGetLocal 1
9293: oPushResult
9294: oTypeSNodeType
9295: oPushResult
9296: equal_node_type
9297: oPop 2
9299: oChoice 9337
9301: oTypeSNodeType
9302: oChoice 9328
9304: oGetLocal 1
9306: oChoice 9311
9308: oReturn
9309: oJumpForward 9314
9311: Choice Lookup Table
          38   9308
9314: oJumpForward 9333
9316: oGetLocal 1
9318: oChoice 9323
9320: oReturn
9321: oJumpForward 9326
9323: Choice Lookup Table
          37   9320
9326: oJumpForward 9333
9328: Choice Lookup Table
          38   9316
          37   9304
9333: oError 15
9335: oJumpForward 9340
9337: Choice Lookup Table
           0   9301
9340: oReturn
9341: oLocalSpace 0
9343: oTypeSNodeType
9344: oChoice 9348
9346: oJumpForward 9353
9348: Choice Lookup Table
          31   9346
9351: oError 7
9353: oTypeSPop
9354: oReturn
9355: oLocalSpace 0
9357: oTypeSNodeType
9358: oChoice 9362
9360: oJumpForward 9367
9362: Choice Lookup Table
          31   9360
9365: oError 7
9367: oReturn
9368: oLocalSpace 0
9370: oTypeSNodeType
9371: oChoice 9379
9373: oJumpForward 9386
9375: oEmit 32
9377: oJumpForward 9386
9379: Choice Lookup Table
          30   9375
          31   9373
9384: oError 7
9386: oTypeSPop
9387: oReturn
9388: oLocalSpace 0
9390: oTypeSNodeType
9391: oChoice 9406
9393: oJumpForward 9413
9395: oEmit 32
9397: oTypeSPop
9398: oGetGlobal 6
9400: oPushResult
9401: oTypeSPush
9402: oPop 1
9404: oJumpForward 9413
9406: Choice Lookup Table
          30   9395
          31   9393
9411: oError 7
9413: oReturn
9414: oLocalSpace 0
9416: oTypeSNodeType
9417: oChoice 9430
9419: oEmit 32
9421: oTypeSPop
9422: oGetGlobal 6
9424: oPushResult
9425: oTypeSPush
9426: oPop 1
9428: oJumpForward 9433
9430: Choice Lookup Table
          30   9419
9433: oReturn
9434: oLocalSpace 0
9436: oTypeSNodeType
9437: oChoice 9465
9439: oJumpForward 9474
9441: oEmit 34
9443: oTypeSPop
9444: oGetGlobal 13
9446: oPushResult
9447: oTypeSPush
9448: oPop 1
9450: oJumpForward 9474
9452: oEmit 32
9454: oEmit 34
9456: oTypeSPop
9457: oGetGlobal 13
9459: oPushResult
9460: oTypeSPush
9461: oPop 1
9463: oJumpForward 9474
9465: Choice Lookup Table
          30   9452
          31   9441
          33   9439
9472: oError 9
9474: oTypeSPop
9475: oReturn
9476: oLocalSpace 0
9478: oTypeSNodeType
9479: oChoice 9483
9481: oJumpForward 9488
9483: Choice Lookup Table
          34   9481
9486: oError 8
9488: oTypeSPop
9489: oReturn
9490: oLocalSpace 0
9492: oTypeSNodeType
9493: oChoice 9497
9495: oJumpForward 9502
9497: Choice Lookup Table
          34   9495
9500: oError 8
9502: oReturn
9503: oLocalSpace 0
9505: oInputChoice 9568
9507: oCall 11240
9509: oJumpForward 9599
9511: oCall 11247
9513: oJumpForward 9599
9515: oCall 11377
9517: oJumpForward 9599
9519: oCall 11384
9521: oJumpForward 9599
9523: oCall 10391
9525: oJumpForward 9599
9527: oCall 10714
9529: oJumpForward 9599
9531: oCall 10457
9533: oJumpForward 9599
9535: oCall 10634
9537: oJumpForward 9599
9539: oCall 10799
9541: oJumpForward 9599
9543: oCall 10767
9545: oJumpForward 9599
9547: oCall 11217
9549: oJumpForward 9599
9551: oCall 9600
9553: oJumpForward 9599
9555: oCall 10831
9557: oJumpForward 9599
9559: oCall 11165
9561: oJumpForward 9599
9563: oChangeIntLitToLabelIdent
9564: oCall 9600
9566: oJumpForward 9599
9568: Choice Lookup Table
           1   9563
          56   9559
          54   9555
           0   9551
          36   9547
          52   9543
          53   9539
          50   9535
          45   9531
          49   9527
          42   9523
          69   9519
          68   9515
          67   9511
          66   9507
9599: oReturn
9600: oLocalSpace 1
9602: oGetAddrLocal 1
9604: oPushResult
9605: oScopeFindRequire
9606: oAssign
9607: oGetAddrLocal 1
9609: oPushResult
9610: oCall 244
9612: oPop 1
9614: oGetLocal 1
9616: oPushResult
9617: oNodeType
9618: oPop 1
9620: oChoice 9660
9622: oGetLocal 1
9624: oPushResult
9625: oCall 9678
9627: oPop 1
9629: oCall 9503
9631: oJumpForward 9677
9633: oGetLocal 1
9635: oPushResult
9636: oCall 11779
9638: oPop 1
9640: oJumpForward 9677
9642: oGetLocal 1
9644: oPushResult
9645: oCall 9728
9647: oPop 1
9649: oJumpForward 9677
9651: oGetLocal 1
9653: oPushResult
9654: oCall 9824
9656: oPop 1
9658: oJumpForward 9677
9660: Choice Lookup Table
          13   9651
          20   9642
          25   9642
          23   9642
          22   9642
          12   9633
          27   9622
9675: oError 0
9677: oReturn
9678: oLocalSpace 0
9680: oGetParam 1
9682: oPushResult
9683: oSetResult 36
9685: oPushResult
9686: oNodeGetBoolean
9687: oPop 2
9689: oChoice 9695
9691: oError 22
9693: oJumpForward 9698
9695: Choice Lookup Table
           1   9691
9698: oEmit 91
9700: oGetParam 1
9702: oPushResult
9703: oSetResult 22
9705: oPushResult
9706: oNodeGetLabel
9707: oPop 2
9709: oPushResult
9710: oEmitLabel
9711: oPop 1
9713: oGetParam 1
9715: oPushResult
9716: oSetResult 36
9718: oPushResult
9719: oSetResult 1
9721: oPushResult
9722: oNodeSetBoolean
9723: oPop 3
9725: oInput 13
9727: oReturn
9728: oLocalSpace 0
9730: oGetParam 1
9732: oPushResult
9733: oSetResult 1
9735: oPushResult
9736: oCall 9984
9738: oPop 2
9740: oInput 5
9742: oCall 5047
9744: oCall 8645
9746: oCall 9749
9748: oReturn
9749: oLocalSpace 1
9751: oTypeSNodeType
9752: oChoice 9796
9754: oEmit 27
9756: oJumpForward 9822
9758: oEmit 28
9760: oJumpForward 9822
9762: oEmit 30
9764: oJumpForward 9822
9766: oError 17
9768: oJumpForward 9822
9770: oEmit 29
9772: oJumpForward 9822
9774: oGetAddrLocal 1
9776: oPushResult
9777: oTypeSTop
9778: oPushResult
9779: oSetResult 17
9781: oPushResult
9782: oNodeGetInt
9783: oPop 2
9785: oAssign
9786: oEmit 31
9788: oGetLocal 1
9790: oPushResult
9791: oEmitInt
9792: oPop 1
9794: oJumpForward 9822
9796: Choice Lookup Table
          43   9774
          41   9774
          39   9774
          38   9770
          37   9770
          29   9766
          33   9762
          36   9758
          30   9758
          34   9758
          44   9754
          31   9754
9821: oEndChoice
9822: oTypeSPop
9823: oReturn
9824: oLocalSpace 1
9826: oGetParam 1
9828: oPushResult
9829: oSetResult 6
9831: oPushResult
9832: oNodeGet
9833: oPop 2
9835: oPushResult
9836: oScopeCurrent
9837: oPushResult
9838: oNodeEqual
9839: oPop 2
9841: oChoice 9847
9843: oError 21
9845: oJumpForward 9850
9847: Choice Lookup Table
           0   9843
9850: oEmit 8
9852: oGetParam 1
9854: oPushResult
9855: oSetResult 31
9857: oPushResult
9858: oNodeGetInt
9859: oPop 2
9861: oPushResult
9862: oEmitInt
9863: oPop 1
9865: oGetParam 1
9867: oPushResult
9868: oSetResult 21
9870: oPushResult
9871: oNodeGet
9872: oPop 2
9874: oPushResult
9875: oTypeSPush
9876: oPop 1
9878: oInput 5
9880: oCall 5047
9882: oCall 8645
9884: oTypeSNodeType
9885: oChoice 9929
9887: oEmit 27
9889: oJumpForward 9955
9891: oEmit 28
9893: oJumpForward 9955
9895: oEmit 30
9897: oJumpForward 9955
9899: oError 17
9901: oJumpForward 9955
9903: oEmit 29
9905: oJumpForward 9955
9907: oGetAddrLocal 1
9909: oPushResult
9910: oTypeSTop
9911: oPushResult
9912: oSetResult 17
9914: oPushResult
9915: oNodeGetInt
9916: oPop 2
9918: oAssign
9919: oEmit 31
9921: oGetLocal 1
9923: oPushResult
9924: oEmitInt
9925: oPop 1
9927: oJumpForward 9955
9929: Choice Lookup Table
          43   9907
          41   9907
          39   9907
          38   9903
          37   9903
          29   9899
          33   9895
          36   9891
          30   9891
          34   9891
          44   9887
          31   9887
9954: oEndChoice
9955: oTypeSPop
9956: oReturn
9957: oLocalSpace 1
9959: oInput 0
9961: oGetAddrLocal 1
9963: oPushResult
9964: oScopeFindRequire
9965: oAssign
9966: oGetAddrLocal 1
9968: oPushResult
9969: oCall 244
9971: oPop 1
9973: oGetLocal 1
9975: oPushResult
9976: oGetParam 1
9978: oPushResult
9979: oCall 9984
9981: oPop 2
9983: oReturn
9984: oLocalSpace 0
9986: oGetParam 2
9988: oPushResult
9989: oNodeType
9990: oPop 1
9992: oChoice 10055
9994: oGetParam 2
9996: oPushResult
9997: oGetParam 1
9999: oPushResult
10000: oCall 10201
10002: oPop 2
10004: oJumpForward 10068
10006: oGetParam 2
10008: oPushResult
10009: oSetResult 21
10011: oPushResult
10012: oNodeGet
10013: oPop 2
10015: oPushResult
10016: oTypeSPush
10017: oPop 1
10019: oInput 15
10021: oGetParam 1
10023: oPushResult
10024: oCall 9957
10026: oPop 1
10028: oInput 16
10030: oCall 10069
10032: oTypeSNodeType
10033: oChoice 10048
10035: oInputChoice 10043
10037: oEmit 26
10039: oCall 8223
10041: oJumpForward 10046
10043: Choice Lookup Table
          17   10037
10046: oJumpForward 10051
10048: Choice Lookup Table
          37   10035
10051: oCall 8028
10053: oJumpForward 10068
10055: Choice Lookup Table
          20   10006
          26   9994
          25   9994
          23   9994
          22   9994
10066: oError 4
10068: oReturn
10069: oLocalSpace 1
10071: oGetAddrLocal 1
10073: oPushResult
10074: oTypeSNodeType
10075: oAssign
10076: oTypeSPop
10077: oGetLocal 1
10079: oPushResult
10080: oTypeSNodeType
10081: oPushResult
10082: equal_node_type
10083: oPop 2
10085: oChoice 10197
10087: oTypeSNodeType
10088: oChoice 10176
10090: oGetLocal 1
10092: oChoice 10102
10094: oError 32
10096: oReturn
10097: oJumpForward 10113
10099: oReturn
10100: oJumpForward 10113
10102: Choice Lookup Table
          44   10099
          31   10099
          34   10094
          36   10094
          30   10094
10113: oJumpForward 10193
10115: oGetLocal 1
10117: oChoice 10127
10119: oReturn
10120: oJumpForward 10138
10122: oError 32
10124: oReturn
10125: oJumpForward 10138
10127: Choice Lookup Table
          44   10122
          31   10122
          34   10119
          36   10119
          30   10119
10138: oJumpForward 10193
10140: oGetLocal 1
10142: oChoice 10147
10144: oReturn
10145: oJumpForward 10150
10147: Choice Lookup Table
          38   10144
10150: oJumpForward 10193
10152: oGetLocal 1
10154: oChoice 10159
10156: oReturn
10157: oJumpForward 10162
10159: Choice Lookup Table
          37   10156
10162: oJumpForward 10193
10164: oGetLocal 1
10166: oChoice 10171
10168: oReturn
10169: oJumpForward 10174
10171: Choice Lookup Table
          42   10168
10174: oJumpForward 10193
10176: Choice Lookup Table
          43   10164
          38   10152
          37   10140
          34   10115
          36   10115
          30   10115
          44   10090
          31   10090
10193: oError 15
10195: oJumpForward 10200
10197: Choice Lookup Table
           0   10087
10200: oReturn
10201: oLocalSpace 0
10203: oGetParam 2
10205: oPushResult
10206: oNodeType
10207: oPop 1
10209: oChoice 10291
10211: oEmit 17
10213: oGetParam 2
10215: oPushResult
10216: oCall 14818
10218: oPop 1
10220: oJumpForward 10302
10222: oEmit 18
10224: oGetParam 2
10226: oPushResult
10227: oCall 14818
10229: oPop 1
10231: oJumpForward 10302
10233: oGetParam 2
10235: oPushResult
10236: oSetResult 35
10238: oPushResult
10239: oNodeGetBoolean
10240: oPop 2
10242: oChoice 10255
10244: oEmit 8
10246: oGetParam 2
10248: oPushResult
10249: oCall 14818
10251: oPop 1
10253: oJumpForward 10267
10255: Choice Lookup Table
           1   10244
10258: oEmit 19
10260: oGetParam 2
10262: oPushResult
10263: oCall 14818
10265: oPop 1
10267: oJumpForward 10302
10269: oGetParam 1
10271: oChoice 10284
10273: oEmit 17
10275: oGetParam 2
10277: oPushResult
10278: oCall 14818
10280: oPop 1
10282: oJumpForward 10289
10284: Choice Lookup Table
           0   10273
10287: oError 4
10289: oJumpForward 10302
10291: Choice Lookup Table
          26   10269
          25   10233
          23   10222
          22   10211
10300: oError 4
10302: oGetParam 2
10304: oPushResult
10305: oSetResult 21
10307: oPushResult
10308: oNodeGet
10309: oPop 2
10311: oPushResult
10312: oTypeSPush
10313: oPop 1
10315: oTypeSNodeType
10316: oChoice 10331
10318: oInputChoice 10326
10320: oEmit 26
10322: oCall 8223
10324: oJumpForward 10329
10326: Choice Lookup Table
          17   10320
10329: oJumpForward 10334
10331: Choice Lookup Table
          37   10318
10334: oCall 8028
10336: oReturn
10337: oLocalSpace 0
10339: oGetParam 1
10341: oPushResult
10342: oSetResult 1
10344: oPushResult
10345: oCall 10201
10347: oPop 2
10349: oCall 9341
10351: oGetParam 1
10353: oPushResult
10354: oCall 7215
10356: oPop 1
10358: oTypeSPop
10359: oEmit 35
10361: oEmit 27
10363: oReturn
10364: oLocalSpace 0
10366: oGetParam 1
10368: oPushResult
10369: oSetResult 1
10371: oPushResult
10372: oCall 10201
10374: oPop 2
10376: oCall 9341
10378: oGetParam 1
10380: oPushResult
10381: oCall 7215
10383: oPop 1
10385: oTypeSPop
10386: oEmit 36
10388: oEmit 27
10390: oReturn
10391: oLocalSpace 2
10393: oGetAddrLocal 1
10395: oPushResult
10396: oSetResult 0
10398: oAssign
10399: oGetAddrLocal 1
10401: oPushResult
10402: oCall 5093
10404: oPop 1
10406: oInput 43
10408: oCall 9503
10410: oInputChoice 10445
10412: oGetAddrLocal 2
10414: oPushResult
10415: oLabelNew
10416: oAssign
10417: oEmit 82
10419: oGetLocal 2
10421: oPushResult
10422: oEmitLabel
10423: oPop 1
10425: oEmit 91
10427: oGetLocal 1
10429: oPushResult
10430: oEmitLabel
10431: oPop 1
10433: oCall 9503
10435: oEmit 91
10437: oGetLocal 2
10439: oPushResult
10440: oEmitLabel
10441: oPop 1
10443: oJumpForward 10456
10445: Choice Lookup Table
          44   10412
10448: oEmit 91
10450: oGetLocal 1
10452: oPushResult
10453: oEmitLabel
10454: oPop 1
10456: oReturn
10457: oLocalSpace 4
10459: oInput 0
10461: oGetAddrLocal 1
10463: oPushResult
10464: oScopeFindRequire
10465: oAssign
10466: oGetLocal 1
10468: oPushResult
10469: oSetResult 1
10471: oPushResult
10472: oCall 10201
10474: oPop 2
10476: oCall 9341
10478: oInput 5
10480: oCall 5047
10482: oCall 9341
10484: oEmit 27
10486: oGetAddrLocal 2
10488: oPushResult
10489: oLabelNew
10490: oAssign
10491: oGetAddrLocal 3
10493: oPushResult
10494: oLabelNew
10495: oAssign
10496: oEmit 82
10498: oGetLocal 3
10500: oPushResult
10501: oEmitLabel
10502: oPop 1
10504: oGetAddrLocal 4
10506: oPushResult
10507: oLabelNew
10508: oAssign
10509: oEmit 91
10511: oGetLocal 4
10513: oPushResult
10514: oEmitLabel
10515: oPop 1
10517: oInputChoice 10597
10519: oGetLocal 1
10521: oPushResult
10522: oCall 10337
10524: oPop 1
10526: oEmit 91
10528: oGetLocal 3
10530: oPushResult
10531: oEmitLabel
10532: oPop 1
10534: oGetLocal 1
10536: oPushResult
10537: oCall 7215
10539: oPop 1
10541: oTypeSPop
10542: oCall 5047
10544: oCall 9341
10546: oEmit 59
10548: oEmit 83
10550: oGetLocal 2
10552: oPushResult
10553: oEmitLabel
10554: oPop 1
10556: oJumpForward 10603
10558: oGetLocal 1
10560: oPushResult
10561: oCall 10364
10563: oPop 1
10565: oEmit 91
10567: oGetLocal 3
10569: oPushResult
10570: oEmitLabel
10571: oPop 1
10573: oGetLocal 1
10575: oPushResult
10576: oCall 7215
10578: oPop 1
10580: oTypeSPop
10581: oCall 5047
10583: oCall 9341
10585: oEmit 60
10587: oEmit 83
10589: oGetLocal 2
10591: oPushResult
10592: oEmitLabel
10593: oPop 1
10595: oJumpForward 10603
10597: Choice Lookup Table
          47   10558
          46   10519
10602: oEndChoice
10603: oGetLocal 4
10605: oPushResult
10606: oGetLocal 2
10608: oPushResult
10609: oLoopPush
10610: oPop 2
10612: oInput 48
10614: oCall 9503
10616: oEmit 82
10618: oGetLocal 4
10620: oPushResult
10621: oEmitLabel
10622: oPop 1
10624: oEmit 91
10626: oGetLocal 2
10628: oPushResult
10629: oEmitLabel
10630: oPop 1
10632: oLoopPop
10633: oReturn
10634: oLocalSpace 3
10636: oGetAddrLocal 1
10638: oPushResult
10639: oLabelNew
10640: oAssign
10641: oEmit 91
10643: oGetLocal 1
10645: oPushResult
10646: oEmitLabel
10647: oPop 1
10649: oGetAddrLocal 2
10651: oPushResult
10652: oLabelNew
10653: oAssign
10654: oGetLocal 1
10656: oPushResult
10657: oGetLocal 2
10659: oPushResult
10660: oLoopPush
10661: oPop 2
10663: oCall 9503
10665: oInputChoice 10696
10667: oCall 9503
10669: oJumpForward 10702
10671: oGetAddrLocal 3
10673: oPushResult
10674: oCall 5093
10676: oPop 1
10678: oEmit 92
10680: oGetLocal 3
10682: oPushResult
10683: oEmitLabel
10684: oPop 1
10686: oGetLocal 1
10688: oPushResult
10689: oEmitLabel
10690: oPop 1
10692: oJumpForward 10704
10694: oJumpForward 10702
10696: Choice Lookup Table
          51   10671
           6   10667
10701: oEndChoice
10702: oJumpBack 10665
10704: oEmit 91
10706: oGetLocal 2
10708: oPushResult
10709: oEmitLabel
10710: oPop 1
10712: oLoopPop
10713: oReturn
10714: oLocalSpace 2
10716: oGetAddrLocal 1
10718: oPushResult
10719: oLabelNew
10720: oAssign
10721: oEmit 91
10723: oGetLocal 1
10725: oPushResult
10726: oEmitLabel
10727: oPop 1
10729: oGetAddrLocal 2
10731: oPushResult
10732: oCall 5093
10734: oPop 1
10736: oGetLocal 1
10738: oPushResult
10739: oGetLocal 2
10741: oPushResult
10742: oLoopPush
10743: oPop 2
10745: oInput 48
10747: oCall 9503
10749: oEmit 82
10751: oGetLocal 1
10753: oPushResult
10754: oEmitLabel
10755: oPop 1
10757: oEmit 91
10759: oGetLocal 2
10761: oPushResult
10762: oEmitLabel
10763: oPop 1
10765: oLoopPop
10766: oReturn
10767: oLocalSpace 0
10769: oLoopContinueLabel
10770: oPushResult
10771: oSetResult 0
10773: oPushResult
10774: equal_label
10775: oPop 2
10777: oChoice 10792
10779: oError 19
10781: oJumpForward 10798
10783: oEmit 82
10785: oLoopContinueLabel
10786: oPushResult
10787: oEmitLabel
10788: oPop 1
10790: oJumpForward 10798
10792: Choice Lookup Table
           0   10783
           1   10779
10797: oEndChoice
10798: oReturn
10799: oLocalSpace 0
10801: oLoopBreakLabel
10802: oPushResult
10803: oSetResult 0
10805: oPushResult
10806: equal_label
10807: oPop 2
10809: oChoice 10824
10811: oError 19
10813: oJumpForward 10830
10815: oEmit 82
10817: oLoopBreakLabel
10818: oPushResult
10819: oEmitLabel
10820: oPop 1
10822: oJumpForward 10830
10824: Choice Lookup Table
           0   10815
           1   10811
10829: oEndChoice
10830: oReturn
10831: oLocalSpace 8
10833: oGetAddrLocal 1
10835: oPushResult
10836: oCodeNew
10837: oAssign
10838: oGetAddrLocal 2
10840: oPushResult
10841: oLabelNew
10842: oAssign
10843: oGetAddrLocal 3
10845: oPushResult
10846: oLabelNew
10847: oAssign
10848: oGetAddrLocal 4
10850: oPushResult
10851: oGetLocal 3
10853: oAssign
10854: oGetAddrLocal 5
10856: oPushResult
10857: oSetResult 0
10859: oAssign
10860: oCall 5047
10862: oTypeSNodeType
10863: oChoice 10901
10865: oEmit 85
10867: oGetLocal 2
10869: oPushResult
10870: oEmitLabel
10871: oPop 1
10873: oJumpForward 10918
10875: oEmit 86
10877: oGetLocal 2
10879: oPushResult
10880: oEmitLabel
10881: oPop 1
10883: oJumpForward 10918
10885: oGetAddrLocal 5
10887: oPushResult
10888: oSetResult 1
10890: oAssign
10891: oEmit 87
10893: oGetLocal 2
10895: oPushResult
10896: oEmitLabel
10897: oPop 1
10899: oJumpForward 10918
10901: Choice Lookup Table
          42   10885
          43   10885
          44   10875
          31   10875
          36   10865
          30   10865
          34   10865
10916: oError 18
10918: oInput 41
10920: oInputChoice 10967
10922: oGetAddrLocal 4
10924: oPushResult
10925: oLabelNew
10926: oAssign
10927: oEmit 91
10929: oGetLocal 4
10931: oPushResult
10932: oEmitLabel
10933: oPop 1
10935: oInputChoice 10941
10937: oJumpForward 10959
10939: oJumpForward 10957
10941: Choice Lookup Table
          37   10937
10944: oCall 9503
10946: oInputChoice 10950
10948: oJumpForward 10957
10950: Choice Lookup Table
           6   10948
10953: oInput 37
10955: oJumpForward 10959
10957: oJumpBack 10935
10959: oJumpForward 11133
10961: oJumpForward 11131
10963: oJumpForward 11133
10965: oJumpForward 11131
10967: Choice Lookup Table
          37   10963
          44   10922
          55   10922
10974: oGetAddrLocal 6
10976: oPushResult
10977: oLabelNew
10978: oAssign
10979: oGetLocal 1
10981: oPushResult
10982: oCodePush
10983: oPop 1
10985: oCall 3586
10987: oCall 4478
10989: oGetLocal 5
10991: oChoice 11011
10993: oGetAddrLocal 7
10995: oPushResult
10996: oValueTopString
10997: oPushResult
10998: oStringAllocShortStringLit
10999: oPop 1
11001: oAssign
11002: oJumpForward 11017
11004: oGetAddrLocal 7
11006: oPushResult
11007: oValueTop
11008: oAssign
11009: oJumpForward 11017
11011: Choice Lookup Table
           0   11004
           1   10993
11016: oEndChoice
11017: oValuePop
11018: oInputChoice 11075
11020: oCall 3586
11022: oCall 4478
11024: oGetLocal 5
11026: oChoice 11046
11028: oGetAddrLocal 8
11030: oPushResult
11031: oValueTopString
11032: oPushResult
11033: oStringAllocShortStringLit
11034: oPop 1
11036: oAssign
11037: oJumpForward 11052
11039: oGetAddrLocal 8
11041: oPushResult
11042: oValueTop
11043: oAssign
11044: oJumpForward 11052
11046: Choice Lookup Table
           0   11039
           1   11028
11051: oEndChoice
11052: oValuePop
11053: oEmit 89
11055: oGetLocal 7
11057: oPushResult
11058: oEmitInt
11059: oPop 1
11061: oGetLocal 8
11063: oPushResult
11064: oEmitInt
11065: oPop 1
11067: oGetLocal 6
11069: oPushResult
11070: oEmitLabel
11071: oPop 1
11073: oJumpForward 11092
11075: Choice Lookup Table
          22   11020
11078: oEmit 88
11080: oGetLocal 7
11082: oPushResult
11083: oEmitInt
11084: oPop 1
11086: oGetLocal 6
11088: oPushResult
11089: oEmitLabel
11090: oPop 1
11092: oInputChoice 11096
11094: oJumpForward 11101
11096: Choice Lookup Table
          14   11094
11099: oJumpForward 11103
11101: oJumpBack 10985
11103: oCodePop
11104: oInput 13
11106: oEmit 91
11108: oGetLocal 6
11110: oPushResult
11111: oEmitLabel
11112: oPop 1
11114: oCall 9503
11116: oEmit 82
11118: oGetLocal 3
11120: oPushResult
11121: oEmitLabel
11122: oPop 1
11124: oInputChoice 11128
11126: oJumpForward 11131
11128: Choice Lookup Table
           6   11126
11131: oJumpBack 10920
11133: oEmit 91
11135: oGetLocal 2
11137: oPushResult
11138: oEmitLabel
11139: oPop 1
11141: oGetLocal 1
11143: oPushResult
11144: oEmitCode
11145: oPop 1
11147: oEmit 90
11149: oGetLocal 4
11151: oPushResult
11152: oEmitLabel
11153: oPop 1
11155: oEmit 91
11157: oGetLocal 3
11159: oPushResult
11160: oEmitLabel
11161: oPop 1
11163: oTypeSPop
11164: oReturn
11165: oLocalSpace 1
11167: oInputChoice 11174
11169: oJumpForward 11180
11171: oChangeIntLitToLabelIdent
11172: oJumpForward 11180
11174: Choice Lookup Table
           1   11171
           0   11169
11179: oEndChoice
11180: oGetAddrLocal 1
11182: oPushResult
11183: oScopeCurrent
11184: oPushResult
11185: oScopeFindRequireInScope
11186: oPop 1
11188: oAssign
11189: oGetLocal 1
11191: oPushResult
11192: oSetResult 28
11194: oPushResult
11195: oSetResult 1
11197: oPushResult
11198: oNodeSetBoolean
11199: oPop 3
11201: oEmit 82
11203: oGetLocal 1
11205: oPushResult
11206: oSetResult 22
11208: oPushResult
11209: oNodeGetLabel
11210: oPop 2
11212: oPushResult
11213: oEmitLabel
11214: oPop 1
11216: oReturn
11217: oLocalSpace 0
11219: oCall 9503
11221: oInputChoice 11231
11223: oCall 9503
11225: oJumpForward 11237
11227: oJumpForward 11239
11229: oJumpForward 11237
11231: Choice Lookup Table
          37   11227
           6   11223
11236: oEndChoice
11237: oJumpBack 11221
11239: oReturn
11240: oLocalSpace 0
11242: oCall 11247
11244: oEmit 102
11246: oReturn
11247: oLocalSpace 0
11249: oInputChoice 11373
11251: oCall 5047
11253: oTypeSNodeType
11254: oChoice 11329
11256: oEmit 94
11258: oJumpForward 11354
11260: oEmit 95
11262: oJumpForward 11354
11264: oEmit 32
11266: oEmit 94
11268: oJumpForward 11354
11270: oEmit 96
11272: oJumpForward 11354
11274: oEmit 101
11276: oJumpForward 11354
11278: oEmit 97
11280: oJumpForward 11354
11282: oError 17
11284: oJumpForward 11354
11286: oEmit 17
11288: oTypeSTop
11289: oPushResult
11290: oSetResult 44
11292: oPushResult
11293: oNodeGetInt
11294: oPop 2
11296: oPushResult
11297: oEmitInt
11298: oPop 1
11300: oEmit 100
11302: oJumpForward 11354
11304: oTypeSTop
11305: oPushResult
11306: oGetGlobal 10
11308: oPushResult
11309: equal_node
11310: oPop 2
11312: oChoice 11318
11314: oEmit 98
11316: oJumpForward 11323
11318: Choice Lookup Table
           1   11314
11321: oEmit 99
11323: oJumpForward 11354
11325: oEmit 99
11327: oJumpForward 11354
11329: Choice Lookup Table
          38   11325
          37   11304
          44   11286
          29   11282
          42   11278
          43   11278
          33   11274
          36   11270
          30   11264
          34   11260
          31   11256
11352: oError 18
11354: oTypeSPop
11355: oInputChoice 11363
11357: oJumpForward 11371
11359: oJumpForward 11369
11361: oJumpForward 11369
11363: Choice Lookup Table
          14   11361
          16   11357
11368: oEndChoice
11369: oJumpBack 11251
11371: oJumpForward 11376
11373: Choice Lookup Table
          15   11251
11376: oReturn
11377: oLocalSpace 0
11379: oCall 11384
11381: oEmit 106
11383: oReturn
11384: oLocalSpace 1
11386: oInputChoice 11463
11388: oSetResult 1
11390: oPushResult
11391: oCall 9957
11393: oPop 1
11395: oTypeSNodeType
11396: oChoice 11435
11398: oEmit 103
11400: oJumpForward 11444
11402: oEmit 104
11404: oJumpForward 11444
11406: oGetAddrLocal 1
11408: oPushResult
11409: oTypeSTop
11410: oPushResult
11411: oSetResult 17
11413: oPushResult
11414: oNodeGetInt
11415: oPop 2
11417: oPushResult
11418: oSetResult 1
11420: oPushResult
11421: subtract
11422: oPop 2
11424: oAssign
11425: oEmit 105
11427: oGetLocal 1
11429: oPushResult
11430: oEmitInt
11431: oPop 1
11433: oJumpForward 11444
11435: Choice Lookup Table
          43   11406
          36   11402
          31   11398
11442: oError 18
11444: oTypeSPop
11445: oInputChoice 11453
11447: oJumpForward 11461
11449: oJumpForward 11459
11451: oJumpForward 11459
11453: Choice Lookup Table
          14   11451
          16   11447
11458: oEndChoice
11459: oJumpBack 11388
11461: oJumpForward 11466
11463: Choice Lookup Table
          15   11388
11466: oReturn
11467: oLocalSpace 1
11469: oGetAddrLocal 1
11471: oPushResult
11472: oGetGlobal 16
11474: oPushResult
11475: oScopeAllocType
11476: oPop 1
11478: oAssign
11479: oTypeSNodeType
11480: oChoice 11548
11482: oEmit 18
11484: oGetLocal 1
11486: oPushResult
11487: oEmitInt
11488: oPop 1
11490: oEmit 23
11492: oEmit 31
11494: oGetGlobal 16
11496: oPushResult
11497: oSetResult 17
11499: oPushResult
11500: oNodeGetInt
11501: oPop 2
11503: oPushResult
11504: oEmitInt
11505: oPop 1
11507: oJumpForward 11557
11509: oEmit 18
11511: oGetLocal 1
11513: oPushResult
11514: oEmitInt
11515: oPop 1
11517: oEmit 15
11519: oSetResult 1
11521: oPushResult
11522: oEmitInt
11523: oPop 1
11525: oEmit 28
11527: oEmit 18
11529: oGetLocal 1
11531: oPushResult
11532: oSetResult 1
11534: oPushResult
11535: add
11536: oPop 2
11538: oPushResult
11539: oEmitInt
11540: oPop 1
11542: oEmit 23
11544: oEmit 28
11546: oJumpForward 11557
11548: Choice Lookup Table
          36   11509
          42   11482
          43   11482
11555: oError 15
11557: oTypeSPop
11558: oEmit 18
11560: oGetLocal 1
11562: oPushResult
11563: oEmitInt
11564: oPop 1
11566: oGetGlobal 16
11568: oPushResult
11569: oTypeSPush
11570: oPop 1
11572: oGetLocal 1
11574: oReturn
11575: oReturn
11576: oLocalSpace 0
11578: oEmit 75
11580: oSetResult 16
11582: oPushResult
11583: oEmitInt
11584: oPop 1
11586: oEmit 20
11588: oSetResult 8
11590: oPushResult
11591: oEmitInt
11592: oPop 1
11594: oEmit 23
11596: oEmit 29
11598: oEmit 20
11600: oSetResult 0
11602: oPushResult
11603: oEmitInt
11604: oPop 1
11606: oEmit 23
11608: oEmit 29
11610: oEmit 78
11612: oGetGlobal 22
11614: oPushResult
11615: oCall 14818
11617: oPop 1
11619: oEmit 77
11621: oSetResult 16
11623: oPushResult
11624: oEmitInt
11625: oPop 1
11627: oTypeSPop
11628: oTypeSPop
11629: oReturn
11630: oLocalSpace 0
11632: oEmit 75
11634: oSetResult 12
11636: oPushResult
11637: oEmitInt
11638: oPop 1
11640: oEmit 20
11642: oSetResult 8
11644: oPushResult
11645: oEmitInt
11646: oPop 1
11648: oEmit 23
11650: oEmit 28
11652: oEmit 20
11654: oSetResult 0
11656: oPushResult
11657: oEmitInt
11658: oPop 1
11660: oEmit 23
11662: oEmit 29
11664: oEmit 78
11666: oGetGlobal 23
11668: oPushResult
11669: oCall 14818
11671: oPop 1
11673: oEmit 77
11675: oSetResult 12
11677: oPushResult
11678: oEmitInt
11679: oPop 1
11681: oTypeSPop
11682: oTypeSPop
11683: oReturn
11684: oLocalSpace 1
11686: oEmit 76
11688: oSetResult 24
11690: oPushResult
11691: oEmitInt
11692: oPop 1
11694: oEmit 20
11696: oSetResult 8
11698: oPushResult
11699: oEmitInt
11700: oPop 1
11702: oEmit 23
11704: oEmit 29
11706: oEmit 20
11708: oSetResult 0
11710: oPushResult
11711: oEmitInt
11712: oPop 1
11714: oEmit 23
11716: oEmit 29
11718: oGetAddrLocal 1
11720: oPushResult
11721: oGetGlobal 6
11723: oPushResult
11724: oScopeAllocType
11725: oPop 1
11727: oAssign
11728: oEmit 20
11730: oSetResult 16
11732: oPushResult
11733: oEmitInt
11734: oPop 1
11736: oEmit 18
11738: oGetLocal 1
11740: oPushResult
11741: oEmitInt
11742: oPop 1
11744: oEmit 29
11746: oEmit 79
11748: oGetGlobal 24
11750: oPushResult
11751: oCall 14818
11753: oPop 1
11755: oEmit 3
11757: oGetLocal 1
11759: oPushResult
11760: oEmitInt
11761: oPop 1
11763: oEmit 77
11765: oSetResult 24
11767: oPushResult
11768: oEmitInt
11769: oPop 1
11771: oTypeSPop
11772: oGetGlobal 6
11774: oPushResult
11775: oTypeSPush
11776: oPop 1
11778: oReturn
11779: oLocalSpace 10
11781: oGetParam 1
11783: oPushResult
11784: oSetResult 28
11786: oPushResult
11787: oSetResult 1
11789: oPushResult
11790: oNodeSetBoolean
11791: oPop 3
11793: oGetAddrLocal 1
11795: oPushResult
11796: oGetParam 1
11798: oPushResult
11799: oSetResult 27
11801: oPushResult
11802: oNodeGetBoolean
11803: oPop 2
11805: oAssign
11806: oGetAddrLocal 4
11808: oPushResult
11809: oGetParam 1
11811: oPushResult
11812: oNodeType
11813: oPop 1
11815: oPushResult
11816: oSetResult 13
11818: oPushResult
11819: equal_node_type
11820: oPop 2
11822: oAssign
11823: oGetLocal 4
11825: oChoice 11852
11827: oGetAddrLocal 2
11829: oPushResult
11830: oGetParam 1
11832: oPushResult
11833: oSetResult 21
11835: oPushResult
11836: oNodeGet
11837: oPop 2
11839: oAssign
11840: oGetAddrLocal 3
11842: oPushResult
11843: oGetLocal 2
11845: oPushResult
11846: oScopeAllocType
11847: oPop 1
11849: oAssign
11850: oJumpForward 11855
11852: Choice Lookup Table
           1   11827
11855: oGetAddrLocal 5
11857: oPushResult
11858: oGetParam 1
11860: oPushResult
11861: oSetResult 23
11863: oPushResult
11864: oNodeGet
11865: oPop 2
11867: oAssign
11868: oGetAddrLocal 6
11870: oPushResult
11871: oGetLocal 5
11873: oPushResult
11874: oSetResult 17
11876: oPushResult
11877: oNodeGetInt
11878: oPop 2
11880: oAssign
11881: oGetLocal 1
11883: oChoice 11905
11885: oEmit 76
11887: oGetLocal 6
11889: oPushResult
11890: oEmitInt
11891: oPop 1
11893: oJumpForward 11911
11895: oEmit 75
11897: oGetLocal 6
11899: oPushResult
11900: oEmitInt
11901: oPop 1
11903: oJumpForward 11911
11905: Choice Lookup Table
           0   11895
           1   11885
11910: oEndChoice
11911: oGetParam 1
11913: oPushResult
11914: oCall 14752
11916: oPop 1
11918: oPushResult
11919: oSetResult 0
11921: oPushResult
11922: greater
11923: oPop 2
11925: oChoice 11958
11927: oEmit 20
11929: oSetResult 0
11931: oPushResult
11932: oEmitInt
11933: oPop 1
11935: oEmit 21
11937: oGetParam 1
11939: oPushResult
11940: oCall 14772
11942: oPop 1
11944: oPushResult
11945: oEmitInt
11946: oPop 1
11948: oSetResult 0
11950: oPushResult
11951: oEmitInt
11952: oPop 1
11954: oEmit 29
11956: oJumpForward 11961
11958: Choice Lookup Table
           1   11927
11961: oGetAddrLocal 7
11963: oPushResult
11964: oGetLocal 5
11966: oPushResult
11967: oSetResult 15
11969: oPushResult
11970: oNodeGetIter
11971: oPop 2
11973: oAssign
11974: oGetAddrLocal 8
11976: oPushResult
11977: oGetLocal 7
11979: oPushResult
11980: oNodeIterValue
11981: oPop 1
11983: oAssign
11984: oInputChoice 12187
11986: oGetLocal 8
11988: oPushResult
11989: oNodeNull
11990: oPop 1
11992: oChoice 11998
11994: oJumpForward 12183
11996: oJumpForward 12001
11998: Choice Lookup Table
           1   11994
12001: oGetAddrLocal 9
12003: oPushResult
12004: oGetLocal 8
12006: oPushResult
12007: oSetResult 22
12009: oPushResult
12010: oNodeGetInt
12011: oPop 2
12013: oAssign
12014: oEmit 20
12016: oGetLocal 9
12018: oPushResult
12019: oEmitInt
12020: oPop 1
12022: oGetLocal 8
12024: oPushResult
12025: oSetResult 21
12027: oPushResult
12028: oNodeGet
12029: oPop 2
12031: oPushResult
12032: oTypeSPush
12033: oPop 1
12035: oGetLocal 8
12037: oPushResult
12038: oSetResult 35
12040: oPushResult
12041: oNodeGetBoolean
12042: oPop 2
12044: oChoice 12136
12046: oSetResult 1
12048: oPushResult
12049: oCall 9957
12051: oPop 1
12053: oCall 9283
12055: oEmit 29
12057: oJumpForward 12142
12059: oCall 5047
12061: oCall 8645
12063: oTypeSNodeType
12064: oChoice 12108
12066: oEmit 27
12068: oJumpForward 12134
12070: oEmit 28
12072: oJumpForward 12134
12074: oEmit 30
12076: oJumpForward 12134
12078: oError 17
12080: oJumpForward 12134
12082: oEmit 29
12084: oJumpForward 12134
12086: oGetAddrLocal 10
12088: oPushResult
12089: oTypeSTop
12090: oPushResult
12091: oSetResult 17
12093: oPushResult
12094: oNodeGetInt
12095: oPop 2
12097: oAssign
12098: oEmit 31
12100: oGetLocal 10
12102: oPushResult
12103: oEmitInt
12104: oPop 1
12106: oJumpForward 12134
12108: Choice Lookup Table
          43   12086
          41   12086
          39   12086
          38   12082
          37   12082
          29   12078
          33   12074
          36   12070
          30   12070
          34   12070
          44   12066
          31   12066
12133: oEndChoice
12134: oJumpForward 12142
12136: Choice Lookup Table
           0   12059
           1   12046
12141: oEndChoice
12142: oTypeSPop
12143: oGetAddrLocal 7
12145: oPushResult
12146: oNodeIterNext
12147: oPop 1
12149: oGetAddrLocal 8
12151: oPushResult
12152: oGetLocal 7
12154: oPushResult
12155: oNodeIterValue
12156: oPop 1
12158: oAssign
12159: oGetLocal 8
12161: oPushResult
12162: oNodeNull
12163: oPop 1
12165: oChoice 12173
12167: oJumpForward 12183
12169: oJumpForward 12179
12171: oJumpForward 12179
12173: Choice Lookup Table
           0   12171
           1   12167
12178: oEndChoice
12179: oInput 14
12181: oJumpBack 11986
12183: oInput 16
12185: oJumpForward 12190
12187: Choice Lookup Table
          15   11986
12190: oGetLocal 8
12192: oPushResult
12193: oNodeNull
12194: oPop 1
12196: oChoice 12202
12198: oError 16
12200: oJumpForward 12205
12202: Choice Lookup Table
           0   12198
12205: oGetLocal 4
12207: oChoice 12236
12209: oEmit 20
12211: oGetParam 1
12213: oPushResult
12214: oSetResult 31
12216: oPushResult
12217: oNodeGetInt
12218: oPop 2
12220: oPushResult
12221: oEmitInt
12222: oPop 1
12224: oEmit 18
12226: oGetLocal 3
12228: oPushResult
12229: oEmitInt
12230: oPop 1
12232: oEmit 29
12234: oJumpForward 12239
12236: Choice Lookup Table
           1   12209
12239: oGetLocal 1
12241: oChoice 12265
12243: oEmit 79
12245: oGetParam 1
12247: oPushResult
12248: oCall 14818
12250: oPop 1
12252: oJumpForward 12271
12254: oEmit 78
12256: oGetParam 1
12258: oPushResult
12259: oCall 14818
12261: oPop 1
12263: oJumpForward 12271
12265: Choice Lookup Table
           0   12254
           1   12243
12270: oEndChoice
12271: oGetLocal 4
12273: oChoice 12354
12275: oGetLocal 2
12277: oPushResult
12278: oTypeSPush
12279: oPop 1
12281: oTypeSNodeType
12282: oChoice 12328
12284: oEmit 3
12286: oGetLocal 3
12288: oPushResult
12289: oEmitInt
12290: oPop 1
12292: oJumpForward 12352
12294: oEmit 4
12296: oGetLocal 3
12298: oPushResult
12299: oEmitInt
12300: oPop 1
12302: oJumpForward 12352
12304: oError 17
12306: oJumpForward 12352
12308: oEmit 5
12310: oGetLocal 3
12312: oPushResult
12313: oEmitInt
12314: oPop 1
12316: oJumpForward 12352
12318: oEmit 18
12320: oGetLocal 3
12322: oPushResult
12323: oEmitInt
12324: oPop 1
12326: oJumpForward 12352
12328: Choice Lookup Table
          43   12318
          41   12318
          39   12318
          38   12308
          37   12308
          29   12304
          36   12294
          30   12294
          34   12294
          44   12284
          31   12284
12351: oEndChoice
12352: oJumpForward 12357
12354: Choice Lookup Table
           1   12275
12357: oEmit 77
12359: oGetLocal 6
12361: oPushResult
12362: oEmitInt
12363: oPop 1
12365: oReturn
12366: oLocalSpace 2
12368: oGetAddrLocal 2
12370: oPushResult
12371: oGetParam 1
12373: oPushResult
12374: oSetResult 26
12376: oPushResult
12377: oNodeGetString
12378: oPop 2
12380: oAssign
12381: oGetLocal 2
12383: oPushResult
12384: oSetResult 0
12386: oPushResult
12387: equal_string
12388: oPop 2
12390: oChoice 12427
12392: oGetAddrLocal 1
12394: oPushResult
12395: oGetParam 1
12397: oPushResult
12398: oSetResult 4
12400: oPushResult
12401: oNodeGetInt
12402: oPop 2
12404: oPushResult
12405: ID_STRING
12406: oPop 1
12408: oPushResult
12409: oStringAllocLit
12410: oPop 1
12412: oAssign
12413: oJumpForward 12433
12415: oGetAddrLocal 1
12417: oPushResult
12418: oGetLocal 2
12420: oPushResult
12421: oStringAllocLit
12422: oPop 1
12424: oAssign
12425: oJumpForward 12433
12427: Choice Lookup Table
           0   12415
           1   12392
12432: oEndChoice
12433: oEmit 93
12435: oGetParam 1
12437: oPushResult
12438: oCall 14818
12440: oPop 1
12442: oGetLocal 1
12444: oPushResult
12445: oEmitInt
12446: oPop 1
12448: oReturn
12449: oLocalSpace 2
12451: oGetParam 1
12453: oPushResult
12454: oGetGlobal 17
12456: oPushResult
12457: oNodeEqual
12458: oPop 2
12460: oChoice 12500
12462: oInput 15
12464: oCall 5047
12466: oTypeSNodeType
12467: oChoice 12475
12469: oJumpForward 12488
12471: oEmit 32
12473: oJumpForward 12488
12475: Choice Lookup Table
          36   12471
          30   12471
          34   12471
          44   12469
          31   12469
12486: oError 15
12488: oTypeSPop
12489: oGetGlobal 6
12491: oPushResult
12492: oTypeSPush
12493: oPop 1
12495: oInput 16
12497: oReturn
12498: oJumpForward 12503
12500: Choice Lookup Table
           1   12462
12503: oGetParam 1
12505: oPushResult
12506: oGetGlobal 18
12508: oPushResult
12509: oNodeEqual
12510: oPop 2
12512: oChoice 12546
12514: oInput 15
12516: oCall 5047
12518: oTypeSNodeType
12519: oChoice 12527
12521: oEmit 33
12523: oJumpForward 12534
12525: oJumpForward 12534
12527: Choice Lookup Table
          30   12525
          31   12521
12532: oError 15
12534: oTypeSPop
12535: oGetGlobal 9
12537: oPushResult
12538: oTypeSPush
12539: oPop 1
12541: oInput 16
12543: oReturn
12544: oJumpForward 12549
12546: Choice Lookup Table
           1   12514
12549: oGetParam 1
12551: oPushResult
12552: oGetGlobal 19
12554: oPushResult
12555: oNodeEqual
12556: oPop 2
12558: oChoice 12598
12560: oInput 15
12562: oCall 5047
12564: oTypeSNodeType
12565: oChoice 12586
12567: oTypeSTop
12568: oPushResult
12569: oSetResult 45
12571: oPushResult
12572: oNodeGetBoolean
12573: oPop 2
12575: oChoice 12581
12577: oError 30
12579: oJumpForward 12584
12581: Choice Lookup Table
           1   12577
12584: oJumpForward 12591
12586: Choice Lookup Table
          44   12567
12589: oError 15
12591: oEmit 36
12593: oInput 16
12595: oReturn
12596: oJumpForward 12601
12598: Choice Lookup Table
           1   12560
12601: oGetParam 1
12603: oPushResult
12604: oGetGlobal 20
12606: oPushResult
12607: oNodeEqual
12608: oPop 2
12610: oChoice 12650
12612: oInput 15
12614: oCall 5047
12616: oTypeSNodeType
12617: oChoice 12638
12619: oTypeSTop
12620: oPushResult
12621: oSetResult 45
12623: oPushResult
12624: oNodeGetBoolean
12625: oPop 2
12627: oChoice 12633
12629: oError 30
12631: oJumpForward 12636
12633: Choice Lookup Table
           1   12629
12636: oJumpForward 12643
12638: Choice Lookup Table
          44   12619
12641: oError 15
12643: oEmit 35
12645: oInput 16
12647: oReturn
12648: oJumpForward 12653
12650: Choice Lookup Table
           1   12612
12653: oGetParam 1
12655: oPushResult
12656: oGetGlobal 21
12658: oPushResult
12659: oNodeEqual
12660: oPop 2
12662: oChoice 12718
12664: oInput 15
12666: oGetAddrLocal 1
12668: oPushResult
12669: oCodeNew
12670: oAssign
12671: oGetLocal 1
12673: oPushResult
12674: oCodePush
12675: oPop 1
12677: oCall 5070
12679: oCodePop
12680: oGetLocal 1
12682: oPushResult
12683: oCodeDiscard
12684: oPop 1
12686: oGetAddrLocal 2
12688: oPushResult
12689: oTypeSTop
12690: oAssign
12691: oTypeSPop
12692: oEmit 15
12694: oGetLocal 2
12696: oPushResult
12697: oSetResult 17
12699: oPushResult
12700: oNodeGetInt
12701: oPop 2
12703: oPushResult
12704: oEmitInt
12705: oPop 1
12707: oGetGlobal 6
12709: oPushResult
12710: oTypeSPush
12711: oPop 1
12713: oInput 16
12715: oReturn
12716: oJumpForward 12721
12718: Choice Lookup Table
           1   12664
12721: oError 17
12723: oReturn
12724: oLocalSpace 1
12726: oGetAddrLocal 1
12728: oPushResult
12729: oGetParam 2
12731: oPushResult
12732: oNodeNew
12733: oPop 1
12735: oAssign
12736: oGetLocal 1
12738: oPushResult
12739: oSetResult 17
12741: oPushResult
12742: oGetParam 1
12744: oPushResult
12745: oNodeSetInt
12746: oPop 3
12748: oGetLocal 1
12750: oPushResult
12751: oTypeAdd
12752: oPop 1
12754: oGetLocal 1
12756: oReturn
12757: oReturn
12758: oLocalSpace 12
12760: oInputChoice 13243
12762: oGetAddrLocal 1
12764: oPushResult
12765: oScopeFindRequire
12766: oAssign
12767: oGetAddrLocal 1
12769: oPushResult
12770: oCall 244
12772: oPop 1
12774: oGetLocal 1
12776: oPushResult
12777: oNodeType
12778: oPop 1
12780: oChoice 12797
12782: oGetParam 1
12784: oPushResult
12785: oGetLocal 1
12787: oPushResult
12788: oSetResult 21
12790: oPushResult
12791: oNodeGet
12792: oPop 2
12794: oAssign
12795: oJumpForward 12808
12797: Choice Lookup Table
          20   12782
12800: oError 2
12802: oGetParam 1
12804: oPushResult
12805: oGetGlobal 6
12807: oAssign
12808: oJumpForward 13266
12810: oInput 17
12812: oGetAddrLocal 2
12814: oPushResult
12815: oNodeVecNew
12816: oAssign
12817: oGetAddrLocal 3
12819: oPushResult
12820: oSetResult 40
12822: oPushResult
12823: oNodeNew
12824: oPop 1
12826: oAssign
12827: oCall 3586
12829: oGetLocal 3
12831: oPushResult
12832: oSetResult 40
12834: oPushResult
12835: oValueTop
12836: oPushResult
12837: oNodeSetInt
12838: oPop 3
12840: oValuePop
12841: oInput 22
12843: oCall 3586
12845: oGetLocal 3
12847: oPushResult
12848: oSetResult 41
12850: oPushResult
12851: oValueTop
12852: oPushResult
12853: oNodeSetInt
12854: oPop 3
12856: oValuePop
12857: oCall 4381
12859: oGetLocal 3
12861: oPushResult
12862: oSetResult 38
12864: oPushResult
12865: oTypeSTop
12866: oPushResult
12867: oNodeSet
12868: oPop 3
12870: oGetLocal 3
12872: oPushResult
12873: oSetResult 17
12875: oPushResult
12876: oTypeSTop
12877: oPushResult
12878: oSetResult 17
12880: oPushResult
12881: oNodeGetInt
12882: oPop 2
12884: oPushResult
12885: oNodeSetInt
12886: oPop 3
12888: oTypeSPop
12889: oGetLocal 3
12891: oPushResult
12892: oTypeAdd
12893: oPop 1
12895: oGetAddrLocal 4
12897: oPushResult
12898: oSetResult 39
12900: oPushResult
12901: oNodeNew
12902: oPop 1
12904: oAssign
12905: oGetLocal 4
12907: oPushResult
12908: oSetResult 39
12910: oPushResult
12911: oGetLocal 3
12913: oPushResult
12914: oNodeSet
12915: oPop 3
12917: oGetLocal 2
12919: oPushResult
12920: oGetLocal 4
12922: oPushResult
12923: oNodeVecAppend
12924: oPop 2
12926: oInputChoice 12934
12928: oJumpForward 12942
12930: oJumpForward 12940
12932: oJumpForward 12940
12934: Choice Lookup Table
          14   12932
          18   12928
12939: oEndChoice
12940: oJumpBack 12817
12942: oInput 41
12944: oGetAddrLocal 5
12946: oPushResult
12947: oCall 12758
12949: oPop 1
12951: oGetAddrLocal 6
12953: oPushResult
12954: oGetLocal 2
12956: oPushResult
12957: oNodeVecSize
12958: oPop 1
12960: oAssign
12961: oGetAddrLocal 6
12963: oPushResult
12964: dec
12965: oPop 1
12967: oGetAddrLocal 7
12969: oPushResult
12970: oGetLocal 2
12972: oPushResult
12973: oGetLocal 6
12975: oPushResult
12976: oNodeVecElement
12977: oPop 2
12979: oAssign
12980: oGetLocal 7
12982: oPushResult
12983: oSetResult 38
12985: oPushResult
12986: oGetLocal 5
12988: oPushResult
12989: oNodeSet
12990: oPop 3
12992: oGetAddrLocal 8
12994: oPushResult
12995: oGetLocal 7
12997: oPushResult
12998: oSetResult 39
13000: oPushResult
13001: oNodeGet
13002: oPop 2
13004: oAssign
13005: oGetAddrLocal 9
13007: oPushResult
13008: oGetLocal 8
13010: oPushResult
13011: oSetResult 41
13013: oPushResult
13014: oNodeGetInt
13015: oPop 2
13017: oPushResult
13018: oGetLocal 8
13020: oPushResult
13021: oSetResult 40
13023: oPushResult
13024: oNodeGetInt
13025: oPop 2
13027: oPushResult
13028: subtract
13029: oPop 2
13031: oAssign
13032: oGetAddrLocal 9
13034: oPushResult
13035: inc
13036: oPop 1
13038: oGetLocal 7
13040: oPushResult
13041: oSetResult 17
13043: oPushResult
13044: oGetLocal 9
13046: oPushResult
13047: oGetLocal 5
13049: oPushResult
13050: oSetResult 17
13052: oPushResult
13053: oNodeGetInt
13054: oPop 2
13056: oPushResult
13057: multiply
13058: oPop 2
13060: oPushResult
13061: oNodeSetInt
13062: oPop 3
13064: oGetLocal 7
13066: oPushResult
13067: oTypeAdd
13068: oPop 1
13070: oGetAddrLocal 5
13072: oPushResult
13073: oGetLocal 7
13075: oAssign
13076: oGetLocal 6
13078: oPushResult
13079: equal_zero
13080: oPop 1
13082: oChoice 13088
13084: oJumpForward 13093
13086: oJumpForward 13091
13088: Choice Lookup Table
           1   13084
13091: oJumpBack 12961
13093: oGetParam 1
13095: oPushResult
13096: oGetLocal 2
13098: oPushResult
13099: oSetResult 0
13101: oPushResult
13102: oNodeVecElement
13103: oPop 2
13105: oAssign
13106: oGetLocal 2
13108: oPushResult
13109: oNodeVecDelete
13110: oPop 1
13112: oJumpForward 13266
13114: oGetAddrLocal 10
13116: oPushResult
13117: oCall 12758
13119: oPop 1
13121: oGetParam 1
13123: oPushResult
13124: oGetLocal 10
13126: oPushResult
13127: oCall 13837
13129: oPop 1
13131: oAssign
13132: oJumpForward 13266
13134: oGetParam 1
13136: oPushResult
13137: oSetResult 41
13139: oPushResult
13140: oNodeNew
13141: oPop 1
13143: oAssign
13144: oSetResult -1
13146: oPushResult
13147: oSetResult 2
13149: oPushResult
13150: oScopeBegin
13151: oPop 2
13153: oSetResult 24
13155: oPushResult
13156: oCall 3287
13158: oPop 1
13160: oGetAddrLocal 11
13162: oPushResult
13163: oScopeCurrent
13164: oPushResult
13165: oSetResult 17
13167: oPushResult
13168: oNodeGetInt
13169: oPop 2
13171: oAssign
13172: oGetLocal 11
13174: oPushResult
13175: equal_zero
13176: oPop 1
13178: oChoice 13184
13180: oError 20
13182: oJumpForward 13187
13184: Choice Lookup Table
           1   13180
13187: oInput 37
13189: oGetFromParam 1
13191: oPushResult
13192: oSetResult 42
13194: oPushResult
13195: oScopeCurrent
13196: oPushResult
13197: oNodeSet
13198: oPop 3
13200: oGetFromParam 1
13202: oPushResult
13203: oSetResult 17
13205: oPushResult
13206: oGetLocal 11
13208: oPushResult
13209: oNodeSetInt
13210: oPop 3
13212: oScopeEnd
13213: oGetFromParam 1
13215: oPushResult
13216: oTypeAdd
13217: oPop 1
13219: oJumpForward 13266
13221: oGetParam 1
13223: oPushResult
13224: oCall 13267
13226: oPop 1
13228: oJumpForward 13266
13230: oInput 41
13232: oGetAddrLocal 12
13234: oPushResult
13235: oCall 12758
13237: oPop 1
13239: oError 17
13241: oJumpForward 13266
13243: Choice Lookup Table
          40   13230
          15   13221
          39   13134
          19   13114
          38   12810
           0   12762
13256: oCall 3586
13258: oInput 22
13260: oCall 3586
13262: oCall 4381
13264: oError 17
13266: oReturn
13267: oLocalSpace 11
13269: oGetParam 1
13271: oPushResult
13272: oSetResult 44
13274: oPushResult
13275: oNodeNew
13276: oPop 1
13278: oAssign
13279: oGetAddrLocal 1
13281: oPushResult
13282: oSetResult 0
13284: oAssign
13285: oGetAddrLocal 2
13287: oPushResult
13288: oSetResult 0
13290: oAssign
13291: oGetAddrLocal 3
13293: oPushResult
13294: oSetResult 1
13296: oAssign
13297: oGetAddrLocal 4
13299: oPushResult
13300: oScopeCurrent
13301: oAssign
13302: oSetResult -1
13304: oPushResult
13305: oSetResult 2
13307: oPushResult
13308: oScopeBegin
13309: oPop 2
13311: oInput 0
13313: oGetAddrLocal 5
13315: oPushResult
13316: oSetResult 17
13318: oPushResult
13319: LAST_ID
13320: oPushResult
13321: oCall 14790
13323: oPop 2
13325: oAssign
13326: oGetAddrLocal 6
13328: oPushResult
13329: oSetResult 17
13331: oPushResult
13332: LAST_ID
13333: oPushResult
13334: oCall 14790
13336: oPop 2
13338: oAssign
13339: oGetLocal 5
13341: oPushResult
13342: oSetResult 21
13344: oPushResult
13345: oGetFromParam 1
13347: oPushResult
13348: oNodeSet
13349: oPop 3
13351: oGetLocal 6
13353: oPushResult
13354: oSetResult 21
13356: oPushResult
13357: oGetFromParam 1
13359: oPushResult
13360: oNodeSet
13361: oPop 3
13363: oGetAddrLocal 7
13365: oPushResult
13366: LAST_ID
13367: oPushResult
13368: ID_STRING
13369: oPop 1
13371: oPushResult
13372: oStringAllocLit
13373: oPop 1
13375: oAssign
13376: oGetLocal 5
13378: oPushResult
13379: oSetResult 32
13381: oPushResult
13382: oGetLocal 7
13384: oPushResult
13385: oNodeSetInt
13386: oPop 3
13388: oGetLocal 6
13390: oPushResult
13391: oSetResult 32
13393: oPushResult
13394: oGetLocal 7
13396: oPushResult
13397: oNodeSetInt
13398: oPop 3
13400: oInputChoice 13478
13402: oGetGlobal 6
13404: oPushResult
13405: oTypeSPush
13406: oPop 1
13408: oCall 3586
13410: oCall 4478
13412: oTypeSPop
13413: oGetLocal 2
13415: oPushResult
13416: equal_zero
13417: oPop 1
13419: oChoice 13440
13421: oValueTop
13422: oPushResult
13423: oGetLocal 1
13425: oPushResult
13426: greater
13427: oPop 2
13429: oChoice 13435
13431: oError 28
13433: oJumpForward 13438
13435: Choice Lookup Table
           0   13431
13438: oJumpForward 13443
13440: Choice Lookup Table
           0   13421
13443: oGetLocal 1
13445: oPushResult
13446: oValueTop
13447: oPushResult
13448: equal
13449: oPop 2
13451: oChoice 13467
13453: oGetFromParam 1
13455: oPushResult
13456: oSetResult 45
13458: oPushResult
13459: oSetResult 1
13461: oPushResult
13462: oNodeSetBoolean
13463: oPop 3
13465: oJumpForward 13470
13467: Choice Lookup Table
           0   13453
13470: oGetAddrLocal 1
13472: oPushResult
13473: oValueTop
13474: oAssign
13475: oValuePop
13476: oJumpForward 13483
13478: Choice Lookup Table
           5   13402
           7   13402
13483: oGetLocal 5
13485: oPushResult
13486: oSetResult 22
13488: oPushResult
13489: oGetLocal 1
13491: oPushResult
13492: oNodeSetInt
13493: oPop 3
13495: oGetLocal 6
13497: oPushResult
13498: oSetResult 22
13500: oPushResult
13501: oGetLocal 1
13503: oPushResult
13504: oNodeSetInt
13505: oPop 3
13507: oGetLocal 5
13509: oPushResult
13510: oScopeDeclare
13511: oPop 1
13513: oGetLocal 4
13515: oPushResult
13516: oScopeEnter
13517: oPop 1
13519: oGetLocal 6
13521: oPushResult
13522: oScopeDeclare
13523: oPop 1
13525: oScopeEnd
13526: oGetAddrLocal 1
13528: oPushResult
13529: inc
13530: oPop 1
13532: oGetAddrLocal 2
13534: oPushResult
13535: inc
13536: oPop 1
13538: oInputChoice 13542
13540: oJumpForward 13547
13542: Choice Lookup Table
          14   13540
13545: oJumpForward 13549
13547: oJumpBack 13311
13549: oInput 16
13551: oGetFromParam 1
13553: oPushResult
13554: oSetResult 42
13556: oPushResult
13557: oScopeCurrent
13558: oPushResult
13559: oNodeSet
13560: oPop 3
13562: oGetFromParam 1
13564: oPushResult
13565: oSetResult 17
13567: oPushResult
13568: oSetResult 4
13570: oPushResult
13571: oNodeSetInt
13572: oPop 3
13574: oScopeEnd
13575: oGetGlobal 2
13577: oPushResult
13578: oCall 14688
13580: oPop 1
13582: oPushResult
13583: oCodePush
13584: oPop 1
13586: oGetGlobal 2
13588: oPushResult
13589: oScopeEnter
13590: oPop 1
13592: oGetAddrLocal 8
13594: oPushResult
13595: oGetLocal 2
13597: oPushResult
13598: oSetResult 1
13600: oPushResult
13601: add
13602: oPop 2
13604: oPushResult
13605: oSetResult 16
13607: oPushResult
13608: multiply
13609: oPop 2
13611: oAssign
13612: oGetAddrLocal 9
13614: oPushResult
13615: oGetLocal 8
13617: oPushResult
13618: oSetResult 8
13620: oPushResult
13621: oScopeAlloc
13622: oPop 2
13624: oAssign
13625: oScopeEnd
13626: oGetFromParam 1
13628: oPushResult
13629: oSetResult 44
13631: oPushResult
13632: oGetLocal 9
13634: oPushResult
13635: oNodeSetInt
13636: oPop 3
13638: oGetAddrLocal 10
13640: oPushResult
13641: oGetFromParam 1
13643: oPushResult
13644: oSetResult 42
13646: oPushResult
13647: oNodeGet
13648: oPop 2
13650: oPushResult
13651: oSetResult 15
13653: oPushResult
13654: oNodeGetIter
13655: oPop 2
13657: oAssign
13658: oGetAddrLocal 11
13660: oPushResult
13661: oGetLocal 10
13663: oPushResult
13664: oNodeIterValue
13665: oPop 1
13667: oAssign
13668: oGetLocal 11
13670: oPushResult
13671: oNodeNull
13672: oPop 1
13674: oChoice 13680
13676: oJumpForward 13767
13678: oJumpForward 13683
13680: Choice Lookup Table
           1   13676
13683: oEmit 17
13685: oGetLocal 9
13687: oPushResult
13688: oEmitInt
13689: oPop 1
13691: oEmit 15
13693: oGetLocal 11
13695: oPushResult
13696: oSetResult 22
13698: oPushResult
13699: oNodeGetInt
13700: oPop 2
13702: oPushResult
13703: oEmitInt
13704: oPop 1
13706: oEmit 27
13708: oGetAddrLocal 9
13710: oPushResult
13711: oGetLocal 9
13713: oPushResult
13714: oSetResult 8
13716: oPushResult
13717: add
13718: oPop 2
13720: oAssign
13721: oEmit 17
13723: oGetLocal 9
13725: oPushResult
13726: oEmitInt
13727: oPop 1
13729: oEmit 17
13731: oGetLocal 11
13733: oPushResult
13734: oSetResult 32
13736: oPushResult
13737: oNodeGetInt
13738: oPop 2
13740: oPushResult
13741: oEmitInt
13742: oPop 1
13744: oEmit 29
13746: oGetAddrLocal 9
13748: oPushResult
13749: oGetLocal 9
13751: oPushResult
13752: oSetResult 8
13754: oPushResult
13755: add
13756: oPop 2
13758: oAssign
13759: oGetAddrLocal 10
13761: oPushResult
13762: oNodeIterNext
13763: oPop 1
13765: oJumpBack 13658
13767: oEmit 17
13769: oGetLocal 9
13771: oPushResult
13772: oEmitInt
13773: oPop 1
13775: oEmit 15
13777: oSetResult 0
13779: oPushResult
13780: oEmitInt
13781: oPop 1
13783: oEmit 27
13785: oGetAddrLocal 9
13787: oPushResult
13788: oGetLocal 9
13790: oPushResult
13791: oSetResult 8
13793: oPushResult
13794: add
13795: oPop 2
13797: oAssign
13798: oEmit 17
13800: oGetLocal 9
13802: oPushResult
13803: oEmitInt
13804: oPop 1
13806: oEmit 15
13808: oSetResult 0
13810: oPushResult
13811: oEmitInt
13812: oPop 1
13814: oEmit 29
13816: oGetAddrLocal 9
13818: oPushResult
13819: oGetLocal 9
13821: oPushResult
13822: oSetResult 8
13824: oPushResult
13825: add
13826: oPop 2
13828: oAssign
13829: oCodePop
13830: oGetFromParam 1
13832: oPushResult
13833: oTypeAdd
13834: oPop 1
13836: oReturn
13837: oLocalSpace 1
13839: oGetAddrLocal 1
13841: oPushResult
13842: oGetParam 1
13844: oPushResult
13845: oSetResult 37
13847: oPushResult
13848: oNodeGet
13849: oPop 2
13851: oAssign
13852: oGetLocal 1
13854: oPushResult
13855: oNodeNull
13856: oPop 1
13858: oChoice 13914
13860: oGetAddrLocal 1
13862: oPushResult
13863: oSetResult 37
13865: oPushResult
13866: oNodeNew
13867: oPop 1
13869: oAssign
13870: oGetLocal 1
13872: oPushResult
13873: oSetResult 38
13875: oPushResult
13876: oGetParam 1
13878: oPushResult
13879: oNodeSet
13880: oPop 3
13882: oGetLocal 1
13884: oPushResult
13885: oSetResult 17
13887: oPushResult
13888: oSetResult 8
13890: oPushResult
13891: oNodeSetInt
13892: oPop 3
13894: oGetLocal 1
13896: oPushResult
13897: oTypeAdd
13898: oPop 1
13900: oGetParam 1
13902: oPushResult
13903: oSetResult 37
13905: oPushResult
13906: oGetLocal 1
13908: oPushResult
13909: oNodeSet
13910: oPop 3
13912: oJumpForward 13917
13914: Choice Lookup Table
           1   13860
13917: oGetLocal 1
13919: oReturn
13920: oReturn
13921: oLocalSpace 2
13923: oGetParam 1
13925: oPushResult
13926: oNodeType
13927: oPop 1
13929: oChoice 13999
13931: oMININT
13932: oReturn
13933: oJumpForward 14015
13935: oSetResult 0
13937: oReturn
13938: oJumpForward 14015
13940: oSetResult 0
13942: oReturn
13943: oJumpForward 14015
13945: oGetAddrLocal 1
13947: oPushResult
13948: oGetParam 1
13950: oPushResult
13951: oSetResult 42
13953: oPushResult
13954: oNodeGet
13955: oPop 2
13957: oAssign
13958: oGetAddrLocal 2
13960: oPushResult
13961: oGetLocal 1
13963: oPushResult
13964: oSetResult 15
13966: oPushResult
13967: oNodeGetIter
13968: oPop 2
13970: oPushResult
13971: oNodeIterValue
13972: oPop 1
13974: oAssign
13975: oGetLocal 2
13977: oPushResult
13978: oSetResult 22
13980: oPushResult
13981: oNodeGetInt
13982: oPop 2
13984: oReturn
13985: oJumpForward 14015
13987: oGetParam 1
13989: oPushResult
13990: oSetResult 40
13992: oPushResult
13993: oNodeGetInt
13994: oPop 2
13996: oReturn
13997: oJumpForward 14015
13999: Choice Lookup Table
          40   13987
          44   13945
          36   13940
          34   13935
          31   13931
14010: oError 3
14012: oSetResult 0
14014: oReturn
14015: oReturn
14016: oLocalSpace 2
14018: oGetParam 1
14020: oPushResult
14021: oNodeType
14022: oPop 1
14024: oChoice 14094
14026: oMAXINT
14027: oReturn
14028: oJumpForward 14110
14030: oSetResult 1
14032: oReturn
14033: oJumpForward 14110
14035: oSetResult 255
14037: oReturn
14038: oJumpForward 14110
14040: oGetAddrLocal 1
14042: oPushResult
14043: oGetParam 1
14045: oPushResult
14046: oSetResult 42
14048: oPushResult
14049: oNodeGet
14050: oPop 2
14052: oAssign
14053: oGetAddrLocal 2
14055: oPushResult
14056: oGetLocal 1
14058: oPushResult
14059: oSetResult 15
14061: oPushResult
14062: oNodeGetIterLast
14063: oPop 2
14065: oPushResult
14066: oNodeIterValue
14067: oPop 1
14069: oAssign
14070: oGetLocal 2
14072: oPushResult
14073: oSetResult 22
14075: oPushResult
14076: oNodeGetInt
14077: oPop 2
14079: oReturn
14080: oJumpForward 14110
14082: oGetParam 1
14084: oPushResult
14085: oSetResult 41
14087: oPushResult
14088: oNodeGetInt
14089: oPop 2
14091: oReturn
14092: oJumpForward 14110
14094: Choice Lookup Table
          40   14082
          44   14040
          36   14035
          34   14030
          31   14026
14105: oError 3
14107: oSetResult 0
14109: oReturn
14110: oReturn
14111: oLocalSpace 5
14113: oGetAddrGlobal 1
14115: oPushResult
14116: oWorkspaceNew
14117: oAssign
14118: oSetResult 0
14120: oPushResult
14121: oSetResult 0
14123: oPushResult
14124: oScopeBegin
14125: oPop 2
14127: oGetAddrLocal 2
14129: oPushResult
14130: oScopeCurrent
14131: oAssign
14132: oCall 14860
14134: oEmit 81
14136: oSetResult 0
14138: oPushResult
14139: oEmitInt
14140: oPop 1
14142: oGetAddrLocal 3
14144: oPushResult
14145: oLabelNew
14146: oAssign
14147: oEmit 75
14149: oSetResult 0
14151: oPushResult
14152: oEmitInt
14153: oPop 1
14155: oEmit 78
14157: oGetLocal 3
14159: oPushResult
14160: oEmitLabel
14161: oPop 1
14163: oEmit 77
14165: oSetResult 0
14167: oPushResult
14168: oEmitInt
14169: oPop 1
14171: oEmit 80
14173: oInput 29
14175: oInput 0
14177: oGetAddrLocal 4
14179: oPushResult
14180: oSetResult 4
14182: oPushResult
14183: oNodeNew
14184: oPop 1
14186: oAssign
14187: oGetLocal 4
14189: oPushResult
14190: oSetResult 4
14192: oPushResult
14193: LAST_ID
14194: oPushResult
14195: oNodeSetInt
14196: oPop 3
14198: oGetGlobal 1
14200: oPushResult
14201: oSetResult 2
14203: oPushResult
14204: oGetLocal 4
14206: oPushResult
14207: oNodeSet
14208: oPop 3
14210: oInputChoice 14284
14212: oInput 0
14214: oGetAddrLocal 1
14216: oPushResult
14217: oSetResult 21
14219: oPushResult
14220: LAST_ID
14221: oPushResult
14222: oCall 14790
14224: oPop 2
14226: oAssign
14227: oGetLocal 1
14229: oPushResult
14230: oSetResult 21
14232: oPushResult
14233: oGetGlobal 5
14235: oPushResult
14236: oNodeSet
14237: oPop 3
14239: oGetLocal 1
14241: oPushResult
14242: oScopeDeclareAlloc
14243: oPop 1
14245: oInput 14
14247: oInput 0
14249: oGetAddrLocal 1
14251: oPushResult
14252: oSetResult 21
14254: oPushResult
14255: LAST_ID
14256: oPushResult
14257: oCall 14790
14259: oPop 2
14261: oAssign
14262: oGetLocal 1
14264: oPushResult
14265: oSetResult 21
14267: oPushResult
14268: oGetGlobal 5
14270: oPushResult
14271: oNodeSet
14272: oPop 3
14274: oGetLocal 1
14276: oPushResult
14277: oScopeDeclareAlloc
14278: oPop 1
14280: oInput 16
14282: oJumpForward 14287
14284: Choice Lookup Table
          15   14212
14287: oInput 6
14289: oGetLocal 4
14291: oPushResult
14292: oCall 34
14294: oPop 1
14296: oInputChoice 14307
14298: oGetLocal 4
14300: oPushResult
14301: oCall 7
14303: oPop 1
14305: oJumpForward 14310
14307: Choice Lookup Table
          60   14298
14310: oGetLocal 4
14312: oPushResult
14313: oCall 287
14315: oPop 1
14317: oSetResult 0
14319: oPushResult
14320: oSetResult 0
14322: oPushResult
14323: oScopeBegin
14324: oPop 2
14326: oGetAddrGlobal 2
14328: oPushResult
14329: oScopeCurrent
14330: oAssign
14331: oSetResult 0
14333: oPushResult
14334: oSetResult 1
14336: oPushResult
14337: oScopeBegin
14338: oPop 2
14340: oScopeCurrent
14341: oPushResult
14342: oSetResult 16
14344: oPushResult
14345: oGetGlobal 2
14347: oPushResult
14348: oNodeSet
14349: oPop 3
14351: oGetAddrGlobal 3
14353: oPushResult
14354: oScopeCurrent
14355: oAssign
14356: oGetLocal 4
14358: oPushResult
14359: oSetResult 7
14361: oPushResult
14362: oGetGlobal 3
14364: oPushResult
14365: oNodeSet
14366: oPop 3
14368: oScopeEnd
14369: oSetResult 22
14371: oPushResult
14372: oCall 14439
14374: oPop 1
14376: oGetGlobal 3
14378: oPushResult
14379: oScopeEnter
14380: oPop 1
14382: oGetAddrLocal 5
14384: oPushResult
14385: oSetResult 1
14387: oAssign
14388: oGetLocal 3
14390: oPushResult
14391: oGetGlobal 2
14393: oPushResult
14394: oGetLocal 5
14396: oPushResult
14397: oCall 14590
14399: oPop 3
14401: oScopeEnd
14402: oInput 21
14404: oCall 14495
14406: oScopeEnd
14407: oGetLocal 4
14409: oPushResult
14410: oCall 349
14412: oPop 1
14414: oReturn
14415: oLocalSpace 0
14417: oGetParam 2
14419: oPushResult
14420: oCall 14439
14422: oPop 1
14424: oGetParam 1
14426: oPushResult
14427: oScopeCurrent
14428: oPushResult
14429: oSetResult 0
14431: oPushResult
14432: oCall 14590
14434: oPop 3
14436: oCall 14495
14438: oReturn
14439: oLocalSpace 0
14441: oInputChoice 14472
14443: oCall 2538
14445: oJumpForward 14487
14447: oCall 3231
14449: oJumpForward 14487
14451: oGetParam 1
14453: oPushResult
14454: oCall 3287
14456: oPop 1
14458: oJumpForward 14487
14460: oCall 3521
14462: oJumpForward 14487
14464: oCall 1761
14466: oJumpForward 14487
14468: oCall 2196
14470: oJumpForward 14487
14472: Choice Lookup Table
          31   14468
          30   14464
          35   14460
          34   14451
          33   14447
          32   14443
14485: oJumpForward 14489
14487: oJumpBack 14441
14489: oCall 14492
14491: oReturn
14492: oLocalSpace 0
14494: oReturn
14495: oLocalSpace 2
14497: oGetAddrLocal 1
14499: oPushResult
14500: oScopeCurrent
14501: oPushResult
14502: oSetResult 15
14504: oPushResult
14505: oNodeGetIter
14506: oPop 2
14508: oAssign
14509: oGetAddrLocal 2
14511: oPushResult
14512: oGetLocal 1
14514: oPushResult
14515: oNodeIterValue
14516: oPop 1
14518: oAssign
14519: oGetLocal 2
14521: oPushResult
14522: oNodeNull
14523: oPop 1
14525: oChoice 14529
14527: oJumpForward 14534
14529: Choice Lookup Table
           0   14527
14532: oJumpForward 14589
14534: oGetLocal 2
14536: oPushResult
14537: oNodeType
14538: oPop 1
14540: oChoice 14578
14542: oGetLocal 2
14544: oPushResult
14545: oSetResult 36
14547: oPushResult
14548: oNodeGetBoolean
14549: oPop 2
14551: oChoice 14573
14553: oGetLocal 2
14555: oPushResult
14556: oSetResult 28
14558: oPushResult
14559: oNodeGetBoolean
14560: oPop 2
14562: oChoice 14568
14564: oError 29
14566: oJumpForward 14571
14568: Choice Lookup Table
           1   14564
14571: oJumpForward 14576
14573: Choice Lookup Table
           0   14553
14576: oJumpForward 14581
14578: Choice Lookup Table
          27   14542
14581: oGetAddrLocal 1
14583: oPushResult
14584: oNodeIterNext
14585: oPop 1
14587: oJumpBack 14509
14589: oReturn
14590: oLocalSpace 3
14592: oEmit 91
14594: oGetParam 3
14596: oPushResult
14597: oEmitLabel
14598: oPop 1
14600: oEmit 81
14602: oGetAddrLocal 1
14604: oPushResult
14605: Here
14606: oAssign
14607: oEmit 109
14609: oGetParam 1
14611: oChoice 14617
14613: oCall 1220
14615: oJumpForward 14620
14617: Choice Lookup Table
           1   14613
14620: oGetAddrLocal 2
14622: oPushResult
14623: oGetParam 2
14625: oPushResult
14626: oSetResult 19
14628: oPushResult
14629: oNodeGetCode
14630: oPop 2
14632: oAssign
14633: oGetLocal 2
14635: oPushResult
14636: oEmitCode
14637: oPop 1
14639: oGetParam 2
14641: oPushResult
14642: oSetResult 19
14644: oPushResult
14645: oSetResult 0
14647: oPushResult
14648: oNodeSetCode
14649: oPop 3
14651: oCall 9503
14653: oGetParam 1
14655: oChoice 14661
14657: oCall 1305
14659: oJumpForward 14664
14661: Choice Lookup Table
           1   14657
14664: oEmit 80
14666: oGetAddrLocal 3
14668: oPushResult
14669: oScopeCurrent
14670: oPushResult
14671: oSetResult 17
14673: oPushResult
14674: oNodeGetInt
14675: oPop 2
14677: oAssign
14678: oGetLocal 1
14680: oPushResult
14681: oGetLocal 3
14683: oPushResult
14684: oPatch
14685: oPop 2
14687: oReturn
14688: oLocalSpace 1
14690: oGetAddrLocal 1
14692: oPushResult
14693: oGetParam 1
14695: oPushResult
14696: oSetResult 19
14698: oPushResult
14699: oNodeGetCode
14700: oPop 2
14702: oAssign
14703: oGetLocal 1
14705: oPushResult
14706: oSetResult 0
14708: oPushResult
14709: equal_code
14710: oPop 2
14712: oChoice 14733
14714: oGetAddrLocal 1
14716: oPushResult
14717: oCodeNew
14718: oAssign
14719: oGetParam 1
14721: oPushResult
14722: oSetResult 19
14724: oPushResult
14725: oGetLocal 1
14727: oPushResult
14728: oNodeSetCode
14729: oPop 3
14731: oJumpForward 14736
14733: Choice Lookup Table
           1   14714
14736: oGetLocal 1
14738: oReturn
14739: oReturn
14740: oLocalSpace 0
14742: oScopeCurrent
14743: oPushResult
14744: oSetResult 14
14746: oPushResult
14747: oNodeGetInt
14748: oPop 2
14750: oReturn
14751: oReturn
14752: oLocalSpace 0
14754: oGetParam 1
14756: oPushResult
14757: oSetResult 20
14759: oPushResult
14760: oNodeGet
14761: oPop 2
14763: oPushResult
14764: oSetResult 14
14766: oPushResult
14767: oNodeGetInt
14768: oPop 2
14770: oReturn
14771: oReturn
14772: oLocalSpace 0
14774: oCall 14740
14776: oPushResult
14777: oGetParam 1
14779: oPushResult
14780: oCall 14752
14782: oPop 1
14784: oPushResult
14785: subtract
14786: oPop 2
14788: oReturn
14789: oReturn
14790: oLocalSpace 1
14792: oGetAddrLocal 1
14794: oPushResult
14795: oGetParam 2
14797: oPushResult
14798: oNodeNew
14799: oPop 1
14801: oAssign
14802: oGetLocal 1
14804: oPushResult
14805: oSetResult 4
14807: oPushResult
14808: oGetParam 1
14810: oPushResult
14811: oNodeSetInt
14812: oPop 3
14814: oGetLocal 1
14816: oReturn
14817: oReturn
14818: oLocalSpace 0
14820: oGetParam 1
14822: oPushResult
14823: oSetResult 22
14825: oPushResult
14826: oNodeGetInt
14827: oPop 2
14829: oPushResult
14830: oEmitInt
14831: oPop 1
14833: oReturn
14834: oLocalSpace 1
14836: oGetAddrLocal 1
14838: oPushResult
14839: oSetResult 14
14841: oPushResult
14842: oGetParam 1
14844: oPushResult
14845: oCall 14790
14847: oPop 2
14849: oAssign
14850: oGetLocal 1
14852: oPushResult
14853: oScopeDeclare
14854: oPop 1
14856: oGetLocal 1
14858: oReturn
14859: oReturn
14860: oLocalSpace 1
14862: oGetAddrGlobal 25
14864: oPushResult
14865: oSetResult 0
14867: oAssign
14868: oGetAddrGlobal 4
14870: oPushResult
14871: oId_mysystem
14872: oAssign
14873: oGetAddrGlobal 5
14875: oPushResult
14876: oSetResult 29
14878: oPushResult
14879: oSetResult 4
14881: oPushResult
14882: oCall 12724
14884: oPop 2
14886: oAssign
14887: oGetAddrGlobal 6
14889: oPushResult
14890: oSetResult 31
14892: oPushResult
14893: oSetResult 4
14895: oPushResult
14896: oCall 12724
14898: oPop 2
14900: oAssign
14901: oGetAddrGlobal 7
14903: oPushResult
14904: oSetResult 34
14906: oPushResult
14907: oSetResult 1
14909: oPushResult
14910: oCall 12724
14912: oPop 2
14914: oAssign
14915: oGetAddrGlobal 8
14917: oPushResult
14918: oSetResult 35
14920: oPushResult
14921: oSetResult 1
14923: oPushResult
14924: oCall 12724
14926: oPop 2
14928: oAssign
14929: oGetAddrGlobal 9
14931: oPushResult
14932: oSetResult 36
14934: oPushResult
14935: oSetResult 1
14937: oPushResult
14938: oCall 12724
14940: oPop 2
14942: oAssign
14943: oGetAddrGlobal 10
14945: oPushResult
14946: oGetGlobal 9
14948: oPushResult
14949: oCall 13837
14951: oPop 1
14953: oAssign
14954: oGetAddrGlobal 11
14956: oPushResult
14957: oSetResult 30
14959: oPushResult
14960: oSetResult 1
14962: oPushResult
14963: oCall 12724
14965: oPop 2
14967: oAssign
14968: oGetAddrGlobal 12
14970: oPushResult
14971: oSetResult 32
14973: oPushResult
14974: oSetResult 4
14976: oPushResult
14977: oCall 12724
14979: oPop 2
14981: oAssign
14982: oGetAddrGlobal 13
14984: oPushResult
14985: oSetResult 33
14987: oPushResult
14988: oSetResult 8
14990: oPushResult
14991: oCall 12724
14993: oPop 2
14995: oAssign
14996: oGetAddrGlobal 14
14998: oPushResult
14999: oSetResult 38
15001: oPushResult
15002: oSetResult 8
15004: oPushResult
15005: oCall 12724
15007: oPop 2
15009: oAssign
15010: oGetGlobal 14
15012: oPushResult
15013: oSetResult 38
15015: oPushResult
15016: oGetGlobal 11
15018: oPushResult
15019: oNodeSet
15020: oPop 3
15022: oGetAddrGlobal 15
15024: oPushResult
15025: oSetResult 42
15027: oPushResult
15028: oSetResult 256
15030: oPushResult
15031: oCall 12724
15033: oPop 2
15035: oAssign
15036: oGetAddrGlobal 16
15038: oPushResult
15039: oSetResult 43
15041: oPushResult
15042: oSetResult 256
15044: oPushResult
15045: oCall 12724
15047: oPop 2
15049: oAssign
15050: oGetGlobal 16
15052: oPushResult
15053: oSetResult 43
15055: oPushResult
15056: oSetResult 255
15058: oPushResult
15059: oNodeSetInt
15060: oPop 3
15062: oGetAddrLocal 1
15064: oPushResult
15065: oSetResult 20
15067: oPushResult
15068: oId_File
15069: oPushResult
15070: oCall 14790
15072: oPop 2
15074: oAssign
15075: oGetLocal 1
15077: oPushResult
15078: oSetResult 21
15080: oPushResult
15081: oGetGlobal 5
15083: oPushResult
15084: oNodeSet
15085: oPop 3
15087: oGetLocal 1
15089: oPushResult
15090: oScopeDeclare
15091: oPop 1
15093: oGetAddrLocal 1
15095: oPushResult
15096: oSetResult 20
15098: oPushResult
15099: oId_Integer
15100: oPushResult
15101: oCall 14790
15103: oPop 2
15105: oAssign
15106: oGetLocal 1
15108: oPushResult
15109: oSetResult 21
15111: oPushResult
15112: oGetGlobal 6
15114: oPushResult
15115: oNodeSet
15116: oPop 3
15118: oGetLocal 1
15120: oPushResult
15121: oScopeDeclare
15122: oPop 1
15124: oGetAddrLocal 1
15126: oPushResult
15127: oSetResult 20
15129: oPushResult
15130: oId_Boolean
15131: oPushResult
15132: oCall 14790
15134: oPop 2
15136: oAssign
15137: oGetLocal 1
15139: oPushResult
15140: oSetResult 21
15142: oPushResult
15143: oGetGlobal 7
15145: oPushResult
15146: oNodeSet
15147: oPop 3
15149: oGetLocal 1
15151: oPushResult
15152: oScopeDeclare
15153: oPop 1
15155: oGetAddrLocal 1
15157: oPushResult
15158: oSetResult 20
15160: oPushResult
15161: oId_Char
15162: oPushResult
15163: oCall 14790
15165: oPop 2
15167: oAssign
15168: oGetLocal 1
15170: oPushResult
15171: oSetResult 21
15173: oPushResult
15174: oGetGlobal 9
15176: oPushResult
15177: oNodeSet
15178: oPop 3
15180: oGetLocal 1
15182: oPushResult
15183: oScopeDeclare
15184: oPop 1
15186: oGetAddrLocal 1
15188: oPushResult
15189: oSetResult 20
15191: oPushResult
15192: oId_Byte
15193: oPushResult
15194: oCall 14790
15196: oPop 2
15198: oAssign
15199: oGetLocal 1
15201: oPushResult
15202: oSetResult 21
15204: oPushResult
15205: oGetGlobal 11
15207: oPushResult
15208: oNodeSet
15209: oPop 3
15211: oGetLocal 1
15213: oPushResult
15214: oScopeDeclare
15215: oPop 1
15217: oGetAddrLocal 1
15219: oPushResult
15220: oSetResult 20
15222: oPushResult
15223: oId_Single
15224: oPushResult
15225: oCall 14790
15227: oPop 2
15229: oAssign
15230: oGetLocal 1
15232: oPushResult
15233: oSetResult 21
15235: oPushResult
15236: oGetGlobal 12
15238: oPushResult
15239: oNodeSet
15240: oPop 3
15242: oGetLocal 1
15244: oPushResult
15245: oScopeDeclare
15246: oPop 1
15248: oGetAddrLocal 1
15250: oPushResult
15251: oSetResult 20
15253: oPushResult
15254: oId_Double
15255: oPushResult
15256: oCall 14790
15258: oPop 2
15260: oAssign
15261: oGetLocal 1
15263: oPushResult
15264: oSetResult 21
15266: oPushResult
15267: oGetGlobal 13
15269: oPushResult
15270: oNodeSet
15271: oPop 3
15273: oGetLocal 1
15275: oPushResult
15276: oScopeDeclare
15277: oPop 1
15279: oGetAddrLocal 1
15281: oPushResult
15282: oSetResult 20
15284: oPushResult
15285: oId_Pointer
15286: oPushResult
15287: oCall 14790
15289: oPop 2
15291: oAssign
15292: oGetLocal 1
15294: oPushResult
15295: oSetResult 21
15297: oPushResult
15298: oGetGlobal 14
15300: oPushResult
15301: oNodeSet
15302: oPop 3
15304: oGetLocal 1
15306: oPushResult
15307: oScopeDeclare
15308: oPop 1
15310: oGetAddrLocal 1
15312: oPushResult
15313: oSetResult 20
15315: oPushResult
15316: oId_ShortString
15317: oPushResult
15318: oCall 14790
15320: oPop 2
15322: oAssign
15323: oGetLocal 1
15325: oPushResult
15326: oSetResult 21
15328: oPushResult
15329: oGetGlobal 16
15331: oPushResult
15332: oNodeSet
15333: oPop 3
15335: oGetLocal 1
15337: oPushResult
15338: oScopeDeclare
15339: oPop 1
15341: oGetAddrLocal 1
15343: oPushResult
15344: oSetResult 16
15346: oPushResult
15347: oId_True
15348: oPushResult
15349: oCall 14790
15351: oPop 2
15353: oAssign
15354: oGetLocal 1
15356: oPushResult
15357: oSetResult 21
15359: oPushResult
15360: oGetGlobal 7
15362: oPushResult
15363: oNodeSet
15364: oPop 3
15366: oGetLocal 1
15368: oPushResult
15369: oSetResult 22
15371: oPushResult
15372: oSetResult 1
15374: oPushResult
15375: oNodeSetInt
15376: oPop 3
15378: oGetLocal 1
15380: oPushResult
15381: oScopeDeclare
15382: oPop 1
15384: oGetAddrLocal 1
15386: oPushResult
15387: oSetResult 16
15389: oPushResult
15390: oId_False
15391: oPushResult
15392: oCall 14790
15394: oPop 2
15396: oAssign
15397: oGetLocal 1
15399: oPushResult
15400: oSetResult 21
15402: oPushResult
15403: oGetGlobal 7
15405: oPushResult
15406: oNodeSet
15407: oPop 3
15409: oGetLocal 1
15411: oPushResult
15412: oSetResult 22
15414: oPushResult
15415: oSetResult 0
15417: oPushResult
15418: oNodeSetInt
15419: oPop 3
15421: oGetLocal 1
15423: oPushResult
15424: oScopeDeclare
15425: oPop 1
15427: oGetAddrLocal 1
15429: oPushResult
15430: oSetResult 16
15432: oPushResult
15433: oId_Nil
15434: oPushResult
15435: oCall 14790
15437: oPop 2
15439: oAssign
15440: oGetLocal 1
15442: oPushResult
15443: oSetResult 21
15445: oPushResult
15446: oGetGlobal 14
15448: oPushResult
15449: oNodeSet
15450: oPop 3
15452: oGetLocal 1
15454: oPushResult
15455: oSetResult 22
15457: oPushResult
15458: oSetResult 0
15460: oPushResult
15461: oNodeSetInt
15462: oPop 3
15464: oGetLocal 1
15466: oPushResult
15467: oScopeDeclare
15468: oPop 1
15470: oGetAddrGlobal 17
15472: oPushResult
15473: oId_Ord
15474: oPushResult
15475: oCall 14834
15477: oPop 1
15479: oAssign
15480: oGetAddrGlobal 18
15482: oPushResult
15483: oId_Chr
15484: oPushResult
15485: oCall 14834
15487: oPop 1
15489: oAssign
15490: oGetAddrGlobal 19
15492: oPushResult
15493: oId_Pred
15494: oPushResult
15495: oCall 14834
15497: oPop 1
15499: oAssign
15500: oGetAddrGlobal 20
15502: oPushResult
15503: oId_Succ
15504: oPushResult
15505: oCall 14834
15507: oPop 1
15509: oAssign
15510: oGetAddrGlobal 21
15512: oPushResult
15513: oId_Sizeof
15514: oPushResult
15515: oCall 14834
15517: oPop 1
15519: oAssign
15520: oReturn
