   2: title: 'Pascal Compiler 1.1.5 -- Jan 01 ''90';
         
      %
      %  Pascal.ssl
      %
      %  Pascal Compiler for the Amiga, by Steve Rice.
      %
      %  HISTORY
      %    11Sep89   First version, framework of parser.
      %    18Sep89   Added some semantic mechanisms.
      %    21Sep89   Added simple type references; expressions generate code.
      %    22Sep89   Allocate variable addresses as they're declared.
      %    24Sep89   Added arrays, pointers.
      %    27Sep89   Added for statement.
      %    23Oct89   Fixed for statement, so CYCLE goes to next step.
      %    01Jan90   Added string literals
      %    09Sep22   I have returned.  Migrate symbol table to schema, to ease development.
      %    01Oct22   Language: Switch from cycle/exit (Mac Pascal extension) to continue/break (Borland).
      %
      %  NOTES
      %    -  The 'value' of a var symbol is its allocated address.
      %    -  References to vars of intrinsic types, and pointer types,
      %       pushes the value of the var on the expr stack.  Referenecs to
      %       vars of compound types (arrays, records...) pushes the address
      %       on the expr stack.
      %    -  Just as there is only one type table entry for a given (named) type,
      %       there is only one type table entry for a pointer to a named type.
      %       When a pointer type is declared, a field in the TT entry of the
      %       type pointed to will be set to indicate the TT entry of the pointer
      %       to that type (0 means none defined yet).  When evaluating the
      %       expression ^x, the type in that field in the entry for the type of x
      %       will be used (unless it's 0, in which case a new TT entry will be
      %       created).
      %
      %
      %  MISSING
      %
      %    - Functions. 
      %      Caller allocates a temporary variable for the result.
      %      The params contain an extra hidden VAR parameter, i.e. passing in the temporary by reference.
      %      After the call, the caller pushes a reference to the temporary on the expression stack.
      %      (This would push a scalar value, or the addr of the temporary if a compound type.)
      %
      %    - VAR parameters need work, on caller side and reference side (lhs and rhs).
      %
      %    - Forward declaration of proceudres and functions.
      %      Only one forward declaration should be allowed.
      %      I will overwrite the nMethod info with the final addr and param names when the true body is seen.
      %      If a call is made to a foward declared method, add the forward decl node & Here to patch table.
      % 
      %    - procedure and function declarations may be nested within other procs/funcs!
      %      They are allowed to see locals within those parent scopes.
      %      Pass a hidden parameter to nested methods, to follow up to parent scopes as needed.
      %      Need a level counter at each scope, and uplevels count on reference to local/param.
      %      
      %    - Consider non-ISO extensions.  e.g. see "Units" e.g. from Turbo Pascal wikipedia page.
      %      Dynamic arrays.  Objects.  But, perhaps stick to my old goal, standard Pascal.
      %
      %    - x86 code generation.
      %
      %
      %  PASCAL DOCS
      %      Here's some handy language material:
      %      https://www.freepascal.org/docs-html/ref/ref.html
      %      https://www.freepascal.org/docs-html/prog/prog.html
      %      https://en.wikipedia.org/wiki/Turbo_Pascal
      %      https://en.wikipedia.org/wiki/Pascal_(programming_language)#Standards
      %      http://www.standardpascaline.org/
      %
      
   2: input:
   2:    pIdent
   2:    pIntLit
   2:    pStrLit
   2:    pAssign       ':='
   2:    pSemiColon    ';'
   2:    pEqual        '='
   2:    pNotEqual     '<>'
   2:    pLess         '<'
   2:    pGreater      '>'
   2:    pLessEqual    '<='
   2:    pGreaterEqual '>='
   2:    pColon        ':'
   2:    pComma        ','
   2:    pLParen       '('
   2:    pRParen       ')'
   2:    pLSquare      '['
   2:    pRSquare      ']'
   2:    pCarat        '^'
   2:    pAt           '@'
   2:    pDot          '.'
   2:    pDotDot       '..'
   2:    pTimes        '*'
   2:    pDivide       '/'
   2:    pPlus         '+'
   2:    pMinus        '-'
   2:    pEof
   2:    pInvalid
      
      %  keywords  (built-in types 'integer', 'char', etc, are not keywords,
      %             type constructors 'array', 'record', 'set' are keywords,
      %             pseudo-procedures 'writeln', 'readln' are keywords)
      
   2:    pProgram
   2:    pProcedure
   2:    pFunction
   2:    pConst
   2:    pType
   2:    pVar
   2:    pBegin
   2:    pEnd
   2:    pArray
   2:    pRecord
   2:    pSet
   2:    pOf
   2:    pIf
   2:    pThen
   2:    pElse
   2:    pFor
   2:    pTo
   2:    pDownto
   2:    pDo
   2:    pWhile
   2:    pRepeat
   2:    pUntil
   2:    pContinue
   2:    pBreak
   2:    pReturn
   2:    pAnd
   2:    pOr
   2:    pNot
   2:    pWriteln
   2:    pWrite
   2:    pReadln
   2:    pRead;
      
      
   2: output:
      
      %  Instructions for a stack machine (all vars are 32-bit integers)
      
   2:    tPushGlobalI      % <ptr> - push int value read from ptr
   2:    tPushGlobalB      % <ptr> - push byte value read from ptr
   2:    tPushGlobalP      % <ptr> - push ptr value read from ptr
   2:    tPushLocalI       % <offset> - push int value read from local var
   2:    tPushLocalB       % <offset> - push byte value read from local var
   2:    tPushLocalP       % <offset> - push ptr value read from local var
   2:    tPushParamI       % <offset> - push int value read from local var
   2:    tPushParamB       % <offset> - push byte value read from local var
   2:    tPushParamP       % <offset> - push ptr value read from local var
      
   2:    tPushConstI       % <int> - push int value on stack (NOTE, used for BOOLEAN too)
   2:    tPushAddrGlobal   % <offset> - push ptr to global var (same as tPushConstP)
   2:    tPushAddrLocal    % <offset> - push ptr to local var
   2:    tPushAddrParam    % <offset> - push ptr to formal param (used by method to see its param)
   2:    tPushAddrActual   % <offset> - push ptr to actual param, in actuals space (used by caller)
   2:    tFetchI           % pop ptr from stack, and push int value it points to
   2:    tFetchB           %    "      "      "     "     byte  "   "    "
   2:    tFetchP           %    "      "      "     "     ptr   "   "    "   
   2:    tAssignI          % assign int value on top of stack to addr under it (pop both)
   2:    tAssignB          %   "    byte   "    "   "  "   "    "    "   "   "
   2:    tAssignP          %   "    ptr    "    "   "  "   "    "    "   "   "
   2:    tCopy             % <#bytes> - copy bytes.  tos=src, 2nd=dest (pop 2)
   2:    tIncI             % increment int value on top of expr stack
   2:    tDecI             % decrement int value on top of expr stack
   2:    tMultI            % multiply top two integers (replacing with result)
   2:    tDivI
   2:    tAddPI            % add ptr (2nd value) and int (top value), resulting in a ptr
   2:    tAddI
   2:    tSubI
   2:    tNegI             % top entry *= -1
   2:    tNot              % negate top boolean
   2:    tEqualI           % top two entries equal? (pop 2, push 1) (true=1)
   2:    tNotEqualI        %    NOTE, these all work for booleans too
   2:    tGreaterI         % 2nd entry greater than top entry? (pop 2, push answer)
   2:    tLessI  
   2:    tGreaterEqualI
   2:    tLessEqualI
   2:    tEqualP           % two two pointer values equal? (pop 2, push 1) (true=1)
   2:    tNotEqualP
   2:    tAllocActuals     % <#bytes> - make space on call stack for actual params (adjusting call stack sp)
   2:    tFreeActuals      % <#bytes> - discard space on call stack allocated by tAllocActuals
   2:    tCall             % <label#>
   2:    tReturn
   2:    tEnter            % <#bytes> - start a stack frame on the call stack, reserving #bytes of local variable space
   2:    tJump             % <label#>
   2:    tJumpTrue         % <label#>  (pops top of stack, jumps if true)
   2:    tJumpFalse        % <label#>  (pops top of stack, jumps if false)
   2:    tLabel            % <label#> - define label# at the current address
   2:    tLabelAlias       % <label#> <aliasToLabel#> - defines label to be an alias of another label
   2:    tWriteI           % for writeln : write integer on tos, pop
   2:    tWriteBool        %  "     "    : write TRUE/FALSE, pop
   2:    tWriteStr         %  "     "    : write string whose addr is on tos, pop
   2:    tWriteP           %  "     "    : write ptr var whose addr is on tos, pop
   2:    tWriteCR          %  "     "    : write cr
      
      %  Other:
      
   2:    tSpace            % emit a hole, to be patched later
   2:    ;
      
   2: error:
   2:    eBadStatement
   2:    eNotConst
   2:    eNotType
   2:    eNotOrdinalType
   2:    eNotVar
   2:    eNotIntVar
   2:    eNotValue
   2:    eNotInteger
   2:    eNotBoolean
   2:    eNotPointer
   2:    eNotArray
   2:    eNotRecord
   2:    eNotRecordField
   2:    eTooManySubscripts
   2:    eTypeMismatch
   2:    eMissingParameter
   2:    eNotImplemented
   2:    eNotAllowed
   2:    eNotInALoop
   2:    eRecordEmpty
   2:    eNotCurrentFunction
   2:    ;
      
   2: include 'pascal_schema.ssl'
      
      % Generated automatically by schema
      
   2: type node_type:
   2: 	nINVALID
   2: 	Object
   2: 	nScope
   2: 	nDeclaration
   2: 	nIdent
   2: 	nProgram
   2: 	nMethod
   2: 	nProc
   2: 	nFunc
   2: 	nConst
   2: 	nTypeDecl
   2: 	nVar
   2: 	nGlobalVar
   2: 	nLocalVar
   2: 	nRecordField
   2: 	nParam
   2: 	nType
   2: 	nFileType
   2: 	nIntegerType
   2: 	nBooleanType
   2: 	nBooleanCFType
   2: 	nCharType
   2: 	nStringType
   2: 	nPointerType
   2: 	nArrayType
   2: 	nSubrangeType
   2: 	nRecordType
   2: 	nEnumType
   2: 	nSetType
   2: 	;
      
   2: type node_attribute:
   2: 	qINVALID
   2: 	qDecls
   2: 	qSize
   2: 	qAllocDown
   2: 	qIdent
   2: 	qType
   2: 	qValue
   2: 	qMainRoutineScope
   2: 	qParams
   2: 	qChildScope
   2: 	qAddrDefined
   2: 	qResultOffset
   2: 	qInOut
   2: 	qPointerType
   2: 	qBaseType
   2: 	qIndexType
   2: 	qLow
   2: 	qHigh
   2: 	qScope
   2: 	;
      
      
   2: type Node:     % A pointer to a node in the schema database (symbol database)
   2:     Null = 0
   2:     ;
      
   2: type NodeVec:  % A pointer to a vector of Node.  See mechanism node_vec_mech
   2:     NullVec = 0
   2:     ;
      
   2: type boolean:
   2:    false    = 0
   2:    true     = 1;
      
   2: type kind:           % kind of identifier
   2:    kUndefined        % not yet added to symbol table
   2:    kProgram
   2:    kProc
   2:    kFunc
   2:    kConst
   2:    kType
   2:    kVar;
      
      % intrinsic types & type constructs
      
   2: type typ:
   2:    tyNone     = 0    % in ptrTyp field of TT, means no ptr to type defined
   2:    tyInteger
   2:    tyBoolean
   2:    tyChar
   2:    tyString
   2:    tyFile            % tyInteger..tyFile are scalars (types on their own)
   2:    tyPointer         % following are type constructor classes...
   2:    tyArray           %   (they are not type#'s)
   2:    tyRecord
   2:    tyParams          % like record; a collection of proc/func params
   2:    tySet;
      
   2: type Label:
   2:    labelNull;
      
      
      % Some general schema node operations.
      % node_type and node_attribute are defined in generated file pascal_schema.ssl included above.
      %
   2: mechanism node_mech:
   2:     oNodeNew (node_type) >> Node         % create new node
   2:     oNodeSet (Node, node_attribute, Node)   % set Node attribute of node
   2:     oNodeSetInt (Node, node_attribute, int) % set int attribute of node
   2:     oNodeSetBoolean (Node, node_attribute, boolean)
   2:     oNodeSetKind (Node, node_attribute, kind) % set attribute of node  *** MIGHT NOT NEED
   2:     oNodeSetLabel( Node, node_attribute, Label )
   2:     oNodeGet (Node, node_attribute) >> Node    % get Node attribute of node
   2:     oNodeGetInt (Node, node_attribute) >> int  % get int attribute of node
   2:     oNodeGetBoolean (Node, node_attribute) >> boolean  % get int attribute of node
   2:     oNodeNull (Node) >> boolean          % is node null?
   2:     oNodeNext (inout Node)               % advance Node to next in list
   2:     oNodeType (Node) >> node_type        % return node type of node
   2:     oNodeEqual (Node, Node) >> boolean   % compare two nodes for equality
                                               % (i.e. same node, not just same contents)
   2:     ;
      
      
      % Manipulate a temporary vector of Node
      %
   2: mechanism node_vec_mech:
   2:     oNodeVecNew >> NodeVec
   2:     oNodeVecDelete( NodeVec nv )
   2:     oNodeVecAppend( NodeVec nv, Node n )
   2:     oNodeVecSize( NodeVec nv ) >> int                % how many elements
   2:     oNodeVecElement( NodeVec nv, int idx ) >> Node   % element at index idx (0..size-1)
   2:     ;
      
      
      
   2: mechanism emit_mech:
   2:     oEmitInt( int )              % emit int into the generated code
   2:     oEmitLabel( Label )
   2:     Here >> int                  % current address in the generated code
   2:     oPatch( int addr, int val )  % patch an int into address in the generated code
   2:     ;
      
   2: mechanism math:
   2:     inc (inout int)
   2:     dec (inout int)
   2:     negate (int) >> int
   2:     subtract( int x, int y ) >> int     % x - y
   2:     multiply( int x, int y ) >> int     % x * y
   2:     equal( int x, int y ) >> boolean
   2:     equal_zero (int) >> boolean
   2:     equal_node_type (node_type, node_type) >> boolean     % Want equal_<type> for every type
   2:     equal_label( Label, Label ) >> boolean
   2:     oMININT >> int    % the minimum 32-bit integer.  necessary because ssl literal ints are currently (silently) short (!)
   2:     ;
      
   2: mechanism more_builtins:      % These should be built-in SSL operations
   2:     TOKEN_VALUE >> int        % value of just accepted token, e.g. IntLit token
   2:     LAST_ID >> int            % id number of last accepted identifier
   2:     ;
      
   2: mechanism scope_mech:
   2:     oScopeBegin                          % create a new scope. Subsequent declarations will go here.
   2:     oScopeEnter( Node scope )            % enter an existing scope.
   2:     oScopeEnd                            % end current scope. Subsequent declarations will go to previous scope.
   2:     oScopeCurrent >> Node                % returns current scope
   2:     oScopeDeclare( Node decl )           % add declaration to current scope.
   2:     oScopeDeclareAlloc( Node decl )      % add declaration to current scope, and allocate space according to its type
   2:     oScopeAllocType( Node theType ) >> int   % allocate space for type in current scope, and return its address
   2:     oScopeFind >> Node                   % find declaration of last accepted identifier.  Returns Null if not found.
   2:     oScopeFindRequire >> Node            % find declaration of last accepted identifier.  Error if not found.
   2:     ;
      
      
   2: mechanism type_mech:
   2:     oTypeAdd( Node node )     % add the given nType to the type table
   2:     ;
      
   2: mechanism type_stack_mech:
   2:     oTypeSPush( Node node )
   2:     oTypeSPop
   2:     oTypeSTop >> Node
   2:     oTypeSNodeType >> node_type          % node_type of the node on top of type stack, skipping subranges
   2:     ;
      
      
   2: mechanism id_mech:
          % adds a predefined id to the scanner's id table, and returns the id code
   2:     oIdAdd_File >> int
   2:     oIdAdd_Integer >> int
   2:     oIdAdd_Boolean >> int
   2:     oIdAdd_Char >> int
   2:     oIdAdd_String >> int
   2:     oIdAdd_True >> int
   2:     oIdAdd_False >> int
   2:     ;
      
      
      
   2: mechanism label_mech:
   2:    oLabelNew >> Label
   2:    ;
      
   2: mechanism count :
   2:    oCountPush(int)          % start a new counter, with initial value
   2:    oCountInc
   2:    oCountDec
   2:    oCountIsZero >> boolean
   2:    oCountPop;
      
      
   2: mechanism value :              % value stack, to calc. const expr's
   2:    oValuePush(int)             % push an explicit int lit
   2:    oValueNegate                % negate top value
   2:    oValueTop >> int            % get top value on value stack
   2:    oValuePop;
      
   2: mechanism string :
   2:    oStringAllocLit;            % alloc data space for strlit, push address
                                     %   on value stack
      
      % track labels for the loop we're in, if any
   2: mechanism loop_mech:
   2:    oLoopPush( Label continueLabel, Label breakLabel )
   2:    oLoopContinueLabel >> Label
   2:    oLoopBreakLabel >> Label
   2:    oLoopPop
   2:    ;
      
      % for hacky debugging
   2: mechanism msg_mech:
   2:    oMsg( int num )             % print message "oMsg <num>"
   2:    oMsgTrace( int num )        % print message "oMsg <num>" followed by ssl traceback
   2:    oMsgNode( Node node )       % print node
   2:    oMsgNodeVec( NodeVec vec )  % print node vec
   2:    ;
      
      
   2: rules
      
      % ----------------------------- Global Variables ----------------------------
      
   2: Node    globalScope            % global nScope
      
      % built-in nTypes
   2: Node    FileType
   2: Node    IntegerType
   2: Node    BooleanType
   2: Node    BooleanCFType
   2: Node    CharType
   2: Node    StringType
      
      % -------------------------- Forward Declarations -------------------------
      
   2: Block( node_type varNodeType, Label labelForBody );
   2: BlockDecls( node_type varNodeType );
   2: BlockStmt( Label labelForBody );
   2: VarDecl( node_type varNodeType );
   2: newType( node_type nt, int size ) >> Node;
   2: newIdent( node_type nt, kind k, int id ) >> Node;
   2: EmitValue( Node decl );
   2: TypeRef( out Node theType );
   2: PointerTypeTo( Node theType ) >> Node;
   2: OrdinalLow( Node theType ) >> int;
   2: AssignStmt( Node decl );
   2: BooleanExprControlFlow( out Label falseLabel );
   2: ExprAllowCF( out Label falseLabel );
   2: BoolExprAllowCF( out Label falseLabel );
   2: BoolTermAllowCF( out Label falseLabel );
   2: BoolFactorAllowCF( out Label falseLabel );
   2: ArithExprAllowCF( out Label falseLabel );
   2: TermAllowCF( out Label falseLabel );
   2: FactorAllowCF( out Label falseLabel );
   2: PrimaryAllowCF( out Label falseLabel );
      
      
      
   2: VarExpr( Node decl );
   2: LValueVar( Node decl );
   2: IncVar( Node decl );
   2: DecVar( Node decl );
      
   2: CFToVal( inout Label falseLabel );
   2: ValToCF( out Label falseLabel );
      
      % ----------------------------- Declarations ----------------------------
      
   2: Program:
   4:    Node t
      
   4:    oScopeBegin
   5:    globalScope = oScopeCurrent
      
  10:    @installBuiltIns
      
         % Start by calling the main program routine
  12:    Label mainLabel = oLabelNew
      
  17:    .tCall  oEmitLabel( mainLabel )
  25:    .tReturn
      
  27:    pProgram
  29:    pIdent
      
  31:    Node progDecl = @newIdent( nProgram, kProgram, LAST_ID )
  47:    oScopeDeclare( progDecl )
      
  53:    [
  53:       | '(' :
  55:          pIdent      % input, output files
      
  57:          t = @newIdent( nVar, kVar, LAST_ID )
  73:          oNodeSet( t, qType, FileType )
  85:          oScopeDeclareAlloc( t )
      
  91:          ','
  93:          pIdent
      
  95:          t = @newIdent( nVar, kVar, LAST_ID )
 111:          oNodeSet( t, qType, FileType )
 123:          oScopeDeclareAlloc( t )
      
 129:          ')'
 131:       | * :
 136:    ]
 136:    ';'
      
 138:    @BlockDecls( nGlobalVar )
      
         % a new scope just for temporaries in the main routine
 145:    oScopeBegin
 146:    oNodeSetBoolean( oScopeCurrent, qAllocDown, true )
 157:    oNodeSet( progDecl, qMainRoutineScope, oScopeCurrent )
      
         % The block statement includes a stack frame, and enter/return,
         % even for the main routine.
         % That will be necessary for temporaries allocated in the main routine.
 168:    @BlockStmt( mainLabel )
      
 175:    oScopeEnd   % main routine scope
      
 176:    '.'
 178:    oScopeEnd   % global scope
 180:    ;
      
      
 180: Block( node_type varNodeType, Label labelForBody ):
 182:    @BlockDecls( varNodeType )
 189:    @BlockStmt( labelForBody )
 197:    ;
      
      
 197: BlockDecls( node_type varNodeType ):
 199:    {[
 199:       | pConst :     @ConstDecl
 203:       | pType :      @TypeDecl
 207:       | pVar :       @VarDecl( varNodeType )
 216:       | pProcedure : @ProcDecl
 220:       | pFunction :  @FuncDecl
 224:       | * :          >
 239:    ]};
      
      
 242: BlockStmt( Label labelForBody ):
 244:    .tLabel  oEmitLabel( labelForBody )
      
         % Proc, func, and main routine all start with tEnter
         % to create a stack frame.  This will be used for temporaries
         % (and local vars in the case of proc, func).
      
 252:    int patchLS
 252:    .tEnter  patchLS = Here  .tSpace
      
 261:    @Statement
 263:    .tReturn
      
 265:    int localSpace = oNodeGetInt( oScopeCurrent, qSize )
 277:    oPatch( patchLS, localSpace )
 287:    ;
      
      
      
 287: ProcDecl:
 289:    pIdent
 291:    Node decl = @newIdent( nProc, kProc, LAST_ID )
      
 307:    oScopeBegin
 308:    Node paramScope = oScopeCurrent
      
 313:    @FormalArgDecl
 315:    oNodeSet( decl, qParams, paramScope )
 327:    oScopeEnd
      
 328:    oScopeDeclare( decl )
 334:    ';'
      
         % Enter the params scope again, so params are visible in body.
         % TO DO: Perhaps I could mark the scope read-only at this point.
 336:    oScopeEnter( paramScope )
      
         % Start scope for declarations within the proc
 342:    oScopeBegin
 343:    oNodeSetBoolean( oScopeCurrent, qAllocDown, true )
 354:    oNodeSet( decl, qChildScope, oScopeCurrent )
      
 365:    Label label = oLabelNew
 370:    @Block( nLocalVar, label )
 380:    oNodeSetLabel( decl, qValue, label )
 392:    oNodeSetBoolean( decl, qAddrDefined, true )
 404:    oScopeEnd
      
 405:    oScopeEnd  % paramScope
 406:    ';';
      
 409: FuncDecl:
 411:    pIdent
 413:    Node decl = @newIdent( nFunc, kFunc, LAST_ID )
      
 429:    oScopeBegin
 430:    Node paramScope = oScopeCurrent
      
 435:    @FormalArgDecl
 437:    oNodeSet( decl, qParams, paramScope )
      
 449:    ':'
      
 451:    Node theType
 451:    @TypeRef( theType )
 458:    oNodeSet( decl, qType, theType )
      
         % The function's param space gets an additional pointer,
         % which will point to a temporary in the caller's scope.
         % This pointer is essentially a VAR param, but I won't create an nParam for it.
      
 470:    Node ptrType = @PointerTypeTo( theType )
 481:    oNodeSetInt( decl, qResultOffset, oScopeAllocType( ptrType ) )
      
 497:    ';'
      
 499:    oScopeEnd
 500:    oScopeDeclare( decl )
      
         % Enter the params scope again, so params are visible in body.
         % TO DO: Perhaps I could mark the scope read-only at this point.
 506:    oScopeEnter( paramScope )
      
 512:    oScopeBegin
 513:    oNodeSetBoolean( oScopeCurrent, qAllocDown, true )
 524:    oNodeSet( decl, qChildScope, oScopeCurrent )
      
 535:    Label label = oLabelNew
 540:    @Block( nLocalVar, label )
 550:    oNodeSetLabel( decl, qValue, label )
 562:    oNodeSetBoolean( decl, qAddrDefined, true )
 574:    oScopeEnd
      
 575:    oScopeEnd  % paramScope
 576:    ';';
      
      
 579: FormalArgDecl:
 581:    [
 581:       | '(' :
 583:          {
 583:             NodeVec decls = oNodeVecNew
 588:             Node decl
 588:             boolean isInOut = false
      
 594:             [
 594:                | pVar : isInOut = true
 602:                | * :
 607:             ]
      
 607:             {  pIdent
      
 609:                decl = @newIdent( nParam, kVar, LAST_ID )
 625:                oNodeSetBoolean( decl, qInOut, isInOut )
 637:                oNodeVecAppend( decls, decl )
      
 646:                [
 646:                   | ':' : >
 650:                   | ',' :
 652:                ]
 660:             }
      
 662:             Node theType
 662:             @TypeRef( theType )
      
                  % VAR param is declared with its given type, but allocated as a pointer.
 669:             Node allocType
 669:             [ isInOut
 672:                | true :   allocType = @PointerTypeTo( theType )
 684:                | * :      allocType = theType
 695:             ]
      
 695:             int i = 0
 701:             {[ equal( i, oNodeVecSize( decls ) )
 715:                | false :
 716:                   decl = oNodeVecElement( decls, i )
      
 729:                   oNodeSet( decl, qType, theType )
 741:                   oScopeDeclare( decl )
 747:                   oNodeSetInt( decl, qValue, oScopeAllocType( allocType ) )
 763:                   inc( i )
 769:                | * :
 774:                   >
 776:             ]}
      
 778:             oNodeVecDelete( decls )
      
 784:             [
 784:                | ')' : >
 788:                | ';' :
 790:             ]
 798:          }
 800:       | * :
 805:    ];
      
 806: ConstDecl:
 808:    {[
 808:       | pIdent :
 810:          Node decl = @newIdent( nConst, kConst, LAST_ID )
 826:          '='
      
 828:          @ConstExpr
               % TO DO: currently ConstExpr leaves int result on oValue stack
 830:          int val = oValueTop
 835:          oValuePop
 836:          oNodeSetInt( decl, qValue, val )
      
               % TO DO: different types.  Currently assumes int!
 848:          oNodeSet( decl, qType, IntegerType )
      
 860:          oScopeDeclare( decl )
 866:          ';'
 868:       | * :
 873:          >
 875:    ]};
      
 878: TypeDecl:
 880:    {[
 880:       | pIdent :
 882:          Node decl = @newIdent( nTypeDecl, kType, LAST_ID )
 898:          '='
 900:          Node theType
 900:          @TypeRef( theType )
 907:          oNodeSet( decl, qType, theType )
 919:          oScopeDeclare( decl )
 925:          ';'
 927:       | * :
 932:          >
 934:    ]};
      
 937: VarDecl( node_type varNodeType ):
 939:    {[
 939:       | pIdent :
 941:          NodeVec decls = oNodeVecNew
 946:          Node decl
 946:          {
 946:             decl = @newIdent( varNodeType, kVar, LAST_ID )
 962:             oNodeVecAppend( decls, decl )
 971:             [
 971:                | ',' :
 973:                   pIdent
 975:                | * :
 980:                   >
 982:             ]
 982:          }
 984:          ':'
 986:          Node theType
 986:          @TypeRef( theType )
      
 993:          int i = 0
 999:          {[ equal( i, oNodeVecSize( decls ) )
1013:            | false :
1014:              decl = oNodeVecElement( decls, i )
1027:              oNodeSet( decl, qType, theType )
1039:              oScopeDeclareAlloc( decl )
1045:              inc( i )
1051:             | * :
1056:               >
1058:          ]}
      
1060:          oNodeVecDelete( decls )
1066:          ';'
1068:       | * :
1073:          >
1075:    ]};
      
      
      % Parse a type reference, returning the nType.
      % This will add types to the type table, as needed.
      %
      % Style question - at the moment I think callers look clearer if we use
      % an out param here, rather than a return value.
      %
1078: TypeRef( out Node resultType ):
1080:    [
1080:       | pIdent :           % previously named type (including intrinsics)
1082:          Node decl = oScopeFindRequire
1087:          [ oNodeType( decl )
1094:            | nTypeDecl :
1095:                resultType = oNodeGet( decl, qType )
1108:            | * :
1113:                #eNotType
1115:                resultType = IntegerType
1121:          ]
         
1121:       | pArray :
1123:          '['
      
               % A multi-dimensional array is represented as a chain
               %    array [subrange1] of array [subrange2] of elementType
      
               % First, we build a vector of nArray's, each with one subrange as its index type,
               % but without setting the "of" type or size.
      
1125:          NodeVec dimensions = oNodeVecNew
      
1130:          {
                  % to do: probably should use general subrange parsing, incl minimal size value
                  %   In fact, supposed to parse ordinal_type here.  all ordinal types have a static low, high.
                  %   Not necessary to be a subrange.
      
1130:             Node subrange = oNodeNew( nSubrangeType )
                  % TO DO: currently assuming subrange of integer
1140:             oNodeSet( subrange, qBaseType, IntegerType )
      
                  % TO DO: currently ConstExpr leaves int result on oValue stack
1152:             @ConstExpr
1154:             oNodeSetInt( subrange, qLow, oValueTop )
1165:             oValuePop
1166:             '..'
1168:             @ConstExpr
1170:             oNodeSetInt( subrange, qHigh, oValueTop )
1181:             oValuePop
1182:             oNodeSetInt( subrange, qSize, 4 )   % maybe don't need
      
1194:             oTypeAdd( subrange )
      
1200:             Node a = oNodeNew( nArrayType )
1210:             oNodeSet( a, qIndexType, subrange )
      
1222:             oNodeVecAppend( dimensions, a )
                  % I'll hold off on adding 'a' to the type table since not fully formed yet
      
1231:             [
1231:                | ']' : >
1235:                | ',' :
1237:             ]
1245:          }
      
1247:          pOf
1249:          Node baseType
1249:          @TypeRef( baseType )
      
               % Work backwards through the dimensions,
               % hooking up the 'of' type and calculating the size.
               % At each iteration, baseType is the 'of' type.
      
1256:          int dim = oNodeVecSize( dimensions )
      
1266:          {
1266:              dec(dim)
      
1272:              Node a = oNodeVecElement( dimensions, dim )
      
1285:              oNodeSet( a, qBaseType, baseType )
1297:              Node subrange = oNodeGet( a, qIndexType )
1310:              int width = subtract( oNodeGetInt( subrange, qHigh ), oNodeGetInt( subrange, qLow ) )
1337:              inc( width )
1343:              oNodeSetInt( a, qSize, multiply( width, oNodeGetInt( baseType, qSize ) ) )
      
1369:              oTypeAdd( a )
1375:              baseType = a
      
1381:              [ equal_zero(dim)
1388:                  | true:  >
1391:                  | *:
1396:              ]
1396:          }
      
1398:          resultType = oNodeVecElement( dimensions, 0 )
1411:          oNodeVecDelete( dimensions )
      
1417:       | '^' :
1419:          Node theType
1419:          @TypeRef( theType )
1426:          resultType = @PointerTypeTo( theType )
      
1437:       | pRecord :
1439:          resultType = oNodeNew( nRecordType )
1449:          oScopeBegin
      
1450:          @VarDecl( nRecordField )
      
1457:          int size = oNodeGetInt( oScopeCurrent, qSize )
               % to do: padding
1469:          [ equal_zero( size )
1476:             | true : #eRecordEmpty
1479:             | * :
1484:          ]
      
1484:          pEnd
      
1486:          oNodeSet( resultType, qScope, oScopeCurrent )
1497:          oNodeSetInt( resultType, qSize, size )
1509:          oScopeEnd
1510:          oTypeAdd( resultType )
      
      
            % *** TO DO: following type constructors are not implemented *** 
            % *** TO DO: also missing declaration of enum type
1516:       | pSet :
1518:          pOf
1520:          Node theType
1520:          @TypeRef( theType )
1527:       | * :       % this works for cases except where expr starts with an id
1540:          @ConstExpr '..' @ConstExpr
1546:    ];
      
      
      % --------------------------- Const Expressions --------------------------
      
      % Constant expressions: currently, only literal integers or previously
      % named constant integers are supported, possibly with a negation.
      % Constant expressions are evaluated at compile time.
      
1547: ConstExpr:
1549:    [
1549:       | pIntLit :
1551:          oValuePush( TOKEN_VALUE )
1556:       | pIdent :
1558:          Node decl = oScopeFindRequire
1563:          [ oNodeType( decl )
1570:             | nConst :
1571:                oValuePush( oNodeGetInt( decl, qValue ) )
1584:             | * :
1589:                #eNotConst
1591:                oValuePush( 0 )
1597:          ]
1597:       | pMinus :
1599:          @ConstExpr
1601:          oValueNegate
1602:    ];
      
      
      
      % ------------------------------ Expressions -----------------------------
      
      % There are two wrappers leading into expression parsing:
      %   Expr()
      %   BooleanExprControlFlow( out Label falseLabel )
      %
      % Expr always produces a value on the runtime expr stack,
      % and pushes its type on the type stack.
      %
      % BooleanExprControlFlow always generates control-flow code.
      % It does not push a value on the runtime expr stack.
      % It does not push a type on the type stack.
      % The control flow code ends up at Here if the expr is true,
      % and jumps to falseLabel if the expr is false.
      % This rule allocates falseLabel, and passes it back.
      % The caller will need to define its location.
      %
      % The internal methods of expr parsing may produce a mix of
      % values and control flow, depending on the operators seen.
      % We don't always do one or the other, hoping to be efficient for
      % cases like   "func_call( bool_var1, bool_var2 )"
      % as well as  "if bool_expr1 or bool_expr2 then ...".
      % If a subexpression rule produces control flow, it will allocate a
      % falseLabel and pass it back up.  And it will push the
      % result type as BooleanCFType, to distinguish from BooleanType
      % which corresponds with a boolean value on the expr stack.
      % 
      % Note that my expression parsing is broken into more levels than
      % grammars describe for Pascal precedence levels.  This follows my
      % original parser implementation.  I think my rationale was that
      % operators from the levels that I split up couldn't have been
      % mixed anyway, since they require different data types
      % (e.g. boolean vs int/real).  And splitting them up simplified
      % my code.  But, I should revisit this.
      %
      
      
      % Public entry point:
      %
      % Parse an expression, leaving a value on the runtime expr stack
      % and its type on the type stack.
      %
      % This rule does not export control flow (though it may generate
      % control flow internally for subexpressions).
      %
1613: Expr:
1615:    Label falseLabel = labelNull
      
1621:    @ExprAllowCF( falseLabel )
1628:    @CFToVal( falseLabel );
      
      
      % Public entry point:
      %
      % Parse a Boolean expression, producing control flow code rather than a value.
      % Does not leave a value on the runtime expr stack.
      % Does not leave a type on the type stack.
      %
      % If the expression is true, the code will fall through to the end (Here).
      % If the expression is false, the code will jump to the given falseLabel,
      % which this rule will allocate but not define the location for.
      % The caller must do so.
      %
1636: BooleanExprControlFlow( out Label falseLabel ):
1638:    @ExprAllowCF( falseLabel )
1645:    [ oTypeSNodeType
1647:       | nBooleanCFType :
1648:       | nBooleanType :
               % convert value to control flow
1650:          falseLabel = oLabelNew
1655:          .tJumpFalse  oEmitLabel( falseLabel )
1663:       | * :
1670:          #eNotBoolean
1672:    ]
1672:    oTypeSPop;
      
      
      % If the current expr result is control flow, convert it to a value.
      % falseLabel is the label that had been used by the control flow.
      % On return it will be set to labelNull.
      %
1674: CFToVal( inout Label falseLabel ):
1676:    [ oTypeSNodeType
1678:       | nBooleanCFType :
1679:          Label doneLabel = oLabelNew
1684:          .tPushConstI  oEmitInt( 1 )
1692:          .tJump  oEmitLabel( doneLabel )
1700:          .tLabel  oEmitLabel( falseLabel )
1708:          .tPushConstI  oEmitInt( 0 )
1716:          .tLabel  oEmitLabel( doneLabel )
1724:          oTypeSPop
1725:          oTypeSPush( BooleanType )
1731:          falseLabel = labelNull
1737:       | * :
1742:    ];
      
      
      % If the current expr result is boolean value, convert it to control flow.
      % falseLabel will be allocated by this rule and passed back.
      % The caller must define its location.
      %
1743: ValToCF( out Label falseLabel ):
1745:    [ oTypeSNodeType
1747:       | nBooleanType :
1748:          falseLabel = oLabelNew
1753:          .tJumpFalse  oEmitLabel( falseLabel )
1761:          oTypeSPop
1762:          oTypeSPush( BooleanCFType )
1768:       | * :
1773:    ];
      
      
      % Parse an expression.  It may produce a value on the expr stack,
      % or control flow, depending on what's seen in the expression.
      % Leaves the expression type on the type stack.
      %
      % If the expression produces control flow, the expression type will be
      % nBooleanCFType.  In this case, a true value falls through to Here,
      % and a false value jumps to falseLabel.  This rule will allocate falseLabel
      % and return it, but will not define its location; the caller must do so.
      %
      % If the expression produces a value, the value will be left on the
      % expression stack, and the type will be some type other than nBooleanCFType.
      % In this case, falseLabel is ignored.
      %
1774: ExprAllowCF( out Label falseLabel ):
1776:    @BoolExprAllowCF( falseLabel )
1783:    {[
1783:       | '=' :
1785:          @CFToVal( falseLabel )
1792:          @BoolExprAllowCF( falseLabel )
1799:          @CFToVal( falseLabel )
1806:          @MatchTypes
1808:          [ oTypeSNodeType
1810:             | nIntegerType, nBooleanType :  .tEqualI
1813:             | nPointerType :                .tEqualP
1817:             | nCharType, nStringType :      #eNotImplemented
1821:             | * :                           #eNotAllowed
1836:          ]
1836:          oTypeSPop
1837:          oTypeSPush( BooleanType )
      
1843:       | '<>' :
1845:          @CFToVal( falseLabel )
1852:          @BoolExprAllowCF( falseLabel )
1859:          @CFToVal( falseLabel )
1866:          @MatchTypes
1868:          [ oTypeSNodeType
1870:             | nIntegerType, nBooleanType :  .tNotEqualI
1873:             | nPointerType :                .tNotEqualP
1877:             | nCharType, nStringType :      #eNotImplemented
1881:             | * :                           #eNotAllowed
1896:          ]
1896:          oTypeSPop
1897:          oTypeSPush( BooleanType )
      
1903:       | '<' :
1905:          @CFToVal( falseLabel )
1912:          @BoolExprAllowCF( falseLabel )
1919:          @CFToVal( falseLabel )
1926:          @MatchTypes
1928:          [ oTypeSNodeType
1930:             | nIntegerType, nBooleanType :  .tLessI
1933:             | nCharType, nStringType :      #eNotImplemented
1937:             | * :                           #eNotAllowed
1950:          ]
1950:          oTypeSPop
1951:          oTypeSPush( BooleanType )
      
1957:       | '>' :
1959:          @CFToVal( falseLabel )
1966:          @BoolExprAllowCF( falseLabel )
1973:          @CFToVal( falseLabel )
1980:          @MatchTypes
1982:          [ oTypeSNodeType
1984:             | nIntegerType, nBooleanType :  .tGreaterI
1987:             | nCharType, nStringType :      #eNotImplemented
1991:             | * :                           #eNotAllowed
2004:          ]
2004:          oTypeSPop
2005:          oTypeSPush( BooleanType )
      
2011:       | '<=' :
2013:          @CFToVal( falseLabel )
2020:          @BoolExprAllowCF( falseLabel )
2027:          @CFToVal( falseLabel )
2034:          @MatchTypes
2036:          [ oTypeSNodeType
2038:             | nIntegerType, nBooleanType :  .tLessEqualI
2041:             | nCharType, nStringType :      #eNotImplemented
2045:             | * :                           #eNotAllowed
2058:          ]
2058:          oTypeSPop
2059:          oTypeSPush( BooleanType )
      
2065:       | '>=' :
2067:          @CFToVal( falseLabel )
2074:          @BoolExprAllowCF( falseLabel )
2081:          @CFToVal( falseLabel )
2088:          @MatchTypes
2090:          [ oTypeSNodeType
2092:             | nIntegerType, nBooleanType :  .tGreaterEqualI
2095:             | nCharType, nStringType :      #eNotImplemented
2099:             | * :                           #eNotAllowed
2112:          ]
2112:          oTypeSPop
2113:          oTypeSPush( BooleanType )
      
2119:       | * :
2134:          >
2136:    ]};
      
      
2139: BoolExprAllowCF( out Label falseLabel ):
2141:    Label trueLabel = labelNull
      
2147:    @BoolTermAllowCF( falseLabel )
2154:    {[
2154:       | pOr :
2156:          [ oTypeSNodeType
2158:             | nBooleanCFType :
                     % We are true here. Jump ahead to done
2159:                [ equal_label( trueLabel, labelNull )
2169:                   | true :  trueLabel = oLabelNew
2175:                   | * :
2180:                ]
2180:                .tJump  oEmitLabel( trueLabel )
2188:             | nBooleanType :
2190:                @ValToCF( falseLabel )
                     % We might be true here. If so, jump ahead to done
2197:                [ equal_label( trueLabel, labelNull )
2207:                   | true :  trueLabel = oLabelNew
2213:                   | * :
2218:                ]
2218:                .tJumpTrue  oEmitLabel( trueLabel )
2226:             | * : #eNotBoolean
2235:          ]
2235:          oTypeSPop
      
               % false in previous term will jump here, to try this alternative term
2236:          .tLabel  oEmitLabel( falseLabel )
      
               % we'll get a new falseLabel for this term
2244:          falseLabel = labelNull
2250:          @BoolTermAllowCF( falseLabel )
      
2257:          [ oTypeSNodeType
2259:             | nBooleanCFType :
2260:             | nBooleanType :
2262:                @ValToCF( falseLabel )
2269:             | * : #eNotBoolean
2278:          ]
      
2278:          oTypeSPop
2279:          oTypeSPush( BooleanCFType )
      
2285:       | * :
2290:          >
2292:    ]}
      
         % any short-circuit trues jump here to the end
2294:    [ equal_label( trueLabel, labelNull )
2304:       | false :
2305:          .tLabel  oEmitLabel( trueLabel )
2313:       | * :
2318:    ]
2319:    ;
      
      
2319: BoolTermAllowCF( out Label falseLabel ):
2321:    Label overallFalseLabel = labelNull
      
2327:    @BoolFactorAllowCF( falseLabel )
2334:    {[
2334:       | pAnd :
2336:          [ oTypeSNodeType
2338:             | nBooleanCFType :
2339:             | nBooleanType :
2341:                @ValToCF( falseLabel )
2348:             | * :
2355:                #eNotBoolean
2357:          ]
2357:          oTypeSPop
      
               % We're going to have a different falseLabel for each term,
               % because we let each rule allocate its own (rather than accepting labels passed in).
               % And in this case we want them all to go to the same place,
               % to be determined by the caller.
               %
               % I'll allow for label aliases.  This will be more optimal than generating
               % multiple private false-handling code segments, that the true path would have to
               % jump around.  That would be hard to eliminate afterwards.
      
2358:          [ equal_label( overallFalseLabel, labelNull )
2368:             | true :
2369:                overallFalseLabel = oLabelNew
2374:                .tLabelAlias  oEmitLabel( falseLabel )  oEmitLabel( overallFalseLabel )
2388:                falseLabel = overallFalseLabel
2394:             | * :
2399:          ]
      
2399:          Label factorFalseLabel = labelNull
2405:          @BoolFactorAllowCF( factorFalseLabel )
      
2412:          [ oTypeSNodeType
2414:             | nBooleanCFType :
2415:             | nBooleanType :
2417:                @ValToCF( factorFalseLabel )
2424:             | * : #eNotBoolean
2433:          ]
2433:         .tLabelAlias  oEmitLabel( factorFalseLabel )  oEmitLabel( overallFalseLabel )
      
2447:       | * :
2452:          >
2454:    ]};
      
2457: BoolFactorAllowCF( out Label falseLabel ):
2459:    [
2459:       | pNot :
2461:          Label factorFalseLabel = labelNull
      
2467:          @BoolFactorAllowCF( factorFalseLabel )
2474:          [ oTypeSNodeType
2476:             | nBooleanCFType :
                     % We have control flow, and are sitting at the point that has value false.
2477:                falseLabel = oLabelNew
2482:                .tJump  oEmitLabel( falseLabel )
                     % The true path jumps here
2490:                .tLabel  oEmitLabel( factorFalseLabel )
      
2498:             | nBooleanType :
                     % I have a value.  I'll leave it as a value, rather than create control flow.
                     % See how this goes.
2500:                .tNot
      
2502:             | * : #eNotBoolean
2511:          ]
      
2511:       | * :
2516:          @ArithExprAllowCF( falseLabel )
2523:    ];
      
2524: ArithExprAllowCF( out Label falseLabel ):
2526:    @TermAllowCF( falseLabel )
2533:    {[
2533:       | pPlus :
2535:          @RequireIntPop
2537:          @TermAllowCF( falseLabel )  % actually not allowing CF, will be caught by type check
2544:          @RequireInt
2546:          .tAddI
2548:       | pMinus :
2550:          @RequireIntPop
2552:          @TermAllowCF( falseLabel )
2559:          @RequireInt
2561:          .tSubI
2563:       | * :
2570:          >
2572:    ]};
      
2575: TermAllowCF( out Label falseLabel ):
2577:    @FactorAllowCF( falseLabel )
2584:    {[
2584:       | pTimes :
2586:          @RequireIntPop
2588:          @FactorAllowCF( falseLabel )  % actually not allowing CF, will be caught by type check
2595:          @RequireInt
2597:          .tMultI
2599:       | pDivide :
2601:          @RequireIntPop
2603:          @FactorAllowCF( falseLabel )
2610:          @RequireInt
2612:          .tDivI
2614:       | * :
2621:          >
2623:    ]};
      
2626: FactorAllowCF( out Label falseLabel ):
2628:    [
2628:       | pPlus :
2630:          @PrimaryAllowCF( falseLabel )  % actually not allowing CF, will be caught by type check
2637:          @RequireInt
2639:       | pMinus :
2641:          @PrimaryAllowCF( falseLabel )
2648:          @RequireInt
2650:          .tNegI
2652:       | * :
2659:          @PrimaryAllowCF( falseLabel )
2666:    ];
      
2667: PrimaryAllowCF( out Label falseLabel ):
2669:    [
2669:       | pIntLit :
2671:          .tPushConstI  oEmitInt( TOKEN_VALUE )
2678:          oTypeSPush( IntegerType )
      
2684:       | '(' :
2686:          @ExprAllowCF( falseLabel )
2693:          ')'
      
2695:       | pStrLit :
2697:          oStringAllocLit     % store in global data, push offset on value stack
2698:          .tPushAddrGlobal oEmitInt( oValueTop )  oValuePop
               % TO DO: do we need to create a type with the literal's length?
2706:          oTypeSPush( StringType )
      
2712:       | pIdent :
2714:          Node decl = oScopeFindRequire
2719:          Node theType
      
2719:          [ oNodeType( decl )
2726:             | nFunc :
      
2727:                @Call( decl )
      
2734:             | nConst :
2736:                theType = oNodeGet( decl, qType )
2749:                oTypeSPush( theType )
2755:                [ oTypeSNodeType
2757:                   | nIntegerType, nBooleanType :
2758:                      .tPushConstI @EmitValue( decl )
2767:                   | * :
2774:                      #eNotImplemented
2776:                ]
      
2776:             | nGlobalVar, nLocalVar, nParam :
2778:                @VarExpr( decl )
      
2785:             | * :
2798:                #eNotValue
2800:                oTypeSPush( IntegerType )
2806:          ]
      
2806:       | '@' :        % @var -- pointer to var
2808:          pIdent
      
2810:          Node decl = oScopeFindRequire
2815:          Node theType
      
2815:          @LValueVar( decl )
      
               % The above leaves the pointed-to type on type stack.
               % Replace with ptr-to-<type>.
2822:          theType = oTypeSTop
2827:          oTypeSPop
2828:          Node ptrType = @PointerTypeTo( theType )
2839:          oTypeSPush( ptrType )
      
2845:       | * :
2858:          #eNotValue
2860:          oTypeSPush( IntegerType )
2866:    ];
      
      
      % Parse a variable expression, given the declaration of the
      % just-accepted identifier.
      % Leaves the value on the expression stack, and type on the type stack.
      %
2867: VarExpr( Node decl ):
2869:    Node theType = oNodeGet( decl, qType )
2882:    oTypeSPush( theType )
2888:    [ oTypeSNodeType
2890:       | nIntegerType :
2891:          [ oNodeType( decl )
2898:             | nGlobalVar :   .tPushGlobalI @EmitValue( decl )
2908:             | nLocalVar :    .tPushLocalI @EmitValue( decl )
2919:             | nParam :
2921:                [ oNodeGetBoolean( decl, qInOut )
2931:                   | true :    % VAR param points to the var.  Auto dereference.
2932:                               .tPushParamP @EmitValue( decl )
2941:                               .tFetchI
2943:                   | * :       .tPushParamI @EmitValue( decl )
2957:                ]
2957:          ]
      
2967:       | nBooleanType :
2969:          [ oNodeType( decl )
2976:             | nGlobalVar :   .tPushGlobalB @EmitValue( decl )
2986:             | nLocalVar :    .tPushLocalB @EmitValue( decl )
2997:             | nParam :
2999:                [ oNodeGetBoolean( decl, qInOut )
3009:                   | true :    % VAR param points to the var.  Auto derefernce.
3010:                               .tPushParamP @EmitValue( decl )
3019:                               .tFetchB
3021:                   | * :       .tPushParamB @EmitValue( decl )
3035:                ]
3035:          ]
      
3045:       | nCharType, nStringType, nFileType :
3047:          #eNotImplemented
      
3049:       | nPointerType :
3051:          [ oNodeType( decl )
3058:             | nGlobalVar :   .tPushGlobalP @EmitValue( decl )
3068:             | nLocalVar :    .tPushLocalP @EmitValue( decl )
3079:             | nParam :
3081:                [ oNodeGetBoolean( decl, qInOut )
3091:                   | true :    % VAR param points to the var.  Auto derefernce.
3092:                               .tPushParamP @EmitValue( decl )
3101:                               .tFetchP
3103:                   | * :       .tPushParamP @EmitValue( decl )
3117:                ]
3117:          ]
3127:          [
3127:             | '^' :             % dereferenced
3129:                oTypeSPop
3130:                oTypeSPush( oNodeGet( theType, qBaseType ) )
3143:                @LValueIndexes
3145:                @FetchVar
3147:             | * :               % just ptr value alone
3152:          ]
      
3152:       | * :
               % compound type
               % first, push addr of start of var
3167:          [ oNodeType( decl )
3174:             | nGlobalVar :   .tPushAddrGlobal @EmitValue( decl )
3184:             | nLocalVar :    .tPushAddrLocal @EmitValue( decl )
3195:             | nParam :
3197:                [ oNodeGetBoolean( decl, qInOut )
3207:                   | true :    % VAR param points to the var.  Auto derefernce.
3208:                               .tPushParamP @EmitValue( decl )
3217:                   | * :       .tPushAddrParam @EmitValue( decl )
3231:                ]
3231:          ]
               % modify addr for subscripts, field references, etc
3241:          @LValueIndexes
               % get final value
3243:          @FetchVar
3245:    ];
      
      
      % Addr of start of var is on expr stack; type is on type stack.
      % Replace expr stack with value of var.
      % (In the case of compound vars, this remains as the addr of the var).
      
3246: FetchVar:
3248:    [ oTypeSNodeType
3250:       | nIntegerType :   .tFetchI
3253:       | nBooleanType :   .tFetchB
3257:       | nCharType, nStringType, nFileType : #eNotImplemented
3261:       | nPointerType :   .tFetchP
3265:       | * :              % compound type; leave as addr
3280:    ];
      
      
      % Addr of start of var is already on run stack, and type is on type stack.
      % Read subscripts, record fields, etc, to get final addr on run stack, and final type
      % on type stack.
      
3281: LValueIndexes:
3283:    {[
3283:       | '[' :       @ArraySubscripts
3287:       | '.' :       @RecordFieldRef
3291:       | '^' :       @PointerDeref
3295:       | * :         >
3306:    ]};
      
3309: ArraySubscripts:
3311:    [ oTypeSNodeType
3313:       | nArrayType :
3314:       | * :       #eNotArray
3321:    ]
3321:    {
3321:       [ oTypeSNodeType
3323:          | nArrayType :
3324:          | * :    #eTooManySubscripts
3331:       ]
      
            % low subscript of this dimension
3331:       int low = @OrdinalLow( oNodeGet( oTypeSTop, qIndexType ) )
      
            % replace type stack with next dimension, or OF type
3348:       Node baseType
3348:       baseType = oNodeGet( oTypeSTop, qBaseType )
3360:       oTypeSPop
3361:       oTypeSPush( baseType )
      
3367:       @Expr
3369:       @RequireIntPop
            % adjust for low subscript
3371:       [ equal_zero( low )
3378:          | false :
3379:             .tPushConstI oEmitInt( low ) .tSubI
3389:          | * :
3394:       ]
      
            % multiply by element size
3394:       int size = oNodeGetInt( baseType, qSize )
3407:       [ equal( size, 1 )
3417:          | false :
3418:             .tPushConstI oEmitInt( size ) .tMultI
3428:          | * :
3433:       ]
      
            % update start address
3433:       .tAddPI
3435:       [
3435:          | ']' :  >
3439:          | ',' :
3441:       ]
3449:    };
      
      
3452: RecordFieldRef:
3454:    [ oTypeSNodeType
3456:       | nRecordType :
3457:       | * :    #eNotRecord
3464:    ]
3464:    oScopeEnter( oNodeGet( oTypeSTop, qScope ) )
3476:    pIdent
3478:    Node field = oScopeFindRequire
         % oScopeFind searches all open scopes, so make sure we found nRecordField
         % which could only be seen in the local scope we entered above.
3483:    [ oNodeType( field )
3490:       | nRecordField :
3491:       | * :   #eNotRecordField
3498:    ]
3498:    oScopeEnd
3499:    int offset = oNodeGetInt( field, qValue )
3512:    [ equal_zero( offset )
3519:       | false :
3520:          .tPushConstI oEmitInt( offset ) .tAddPI
3530:       | * :
3535:    ]
      
         % replace the type on the type stack, with the field type
3535:    oTypeSPop
3536:    oTypeSPush( oNodeGet( field, qType ) )
3550:    ;
      
      
      % ptr deref on left side, i.e. BEFORE addr of ptr var is on stack,
      %                              AFTER addr of thing pointed to is on stack
3550: PointerDeref:
3552:    [ oTypeSNodeType
3554:       | nPointerType :
3555:       | * :       #eNotPointer
3562:    ]
3562:    .tFetchP           % now addr on stack is addr of what we're pointing to
      
3564:    Node theType = oTypeSTop
3569:    oTypeSPop
3570:    oTypeSPush( oNodeGet( theType, qBaseType ) )
3584:    ;
      
      
      % The expr stack contains a value whose type is on top of the type stack.
      % Generate code to coerce the value to the type under it in the type stack
      % (pop the type stack, leaving only the desired type).
      % This is used for assignment.
      %
3584: CoerceType:
         % TO DO: not implemented yet.  For now I require exact type match.
3586:    @MatchTypes
3589:    ;
      
      
      % Parse a call, given an nProc or nFunc for the just-accepted identifier.
      % If a func, this will also generate the code to push the return value on the expr stack,
      % and push the return type on the type stack.
      %
3589: Call( Node method ):
      
         % If this is a function, we will allocate a temporary
         % in the current scope, to hold the result value.
         % And pass a pointer to that temporary as an extra parameter.
3591:    Node resultType
3591:    int tempOffset
      
3591:    boolean isFunc = equal_node_type( oNodeType( method ), nFunc )
      
3608:    [ isFunc
3611:       | true :
3612:          resultType = oNodeGet( method, qType )
3625:          tempOffset = oScopeAllocType( resultType )
               % TO DO: we could manage temp allocation, so temp space can be reused
               %        by different code branches.
3635:       | * :
3640:    ]
         
      
3640:    Node paramScope = oNodeGet( method, qParams )
3653:    int actualsSize = oNodeGetInt( paramScope, qSize )
3666:    .tAllocActuals  oEmitInt( actualsSize )
      
3674:    Node param = oNodeGet( paramScope, qDecls )
3687:    [
3687:       | '(' :
            
3689:          {
3689:             [ oNodeNull( param )
3696:                | true : >
3699:                | * :
3704:             ]
      
3704:             int offset = oNodeGetInt( param, qValue )
      
                  % Assign actual value to spot in actuals space
3717:             .tPushAddrActual oEmitInt( offset )
3725:             oTypeSPush( oNodeGet( param, qType ) )
      
3738:             [ oNodeGetBoolean( param, qInOut )
3748:                | true :   % A VAR param.
                                % The actual is a pointer to the value.
                                % The type on the type stack (pushed above) is for the pointed-to value.
      
3749:                           @LValueExpr
                                % Addr of the referenced variable is on the expr stack,
                                % type of the variable is on the type stack.
      
                                % Match types more exactly. It's not sufficient to be assign compatible
                                % since the method will be assigning to the actual using the param type.
                                % Maybe something like type contents must match, incl subrange bounds.
3751:                           @MatchTypes
      
3753:                           .tAssignP
      
3755:                | false :  @Expr
3759:                           @CoerceType
                                
                                % Assign to offset in actuals space
      
3761:                           [ oTypeSNodeType
3763:                              | nIntegerType :            .tAssignI
3766:                              | nBooleanType :            .tAssignB
3770:                              | nCharType, nStringType, nFileType :   #eNotImplemented
3774:                              | nPointerType :            .tAssignP
3778:                              | * :
                                       % compound types: copy value into actuals space
3793:                                  int size = oNodeGetInt( oTypeSTop, qSize )
3805:                                  .tCopy  oEmitInt( size )    % multi-word copy
3813:                           ]
3813:             ]
3821:             oTypeSPop
      
3822:             oNodeNext( param )
3828:             [ oNodeNull( param )
3835:                | true :  >
3838:                | false :
3840:             ]
      
3848:             ','
3850:          }
      
3852:          ')'
      
3854:       | * :
3859:    ]
      
3859:    [ oNodeNull( param )
3866:       | false :    #eMissingParameter
3869:       | * :
3874:    ]
      
3874:    [ isFunc
3877:       | true :
               % Pass result temp as an additional VAR parameter.
3878:          .tPushAddrActual oEmitInt( oNodeGetInt( method, qResultOffset ) )
3893:          .tPushAddrLocal  oEmitInt( tempOffset )
3901:          .tAssignP
3903:       | * :
3908:    ]
      
3908:    .tCall   @EmitValue( method )
      
3917:    [ isFunc
3920:       | true :
               % push return value from temp
3921:          oTypeSPush( resultType )
3927:          .tPushAddrLocal  oEmitInt( tempOffset )
3935:          @FetchVar
3937:       | * :
3942:    ]
         
3942:    .tFreeActuals  oEmitInt( actualsSize )
3951:    ;
      
      
      % ------------------------------ Statements -----------------------------
      
3951: Statement:
3953:    [
3953:       | pWriteln :     @WritelnStmt
3957:       | pWrite :       @WriteStmt
3961:       | pReadln :      @ReadlnStmt
3965:       | pRead :        @ReadStmt
3969:       | pIf :          @IfStmt
3973:       | pWhile :       @WhileStmt
3977:       | pFor :         @ForStmt
3981:       | pRepeat :      @RepeatStmt
3985:       | pBreak :       @BreakStmt
3989:       | pContinue :    @ContinueStmt
3993:       | pBegin :       @BeginStmt
3997:       | pIdent :       @AssignOrCallStmt
4001:       | * :            % null statement : don't accept any tokens
4028:    ];
      
      
4029: AssignOrCallStmt:
4031:    Node decl = oScopeFindRequire
4036:    [ oNodeType( decl )
4043:       | nProc :                           @Call( decl )
4051:       | nGlobalVar, nLocalVar, nParam :   @AssignStmt( decl )
4060:       | nFunc :                           @AssignResultStmt( decl )
4069:       | * :                               #eBadStatement
4084:    ];
      
      
      % Given decl, the just-accepted first identifier on the left hand side.
      %
4085: AssignStmt( Node decl ):
      
4087:    @LValueVar( decl )
      
4094:    ':=' 
4096:    @Expr
4098:    @MatchTypes
4100:    [ oTypeSNodeType
4102:       | nIntegerType :            .tAssignI
4105:       | nBooleanType :            .tAssignB
4109:       | nCharType, nStringType, nFileType :   #eNotImplemented
      
            % compound var assigns; addrs of src, dest on stack
4113:       | nPointerType :            .tAssignP
4117:       | * :
4132:           int size = oNodeGetInt( oTypeSTop, qSize )
4144:           .tCopy  oEmitInt( size )    % multi-word copy
4152:    ]
4152:    oTypeSPop
4154:    ;
      
      
      % Given nFunc for the just-accepted identifier on the left hand side.
      % Parse an assignment that represents assignment of the function result.
      %
4154: AssignResultStmt( Node funcDecl ):
         % Only allowed to assign the result of the immediately enclosing function, I think.
4156:    [ oNodeEqual( oNodeGet( funcDecl, qChildScope ), oScopeCurrent )
4172:       | false :   #eNotCurrentFunction
4175:       | * :
4180:    ]
      
         % Result value is stored in the caller's space, via a hidden VAR parameter.
4180:    .tPushParamP  oEmitInt( oNodeGetInt( funcDecl, qResultOffset ) )
4195:    oTypeSPush( oNodeGet( funcDecl, qType ) )
      
4208:    ':='
4210:    @Expr
4212:    @MatchTypes
4214:    [ oTypeSNodeType
4216:       | nIntegerType :            .tAssignI
4219:       | nBooleanType :            .tAssignB
4223:       | nCharType, nStringType, nFileType :   #eNotImplemented
      
            % compound var assigns; addrs of src, dest on stack
4227:       | nPointerType :            .tAssignP
4231:       | * :
4246:           int size = oNodeGetInt( oTypeSTop, qSize )
4258:           .tCopy  oEmitInt( size )    % multi-word copy
4266:    ]
4266:    oTypeSPop
4268:    ;
      
      
      
      % Parse an lvalue expression, from scratch.
      % This is an expression that may appear on the left side of an assignment.
      % Leaves the address of the value on the expr stack,
      % and the type of the value at that address on the type stack.
      %
4268: LValueExpr:
         % At the moment, all lvalue expressions start with a variable name.
         % I think there can also be typecasts, not supported yet.  Check standard syntax.
4270:    pIdent
4272:    Node decl = oScopeFindRequire
4277:    [ oNodeType( decl )
4284:       | nGlobalVar, nLocalVar, nParam :
4285:       | * :  #eNotVar
4296:    ]
4296:    @LValueVar( decl )
4304:    ;
      
      
      % Parse an lvalue expression (e.g. left side of an assign statement)
      % that starts with the just-accepted identifier indicated by the given decl.
      % Leaves the lvalue address on the expression stack,
      % and the type of the value at that address on the type stack.
      %
4304: LValueVar( Node decl ):
4306:    [ oNodeType( decl )
4313:       | nGlobalVar :   .tPushAddrGlobal @EmitValue( decl )
4323:       | nLocalVar :    .tPushAddrLocal @EmitValue( decl )
4334:       | nParam :
4336:          [ oNodeGetBoolean( decl, qInOut )
4346:             | true :   % VAR param points to variable.  No dereference.
4347:                        .tPushParamP @EmitValue( decl )
4356:             | * :      .tPushAddrParam @EmitValue( decl )
4370:          ]
4370:       | * :            #eNotVar
4381:    ]
      
4381:    oTypeSPush( oNodeGet( decl, qType ) )
4394:    @LValueIndexes        % handle subscripts, if any
4397:    ;
      
      
4397: IncVar( Node decl ):
4399:    @LValueVar( decl )
4406:    @RequireIntPop
4408:    @VarExpr( decl )
4415:    oTypeSPop
4416:    .tIncI
4418:    .tAssignI;
      
4421: DecVar( Node decl ):
4423:    @LValueVar( decl )
4430:    @RequireIntPop
4432:    @VarExpr( decl )
4439:    oTypeSPop
4440:    .tDecI
4442:    .tAssignI;
      
      
4445: IfStmt:
4447:    Label falseLabel = labelNull
      
4453:    @BooleanExprControlFlow( falseLabel )
4460:    pThen
4462:    @Statement
4464:    [
4464:       | pElse :
4466:          Label doneLabel = oLabelNew
      
4471:          .tJump  oEmitLabel( doneLabel )
4479:          .tLabel oEmitLabel( falseLabel )
4487:          @Statement
4489:          .tLabel oEmitLabel( doneLabel )
      
4497:       | * :
4502:          .tLabel oEmitLabel( falseLabel )
4510:    ];
      
      
4511: ForStmt:
4513:    pIdent
      
4515:    Node decl = oScopeFindRequire
         % TO DO: disallow use of a compound variable field.
         %        Could do that by disallowing use of LValueIndexes,
         %        or by double-checking the decl's qType here.
4520:    @LValueVar( decl )
4527:    @RequireIntPop
      
4529:    ':='
      
4531:    @Expr
4533:    @RequireIntPop
4535:    .tAssignI
      
4537:    Label breakLabel = oLabelNew
      
4542:    Label checkLabel = oLabelNew
4547:    .tJump  oEmitLabel( checkLabel )
      
4555:    Label continueLabel = oLabelNew
4560:    .tLabel  oEmitLabel( continueLabel )
4568:    [
4568:       | pTo :
4570:          @IncVar( decl )
4577:          .tLabel  oEmitLabel( checkLabel )
4585:          @VarExpr( decl )  oTypeSPop
4593:          @Expr
4595:          @RequireIntPop
4597:          .tGreaterI
4599:          .tJumpTrue  oEmitLabel( breakLabel )
4607:       | pDownto :
4609:          @DecVar( decl )
4616:          .tLabel  oEmitLabel( checkLabel )
4624:          @VarExpr( decl )  oTypeSPop
4632:          @Expr
4634:          @RequireIntPop
4636:          .tLessI
4638:          .tJumpTrue  oEmitLabel( breakLabel )
4646:    ]
4654:    oLoopPush( continueLabel, breakLabel )
4663:    pDo
4665:    @Statement
4667:    .tJump  oEmitLabel( continueLabel )
4675:    .tLabel  oEmitLabel( breakLabel )
4683:    oLoopPop;
      
      
4685: RepeatStmt:
4687:    Label continueLabel = oLabelNew
4692:    .tLabel  oEmitLabel( continueLabel )
      
4700:    Label breakLabel = oLabelNew
      
4705:    oLoopPush( continueLabel, breakLabel )
4714:    @Statement
4716:    {[
4716:       | ';' :
4718:          @Statement
4720:       | pUntil :
4722:          Label falseLabel
4722:          @BooleanExprControlFlow( falseLabel )
4729:          .tLabelAlias  oEmitLabel( falseLabel )  oEmitLabel( continueLabel )
4743:          >
4745:    ]}
4755:    .tLabel  oEmitLabel( breakLabel )
4763:    oLoopPop;
      
      
4765: WhileStmt:
4767:    Label continueLabel = oLabelNew
4772:    .tLabel  oEmitLabel( continueLabel )
      
4780:    Label breakLabel
4780:    @BooleanExprControlFlow( breakLabel )
      
4787:    oLoopPush( continueLabel, breakLabel )
4796:    pDo
4798:    @Statement
4800:    .tJump  oEmitLabel( continueLabel )
4808:    .tLabel  oEmitLabel( breakLabel )
4816:    oLoopPop;
      
      
4818: ContinueStmt:                     % NOTE, for repeat..until, skips test (??)
4820:    [ equal_label( oLoopContinueLabel, labelNull )
4829:       | true :
4830:          #eNotInALoop
4832:       | false :
4834:          .tJump  oEmitLabel( oLoopContinueLabel )
4841:    ];
      
      
4850: BreakStmt:
4852:    [ equal_label( oLoopBreakLabel, labelNull )
4861:       | true :
4862:          #eNotInALoop
4864:       | false :
4866:          .tJump  oEmitLabel( oLoopBreakLabel )
4873:    ];
      
      
4882: BeginStmt:
4884:    @Statement
4886:    {[
4886:       | ';' :   @Statement
4890:       | pEnd :  >
4894:    ]};
      
      
4905: WritelnStmt:
4907:    @WriteStmt
4909:    .tWriteCR;
      
      
4912: WriteStmt:
4914:    [
4914:       | '(' :
4916:          {
4916:             @Expr
4918:             [ oTypeSNodeType
4920:                | nIntegerType :             .tWriteI
4923:                | nBooleanType :             .tWriteBool
4927:                | nStringType :              .tWriteStr
4931:                | nCharType, nFileType :     #eNotImplemented
4935:                | nPointerType :             .tWriteP
4939:                | * :                        #eNotAllowed
4956:             ]
4956:             oTypeSPop
4957:             [
4957:                | ')' : >
4961:                | ',' :
4963:             ]
4971:          }
4973:       | * :
4978:    ];
      
      
4979: ReadlnStmt:      % ***
         % TO DO
4982:    ;
      
4982: ReadStmt:
         % TO DO
4985:    ;
      
      % -------------------------------- Utilities -------------------------------
      
      
      % Require that the top two types on the type stack are matching (ignoring subranges).
      % Pop one of them, leaving only one.
      %
4985: MatchTypes:
4987:    node_type nt = oTypeSNodeType
4992:    oTypeSPop
4993:    [ equal_node_type( nt, oTypeSNodeType )
5002:       | false :
5003:          #eTypeMismatch
5005:       | * :
5010:    ];
      
      
      % Require that the top type on the type stack is integer (ignoring subranges).
      % Pop it.
      %
5011: RequireIntPop:
5013:    [ oTypeSNodeType
5015:       | nIntegerType :
5016:       | * :          #eNotInteger
5023:    ]
5023:    oTypeSPop;
      
5025: RequireInt:
5027:    [ oTypeSNodeType
5029:       | nIntegerType :
5030:       | * :          #eNotInteger
5037:    ];
      
5038: RequireBoolPop:
5040:    [ oTypeSNodeType
5042:       | nBooleanType :
5043:       | * :          #eNotBoolean
5050:    ]
5050:    oTypeSPop;
      
5052: RequireBool:
5054:    [ oTypeSNodeType
5056:       | nBooleanType :
5057:       | * :          #eNotBoolean
5064:    ];
      
      
      % Create and return a new nType of the given node_type, adding it to the type table.
      %
5065: newType( node_type nt, int size ) >> Node:
5067:   Node node = oNodeNew( nt )
5077:   oNodeSetInt( node, qSize, size )
5089:   oTypeAdd( node )
5095:   >> node
5099:   ;
      
      
      % Create and return a new nIdent of the given node_type, with the given ident id.
      % Does not add it to any scope.
      %
5099: newIdent( node_type nt, kind k, int id ) >> Node:
5101:   Node t = oNodeNew( nt )
5111:   oNodeSetInt( t, qIdent, id )
5123:   >> t
5127:   ;
      
      
      % Return an nType representing a pointer to the given type.
      % (Creates a new type if necessary.)
      %
5127: PointerTypeTo( Node theType ) >> Node:
5129:    Node ptrType = oNodeGet( theType, qPointerType )
5142:    [ oNodeNull( ptrType )
5149:       | true :
5150:          ptrType = oNodeNew( nPointerType )
5160:          oNodeSet( ptrType, qBaseType, theType )
5172:          oNodeSetInt( ptrType, qSize, 8 )
5184:          oTypeAdd( ptrType )
5190:          oNodeSet( theType, qPointerType, ptrType )
5202:       | * :
5207:    ]
5207:    >> ptrType;
      
      
      % Return the low value of an ordinal type
      %
5211: OrdinalLow( Node theType ) >> int:
5213:    [ oNodeType( theType )
5220:       | nIntegerType :  >> oMININT    % NOTE ssl literals are limited to 16 bit at the moment, though values are 32 bit ok. So need a mechanism.
5223:       | nBooleanType :  >> 0
5228:       | nCharType :     >> 0
5233:       | nSubrangeType : >> oNodeGetInt( theType, qLow )
5245:       | * :             #eNotOrdinalType
5258:                         >> 0
5261:    ];
      
      
      
      % Emit the value in a declaration.
      % For a constant integer, this is the constant value.
      % For a global variable, this is the global address.
      % For a local variable, this is the local address relative to the call stack frame.
      %
5262: EmitValue( Node decl ):
5264:     oEmitInt( oNodeGetInt( decl, qValue ));
      
      
5278: installBuiltIns:
      
         % install built-in types
5280:    FileType = @newType( nFileType, 4 )
5294:    IntegerType = @newType( nIntegerType, 4 )
5308:    BooleanType = @newType( nBooleanType, 1 )
5322:    BooleanCFType = @newType( nBooleanCFType, 1 )
5336:    CharType = @newType( nCharType, 1 )
5350:    StringType = @newType( nStringType, 256 )    % string with default length 256
      
         % Declare those type identifiers.
         % SSL doesn't support strings, so need help from operations e.g. oIdAdd_File
      
5364:    Node t
      
5364:    t = @newIdent( nTypeDecl, kType, oIdAdd_File )
5380:    oNodeSet( t, qType, FileType )
5392:    oScopeDeclare( t )
      
5398:    t = @newIdent( nTypeDecl, kType, oIdAdd_Integer )
5414:    oNodeSet( t, qType, IntegerType )
5426:    oScopeDeclare( t )
      
5432:    t = @newIdent( nTypeDecl, kType, oIdAdd_Boolean )
5448:    oNodeSet( t, qType, BooleanType )
5460:    oScopeDeclare( t )
      
5466:    t = @newIdent( nTypeDecl, kType, oIdAdd_Char )
5482:    oNodeSet( t, qType, CharType )
5494:    oScopeDeclare( t )
      
5500:    t = @newIdent( nTypeDecl, kType, oIdAdd_String )
5516:    oNodeSet( t, qType, StringType )
5528:    oScopeDeclare( t )
      
         % Built-in constants
      
5534:    t = @newIdent( nConst, kConst, oIdAdd_True )
5550:    oNodeSet( t, qType, BooleanType )
5562:    oNodeSetInt( t, qValue, 1 )
5574:    oScopeDeclare( t )
      
5580:    t = @newIdent( nConst, kConst, oIdAdd_False )
5596:    oNodeSet( t, qType, BooleanType )
5608:    oNodeSetInt( t, qValue, 0 )
5620:    oScopeDeclare( t )
      
5627:    ;
      
5627: end
      
5627: 

Generated code:

   0: oGlobalSpace 8
   2: oLocalSpace 3
   4: oScopeBegin
   5: oGetAddrGlobal 1
   7: oPushResult
   8: oScopeCurrent
   9: oAssign
  10: oCall 5278
  12: oGetAddrLocal 2
  14: oPushResult
  15: oLabelNew
  16: oAssign
  17: oEmit 40
  19: oGetLocal 2
  21: oPushResult
  22: oEmitLabel
  23: oPop 1
  25: oEmit 41
  27: oInput 27
  29: oInput 0
  31: oGetAddrLocal 3
  33: oPushResult
  34: oSetResult 5
  36: oPushResult
  37: oSetResult 1
  39: oPushResult
  40: LAST_ID
  41: oPushResult
  42: oCall 5099
  44: oPop 3
  46: oAssign
  47: oGetLocal 3
  49: oPushResult
  50: oScopeDeclare
  51: oPop 1
  53: oInputChoice 133
  55: oInput 0
  57: oGetAddrLocal 1
  59: oPushResult
  60: oSetResult 11
  62: oPushResult
  63: oSetResult 6
  65: oPushResult
  66: LAST_ID
  67: oPushResult
  68: oCall 5099
  70: oPop 3
  72: oAssign
  73: oGetLocal 1
  75: oPushResult
  76: oSetResult 5
  78: oPushResult
  79: oGetGlobal 2
  81: oPushResult
  82: oNodeSet
  83: oPop 3
  85: oGetLocal 1
  87: oPushResult
  88: oScopeDeclareAlloc
  89: oPop 1
  91: oInput 12
  93: oInput 0
  95: oGetAddrLocal 1
  97: oPushResult
  98: oSetResult 11
 100: oPushResult
 101: oSetResult 6
 103: oPushResult
 104: LAST_ID
 105: oPushResult
 106: oCall 5099
 108: oPop 3
 110: oAssign
 111: oGetLocal 1
 113: oPushResult
 114: oSetResult 5
 116: oPushResult
 117: oGetGlobal 2
 119: oPushResult
 120: oNodeSet
 121: oPop 3
 123: oGetLocal 1
 125: oPushResult
 126: oScopeDeclareAlloc
 127: oPop 1
 129: oInput 14
 131: oJumpForward 136
 133: Choice Lookup Table
          13     55
 136: oInput 4
 138: oSetResult 12
 140: oPushResult
 141: oCall 197
 143: oPop 1
 145: oScopeBegin
 146: oScopeCurrent
 147: oPushResult
 148: oSetResult 3
 150: oPushResult
 151: oSetResult 1
 153: oPushResult
 154: oNodeSetBoolean
 155: oPop 3
 157: oGetLocal 3
 159: oPushResult
 160: oSetResult 7
 162: oPushResult
 163: oScopeCurrent
 164: oPushResult
 165: oNodeSet
 166: oPop 3
 168: oGetLocal 2
 170: oPushResult
 171: oCall 242
 173: oPop 1
 175: oScopeEnd
 176: oInput 19
 178: oScopeEnd
 179: oReturn
 180: oLocalSpace 0
 182: oGetParam 2
 184: oPushResult
 185: oCall 197
 187: oPop 1
 189: oGetParam 1
 191: oPushResult
 192: oCall 242
 194: oPop 1
 196: oReturn
 197: oLocalSpace 0
 199: oInputChoice 226
 201: oCall 806
 203: oJumpForward 239
 205: oCall 878
 207: oJumpForward 239
 209: oGetParam 1
 211: oPushResult
 212: oCall 937
 214: oPop 1
 216: oJumpForward 239
 218: oCall 287
 220: oJumpForward 239
 222: oCall 409
 224: oJumpForward 239
 226: Choice Lookup Table
          29    222
          28    218
          32    209
          31    205
          30    201
 237: oJumpForward 241
 239: oJumpBack 199
 241: oReturn
 242: oLocalSpace 2
 244: oEmit 46
 246: oGetParam 1
 248: oPushResult
 249: oEmitLabel
 250: oPop 1
 252: oEmit 42
 254: oGetAddrLocal 1
 256: oPushResult
 257: Here
 258: oAssign
 259: oEmit 53
 261: oCall 3951
 263: oEmit 41
 265: oGetAddrLocal 2
 267: oPushResult
 268: oScopeCurrent
 269: oPushResult
 270: oSetResult 2
 272: oPushResult
 273: oNodeGetInt
 274: oPop 2
 276: oAssign
 277: oGetLocal 1
 279: oPushResult
 280: oGetLocal 2
 282: oPushResult
 283: oPatch
 284: oPop 2
 286: oReturn
 287: oLocalSpace 3
 289: oInput 0
 291: oGetAddrLocal 1
 293: oPushResult
 294: oSetResult 7
 296: oPushResult
 297: oSetResult 2
 299: oPushResult
 300: LAST_ID
 301: oPushResult
 302: oCall 5099
 304: oPop 3
 306: oAssign
 307: oScopeBegin
 308: oGetAddrLocal 2
 310: oPushResult
 311: oScopeCurrent
 312: oAssign
 313: oCall 579
 315: oGetLocal 1
 317: oPushResult
 318: oSetResult 8
 320: oPushResult
 321: oGetLocal 2
 323: oPushResult
 324: oNodeSet
 325: oPop 3
 327: oScopeEnd
 328: oGetLocal 1
 330: oPushResult
 331: oScopeDeclare
 332: oPop 1
 334: oInput 4
 336: oGetLocal 2
 338: oPushResult
 339: oScopeEnter
 340: oPop 1
 342: oScopeBegin
 343: oScopeCurrent
 344: oPushResult
 345: oSetResult 3
 347: oPushResult
 348: oSetResult 1
 350: oPushResult
 351: oNodeSetBoolean
 352: oPop 3
 354: oGetLocal 1
 356: oPushResult
 357: oSetResult 9
 359: oPushResult
 360: oScopeCurrent
 361: oPushResult
 362: oNodeSet
 363: oPop 3
 365: oGetAddrLocal 3
 367: oPushResult
 368: oLabelNew
 369: oAssign
 370: oSetResult 13
 372: oPushResult
 373: oGetLocal 3
 375: oPushResult
 376: oCall 180
 378: oPop 2
 380: oGetLocal 1
 382: oPushResult
 383: oSetResult 6
 385: oPushResult
 386: oGetLocal 3
 388: oPushResult
 389: oNodeSetLabel
 390: oPop 3
 392: oGetLocal 1
 394: oPushResult
 395: oSetResult 10
 397: oPushResult
 398: oSetResult 1
 400: oPushResult
 401: oNodeSetBoolean
 402: oPop 3
 404: oScopeEnd
 405: oScopeEnd
 406: oInput 4
 408: oReturn
 409: oLocalSpace 5
 411: oInput 0
 413: oGetAddrLocal 1
 415: oPushResult
 416: oSetResult 8
 418: oPushResult
 419: oSetResult 3
 421: oPushResult
 422: LAST_ID
 423: oPushResult
 424: oCall 5099
 426: oPop 3
 428: oAssign
 429: oScopeBegin
 430: oGetAddrLocal 2
 432: oPushResult
 433: oScopeCurrent
 434: oAssign
 435: oCall 579
 437: oGetLocal 1
 439: oPushResult
 440: oSetResult 8
 442: oPushResult
 443: oGetLocal 2
 445: oPushResult
 446: oNodeSet
 447: oPop 3
 449: oInput 11
 451: oGetAddrLocal 3
 453: oPushResult
 454: oCall 1078
 456: oPop 1
 458: oGetLocal 1
 460: oPushResult
 461: oSetResult 5
 463: oPushResult
 464: oGetLocal 3
 466: oPushResult
 467: oNodeSet
 468: oPop 3
 470: oGetAddrLocal 4
 472: oPushResult
 473: oGetLocal 3
 475: oPushResult
 476: oCall 5127
 478: oPop 1
 480: oAssign
 481: oGetLocal 1
 483: oPushResult
 484: oSetResult 11
 486: oPushResult
 487: oGetLocal 4
 489: oPushResult
 490: oScopeAllocType
 491: oPop 1
 493: oPushResult
 494: oNodeSetInt
 495: oPop 3
 497: oInput 4
 499: oScopeEnd
 500: oGetLocal 1
 502: oPushResult
 503: oScopeDeclare
 504: oPop 1
 506: oGetLocal 2
 508: oPushResult
 509: oScopeEnter
 510: oPop 1
 512: oScopeBegin
 513: oScopeCurrent
 514: oPushResult
 515: oSetResult 3
 517: oPushResult
 518: oSetResult 1
 520: oPushResult
 521: oNodeSetBoolean
 522: oPop 3
 524: oGetLocal 1
 526: oPushResult
 527: oSetResult 9
 529: oPushResult
 530: oScopeCurrent
 531: oPushResult
 532: oNodeSet
 533: oPop 3
 535: oGetAddrLocal 5
 537: oPushResult
 538: oLabelNew
 539: oAssign
 540: oSetResult 13
 542: oPushResult
 543: oGetLocal 5
 545: oPushResult
 546: oCall 180
 548: oPop 2
 550: oGetLocal 1
 552: oPushResult
 553: oSetResult 6
 555: oPushResult
 556: oGetLocal 5
 558: oPushResult
 559: oNodeSetLabel
 560: oPop 3
 562: oGetLocal 1
 564: oPushResult
 565: oSetResult 10
 567: oPushResult
 568: oSetResult 1
 570: oPushResult
 571: oNodeSetBoolean
 572: oPop 3
 574: oScopeEnd
 575: oScopeEnd
 576: oInput 4
 578: oReturn
 579: oLocalSpace 6
 581: oInputChoice 802
 583: oGetAddrLocal 1
 585: oPushResult
 586: oNodeVecNew
 587: oAssign
 588: oGetAddrLocal 3
 590: oPushResult
 591: oSetResult 0
 593: oAssign
 594: oInputChoice 604
 596: oGetAddrLocal 3
 598: oPushResult
 599: oSetResult 1
 601: oAssign
 602: oJumpForward 607
 604: Choice Lookup Table
          32    596
 607: oInput 0
 609: oGetAddrLocal 2
 611: oPushResult
 612: oSetResult 15
 614: oPushResult
 615: oSetResult 6
 617: oPushResult
 618: LAST_ID
 619: oPushResult
 620: oCall 5099
 622: oPop 3
 624: oAssign
 625: oGetLocal 2
 627: oPushResult
 628: oSetResult 12
 630: oPushResult
 631: oGetLocal 3
 633: oPushResult
 634: oNodeSetBoolean
 635: oPop 3
 637: oGetLocal 1
 639: oPushResult
 640: oGetLocal 2
 642: oPushResult
 643: oNodeVecAppend
 644: oPop 2
 646: oInputChoice 654
 648: oJumpForward 662
 650: oJumpForward 660
 652: oJumpForward 660
 654: Choice Lookup Table
          12    652
          11    648
 659: oEndChoice
 660: oJumpBack 607
 662: oGetAddrLocal 4
 664: oPushResult
 665: oCall 1078
 667: oPop 1
 669: oGetLocal 3
 671: oChoice 686
 673: oGetAddrLocal 5
 675: oPushResult
 676: oGetLocal 4
 678: oPushResult
 679: oCall 5127
 681: oPop 1
 683: oAssign
 684: oJumpForward 695
 686: Choice Lookup Table
           1    673
 689: oGetAddrLocal 5
 691: oPushResult
 692: oGetLocal 4
 694: oAssign
 695: oGetAddrLocal 6
 697: oPushResult
 698: oSetResult 0
 700: oAssign
 701: oGetLocal 6
 703: oPushResult
 704: oGetLocal 1
 706: oPushResult
 707: oNodeVecSize
 708: oPop 1
 710: oPushResult
 711: equal
 712: oPop 2
 714: oChoice 771
 716: oGetAddrLocal 2
 718: oPushResult
 719: oGetLocal 1
 721: oPushResult
 722: oGetLocal 6
 724: oPushResult
 725: oNodeVecElement
 726: oPop 2
 728: oAssign
 729: oGetLocal 2
 731: oPushResult
 732: oSetResult 5
 734: oPushResult
 735: oGetLocal 4
 737: oPushResult
 738: oNodeSet
 739: oPop 3
 741: oGetLocal 2
 743: oPushResult
 744: oScopeDeclare
 745: oPop 1
 747: oGetLocal 2
 749: oPushResult
 750: oSetResult 6
 752: oPushResult
 753: oGetLocal 5
 755: oPushResult
 756: oScopeAllocType
 757: oPop 1
 759: oPushResult
 760: oNodeSetInt
 761: oPop 3
 763: oGetAddrLocal 6
 765: oPushResult
 766: inc
 767: oPop 1
 769: oJumpForward 776
 771: Choice Lookup Table
           0    716
 774: oJumpForward 778
 776: oJumpBack 701
 778: oGetLocal 1
 780: oPushResult
 781: oNodeVecDelete
 782: oPop 1
 784: oInputChoice 792
 786: oJumpForward 800
 788: oJumpForward 798
 790: oJumpForward 798
 792: Choice Lookup Table
           4    790
          14    786
 797: oEndChoice
 798: oJumpBack 583
 800: oJumpForward 805
 802: Choice Lookup Table
          13    583
 805: oReturn
 806: oLocalSpace 2
 808: oInputChoice 870
 810: oGetAddrLocal 1
 812: oPushResult
 813: oSetResult 9
 815: oPushResult
 816: oSetResult 4
 818: oPushResult
 819: LAST_ID
 820: oPushResult
 821: oCall 5099
 823: oPop 3
 825: oAssign
 826: oInput 5
 828: oCall 1547
 830: oGetAddrLocal 2
 832: oPushResult
 833: oValueTop
 834: oAssign
 835: oValuePop
 836: oGetLocal 1
 838: oPushResult
 839: oSetResult 6
 841: oPushResult
 842: oGetLocal 2
 844: oPushResult
 845: oNodeSetInt
 846: oPop 3
 848: oGetLocal 1
 850: oPushResult
 851: oSetResult 5
 853: oPushResult
 854: oGetGlobal 3
 856: oPushResult
 857: oNodeSet
 858: oPop 3
 860: oGetLocal 1
 862: oPushResult
 863: oScopeDeclare
 864: oPop 1
 866: oInput 4
 868: oJumpForward 875
 870: Choice Lookup Table
           0    810
 873: oJumpForward 877
 875: oJumpBack 808
 877: oReturn
 878: oLocalSpace 2
 880: oInputChoice 929
 882: oGetAddrLocal 1
 884: oPushResult
 885: oSetResult 10
 887: oPushResult
 888: oSetResult 5
 890: oPushResult
 891: LAST_ID
 892: oPushResult
 893: oCall 5099
 895: oPop 3
 897: oAssign
 898: oInput 5
 900: oGetAddrLocal 2
 902: oPushResult
 903: oCall 1078
 905: oPop 1
 907: oGetLocal 1
 909: oPushResult
 910: oSetResult 5
 912: oPushResult
 913: oGetLocal 2
 915: oPushResult
 916: oNodeSet
 917: oPop 3
 919: oGetLocal 1
 921: oPushResult
 922: oScopeDeclare
 923: oPop 1
 925: oInput 4
 927: oJumpForward 934
 929: Choice Lookup Table
           0    882
 932: oJumpForward 936
 934: oJumpBack 880
 936: oReturn
 937: oLocalSpace 4
 939: oInputChoice 1070
 941: oGetAddrLocal 1
 943: oPushResult
 944: oNodeVecNew
 945: oAssign
 946: oGetAddrLocal 2
 948: oPushResult
 949: oGetParam 1
 951: oPushResult
 952: oSetResult 6
 954: oPushResult
 955: LAST_ID
 956: oPushResult
 957: oCall 5099
 959: oPop 3
 961: oAssign
 962: oGetLocal 1
 964: oPushResult
 965: oGetLocal 2
 967: oPushResult
 968: oNodeVecAppend
 969: oPop 2
 971: oInputChoice 977
 973: oInput 0
 975: oJumpForward 982
 977: Choice Lookup Table
          12    973
 980: oJumpForward 984
 982: oJumpBack 946
 984: oInput 11
 986: oGetAddrLocal 3
 988: oPushResult
 989: oCall 1078
 991: oPop 1
 993: oGetAddrLocal 4
 995: oPushResult
 996: oSetResult 0
 998: oAssign
 999: oGetLocal 4
1001: oPushResult
1002: oGetLocal 1
1004: oPushResult
1005: oNodeVecSize
1006: oPop 1
1008: oPushResult
1009: equal
1010: oPop 2
1012: oChoice 1053
1014: oGetAddrLocal 2
1016: oPushResult
1017: oGetLocal 1
1019: oPushResult
1020: oGetLocal 4
1022: oPushResult
1023: oNodeVecElement
1024: oPop 2
1026: oAssign
1027: oGetLocal 2
1029: oPushResult
1030: oSetResult 5
1032: oPushResult
1033: oGetLocal 3
1035: oPushResult
1036: oNodeSet
1037: oPop 3
1039: oGetLocal 2
1041: oPushResult
1042: oScopeDeclareAlloc
1043: oPop 1
1045: oGetAddrLocal 4
1047: oPushResult
1048: inc
1049: oPop 1
1051: oJumpForward 1058
1053: Choice Lookup Table
           0   1014
1056: oJumpForward 1060
1058: oJumpBack 999
1060: oGetLocal 1
1062: oPushResult
1063: oNodeVecDelete
1064: oPop 1
1066: oInput 4
1068: oJumpForward 1075
1070: Choice Lookup Table
           0    941
1073: oJumpForward 1077
1075: oJumpBack 939
1077: oReturn
1078: oLocalSpace 12
1080: oInputChoice 1529
1082: oGetAddrLocal 1
1084: oPushResult
1085: oScopeFindRequire
1086: oAssign
1087: oGetLocal 1
1089: oPushResult
1090: oNodeType
1091: oPop 1
1093: oChoice 1110
1095: oGetParam 1
1097: oPushResult
1098: oGetLocal 1
1100: oPushResult
1101: oSetResult 5
1103: oPushResult
1104: oNodeGet
1105: oPop 2
1107: oAssign
1108: oJumpForward 1121
1110: Choice Lookup Table
          10   1095
1113: oError 2
1115: oGetParam 1
1117: oPushResult
1118: oGetGlobal 3
1120: oAssign
1121: oJumpForward 1546
1123: oInput 15
1125: oGetAddrLocal 2
1127: oPushResult
1128: oNodeVecNew
1129: oAssign
1130: oGetAddrLocal 3
1132: oPushResult
1133: oSetResult 25
1135: oPushResult
1136: oNodeNew
1137: oPop 1
1139: oAssign
1140: oGetLocal 3
1142: oPushResult
1143: oSetResult 14
1145: oPushResult
1146: oGetGlobal 3
1148: oPushResult
1149: oNodeSet
1150: oPop 3
1152: oCall 1547
1154: oGetLocal 3
1156: oPushResult
1157: oSetResult 16
1159: oPushResult
1160: oValueTop
1161: oPushResult
1162: oNodeSetInt
1163: oPop 3
1165: oValuePop
1166: oInput 20
1168: oCall 1547
1170: oGetLocal 3
1172: oPushResult
1173: oSetResult 17
1175: oPushResult
1176: oValueTop
1177: oPushResult
1178: oNodeSetInt
1179: oPop 3
1181: oValuePop
1182: oGetLocal 3
1184: oPushResult
1185: oSetResult 2
1187: oPushResult
1188: oSetResult 4
1190: oPushResult
1191: oNodeSetInt
1192: oPop 3
1194: oGetLocal 3
1196: oPushResult
1197: oTypeAdd
1198: oPop 1
1200: oGetAddrLocal 4
1202: oPushResult
1203: oSetResult 24
1205: oPushResult
1206: oNodeNew
1207: oPop 1
1209: oAssign
1210: oGetLocal 4
1212: oPushResult
1213: oSetResult 15
1215: oPushResult
1216: oGetLocal 3
1218: oPushResult
1219: oNodeSet
1220: oPop 3
1222: oGetLocal 2
1224: oPushResult
1225: oGetLocal 4
1227: oPushResult
1228: oNodeVecAppend
1229: oPop 2
1231: oInputChoice 1239
1233: oJumpForward 1247
1235: oJumpForward 1245
1237: oJumpForward 1245
1239: Choice Lookup Table
          12   1237
          16   1233
1244: oEndChoice
1245: oJumpBack 1130
1247: oInput 38
1249: oGetAddrLocal 5
1251: oPushResult
1252: oCall 1078
1254: oPop 1
1256: oGetAddrLocal 6
1258: oPushResult
1259: oGetLocal 2
1261: oPushResult
1262: oNodeVecSize
1263: oPop 1
1265: oAssign
1266: oGetAddrLocal 6
1268: oPushResult
1269: dec
1270: oPop 1
1272: oGetAddrLocal 7
1274: oPushResult
1275: oGetLocal 2
1277: oPushResult
1278: oGetLocal 6
1280: oPushResult
1281: oNodeVecElement
1282: oPop 2
1284: oAssign
1285: oGetLocal 7
1287: oPushResult
1288: oSetResult 14
1290: oPushResult
1291: oGetLocal 5
1293: oPushResult
1294: oNodeSet
1295: oPop 3
1297: oGetAddrLocal 8
1299: oPushResult
1300: oGetLocal 7
1302: oPushResult
1303: oSetResult 15
1305: oPushResult
1306: oNodeGet
1307: oPop 2
1309: oAssign
1310: oGetAddrLocal 9
1312: oPushResult
1313: oGetLocal 8
1315: oPushResult
1316: oSetResult 17
1318: oPushResult
1319: oNodeGetInt
1320: oPop 2
1322: oPushResult
1323: oGetLocal 8
1325: oPushResult
1326: oSetResult 16
1328: oPushResult
1329: oNodeGetInt
1330: oPop 2
1332: oPushResult
1333: subtract
1334: oPop 2
1336: oAssign
1337: oGetAddrLocal 9
1339: oPushResult
1340: inc
1341: oPop 1
1343: oGetLocal 7
1345: oPushResult
1346: oSetResult 2
1348: oPushResult
1349: oGetLocal 9
1351: oPushResult
1352: oGetLocal 5
1354: oPushResult
1355: oSetResult 2
1357: oPushResult
1358: oNodeGetInt
1359: oPop 2
1361: oPushResult
1362: multiply
1363: oPop 2
1365: oPushResult
1366: oNodeSetInt
1367: oPop 3
1369: oGetLocal 7
1371: oPushResult
1372: oTypeAdd
1373: oPop 1
1375: oGetAddrLocal 5
1377: oPushResult
1378: oGetLocal 7
1380: oAssign
1381: oGetLocal 6
1383: oPushResult
1384: equal_zero
1385: oPop 1
1387: oChoice 1393
1389: oJumpForward 1398
1391: oJumpForward 1396
1393: Choice Lookup Table
           1   1389
1396: oJumpBack 1266
1398: oGetParam 1
1400: oPushResult
1401: oGetLocal 2
1403: oPushResult
1404: oSetResult 0
1406: oPushResult
1407: oNodeVecElement
1408: oPop 2
1410: oAssign
1411: oGetLocal 2
1413: oPushResult
1414: oNodeVecDelete
1415: oPop 1
1417: oJumpForward 1546
1419: oGetAddrLocal 10
1421: oPushResult
1422: oCall 1078
1424: oPop 1
1426: oGetParam 1
1428: oPushResult
1429: oGetLocal 10
1431: oPushResult
1432: oCall 5127
1434: oPop 1
1436: oAssign
1437: oJumpForward 1546
1439: oGetParam 1
1441: oPushResult
1442: oSetResult 26
1444: oPushResult
1445: oNodeNew
1446: oPop 1
1448: oAssign
1449: oScopeBegin
1450: oSetResult 14
1452: oPushResult
1453: oCall 937
1455: oPop 1
1457: oGetAddrLocal 11
1459: oPushResult
1460: oScopeCurrent
1461: oPushResult
1462: oSetResult 2
1464: oPushResult
1465: oNodeGetInt
1466: oPop 2
1468: oAssign
1469: oGetLocal 11
1471: oPushResult
1472: equal_zero
1473: oPop 1
1475: oChoice 1481
1477: oError 19
1479: oJumpForward 1484
1481: Choice Lookup Table
           1   1477
1484: oInput 34
1486: oGetFromParam 1
1488: oPushResult
1489: oSetResult 18
1491: oPushResult
1492: oScopeCurrent
1493: oPushResult
1494: oNodeSet
1495: oPop 3
1497: oGetFromParam 1
1499: oPushResult
1500: oSetResult 2
1502: oPushResult
1503: oGetLocal 11
1505: oPushResult
1506: oNodeSetInt
1507: oPop 3
1509: oScopeEnd
1510: oGetFromParam 1
1512: oPushResult
1513: oTypeAdd
1514: oPop 1
1516: oJumpForward 1546
1518: oInput 38
1520: oGetAddrLocal 12
1522: oPushResult
1523: oCall 1078
1525: oPop 1
1527: oJumpForward 1546
1529: Choice Lookup Table
          37   1518
          36   1439
          17   1419
          35   1123
           0   1082
1540: oCall 1547
1542: oInput 20
1544: oCall 1547
1546: oReturn
1547: oLocalSpace 1
1549: oInputChoice 1604
1551: TOKEN_VALUE
1552: oPushResult
1553: oValuePush
1554: oPop 1
1556: oJumpForward 1612
1558: oGetAddrLocal 1
1560: oPushResult
1561: oScopeFindRequire
1562: oAssign
1563: oGetLocal 1
1565: oPushResult
1566: oNodeType
1567: oPop 1
1569: oChoice 1586
1571: oGetLocal 1
1573: oPushResult
1574: oSetResult 6
1576: oPushResult
1577: oNodeGetInt
1578: oPop 2
1580: oPushResult
1581: oValuePush
1582: oPop 1
1584: oJumpForward 1597
1586: Choice Lookup Table
           9   1571
1589: oError 1
1591: oSetResult 0
1593: oPushResult
1594: oValuePush
1595: oPop 1
1597: oJumpForward 1612
1599: oCall 1547
1601: oValueNegate
1602: oJumpForward 1612
1604: Choice Lookup Table
          24   1599
           0   1558
           1   1551
1611: oEndChoice
1612: oReturn
1613: oLocalSpace 1
1615: oGetAddrLocal 1
1617: oPushResult
1618: oSetResult 0
1620: oAssign
1621: oGetAddrLocal 1
1623: oPushResult
1624: oCall 1774
1626: oPop 1
1628: oGetAddrLocal 1
1630: oPushResult
1631: oCall 1674
1633: oPop 1
1635: oReturn
1636: oLocalSpace 0
1638: oGetParam 1
1640: oPushResult
1641: oCall 1774
1643: oPop 1
1645: oTypeSNodeType
1646: oChoice 1665
1648: oJumpForward 1672
1650: oGetParam 1
1652: oPushResult
1653: oLabelNew
1654: oAssign
1655: oEmit 45
1657: oGetFromParam 1
1659: oPushResult
1660: oEmitLabel
1661: oPop 1
1663: oJumpForward 1672
1665: Choice Lookup Table
          19   1650
          20   1648
1670: oError 8
1672: oTypeSPop
1673: oReturn
1674: oLocalSpace 1
1676: oTypeSNodeType
1677: oChoice 1739
1679: oGetAddrLocal 1
1681: oPushResult
1682: oLabelNew
1683: oAssign
1684: oEmit 9
1686: oSetResult 1
1688: oPushResult
1689: oEmitInt
1690: oPop 1
1692: oEmit 43
1694: oGetLocal 1
1696: oPushResult
1697: oEmitLabel
1698: oPop 1
1700: oEmit 46
1702: oGetFromParam 1
1704: oPushResult
1705: oEmitLabel
1706: oPop 1
1708: oEmit 9
1710: oSetResult 0
1712: oPushResult
1713: oEmitInt
1714: oPop 1
1716: oEmit 46
1718: oGetLocal 1
1720: oPushResult
1721: oEmitLabel
1722: oPop 1
1724: oTypeSPop
1725: oGetGlobal 4
1727: oPushResult
1728: oTypeSPush
1729: oPop 1
1731: oGetParam 1
1733: oPushResult
1734: oSetResult 0
1736: oAssign
1737: oJumpForward 1742
1739: Choice Lookup Table
          20   1679
1742: oReturn
1743: oLocalSpace 0
1745: oTypeSNodeType
1746: oChoice 1770
1748: oGetParam 1
1750: oPushResult
1751: oLabelNew
1752: oAssign
1753: oEmit 45
1755: oGetFromParam 1
1757: oPushResult
1758: oEmitLabel
1759: oPop 1
1761: oTypeSPop
1762: oGetGlobal 5
1764: oPushResult
1765: oTypeSPush
1766: oPop 1
1768: oJumpForward 1773
1770: Choice Lookup Table
          19   1748
1773: oReturn
1774: oLocalSpace 0
1776: oGetParam 1
1778: oPushResult
1779: oCall 2139
1781: oPop 1
1783: oInputChoice 2121
1785: oGetParam 1
1787: oPushResult
1788: oCall 1674
1790: oPop 1
1792: oGetParam 1
1794: oPushResult
1795: oCall 2139
1797: oPop 1
1799: oGetParam 1
1801: oPushResult
1802: oCall 1674
1804: oPop 1
1806: oCall 4985
1808: oTypeSNodeType
1809: oChoice 1823
1811: oEmit 30
1813: oJumpForward 1836
1815: oEmit 36
1817: oJumpForward 1836
1819: oError 16
1821: oJumpForward 1836
1823: Choice Lookup Table
          22   1819
          21   1819
          23   1815
          19   1811
          18   1811
1834: oError 17
1836: oTypeSPop
1837: oGetGlobal 4
1839: oPushResult
1840: oTypeSPush
1841: oPop 1
1843: oJumpForward 2136
1845: oGetParam 1
1847: oPushResult
1848: oCall 1674
1850: oPop 1
1852: oGetParam 1
1854: oPushResult
1855: oCall 2139
1857: oPop 1
1859: oGetParam 1
1861: oPushResult
1862: oCall 1674
1864: oPop 1
1866: oCall 4985
1868: oTypeSNodeType
1869: oChoice 1883
1871: oEmit 31
1873: oJumpForward 1896
1875: oEmit 37
1877: oJumpForward 1896
1879: oError 16
1881: oJumpForward 1896
1883: Choice Lookup Table
          22   1879
          21   1879
          23   1875
          19   1871
          18   1871
1894: oError 17
1896: oTypeSPop
1897: oGetGlobal 4
1899: oPushResult
1900: oTypeSPush
1901: oPop 1
1903: oJumpForward 2136
1905: oGetParam 1
1907: oPushResult
1908: oCall 1674
1910: oPop 1
1912: oGetParam 1
1914: oPushResult
1915: oCall 2139
1917: oPop 1
1919: oGetParam 1
1921: oPushResult
1922: oCall 1674
1924: oPop 1
1926: oCall 4985
1928: oTypeSNodeType
1929: oChoice 1939
1931: oEmit 33
1933: oJumpForward 1950
1935: oError 16
1937: oJumpForward 1950
1939: Choice Lookup Table
          22   1935
          21   1935
          19   1931
          18   1931
1948: oError 17
1950: oTypeSPop
1951: oGetGlobal 4
1953: oPushResult
1954: oTypeSPush
1955: oPop 1
1957: oJumpForward 2136
1959: oGetParam 1
1961: oPushResult
1962: oCall 1674
1964: oPop 1
1966: oGetParam 1
1968: oPushResult
1969: oCall 2139
1971: oPop 1
1973: oGetParam 1
1975: oPushResult
1976: oCall 1674
1978: oPop 1
1980: oCall 4985
1982: oTypeSNodeType
1983: oChoice 1993
1985: oEmit 32
1987: oJumpForward 2004
1989: oError 16
1991: oJumpForward 2004
1993: Choice Lookup Table
          22   1989
          21   1989
          19   1985
          18   1985
2002: oError 17
2004: oTypeSPop
2005: oGetGlobal 4
2007: oPushResult
2008: oTypeSPush
2009: oPop 1
2011: oJumpForward 2136
2013: oGetParam 1
2015: oPushResult
2016: oCall 1674
2018: oPop 1
2020: oGetParam 1
2022: oPushResult
2023: oCall 2139
2025: oPop 1
2027: oGetParam 1
2029: oPushResult
2030: oCall 1674
2032: oPop 1
2034: oCall 4985
2036: oTypeSNodeType
2037: oChoice 2047
2039: oEmit 35
2041: oJumpForward 2058
2043: oError 16
2045: oJumpForward 2058
2047: Choice Lookup Table
          22   2043
          21   2043
          19   2039
          18   2039
2056: oError 17
2058: oTypeSPop
2059: oGetGlobal 4
2061: oPushResult
2062: oTypeSPush
2063: oPop 1
2065: oJumpForward 2136
2067: oGetParam 1
2069: oPushResult
2070: oCall 1674
2072: oPop 1
2074: oGetParam 1
2076: oPushResult
2077: oCall 2139
2079: oPop 1
2081: oGetParam 1
2083: oPushResult
2084: oCall 1674
2086: oPop 1
2088: oCall 4985
2090: oTypeSNodeType
2091: oChoice 2101
2093: oEmit 34
2095: oJumpForward 2112
2097: oError 16
2099: oJumpForward 2112
2101: Choice Lookup Table
          22   2097
          21   2097
          19   2093
          18   2093
2110: oError 17
2112: oTypeSPop
2113: oGetGlobal 4
2115: oPushResult
2116: oTypeSPush
2117: oPop 1
2119: oJumpForward 2136
2121: Choice Lookup Table
          10   2067
           9   2013
           8   1959
           7   1905
           6   1845
           5   1785
2134: oJumpForward 2138
2136: oJumpBack 1783
2138: oReturn
2139: oLocalSpace 1
2141: oGetAddrLocal 1
2143: oPushResult
2144: oSetResult 0
2146: oAssign
2147: oGetParam 1
2149: oPushResult
2150: oCall 2319
2152: oPop 1
2154: oInputChoice 2287
2156: oTypeSNodeType
2157: oChoice 2228
2159: oGetLocal 1
2161: oPushResult
2162: oSetResult 0
2164: oPushResult
2165: equal_label
2166: oPop 2
2168: oChoice 2177
2170: oGetAddrLocal 1
2172: oPushResult
2173: oLabelNew
2174: oAssign
2175: oJumpForward 2180
2177: Choice Lookup Table
           1   2170
2180: oEmit 43
2182: oGetLocal 1
2184: oPushResult
2185: oEmitLabel
2186: oPop 1
2188: oJumpForward 2235
2190: oGetParam 1
2192: oPushResult
2193: oCall 1743
2195: oPop 1
2197: oGetLocal 1
2199: oPushResult
2200: oSetResult 0
2202: oPushResult
2203: equal_label
2204: oPop 2
2206: oChoice 2215
2208: oGetAddrLocal 1
2210: oPushResult
2211: oLabelNew
2212: oAssign
2213: oJumpForward 2218
2215: Choice Lookup Table
           1   2208
2218: oEmit 44
2220: oGetLocal 1
2222: oPushResult
2223: oEmitLabel
2224: oPop 1
2226: oJumpForward 2235
2228: Choice Lookup Table
          19   2190
          20   2159
2233: oError 8
2235: oTypeSPop
2236: oEmit 46
2238: oGetFromParam 1
2240: oPushResult
2241: oEmitLabel
2242: oPop 1
2244: oGetParam 1
2246: oPushResult
2247: oSetResult 0
2249: oAssign
2250: oGetParam 1
2252: oPushResult
2253: oCall 2319
2255: oPop 1
2257: oTypeSNodeType
2258: oChoice 2271
2260: oJumpForward 2278
2262: oGetParam 1
2264: oPushResult
2265: oCall 1743
2267: oPop 1
2269: oJumpForward 2278
2271: Choice Lookup Table
          19   2262
          20   2260
2276: oError 8
2278: oTypeSPop
2279: oGetGlobal 5
2281: oPushResult
2282: oTypeSPush
2283: oPop 1
2285: oJumpForward 2292
2287: Choice Lookup Table
          53   2156
2290: oJumpForward 2294
2292: oJumpBack 2154
2294: oGetLocal 1
2296: oPushResult
2297: oSetResult 0
2299: oPushResult
2300: equal_label
2301: oPop 2
2303: oChoice 2315
2305: oEmit 46
2307: oGetLocal 1
2309: oPushResult
2310: oEmitLabel
2311: oPop 1
2313: oJumpForward 2318
2315: Choice Lookup Table
           0   2305
2318: oReturn
2319: oLocalSpace 2
2321: oGetAddrLocal 1
2323: oPushResult
2324: oSetResult 0
2326: oAssign
2327: oGetParam 1
2329: oPushResult
2330: oCall 2457
2332: oPop 1
2334: oInputChoice 2449
2336: oTypeSNodeType
2337: oChoice 2350
2339: oJumpForward 2357
2341: oGetParam 1
2343: oPushResult
2344: oCall 1743
2346: oPop 1
2348: oJumpForward 2357
2350: Choice Lookup Table
          19   2341
          20   2339
2355: oError 8
2357: oTypeSPop
2358: oGetLocal 1
2360: oPushResult
2361: oSetResult 0
2363: oPushResult
2364: equal_label
2365: oPop 2
2367: oChoice 2396
2369: oGetAddrLocal 1
2371: oPushResult
2372: oLabelNew
2373: oAssign
2374: oEmit 47
2376: oGetFromParam 1
2378: oPushResult
2379: oEmitLabel
2380: oPop 1
2382: oGetLocal 1
2384: oPushResult
2385: oEmitLabel
2386: oPop 1
2388: oGetParam 1
2390: oPushResult
2391: oGetLocal 1
2393: oAssign
2394: oJumpForward 2399
2396: Choice Lookup Table
           1   2369
2399: oGetAddrLocal 2
2401: oPushResult
2402: oSetResult 0
2404: oAssign
2405: oGetAddrLocal 2
2407: oPushResult
2408: oCall 2457
2410: oPop 1
2412: oTypeSNodeType
2413: oChoice 2426
2415: oJumpForward 2433
2417: oGetAddrLocal 2
2419: oPushResult
2420: oCall 1743
2422: oPop 1
2424: oJumpForward 2433
2426: Choice Lookup Table
          19   2417
          20   2415
2431: oError 8
2433: oEmit 47
2435: oGetLocal 2
2437: oPushResult
2438: oEmitLabel
2439: oPop 1
2441: oGetLocal 1
2443: oPushResult
2444: oEmitLabel
2445: oPop 1
2447: oJumpForward 2454
2449: Choice Lookup Table
          52   2336
2452: oJumpForward 2456
2454: oJumpBack 2334
2456: oReturn
2457: oLocalSpace 1
2459: oInputChoice 2513
2461: oGetAddrLocal 1
2463: oPushResult
2464: oSetResult 0
2466: oAssign
2467: oGetAddrLocal 1
2469: oPushResult
2470: oCall 2457
2472: oPop 1
2474: oTypeSNodeType
2475: oChoice 2504
2477: oGetParam 1
2479: oPushResult
2480: oLabelNew
2481: oAssign
2482: oEmit 43
2484: oGetFromParam 1
2486: oPushResult
2487: oEmitLabel
2488: oPop 1
2490: oEmit 46
2492: oGetLocal 1
2494: oPushResult
2495: oEmitLabel
2496: oPop 1
2498: oJumpForward 2511
2500: oEmit 29
2502: oJumpForward 2511
2504: Choice Lookup Table
          19   2500
          20   2477
2509: oError 8
2511: oJumpForward 2523
2513: Choice Lookup Table
          54   2461
2516: oGetParam 1
2518: oPushResult
2519: oCall 2524
2521: oPop 1
2523: oReturn
2524: oLocalSpace 0
2526: oGetParam 1
2528: oPushResult
2529: oCall 2575
2531: oPop 1
2533: oInputChoice 2565
2535: oCall 5011
2537: oGetParam 1
2539: oPushResult
2540: oCall 2575
2542: oPop 1
2544: oCall 5025
2546: oEmit 26
2548: oJumpForward 2572
2550: oCall 5011
2552: oGetParam 1
2554: oPushResult
2555: oCall 2575
2557: oPop 1
2559: oCall 5025
2561: oEmit 27
2563: oJumpForward 2572
2565: Choice Lookup Table
          24   2550
          23   2535
2570: oJumpForward 2574
2572: oJumpBack 2533
2574: oReturn
2575: oLocalSpace 0
2577: oGetParam 1
2579: oPushResult
2580: oCall 2626
2582: oPop 1
2584: oInputChoice 2616
2586: oCall 5011
2588: oGetParam 1
2590: oPushResult
2591: oCall 2626
2593: oPop 1
2595: oCall 5025
2597: oEmit 23
2599: oJumpForward 2623
2601: oCall 5011
2603: oGetParam 1
2605: oPushResult
2606: oCall 2626
2608: oPop 1
2610: oCall 5025
2612: oEmit 24
2614: oJumpForward 2623
2616: Choice Lookup Table
          22   2601
          21   2586
2621: oJumpForward 2625
2623: oJumpBack 2584
2625: oReturn
2626: oLocalSpace 0
2628: oInputChoice 2654
2630: oGetParam 1
2632: oPushResult
2633: oCall 2667
2635: oPop 1
2637: oCall 5025
2639: oJumpForward 2666
2641: oGetParam 1
2643: oPushResult
2644: oCall 2667
2646: oPop 1
2648: oCall 5025
2650: oEmit 28
2652: oJumpForward 2666
2654: Choice Lookup Table
          24   2641
          23   2630
2659: oGetParam 1
2661: oPushResult
2662: oCall 2667
2664: oPop 1
2666: oReturn
2667: oLocalSpace 5
2669: oInputChoice 2847
2671: oEmit 9
2673: TOKEN_VALUE
2674: oPushResult
2675: oEmitInt
2676: oPop 1
2678: oGetGlobal 3
2680: oPushResult
2681: oTypeSPush
2682: oPop 1
2684: oJumpForward 2866
2686: oGetParam 1
2688: oPushResult
2689: oCall 1774
2691: oPop 1
2693: oInput 14
2695: oJumpForward 2866
2697: oStringAllocLit
2698: oEmit 10
2700: oValueTop
2701: oPushResult
2702: oEmitInt
2703: oPop 1
2705: oValuePop
2706: oGetGlobal 7
2708: oPushResult
2709: oTypeSPush
2710: oPop 1
2712: oJumpForward 2866
2714: oGetAddrLocal 1
2716: oPushResult
2717: oScopeFindRequire
2718: oAssign
2719: oGetLocal 1
2721: oPushResult
2722: oNodeType
2723: oPop 1
2725: oChoice 2787
2727: oGetLocal 1
2729: oPushResult
2730: oCall 3589
2732: oPop 1
2734: oJumpForward 2806
2736: oGetAddrLocal 2
2738: oPushResult
2739: oGetLocal 1
2741: oPushResult
2742: oSetResult 5
2744: oPushResult
2745: oNodeGet
2746: oPop 2
2748: oAssign
2749: oGetLocal 2
2751: oPushResult
2752: oTypeSPush
2753: oPop 1
2755: oTypeSNodeType
2756: oChoice 2769
2758: oEmit 9
2760: oGetLocal 1
2762: oPushResult
2763: oCall 5262
2765: oPop 1
2767: oJumpForward 2776
2769: Choice Lookup Table
          19   2758
          18   2758
2774: oError 16
2776: oJumpForward 2806
2778: oGetLocal 1
2780: oPushResult
2781: oCall 2867
2783: oPop 1
2785: oJumpForward 2806
2787: Choice Lookup Table
          15   2778
          13   2778
          12   2778
           9   2736
           8   2727
2798: oError 6
2800: oGetGlobal 3
2802: oPushResult
2803: oTypeSPush
2804: oPop 1
2806: oJumpForward 2866
2808: oInput 0
2810: oGetAddrLocal 3
2812: oPushResult
2813: oScopeFindRequire
2814: oAssign
2815: oGetLocal 3
2817: oPushResult
2818: oCall 4304
2820: oPop 1
2822: oGetAddrLocal 4
2824: oPushResult
2825: oTypeSTop
2826: oAssign
2827: oTypeSPop
2828: oGetAddrLocal 5
2830: oPushResult
2831: oGetLocal 4
2833: oPushResult
2834: oCall 5127
2836: oPop 1
2838: oAssign
2839: oGetLocal 5
2841: oPushResult
2842: oTypeSPush
2843: oPop 1
2845: oJumpForward 2866
2847: Choice Lookup Table
          18   2808
           0   2714
           2   2697
          13   2686
           1   2671
2858: oError 6
2860: oGetGlobal 3
2862: oPushResult
2863: oTypeSPush
2864: oPop 1
2866: oReturn
2867: oLocalSpace 1
2869: oGetAddrLocal 1
2871: oPushResult
2872: oGetParam 1
2874: oPushResult
2875: oSetResult 5
2877: oPushResult
2878: oNodeGet
2879: oPop 2
2881: oAssign
2882: oGetLocal 1
2884: oPushResult
2885: oTypeSPush
2886: oPop 1
2888: oTypeSNodeType
2889: oChoice 3154
2891: oGetParam 1
2893: oPushResult
2894: oNodeType
2895: oPop 1
2897: oChoice 2959
2899: oEmit 0
2901: oGetParam 1
2903: oPushResult
2904: oCall 5262
2906: oPop 1
2908: oJumpForward 2967
2910: oEmit 3
2912: oGetParam 1
2914: oPushResult
2915: oCall 5262
2917: oPop 1
2919: oJumpForward 2967
2921: oGetParam 1
2923: oPushResult
2924: oSetResult 12
2926: oPushResult
2927: oNodeGetBoolean
2928: oPop 2
2930: oChoice 2945
2932: oEmit 8
2934: oGetParam 1
2936: oPushResult
2937: oCall 5262
2939: oPop 1
2941: oEmit 14
2943: oJumpForward 2957
2945: Choice Lookup Table
           1   2932
2948: oEmit 6
2950: oGetParam 1
2952: oPushResult
2953: oCall 5262
2955: oPop 1
2957: oJumpForward 2967
2959: Choice Lookup Table
          15   2921
          13   2910
          12   2899
2966: oEndChoice
2967: oJumpForward 3245
2969: oGetParam 1
2971: oPushResult
2972: oNodeType
2973: oPop 1
2975: oChoice 3037
2977: oEmit 1
2979: oGetParam 1
2981: oPushResult
2982: oCall 5262
2984: oPop 1
2986: oJumpForward 3045
2988: oEmit 4
2990: oGetParam 1
2992: oPushResult
2993: oCall 5262
2995: oPop 1
2997: oJumpForward 3045
2999: oGetParam 1
3001: oPushResult
3002: oSetResult 12
3004: oPushResult
3005: oNodeGetBoolean
3006: oPop 2
3008: oChoice 3023
3010: oEmit 8
3012: oGetParam 1
3014: oPushResult
3015: oCall 5262
3017: oPop 1
3019: oEmit 15
3021: oJumpForward 3035
3023: Choice Lookup Table
           1   3010
3026: oEmit 7
3028: oGetParam 1
3030: oPushResult
3031: oCall 5262
3033: oPop 1
3035: oJumpForward 3045
3037: Choice Lookup Table
          15   2999
          13   2988
          12   2977
3044: oEndChoice
3045: oJumpForward 3245
3047: oError 16
3049: oJumpForward 3245
3051: oGetParam 1
3053: oPushResult
3054: oNodeType
3055: oPop 1
3057: oChoice 3119
3059: oEmit 2
3061: oGetParam 1
3063: oPushResult
3064: oCall 5262
3066: oPop 1
3068: oJumpForward 3127
3070: oEmit 5
3072: oGetParam 1
3074: oPushResult
3075: oCall 5262
3077: oPop 1
3079: oJumpForward 3127
3081: oGetParam 1
3083: oPushResult
3084: oSetResult 12
3086: oPushResult
3087: oNodeGetBoolean
3088: oPop 2
3090: oChoice 3105
3092: oEmit 8
3094: oGetParam 1
3096: oPushResult
3097: oCall 5262
3099: oPop 1
3101: oEmit 16
3103: oJumpForward 3117
3105: Choice Lookup Table
           1   3092
3108: oEmit 8
3110: oGetParam 1
3112: oPushResult
3113: oCall 5262
3115: oPop 1
3117: oJumpForward 3127
3119: Choice Lookup Table
          15   3081
          13   3070
          12   3059
3126: oEndChoice
3127: oInputChoice 3149
3129: oTypeSPop
3130: oGetLocal 1
3132: oPushResult
3133: oSetResult 14
3135: oPushResult
3136: oNodeGet
3137: oPop 2
3139: oPushResult
3140: oTypeSPush
3141: oPop 1
3143: oCall 3281
3145: oCall 3246
3147: oJumpForward 3152
3149: Choice Lookup Table
          17   3129
3152: oJumpForward 3245
3154: Choice Lookup Table
          23   3051
          17   3047
          22   3047
          21   3047
          19   2969
          18   2891
3167: oGetParam 1
3169: oPushResult
3170: oNodeType
3171: oPop 1
3173: oChoice 3233
3175: oEmit 10
3177: oGetParam 1
3179: oPushResult
3180: oCall 5262
3182: oPop 1
3184: oJumpForward 3241
3186: oEmit 11
3188: oGetParam 1
3190: oPushResult
3191: oCall 5262
3193: oPop 1
3195: oJumpForward 3241
3197: oGetParam 1
3199: oPushResult
3200: oSetResult 12
3202: oPushResult
3203: oNodeGetBoolean
3204: oPop 2
3206: oChoice 3219
3208: oEmit 8
3210: oGetParam 1
3212: oPushResult
3213: oCall 5262
3215: oPop 1
3217: oJumpForward 3231
3219: Choice Lookup Table
           1   3208
3222: oEmit 12
3224: oGetParam 1
3226: oPushResult
3227: oCall 5262
3229: oPop 1
3231: oJumpForward 3241
3233: Choice Lookup Table
          15   3197
          13   3186
          12   3175
3240: oEndChoice
3241: oCall 3281
3243: oCall 3246
3245: oReturn
3246: oLocalSpace 0
3248: oTypeSNodeType
3249: oChoice 3267
3251: oEmit 14
3253: oJumpForward 3280
3255: oEmit 15
3257: oJumpForward 3280
3259: oError 16
3261: oJumpForward 3280
3263: oEmit 16
3265: oJumpForward 3280
3267: Choice Lookup Table
          23   3263
          17   3259
          22   3259
          21   3259
          19   3255
          18   3251
3280: oReturn
3281: oLocalSpace 0
3283: oInputChoice 3297
3285: oCall 3309
3287: oJumpForward 3306
3289: oCall 3452
3291: oJumpForward 3306
3293: oCall 3550
3295: oJumpForward 3306
3297: Choice Lookup Table
          17   3293
          19   3289
          15   3285
3304: oJumpForward 3308
3306: oJumpBack 3283
3308: oReturn
3309: oLocalSpace 3
3311: oTypeSNodeType
3312: oChoice 3316
3314: oJumpForward 3321
3316: Choice Lookup Table
          24   3314
3319: oError 10
3321: oTypeSNodeType
3322: oChoice 3326
3324: oJumpForward 3331
3326: Choice Lookup Table
          24   3324
3329: oError 13
3331: oGetAddrLocal 1
3333: oPushResult
3334: oTypeSTop
3335: oPushResult
3336: oSetResult 15
3338: oPushResult
3339: oNodeGet
3340: oPop 2
3342: oPushResult
3343: oCall 5211
3345: oPop 1
3347: oAssign
3348: oGetAddrLocal 2
3350: oPushResult
3351: oTypeSTop
3352: oPushResult
3353: oSetResult 14
3355: oPushResult
3356: oNodeGet
3357: oPop 2
3359: oAssign
3360: oTypeSPop
3361: oGetLocal 2
3363: oPushResult
3364: oTypeSPush
3365: oPop 1
3367: oCall 1613
3369: oCall 5011
3371: oGetLocal 1
3373: oPushResult
3374: equal_zero
3375: oPop 1
3377: oChoice 3391
3379: oEmit 9
3381: oGetLocal 1
3383: oPushResult
3384: oEmitInt
3385: oPop 1
3387: oEmit 27
3389: oJumpForward 3394
3391: Choice Lookup Table
           0   3379
3394: oGetAddrLocal 3
3396: oPushResult
3397: oGetLocal 2
3399: oPushResult
3400: oSetResult 2
3402: oPushResult
3403: oNodeGetInt
3404: oPop 2
3406: oAssign
3407: oGetLocal 3
3409: oPushResult
3410: oSetResult 1
3412: oPushResult
3413: equal
3414: oPop 2
3416: oChoice 3430
3418: oEmit 9
3420: oGetLocal 3
3422: oPushResult
3423: oEmitInt
3424: oPop 1
3426: oEmit 23
3428: oJumpForward 3433
3430: Choice Lookup Table
           0   3418
3433: oEmit 25
3435: oInputChoice 3443
3437: oJumpForward 3451
3439: oJumpForward 3449
3441: oJumpForward 3449
3443: Choice Lookup Table
          12   3441
          16   3437
3448: oEndChoice
3449: oJumpBack 3321
3451: oReturn
3452: oLocalSpace 2
3454: oTypeSNodeType
3455: oChoice 3459
3457: oJumpForward 3464
3459: Choice Lookup Table
          26   3457
3462: oError 11
3464: oTypeSTop
3465: oPushResult
3466: oSetResult 18
3468: oPushResult
3469: oNodeGet
3470: oPop 2
3472: oPushResult
3473: oScopeEnter
3474: oPop 1
3476: oInput 0
3478: oGetAddrLocal 1
3480: oPushResult
3481: oScopeFindRequire
3482: oAssign
3483: oGetLocal 1
3485: oPushResult
3486: oNodeType
3487: oPop 1
3489: oChoice 3493
3491: oJumpForward 3498
3493: Choice Lookup Table
          14   3491
3496: oError 12
3498: oScopeEnd
3499: oGetAddrLocal 2
3501: oPushResult
3502: oGetLocal 1
3504: oPushResult
3505: oSetResult 6
3507: oPushResult
3508: oNodeGetInt
3509: oPop 2
3511: oAssign
3512: oGetLocal 2
3514: oPushResult
3515: equal_zero
3516: oPop 1
3518: oChoice 3532
3520: oEmit 9
3522: oGetLocal 2
3524: oPushResult
3525: oEmitInt
3526: oPop 1
3528: oEmit 25
3530: oJumpForward 3535
3532: Choice Lookup Table
           0   3520
3535: oTypeSPop
3536: oGetLocal 1
3538: oPushResult
3539: oSetResult 5
3541: oPushResult
3542: oNodeGet
3543: oPop 2
3545: oPushResult
3546: oTypeSPush
3547: oPop 1
3549: oReturn
3550: oLocalSpace 1
3552: oTypeSNodeType
3553: oChoice 3557
3555: oJumpForward 3562
3557: Choice Lookup Table
          23   3555
3560: oError 9
3562: oEmit 16
3564: oGetAddrLocal 1
3566: oPushResult
3567: oTypeSTop
3568: oAssign
3569: oTypeSPop
3570: oGetLocal 1
3572: oPushResult
3573: oSetResult 14
3575: oPushResult
3576: oNodeGet
3577: oPop 2
3579: oPushResult
3580: oTypeSPush
3581: oPop 1
3583: oReturn
3584: oLocalSpace 0
3586: oCall 4985
3588: oReturn
3589: oLocalSpace 8
3591: oGetAddrLocal 3
3593: oPushResult
3594: oGetParam 1
3596: oPushResult
3597: oNodeType
3598: oPop 1
3600: oPushResult
3601: oSetResult 8
3603: oPushResult
3604: equal_node_type
3605: oPop 2
3607: oAssign
3608: oGetLocal 3
3610: oChoice 3637
3612: oGetAddrLocal 1
3614: oPushResult
3615: oGetParam 1
3617: oPushResult
3618: oSetResult 5
3620: oPushResult
3621: oNodeGet
3622: oPop 2
3624: oAssign
3625: oGetAddrLocal 2
3627: oPushResult
3628: oGetLocal 1
3630: oPushResult
3631: oScopeAllocType
3632: oPop 1
3634: oAssign
3635: oJumpForward 3640
3637: Choice Lookup Table
           1   3612
3640: oGetAddrLocal 4
3642: oPushResult
3643: oGetParam 1
3645: oPushResult
3646: oSetResult 8
3648: oPushResult
3649: oNodeGet
3650: oPop 2
3652: oAssign
3653: oGetAddrLocal 5
3655: oPushResult
3656: oGetLocal 4
3658: oPushResult
3659: oSetResult 2
3661: oPushResult
3662: oNodeGetInt
3663: oPop 2
3665: oAssign
3666: oEmit 38
3668: oGetLocal 5
3670: oPushResult
3671: oEmitInt
3672: oPop 1
3674: oGetAddrLocal 6
3676: oPushResult
3677: oGetLocal 4
3679: oPushResult
3680: oSetResult 1
3682: oPushResult
3683: oNodeGet
3684: oPop 2
3686: oAssign
3687: oInputChoice 3856
3689: oGetLocal 6
3691: oPushResult
3692: oNodeNull
3693: oPop 1
3695: oChoice 3701
3697: oJumpForward 3852
3699: oJumpForward 3704
3701: Choice Lookup Table
           1   3697
3704: oGetAddrLocal 7
3706: oPushResult
3707: oGetLocal 6
3709: oPushResult
3710: oSetResult 6
3712: oPushResult
3713: oNodeGetInt
3714: oPop 2
3716: oAssign
3717: oEmit 13
3719: oGetLocal 7
3721: oPushResult
3722: oEmitInt
3723: oPop 1
3725: oGetLocal 6
3727: oPushResult
3728: oSetResult 5
3730: oPushResult
3731: oNodeGet
3732: oPop 2
3734: oPushResult
3735: oTypeSPush
3736: oPop 1
3738: oGetLocal 6
3740: oPushResult
3741: oSetResult 12
3743: oPushResult
3744: oNodeGetBoolean
3745: oPop 2
3747: oChoice 3815
3749: oCall 4268
3751: oCall 4985
3753: oEmit 19
3755: oJumpForward 3821
3757: oCall 1613
3759: oCall 3584
3761: oTypeSNodeType
3762: oChoice 3780
3764: oEmit 17
3766: oJumpForward 3813
3768: oEmit 18
3770: oJumpForward 3813
3772: oError 16
3774: oJumpForward 3813
3776: oEmit 19
3778: oJumpForward 3813
3780: Choice Lookup Table
          23   3776
          17   3772
          22   3772
          21   3772
          19   3768
          18   3764
3793: oGetAddrLocal 8
3795: oPushResult
3796: oTypeSTop
3797: oPushResult
3798: oSetResult 2
3800: oPushResult
3801: oNodeGetInt
3802: oPop 2
3804: oAssign
3805: oEmit 20
3807: oGetLocal 8
3809: oPushResult
3810: oEmitInt
3811: oPop 1
3813: oJumpForward 3821
3815: Choice Lookup Table
           0   3757
           1   3749
3820: oEndChoice
3821: oTypeSPop
3822: oGetAddrLocal 6
3824: oPushResult
3825: oNodeNext
3826: oPop 1
3828: oGetLocal 6
3830: oPushResult
3831: oNodeNull
3832: oPop 1
3834: oChoice 3842
3836: oJumpForward 3852
3838: oJumpForward 3848
3840: oJumpForward 3848
3842: Choice Lookup Table
           0   3840
           1   3836
3847: oEndChoice
3848: oInput 12
3850: oJumpBack 3689
3852: oInput 14
3854: oJumpForward 3859
3856: Choice Lookup Table
          13   3689
3859: oGetLocal 6
3861: oPushResult
3862: oNodeNull
3863: oPop 1
3865: oChoice 3871
3867: oError 15
3869: oJumpForward 3874
3871: Choice Lookup Table
           0   3867
3874: oGetLocal 3
3876: oChoice 3905
3878: oEmit 13
3880: oGetParam 1
3882: oPushResult
3883: oSetResult 11
3885: oPushResult
3886: oNodeGetInt
3887: oPop 2
3889: oPushResult
3890: oEmitInt
3891: oPop 1
3893: oEmit 11
3895: oGetLocal 2
3897: oPushResult
3898: oEmitInt
3899: oPop 1
3901: oEmit 19
3903: oJumpForward 3908
3905: Choice Lookup Table
           1   3878
3908: oEmit 40
3910: oGetParam 1
3912: oPushResult
3913: oCall 5262
3915: oPop 1
3917: oGetLocal 3
3919: oChoice 3939
3921: oGetLocal 1
3923: oPushResult
3924: oTypeSPush
3925: oPop 1
3927: oEmit 11
3929: oGetLocal 2
3931: oPushResult
3932: oEmitInt
3933: oPop 1
3935: oCall 3246
3937: oJumpForward 3942
3939: Choice Lookup Table
           1   3921
3942: oEmit 39
3944: oGetLocal 5
3946: oPushResult
3947: oEmitInt
3948: oPop 1
3950: oReturn
3951: oLocalSpace 0
3953: oInputChoice 4003
3955: oCall 4905
3957: oJumpForward 4028
3959: oCall 4912
3961: oJumpForward 4028
3963: oCall 4979
3965: oJumpForward 4028
3967: oCall 4982
3969: oJumpForward 4028
3971: oCall 4445
3973: oJumpForward 4028
3975: oCall 4765
3977: oJumpForward 4028
3979: oCall 4511
3981: oJumpForward 4028
3983: oCall 4685
3985: oJumpForward 4028
3987: oCall 4850
3989: oJumpForward 4028
3991: oCall 4818
3993: oJumpForward 4028
3995: oCall 4882
3997: oJumpForward 4028
3999: oCall 4029
4001: oJumpForward 4028
4003: Choice Lookup Table
           0   3999
          33   3995
          49   3991
          50   3987
          47   3983
          42   3979
          46   3975
          39   3971
          58   3967
          57   3963
          56   3959
          55   3955
4028: oReturn
4029: oLocalSpace 1
4031: oGetAddrLocal 1
4033: oPushResult
4034: oScopeFindRequire
4035: oAssign
4036: oGetLocal 1
4038: oPushResult
4039: oNodeType
4040: oPop 1
4042: oChoice 4071
4044: oGetLocal 1
4046: oPushResult
4047: oCall 3589
4049: oPop 1
4051: oJumpForward 4084
4053: oGetLocal 1
4055: oPushResult
4056: oCall 4085
4058: oPop 1
4060: oJumpForward 4084
4062: oGetLocal 1
4064: oPushResult
4065: oCall 4154
4067: oPop 1
4069: oJumpForward 4084
4071: Choice Lookup Table
           8   4062
          15   4053
          13   4053
          12   4053
           7   4044
4082: oError 0
4084: oReturn
4085: oLocalSpace 1
4087: oGetParam 1
4089: oPushResult
4090: oCall 4304
4092: oPop 1
4094: oInput 3
4096: oCall 1613
4098: oCall 4985
4100: oTypeSNodeType
4101: oChoice 4119
4103: oEmit 17
4105: oJumpForward 4152
4107: oEmit 18
4109: oJumpForward 4152
4111: oError 16
4113: oJumpForward 4152
4115: oEmit 19
4117: oJumpForward 4152
4119: Choice Lookup Table
          23   4115
          17   4111
          22   4111
          21   4111
          19   4107
          18   4103
4132: oGetAddrLocal 1
4134: oPushResult
4135: oTypeSTop
4136: oPushResult
4137: oSetResult 2
4139: oPushResult
4140: oNodeGetInt
4141: oPop 2
4143: oAssign
4144: oEmit 20
4146: oGetLocal 1
4148: oPushResult
4149: oEmitInt
4150: oPop 1
4152: oTypeSPop
4153: oReturn
4154: oLocalSpace 1
4156: oGetParam 1
4158: oPushResult
4159: oSetResult 9
4161: oPushResult
4162: oNodeGet
4163: oPop 2
4165: oPushResult
4166: oScopeCurrent
4167: oPushResult
4168: oNodeEqual
4169: oPop 2
4171: oChoice 4177
4173: oError 20
4175: oJumpForward 4180
4177: Choice Lookup Table
           0   4173
4180: oEmit 8
4182: oGetParam 1
4184: oPushResult
4185: oSetResult 11
4187: oPushResult
4188: oNodeGetInt
4189: oPop 2
4191: oPushResult
4192: oEmitInt
4193: oPop 1
4195: oGetParam 1
4197: oPushResult
4198: oSetResult 5
4200: oPushResult
4201: oNodeGet
4202: oPop 2
4204: oPushResult
4205: oTypeSPush
4206: oPop 1
4208: oInput 3
4210: oCall 1613
4212: oCall 4985
4214: oTypeSNodeType
4215: oChoice 4233
4217: oEmit 17
4219: oJumpForward 4266
4221: oEmit 18
4223: oJumpForward 4266
4225: oError 16
4227: oJumpForward 4266
4229: oEmit 19
4231: oJumpForward 4266
4233: Choice Lookup Table
          23   4229
          17   4225
          22   4225
          21   4225
          19   4221
          18   4217
4246: oGetAddrLocal 1
4248: oPushResult
4249: oTypeSTop
4250: oPushResult
4251: oSetResult 2
4253: oPushResult
4254: oNodeGetInt
4255: oPop 2
4257: oAssign
4258: oEmit 20
4260: oGetLocal 1
4262: oPushResult
4263: oEmitInt
4264: oPop 1
4266: oTypeSPop
4267: oReturn
4268: oLocalSpace 1
4270: oInput 0
4272: oGetAddrLocal 1
4274: oPushResult
4275: oScopeFindRequire
4276: oAssign
4277: oGetLocal 1
4279: oPushResult
4280: oNodeType
4281: oPop 1
4283: oChoice 4287
4285: oJumpForward 4296
4287: Choice Lookup Table
          15   4285
          13   4285
          12   4285
4294: oError 4
4296: oGetLocal 1
4298: oPushResult
4299: oCall 4304
4301: oPop 1
4303: oReturn
4304: oLocalSpace 0
4306: oGetParam 1
4308: oPushResult
4309: oNodeType
4310: oPop 1
4312: oChoice 4372
4314: oEmit 10
4316: oGetParam 1
4318: oPushResult
4319: oCall 5262
4321: oPop 1
4323: oJumpForward 4381
4325: oEmit 11
4327: oGetParam 1
4329: oPushResult
4330: oCall 5262
4332: oPop 1
4334: oJumpForward 4381
4336: oGetParam 1
4338: oPushResult
4339: oSetResult 12
4341: oPushResult
4342: oNodeGetBoolean
4343: oPop 2
4345: oChoice 4358
4347: oEmit 8
4349: oGetParam 1
4351: oPushResult
4352: oCall 5262
4354: oPop 1
4356: oJumpForward 4370
4358: Choice Lookup Table
           1   4347
4361: oEmit 12
4363: oGetParam 1
4365: oPushResult
4366: oCall 5262
4368: oPop 1
4370: oJumpForward 4381
4372: Choice Lookup Table
          15   4336
          13   4325
          12   4314
4379: oError 4
4381: oGetParam 1
4383: oPushResult
4384: oSetResult 5
4386: oPushResult
4387: oNodeGet
4388: oPop 2
4390: oPushResult
4391: oTypeSPush
4392: oPop 1
4394: oCall 3281
4396: oReturn
4397: oLocalSpace 0
4399: oGetParam 1
4401: oPushResult
4402: oCall 4304
4404: oPop 1
4406: oCall 5011
4408: oGetParam 1
4410: oPushResult
4411: oCall 2867
4413: oPop 1
4415: oTypeSPop
4416: oEmit 21
4418: oEmit 17
4420: oReturn
4421: oLocalSpace 0
4423: oGetParam 1
4425: oPushResult
4426: oCall 4304
4428: oPop 1
4430: oCall 5011
4432: oGetParam 1
4434: oPushResult
4435: oCall 2867
4437: oPop 1
4439: oTypeSPop
4440: oEmit 22
4442: oEmit 17
4444: oReturn
4445: oLocalSpace 2
4447: oGetAddrLocal 1
4449: oPushResult
4450: oSetResult 0
4452: oAssign
4453: oGetAddrLocal 1
4455: oPushResult
4456: oCall 1636
4458: oPop 1
4460: oInput 40
4462: oCall 3951
4464: oInputChoice 4499
4466: oGetAddrLocal 2
4468: oPushResult
4469: oLabelNew
4470: oAssign
4471: oEmit 43
4473: oGetLocal 2
4475: oPushResult
4476: oEmitLabel
4477: oPop 1
4479: oEmit 46
4481: oGetLocal 1
4483: oPushResult
4484: oEmitLabel
4485: oPop 1
4487: oCall 3951
4489: oEmit 46
4491: oGetLocal 2
4493: oPushResult
4494: oEmitLabel
4495: oPop 1
4497: oJumpForward 4510
4499: Choice Lookup Table
          41   4466
4502: oEmit 46
4504: oGetLocal 1
4506: oPushResult
4507: oEmitLabel
4508: oPop 1
4510: oReturn
4511: oLocalSpace 4
4513: oInput 0
4515: oGetAddrLocal 1
4517: oPushResult
4518: oScopeFindRequire
4519: oAssign
4520: oGetLocal 1
4522: oPushResult
4523: oCall 4304
4525: oPop 1
4527: oCall 5011
4529: oInput 3
4531: oCall 1613
4533: oCall 5011
4535: oEmit 17
4537: oGetAddrLocal 2
4539: oPushResult
4540: oLabelNew
4541: oAssign
4542: oGetAddrLocal 3
4544: oPushResult
4545: oLabelNew
4546: oAssign
4547: oEmit 43
4549: oGetLocal 3
4551: oPushResult
4552: oEmitLabel
4553: oPop 1
4555: oGetAddrLocal 4
4557: oPushResult
4558: oLabelNew
4559: oAssign
4560: oEmit 46
4562: oGetLocal 4
4564: oPushResult
4565: oEmitLabel
4566: oPop 1
4568: oInputChoice 4648
4570: oGetLocal 1
4572: oPushResult
4573: oCall 4397
4575: oPop 1
4577: oEmit 46
4579: oGetLocal 3
4581: oPushResult
4582: oEmitLabel
4583: oPop 1
4585: oGetLocal 1
4587: oPushResult
4588: oCall 2867
4590: oPop 1
4592: oTypeSPop
4593: oCall 1613
4595: oCall 5011
4597: oEmit 32
4599: oEmit 44
4601: oGetLocal 2
4603: oPushResult
4604: oEmitLabel
4605: oPop 1
4607: oJumpForward 4654
4609: oGetLocal 1
4611: oPushResult
4612: oCall 4421
4614: oPop 1
4616: oEmit 46
4618: oGetLocal 3
4620: oPushResult
4621: oEmitLabel
4622: oPop 1
4624: oGetLocal 1
4626: oPushResult
4627: oCall 2867
4629: oPop 1
4631: oTypeSPop
4632: oCall 1613
4634: oCall 5011
4636: oEmit 33
4638: oEmit 44
4640: oGetLocal 2
4642: oPushResult
4643: oEmitLabel
4644: oPop 1
4646: oJumpForward 4654
4648: Choice Lookup Table
          44   4609
          43   4570
4653: oEndChoice
4654: oGetLocal 4
4656: oPushResult
4657: oGetLocal 2
4659: oPushResult
4660: oLoopPush
4661: oPop 2
4663: oInput 45
4665: oCall 3951
4667: oEmit 43
4669: oGetLocal 4
4671: oPushResult
4672: oEmitLabel
4673: oPop 1
4675: oEmit 46
4677: oGetLocal 2
4679: oPushResult
4680: oEmitLabel
4681: oPop 1
4683: oLoopPop
4684: oReturn
4685: oLocalSpace 3
4687: oGetAddrLocal 1
4689: oPushResult
4690: oLabelNew
4691: oAssign
4692: oEmit 46
4694: oGetLocal 1
4696: oPushResult
4697: oEmitLabel
4698: oPop 1
4700: oGetAddrLocal 2
4702: oPushResult
4703: oLabelNew
4704: oAssign
4705: oGetLocal 1
4707: oPushResult
4708: oGetLocal 2
4710: oPushResult
4711: oLoopPush
4712: oPop 2
4714: oCall 3951
4716: oInputChoice 4747
4718: oCall 3951
4720: oJumpForward 4753
4722: oGetAddrLocal 3
4724: oPushResult
4725: oCall 1636
4727: oPop 1
4729: oEmit 47
4731: oGetLocal 3
4733: oPushResult
4734: oEmitLabel
4735: oPop 1
4737: oGetLocal 1
4739: oPushResult
4740: oEmitLabel
4741: oPop 1
4743: oJumpForward 4755
4745: oJumpForward 4753
4747: Choice Lookup Table
          48   4722
           4   4718
4752: oEndChoice
4753: oJumpBack 4716
4755: oEmit 46
4757: oGetLocal 2
4759: oPushResult
4760: oEmitLabel
4761: oPop 1
4763: oLoopPop
4764: oReturn
4765: oLocalSpace 2
4767: oGetAddrLocal 1
4769: oPushResult
4770: oLabelNew
4771: oAssign
4772: oEmit 46
4774: oGetLocal 1
4776: oPushResult
4777: oEmitLabel
4778: oPop 1
4780: oGetAddrLocal 2
4782: oPushResult
4783: oCall 1636
4785: oPop 1
4787: oGetLocal 1
4789: oPushResult
4790: oGetLocal 2
4792: oPushResult
4793: oLoopPush
4794: oPop 2
4796: oInput 45
4798: oCall 3951
4800: oEmit 43
4802: oGetLocal 1
4804: oPushResult
4805: oEmitLabel
4806: oPop 1
4808: oEmit 46
4810: oGetLocal 2
4812: oPushResult
4813: oEmitLabel
4814: oPop 1
4816: oLoopPop
4817: oReturn
4818: oLocalSpace 0
4820: oLoopContinueLabel
4821: oPushResult
4822: oSetResult 0
4824: oPushResult
4825: equal_label
4826: oPop 2
4828: oChoice 4843
4830: oError 18
4832: oJumpForward 4849
4834: oEmit 43
4836: oLoopContinueLabel
4837: oPushResult
4838: oEmitLabel
4839: oPop 1
4841: oJumpForward 4849
4843: Choice Lookup Table
           0   4834
           1   4830
4848: oEndChoice
4849: oReturn
4850: oLocalSpace 0
4852: oLoopBreakLabel
4853: oPushResult
4854: oSetResult 0
4856: oPushResult
4857: equal_label
4858: oPop 2
4860: oChoice 4875
4862: oError 18
4864: oJumpForward 4881
4866: oEmit 43
4868: oLoopBreakLabel
4869: oPushResult
4870: oEmitLabel
4871: oPop 1
4873: oJumpForward 4881
4875: Choice Lookup Table
           0   4866
           1   4862
4880: oEndChoice
4881: oReturn
4882: oLocalSpace 0
4884: oCall 3951
4886: oInputChoice 4896
4888: oCall 3951
4890: oJumpForward 4902
4892: oJumpForward 4904
4894: oJumpForward 4902
4896: Choice Lookup Table
          34   4892
           4   4888
4901: oEndChoice
4902: oJumpBack 4886
4904: oReturn
4905: oLocalSpace 0
4907: oCall 4912
4909: oEmit 52
4911: oReturn
4912: oLocalSpace 0
4914: oInputChoice 4975
4916: oCall 1613
4918: oTypeSNodeType
4919: oChoice 4941
4921: oEmit 48
4923: oJumpForward 4956
4925: oEmit 49
4927: oJumpForward 4956
4929: oEmit 50
4931: oJumpForward 4956
4933: oError 16
4935: oJumpForward 4956
4937: oEmit 51
4939: oJumpForward 4956
4941: Choice Lookup Table
          23   4937
          17   4933
          21   4933
          22   4929
          19   4925
          18   4921
4954: oError 17
4956: oTypeSPop
4957: oInputChoice 4965
4959: oJumpForward 4973
4961: oJumpForward 4971
4963: oJumpForward 4971
4965: Choice Lookup Table
          12   4963
          14   4959
4970: oEndChoice
4971: oJumpBack 4916
4973: oJumpForward 4978
4975: Choice Lookup Table
          13   4916
4978: oReturn
4979: oLocalSpace 0
4981: oReturn
4982: oLocalSpace 0
4984: oReturn
4985: oLocalSpace 1
4987: oGetAddrLocal 1
4989: oPushResult
4990: oTypeSNodeType
4991: oAssign
4992: oTypeSPop
4993: oGetLocal 1
4995: oPushResult
4996: oTypeSNodeType
4997: oPushResult
4998: equal_node_type
4999: oPop 2
5001: oChoice 5007
5003: oError 14
5005: oJumpForward 5010
5007: Choice Lookup Table
           0   5003
5010: oReturn
5011: oLocalSpace 0
5013: oTypeSNodeType
5014: oChoice 5018
5016: oJumpForward 5023
5018: Choice Lookup Table
          18   5016
5021: oError 7
5023: oTypeSPop
5024: oReturn
5025: oLocalSpace 0
5027: oTypeSNodeType
5028: oChoice 5032
5030: oJumpForward 5037
5032: Choice Lookup Table
          18   5030
5035: oError 7
5037: oReturn
5038: oLocalSpace 0
5040: oTypeSNodeType
5041: oChoice 5045
5043: oJumpForward 5050
5045: Choice Lookup Table
          19   5043
5048: oError 8
5050: oTypeSPop
5051: oReturn
5052: oLocalSpace 0
5054: oTypeSNodeType
5055: oChoice 5059
5057: oJumpForward 5064
5059: Choice Lookup Table
          19   5057
5062: oError 8
5064: oReturn
5065: oLocalSpace 1
5067: oGetAddrLocal 1
5069: oPushResult
5070: oGetParam 2
5072: oPushResult
5073: oNodeNew
5074: oPop 1
5076: oAssign
5077: oGetLocal 1
5079: oPushResult
5080: oSetResult 2
5082: oPushResult
5083: oGetParam 1
5085: oPushResult
5086: oNodeSetInt
5087: oPop 3
5089: oGetLocal 1
5091: oPushResult
5092: oTypeAdd
5093: oPop 1
5095: oGetLocal 1
5097: oReturn
5098: oReturn
5099: oLocalSpace 1
5101: oGetAddrLocal 1
5103: oPushResult
5104: oGetParam 3
5106: oPushResult
5107: oNodeNew
5108: oPop 1
5110: oAssign
5111: oGetLocal 1
5113: oPushResult
5114: oSetResult 4
5116: oPushResult
5117: oGetParam 1
5119: oPushResult
5120: oNodeSetInt
5121: oPop 3
5123: oGetLocal 1
5125: oReturn
5126: oReturn
5127: oLocalSpace 1
5129: oGetAddrLocal 1
5131: oPushResult
5132: oGetParam 1
5134: oPushResult
5135: oSetResult 13
5137: oPushResult
5138: oNodeGet
5139: oPop 2
5141: oAssign
5142: oGetLocal 1
5144: oPushResult
5145: oNodeNull
5146: oPop 1
5148: oChoice 5204
5150: oGetAddrLocal 1
5152: oPushResult
5153: oSetResult 23
5155: oPushResult
5156: oNodeNew
5157: oPop 1
5159: oAssign
5160: oGetLocal 1
5162: oPushResult
5163: oSetResult 14
5165: oPushResult
5166: oGetParam 1
5168: oPushResult
5169: oNodeSet
5170: oPop 3
5172: oGetLocal 1
5174: oPushResult
5175: oSetResult 2
5177: oPushResult
5178: oSetResult 8
5180: oPushResult
5181: oNodeSetInt
5182: oPop 3
5184: oGetLocal 1
5186: oPushResult
5187: oTypeAdd
5188: oPop 1
5190: oGetParam 1
5192: oPushResult
5193: oSetResult 13
5195: oPushResult
5196: oGetLocal 1
5198: oPushResult
5199: oNodeSet
5200: oPop 3
5202: oJumpForward 5207
5204: Choice Lookup Table
           1   5150
5207: oGetLocal 1
5209: oReturn
5210: oReturn
5211: oLocalSpace 0
5213: oGetParam 1
5215: oPushResult
5216: oNodeType
5217: oPop 1
5219: oChoice 5247
5221: oMININT
5222: oReturn
5223: oJumpForward 5261
5225: oSetResult 0
5227: oReturn
5228: oJumpForward 5261
5230: oSetResult 0
5232: oReturn
5233: oJumpForward 5261
5235: oGetParam 1
5237: oPushResult
5238: oSetResult 16
5240: oPushResult
5241: oNodeGetInt
5242: oPop 2
5244: oReturn
5245: oJumpForward 5261
5247: Choice Lookup Table
          25   5235
          21   5230
          19   5225
          18   5221
5256: oError 3
5258: oSetResult 0
5260: oReturn
5261: oReturn
5262: oLocalSpace 0
5264: oGetParam 1
5266: oPushResult
5267: oSetResult 6
5269: oPushResult
5270: oNodeGetInt
5271: oPop 2
5273: oPushResult
5274: oEmitInt
5275: oPop 1
5277: oReturn
5278: oLocalSpace 1
5280: oGetAddrGlobal 2
5282: oPushResult
5283: oSetResult 17
5285: oPushResult
5286: oSetResult 4
5288: oPushResult
5289: oCall 5065
5291: oPop 2
5293: oAssign
5294: oGetAddrGlobal 3
5296: oPushResult
5297: oSetResult 18
5299: oPushResult
5300: oSetResult 4
5302: oPushResult
5303: oCall 5065
5305: oPop 2
5307: oAssign
5308: oGetAddrGlobal 4
5310: oPushResult
5311: oSetResult 19
5313: oPushResult
5314: oSetResult 1
5316: oPushResult
5317: oCall 5065
5319: oPop 2
5321: oAssign
5322: oGetAddrGlobal 5
5324: oPushResult
5325: oSetResult 20
5327: oPushResult
5328: oSetResult 1
5330: oPushResult
5331: oCall 5065
5333: oPop 2
5335: oAssign
5336: oGetAddrGlobal 6
5338: oPushResult
5339: oSetResult 21
5341: oPushResult
5342: oSetResult 1
5344: oPushResult
5345: oCall 5065
5347: oPop 2
5349: oAssign
5350: oGetAddrGlobal 7
5352: oPushResult
5353: oSetResult 22
5355: oPushResult
5356: oSetResult 256
5358: oPushResult
5359: oCall 5065
5361: oPop 2
5363: oAssign
5364: oGetAddrLocal 1
5366: oPushResult
5367: oSetResult 10
5369: oPushResult
5370: oSetResult 5
5372: oPushResult
5373: oIdAdd_File
5374: oPushResult
5375: oCall 5099
5377: oPop 3
5379: oAssign
5380: oGetLocal 1
5382: oPushResult
5383: oSetResult 5
5385: oPushResult
5386: oGetGlobal 2
5388: oPushResult
5389: oNodeSet
5390: oPop 3
5392: oGetLocal 1
5394: oPushResult
5395: oScopeDeclare
5396: oPop 1
5398: oGetAddrLocal 1
5400: oPushResult
5401: oSetResult 10
5403: oPushResult
5404: oSetResult 5
5406: oPushResult
5407: oIdAdd_Integer
5408: oPushResult
5409: oCall 5099
5411: oPop 3
5413: oAssign
5414: oGetLocal 1
5416: oPushResult
5417: oSetResult 5
5419: oPushResult
5420: oGetGlobal 3
5422: oPushResult
5423: oNodeSet
5424: oPop 3
5426: oGetLocal 1
5428: oPushResult
5429: oScopeDeclare
5430: oPop 1
5432: oGetAddrLocal 1
5434: oPushResult
5435: oSetResult 10
5437: oPushResult
5438: oSetResult 5
5440: oPushResult
5441: oIdAdd_Boolean
5442: oPushResult
5443: oCall 5099
5445: oPop 3
5447: oAssign
5448: oGetLocal 1
5450: oPushResult
5451: oSetResult 5
5453: oPushResult
5454: oGetGlobal 4
5456: oPushResult
5457: oNodeSet
5458: oPop 3
5460: oGetLocal 1
5462: oPushResult
5463: oScopeDeclare
5464: oPop 1
5466: oGetAddrLocal 1
5468: oPushResult
5469: oSetResult 10
5471: oPushResult
5472: oSetResult 5
5474: oPushResult
5475: oIdAdd_Char
5476: oPushResult
5477: oCall 5099
5479: oPop 3
5481: oAssign
5482: oGetLocal 1
5484: oPushResult
5485: oSetResult 5
5487: oPushResult
5488: oGetGlobal 6
5490: oPushResult
5491: oNodeSet
5492: oPop 3
5494: oGetLocal 1
5496: oPushResult
5497: oScopeDeclare
5498: oPop 1
5500: oGetAddrLocal 1
5502: oPushResult
5503: oSetResult 10
5505: oPushResult
5506: oSetResult 5
5508: oPushResult
5509: oIdAdd_String
5510: oPushResult
5511: oCall 5099
5513: oPop 3
5515: oAssign
5516: oGetLocal 1
5518: oPushResult
5519: oSetResult 5
5521: oPushResult
5522: oGetGlobal 7
5524: oPushResult
5525: oNodeSet
5526: oPop 3
5528: oGetLocal 1
5530: oPushResult
5531: oScopeDeclare
5532: oPop 1
5534: oGetAddrLocal 1
5536: oPushResult
5537: oSetResult 9
5539: oPushResult
5540: oSetResult 4
5542: oPushResult
5543: oIdAdd_True
5544: oPushResult
5545: oCall 5099
5547: oPop 3
5549: oAssign
5550: oGetLocal 1
5552: oPushResult
5553: oSetResult 5
5555: oPushResult
5556: oGetGlobal 4
5558: oPushResult
5559: oNodeSet
5560: oPop 3
5562: oGetLocal 1
5564: oPushResult
5565: oSetResult 6
5567: oPushResult
5568: oSetResult 1
5570: oPushResult
5571: oNodeSetInt
5572: oPop 3
5574: oGetLocal 1
5576: oPushResult
5577: oScopeDeclare
5578: oPop 1
5580: oGetAddrLocal 1
5582: oPushResult
5583: oSetResult 9
5585: oPushResult
5586: oSetResult 4
5588: oPushResult
5589: oIdAdd_False
5590: oPushResult
5591: oCall 5099
5593: oPop 3
5595: oAssign
5596: oGetLocal 1
5598: oPushResult
5599: oSetResult 5
5601: oPushResult
5602: oGetGlobal 4
5604: oPushResult
5605: oNodeSet
5606: oPop 3
5608: oGetLocal 1
5610: oPushResult
5611: oSetResult 6
5613: oPushResult
5614: oSetResult 0
5616: oPushResult
5617: oNodeSetInt
5618: oPop 3
5620: oGetLocal 1
5622: oPushResult
5623: oScopeDeclare
5624: oPop 1
5626: oReturn
