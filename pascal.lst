   2: title: 'Pascal Compiler 1.1.5 -- Jan 01 ''90';
         
      %
      %  Pascal.ssl
      %
      %  Pascal Compiler for the Amiga, by Steve Rice.
      %
      %  HISTORY
      %    11Sep89   First version, framework of parser.
      %    18Sep89   Added some semantic mechanisms.
      %    21Sep89   Added simple type references; expressions generate code.
      %    22Sep89   Allocate variable addresses as they're declared.
      %    24Sep89   Added arrays, pointers.
      %    27Sep89   Added for statement.
      %    23Oct89   Fixed for statement, so CYCLE goes to next step.
      %    01Jan90   Added string literals
      %    09Sep22   I have returned.  Migrate symbol table to schema, to ease development.
      %    01Oct22   Language: Switch from cycle/exit (Mac Pascal extension) to continue/break (Borland).
      %
      %  NOTES
      %    -  The 'value' of a var symbol is its allocated address.
      %    -  References to vars of intrinsic types, and pointer types,
      %       pushes the value of the var on the expr stack.  Referenecs to
      %       vars of compound types (arrays, records...) pushes the address
      %       on the expr stack.
      %    -  Just as there is only one type table entry for a given (named) type,
      %       there is only one type table entry for a pointer to a named type.
      %       When a pointer type is declared, a field in the TT entry of the
      %       type pointed to will be set to indicate the TT entry of the pointer
      %       to that type (0 means none defined yet).  When evaluating the
      %       expression @x, the type in that field in the entry for the type of x
      %       will be used (unless it's 0, in which case a new TT entry will be
      %       created).
      %
      %
      %  MISSING
      %
      %    - procedure and function declarations may be nested within other procs/funcs!
      %      They are allowed to see locals within those parent scopes.
      %      Pass a hidden parameter to nested methods, to follow up to parent scopes as needed.
      %      Need a level counter at each scope, and uplevels count on reference to local/param.
      %      
      %    - Consider non-ISO extensions.  e.g. see "Units" e.g. from Turbo Pascal wikipedia page.
      %      Dynamic arrays.  Objects.  But, perhaps stick to my old goal, standard Pascal.
      %
      %    - variable initialization.
      %      The code should execute on entry to the scope.  I probably need multiple tcode streams,
      %      because there may be nested methods between the variables being initialized
      %      and the block statement of the scope.
      %
      %  PASCAL DOCS
      %      Here's some handy language material:
      %      https://www.freepascal.org/docs-html/ref/ref.html
      %      https://www.freepascal.org/docs-html/prog/prog.html
      %      https://en.wikipedia.org/wiki/Turbo_Pascal
      %      https://en.wikipedia.org/wiki/Pascal_(programming_language)#Standards
      %      http://www.standardpascaline.org/
      %
      
   2: input:
   2:    pIdent
   2:    pIntLit
   2:    pStrLit
   2:    pAssign       ':='
   2:    pSemiColon    ';'
   2:    pEqual        '='
   2:    pNotEqual     '<>'
   2:    pLess         '<'
   2:    pGreater      '>'
   2:    pLessEqual    '<='
   2:    pGreaterEqual '>='
   2:    pColon        ':'
   2:    pComma        ','
   2:    pLParen       '('
   2:    pRParen       ')'
   2:    pLSquare      '['
   2:    pRSquare      ']'
   2:    pCarat        '^'
   2:    pAt           '@'
   2:    pDot          '.'
   2:    pDotDot       '..'
   2:    pTimes        '*'
   2:    pDivide       '/'
   2:    pPlus         '+'
   2:    pMinus        '-'
   2:    pEof
   2:    pInvalid
      
      %  keywords  (built-in types 'integer', 'byte', 'char', etc, are not keywords,
      %             type constructors 'array', 'record', 'set' are keywords,
      %             pseudo-procedures 'writeln', 'readln' are keywords)
      %
      %             forward/external/name/cdecl appear in method modifiers, in fpc grammar.
      %             I'm making them keywords to simplify parsing, but could reconsider.
      
   2:    pProgram
   2:    pProcedure
   2:    pFunction
   2:    pConst
   2:    pType
   2:    pVar
   2:    pBegin
   2:    pEnd
   2:    pArray
   2:    pRecord
   2:    pSet
   2:    pOf
   2:    pIf
   2:    pThen
   2:    pElse
   2:    pFor
   2:    pTo
   2:    pDownto
   2:    pDo
   2:    pWhile
   2:    pRepeat
   2:    pUntil
   2:    pContinue
   2:    pBreak
   2:    pAnd
   2:    pOr
   2:    pNot
   2:    pWriteln
   2:    pWrite
   2:    pReadln
   2:    pRead
   2:    pForward
   2:    pExternal
   2:    pName
   2:    pCdecl
   2:    ;
      
      
   2: output:
      
      %  Instructions for a stack machine (all vars are 32-bit integers)
      
   2:    tPushGlobalI      % <ptr> - push int value read from ptr
   2:    tPushGlobalB      % <ptr> - push byte value read from ptr
   2:    tPushGlobalP      % <ptr> - push ptr value read from ptr
   2:    tPushLocalI       % <offset> - push int value read from local var
   2:    tPushLocalB       % <offset> - push byte value read from local var
   2:    tPushLocalP       % <offset> - push ptr value read from local var
   2:    tPushParamI       % <offset> - push int value read from local var
   2:    tPushParamB       % <offset> - push byte value read from local var
   2:    tPushParamP       % <offset> - push ptr value read from local var
      
   2:    tPushConstI       % <int> - push int value on stack (NOTE, used for BOOLEAN too)
   2:    tPushAddrGlobal   % <offset> - push ptr to global var (same as tPushConstP)
   2:    tPushAddrLocal    % <offset> - push ptr to local var
   2:    tPushAddrParam    % <offset> - push ptr to formal param (used by method to see its param)
   2:    tPushAddrActual   % <offset> - push ptr to actual param, in actuals space (used by caller)
   2:    tFetchI           % pop ptr from stack, and push int value it points to
   2:    tFetchB           %    "      "      "     "     byte  "   "    "
   2:    tFetchP           %    "      "      "     "     ptr   "   "    "   
   2:    tAssignI          % assign int value on top of stack to addr under it (pop both)
   2:    tAssignB          %   "    byte   "    "   "  "   "    "    "   "   "
   2:    tAssignP          %   "    ptr    "    "   "  "   "    "    "   "   "
   2:    tCopy             % <#bytes> - copy bytes.  tos=src, 2nd=dest (pop 2)
   2:    tIncI             % increment int value on top of expr stack
   2:    tDecI             % decrement int value on top of expr stack
   2:    tMultI            % multiply top two integers (replacing with result)
   2:    tDivI
   2:    tAddPI            % add ptr (2nd value) and int (top value), resulting in a ptr
   2:    tAddI
   2:    tSubI
   2:    tNegI             % top entry *= -1
   2:    tNot              % negate top boolean
   2:    tEqualI           % top two entries equal? (pop 2, push 1) (true=1)
   2:    tNotEqualI        %    NOTE, these all work for booleans too
   2:    tGreaterI         % 2nd entry greater than top entry? (pop 2, push answer)
   2:    tLessI  
   2:    tGreaterEqualI
   2:    tLessEqualI
   2:    tEqualP           % two two pointer values equal? (pop 2, push 1) (true=1)
   2:    tNotEqualP
   2:    tAllocActuals     % <#bytes> - make space on call stack for actual params (adjusting call stack sp)
   2:    tAllocActualsCdecl  % <#bytes> - starting a call to a cdecl method.  tcode still describes my own calling convention.
   2:    tFreeActuals      % <#bytes> - discard space on call stack allocated by tAllocActuals
   2:    tCall             % <label#>
   2:    tCallCdecl        % <label#> - call a method using native (C) calling convention. Only supported for extern labels.
   2:    tReturn
   2:    tEnter            % <#bytes> - start a stack frame on the call stack, reserving #bytes of local variable space
   2:    tJump             % <label#>
   2:    tJumpTrue         % <label#>  (pops top of stack, jumps if true)
   2:    tJumpFalse        % <label#>  (pops top of stack, jumps if false)
   2:    tLabel            % <label#> - define label# at the current address
   2:    tLabelAlias       % <label#> <aliasToLabel#> - defines label to be an alias of another label
   2:    tLabelExtern      % <label#> <offsetToStrLit> - defines label to mean an extern symbol, whose name is in global data
   2:    tWriteI           % for writeln : write integer on tos, pop
   2:    tWriteBool        %  "     "    : write TRUE/FALSE, pop
   2:    tWriteStr         %  "     "    : write string whose addr is on tos, pop
   2:    tWriteP           %  "     "    : write ptr var whose addr is on tos, pop
   2:    tWriteCR          %  "     "    : write cr
      
      %  Other:
      
   2:    tSpace            % emit a hole, to be patched later
   2:    ;
      
   2: error:
   2:    eBadStatement
   2:    eNotConst
   2:    eNotType
   2:    eNotOrdinalType
   2:    eNotVar
   2:    eNotIntVar
   2:    eNotValue
   2:    eNotInteger
   2:    eNotBoolean
   2:    eNotPointer
   2:    eNotArray
   2:    eNotRecord
   2:    eNotRecordField
   2:    eTooManySubscripts
   2:    eTypeMismatch
   2:    eMissingParameter
   2:    eNotImplemented
   2:    eNotAllowed
   2:    eNotInALoop
   2:    eRecordEmpty
   2:    eNotCurrentFunction
   2:    eAlreadyDefined
   2:    eOnlyOneVarCanBeInitialized
   2:    ;
      
   2: include 'pascal_schema.ssl'
      
      % Generated automatically by schema
      
   2: type node_type:
   2: 	nINVALID
   2: 	Object
   2: 	nScope
   2: 	nDeclaration
   2: 	nIdent
   2: 	nProgram
   2: 	nMethod
   2: 	nProc
   2: 	nFunc
   2: 	nConst
   2: 	nTypeDecl
   2: 	nVar
   2: 	nGlobalVar
   2: 	nLocalVar
   2: 	nRecordField
   2: 	nParam
   2: 	nType
   2: 	nFileType
   2: 	nIntegerType
   2: 	nBooleanType
   2: 	nBooleanCFType
   2: 	nCharType
   2: 	nStringType
   2: 	nPointerType
   2: 	nArrayType
   2: 	nSubrangeType
   2: 	nRecordType
   2: 	nEnumType
   2: 	nSetType
   2: 	;
      
   2: type node_attribute:
   2: 	qINVALID
   2: 	qDecls
   2: 	qSize
   2: 	qAllocDown
   2: 	qInitCode
   2: 	qIdent
   2: 	qType
   2: 	qValue
   2: 	qMainRoutineScope
   2: 	qParams
   2: 	qChildScope
   2: 	qBodyDefined
   2: 	qExternal
   2: 	qCdecl
   2: 	qCalled
   2: 	qOldParams
   2: 	qOldType
   2: 	qResultOffset
   2: 	qInOut
   2: 	qPointerType
   2: 	qBaseType
   2: 	qIndexType
   2: 	qLow
   2: 	qHigh
   2: 	qScope
   2: 	;
      
      
   2: type Node:     % A pointer to a node in the schema database (symbol database)
   2:    Null = 0
   2:    ;
      
   2: type NodeIter:   % An iterator over nodes in a list, in the schema database
   2:    NullIter = 0
   2:    ;
      
   2: type NodeVec:  % A pointer to a vector of Node.  See mechanism node_vec_mech
   2:    NullVec = 0
   2:    ;
      
   2: type boolean:
   2:    false    = 0
   2:    true     = 1;
      
   2: type kind:           % kind of identifier
   2:    kUndefined        % not yet added to symbol table
   2:    kProgram
   2:    kProc
   2:    kFunc
   2:    kConst
   2:    kType
   2:    kVar;
      
      % intrinsic types & type constructs
      
   2: type typ:
   2:    tyNone     = 0    % in ptrTyp field of TT, means no ptr to type defined
   2:    tyInteger
   2:    tyBoolean
   2:    tyChar
   2:    tyString
   2:    tyFile            % tyInteger..tyFile are scalars (types on their own)
   2:    tyPointer         % following are type constructor classes...
   2:    tyArray           %   (they are not type#'s)
   2:    tyRecord
   2:    tyParams          % like record; a collection of proc/func params
   2:    tySet;
      
   2: type Label:
   2:    labelNull = 0;
      
      % An output code stream.
   2: type Code:
   2:    codeNull = 0
   2:    codeDefault = 1
   2:    ;
      
      
      % Some general schema node operations.
      % node_type and node_attribute are defined in generated file pascal_schema.ssl included above.
      %
   2: mechanism node_mech:
   2:     oNodeNew (node_type) >> Node         % create new node
   2:     oNodeSet (Node, node_attribute, Node)   % set Node attribute of node
   2:     oNodeSetInt (Node, node_attribute, int) % set int attribute of node
   2:     oNodeSetBoolean (Node, node_attribute, boolean)
   2:     oNodeSetKind (Node, node_attribute, kind) % set attribute of node  *** MIGHT NOT NEED
   2:     oNodeSetLabel( Node, node_attribute, Label )  % set Label attribute of node
   2:     oNodeSetCode( Node, node_attribute, Code )    % set Code attribute of node
   2:     oNodeGet (Node, node_attribute) >> Node    % get Node attribute of node
   2:     oNodeGetInt (Node, node_attribute) >> int  % get int attribute of node
   2:     oNodeGetBoolean (Node, node_attribute) >> boolean  % get int attribute of node
   2:     oNodeGetLabel (Node, node_attribute) >> Label      % get Label attribute of node
   2:     oNodeGetCode (Node, node_attribute) >> Code        % get code stream attribute of node
   2:     oNodeNull (Node) >> boolean          % is node null?
   2:     oNodeGetIter (Node, node_attribute) >> NodeIter   % get an iterator over nodes in a List attribute
   2:     oNodeIterValue (NodeIter) >> Node             % the node that iter is referring to (NodeNull if no more nodes)
   2:     oNodeIterNext (inout NodeIter)                 % advance iterator through list
   2:     oNodeType (Node) >> node_type        % return node type of node
   2:     oNodeEqual (Node, Node) >> boolean   % compare two nodes for equality
                                               % (i.e. same node, not just same contents)
   2:     ;
      
      
      % Manipulate a temporary vector of Node
      %
   2: mechanism node_vec_mech:
   2:     oNodeVecNew >> NodeVec
   2:     oNodeVecDelete( NodeVec nv )
   2:     oNodeVecAppend( NodeVec nv, Node n )
   2:     oNodeVecSize( NodeVec nv ) >> int                % how many elements
   2:     oNodeVecElement( NodeVec nv, int idx ) >> Node   % element at index idx (0..size-1)
   2:     ;
      
      
      
   2: mechanism emit_mech:
   2:     oEmitInt( int )              % emit int into the generated code
   2:     oEmitLabel( Label )
   2:     oEmitCode( Code )            % append a code stream to the current code stream
   2:     Here >> int                  % current address in the generated code
                                       %   (only usable in the default code stream)
   2:     oPatch( int addr, int val )  % patch an int into address in the generated code
                                       %   (only usable in the default code stream)
   2:     ;
      
   2: mechanism math:
   2:     inc (inout int)
   2:     dec (inout int)
   2:     negate (int) >> int
   2:     subtract( int x, int y ) >> int     % x - y
   2:     multiply( int x, int y ) >> int     % x * y
   2:     equal( int x, int y ) >> boolean
   2:     equal_zero (int) >> boolean
   2:     equal_node_type (node_type, node_type) >> boolean     % Want equal_<type> for every type
   2:     equal_label( Label, Label ) >> boolean
   2:     equal_code( Code, Code ) >> boolean
   2:     oMININT >> int    % the minimum 32-bit integer.  necessary because ssl literal ints are currently (silently) short (!)
   2:     ;
      
   2: mechanism more_builtins:      % These should be built-in SSL operations
   2:     TOKEN_VALUE >> int        % value of just accepted token, e.g. IntLit token
   2:     LAST_ID >> int            % id number of last accepted identifier
   2:     ;
      
   2: mechanism scope_mech:
   2:     oScopeBegin                          % create a new scope. Subsequent declarations will go here.
   2:     oScopeEnter( Node scope )            % enter an existing scope.
   2:     oScopeEnd                            % end current scope. Subsequent declarations will go to previous scope.
   2:     oScopeCurrent >> Node                % returns current scope
   2:     oScopeDeclare( Node decl )           % add declaration to current scope.
   2:     oScopeDeclareAlloc( Node decl )      % add declaration to current scope, and allocate space according to its type
   2:     oScopeAllocType( Node theType ) >> int   % allocate space for type in current scope, and return its address
   2:     oScopeFind >> Node                   % find declaration of last accepted identifier.  Returns Null if not found.
   2:     oScopeFindRequire >> Node            % find declaration of last accepted identifier.  Error if not found.
   2:     oScopeFindInCurrentScope >> Node     % find declaration of last accepted identifier, only within the current scope.  Null if not found.
   2:     ;
      
   2: mechanism type_mech:
   2:     oTypeAdd( Node node )     % add the given nType to the type table
   2:     ;
      
   2: mechanism type_stack_mech:
   2:     oTypeSPush( Node node )
   2:     oTypeSPop
   2:     oTypeSTop >> Node
   2:     oTypeSNodeType >> node_type          % node_type of the node on top of type stack, skipping subranges
   2:     ;
      
      
   2: mechanism id_mech:
          % adds a predefined id to the scanner's id table, and returns the id code
   2:     oIdAdd_File >> int
   2:     oIdAdd_Integer >> int
   2:     oIdAdd_Boolean >> int
   2:     oIdAdd_Char >> int
   2:     oIdAdd_String >> int
   2:     oIdAdd_True >> int
   2:     oIdAdd_False >> int
   2:     ;
      
      
      
   2: mechanism label_mech:
   2:    oLabelNew >> Label
   2:    ;
      
   2: mechanism code_mech:
   2:    oCodeNew >> Code         % create a new empty code stream
   2:    oCodePush( Code )        % change the current output code stream to the given one
   2:    oCodePop                 % restore the current code stream to the previous one
   2:    ;
      
      
   2: mechanism count :
   2:    oCountPush(int)          % start a new counter, with initial value
   2:    oCountInc
   2:    oCountDec
   2:    oCountIsZero >> boolean
   2:    oCountPop;
      
      
   2: mechanism value :              % value stack, to calc. const expr's
   2:    oValuePush(int)             % push an explicit int lit
   2:    oValueNegate                % negate top value
   2:    oValueTop >> int            % get top value on value stack
   2:    oValuePop;
      
   2: mechanism string :
   2:    oStringAllocLit >> int      % alloc global space for strlit, return address
   2:    oStringAllocLitFromIdent( int id ) >> int  % alloc global space for strlit taken from name of ident;
                                                    %  return address
   2:    ;
      
      % track labels for the loop we're in, if any
   2: mechanism loop_mech:
   2:    oLoopPush( Label continueLabel, Label breakLabel )
   2:    oLoopContinueLabel >> Label
   2:    oLoopBreakLabel >> Label
   2:    oLoopPop
   2:    ;
      
      % for hacky debugging
   2: mechanism msg_mech:
   2:    oMsg( int num )             % print message "oMsg <num>"
   2:    oMsgTrace( int num )        % print message "oMsg <num>" followed by ssl traceback
   2:    oMsgNode( Node node )       % print node
   2:    oMsgNodeVec( NodeVec vec )  % print node vec
   2:    ;
      
      
   2: rules
      
      % ----------------------------- Global Variables ----------------------------
      
   2: Node    globalScope            % global nScope
      
      % built-in nTypes
   2: Node    FileType
   2: Node    IntegerType
   2: Node    BooleanType
   2: Node    BooleanCFType
   2: Node    CharType
   2: Node    StringType
      
      % -------------------------- Forward Declarations -------------------------
      
   2: Block( node_type varNodeType, Label labelForBody );
   2: BlockDecls( node_type varNodeType );
   2: BlockStmt( Label labelForBody, Node varScope );
   2: VarDecl( node_type varNodeType );
   2: newType( node_type nt, int size ) >> Node;
   2: newIdent( node_type nt, kind k, int id ) >> Node;
   2: EmitValue( Node decl );
   2: TypeRef( out Node theType );
   2: PointerTypeTo( Node theType ) >> Node;
   2: OrdinalLow( Node theType ) >> int;
   2: AssignStmt( Node decl );
   2: BooleanExprControlFlow( out Label falseLabel );
   2: ExprAllowCF( out Label falseLabel );
   2: BoolExprAllowCF( out Label falseLabel );
   2: BoolTermAllowCF( out Label falseLabel );
   2: BoolFactorAllowCF( out Label falseLabel );
   2: ArithExprAllowCF( out Label falseLabel );
   2: TermAllowCF( out Label falseLabel );
   2: FactorAllowCF( out Label falseLabel );
   2: PrimaryAllowCF( out Label falseLabel );
      
      
      
   2: VarExpr( Node decl );
   2: LValueVar( Node decl );
   2: IncVar( Node decl );
   2: DecVar( Node decl );
      
   2: CFToVal( inout Label falseLabel );
   2: ValToCF( out Label falseLabel );
      
      % ----------------------------- Declarations ----------------------------
      
   2: Program:
   4:    Node t
      
   4:    oScopeBegin
   5:    globalScope = oScopeCurrent
      
  10:    @installBuiltIns
      
         % Start by calling the main program routine.
      
         % This dummy call to main needs to look like a normal method itself,
         % so jit can align the stack properly.  So we need .tEnter,
         % and .tAllocActuals / .tFreeActuals.
  12:    .tEnter  oEmitInt( 0 )
  20:    Label mainLabel = oLabelNew
      
  25:    .tAllocActuals  oEmitInt( 0 )
  33:    .tCall  oEmitLabel( mainLabel )
  41:    .tFreeActuals  oEmitInt( 0 )
  49:    .tReturn
      
  51:    pProgram
  53:    pIdent
      
  55:    Node progDecl = @newIdent( nProgram, kProgram, LAST_ID )
  71:    oScopeDeclare( progDecl )
      
  77:    [
  77:       | '(' :
  79:          pIdent      % input, output files
      
  81:          t = @newIdent( nVar, kVar, LAST_ID )
  97:          oNodeSet( t, qType, FileType )
 109:          oScopeDeclareAlloc( t )
      
 115:          ','
 117:          pIdent
      
 119:          t = @newIdent( nVar, kVar, LAST_ID )
 135:          oNodeSet( t, qType, FileType )
 147:          oScopeDeclareAlloc( t )
      
 153:          ')'
 155:       | * :
 160:    ]
 160:    ';'
      
 162:    @BlockDecls( nGlobalVar )
      
         % a new scope just for temporaries in the main routine
 169:    Node varScope = oScopeCurrent
 174:    oScopeBegin
 175:    oNodeSetBoolean( oScopeCurrent, qAllocDown, true )
 186:    oNodeSet( progDecl, qMainRoutineScope, oScopeCurrent )
      
         % The block statement includes a stack frame, and enter/return,
         % even for the main routine.
         % That will be necessary for temporaries allocated in the main routine.
 197:    @BlockStmt( mainLabel, varScope )
      
 207:    oScopeEnd   % main routine scope
      
 208:    '.'
 210:    oScopeEnd   % global scope
 212:    ;
      
      
 212: Block( node_type varNodeType, Label labelForBody ):
 214:    @BlockDecls( varNodeType )
 221:    @BlockStmt( labelForBody, oScopeCurrent )
 231:    ;
      
      
 231: BlockDecls( node_type varNodeType ):
 233:    {[
 233:       | pConst :     @ConstDecl
 237:       | pType :      @TypeDecl
 241:       | pVar :       @VarDecl( varNodeType )
 250:       | pProcedure : @ProcDecl
 254:       | pFunction :  @FuncDecl
 258:       | * :          >
 273:    ]}
 275:    @CheckForUndefinedMethods
 278:    ;
      
      
      % were there any procedures or functions declared in this scope
      % that were never defined?
 278: CheckForUndefinedMethods:
         % TO DO
         % Note: disregard methods marked external
 281:    ;
      
      
      
      % Given the scope of vars in this block.
      % Usually it's the current scope, but it's a bit different for the main statement.
      %
 281: BlockStmt( Label labelForBody, Node varScope ):
 283:    .tLabel  oEmitLabel( labelForBody )
      
         % Proc, func, and main routine all start with tEnter
         % to create a stack frame.  This will be used for temporaries
         % (and local vars in the case of proc, func).
      
 291:    int patchLS
 291:    .tEnter  patchLS = Here  .tSpace
      
         % insert any code for initialization of this scope's variables
 300:    Code initCode = oNodeGetCode( varScope, qInitCode )
 313:    oEmitCode( initCode )
 319:    oNodeSetCode( oScopeCurrent, qInitCode, codeNull )
      
 330:    @Statement
 332:    .tReturn
      
 334:    int localSpace = oNodeGetInt( oScopeCurrent, qSize )
 346:    oPatch( patchLS, localSpace )
 356:    ;
      
      
      % modifers that may appear on a proc/function declaration.
      %
 356: MethodModifiers( Node decl ):
 358:    {[
 358:       | pCdecl :
 360:          oNodeSetBoolean( decl, qCdecl, true )
 372:          ';'
      
 374:       | * : >
 381:    ]}
 384:    ;
      
      
      % We need an initCode code stream for the current scope.
      % Create it if not present yet.  Return it.
      % (This will be used for variable initialization.)
      %
 384: GetOrCreateInitCode >> Code:
 386:    Code initCode = oNodeGetCode( oScopeCurrent, qInitCode )
 398:    [ equal_code( initCode, codeNull )
 408:       | true :
 409:          initCode = oCodeNew
 414:          oNodeSetCode( oScopeCurrent, qInitCode, initCode )
 425:       | * :
 430:    ]
 430:    >> initCode;
      
      
      % external method resides in an external object file
      % (or in my system, the built-in runtime library).
      % The method has a label, as usual, which callers will use.
      % But we define that label with .tLabelExtern rather than .tLabel.
      %
      % Note, I'll hold off on issuing the .tLabelExtern until we see that
      % the external method is actually called.  Otherwise we'd fill each output file
      % with all the external method names in my included libraries, which seems dumb.
      %
      % Note this is fpc syntax.  I'm not sure about other Pascals.
      %
 434: ExternalDecl( Node decl ):
 436:    oNodeSetBoolean( decl, qExternal, true )
 448:    [
 448:       | pStrLit :
               % that was the optional library name containing the method.
               % TO DO: I'm currently ignoring this.
 450:          [
 450:             | pName :
 452:                pStrLit
                     % that was the optional method name defined in that library,
                     % which might differ from the Pascal name.
                     % TO DO: I'm currently ignoring this.
                     %        Unfortunately my schema system doesn't support string fields yet!
 454:             | * :
 459:          ]
 459:       | * :
 464:    ]
 465:    ;
      
      
 465: ProcDecl:
 467:    pIdent
      
         % If we already have a forward declaration, we'll modify that decl
         % instead of creating a second symbol table entry.
         % (Alternatively could delete or hide the old entry.)
 469:    boolean redeclaring = false
 475:    Node decl = oScopeFindInCurrentScope
      
 480:    [ oNodeNull( decl )
 487:       | true :
               % first declaration
 488:          decl = @newIdent( nProc, kProc, LAST_ID )
 504:          oNodeSetLabel( decl, qValue, oLabelNew )
      
 515:       | false :
               % we already have a declaration.
               % Keep it, and its label.
 517:          redeclaring = true
 523:          [ oNodeGetBoolean( decl, qBodyDefined )
 533:             | true : #eAlreadyDefined
 536:             | * :
 541:          ]
 541:          [ oNodeGetBoolean( decl, qExternal )
 551:             | true : #eAlreadyDefined
 554:             | * :
 559:          ]
 559:          [ oNodeType( decl )
 566:             | nProc :
 567:             | * : #eAlreadyDefined   % wrong kind
 574:          ]
               % Move the existing param scope aside, so we can check that the
               % new one is consistent.  And, the body will want to see the new one
               % since the names might differ.
               % TO DO: If qOldParams already set, we have multiple forward decls,
               % which I believe is supposed to be an error.
 574:          oNodeSet( decl, qOldParams, oNodeGet( decl, qParams ) )
 593:          oNodeSet( decl, qParams, Null )
 605:    ]
      
 613:    oScopeBegin
 614:    Node paramScope = oScopeCurrent
      
 619:    @FormalArgDecl
 621:    oNodeSet( decl, qParams, paramScope )
 633:    oScopeEnd
 634:    ';'
      
 636:    [ redeclaring
 639:       | false : oScopeDeclare( decl )
 646:       | true :  % TO DO: check that qParams is consistent with qOldParams
 648:    ]
      
 656:    @MethodModifiers( decl )
      
         % Body may be a statement, "forward", "external".
         % Note, this syntax is based on FPC, and I'm not sure if other Pascals are similar.
         % FPC says that forward, external, cdecl, name, etc are not reserved words -
         % I think this means the user may declare other things with those names, but if so the
         % original meaning is lost.  I'll make them keywords for simplicity, for now
         % (just not too happy about "name").
      
 663:    [
 663:       | pForward :
               % Nothing to do.  We simply won't set qBodyDefined.
      
 665:       | pExternal : @ExternalDecl( decl )
      
 674:       | * :
               % Body statement
      
               % Enter the params scope again, so params are visible in body.
               % TO DO: Perhaps I could mark the scope read-only at this point.
 681:          oScopeEnter( paramScope )
      
               % Start scope for declarations within the proc
 687:          oScopeBegin
 688:          oNodeSetBoolean( oScopeCurrent, qAllocDown, true )
 699:          oNodeSet( decl, qChildScope, oScopeCurrent )
      
 710:          Label label = oNodeGetLabel( decl, qValue )
 723:          @Block( nLocalVar, label )
 733:          oNodeSetBoolean( decl, qBodyDefined, true )
 745:          oScopeEnd
      
 746:          oScopeEnd  % paramScope
 747:    ]
 747:    ';';
      
      
 750: FuncDecl:
 752:    pIdent
      
         % If we already have a forward declaration, we'll modify that decl
         % instead of creating a second symbol table entry.
         % (Alternatively could delete or hide the old entry.)
 754:    boolean redeclaring = false
 760:    Node decl = oScopeFindInCurrentScope
      
 765:    [ oNodeNull( decl )
 772:       | true :
               % first declaration
 773:          decl = @newIdent( nFunc, kFunc, LAST_ID )
 789:          oNodeSetLabel( decl, qValue, oLabelNew )
      
 800:       | false :
               % we already have a declaration.
               % Keep it, and its label.
 802:          redeclaring = true
 808:          [ oNodeGetBoolean( decl, qBodyDefined )
 818:             | true : #eAlreadyDefined
 821:             | * :
 826:          ]
 826:          [ oNodeType( decl )
 833:             | nFunc :
 834:             | * : #eAlreadyDefined   % wrong kind
 841:          ]
               % Move the existing param scope and return value aside,
               % so we can check that the new one is consistent.
               % And, the body will want to see the new one since the names might differ.
               % TO DO: If qOldParams already set, we have multiple forward decls,
               % which I believe is supposed to be an error.
 841:          oNodeSet( decl, qOldParams, oNodeGet( decl, qParams ) )
 860:          oNodeSet( decl, qParams, Null )
 872:          oNodeSet( decl, qOldType, oNodeGet( decl, qType ) )
 891:          oNodeSet( decl, qType, Null )
 903:    ]
      
 911:    oScopeBegin
 912:    Node paramScope = oScopeCurrent
      
 917:    @FormalArgDecl
 919:    oNodeSet( decl, qParams, paramScope )
      
 931:    ':'
      
 933:    Node theType
 933:    @TypeRef( theType )
 940:    oNodeSet( decl, qType, theType )
      
         % The function's param space gets an additional pointer,
         % which will point to a temporary in the caller's scope.
         % This pointer is essentially a VAR param, but I won't create an nParam for it.
      
 952:    Node ptrType = @PointerTypeTo( theType )
 963:    oNodeSetInt( decl, qResultOffset, oScopeAllocType( ptrType ) )
 979:    oScopeEnd
 980:    ';'
      
 982:    [ redeclaring
 985:       | false : oScopeDeclare( decl )
 992:       | true :  % TO DO: check that qParams is consistent with qOldParams
                      % and qType is consistent with qOldType
 994:    ]
      
1002:    @MethodModifiers( decl )
      
         % Body may be a statement, "forward", "external".
1009:    [
1009:       | pForward :
               % Nothing to do.  We simply won't set qBodyDefined.
      
1011:       | pExternal : @ExternalDecl( decl )
      
1020:       | * :
               % Body statement
      
               % Enter the params scope again, so params are visible in body.
               % TO DO: Perhaps I could mark the scope read-only at this point.
1027:          oScopeEnter( paramScope )
      
1033:          oScopeBegin
1034:          oNodeSetBoolean( oScopeCurrent, qAllocDown, true )
1045:          oNodeSet( decl, qChildScope, oScopeCurrent )
      
1056:          Label label = oNodeGetLabel( decl, qValue )
1069:          @Block( nLocalVar, label )
1079:          oNodeSetBoolean( decl, qBodyDefined, true )
1091:          oScopeEnd
      
1092:          oScopeEnd  % paramScope
1093:    ]
1093:    ';';
      
      
1096: FormalArgDecl:
1098:    [
1098:       | '(' :
1100:          {
1100:             NodeVec decls = oNodeVecNew
1105:             Node decl
1105:             boolean isInOut = false
      
1111:             [
1111:                | pVar : isInOut = true
1119:                | * :
1124:             ]
      
1124:             {  pIdent
      
1126:                decl = @newIdent( nParam, kVar, LAST_ID )
1142:                oNodeSetBoolean( decl, qInOut, isInOut )
1154:                oNodeVecAppend( decls, decl )
      
1163:                [
1163:                   | ':' : >
1167:                   | ',' :
1169:                ]
1177:             }
      
1179:             Node theType
1179:             @TypeRef( theType )
      
                  % VAR param is declared with its given type, but allocated as a pointer.
1186:             Node allocType
1186:             [ isInOut
1189:                | true :   allocType = @PointerTypeTo( theType )
1201:                | * :      allocType = theType
1212:             ]
      
1212:             int i = 0
1218:             {[ equal( i, oNodeVecSize( decls ) )
1232:                | false :
1233:                   decl = oNodeVecElement( decls, i )
      
1246:                   oNodeSet( decl, qType, theType )
1258:                   oScopeDeclare( decl )
1264:                   oNodeSetInt( decl, qValue, oScopeAllocType( allocType ) )
1280:                   inc( i )
1286:                | * :
1291:                   >
1293:             ]}
      
1295:             oNodeVecDelete( decls )
      
1301:             [
1301:                | ')' : >
1305:                | ';' :
1307:             ]
1315:          }
1317:       | * :
1322:    ];
      
1323: ConstDecl:
1325:    {[
1325:       | pIdent :
1327:          Node decl = @newIdent( nConst, kConst, LAST_ID )
1343:          '='
      
1345:          @ConstExpr
               % TO DO: currently ConstExpr leaves int result on oValue stack
1347:          int val = oValueTop
1352:          oValuePop
1353:          oNodeSetInt( decl, qValue, val )
      
               % TO DO: different types.  Currently assumes int!
1365:          oNodeSet( decl, qType, IntegerType )
      
1377:          oScopeDeclare( decl )
1383:          ';'
1385:       | * :
1390:          >
1392:    ]};
      
1395: TypeDecl:
1397:    {[
1397:       | pIdent :
1399:          Node decl = @newIdent( nTypeDecl, kType, LAST_ID )
1415:          '='
1417:          Node theType
1417:          @TypeRef( theType )
1424:          oNodeSet( decl, qType, theType )
1436:          oScopeDeclare( decl )
1442:          ';'
1444:       | * :
1449:          >
1451:    ]};
      
1454: VarDecl( node_type varNodeType ):
1456:    {[
1456:       | pIdent :
1458:          NodeVec decls = oNodeVecNew
1463:          Node decl
1463:          {
1463:             decl = @newIdent( varNodeType, kVar, LAST_ID )
1479:             oNodeVecAppend( decls, decl )
1488:             [
1488:                | ',' :
1490:                   pIdent
1492:                | * :
1497:                   >
1499:             ]
1499:          }
1501:          ':'
1503:          Node theType
1503:          @TypeRef( theType )
      
1510:          int i = 0
1516:          {[ equal( i, oNodeVecSize( decls ) )
1530:             | false :
1531:                decl = oNodeVecElement( decls, i )
1544:                oNodeSet( decl, qType, theType )
1556:                oScopeDeclareAlloc( decl )
1562:                inc( i )
1568:             | * :
1573:               >
1575:          ]}
      
               % optional initialization
1577:          [
1577:             | '=' :
1579:                [ oNodeVecSize( decls )
1586:                   | 1 :
1587:                   | * :  #eOnlyOneVarCanBeInitialized
1594:                ]
      
                     % we need an initCode stream for this scope
1594:                Code initCode = @GetOrCreateInitCode
1600:                oCodePush( initCode )
                     % generate assignment in initCode stream
1606:                @LValueVar( decl )
1613:                @Expr
1615:                @MatchTypes
1617:                @Assign
1619:                oCodePop
                   
1620:             | * :
1625:          ]
      
1625:          oNodeVecDelete( decls )
1631:          ';'
1633:       | * :
1638:          >
1640:    ]};
      
      
      % Parse a type reference, returning the nType.
      % This will add types to the type table, as needed.
      %
      % Style question - at the moment I think callers look clearer if we use
      % an out param here, rather than a return value.
      %
1643: TypeRef( out Node resultType ):
1645:    [
1645:       | pIdent :           % previously named type (including intrinsics)
1647:          Node decl = oScopeFindRequire
1652:          [ oNodeType( decl )
1659:            | nTypeDecl :
1660:                resultType = oNodeGet( decl, qType )
1673:            | * :
1678:                #eNotType
1680:                resultType = IntegerType
1686:          ]
         
1686:       | pArray :
1688:          '['
      
               % A multi-dimensional array is represented as a chain
               %    array [subrange1] of array [subrange2] of elementType
      
               % First, we build a vector of nArray's, each with one subrange as its index type,
               % but without setting the "of" type or size.
      
1690:          NodeVec dimensions = oNodeVecNew
      
1695:          {
                  % to do: probably should use general subrange parsing, incl minimal size value
                  %   In fact, supposed to parse ordinal_type here.  all ordinal types have a static low, high.
                  %   Not necessary to be a subrange.
      
1695:             Node subrange = oNodeNew( nSubrangeType )
                  % TO DO: currently assuming subrange of integer
1705:             oNodeSet( subrange, qBaseType, IntegerType )
      
                  % TO DO: currently ConstExpr leaves int result on oValue stack
1717:             @ConstExpr
1719:             oNodeSetInt( subrange, qLow, oValueTop )
1730:             oValuePop
1731:             '..'
1733:             @ConstExpr
1735:             oNodeSetInt( subrange, qHigh, oValueTop )
1746:             oValuePop
1747:             oNodeSetInt( subrange, qSize, 4 )   % maybe don't need
      
1759:             oTypeAdd( subrange )
      
1765:             Node a = oNodeNew( nArrayType )
1775:             oNodeSet( a, qIndexType, subrange )
      
1787:             oNodeVecAppend( dimensions, a )
                  % I'll hold off on adding 'a' to the type table since not fully formed yet
      
1796:             [
1796:                | ']' : >
1800:                | ',' :
1802:             ]
1810:          }
      
1812:          pOf
1814:          Node baseType
1814:          @TypeRef( baseType )
      
               % Work backwards through the dimensions,
               % hooking up the 'of' type and calculating the size.
               % At each iteration, baseType is the 'of' type.
      
1821:          int dim = oNodeVecSize( dimensions )
      
1831:          {
1831:              dec(dim)
      
1837:              Node a = oNodeVecElement( dimensions, dim )
      
1850:              oNodeSet( a, qBaseType, baseType )
1862:              Node subrange = oNodeGet( a, qIndexType )
1875:              int width = subtract( oNodeGetInt( subrange, qHigh ), oNodeGetInt( subrange, qLow ) )
1902:              inc( width )
1908:              oNodeSetInt( a, qSize, multiply( width, oNodeGetInt( baseType, qSize ) ) )
      
1934:              oTypeAdd( a )
1940:              baseType = a
      
1946:              [ equal_zero(dim)
1953:                  | true:  >
1956:                  | *:
1961:              ]
1961:          }
      
1963:          resultType = oNodeVecElement( dimensions, 0 )
1976:          oNodeVecDelete( dimensions )
      
1982:       | '^' :
1984:          Node theType
1984:          @TypeRef( theType )
1991:          resultType = @PointerTypeTo( theType )
      
2002:       | pRecord :
2004:          resultType = oNodeNew( nRecordType )
2014:          oScopeBegin
      
2015:          @VarDecl( nRecordField )
      
2022:          int size = oNodeGetInt( oScopeCurrent, qSize )
               % to do: padding
2034:          [ equal_zero( size )
2041:             | true : #eRecordEmpty
2044:             | * :
2049:          ]
      
2049:          pEnd
      
2051:          oNodeSet( resultType, qScope, oScopeCurrent )
2062:          oNodeSetInt( resultType, qSize, size )
2074:          oScopeEnd
2075:          oTypeAdd( resultType )
      
      
            % *** TO DO: following type constructors are not implemented *** 
            % *** TO DO: also missing declaration of enum type
2081:       | pSet :
2083:          pOf
2085:          Node theType
2085:          @TypeRef( theType )
2092:       | * :       % this works for cases except where expr starts with an id
2105:          @ConstExpr '..' @ConstExpr
2111:    ];
      
      
      % --------------------------- Const Expressions --------------------------
      
      % Constant expressions: currently, only literal integers or previously
      % named constant integers are supported, possibly with a negation.
      % Constant expressions are evaluated at compile time.
      
2112: ConstExpr:
2114:    [
2114:       | pIntLit :
2116:          oValuePush( TOKEN_VALUE )
2121:       | pIdent :
2123:          Node decl = oScopeFindRequire
2128:          [ oNodeType( decl )
2135:             | nConst :
2136:                oValuePush( oNodeGetInt( decl, qValue ) )
2149:             | * :
2154:                #eNotConst
2156:                oValuePush( 0 )
2162:          ]
2162:       | pMinus :
2164:          @ConstExpr
2166:          oValueNegate
2167:    ];
      
      
      
      % ------------------------------ Expressions -----------------------------
      
      % There are two wrappers leading into expression parsing:
      %   Expr()
      %   BooleanExprControlFlow( out Label falseLabel )
      %
      % Expr always produces a value on the runtime expr stack,
      % and pushes its type on the type stack.
      %
      % BooleanExprControlFlow always generates control-flow code.
      % It does not push a value on the runtime expr stack.
      % It does not push a type on the type stack.
      % The control flow code ends up at Here if the expr is true,
      % and jumps to falseLabel if the expr is false.
      % This rule allocates falseLabel, and passes it back.
      % The caller will need to define its location.
      %
      % The internal methods of expr parsing may produce a mix of
      % values and control flow, depending on the operators seen.
      % We don't always do one or the other, hoping to be efficient for
      % cases like   "func_call( bool_var1, bool_var2 )"
      % as well as  "if bool_expr1 or bool_expr2 then ...".
      % If a subexpression rule produces control flow, it will allocate a
      % falseLabel and pass it back up.  And it will push the
      % result type as BooleanCFType, to distinguish from BooleanType
      % which corresponds with a boolean value on the expr stack.
      % 
      % Note that my expression parsing is broken into more levels than
      % grammars describe for Pascal precedence levels.  This follows my
      % original parser implementation.  I think my rationale was that
      % operators from the levels that I split up couldn't have been
      % mixed anyway, since they require different data types
      % (e.g. boolean vs int/real).  And splitting them up simplified
      % my code.  But, I should revisit this.
      %
      
      
      % Public entry point:
      %
      % Parse an expression, leaving a value on the runtime expr stack
      % and its type on the type stack.
      %
      % This rule does not export control flow (though it may generate
      % control flow internally for subexpressions).
      %
2178: Expr:
2180:    Label falseLabel = labelNull
      
2186:    @ExprAllowCF( falseLabel )
2193:    @CFToVal( falseLabel );
      
      
      % Public entry point:
      %
      % Parse a Boolean expression, producing control flow code rather than a value.
      % Does not leave a value on the runtime expr stack.
      % Does not leave a type on the type stack.
      %
      % If the expression is true, the code will fall through to the end (Here).
      % If the expression is false, the code will jump to the given falseLabel,
      % which this rule will allocate but not define the location for.
      % The caller must do so.
      %
2201: BooleanExprControlFlow( out Label falseLabel ):
2203:    @ExprAllowCF( falseLabel )
2210:    [ oTypeSNodeType
2212:       | nBooleanCFType :
2213:       | nBooleanType :
               % convert value to control flow
2215:          falseLabel = oLabelNew
2220:          .tJumpFalse  oEmitLabel( falseLabel )
2228:       | * :
2235:          #eNotBoolean
2237:    ]
2237:    oTypeSPop;
      
      
      % If the current expr result is control flow, convert it to a value.
      % falseLabel is the label that had been used by the control flow.
      % On return it will be set to labelNull.
      %
2239: CFToVal( inout Label falseLabel ):
2241:    [ oTypeSNodeType
2243:       | nBooleanCFType :
2244:          Label doneLabel = oLabelNew
2249:          .tPushConstI  oEmitInt( 1 )
2257:          .tJump  oEmitLabel( doneLabel )
2265:          .tLabel  oEmitLabel( falseLabel )
2273:          .tPushConstI  oEmitInt( 0 )
2281:          .tLabel  oEmitLabel( doneLabel )
2289:          oTypeSPop
2290:          oTypeSPush( BooleanType )
2296:          falseLabel = labelNull
2302:       | * :
2307:    ];
      
      
      % If the current expr result is boolean value, convert it to control flow.
      % falseLabel will be allocated by this rule and passed back.
      % The caller must define its location.
      %
2308: ValToCF( out Label falseLabel ):
2310:    [ oTypeSNodeType
2312:       | nBooleanType :
2313:          falseLabel = oLabelNew
2318:          .tJumpFalse  oEmitLabel( falseLabel )
2326:          oTypeSPop
2327:          oTypeSPush( BooleanCFType )
2333:       | * :
2338:    ];
      
      
      % Parse an expression.  It may produce a value on the expr stack,
      % or control flow, depending on what's seen in the expression.
      % Leaves the expression type on the type stack.
      %
      % If the expression produces control flow, the expression type will be
      % nBooleanCFType.  In this case, a true value falls through to Here,
      % and a false value jumps to falseLabel.  This rule will allocate falseLabel
      % and return it, but will not define its location; the caller must do so.
      %
      % If the expression produces a value, the value will be left on the
      % expression stack, and the type will be some type other than nBooleanCFType.
      % In this case, falseLabel is ignored.
      %
2339: ExprAllowCF( out Label falseLabel ):
2341:    @BoolExprAllowCF( falseLabel )
2348:    {[
2348:       | '=' :
2350:          @CFToVal( falseLabel )
2357:          @BoolExprAllowCF( falseLabel )
2364:          @CFToVal( falseLabel )
2371:          @MatchTypes
2373:          [ oTypeSNodeType
2375:             | nIntegerType, nBooleanType :  .tEqualI
2378:             | nPointerType :                .tEqualP
2382:             | nCharType, nStringType :      #eNotImplemented
2386:             | * :                           #eNotAllowed
2401:          ]
2401:          oTypeSPop
2402:          oTypeSPush( BooleanType )
      
2408:       | '<>' :
2410:          @CFToVal( falseLabel )
2417:          @BoolExprAllowCF( falseLabel )
2424:          @CFToVal( falseLabel )
2431:          @MatchTypes
2433:          [ oTypeSNodeType
2435:             | nIntegerType, nBooleanType :  .tNotEqualI
2438:             | nPointerType :                .tNotEqualP
2442:             | nCharType, nStringType :      #eNotImplemented
2446:             | * :                           #eNotAllowed
2461:          ]
2461:          oTypeSPop
2462:          oTypeSPush( BooleanType )
      
2468:       | '<' :
2470:          @CFToVal( falseLabel )
2477:          @BoolExprAllowCF( falseLabel )
2484:          @CFToVal( falseLabel )
2491:          @MatchTypes
2493:          [ oTypeSNodeType
2495:             | nIntegerType, nBooleanType :  .tLessI
2498:             | nCharType, nStringType :      #eNotImplemented
2502:             | * :                           #eNotAllowed
2515:          ]
2515:          oTypeSPop
2516:          oTypeSPush( BooleanType )
      
2522:       | '>' :
2524:          @CFToVal( falseLabel )
2531:          @BoolExprAllowCF( falseLabel )
2538:          @CFToVal( falseLabel )
2545:          @MatchTypes
2547:          [ oTypeSNodeType
2549:             | nIntegerType, nBooleanType :  .tGreaterI
2552:             | nCharType, nStringType :      #eNotImplemented
2556:             | * :                           #eNotAllowed
2569:          ]
2569:          oTypeSPop
2570:          oTypeSPush( BooleanType )
      
2576:       | '<=' :
2578:          @CFToVal( falseLabel )
2585:          @BoolExprAllowCF( falseLabel )
2592:          @CFToVal( falseLabel )
2599:          @MatchTypes
2601:          [ oTypeSNodeType
2603:             | nIntegerType, nBooleanType :  .tLessEqualI
2606:             | nCharType, nStringType :      #eNotImplemented
2610:             | * :                           #eNotAllowed
2623:          ]
2623:          oTypeSPop
2624:          oTypeSPush( BooleanType )
      
2630:       | '>=' :
2632:          @CFToVal( falseLabel )
2639:          @BoolExprAllowCF( falseLabel )
2646:          @CFToVal( falseLabel )
2653:          @MatchTypes
2655:          [ oTypeSNodeType
2657:             | nIntegerType, nBooleanType :  .tGreaterEqualI
2660:             | nCharType, nStringType :      #eNotImplemented
2664:             | * :                           #eNotAllowed
2677:          ]
2677:          oTypeSPop
2678:          oTypeSPush( BooleanType )
      
2684:       | * :
2699:          >
2701:    ]};
      
      
2704: BoolExprAllowCF( out Label falseLabel ):
2706:    Label trueLabel = labelNull
      
2712:    @BoolTermAllowCF( falseLabel )
2719:    {[
2719:       | pOr :
2721:          [ oTypeSNodeType
2723:             | nBooleanCFType :
                     % We are true here. Jump ahead to done
2724:                [ equal_label( trueLabel, labelNull )
2734:                   | true :  trueLabel = oLabelNew
2740:                   | * :
2745:                ]
2745:                .tJump  oEmitLabel( trueLabel )
2753:             | nBooleanType :
2755:                @ValToCF( falseLabel )
                     % We are true here. Jump ahead to done
2762:                [ equal_label( trueLabel, labelNull )
2772:                   | true :  trueLabel = oLabelNew
2778:                   | * :
2783:                ]
2783:                .tJump  oEmitLabel( trueLabel )
2791:             | * : #eNotBoolean
2800:          ]
2800:          oTypeSPop
      
               % false in previous term will jump here, to try this alternative term
2801:          .tLabel  oEmitLabel( falseLabel )
      
               % we'll get a new falseLabel for this term
2809:          falseLabel = labelNull
2815:          @BoolTermAllowCF( falseLabel )
      
2822:          [ oTypeSNodeType
2824:             | nBooleanCFType :
2825:             | nBooleanType :
2827:                @ValToCF( falseLabel )
2834:             | * : #eNotBoolean
2843:          ]
      
2843:          oTypeSPop
2844:          oTypeSPush( BooleanCFType )
      
2850:       | * :
2855:          >
2857:    ]}
      
         % any short-circuit trues jump here to the end
2859:    [ equal_label( trueLabel, labelNull )
2869:       | false :
2870:          .tLabel  oEmitLabel( trueLabel )
2878:       | * :
2883:    ]
2884:    ;
      
      
2884: BoolTermAllowCF( out Label falseLabel ):
2886:    Label overallFalseLabel = labelNull
      
2892:    @BoolFactorAllowCF( falseLabel )
2899:    {[
2899:       | pAnd :
2901:          [ oTypeSNodeType
2903:             | nBooleanCFType :
2904:             | nBooleanType :
2906:                @ValToCF( falseLabel )
2913:             | * :
2920:                #eNotBoolean
2922:          ]
2922:          oTypeSPop
      
               % We're going to have a different falseLabel for each term,
               % because we let each rule allocate its own (rather than accepting labels passed in).
               % And in this case we want them all to go to the same place,
               % to be determined by the caller.
               %
               % I'll allow for label aliases.  This will be more optimal than generating
               % multiple private false-handling code segments, that the true path would have to
               % jump around.  That would be hard to eliminate afterwards.
      
2923:          [ equal_label( overallFalseLabel, labelNull )
2933:             | true :
2934:                overallFalseLabel = oLabelNew
2939:                .tLabelAlias  oEmitLabel( falseLabel )  oEmitLabel( overallFalseLabel )
2953:                falseLabel = overallFalseLabel
2959:             | * :
2964:          ]
      
2964:          Label factorFalseLabel = labelNull
2970:          @BoolFactorAllowCF( factorFalseLabel )
      
2977:          [ oTypeSNodeType
2979:             | nBooleanCFType :
2980:             | nBooleanType :
2982:                @ValToCF( factorFalseLabel )
2989:             | * : #eNotBoolean
2998:          ]
2998:         .tLabelAlias  oEmitLabel( factorFalseLabel )  oEmitLabel( overallFalseLabel )
      
3012:       | * :
3017:          >
3019:    ]};
      
3022: BoolFactorAllowCF( out Label falseLabel ):
3024:    [
3024:       | pNot :
3026:          Label factorFalseLabel = labelNull
      
3032:          @BoolFactorAllowCF( factorFalseLabel )
3039:          [ oTypeSNodeType
3041:             | nBooleanCFType :
                     % We have control flow, and are sitting at the point that has value false.
3042:                falseLabel = oLabelNew
3047:                .tJump  oEmitLabel( falseLabel )
                     % The true path jumps here
3055:                .tLabel  oEmitLabel( factorFalseLabel )
      
3063:             | nBooleanType :
                     % I have a value.  I'll leave it as a value, rather than create control flow.
                     % See how this goes.
3065:                .tNot
      
3067:             | * : #eNotBoolean
3076:          ]
      
3076:       | * :
3081:          @ArithExprAllowCF( falseLabel )
3088:    ];
      
3089: ArithExprAllowCF( out Label falseLabel ):
3091:    @TermAllowCF( falseLabel )
3098:    {[
3098:       | pPlus :
3100:          @RequireIntPop
3102:          @TermAllowCF( falseLabel )  % actually not allowing CF, will be caught by type check
3109:          @RequireInt
3111:          .tAddI
3113:       | pMinus :
3115:          @RequireIntPop
3117:          @TermAllowCF( falseLabel )
3124:          @RequireInt
3126:          .tSubI
3128:       | * :
3135:          >
3137:    ]};
      
3140: TermAllowCF( out Label falseLabel ):
3142:    @FactorAllowCF( falseLabel )
3149:    {[
3149:       | pTimes :
3151:          @RequireIntPop
3153:          @FactorAllowCF( falseLabel )  % actually not allowing CF, will be caught by type check
3160:          @RequireInt
3162:          .tMultI
3164:       | pDivide :
3166:          @RequireIntPop
3168:          @FactorAllowCF( falseLabel )
3175:          @RequireInt
3177:          .tDivI
3179:       | * :
3186:          >
3188:    ]};
      
3191: FactorAllowCF( out Label falseLabel ):
3193:    [
3193:       | pPlus :
3195:          @PrimaryAllowCF( falseLabel )  % actually not allowing CF, will be caught by type check
3202:          @RequireInt
3204:       | pMinus :
3206:          @PrimaryAllowCF( falseLabel )
3213:          @RequireInt
3215:          .tNegI
3217:       | * :
3224:          @PrimaryAllowCF( falseLabel )
3231:    ];
      
3232: PrimaryAllowCF( out Label falseLabel ):
3234:    [
3234:       | pIntLit :
3236:          .tPushConstI  oEmitInt( TOKEN_VALUE )
3243:          oTypeSPush( IntegerType )
      
3249:       | '(' :
3251:          @ExprAllowCF( falseLabel )
3258:          ')'
      
3260:       | pStrLit :
3262:          int addr = oStringAllocLit     % store in global data
3267:          .tPushAddrGlobal oEmitInt( addr )
               % TO DO: do we need to create a type with the literal's length?
3275:          oTypeSPush( StringType )
      
3281:       | pIdent :
3283:          Node decl = oScopeFindRequire
3288:          Node theType
      
3288:          [ oNodeType( decl )
3295:             | nFunc :
      
3296:                @Call( decl )
      
3303:             | nConst :
3305:                theType = oNodeGet( decl, qType )
3318:                oTypeSPush( theType )
3324:                [ oTypeSNodeType
3326:                   | nIntegerType, nBooleanType :
3327:                      .tPushConstI @EmitValue( decl )
3336:                   | * :
3343:                      #eNotImplemented
3345:                ]
      
3345:             | nGlobalVar, nLocalVar, nParam :
3347:                @VarExpr( decl )
      
3354:             | * :
3367:                #eNotValue
3369:                oTypeSPush( IntegerType )
3375:          ]
      
3375:       | '@' :        % @var -- pointer to var
3377:          pIdent
      
3379:          Node decl = oScopeFindRequire
3384:          Node theType
      
3384:          @LValueVar( decl )
      
               % The above leaves the pointed-to type on type stack.
               % Replace with ptr-to-<type>.
3391:          theType = oTypeSTop
3396:          oTypeSPop
3397:          Node ptrType = @PointerTypeTo( theType )
3408:          oTypeSPush( ptrType )
      
3414:       | * :
3427:          #eNotValue
3429:          oTypeSPush( IntegerType )
3435:    ];
      
      
      % Parse a variable expression, given the declaration of the
      % just-accepted identifier.
      % Leaves the value on the expression stack, and type on the type stack.
      %
3436: VarExpr( Node decl ):
3438:    Node theType = oNodeGet( decl, qType )
3451:    oTypeSPush( theType )
3457:    [ oTypeSNodeType
3459:       | nIntegerType :
3460:          [ oNodeType( decl )
3467:             | nGlobalVar :   .tPushGlobalI @EmitValue( decl )
3477:             | nLocalVar :    .tPushLocalI @EmitValue( decl )
3488:             | nParam :
3490:                [ oNodeGetBoolean( decl, qInOut )
3500:                   | true :    % VAR param points to the var.  Auto dereference.
3501:                               .tPushParamP @EmitValue( decl )
3510:                               .tFetchI
3512:                   | * :       .tPushParamI @EmitValue( decl )
3526:                ]
3526:          ]
      
3536:       | nBooleanType :
3538:          [ oNodeType( decl )
3545:             | nGlobalVar :   .tPushGlobalB @EmitValue( decl )
3555:             | nLocalVar :    .tPushLocalB @EmitValue( decl )
3566:             | nParam :
3568:                [ oNodeGetBoolean( decl, qInOut )
3578:                   | true :    % VAR param points to the var.  Auto derefernce.
3579:                               .tPushParamP @EmitValue( decl )
3588:                               .tFetchB
3590:                   | * :       .tPushParamB @EmitValue( decl )
3604:                ]
3604:          ]
      
3614:       | nCharType, nStringType, nFileType :
3616:          #eNotImplemented
      
3618:       | nPointerType :
3620:          [ oNodeType( decl )
3627:             | nGlobalVar :   .tPushGlobalP @EmitValue( decl )
3637:             | nLocalVar :    .tPushLocalP @EmitValue( decl )
3648:             | nParam :
3650:                [ oNodeGetBoolean( decl, qInOut )
3660:                   | true :    % VAR param points to the var.  Auto derefernce.
3661:                               .tPushParamP @EmitValue( decl )
3670:                               .tFetchP
3672:                   | * :       .tPushParamP @EmitValue( decl )
3686:                ]
3686:          ]
3696:          [
3696:             | '^' :             % dereferenced
3698:                oTypeSPop
3699:                oTypeSPush( oNodeGet( theType, qBaseType ) )
3712:                @LValueIndexes
3714:                @FetchVar
3716:             | * :               % just ptr value alone
3721:          ]
      
3721:       | * :
               % compound type
               % first, push addr of start of var
3736:          [ oNodeType( decl )
3743:             | nGlobalVar :   .tPushAddrGlobal @EmitValue( decl )
3753:             | nLocalVar :    .tPushAddrLocal @EmitValue( decl )
3764:             | nParam :
3766:                [ oNodeGetBoolean( decl, qInOut )
3776:                   | true :    % VAR param points to the var.  Auto derefernce.
3777:                               .tPushParamP @EmitValue( decl )
3786:                   | * :       .tPushAddrParam @EmitValue( decl )
3800:                ]
3800:          ]
               % modify addr for subscripts, field references, etc
3810:          @LValueIndexes
               % get final value
3812:          @FetchVar
3814:    ];
      
      
      % Addr of start of var is on expr stack; type is on type stack.
      % Replace expr stack with value of var.
      % (In the case of compound vars, this remains as the addr of the var).
      
3815: FetchVar:
3817:    [ oTypeSNodeType
3819:       | nIntegerType :   .tFetchI
3822:       | nBooleanType :   .tFetchB
3826:       | nCharType, nStringType, nFileType : #eNotImplemented
3830:       | nPointerType :   .tFetchP
3834:       | * :              % compound type; leave as addr
3849:    ];
      
      
      % Addr of start of var is already on run stack, and type is on type stack.
      % Read subscripts, record fields, etc, to get final addr on run stack, and final type
      % on type stack.
      
3850: LValueIndexes:
3852:    {[
3852:       | '[' :       @ArraySubscripts
3856:       | '.' :       @RecordFieldRef
3860:       | '^' :       @PointerDeref
3864:       | * :         >
3875:    ]};
      
3878: ArraySubscripts:
3880:    [ oTypeSNodeType
3882:       | nArrayType :
3883:       | * :       #eNotArray
3890:    ]
3890:    {
3890:       [ oTypeSNodeType
3892:          | nArrayType :
3893:          | * :    #eTooManySubscripts
3900:       ]
      
            % low subscript of this dimension
3900:       int low = @OrdinalLow( oNodeGet( oTypeSTop, qIndexType ) )
      
            % replace type stack with next dimension, or OF type
3917:       Node baseType
3917:       baseType = oNodeGet( oTypeSTop, qBaseType )
3929:       oTypeSPop
3930:       oTypeSPush( baseType )
      
3936:       @Expr
3938:       @RequireIntPop
            % adjust for low subscript
3940:       [ equal_zero( low )
3947:          | false :
3948:             .tPushConstI oEmitInt( low ) .tSubI
3958:          | * :
3963:       ]
      
            % multiply by element size
3963:       int size = oNodeGetInt( baseType, qSize )
3976:       [ equal( size, 1 )
3986:          | false :
3987:             .tPushConstI oEmitInt( size ) .tMultI
3997:          | * :
4002:       ]
      
            % update start address
4002:       .tAddPI
4004:       [
4004:          | ']' :  >
4008:          | ',' :
4010:       ]
4018:    };
      
      
4021: RecordFieldRef:
4023:    [ oTypeSNodeType
4025:       | nRecordType :
4026:       | * :    #eNotRecord
4033:    ]
4033:    oScopeEnter( oNodeGet( oTypeSTop, qScope ) )
4045:    pIdent
4047:    Node field = oScopeFindRequire
         % oScopeFind searches all open scopes, so make sure we found nRecordField
         % which could only be seen in the local scope we entered above.
4052:    [ oNodeType( field )
4059:       | nRecordField :
4060:       | * :   #eNotRecordField
4067:    ]
4067:    oScopeEnd
4068:    int offset = oNodeGetInt( field, qValue )
4081:    [ equal_zero( offset )
4088:       | false :
4089:          .tPushConstI oEmitInt( offset ) .tAddPI
4099:       | * :
4104:    ]
      
         % replace the type on the type stack, with the field type
4104:    oTypeSPop
4105:    oTypeSPush( oNodeGet( field, qType ) )
4119:    ;
      
      
      % ptr deref on left side, i.e. BEFORE addr of ptr var is on stack,
      %                              AFTER addr of thing pointed to is on stack
4119: PointerDeref:
4121:    [ oTypeSNodeType
4123:       | nPointerType :
4124:       | * :       #eNotPointer
4131:    ]
4131:    .tFetchP           % now addr on stack is addr of what we're pointing to
      
4133:    Node theType = oTypeSTop
4138:    oTypeSPop
4139:    oTypeSPush( oNodeGet( theType, qBaseType ) )
4153:    ;
      
      
      % The expr stack contains a value whose type is on top of the type stack.
      % Generate code to coerce the value to the type under it in the type stack
      % (pop the type stack, leaving only the desired type).
      % This is used for assignment.
      %
4153: CoerceType:
         % TO DO: not implemented yet.  For now I require exact type match.
4155:    @MatchTypes
4158:    ;
      
      
      % Parse a call, given an nProc or nFunc for the just-accepted identifier.
      % If a func, this will also generate the code to push the return value on the expr stack,
      % and push the return type on the type stack.
      %
4158: Call( Node method ):
      
         % Prior to first call, issue extern label for a called method.
         % I don't want to issue .tLabelExtern for unused methods, that seems inefficient.
4160:    [ oNodeGetBoolean( method, qExternal )
4170:       | true :
4171:          [ oNodeGetBoolean( method, qCalled )
4181:             | false :
                     % define the label as extern
4182:                int strAddr = oStringAllocLitFromIdent( oNodeGetInt( method, qIdent ) )
4199:                .tLabelExtern  @EmitValue( method )  oEmitInt( strAddr )
4214:             | * :
4219:          ]
4219:      | * :
4224:    ]
4224:    oNodeSetBoolean( method, qCalled, true )
      
         % If the method has a cdecl modifier, the back end will need to use the native
         % calling convention, instead of my own.  But, the convention varies by platform,
         % so the front end won't assume what it needs.  I'll still generate the normal tcode
         % that copies values into actuals space on the stack.
         % However, to help the back end, I will at least use a different instruction for the
         % allocation of the actuals space, and for the actual call.
         %
         % p.s. I only support cdecl on external methods, because I don't have a way
         % to let my own Pascal methods read params passed in with the cdecl calling convention.
         %
4236:    boolean cdecl = oNodeGetBoolean( method, qCdecl )
      
         % If this is a function, we will allocate a temporary
         % in the current scope, to hold the result value.
         % And pass a pointer to that temporary as an extra parameter.
4249:    Node resultType
4249:    int tempOffset
      
4249:    boolean isFunc = equal_node_type( oNodeType( method ), nFunc )
      
4266:    [ isFunc
4269:       | true :
4270:          resultType = oNodeGet( method, qType )
4283:          tempOffset = oScopeAllocType( resultType )
               % TO DO: we could manage temp allocation, so temp space can be reused
               %        by different code branches.
4293:       | * :
4298:    ]
         
      
4298:    Node paramScope = oNodeGet( method, qParams )
4311:    int actualsSize = oNodeGetInt( paramScope, qSize )
4324:    [ cdecl
4327:       | true : .tAllocActualsCdecl  oEmitInt( actualsSize )
4336:       | false :  .tAllocActuals  oEmitInt( actualsSize )
4346:    ]
      
4354:    NodeIter paramIter = oNodeGetIter( paramScope, qDecls )
4367:    Node param = oNodeIterValue( paramIter )
4377:    [
4377:       | '(' :
            
4379:          {
4379:             [ oNodeNull( param )
4386:                | true : >
4389:                | * :
4394:             ]
      
4394:             int offset = oNodeGetInt( param, qValue )
      
                  % Assign actual value to spot in actuals space
4407:             .tPushAddrActual oEmitInt( offset )
4415:             oTypeSPush( oNodeGet( param, qType ) )
      
4428:             [ oNodeGetBoolean( param, qInOut )
4438:                | true :   % A VAR param.
                                % The actual is a pointer to the value.
                                % The type on the type stack (pushed above) is for the pointed-to value.
      
4439:                           @LValueExpr
                                % Addr of the referenced variable is on the expr stack,
                                % type of the variable is on the type stack.
      
                                % Match types more exactly. It's not sufficient to be assign compatible
                                % since the method will be assigning to the actual using the param type.
                                % Maybe something like type contents must match, incl subrange bounds.
4441:                           @MatchTypes
      
4443:                           .tAssignP
      
4445:                | false :  @Expr
4449:                           @CoerceType
                                
                                % Assign to offset in actuals space
      
4451:                           [ oTypeSNodeType
4453:                              | nIntegerType :            .tAssignI
4456:                              | nBooleanType :            .tAssignB
4460:                              | nCharType, nStringType, nFileType :   #eNotImplemented
4464:                              | nPointerType :            .tAssignP
4468:                              | * :
                                       % compound types: copy value into actuals space
4483:                                  int size = oNodeGetInt( oTypeSTop, qSize )
4495:                                  .tCopy  oEmitInt( size )    % multi-word copy
4503:                           ]
4503:             ]
4511:             oTypeSPop
      
4512:             oNodeIterNext( paramIter )
4518:             param = oNodeIterValue( paramIter )
4528:             [ oNodeNull( param )
4535:                | true :  >
4538:                | false :
4540:             ]
      
4548:             ','
4550:          }
      
4552:          ')'
      
4554:       | * :
4559:    ]
      
4559:    [ oNodeNull( param )
4566:       | false :    #eMissingParameter
4569:       | * :
4574:    ]
      
4574:    [ isFunc
4577:       | true :
               % Pass result temp as an additional VAR parameter.
4578:          .tPushAddrActual oEmitInt( oNodeGetInt( method, qResultOffset ) )
4593:          .tPushAddrLocal  oEmitInt( tempOffset )
4601:          .tAssignP
4603:       | * :
4608:    ]
      
4608:    [ cdecl
4611:       | true :
4612:          .tCallCdecl  @EmitValue( method )
4621:       | false :
4623:          .tCall   @EmitValue( method )
4632:    ]
      
4640:    [ isFunc
4643:       | true :
               % push return value from temp
4644:          oTypeSPush( resultType )
      
4650:          [ oTypeSNodeType
4652:             | nIntegerType :   .tPushLocalI  oEmitInt( tempOffset )
4661:             | nBooleanType :   .tPushLocalB  oEmitInt( tempOffset )
4671:             | nCharType, nStringType, nFileType : #eNotImplemented
4675:             | nPointerType :   .tPushLocalP  oEmitInt( tempOffset )
4685:             | * :              % compound type: push address
4700:                                .tPushAddrLocal  oEmitInt( tempOffset )
4708:          ]
4708:       | * :
4713:    ]
         
4713:    .tFreeActuals  oEmitInt( actualsSize )
4722:    ;
      
      
      % ------------------------------ Statements -----------------------------
      
4722: Statement:
4724:    [
4724:       | pWriteln :     @WritelnStmt
4728:       | pWrite :       @WriteStmt
4732:       | pReadln :      @ReadlnStmt
4736:       | pRead :        @ReadStmt
4740:       | pIf :          @IfStmt
4744:       | pWhile :       @WhileStmt
4748:       | pFor :         @ForStmt
4752:       | pRepeat :      @RepeatStmt
4756:       | pBreak :       @BreakStmt
4760:       | pContinue :    @ContinueStmt
4764:       | pBegin :       @BeginStmt
4768:       | pIdent :       @AssignOrCallStmt
4772:       | * :            % null statement : don't accept any tokens
4799:    ];
      
      
4800: AssignOrCallStmt:
4802:    Node decl = oScopeFindRequire
4807:    [ oNodeType( decl )
4814:       | nProc :                           @Call( decl )
4822:       | nGlobalVar, nLocalVar, nParam :   @AssignStmt( decl )
4831:       | nFunc :                           @AssignResultStmt( decl )
4840:       | * :                               #eBadStatement
4855:    ];
      
      
      % Given decl, the just-accepted first identifier on the left hand side.
      %
4856: AssignStmt( Node decl ):
      
4858:    @LValueVar( decl )
4865:    ':=' 
4867:    @Expr
4869:    @MatchTypes
4871:    @Assign
4874:    ;
      
      
      % Performs a raw assignment.
      % Given lvalue 2nd on stack, and expr value top of stack,
      % and type of both of these on the type stack,
      % perform the assignment and pop the type off the type stack.
      %
4874: Assign:
4876:    [ oTypeSNodeType
4878:       | nIntegerType :            .tAssignI
4881:       | nBooleanType :            .tAssignB
4885:       | nCharType, nStringType, nFileType :   #eNotImplemented
      
            % compound var assigns; addrs of src, dest on stack
4889:       | nPointerType :            .tAssignP
4893:       | * :
4908:           int size = oNodeGetInt( oTypeSTop, qSize )
4920:           .tCopy  oEmitInt( size )    % multi-word copy
4928:    ]
4928:    oTypeSPop
4930:    ;
      
      % Given nFunc for the just-accepted identifier on the left hand side.
      % Parse an assignment that represents assignment of the function result.
      %
4930: AssignResultStmt( Node funcDecl ):
         % Only allowed to assign the result of the immediately enclosing function, I think.
4932:    [ oNodeEqual( oNodeGet( funcDecl, qChildScope ), oScopeCurrent )
4948:       | false :   #eNotCurrentFunction
4951:       | * :
4956:    ]
      
         % Result value is stored in the caller's space, via a hidden VAR parameter.
4956:    .tPushParamP  oEmitInt( oNodeGetInt( funcDecl, qResultOffset ) )
4971:    oTypeSPush( oNodeGet( funcDecl, qType ) )
      
4984:    ':='
4986:    @Expr
4988:    @MatchTypes
4990:    [ oTypeSNodeType
4992:       | nIntegerType :            .tAssignI
4995:       | nBooleanType :            .tAssignB
4999:       | nCharType, nStringType, nFileType :   #eNotImplemented
      
            % compound var assigns; addrs of src, dest on stack
5003:       | nPointerType :            .tAssignP
5007:       | * :
5022:           int size = oNodeGetInt( oTypeSTop, qSize )
5034:           .tCopy  oEmitInt( size )    % multi-word copy
5042:    ]
5042:    oTypeSPop
5044:    ;
      
      
      
      % Parse an lvalue expression, from scratch.
      % This is an expression that may appear on the left side of an assignment.
      % Leaves the address of the value on the expr stack,
      % and the type of the value at that address on the type stack.
      %
5044: LValueExpr:
         % At the moment, all lvalue expressions start with a variable name.
         % I think there can also be typecasts, not supported yet.  Check standard syntax.
5046:    pIdent
5048:    Node decl = oScopeFindRequire
5053:    [ oNodeType( decl )
5060:       | nGlobalVar, nLocalVar, nParam :
5061:       | * :  #eNotVar
5072:    ]
5072:    @LValueVar( decl )
5080:    ;
      
      
      % Parse an lvalue expression (e.g. left side of an assign statement)
      % that starts with the just-accepted identifier indicated by the given decl.
      % Leaves the lvalue address on the expression stack,
      % and the type of the value at that address on the type stack.
      %
5080: LValueVar( Node decl ):
5082:    [ oNodeType( decl )
5089:       | nGlobalVar :   .tPushAddrGlobal @EmitValue( decl )
5099:       | nLocalVar :    .tPushAddrLocal @EmitValue( decl )
5110:       | nParam :
5112:          [ oNodeGetBoolean( decl, qInOut )
5122:             | true :   % VAR param points to variable.  No dereference.
5123:                        .tPushParamP @EmitValue( decl )
5132:             | * :      .tPushAddrParam @EmitValue( decl )
5146:          ]
5146:       | * :            #eNotVar
5157:    ]
      
5157:    oTypeSPush( oNodeGet( decl, qType ) )
5170:    @LValueIndexes        % handle subscripts, if any
5173:    ;
      
      
5173: IncVar( Node decl ):
5175:    @LValueVar( decl )
5182:    @RequireIntPop
5184:    @VarExpr( decl )
5191:    oTypeSPop
5192:    .tIncI
5194:    .tAssignI;
      
5197: DecVar( Node decl ):
5199:    @LValueVar( decl )
5206:    @RequireIntPop
5208:    @VarExpr( decl )
5215:    oTypeSPop
5216:    .tDecI
5218:    .tAssignI;
      
      
5221: IfStmt:
5223:    Label falseLabel = labelNull
      
5229:    @BooleanExprControlFlow( falseLabel )
5236:    pThen
5238:    @Statement
5240:    [
5240:       | pElse :
5242:          Label doneLabel = oLabelNew
      
5247:          .tJump  oEmitLabel( doneLabel )
5255:          .tLabel oEmitLabel( falseLabel )
5263:          @Statement
5265:          .tLabel oEmitLabel( doneLabel )
      
5273:       | * :
5278:          .tLabel oEmitLabel( falseLabel )
5286:    ];
      
      
5287: ForStmt:
5289:    pIdent
      
5291:    Node decl = oScopeFindRequire
         % TO DO: disallow use of a compound variable field.
         %        Could do that by disallowing use of LValueIndexes,
         %        or by double-checking the decl's qType here.
5296:    @LValueVar( decl )
5303:    @RequireIntPop
      
5305:    ':='
      
5307:    @Expr
5309:    @RequireIntPop
5311:    .tAssignI
      
5313:    Label breakLabel = oLabelNew
      
5318:    Label checkLabel = oLabelNew
5323:    .tJump  oEmitLabel( checkLabel )
      
5331:    Label continueLabel = oLabelNew
5336:    .tLabel  oEmitLabel( continueLabel )
5344:    [
5344:       | pTo :
5346:          @IncVar( decl )
5353:          .tLabel  oEmitLabel( checkLabel )
5361:          @VarExpr( decl )  oTypeSPop
5369:          @Expr
5371:          @RequireIntPop
5373:          .tGreaterI
5375:          .tJumpTrue  oEmitLabel( breakLabel )
5383:       | pDownto :
5385:          @DecVar( decl )
5392:          .tLabel  oEmitLabel( checkLabel )
5400:          @VarExpr( decl )  oTypeSPop
5408:          @Expr
5410:          @RequireIntPop
5412:          .tLessI
5414:          .tJumpTrue  oEmitLabel( breakLabel )
5422:    ]
5430:    oLoopPush( continueLabel, breakLabel )
5439:    pDo
5441:    @Statement
5443:    .tJump  oEmitLabel( continueLabel )
5451:    .tLabel  oEmitLabel( breakLabel )
5459:    oLoopPop;
      
      
5461: RepeatStmt:
5463:    Label continueLabel = oLabelNew
5468:    .tLabel  oEmitLabel( continueLabel )
      
5476:    Label breakLabel = oLabelNew
      
5481:    oLoopPush( continueLabel, breakLabel )
5490:    @Statement
5492:    {[
5492:       | ';' :
5494:          @Statement
5496:       | pUntil :
5498:          Label falseLabel
5498:          @BooleanExprControlFlow( falseLabel )
5505:          .tLabelAlias  oEmitLabel( falseLabel )  oEmitLabel( continueLabel )
5519:          >
5521:    ]}
5531:    .tLabel  oEmitLabel( breakLabel )
5539:    oLoopPop;
      
      
5541: WhileStmt:
5543:    Label continueLabel = oLabelNew
5548:    .tLabel  oEmitLabel( continueLabel )
      
5556:    Label breakLabel
5556:    @BooleanExprControlFlow( breakLabel )
      
5563:    oLoopPush( continueLabel, breakLabel )
5572:    pDo
5574:    @Statement
5576:    .tJump  oEmitLabel( continueLabel )
5584:    .tLabel  oEmitLabel( breakLabel )
5592:    oLoopPop;
      
      
5594: ContinueStmt:                     % NOTE, for repeat..until, skips test (??)
5596:    [ equal_label( oLoopContinueLabel, labelNull )
5605:       | true :
5606:          #eNotInALoop
5608:       | false :
5610:          .tJump  oEmitLabel( oLoopContinueLabel )
5617:    ];
      
      
5626: BreakStmt:
5628:    [ equal_label( oLoopBreakLabel, labelNull )
5637:       | true :
5638:          #eNotInALoop
5640:       | false :
5642:          .tJump  oEmitLabel( oLoopBreakLabel )
5649:    ];
      
      
5658: BeginStmt:
5660:    @Statement
5662:    {[
5662:       | ';' :   @Statement
5666:       | pEnd :  >
5670:    ]};
      
      
5681: WritelnStmt:
5683:    @WriteStmt
5685:    .tWriteCR;
      
      
5688: WriteStmt:
5690:    [
5690:       | '(' :
5692:          {
5692:             @Expr
5694:             [ oTypeSNodeType
5696:                | nIntegerType :             .tWriteI
5699:                | nBooleanType :             .tWriteBool
5703:                | nStringType :              .tWriteStr
5707:                | nCharType, nFileType :     #eNotImplemented
5711:                | nPointerType :             .tWriteP
5715:                | * :                        #eNotAllowed
5732:             ]
5732:             oTypeSPop
5733:             [
5733:                | ')' : >
5737:                | ',' :
5739:             ]
5747:          }
5749:       | * :
5754:    ];
      
      
5755: ReadlnStmt:      % ***
         % TO DO
5758:    ;
      
5758: ReadStmt:
         % TO DO
5761:    ;
      
      % -------------------------------- Utilities -------------------------------
      
      
      % Require that the top two types on the type stack are matching (ignoring subranges).
      % Pop one of them, leaving only one.
      %
5761: MatchTypes:
5763:    node_type nt = oTypeSNodeType
5768:    oTypeSPop
5769:    [ equal_node_type( nt, oTypeSNodeType )
5778:       | false :
5779:          #eTypeMismatch
5781:       | * :
5786:    ];
      
      
      % Require that the top type on the type stack is integer (ignoring subranges).
      % Pop it.
      %
5787: RequireIntPop:
5789:    [ oTypeSNodeType
5791:       | nIntegerType :
5792:       | * :          #eNotInteger
5799:    ]
5799:    oTypeSPop;
      
5801: RequireInt:
5803:    [ oTypeSNodeType
5805:       | nIntegerType :
5806:       | * :          #eNotInteger
5813:    ];
      
5814: RequireBoolPop:
5816:    [ oTypeSNodeType
5818:       | nBooleanType :
5819:       | * :          #eNotBoolean
5826:    ]
5826:    oTypeSPop;
      
5828: RequireBool:
5830:    [ oTypeSNodeType
5832:       | nBooleanType :
5833:       | * :          #eNotBoolean
5840:    ];
      
      
      % Create and return a new nType of the given node_type, adding it to the type table.
      %
5841: newType( node_type nt, int size ) >> Node:
5843:   Node node = oNodeNew( nt )
5853:   oNodeSetInt( node, qSize, size )
5865:   oTypeAdd( node )
5871:   >> node
5875:   ;
      
      
      % Create and return a new nIdent of the given node_type, with the given ident id.
      % Does not add it to any scope.
      %
5875: newIdent( node_type nt, kind k, int id ) >> Node:
5877:   Node t = oNodeNew( nt )
5887:   oNodeSetInt( t, qIdent, id )
5899:   >> t
5903:   ;
      
      
      % Return an nType representing a pointer to the given type.
      % (Creates a new type if necessary.)
      %
5903: PointerTypeTo( Node theType ) >> Node:
5905:    Node ptrType = oNodeGet( theType, qPointerType )
5918:    [ oNodeNull( ptrType )
5925:       | true :
5926:          ptrType = oNodeNew( nPointerType )
5936:          oNodeSet( ptrType, qBaseType, theType )
5948:          oNodeSetInt( ptrType, qSize, 8 )
5960:          oTypeAdd( ptrType )
5966:          oNodeSet( theType, qPointerType, ptrType )
5978:       | * :
5983:    ]
5983:    >> ptrType;
      
      
      % Return the low value of an ordinal type
      %
5987: OrdinalLow( Node theType ) >> int:
5989:    [ oNodeType( theType )
5996:       | nIntegerType :  >> oMININT    % NOTE ssl literals are limited to 16 bit at the moment, though values are 32 bit ok. So need a mechanism.
5999:       | nBooleanType :  >> 0
6004:       | nCharType :     >> 0
6009:       | nSubrangeType : >> oNodeGetInt( theType, qLow )
6021:       | * :             #eNotOrdinalType
6034:                         >> 0
6037:    ];
      
      
      
      % Emit the value in a declaration.
      % For a constant integer, this is the constant value.
      % For a global variable, this is the global address.
      % For a local variable, this is the local address relative to the call stack frame.
      %
6038: EmitValue( Node decl ):
6040:     oEmitInt( oNodeGetInt( decl, qValue ));
      
      
6054: installBuiltIns:
      
         % install built-in types
6056:    FileType = @newType( nFileType, 4 )
6070:    IntegerType = @newType( nIntegerType, 4 )
6084:    BooleanType = @newType( nBooleanType, 1 )
6098:    BooleanCFType = @newType( nBooleanCFType, 1 )
6112:    CharType = @newType( nCharType, 1 )
6126:    StringType = @newType( nStringType, 256 )    % string with default length 256
      
         % Declare those type identifiers.
         % SSL doesn't support strings, so need help from operations e.g. oIdAdd_File
      
6140:    Node t
      
6140:    t = @newIdent( nTypeDecl, kType, oIdAdd_File )
6156:    oNodeSet( t, qType, FileType )
6168:    oScopeDeclare( t )
      
6174:    t = @newIdent( nTypeDecl, kType, oIdAdd_Integer )
6190:    oNodeSet( t, qType, IntegerType )
6202:    oScopeDeclare( t )
      
6208:    t = @newIdent( nTypeDecl, kType, oIdAdd_Boolean )
6224:    oNodeSet( t, qType, BooleanType )
6236:    oScopeDeclare( t )
      
6242:    t = @newIdent( nTypeDecl, kType, oIdAdd_Char )
6258:    oNodeSet( t, qType, CharType )
6270:    oScopeDeclare( t )
      
6276:    t = @newIdent( nTypeDecl, kType, oIdAdd_String )
6292:    oNodeSet( t, qType, StringType )
6304:    oScopeDeclare( t )
      
         % Built-in constants
      
6310:    t = @newIdent( nConst, kConst, oIdAdd_True )
6326:    oNodeSet( t, qType, BooleanType )
6338:    oNodeSetInt( t, qValue, 1 )
6350:    oScopeDeclare( t )
      
6356:    t = @newIdent( nConst, kConst, oIdAdd_False )
6372:    oNodeSet( t, qType, BooleanType )
6384:    oNodeSetInt( t, qValue, 0 )
6396:    oScopeDeclare( t )
      
6403:    ;
      
6403: end
      
6403: 

Generated code:

   0: oGlobalSpace 8
   2: oLocalSpace 4
   4: oScopeBegin
   5: oGetAddrGlobal 1
   7: oPushResult
   8: oScopeCurrent
   9: oAssign
  10: oCall 6054
  12: oEmit 44
  14: oSetResult 0
  16: oPushResult
  17: oEmitInt
  18: oPop 1
  20: oGetAddrLocal 2
  22: oPushResult
  23: oLabelNew
  24: oAssign
  25: oEmit 38
  27: oSetResult 0
  29: oPushResult
  30: oEmitInt
  31: oPop 1
  33: oEmit 41
  35: oGetLocal 2
  37: oPushResult
  38: oEmitLabel
  39: oPop 1
  41: oEmit 40
  43: oSetResult 0
  45: oPushResult
  46: oEmitInt
  47: oPop 1
  49: oEmit 43
  51: oInput 27
  53: oInput 0
  55: oGetAddrLocal 3
  57: oPushResult
  58: oSetResult 5
  60: oPushResult
  61: oSetResult 1
  63: oPushResult
  64: LAST_ID
  65: oPushResult
  66: oCall 5875
  68: oPop 3
  70: oAssign
  71: oGetLocal 3
  73: oPushResult
  74: oScopeDeclare
  75: oPop 1
  77: oInputChoice 157
  79: oInput 0
  81: oGetAddrLocal 1
  83: oPushResult
  84: oSetResult 11
  86: oPushResult
  87: oSetResult 6
  89: oPushResult
  90: LAST_ID
  91: oPushResult
  92: oCall 5875
  94: oPop 3
  96: oAssign
  97: oGetLocal 1
  99: oPushResult
 100: oSetResult 6
 102: oPushResult
 103: oGetGlobal 2
 105: oPushResult
 106: oNodeSet
 107: oPop 3
 109: oGetLocal 1
 111: oPushResult
 112: oScopeDeclareAlloc
 113: oPop 1
 115: oInput 12
 117: oInput 0
 119: oGetAddrLocal 1
 121: oPushResult
 122: oSetResult 11
 124: oPushResult
 125: oSetResult 6
 127: oPushResult
 128: LAST_ID
 129: oPushResult
 130: oCall 5875
 132: oPop 3
 134: oAssign
 135: oGetLocal 1
 137: oPushResult
 138: oSetResult 6
 140: oPushResult
 141: oGetGlobal 2
 143: oPushResult
 144: oNodeSet
 145: oPop 3
 147: oGetLocal 1
 149: oPushResult
 150: oScopeDeclareAlloc
 151: oPop 1
 153: oInput 14
 155: oJumpForward 160
 157: Choice Lookup Table
          13     79
 160: oInput 4
 162: oSetResult 12
 164: oPushResult
 165: oCall 231
 167: oPop 1
 169: oGetAddrLocal 4
 171: oPushResult
 172: oScopeCurrent
 173: oAssign
 174: oScopeBegin
 175: oScopeCurrent
 176: oPushResult
 177: oSetResult 3
 179: oPushResult
 180: oSetResult 1
 182: oPushResult
 183: oNodeSetBoolean
 184: oPop 3
 186: oGetLocal 3
 188: oPushResult
 189: oSetResult 8
 191: oPushResult
 192: oScopeCurrent
 193: oPushResult
 194: oNodeSet
 195: oPop 3
 197: oGetLocal 2
 199: oPushResult
 200: oGetLocal 4
 202: oPushResult
 203: oCall 281
 205: oPop 2
 207: oScopeEnd
 208: oInput 19
 210: oScopeEnd
 211: oReturn
 212: oLocalSpace 0
 214: oGetParam 2
 216: oPushResult
 217: oCall 231
 219: oPop 1
 221: oGetParam 1
 223: oPushResult
 224: oScopeCurrent
 225: oPushResult
 226: oCall 281
 228: oPop 2
 230: oReturn
 231: oLocalSpace 0
 233: oInputChoice 260
 235: oCall 1323
 237: oJumpForward 273
 239: oCall 1395
 241: oJumpForward 273
 243: oGetParam 1
 245: oPushResult
 246: oCall 1454
 248: oPop 1
 250: oJumpForward 273
 252: oCall 465
 254: oJumpForward 273
 256: oCall 750
 258: oJumpForward 273
 260: Choice Lookup Table
          29    256
          28    252
          32    243
          31    239
          30    235
 271: oJumpForward 275
 273: oJumpBack 233
 275: oCall 278
 277: oReturn
 278: oLocalSpace 0
 280: oReturn
 281: oLocalSpace 3
 283: oEmit 48
 285: oGetParam 2
 287: oPushResult
 288: oEmitLabel
 289: oPop 1
 291: oEmit 44
 293: oGetAddrLocal 1
 295: oPushResult
 296: Here
 297: oAssign
 298: oEmit 56
 300: oGetAddrLocal 2
 302: oPushResult
 303: oGetParam 1
 305: oPushResult
 306: oSetResult 4
 308: oPushResult
 309: oNodeGetCode
 310: oPop 2
 312: oAssign
 313: oGetLocal 2
 315: oPushResult
 316: oEmitCode
 317: oPop 1
 319: oScopeCurrent
 320: oPushResult
 321: oSetResult 4
 323: oPushResult
 324: oSetResult 0
 326: oPushResult
 327: oNodeSetCode
 328: oPop 3
 330: oCall 4722
 332: oEmit 43
 334: oGetAddrLocal 3
 336: oPushResult
 337: oScopeCurrent
 338: oPushResult
 339: oSetResult 2
 341: oPushResult
 342: oNodeGetInt
 343: oPop 2
 345: oAssign
 346: oGetLocal 1
 348: oPushResult
 349: oGetLocal 3
 351: oPushResult
 352: oPatch
 353: oPop 2
 355: oReturn
 356: oLocalSpace 0
 358: oInputChoice 376
 360: oGetParam 1
 362: oPushResult
 363: oSetResult 13
 365: oPushResult
 366: oSetResult 1
 368: oPushResult
 369: oNodeSetBoolean
 370: oPop 3
 372: oInput 4
 374: oJumpForward 381
 376: Choice Lookup Table
          61    360
 379: oJumpForward 383
 381: oJumpBack 358
 383: oReturn
 384: oLocalSpace 1
 386: oGetAddrLocal 1
 388: oPushResult
 389: oScopeCurrent
 390: oPushResult
 391: oSetResult 4
 393: oPushResult
 394: oNodeGetCode
 395: oPop 2
 397: oAssign
 398: oGetLocal 1
 400: oPushResult
 401: oSetResult 0
 403: oPushResult
 404: equal_code
 405: oPop 2
 407: oChoice 427
 409: oGetAddrLocal 1
 411: oPushResult
 412: oCodeNew
 413: oAssign
 414: oScopeCurrent
 415: oPushResult
 416: oSetResult 4
 418: oPushResult
 419: oGetLocal 1
 421: oPushResult
 422: oNodeSetCode
 423: oPop 3
 425: oJumpForward 430
 427: Choice Lookup Table
           1    409
 430: oGetLocal 1
 432: oReturn
 433: oReturn
 434: oLocalSpace 0
 436: oGetParam 1
 438: oPushResult
 439: oSetResult 12
 441: oPushResult
 442: oSetResult 1
 444: oPushResult
 445: oNodeSetBoolean
 446: oPop 3
 448: oInputChoice 461
 450: oInputChoice 456
 452: oInput 2
 454: oJumpForward 459
 456: Choice Lookup Table
          60    452
 459: oJumpForward 464
 461: Choice Lookup Table
           2    450
 464: oReturn
 465: oLocalSpace 4
 467: oInput 0
 469: oGetAddrLocal 1
 471: oPushResult
 472: oSetResult 0
 474: oAssign
 475: oGetAddrLocal 2
 477: oPushResult
 478: oScopeFindInCurrentScope
 479: oAssign
 480: oGetLocal 2
 482: oPushResult
 483: oNodeNull
 484: oPop 1
 486: oChoice 607
 488: oGetAddrLocal 2
 490: oPushResult
 491: oSetResult 7
 493: oPushResult
 494: oSetResult 2
 496: oPushResult
 497: LAST_ID
 498: oPushResult
 499: oCall 5875
 501: oPop 3
 503: oAssign
 504: oGetLocal 2
 506: oPushResult
 507: oSetResult 7
 509: oPushResult
 510: oLabelNew
 511: oPushResult
 512: oNodeSetLabel
 513: oPop 3
 515: oJumpForward 613
 517: oGetAddrLocal 1
 519: oPushResult
 520: oSetResult 1
 522: oAssign
 523: oGetLocal 2
 525: oPushResult
 526: oSetResult 11
 528: oPushResult
 529: oNodeGetBoolean
 530: oPop 2
 532: oChoice 538
 534: oError 21
 536: oJumpForward 541
 538: Choice Lookup Table
           1    534
 541: oGetLocal 2
 543: oPushResult
 544: oSetResult 12
 546: oPushResult
 547: oNodeGetBoolean
 548: oPop 2
 550: oChoice 556
 552: oError 21
 554: oJumpForward 559
 556: Choice Lookup Table
           1    552
 559: oGetLocal 2
 561: oPushResult
 562: oNodeType
 563: oPop 1
 565: oChoice 569
 567: oJumpForward 574
 569: Choice Lookup Table
           7    567
 572: oError 21
 574: oGetLocal 2
 576: oPushResult
 577: oSetResult 15
 579: oPushResult
 580: oGetLocal 2
 582: oPushResult
 583: oSetResult 9
 585: oPushResult
 586: oNodeGet
 587: oPop 2
 589: oPushResult
 590: oNodeSet
 591: oPop 3
 593: oGetLocal 2
 595: oPushResult
 596: oSetResult 9
 598: oPushResult
 599: oSetResult 0
 601: oPushResult
 602: oNodeSet
 603: oPop 3
 605: oJumpForward 613
 607: Choice Lookup Table
           0    517
           1    488
 612: oEndChoice
 613: oScopeBegin
 614: oGetAddrLocal 3
 616: oPushResult
 617: oScopeCurrent
 618: oAssign
 619: oCall 1096
 621: oGetLocal 2
 623: oPushResult
 624: oSetResult 9
 626: oPushResult
 627: oGetLocal 3
 629: oPushResult
 630: oNodeSet
 631: oPop 3
 633: oScopeEnd
 634: oInput 4
 636: oGetLocal 1
 638: oChoice 650
 640: oGetLocal 2
 642: oPushResult
 643: oScopeDeclare
 644: oPop 1
 646: oJumpForward 656
 648: oJumpForward 656
 650: Choice Lookup Table
           1    648
           0    640
 655: oEndChoice
 656: oGetLocal 2
 658: oPushResult
 659: oCall 356
 661: oPop 1
 663: oInputChoice 676
 665: oJumpForward 747
 667: oGetLocal 2
 669: oPushResult
 670: oCall 434
 672: oPop 1
 674: oJumpForward 747
 676: Choice Lookup Table
          59    667
          58    665
 681: oGetLocal 3
 683: oPushResult
 684: oScopeEnter
 685: oPop 1
 687: oScopeBegin
 688: oScopeCurrent
 689: oPushResult
 690: oSetResult 3
 692: oPushResult
 693: oSetResult 1
 695: oPushResult
 696: oNodeSetBoolean
 697: oPop 3
 699: oGetLocal 2
 701: oPushResult
 702: oSetResult 10
 704: oPushResult
 705: oScopeCurrent
 706: oPushResult
 707: oNodeSet
 708: oPop 3
 710: oGetAddrLocal 4
 712: oPushResult
 713: oGetLocal 2
 715: oPushResult
 716: oSetResult 7
 718: oPushResult
 719: oNodeGetLabel
 720: oPop 2
 722: oAssign
 723: oSetResult 13
 725: oPushResult
 726: oGetLocal 4
 728: oPushResult
 729: oCall 212
 731: oPop 2
 733: oGetLocal 2
 735: oPushResult
 736: oSetResult 11
 738: oPushResult
 739: oSetResult 1
 741: oPushResult
 742: oNodeSetBoolean
 743: oPop 3
 745: oScopeEnd
 746: oScopeEnd
 747: oInput 4
 749: oReturn
 750: oLocalSpace 6
 752: oInput 0
 754: oGetAddrLocal 1
 756: oPushResult
 757: oSetResult 0
 759: oAssign
 760: oGetAddrLocal 2
 762: oPushResult
 763: oScopeFindInCurrentScope
 764: oAssign
 765: oGetLocal 2
 767: oPushResult
 768: oNodeNull
 769: oPop 1
 771: oChoice 905
 773: oGetAddrLocal 2
 775: oPushResult
 776: oSetResult 8
 778: oPushResult
 779: oSetResult 3
 781: oPushResult
 782: LAST_ID
 783: oPushResult
 784: oCall 5875
 786: oPop 3
 788: oAssign
 789: oGetLocal 2
 791: oPushResult
 792: oSetResult 7
 794: oPushResult
 795: oLabelNew
 796: oPushResult
 797: oNodeSetLabel
 798: oPop 3
 800: oJumpForward 911
 802: oGetAddrLocal 1
 804: oPushResult
 805: oSetResult 1
 807: oAssign
 808: oGetLocal 2
 810: oPushResult
 811: oSetResult 11
 813: oPushResult
 814: oNodeGetBoolean
 815: oPop 2
 817: oChoice 823
 819: oError 21
 821: oJumpForward 826
 823: Choice Lookup Table
           1    819
 826: oGetLocal 2
 828: oPushResult
 829: oNodeType
 830: oPop 1
 832: oChoice 836
 834: oJumpForward 841
 836: Choice Lookup Table
           8    834
 839: oError 21
 841: oGetLocal 2
 843: oPushResult
 844: oSetResult 15
 846: oPushResult
 847: oGetLocal 2
 849: oPushResult
 850: oSetResult 9
 852: oPushResult
 853: oNodeGet
 854: oPop 2
 856: oPushResult
 857: oNodeSet
 858: oPop 3
 860: oGetLocal 2
 862: oPushResult
 863: oSetResult 9
 865: oPushResult
 866: oSetResult 0
 868: oPushResult
 869: oNodeSet
 870: oPop 3
 872: oGetLocal 2
 874: oPushResult
 875: oSetResult 16
 877: oPushResult
 878: oGetLocal 2
 880: oPushResult
 881: oSetResult 6
 883: oPushResult
 884: oNodeGet
 885: oPop 2
 887: oPushResult
 888: oNodeSet
 889: oPop 3
 891: oGetLocal 2
 893: oPushResult
 894: oSetResult 6
 896: oPushResult
 897: oSetResult 0
 899: oPushResult
 900: oNodeSet
 901: oPop 3
 903: oJumpForward 911
 905: Choice Lookup Table
           0    802
           1    773
 910: oEndChoice
 911: oScopeBegin
 912: oGetAddrLocal 3
 914: oPushResult
 915: oScopeCurrent
 916: oAssign
 917: oCall 1096
 919: oGetLocal 2
 921: oPushResult
 922: oSetResult 9
 924: oPushResult
 925: oGetLocal 3
 927: oPushResult
 928: oNodeSet
 929: oPop 3
 931: oInput 11
 933: oGetAddrLocal 4
 935: oPushResult
 936: oCall 1643
 938: oPop 1
 940: oGetLocal 2
 942: oPushResult
 943: oSetResult 6
 945: oPushResult
 946: oGetLocal 4
 948: oPushResult
 949: oNodeSet
 950: oPop 3
 952: oGetAddrLocal 5
 954: oPushResult
 955: oGetLocal 4
 957: oPushResult
 958: oCall 5903
 960: oPop 1
 962: oAssign
 963: oGetLocal 2
 965: oPushResult
 966: oSetResult 17
 968: oPushResult
 969: oGetLocal 5
 971: oPushResult
 972: oScopeAllocType
 973: oPop 1
 975: oPushResult
 976: oNodeSetInt
 977: oPop 3
 979: oScopeEnd
 980: oInput 4
 982: oGetLocal 1
 984: oChoice 996
 986: oGetLocal 2
 988: oPushResult
 989: oScopeDeclare
 990: oPop 1
 992: oJumpForward 1002
 994: oJumpForward 1002
 996: Choice Lookup Table
           1    994
           0    986
1001: oEndChoice
1002: oGetLocal 2
1004: oPushResult
1005: oCall 356
1007: oPop 1
1009: oInputChoice 1022
1011: oJumpForward 1093
1013: oGetLocal 2
1015: oPushResult
1016: oCall 434
1018: oPop 1
1020: oJumpForward 1093
1022: Choice Lookup Table
          59   1013
          58   1011
1027: oGetLocal 3
1029: oPushResult
1030: oScopeEnter
1031: oPop 1
1033: oScopeBegin
1034: oScopeCurrent
1035: oPushResult
1036: oSetResult 3
1038: oPushResult
1039: oSetResult 1
1041: oPushResult
1042: oNodeSetBoolean
1043: oPop 3
1045: oGetLocal 2
1047: oPushResult
1048: oSetResult 10
1050: oPushResult
1051: oScopeCurrent
1052: oPushResult
1053: oNodeSet
1054: oPop 3
1056: oGetAddrLocal 6
1058: oPushResult
1059: oGetLocal 2
1061: oPushResult
1062: oSetResult 7
1064: oPushResult
1065: oNodeGetLabel
1066: oPop 2
1068: oAssign
1069: oSetResult 13
1071: oPushResult
1072: oGetLocal 6
1074: oPushResult
1075: oCall 212
1077: oPop 2
1079: oGetLocal 2
1081: oPushResult
1082: oSetResult 11
1084: oPushResult
1085: oSetResult 1
1087: oPushResult
1088: oNodeSetBoolean
1089: oPop 3
1091: oScopeEnd
1092: oScopeEnd
1093: oInput 4
1095: oReturn
1096: oLocalSpace 6
1098: oInputChoice 1319
1100: oGetAddrLocal 1
1102: oPushResult
1103: oNodeVecNew
1104: oAssign
1105: oGetAddrLocal 3
1107: oPushResult
1108: oSetResult 0
1110: oAssign
1111: oInputChoice 1121
1113: oGetAddrLocal 3
1115: oPushResult
1116: oSetResult 1
1118: oAssign
1119: oJumpForward 1124
1121: Choice Lookup Table
          32   1113
1124: oInput 0
1126: oGetAddrLocal 2
1128: oPushResult
1129: oSetResult 15
1131: oPushResult
1132: oSetResult 6
1134: oPushResult
1135: LAST_ID
1136: oPushResult
1137: oCall 5875
1139: oPop 3
1141: oAssign
1142: oGetLocal 2
1144: oPushResult
1145: oSetResult 18
1147: oPushResult
1148: oGetLocal 3
1150: oPushResult
1151: oNodeSetBoolean
1152: oPop 3
1154: oGetLocal 1
1156: oPushResult
1157: oGetLocal 2
1159: oPushResult
1160: oNodeVecAppend
1161: oPop 2
1163: oInputChoice 1171
1165: oJumpForward 1179
1167: oJumpForward 1177
1169: oJumpForward 1177
1171: Choice Lookup Table
          12   1169
          11   1165
1176: oEndChoice
1177: oJumpBack 1124
1179: oGetAddrLocal 4
1181: oPushResult
1182: oCall 1643
1184: oPop 1
1186: oGetLocal 3
1188: oChoice 1203
1190: oGetAddrLocal 5
1192: oPushResult
1193: oGetLocal 4
1195: oPushResult
1196: oCall 5903
1198: oPop 1
1200: oAssign
1201: oJumpForward 1212
1203: Choice Lookup Table
           1   1190
1206: oGetAddrLocal 5
1208: oPushResult
1209: oGetLocal 4
1211: oAssign
1212: oGetAddrLocal 6
1214: oPushResult
1215: oSetResult 0
1217: oAssign
1218: oGetLocal 6
1220: oPushResult
1221: oGetLocal 1
1223: oPushResult
1224: oNodeVecSize
1225: oPop 1
1227: oPushResult
1228: equal
1229: oPop 2
1231: oChoice 1288
1233: oGetAddrLocal 2
1235: oPushResult
1236: oGetLocal 1
1238: oPushResult
1239: oGetLocal 6
1241: oPushResult
1242: oNodeVecElement
1243: oPop 2
1245: oAssign
1246: oGetLocal 2
1248: oPushResult
1249: oSetResult 6
1251: oPushResult
1252: oGetLocal 4
1254: oPushResult
1255: oNodeSet
1256: oPop 3
1258: oGetLocal 2
1260: oPushResult
1261: oScopeDeclare
1262: oPop 1
1264: oGetLocal 2
1266: oPushResult
1267: oSetResult 7
1269: oPushResult
1270: oGetLocal 5
1272: oPushResult
1273: oScopeAllocType
1274: oPop 1
1276: oPushResult
1277: oNodeSetInt
1278: oPop 3
1280: oGetAddrLocal 6
1282: oPushResult
1283: inc
1284: oPop 1
1286: oJumpForward 1293
1288: Choice Lookup Table
           0   1233
1291: oJumpForward 1295
1293: oJumpBack 1218
1295: oGetLocal 1
1297: oPushResult
1298: oNodeVecDelete
1299: oPop 1
1301: oInputChoice 1309
1303: oJumpForward 1317
1305: oJumpForward 1315
1307: oJumpForward 1315
1309: Choice Lookup Table
           4   1307
          14   1303
1314: oEndChoice
1315: oJumpBack 1100
1317: oJumpForward 1322
1319: Choice Lookup Table
          13   1100
1322: oReturn
1323: oLocalSpace 2
1325: oInputChoice 1387
1327: oGetAddrLocal 1
1329: oPushResult
1330: oSetResult 9
1332: oPushResult
1333: oSetResult 4
1335: oPushResult
1336: LAST_ID
1337: oPushResult
1338: oCall 5875
1340: oPop 3
1342: oAssign
1343: oInput 5
1345: oCall 2112
1347: oGetAddrLocal 2
1349: oPushResult
1350: oValueTop
1351: oAssign
1352: oValuePop
1353: oGetLocal 1
1355: oPushResult
1356: oSetResult 7
1358: oPushResult
1359: oGetLocal 2
1361: oPushResult
1362: oNodeSetInt
1363: oPop 3
1365: oGetLocal 1
1367: oPushResult
1368: oSetResult 6
1370: oPushResult
1371: oGetGlobal 3
1373: oPushResult
1374: oNodeSet
1375: oPop 3
1377: oGetLocal 1
1379: oPushResult
1380: oScopeDeclare
1381: oPop 1
1383: oInput 4
1385: oJumpForward 1392
1387: Choice Lookup Table
           0   1327
1390: oJumpForward 1394
1392: oJumpBack 1325
1394: oReturn
1395: oLocalSpace 2
1397: oInputChoice 1446
1399: oGetAddrLocal 1
1401: oPushResult
1402: oSetResult 10
1404: oPushResult
1405: oSetResult 5
1407: oPushResult
1408: LAST_ID
1409: oPushResult
1410: oCall 5875
1412: oPop 3
1414: oAssign
1415: oInput 5
1417: oGetAddrLocal 2
1419: oPushResult
1420: oCall 1643
1422: oPop 1
1424: oGetLocal 1
1426: oPushResult
1427: oSetResult 6
1429: oPushResult
1430: oGetLocal 2
1432: oPushResult
1433: oNodeSet
1434: oPop 3
1436: oGetLocal 1
1438: oPushResult
1439: oScopeDeclare
1440: oPop 1
1442: oInput 4
1444: oJumpForward 1451
1446: Choice Lookup Table
           0   1399
1449: oJumpForward 1453
1451: oJumpBack 1397
1453: oReturn
1454: oLocalSpace 5
1456: oInputChoice 1635
1458: oGetAddrLocal 1
1460: oPushResult
1461: oNodeVecNew
1462: oAssign
1463: oGetAddrLocal 2
1465: oPushResult
1466: oGetParam 1
1468: oPushResult
1469: oSetResult 6
1471: oPushResult
1472: LAST_ID
1473: oPushResult
1474: oCall 5875
1476: oPop 3
1478: oAssign
1479: oGetLocal 1
1481: oPushResult
1482: oGetLocal 2
1484: oPushResult
1485: oNodeVecAppend
1486: oPop 2
1488: oInputChoice 1494
1490: oInput 0
1492: oJumpForward 1499
1494: Choice Lookup Table
          12   1490
1497: oJumpForward 1501
1499: oJumpBack 1463
1501: oInput 11
1503: oGetAddrLocal 3
1505: oPushResult
1506: oCall 1643
1508: oPop 1
1510: oGetAddrLocal 4
1512: oPushResult
1513: oSetResult 0
1515: oAssign
1516: oGetLocal 4
1518: oPushResult
1519: oGetLocal 1
1521: oPushResult
1522: oNodeVecSize
1523: oPop 1
1525: oPushResult
1526: equal
1527: oPop 2
1529: oChoice 1570
1531: oGetAddrLocal 2
1533: oPushResult
1534: oGetLocal 1
1536: oPushResult
1537: oGetLocal 4
1539: oPushResult
1540: oNodeVecElement
1541: oPop 2
1543: oAssign
1544: oGetLocal 2
1546: oPushResult
1547: oSetResult 6
1549: oPushResult
1550: oGetLocal 3
1552: oPushResult
1553: oNodeSet
1554: oPop 3
1556: oGetLocal 2
1558: oPushResult
1559: oScopeDeclareAlloc
1560: oPop 1
1562: oGetAddrLocal 4
1564: oPushResult
1565: inc
1566: oPop 1
1568: oJumpForward 1575
1570: Choice Lookup Table
           0   1531
1573: oJumpForward 1577
1575: oJumpBack 1516
1577: oInputChoice 1622
1579: oGetLocal 1
1581: oPushResult
1582: oNodeVecSize
1583: oPop 1
1585: oChoice 1589
1587: oJumpForward 1594
1589: Choice Lookup Table
           1   1587
1592: oError 22
1594: oGetAddrLocal 5
1596: oPushResult
1597: oCall 384
1599: oAssign
1600: oGetLocal 5
1602: oPushResult
1603: oCodePush
1604: oPop 1
1606: oGetLocal 2
1608: oPushResult
1609: oCall 5080
1611: oPop 1
1613: oCall 2178
1615: oCall 5761
1617: oCall 4874
1619: oCodePop
1620: oJumpForward 1625
1622: Choice Lookup Table
           5   1579
1625: oGetLocal 1
1627: oPushResult
1628: oNodeVecDelete
1629: oPop 1
1631: oInput 4
1633: oJumpForward 1640
1635: Choice Lookup Table
           0   1458
1638: oJumpForward 1642
1640: oJumpBack 1456
1642: oReturn
1643: oLocalSpace 12
1645: oInputChoice 2094
1647: oGetAddrLocal 1
1649: oPushResult
1650: oScopeFindRequire
1651: oAssign
1652: oGetLocal 1
1654: oPushResult
1655: oNodeType
1656: oPop 1
1658: oChoice 1675
1660: oGetParam 1
1662: oPushResult
1663: oGetLocal 1
1665: oPushResult
1666: oSetResult 6
1668: oPushResult
1669: oNodeGet
1670: oPop 2
1672: oAssign
1673: oJumpForward 1686
1675: Choice Lookup Table
          10   1660
1678: oError 2
1680: oGetParam 1
1682: oPushResult
1683: oGetGlobal 3
1685: oAssign
1686: oJumpForward 2111
1688: oInput 15
1690: oGetAddrLocal 2
1692: oPushResult
1693: oNodeVecNew
1694: oAssign
1695: oGetAddrLocal 3
1697: oPushResult
1698: oSetResult 25
1700: oPushResult
1701: oNodeNew
1702: oPop 1
1704: oAssign
1705: oGetLocal 3
1707: oPushResult
1708: oSetResult 20
1710: oPushResult
1711: oGetGlobal 3
1713: oPushResult
1714: oNodeSet
1715: oPop 3
1717: oCall 2112
1719: oGetLocal 3
1721: oPushResult
1722: oSetResult 22
1724: oPushResult
1725: oValueTop
1726: oPushResult
1727: oNodeSetInt
1728: oPop 3
1730: oValuePop
1731: oInput 20
1733: oCall 2112
1735: oGetLocal 3
1737: oPushResult
1738: oSetResult 23
1740: oPushResult
1741: oValueTop
1742: oPushResult
1743: oNodeSetInt
1744: oPop 3
1746: oValuePop
1747: oGetLocal 3
1749: oPushResult
1750: oSetResult 2
1752: oPushResult
1753: oSetResult 4
1755: oPushResult
1756: oNodeSetInt
1757: oPop 3
1759: oGetLocal 3
1761: oPushResult
1762: oTypeAdd
1763: oPop 1
1765: oGetAddrLocal 4
1767: oPushResult
1768: oSetResult 24
1770: oPushResult
1771: oNodeNew
1772: oPop 1
1774: oAssign
1775: oGetLocal 4
1777: oPushResult
1778: oSetResult 21
1780: oPushResult
1781: oGetLocal 3
1783: oPushResult
1784: oNodeSet
1785: oPop 3
1787: oGetLocal 2
1789: oPushResult
1790: oGetLocal 4
1792: oPushResult
1793: oNodeVecAppend
1794: oPop 2
1796: oInputChoice 1804
1798: oJumpForward 1812
1800: oJumpForward 1810
1802: oJumpForward 1810
1804: Choice Lookup Table
          12   1802
          16   1798
1809: oEndChoice
1810: oJumpBack 1695
1812: oInput 38
1814: oGetAddrLocal 5
1816: oPushResult
1817: oCall 1643
1819: oPop 1
1821: oGetAddrLocal 6
1823: oPushResult
1824: oGetLocal 2
1826: oPushResult
1827: oNodeVecSize
1828: oPop 1
1830: oAssign
1831: oGetAddrLocal 6
1833: oPushResult
1834: dec
1835: oPop 1
1837: oGetAddrLocal 7
1839: oPushResult
1840: oGetLocal 2
1842: oPushResult
1843: oGetLocal 6
1845: oPushResult
1846: oNodeVecElement
1847: oPop 2
1849: oAssign
1850: oGetLocal 7
1852: oPushResult
1853: oSetResult 20
1855: oPushResult
1856: oGetLocal 5
1858: oPushResult
1859: oNodeSet
1860: oPop 3
1862: oGetAddrLocal 8
1864: oPushResult
1865: oGetLocal 7
1867: oPushResult
1868: oSetResult 21
1870: oPushResult
1871: oNodeGet
1872: oPop 2
1874: oAssign
1875: oGetAddrLocal 9
1877: oPushResult
1878: oGetLocal 8
1880: oPushResult
1881: oSetResult 23
1883: oPushResult
1884: oNodeGetInt
1885: oPop 2
1887: oPushResult
1888: oGetLocal 8
1890: oPushResult
1891: oSetResult 22
1893: oPushResult
1894: oNodeGetInt
1895: oPop 2
1897: oPushResult
1898: subtract
1899: oPop 2
1901: oAssign
1902: oGetAddrLocal 9
1904: oPushResult
1905: inc
1906: oPop 1
1908: oGetLocal 7
1910: oPushResult
1911: oSetResult 2
1913: oPushResult
1914: oGetLocal 9
1916: oPushResult
1917: oGetLocal 5
1919: oPushResult
1920: oSetResult 2
1922: oPushResult
1923: oNodeGetInt
1924: oPop 2
1926: oPushResult
1927: multiply
1928: oPop 2
1930: oPushResult
1931: oNodeSetInt
1932: oPop 3
1934: oGetLocal 7
1936: oPushResult
1937: oTypeAdd
1938: oPop 1
1940: oGetAddrLocal 5
1942: oPushResult
1943: oGetLocal 7
1945: oAssign
1946: oGetLocal 6
1948: oPushResult
1949: equal_zero
1950: oPop 1
1952: oChoice 1958
1954: oJumpForward 1963
1956: oJumpForward 1961
1958: Choice Lookup Table
           1   1954
1961: oJumpBack 1831
1963: oGetParam 1
1965: oPushResult
1966: oGetLocal 2
1968: oPushResult
1969: oSetResult 0
1971: oPushResult
1972: oNodeVecElement
1973: oPop 2
1975: oAssign
1976: oGetLocal 2
1978: oPushResult
1979: oNodeVecDelete
1980: oPop 1
1982: oJumpForward 2111
1984: oGetAddrLocal 10
1986: oPushResult
1987: oCall 1643
1989: oPop 1
1991: oGetParam 1
1993: oPushResult
1994: oGetLocal 10
1996: oPushResult
1997: oCall 5903
1999: oPop 1
2001: oAssign
2002: oJumpForward 2111
2004: oGetParam 1
2006: oPushResult
2007: oSetResult 26
2009: oPushResult
2010: oNodeNew
2011: oPop 1
2013: oAssign
2014: oScopeBegin
2015: oSetResult 14
2017: oPushResult
2018: oCall 1454
2020: oPop 1
2022: oGetAddrLocal 11
2024: oPushResult
2025: oScopeCurrent
2026: oPushResult
2027: oSetResult 2
2029: oPushResult
2030: oNodeGetInt
2031: oPop 2
2033: oAssign
2034: oGetLocal 11
2036: oPushResult
2037: equal_zero
2038: oPop 1
2040: oChoice 2046
2042: oError 19
2044: oJumpForward 2049
2046: Choice Lookup Table
           1   2042
2049: oInput 34
2051: oGetFromParam 1
2053: oPushResult
2054: oSetResult 24
2056: oPushResult
2057: oScopeCurrent
2058: oPushResult
2059: oNodeSet
2060: oPop 3
2062: oGetFromParam 1
2064: oPushResult
2065: oSetResult 2
2067: oPushResult
2068: oGetLocal 11
2070: oPushResult
2071: oNodeSetInt
2072: oPop 3
2074: oScopeEnd
2075: oGetFromParam 1
2077: oPushResult
2078: oTypeAdd
2079: oPop 1
2081: oJumpForward 2111
2083: oInput 38
2085: oGetAddrLocal 12
2087: oPushResult
2088: oCall 1643
2090: oPop 1
2092: oJumpForward 2111
2094: Choice Lookup Table
          37   2083
          36   2004
          17   1984
          35   1688
           0   1647
2105: oCall 2112
2107: oInput 20
2109: oCall 2112
2111: oReturn
2112: oLocalSpace 1
2114: oInputChoice 2169
2116: TOKEN_VALUE
2117: oPushResult
2118: oValuePush
2119: oPop 1
2121: oJumpForward 2177
2123: oGetAddrLocal 1
2125: oPushResult
2126: oScopeFindRequire
2127: oAssign
2128: oGetLocal 1
2130: oPushResult
2131: oNodeType
2132: oPop 1
2134: oChoice 2151
2136: oGetLocal 1
2138: oPushResult
2139: oSetResult 7
2141: oPushResult
2142: oNodeGetInt
2143: oPop 2
2145: oPushResult
2146: oValuePush
2147: oPop 1
2149: oJumpForward 2162
2151: Choice Lookup Table
           9   2136
2154: oError 1
2156: oSetResult 0
2158: oPushResult
2159: oValuePush
2160: oPop 1
2162: oJumpForward 2177
2164: oCall 2112
2166: oValueNegate
2167: oJumpForward 2177
2169: Choice Lookup Table
          24   2164
           0   2123
           1   2116
2176: oEndChoice
2177: oReturn
2178: oLocalSpace 1
2180: oGetAddrLocal 1
2182: oPushResult
2183: oSetResult 0
2185: oAssign
2186: oGetAddrLocal 1
2188: oPushResult
2189: oCall 2339
2191: oPop 1
2193: oGetAddrLocal 1
2195: oPushResult
2196: oCall 2239
2198: oPop 1
2200: oReturn
2201: oLocalSpace 0
2203: oGetParam 1
2205: oPushResult
2206: oCall 2339
2208: oPop 1
2210: oTypeSNodeType
2211: oChoice 2230
2213: oJumpForward 2237
2215: oGetParam 1
2217: oPushResult
2218: oLabelNew
2219: oAssign
2220: oEmit 47
2222: oGetFromParam 1
2224: oPushResult
2225: oEmitLabel
2226: oPop 1
2228: oJumpForward 2237
2230: Choice Lookup Table
          19   2215
          20   2213
2235: oError 8
2237: oTypeSPop
2238: oReturn
2239: oLocalSpace 1
2241: oTypeSNodeType
2242: oChoice 2304
2244: oGetAddrLocal 1
2246: oPushResult
2247: oLabelNew
2248: oAssign
2249: oEmit 9
2251: oSetResult 1
2253: oPushResult
2254: oEmitInt
2255: oPop 1
2257: oEmit 45
2259: oGetLocal 1
2261: oPushResult
2262: oEmitLabel
2263: oPop 1
2265: oEmit 48
2267: oGetFromParam 1
2269: oPushResult
2270: oEmitLabel
2271: oPop 1
2273: oEmit 9
2275: oSetResult 0
2277: oPushResult
2278: oEmitInt
2279: oPop 1
2281: oEmit 48
2283: oGetLocal 1
2285: oPushResult
2286: oEmitLabel
2287: oPop 1
2289: oTypeSPop
2290: oGetGlobal 4
2292: oPushResult
2293: oTypeSPush
2294: oPop 1
2296: oGetParam 1
2298: oPushResult
2299: oSetResult 0
2301: oAssign
2302: oJumpForward 2307
2304: Choice Lookup Table
          20   2244
2307: oReturn
2308: oLocalSpace 0
2310: oTypeSNodeType
2311: oChoice 2335
2313: oGetParam 1
2315: oPushResult
2316: oLabelNew
2317: oAssign
2318: oEmit 47
2320: oGetFromParam 1
2322: oPushResult
2323: oEmitLabel
2324: oPop 1
2326: oTypeSPop
2327: oGetGlobal 5
2329: oPushResult
2330: oTypeSPush
2331: oPop 1
2333: oJumpForward 2338
2335: Choice Lookup Table
          19   2313
2338: oReturn
2339: oLocalSpace 0
2341: oGetParam 1
2343: oPushResult
2344: oCall 2704
2346: oPop 1
2348: oInputChoice 2686
2350: oGetParam 1
2352: oPushResult
2353: oCall 2239
2355: oPop 1
2357: oGetParam 1
2359: oPushResult
2360: oCall 2704
2362: oPop 1
2364: oGetParam 1
2366: oPushResult
2367: oCall 2239
2369: oPop 1
2371: oCall 5761
2373: oTypeSNodeType
2374: oChoice 2388
2376: oEmit 30
2378: oJumpForward 2401
2380: oEmit 36
2382: oJumpForward 2401
2384: oError 16
2386: oJumpForward 2401
2388: Choice Lookup Table
          22   2384
          21   2384
          23   2380
          19   2376
          18   2376
2399: oError 17
2401: oTypeSPop
2402: oGetGlobal 4
2404: oPushResult
2405: oTypeSPush
2406: oPop 1
2408: oJumpForward 2701
2410: oGetParam 1
2412: oPushResult
2413: oCall 2239
2415: oPop 1
2417: oGetParam 1
2419: oPushResult
2420: oCall 2704
2422: oPop 1
2424: oGetParam 1
2426: oPushResult
2427: oCall 2239
2429: oPop 1
2431: oCall 5761
2433: oTypeSNodeType
2434: oChoice 2448
2436: oEmit 31
2438: oJumpForward 2461
2440: oEmit 37
2442: oJumpForward 2461
2444: oError 16
2446: oJumpForward 2461
2448: Choice Lookup Table
          22   2444
          21   2444
          23   2440
          19   2436
          18   2436
2459: oError 17
2461: oTypeSPop
2462: oGetGlobal 4
2464: oPushResult
2465: oTypeSPush
2466: oPop 1
2468: oJumpForward 2701
2470: oGetParam 1
2472: oPushResult
2473: oCall 2239
2475: oPop 1
2477: oGetParam 1
2479: oPushResult
2480: oCall 2704
2482: oPop 1
2484: oGetParam 1
2486: oPushResult
2487: oCall 2239
2489: oPop 1
2491: oCall 5761
2493: oTypeSNodeType
2494: oChoice 2504
2496: oEmit 33
2498: oJumpForward 2515
2500: oError 16
2502: oJumpForward 2515
2504: Choice Lookup Table
          22   2500
          21   2500
          19   2496
          18   2496
2513: oError 17
2515: oTypeSPop
2516: oGetGlobal 4
2518: oPushResult
2519: oTypeSPush
2520: oPop 1
2522: oJumpForward 2701
2524: oGetParam 1
2526: oPushResult
2527: oCall 2239
2529: oPop 1
2531: oGetParam 1
2533: oPushResult
2534: oCall 2704
2536: oPop 1
2538: oGetParam 1
2540: oPushResult
2541: oCall 2239
2543: oPop 1
2545: oCall 5761
2547: oTypeSNodeType
2548: oChoice 2558
2550: oEmit 32
2552: oJumpForward 2569
2554: oError 16
2556: oJumpForward 2569
2558: Choice Lookup Table
          22   2554
          21   2554
          19   2550
          18   2550
2567: oError 17
2569: oTypeSPop
2570: oGetGlobal 4
2572: oPushResult
2573: oTypeSPush
2574: oPop 1
2576: oJumpForward 2701
2578: oGetParam 1
2580: oPushResult
2581: oCall 2239
2583: oPop 1
2585: oGetParam 1
2587: oPushResult
2588: oCall 2704
2590: oPop 1
2592: oGetParam 1
2594: oPushResult
2595: oCall 2239
2597: oPop 1
2599: oCall 5761
2601: oTypeSNodeType
2602: oChoice 2612
2604: oEmit 35
2606: oJumpForward 2623
2608: oError 16
2610: oJumpForward 2623
2612: Choice Lookup Table
          22   2608
          21   2608
          19   2604
          18   2604
2621: oError 17
2623: oTypeSPop
2624: oGetGlobal 4
2626: oPushResult
2627: oTypeSPush
2628: oPop 1
2630: oJumpForward 2701
2632: oGetParam 1
2634: oPushResult
2635: oCall 2239
2637: oPop 1
2639: oGetParam 1
2641: oPushResult
2642: oCall 2704
2644: oPop 1
2646: oGetParam 1
2648: oPushResult
2649: oCall 2239
2651: oPop 1
2653: oCall 5761
2655: oTypeSNodeType
2656: oChoice 2666
2658: oEmit 34
2660: oJumpForward 2677
2662: oError 16
2664: oJumpForward 2677
2666: Choice Lookup Table
          22   2662
          21   2662
          19   2658
          18   2658
2675: oError 17
2677: oTypeSPop
2678: oGetGlobal 4
2680: oPushResult
2681: oTypeSPush
2682: oPop 1
2684: oJumpForward 2701
2686: Choice Lookup Table
          10   2632
           9   2578
           8   2524
           7   2470
           6   2410
           5   2350
2699: oJumpForward 2703
2701: oJumpBack 2348
2703: oReturn
2704: oLocalSpace 1
2706: oGetAddrLocal 1
2708: oPushResult
2709: oSetResult 0
2711: oAssign
2712: oGetParam 1
2714: oPushResult
2715: oCall 2884
2717: oPop 1
2719: oInputChoice 2852
2721: oTypeSNodeType
2722: oChoice 2793
2724: oGetLocal 1
2726: oPushResult
2727: oSetResult 0
2729: oPushResult
2730: equal_label
2731: oPop 2
2733: oChoice 2742
2735: oGetAddrLocal 1
2737: oPushResult
2738: oLabelNew
2739: oAssign
2740: oJumpForward 2745
2742: Choice Lookup Table
           1   2735
2745: oEmit 45
2747: oGetLocal 1
2749: oPushResult
2750: oEmitLabel
2751: oPop 1
2753: oJumpForward 2800
2755: oGetParam 1
2757: oPushResult
2758: oCall 2308
2760: oPop 1
2762: oGetLocal 1
2764: oPushResult
2765: oSetResult 0
2767: oPushResult
2768: equal_label
2769: oPop 2
2771: oChoice 2780
2773: oGetAddrLocal 1
2775: oPushResult
2776: oLabelNew
2777: oAssign
2778: oJumpForward 2783
2780: Choice Lookup Table
           1   2773
2783: oEmit 45
2785: oGetLocal 1
2787: oPushResult
2788: oEmitLabel
2789: oPop 1
2791: oJumpForward 2800
2793: Choice Lookup Table
          19   2755
          20   2724
2798: oError 8
2800: oTypeSPop
2801: oEmit 48
2803: oGetFromParam 1
2805: oPushResult
2806: oEmitLabel
2807: oPop 1
2809: oGetParam 1
2811: oPushResult
2812: oSetResult 0
2814: oAssign
2815: oGetParam 1
2817: oPushResult
2818: oCall 2884
2820: oPop 1
2822: oTypeSNodeType
2823: oChoice 2836
2825: oJumpForward 2843
2827: oGetParam 1
2829: oPushResult
2830: oCall 2308
2832: oPop 1
2834: oJumpForward 2843
2836: Choice Lookup Table
          19   2827
          20   2825
2841: oError 8
2843: oTypeSPop
2844: oGetGlobal 5
2846: oPushResult
2847: oTypeSPush
2848: oPop 1
2850: oJumpForward 2857
2852: Choice Lookup Table
          52   2721
2855: oJumpForward 2859
2857: oJumpBack 2719
2859: oGetLocal 1
2861: oPushResult
2862: oSetResult 0
2864: oPushResult
2865: equal_label
2866: oPop 2
2868: oChoice 2880
2870: oEmit 48
2872: oGetLocal 1
2874: oPushResult
2875: oEmitLabel
2876: oPop 1
2878: oJumpForward 2883
2880: Choice Lookup Table
           0   2870
2883: oReturn
2884: oLocalSpace 2
2886: oGetAddrLocal 1
2888: oPushResult
2889: oSetResult 0
2891: oAssign
2892: oGetParam 1
2894: oPushResult
2895: oCall 3022
2897: oPop 1
2899: oInputChoice 3014
2901: oTypeSNodeType
2902: oChoice 2915
2904: oJumpForward 2922
2906: oGetParam 1
2908: oPushResult
2909: oCall 2308
2911: oPop 1
2913: oJumpForward 2922
2915: Choice Lookup Table
          19   2906
          20   2904
2920: oError 8
2922: oTypeSPop
2923: oGetLocal 1
2925: oPushResult
2926: oSetResult 0
2928: oPushResult
2929: equal_label
2930: oPop 2
2932: oChoice 2961
2934: oGetAddrLocal 1
2936: oPushResult
2937: oLabelNew
2938: oAssign
2939: oEmit 49
2941: oGetFromParam 1
2943: oPushResult
2944: oEmitLabel
2945: oPop 1
2947: oGetLocal 1
2949: oPushResult
2950: oEmitLabel
2951: oPop 1
2953: oGetParam 1
2955: oPushResult
2956: oGetLocal 1
2958: oAssign
2959: oJumpForward 2964
2961: Choice Lookup Table
           1   2934
2964: oGetAddrLocal 2
2966: oPushResult
2967: oSetResult 0
2969: oAssign
2970: oGetAddrLocal 2
2972: oPushResult
2973: oCall 3022
2975: oPop 1
2977: oTypeSNodeType
2978: oChoice 2991
2980: oJumpForward 2998
2982: oGetAddrLocal 2
2984: oPushResult
2985: oCall 2308
2987: oPop 1
2989: oJumpForward 2998
2991: Choice Lookup Table
          19   2982
          20   2980
2996: oError 8
2998: oEmit 49
3000: oGetLocal 2
3002: oPushResult
3003: oEmitLabel
3004: oPop 1
3006: oGetLocal 1
3008: oPushResult
3009: oEmitLabel
3010: oPop 1
3012: oJumpForward 3019
3014: Choice Lookup Table
          51   2901
3017: oJumpForward 3021
3019: oJumpBack 2899
3021: oReturn
3022: oLocalSpace 1
3024: oInputChoice 3078
3026: oGetAddrLocal 1
3028: oPushResult
3029: oSetResult 0
3031: oAssign
3032: oGetAddrLocal 1
3034: oPushResult
3035: oCall 3022
3037: oPop 1
3039: oTypeSNodeType
3040: oChoice 3069
3042: oGetParam 1
3044: oPushResult
3045: oLabelNew
3046: oAssign
3047: oEmit 45
3049: oGetFromParam 1
3051: oPushResult
3052: oEmitLabel
3053: oPop 1
3055: oEmit 48
3057: oGetLocal 1
3059: oPushResult
3060: oEmitLabel
3061: oPop 1
3063: oJumpForward 3076
3065: oEmit 29
3067: oJumpForward 3076
3069: Choice Lookup Table
          19   3065
          20   3042
3074: oError 8
3076: oJumpForward 3088
3078: Choice Lookup Table
          53   3026
3081: oGetParam 1
3083: oPushResult
3084: oCall 3089
3086: oPop 1
3088: oReturn
3089: oLocalSpace 0
3091: oGetParam 1
3093: oPushResult
3094: oCall 3140
3096: oPop 1
3098: oInputChoice 3130
3100: oCall 5787
3102: oGetParam 1
3104: oPushResult
3105: oCall 3140
3107: oPop 1
3109: oCall 5801
3111: oEmit 26
3113: oJumpForward 3137
3115: oCall 5787
3117: oGetParam 1
3119: oPushResult
3120: oCall 3140
3122: oPop 1
3124: oCall 5801
3126: oEmit 27
3128: oJumpForward 3137
3130: Choice Lookup Table
          24   3115
          23   3100
3135: oJumpForward 3139
3137: oJumpBack 3098
3139: oReturn
3140: oLocalSpace 0
3142: oGetParam 1
3144: oPushResult
3145: oCall 3191
3147: oPop 1
3149: oInputChoice 3181
3151: oCall 5787
3153: oGetParam 1
3155: oPushResult
3156: oCall 3191
3158: oPop 1
3160: oCall 5801
3162: oEmit 23
3164: oJumpForward 3188
3166: oCall 5787
3168: oGetParam 1
3170: oPushResult
3171: oCall 3191
3173: oPop 1
3175: oCall 5801
3177: oEmit 24
3179: oJumpForward 3188
3181: Choice Lookup Table
          22   3166
          21   3151
3186: oJumpForward 3190
3188: oJumpBack 3149
3190: oReturn
3191: oLocalSpace 0
3193: oInputChoice 3219
3195: oGetParam 1
3197: oPushResult
3198: oCall 3232
3200: oPop 1
3202: oCall 5801
3204: oJumpForward 3231
3206: oGetParam 1
3208: oPushResult
3209: oCall 3232
3211: oPop 1
3213: oCall 5801
3215: oEmit 28
3217: oJumpForward 3231
3219: Choice Lookup Table
          24   3206
          23   3195
3224: oGetParam 1
3226: oPushResult
3227: oCall 3232
3229: oPop 1
3231: oReturn
3232: oLocalSpace 6
3234: oInputChoice 3416
3236: oEmit 9
3238: TOKEN_VALUE
3239: oPushResult
3240: oEmitInt
3241: oPop 1
3243: oGetGlobal 3
3245: oPushResult
3246: oTypeSPush
3247: oPop 1
3249: oJumpForward 3435
3251: oGetParam 1
3253: oPushResult
3254: oCall 2339
3256: oPop 1
3258: oInput 14
3260: oJumpForward 3435
3262: oGetAddrLocal 1
3264: oPushResult
3265: oStringAllocLit
3266: oAssign
3267: oEmit 10
3269: oGetLocal 1
3271: oPushResult
3272: oEmitInt
3273: oPop 1
3275: oGetGlobal 7
3277: oPushResult
3278: oTypeSPush
3279: oPop 1
3281: oJumpForward 3435
3283: oGetAddrLocal 2
3285: oPushResult
3286: oScopeFindRequire
3287: oAssign
3288: oGetLocal 2
3290: oPushResult
3291: oNodeType
3292: oPop 1
3294: oChoice 3356
3296: oGetLocal 2
3298: oPushResult
3299: oCall 4158
3301: oPop 1
3303: oJumpForward 3375
3305: oGetAddrLocal 3
3307: oPushResult
3308: oGetLocal 2
3310: oPushResult
3311: oSetResult 6
3313: oPushResult
3314: oNodeGet
3315: oPop 2
3317: oAssign
3318: oGetLocal 3
3320: oPushResult
3321: oTypeSPush
3322: oPop 1
3324: oTypeSNodeType
3325: oChoice 3338
3327: oEmit 9
3329: oGetLocal 2
3331: oPushResult
3332: oCall 6038
3334: oPop 1
3336: oJumpForward 3345
3338: Choice Lookup Table
          19   3327
          18   3327
3343: oError 16
3345: oJumpForward 3375
3347: oGetLocal 2
3349: oPushResult
3350: oCall 3436
3352: oPop 1
3354: oJumpForward 3375
3356: Choice Lookup Table
          15   3347
          13   3347
          12   3347
           9   3305
           8   3296
3367: oError 6
3369: oGetGlobal 3
3371: oPushResult
3372: oTypeSPush
3373: oPop 1
3375: oJumpForward 3435
3377: oInput 0
3379: oGetAddrLocal 4
3381: oPushResult
3382: oScopeFindRequire
3383: oAssign
3384: oGetLocal 4
3386: oPushResult
3387: oCall 5080
3389: oPop 1
3391: oGetAddrLocal 5
3393: oPushResult
3394: oTypeSTop
3395: oAssign
3396: oTypeSPop
3397: oGetAddrLocal 6
3399: oPushResult
3400: oGetLocal 5
3402: oPushResult
3403: oCall 5903
3405: oPop 1
3407: oAssign
3408: oGetLocal 6
3410: oPushResult
3411: oTypeSPush
3412: oPop 1
3414: oJumpForward 3435
3416: Choice Lookup Table
          18   3377
           0   3283
           2   3262
          13   3251
           1   3236
3427: oError 6
3429: oGetGlobal 3
3431: oPushResult
3432: oTypeSPush
3433: oPop 1
3435: oReturn
3436: oLocalSpace 1
3438: oGetAddrLocal 1
3440: oPushResult
3441: oGetParam 1
3443: oPushResult
3444: oSetResult 6
3446: oPushResult
3447: oNodeGet
3448: oPop 2
3450: oAssign
3451: oGetLocal 1
3453: oPushResult
3454: oTypeSPush
3455: oPop 1
3457: oTypeSNodeType
3458: oChoice 3723
3460: oGetParam 1
3462: oPushResult
3463: oNodeType
3464: oPop 1
3466: oChoice 3528
3468: oEmit 0
3470: oGetParam 1
3472: oPushResult
3473: oCall 6038
3475: oPop 1
3477: oJumpForward 3536
3479: oEmit 3
3481: oGetParam 1
3483: oPushResult
3484: oCall 6038
3486: oPop 1
3488: oJumpForward 3536
3490: oGetParam 1
3492: oPushResult
3493: oSetResult 18
3495: oPushResult
3496: oNodeGetBoolean
3497: oPop 2
3499: oChoice 3514
3501: oEmit 8
3503: oGetParam 1
3505: oPushResult
3506: oCall 6038
3508: oPop 1
3510: oEmit 14
3512: oJumpForward 3526
3514: Choice Lookup Table
           1   3501
3517: oEmit 6
3519: oGetParam 1
3521: oPushResult
3522: oCall 6038
3524: oPop 1
3526: oJumpForward 3536
3528: Choice Lookup Table
          15   3490
          13   3479
          12   3468
3535: oEndChoice
3536: oJumpForward 3814
3538: oGetParam 1
3540: oPushResult
3541: oNodeType
3542: oPop 1
3544: oChoice 3606
3546: oEmit 1
3548: oGetParam 1
3550: oPushResult
3551: oCall 6038
3553: oPop 1
3555: oJumpForward 3614
3557: oEmit 4
3559: oGetParam 1
3561: oPushResult
3562: oCall 6038
3564: oPop 1
3566: oJumpForward 3614
3568: oGetParam 1
3570: oPushResult
3571: oSetResult 18
3573: oPushResult
3574: oNodeGetBoolean
3575: oPop 2
3577: oChoice 3592
3579: oEmit 8
3581: oGetParam 1
3583: oPushResult
3584: oCall 6038
3586: oPop 1
3588: oEmit 15
3590: oJumpForward 3604
3592: Choice Lookup Table
           1   3579
3595: oEmit 7
3597: oGetParam 1
3599: oPushResult
3600: oCall 6038
3602: oPop 1
3604: oJumpForward 3614
3606: Choice Lookup Table
          15   3568
          13   3557
          12   3546
3613: oEndChoice
3614: oJumpForward 3814
3616: oError 16
3618: oJumpForward 3814
3620: oGetParam 1
3622: oPushResult
3623: oNodeType
3624: oPop 1
3626: oChoice 3688
3628: oEmit 2
3630: oGetParam 1
3632: oPushResult
3633: oCall 6038
3635: oPop 1
3637: oJumpForward 3696
3639: oEmit 5
3641: oGetParam 1
3643: oPushResult
3644: oCall 6038
3646: oPop 1
3648: oJumpForward 3696
3650: oGetParam 1
3652: oPushResult
3653: oSetResult 18
3655: oPushResult
3656: oNodeGetBoolean
3657: oPop 2
3659: oChoice 3674
3661: oEmit 8
3663: oGetParam 1
3665: oPushResult
3666: oCall 6038
3668: oPop 1
3670: oEmit 16
3672: oJumpForward 3686
3674: Choice Lookup Table
           1   3661
3677: oEmit 8
3679: oGetParam 1
3681: oPushResult
3682: oCall 6038
3684: oPop 1
3686: oJumpForward 3696
3688: Choice Lookup Table
          15   3650
          13   3639
          12   3628
3695: oEndChoice
3696: oInputChoice 3718
3698: oTypeSPop
3699: oGetLocal 1
3701: oPushResult
3702: oSetResult 20
3704: oPushResult
3705: oNodeGet
3706: oPop 2
3708: oPushResult
3709: oTypeSPush
3710: oPop 1
3712: oCall 3850
3714: oCall 3815
3716: oJumpForward 3721
3718: Choice Lookup Table
          17   3698
3721: oJumpForward 3814
3723: Choice Lookup Table
          23   3620
          17   3616
          22   3616
          21   3616
          19   3538
          18   3460
3736: oGetParam 1
3738: oPushResult
3739: oNodeType
3740: oPop 1
3742: oChoice 3802
3744: oEmit 10
3746: oGetParam 1
3748: oPushResult
3749: oCall 6038
3751: oPop 1
3753: oJumpForward 3810
3755: oEmit 11
3757: oGetParam 1
3759: oPushResult
3760: oCall 6038
3762: oPop 1
3764: oJumpForward 3810
3766: oGetParam 1
3768: oPushResult
3769: oSetResult 18
3771: oPushResult
3772: oNodeGetBoolean
3773: oPop 2
3775: oChoice 3788
3777: oEmit 8
3779: oGetParam 1
3781: oPushResult
3782: oCall 6038
3784: oPop 1
3786: oJumpForward 3800
3788: Choice Lookup Table
           1   3777
3791: oEmit 12
3793: oGetParam 1
3795: oPushResult
3796: oCall 6038
3798: oPop 1
3800: oJumpForward 3810
3802: Choice Lookup Table
          15   3766
          13   3755
          12   3744
3809: oEndChoice
3810: oCall 3850
3812: oCall 3815
3814: oReturn
3815: oLocalSpace 0
3817: oTypeSNodeType
3818: oChoice 3836
3820: oEmit 14
3822: oJumpForward 3849
3824: oEmit 15
3826: oJumpForward 3849
3828: oError 16
3830: oJumpForward 3849
3832: oEmit 16
3834: oJumpForward 3849
3836: Choice Lookup Table
          23   3832
          17   3828
          22   3828
          21   3828
          19   3824
          18   3820
3849: oReturn
3850: oLocalSpace 0
3852: oInputChoice 3866
3854: oCall 3878
3856: oJumpForward 3875
3858: oCall 4021
3860: oJumpForward 3875
3862: oCall 4119
3864: oJumpForward 3875
3866: Choice Lookup Table
          17   3862
          19   3858
          15   3854
3873: oJumpForward 3877
3875: oJumpBack 3852
3877: oReturn
3878: oLocalSpace 3
3880: oTypeSNodeType
3881: oChoice 3885
3883: oJumpForward 3890
3885: Choice Lookup Table
          24   3883
3888: oError 10
3890: oTypeSNodeType
3891: oChoice 3895
3893: oJumpForward 3900
3895: Choice Lookup Table
          24   3893
3898: oError 13
3900: oGetAddrLocal 1
3902: oPushResult
3903: oTypeSTop
3904: oPushResult
3905: oSetResult 21
3907: oPushResult
3908: oNodeGet
3909: oPop 2
3911: oPushResult
3912: oCall 5987
3914: oPop 1
3916: oAssign
3917: oGetAddrLocal 2
3919: oPushResult
3920: oTypeSTop
3921: oPushResult
3922: oSetResult 20
3924: oPushResult
3925: oNodeGet
3926: oPop 2
3928: oAssign
3929: oTypeSPop
3930: oGetLocal 2
3932: oPushResult
3933: oTypeSPush
3934: oPop 1
3936: oCall 2178
3938: oCall 5787
3940: oGetLocal 1
3942: oPushResult
3943: equal_zero
3944: oPop 1
3946: oChoice 3960
3948: oEmit 9
3950: oGetLocal 1
3952: oPushResult
3953: oEmitInt
3954: oPop 1
3956: oEmit 27
3958: oJumpForward 3963
3960: Choice Lookup Table
           0   3948
3963: oGetAddrLocal 3
3965: oPushResult
3966: oGetLocal 2
3968: oPushResult
3969: oSetResult 2
3971: oPushResult
3972: oNodeGetInt
3973: oPop 2
3975: oAssign
3976: oGetLocal 3
3978: oPushResult
3979: oSetResult 1
3981: oPushResult
3982: equal
3983: oPop 2
3985: oChoice 3999
3987: oEmit 9
3989: oGetLocal 3
3991: oPushResult
3992: oEmitInt
3993: oPop 1
3995: oEmit 23
3997: oJumpForward 4002
3999: Choice Lookup Table
           0   3987
4002: oEmit 25
4004: oInputChoice 4012
4006: oJumpForward 4020
4008: oJumpForward 4018
4010: oJumpForward 4018
4012: Choice Lookup Table
          12   4010
          16   4006
4017: oEndChoice
4018: oJumpBack 3890
4020: oReturn
4021: oLocalSpace 2
4023: oTypeSNodeType
4024: oChoice 4028
4026: oJumpForward 4033
4028: Choice Lookup Table
          26   4026
4031: oError 11
4033: oTypeSTop
4034: oPushResult
4035: oSetResult 24
4037: oPushResult
4038: oNodeGet
4039: oPop 2
4041: oPushResult
4042: oScopeEnter
4043: oPop 1
4045: oInput 0
4047: oGetAddrLocal 1
4049: oPushResult
4050: oScopeFindRequire
4051: oAssign
4052: oGetLocal 1
4054: oPushResult
4055: oNodeType
4056: oPop 1
4058: oChoice 4062
4060: oJumpForward 4067
4062: Choice Lookup Table
          14   4060
4065: oError 12
4067: oScopeEnd
4068: oGetAddrLocal 2
4070: oPushResult
4071: oGetLocal 1
4073: oPushResult
4074: oSetResult 7
4076: oPushResult
4077: oNodeGetInt
4078: oPop 2
4080: oAssign
4081: oGetLocal 2
4083: oPushResult
4084: equal_zero
4085: oPop 1
4087: oChoice 4101
4089: oEmit 9
4091: oGetLocal 2
4093: oPushResult
4094: oEmitInt
4095: oPop 1
4097: oEmit 25
4099: oJumpForward 4104
4101: Choice Lookup Table
           0   4089
4104: oTypeSPop
4105: oGetLocal 1
4107: oPushResult
4108: oSetResult 6
4110: oPushResult
4111: oNodeGet
4112: oPop 2
4114: oPushResult
4115: oTypeSPush
4116: oPop 1
4118: oReturn
4119: oLocalSpace 1
4121: oTypeSNodeType
4122: oChoice 4126
4124: oJumpForward 4131
4126: Choice Lookup Table
          23   4124
4129: oError 9
4131: oEmit 16
4133: oGetAddrLocal 1
4135: oPushResult
4136: oTypeSTop
4137: oAssign
4138: oTypeSPop
4139: oGetLocal 1
4141: oPushResult
4142: oSetResult 20
4144: oPushResult
4145: oNodeGet
4146: oPop 2
4148: oPushResult
4149: oTypeSPush
4150: oPop 1
4152: oReturn
4153: oLocalSpace 0
4155: oCall 5761
4157: oReturn
4158: oLocalSpace 11
4160: oGetParam 1
4162: oPushResult
4163: oSetResult 12
4165: oPushResult
4166: oNodeGetBoolean
4167: oPop 2
4169: oChoice 4221
4171: oGetParam 1
4173: oPushResult
4174: oSetResult 14
4176: oPushResult
4177: oNodeGetBoolean
4178: oPop 2
4180: oChoice 4216
4182: oGetAddrLocal 1
4184: oPushResult
4185: oGetParam 1
4187: oPushResult
4188: oSetResult 5
4190: oPushResult
4191: oNodeGetInt
4192: oPop 2
4194: oPushResult
4195: oStringAllocLitFromIdent
4196: oPop 1
4198: oAssign
4199: oEmit 50
4201: oGetParam 1
4203: oPushResult
4204: oCall 6038
4206: oPop 1
4208: oGetLocal 1
4210: oPushResult
4211: oEmitInt
4212: oPop 1
4214: oJumpForward 4219
4216: Choice Lookup Table
           0   4182
4219: oJumpForward 4224
4221: Choice Lookup Table
           1   4171
4224: oGetParam 1
4226: oPushResult
4227: oSetResult 14
4229: oPushResult
4230: oSetResult 1
4232: oPushResult
4233: oNodeSetBoolean
4234: oPop 3
4236: oGetAddrLocal 2
4238: oPushResult
4239: oGetParam 1
4241: oPushResult
4242: oSetResult 13
4244: oPushResult
4245: oNodeGetBoolean
4246: oPop 2
4248: oAssign
4249: oGetAddrLocal 5
4251: oPushResult
4252: oGetParam 1
4254: oPushResult
4255: oNodeType
4256: oPop 1
4258: oPushResult
4259: oSetResult 8
4261: oPushResult
4262: equal_node_type
4263: oPop 2
4265: oAssign
4266: oGetLocal 5
4268: oChoice 4295
4270: oGetAddrLocal 3
4272: oPushResult
4273: oGetParam 1
4275: oPushResult
4276: oSetResult 6
4278: oPushResult
4279: oNodeGet
4280: oPop 2
4282: oAssign
4283: oGetAddrLocal 4
4285: oPushResult
4286: oGetLocal 3
4288: oPushResult
4289: oScopeAllocType
4290: oPop 1
4292: oAssign
4293: oJumpForward 4298
4295: Choice Lookup Table
           1   4270
4298: oGetAddrLocal 6
4300: oPushResult
4301: oGetParam 1
4303: oPushResult
4304: oSetResult 9
4306: oPushResult
4307: oNodeGet
4308: oPop 2
4310: oAssign
4311: oGetAddrLocal 7
4313: oPushResult
4314: oGetLocal 6
4316: oPushResult
4317: oSetResult 2
4319: oPushResult
4320: oNodeGetInt
4321: oPop 2
4323: oAssign
4324: oGetLocal 2
4326: oChoice 4348
4328: oEmit 39
4330: oGetLocal 7
4332: oPushResult
4333: oEmitInt
4334: oPop 1
4336: oJumpForward 4354
4338: oEmit 38
4340: oGetLocal 7
4342: oPushResult
4343: oEmitInt
4344: oPop 1
4346: oJumpForward 4354
4348: Choice Lookup Table
           0   4338
           1   4328
4353: oEndChoice
4354: oGetAddrLocal 8
4356: oPushResult
4357: oGetLocal 6
4359: oPushResult
4360: oSetResult 1
4362: oPushResult
4363: oNodeGetIter
4364: oPop 2
4366: oAssign
4367: oGetAddrLocal 9
4369: oPushResult
4370: oGetLocal 8
4372: oPushResult
4373: oNodeIterValue
4374: oPop 1
4376: oAssign
4377: oInputChoice 4556
4379: oGetLocal 9
4381: oPushResult
4382: oNodeNull
4383: oPop 1
4385: oChoice 4391
4387: oJumpForward 4552
4389: oJumpForward 4394
4391: Choice Lookup Table
           1   4387
4394: oGetAddrLocal 10
4396: oPushResult
4397: oGetLocal 9
4399: oPushResult
4400: oSetResult 7
4402: oPushResult
4403: oNodeGetInt
4404: oPop 2
4406: oAssign
4407: oEmit 13
4409: oGetLocal 10
4411: oPushResult
4412: oEmitInt
4413: oPop 1
4415: oGetLocal 9
4417: oPushResult
4418: oSetResult 6
4420: oPushResult
4421: oNodeGet
4422: oPop 2
4424: oPushResult
4425: oTypeSPush
4426: oPop 1
4428: oGetLocal 9
4430: oPushResult
4431: oSetResult 18
4433: oPushResult
4434: oNodeGetBoolean
4435: oPop 2
4437: oChoice 4505
4439: oCall 5044
4441: oCall 5761
4443: oEmit 19
4445: oJumpForward 4511
4447: oCall 2178
4449: oCall 4153
4451: oTypeSNodeType
4452: oChoice 4470
4454: oEmit 17
4456: oJumpForward 4503
4458: oEmit 18
4460: oJumpForward 4503
4462: oError 16
4464: oJumpForward 4503
4466: oEmit 19
4468: oJumpForward 4503
4470: Choice Lookup Table
          23   4466
          17   4462
          22   4462
          21   4462
          19   4458
          18   4454
4483: oGetAddrLocal 11
4485: oPushResult
4486: oTypeSTop
4487: oPushResult
4488: oSetResult 2
4490: oPushResult
4491: oNodeGetInt
4492: oPop 2
4494: oAssign
4495: oEmit 20
4497: oGetLocal 11
4499: oPushResult
4500: oEmitInt
4501: oPop 1
4503: oJumpForward 4511
4505: Choice Lookup Table
           0   4447
           1   4439
4510: oEndChoice
4511: oTypeSPop
4512: oGetAddrLocal 8
4514: oPushResult
4515: oNodeIterNext
4516: oPop 1
4518: oGetAddrLocal 9
4520: oPushResult
4521: oGetLocal 8
4523: oPushResult
4524: oNodeIterValue
4525: oPop 1
4527: oAssign
4528: oGetLocal 9
4530: oPushResult
4531: oNodeNull
4532: oPop 1
4534: oChoice 4542
4536: oJumpForward 4552
4538: oJumpForward 4548
4540: oJumpForward 4548
4542: Choice Lookup Table
           0   4540
           1   4536
4547: oEndChoice
4548: oInput 12
4550: oJumpBack 4379
4552: oInput 14
4554: oJumpForward 4559
4556: Choice Lookup Table
          13   4379
4559: oGetLocal 9
4561: oPushResult
4562: oNodeNull
4563: oPop 1
4565: oChoice 4571
4567: oError 15
4569: oJumpForward 4574
4571: Choice Lookup Table
           0   4567
4574: oGetLocal 5
4576: oChoice 4605
4578: oEmit 13
4580: oGetParam 1
4582: oPushResult
4583: oSetResult 17
4585: oPushResult
4586: oNodeGetInt
4587: oPop 2
4589: oPushResult
4590: oEmitInt
4591: oPop 1
4593: oEmit 11
4595: oGetLocal 4
4597: oPushResult
4598: oEmitInt
4599: oPop 1
4601: oEmit 19
4603: oJumpForward 4608
4605: Choice Lookup Table
           1   4578
4608: oGetLocal 2
4610: oChoice 4634
4612: oEmit 42
4614: oGetParam 1
4616: oPushResult
4617: oCall 6038
4619: oPop 1
4621: oJumpForward 4640
4623: oEmit 41
4625: oGetParam 1
4627: oPushResult
4628: oCall 6038
4630: oPop 1
4632: oJumpForward 4640
4634: Choice Lookup Table
           0   4623
           1   4612
4639: oEndChoice
4640: oGetLocal 5
4642: oChoice 4710
4644: oGetLocal 3
4646: oPushResult
4647: oTypeSPush
4648: oPop 1
4650: oTypeSNodeType
4651: oChoice 4687
4653: oEmit 3
4655: oGetLocal 4
4657: oPushResult
4658: oEmitInt
4659: oPop 1
4661: oJumpForward 4708
4663: oEmit 4
4665: oGetLocal 4
4667: oPushResult
4668: oEmitInt
4669: oPop 1
4671: oJumpForward 4708
4673: oError 16
4675: oJumpForward 4708
4677: oEmit 5
4679: oGetLocal 4
4681: oPushResult
4682: oEmitInt
4683: oPop 1
4685: oJumpForward 4708
4687: Choice Lookup Table
          23   4677
          17   4673
          22   4673
          21   4673
          19   4663
          18   4653
4700: oEmit 11
4702: oGetLocal 4
4704: oPushResult
4705: oEmitInt
4706: oPop 1
4708: oJumpForward 4713
4710: Choice Lookup Table
           1   4644
4713: oEmit 40
4715: oGetLocal 7
4717: oPushResult
4718: oEmitInt
4719: oPop 1
4721: oReturn
4722: oLocalSpace 0
4724: oInputChoice 4774
4726: oCall 5681
4728: oJumpForward 4799
4730: oCall 5688
4732: oJumpForward 4799
4734: oCall 5755
4736: oJumpForward 4799
4738: oCall 5758
4740: oJumpForward 4799
4742: oCall 5221
4744: oJumpForward 4799
4746: oCall 5541
4748: oJumpForward 4799
4750: oCall 5287
4752: oJumpForward 4799
4754: oCall 5461
4756: oJumpForward 4799
4758: oCall 5626
4760: oJumpForward 4799
4762: oCall 5594
4764: oJumpForward 4799
4766: oCall 5658
4768: oJumpForward 4799
4770: oCall 4800
4772: oJumpForward 4799
4774: Choice Lookup Table
           0   4770
          33   4766
          49   4762
          50   4758
          47   4754
          42   4750
          46   4746
          39   4742
          57   4738
          56   4734
          55   4730
          54   4726
4799: oReturn
4800: oLocalSpace 1
4802: oGetAddrLocal 1
4804: oPushResult
4805: oScopeFindRequire
4806: oAssign
4807: oGetLocal 1
4809: oPushResult
4810: oNodeType
4811: oPop 1
4813: oChoice 4842
4815: oGetLocal 1
4817: oPushResult
4818: oCall 4158
4820: oPop 1
4822: oJumpForward 4855
4824: oGetLocal 1
4826: oPushResult
4827: oCall 4856
4829: oPop 1
4831: oJumpForward 4855
4833: oGetLocal 1
4835: oPushResult
4836: oCall 4930
4838: oPop 1
4840: oJumpForward 4855
4842: Choice Lookup Table
           8   4833
          15   4824
          13   4824
          12   4824
           7   4815
4853: oError 0
4855: oReturn
4856: oLocalSpace 0
4858: oGetParam 1
4860: oPushResult
4861: oCall 5080
4863: oPop 1
4865: oInput 3
4867: oCall 2178
4869: oCall 5761
4871: oCall 4874
4873: oReturn
4874: oLocalSpace 1
4876: oTypeSNodeType
4877: oChoice 4895
4879: oEmit 17
4881: oJumpForward 4928
4883: oEmit 18
4885: oJumpForward 4928
4887: oError 16
4889: oJumpForward 4928
4891: oEmit 19
4893: oJumpForward 4928
4895: Choice Lookup Table
          23   4891
          17   4887
          22   4887
          21   4887
          19   4883
          18   4879
4908: oGetAddrLocal 1
4910: oPushResult
4911: oTypeSTop
4912: oPushResult
4913: oSetResult 2
4915: oPushResult
4916: oNodeGetInt
4917: oPop 2
4919: oAssign
4920: oEmit 20
4922: oGetLocal 1
4924: oPushResult
4925: oEmitInt
4926: oPop 1
4928: oTypeSPop
4929: oReturn
4930: oLocalSpace 1
4932: oGetParam 1
4934: oPushResult
4935: oSetResult 10
4937: oPushResult
4938: oNodeGet
4939: oPop 2
4941: oPushResult
4942: oScopeCurrent
4943: oPushResult
4944: oNodeEqual
4945: oPop 2
4947: oChoice 4953
4949: oError 20
4951: oJumpForward 4956
4953: Choice Lookup Table
           0   4949
4956: oEmit 8
4958: oGetParam 1
4960: oPushResult
4961: oSetResult 17
4963: oPushResult
4964: oNodeGetInt
4965: oPop 2
4967: oPushResult
4968: oEmitInt
4969: oPop 1
4971: oGetParam 1
4973: oPushResult
4974: oSetResult 6
4976: oPushResult
4977: oNodeGet
4978: oPop 2
4980: oPushResult
4981: oTypeSPush
4982: oPop 1
4984: oInput 3
4986: oCall 2178
4988: oCall 5761
4990: oTypeSNodeType
4991: oChoice 5009
4993: oEmit 17
4995: oJumpForward 5042
4997: oEmit 18
4999: oJumpForward 5042
5001: oError 16
5003: oJumpForward 5042
5005: oEmit 19
5007: oJumpForward 5042
5009: Choice Lookup Table
          23   5005
          17   5001
          22   5001
          21   5001
          19   4997
          18   4993
5022: oGetAddrLocal 1
5024: oPushResult
5025: oTypeSTop
5026: oPushResult
5027: oSetResult 2
5029: oPushResult
5030: oNodeGetInt
5031: oPop 2
5033: oAssign
5034: oEmit 20
5036: oGetLocal 1
5038: oPushResult
5039: oEmitInt
5040: oPop 1
5042: oTypeSPop
5043: oReturn
5044: oLocalSpace 1
5046: oInput 0
5048: oGetAddrLocal 1
5050: oPushResult
5051: oScopeFindRequire
5052: oAssign
5053: oGetLocal 1
5055: oPushResult
5056: oNodeType
5057: oPop 1
5059: oChoice 5063
5061: oJumpForward 5072
5063: Choice Lookup Table
          15   5061
          13   5061
          12   5061
5070: oError 4
5072: oGetLocal 1
5074: oPushResult
5075: oCall 5080
5077: oPop 1
5079: oReturn
5080: oLocalSpace 0
5082: oGetParam 1
5084: oPushResult
5085: oNodeType
5086: oPop 1
5088: oChoice 5148
5090: oEmit 10
5092: oGetParam 1
5094: oPushResult
5095: oCall 6038
5097: oPop 1
5099: oJumpForward 5157
5101: oEmit 11
5103: oGetParam 1
5105: oPushResult
5106: oCall 6038
5108: oPop 1
5110: oJumpForward 5157
5112: oGetParam 1
5114: oPushResult
5115: oSetResult 18
5117: oPushResult
5118: oNodeGetBoolean
5119: oPop 2
5121: oChoice 5134
5123: oEmit 8
5125: oGetParam 1
5127: oPushResult
5128: oCall 6038
5130: oPop 1
5132: oJumpForward 5146
5134: Choice Lookup Table
           1   5123
5137: oEmit 12
5139: oGetParam 1
5141: oPushResult
5142: oCall 6038
5144: oPop 1
5146: oJumpForward 5157
5148: Choice Lookup Table
          15   5112
          13   5101
          12   5090
5155: oError 4
5157: oGetParam 1
5159: oPushResult
5160: oSetResult 6
5162: oPushResult
5163: oNodeGet
5164: oPop 2
5166: oPushResult
5167: oTypeSPush
5168: oPop 1
5170: oCall 3850
5172: oReturn
5173: oLocalSpace 0
5175: oGetParam 1
5177: oPushResult
5178: oCall 5080
5180: oPop 1
5182: oCall 5787
5184: oGetParam 1
5186: oPushResult
5187: oCall 3436
5189: oPop 1
5191: oTypeSPop
5192: oEmit 21
5194: oEmit 17
5196: oReturn
5197: oLocalSpace 0
5199: oGetParam 1
5201: oPushResult
5202: oCall 5080
5204: oPop 1
5206: oCall 5787
5208: oGetParam 1
5210: oPushResult
5211: oCall 3436
5213: oPop 1
5215: oTypeSPop
5216: oEmit 22
5218: oEmit 17
5220: oReturn
5221: oLocalSpace 2
5223: oGetAddrLocal 1
5225: oPushResult
5226: oSetResult 0
5228: oAssign
5229: oGetAddrLocal 1
5231: oPushResult
5232: oCall 2201
5234: oPop 1
5236: oInput 40
5238: oCall 4722
5240: oInputChoice 5275
5242: oGetAddrLocal 2
5244: oPushResult
5245: oLabelNew
5246: oAssign
5247: oEmit 45
5249: oGetLocal 2
5251: oPushResult
5252: oEmitLabel
5253: oPop 1
5255: oEmit 48
5257: oGetLocal 1
5259: oPushResult
5260: oEmitLabel
5261: oPop 1
5263: oCall 4722
5265: oEmit 48
5267: oGetLocal 2
5269: oPushResult
5270: oEmitLabel
5271: oPop 1
5273: oJumpForward 5286
5275: Choice Lookup Table
          41   5242
5278: oEmit 48
5280: oGetLocal 1
5282: oPushResult
5283: oEmitLabel
5284: oPop 1
5286: oReturn
5287: oLocalSpace 4
5289: oInput 0
5291: oGetAddrLocal 1
5293: oPushResult
5294: oScopeFindRequire
5295: oAssign
5296: oGetLocal 1
5298: oPushResult
5299: oCall 5080
5301: oPop 1
5303: oCall 5787
5305: oInput 3
5307: oCall 2178
5309: oCall 5787
5311: oEmit 17
5313: oGetAddrLocal 2
5315: oPushResult
5316: oLabelNew
5317: oAssign
5318: oGetAddrLocal 3
5320: oPushResult
5321: oLabelNew
5322: oAssign
5323: oEmit 45
5325: oGetLocal 3
5327: oPushResult
5328: oEmitLabel
5329: oPop 1
5331: oGetAddrLocal 4
5333: oPushResult
5334: oLabelNew
5335: oAssign
5336: oEmit 48
5338: oGetLocal 4
5340: oPushResult
5341: oEmitLabel
5342: oPop 1
5344: oInputChoice 5424
5346: oGetLocal 1
5348: oPushResult
5349: oCall 5173
5351: oPop 1
5353: oEmit 48
5355: oGetLocal 3
5357: oPushResult
5358: oEmitLabel
5359: oPop 1
5361: oGetLocal 1
5363: oPushResult
5364: oCall 3436
5366: oPop 1
5368: oTypeSPop
5369: oCall 2178
5371: oCall 5787
5373: oEmit 32
5375: oEmit 46
5377: oGetLocal 2
5379: oPushResult
5380: oEmitLabel
5381: oPop 1
5383: oJumpForward 5430
5385: oGetLocal 1
5387: oPushResult
5388: oCall 5197
5390: oPop 1
5392: oEmit 48
5394: oGetLocal 3
5396: oPushResult
5397: oEmitLabel
5398: oPop 1
5400: oGetLocal 1
5402: oPushResult
5403: oCall 3436
5405: oPop 1
5407: oTypeSPop
5408: oCall 2178
5410: oCall 5787
5412: oEmit 33
5414: oEmit 46
5416: oGetLocal 2
5418: oPushResult
5419: oEmitLabel
5420: oPop 1
5422: oJumpForward 5430
5424: Choice Lookup Table
          44   5385
          43   5346
5429: oEndChoice
5430: oGetLocal 4
5432: oPushResult
5433: oGetLocal 2
5435: oPushResult
5436: oLoopPush
5437: oPop 2
5439: oInput 45
5441: oCall 4722
5443: oEmit 45
5445: oGetLocal 4
5447: oPushResult
5448: oEmitLabel
5449: oPop 1
5451: oEmit 48
5453: oGetLocal 2
5455: oPushResult
5456: oEmitLabel
5457: oPop 1
5459: oLoopPop
5460: oReturn
5461: oLocalSpace 3
5463: oGetAddrLocal 1
5465: oPushResult
5466: oLabelNew
5467: oAssign
5468: oEmit 48
5470: oGetLocal 1
5472: oPushResult
5473: oEmitLabel
5474: oPop 1
5476: oGetAddrLocal 2
5478: oPushResult
5479: oLabelNew
5480: oAssign
5481: oGetLocal 1
5483: oPushResult
5484: oGetLocal 2
5486: oPushResult
5487: oLoopPush
5488: oPop 2
5490: oCall 4722
5492: oInputChoice 5523
5494: oCall 4722
5496: oJumpForward 5529
5498: oGetAddrLocal 3
5500: oPushResult
5501: oCall 2201
5503: oPop 1
5505: oEmit 49
5507: oGetLocal 3
5509: oPushResult
5510: oEmitLabel
5511: oPop 1
5513: oGetLocal 1
5515: oPushResult
5516: oEmitLabel
5517: oPop 1
5519: oJumpForward 5531
5521: oJumpForward 5529
5523: Choice Lookup Table
          48   5498
           4   5494
5528: oEndChoice
5529: oJumpBack 5492
5531: oEmit 48
5533: oGetLocal 2
5535: oPushResult
5536: oEmitLabel
5537: oPop 1
5539: oLoopPop
5540: oReturn
5541: oLocalSpace 2
5543: oGetAddrLocal 1
5545: oPushResult
5546: oLabelNew
5547: oAssign
5548: oEmit 48
5550: oGetLocal 1
5552: oPushResult
5553: oEmitLabel
5554: oPop 1
5556: oGetAddrLocal 2
5558: oPushResult
5559: oCall 2201
5561: oPop 1
5563: oGetLocal 1
5565: oPushResult
5566: oGetLocal 2
5568: oPushResult
5569: oLoopPush
5570: oPop 2
5572: oInput 45
5574: oCall 4722
5576: oEmit 45
5578: oGetLocal 1
5580: oPushResult
5581: oEmitLabel
5582: oPop 1
5584: oEmit 48
5586: oGetLocal 2
5588: oPushResult
5589: oEmitLabel
5590: oPop 1
5592: oLoopPop
5593: oReturn
5594: oLocalSpace 0
5596: oLoopContinueLabel
5597: oPushResult
5598: oSetResult 0
5600: oPushResult
5601: equal_label
5602: oPop 2
5604: oChoice 5619
5606: oError 18
5608: oJumpForward 5625
5610: oEmit 45
5612: oLoopContinueLabel
5613: oPushResult
5614: oEmitLabel
5615: oPop 1
5617: oJumpForward 5625
5619: Choice Lookup Table
           0   5610
           1   5606
5624: oEndChoice
5625: oReturn
5626: oLocalSpace 0
5628: oLoopBreakLabel
5629: oPushResult
5630: oSetResult 0
5632: oPushResult
5633: equal_label
5634: oPop 2
5636: oChoice 5651
5638: oError 18
5640: oJumpForward 5657
5642: oEmit 45
5644: oLoopBreakLabel
5645: oPushResult
5646: oEmitLabel
5647: oPop 1
5649: oJumpForward 5657
5651: Choice Lookup Table
           0   5642
           1   5638
5656: oEndChoice
5657: oReturn
5658: oLocalSpace 0
5660: oCall 4722
5662: oInputChoice 5672
5664: oCall 4722
5666: oJumpForward 5678
5668: oJumpForward 5680
5670: oJumpForward 5678
5672: Choice Lookup Table
          34   5668
           4   5664
5677: oEndChoice
5678: oJumpBack 5662
5680: oReturn
5681: oLocalSpace 0
5683: oCall 5688
5685: oEmit 55
5687: oReturn
5688: oLocalSpace 0
5690: oInputChoice 5751
5692: oCall 2178
5694: oTypeSNodeType
5695: oChoice 5717
5697: oEmit 51
5699: oJumpForward 5732
5701: oEmit 52
5703: oJumpForward 5732
5705: oEmit 53
5707: oJumpForward 5732
5709: oError 16
5711: oJumpForward 5732
5713: oEmit 54
5715: oJumpForward 5732
5717: Choice Lookup Table
          23   5713
          17   5709
          21   5709
          22   5705
          19   5701
          18   5697
5730: oError 17
5732: oTypeSPop
5733: oInputChoice 5741
5735: oJumpForward 5749
5737: oJumpForward 5747
5739: oJumpForward 5747
5741: Choice Lookup Table
          12   5739
          14   5735
5746: oEndChoice
5747: oJumpBack 5692
5749: oJumpForward 5754
5751: Choice Lookup Table
          13   5692
5754: oReturn
5755: oLocalSpace 0
5757: oReturn
5758: oLocalSpace 0
5760: oReturn
5761: oLocalSpace 1
5763: oGetAddrLocal 1
5765: oPushResult
5766: oTypeSNodeType
5767: oAssign
5768: oTypeSPop
5769: oGetLocal 1
5771: oPushResult
5772: oTypeSNodeType
5773: oPushResult
5774: equal_node_type
5775: oPop 2
5777: oChoice 5783
5779: oError 14
5781: oJumpForward 5786
5783: Choice Lookup Table
           0   5779
5786: oReturn
5787: oLocalSpace 0
5789: oTypeSNodeType
5790: oChoice 5794
5792: oJumpForward 5799
5794: Choice Lookup Table
          18   5792
5797: oError 7
5799: oTypeSPop
5800: oReturn
5801: oLocalSpace 0
5803: oTypeSNodeType
5804: oChoice 5808
5806: oJumpForward 5813
5808: Choice Lookup Table
          18   5806
5811: oError 7
5813: oReturn
5814: oLocalSpace 0
5816: oTypeSNodeType
5817: oChoice 5821
5819: oJumpForward 5826
5821: Choice Lookup Table
          19   5819
5824: oError 8
5826: oTypeSPop
5827: oReturn
5828: oLocalSpace 0
5830: oTypeSNodeType
5831: oChoice 5835
5833: oJumpForward 5840
5835: Choice Lookup Table
          19   5833
5838: oError 8
5840: oReturn
5841: oLocalSpace 1
5843: oGetAddrLocal 1
5845: oPushResult
5846: oGetParam 2
5848: oPushResult
5849: oNodeNew
5850: oPop 1
5852: oAssign
5853: oGetLocal 1
5855: oPushResult
5856: oSetResult 2
5858: oPushResult
5859: oGetParam 1
5861: oPushResult
5862: oNodeSetInt
5863: oPop 3
5865: oGetLocal 1
5867: oPushResult
5868: oTypeAdd
5869: oPop 1
5871: oGetLocal 1
5873: oReturn
5874: oReturn
5875: oLocalSpace 1
5877: oGetAddrLocal 1
5879: oPushResult
5880: oGetParam 3
5882: oPushResult
5883: oNodeNew
5884: oPop 1
5886: oAssign
5887: oGetLocal 1
5889: oPushResult
5890: oSetResult 5
5892: oPushResult
5893: oGetParam 1
5895: oPushResult
5896: oNodeSetInt
5897: oPop 3
5899: oGetLocal 1
5901: oReturn
5902: oReturn
5903: oLocalSpace 1
5905: oGetAddrLocal 1
5907: oPushResult
5908: oGetParam 1
5910: oPushResult
5911: oSetResult 19
5913: oPushResult
5914: oNodeGet
5915: oPop 2
5917: oAssign
5918: oGetLocal 1
5920: oPushResult
5921: oNodeNull
5922: oPop 1
5924: oChoice 5980
5926: oGetAddrLocal 1
5928: oPushResult
5929: oSetResult 23
5931: oPushResult
5932: oNodeNew
5933: oPop 1
5935: oAssign
5936: oGetLocal 1
5938: oPushResult
5939: oSetResult 20
5941: oPushResult
5942: oGetParam 1
5944: oPushResult
5945: oNodeSet
5946: oPop 3
5948: oGetLocal 1
5950: oPushResult
5951: oSetResult 2
5953: oPushResult
5954: oSetResult 8
5956: oPushResult
5957: oNodeSetInt
5958: oPop 3
5960: oGetLocal 1
5962: oPushResult
5963: oTypeAdd
5964: oPop 1
5966: oGetParam 1
5968: oPushResult
5969: oSetResult 19
5971: oPushResult
5972: oGetLocal 1
5974: oPushResult
5975: oNodeSet
5976: oPop 3
5978: oJumpForward 5983
5980: Choice Lookup Table
           1   5926
5983: oGetLocal 1
5985: oReturn
5986: oReturn
5987: oLocalSpace 0
5989: oGetParam 1
5991: oPushResult
5992: oNodeType
5993: oPop 1
5995: oChoice 6023
5997: oMININT
5998: oReturn
5999: oJumpForward 6037
6001: oSetResult 0
6003: oReturn
6004: oJumpForward 6037
6006: oSetResult 0
6008: oReturn
6009: oJumpForward 6037
6011: oGetParam 1
6013: oPushResult
6014: oSetResult 22
6016: oPushResult
6017: oNodeGetInt
6018: oPop 2
6020: oReturn
6021: oJumpForward 6037
6023: Choice Lookup Table
          25   6011
          21   6006
          19   6001
          18   5997
6032: oError 3
6034: oSetResult 0
6036: oReturn
6037: oReturn
6038: oLocalSpace 0
6040: oGetParam 1
6042: oPushResult
6043: oSetResult 7
6045: oPushResult
6046: oNodeGetInt
6047: oPop 2
6049: oPushResult
6050: oEmitInt
6051: oPop 1
6053: oReturn
6054: oLocalSpace 1
6056: oGetAddrGlobal 2
6058: oPushResult
6059: oSetResult 17
6061: oPushResult
6062: oSetResult 4
6064: oPushResult
6065: oCall 5841
6067: oPop 2
6069: oAssign
6070: oGetAddrGlobal 3
6072: oPushResult
6073: oSetResult 18
6075: oPushResult
6076: oSetResult 4
6078: oPushResult
6079: oCall 5841
6081: oPop 2
6083: oAssign
6084: oGetAddrGlobal 4
6086: oPushResult
6087: oSetResult 19
6089: oPushResult
6090: oSetResult 1
6092: oPushResult
6093: oCall 5841
6095: oPop 2
6097: oAssign
6098: oGetAddrGlobal 5
6100: oPushResult
6101: oSetResult 20
6103: oPushResult
6104: oSetResult 1
6106: oPushResult
6107: oCall 5841
6109: oPop 2
6111: oAssign
6112: oGetAddrGlobal 6
6114: oPushResult
6115: oSetResult 21
6117: oPushResult
6118: oSetResult 1
6120: oPushResult
6121: oCall 5841
6123: oPop 2
6125: oAssign
6126: oGetAddrGlobal 7
6128: oPushResult
6129: oSetResult 22
6131: oPushResult
6132: oSetResult 256
6134: oPushResult
6135: oCall 5841
6137: oPop 2
6139: oAssign
6140: oGetAddrLocal 1
6142: oPushResult
6143: oSetResult 10
6145: oPushResult
6146: oSetResult 5
6148: oPushResult
6149: oIdAdd_File
6150: oPushResult
6151: oCall 5875
6153: oPop 3
6155: oAssign
6156: oGetLocal 1
6158: oPushResult
6159: oSetResult 6
6161: oPushResult
6162: oGetGlobal 2
6164: oPushResult
6165: oNodeSet
6166: oPop 3
6168: oGetLocal 1
6170: oPushResult
6171: oScopeDeclare
6172: oPop 1
6174: oGetAddrLocal 1
6176: oPushResult
6177: oSetResult 10
6179: oPushResult
6180: oSetResult 5
6182: oPushResult
6183: oIdAdd_Integer
6184: oPushResult
6185: oCall 5875
6187: oPop 3
6189: oAssign
6190: oGetLocal 1
6192: oPushResult
6193: oSetResult 6
6195: oPushResult
6196: oGetGlobal 3
6198: oPushResult
6199: oNodeSet
6200: oPop 3
6202: oGetLocal 1
6204: oPushResult
6205: oScopeDeclare
6206: oPop 1
6208: oGetAddrLocal 1
6210: oPushResult
6211: oSetResult 10
6213: oPushResult
6214: oSetResult 5
6216: oPushResult
6217: oIdAdd_Boolean
6218: oPushResult
6219: oCall 5875
6221: oPop 3
6223: oAssign
6224: oGetLocal 1
6226: oPushResult
6227: oSetResult 6
6229: oPushResult
6230: oGetGlobal 4
6232: oPushResult
6233: oNodeSet
6234: oPop 3
6236: oGetLocal 1
6238: oPushResult
6239: oScopeDeclare
6240: oPop 1
6242: oGetAddrLocal 1
6244: oPushResult
6245: oSetResult 10
6247: oPushResult
6248: oSetResult 5
6250: oPushResult
6251: oIdAdd_Char
6252: oPushResult
6253: oCall 5875
6255: oPop 3
6257: oAssign
6258: oGetLocal 1
6260: oPushResult
6261: oSetResult 6
6263: oPushResult
6264: oGetGlobal 6
6266: oPushResult
6267: oNodeSet
6268: oPop 3
6270: oGetLocal 1
6272: oPushResult
6273: oScopeDeclare
6274: oPop 1
6276: oGetAddrLocal 1
6278: oPushResult
6279: oSetResult 10
6281: oPushResult
6282: oSetResult 5
6284: oPushResult
6285: oIdAdd_String
6286: oPushResult
6287: oCall 5875
6289: oPop 3
6291: oAssign
6292: oGetLocal 1
6294: oPushResult
6295: oSetResult 6
6297: oPushResult
6298: oGetGlobal 7
6300: oPushResult
6301: oNodeSet
6302: oPop 3
6304: oGetLocal 1
6306: oPushResult
6307: oScopeDeclare
6308: oPop 1
6310: oGetAddrLocal 1
6312: oPushResult
6313: oSetResult 9
6315: oPushResult
6316: oSetResult 4
6318: oPushResult
6319: oIdAdd_True
6320: oPushResult
6321: oCall 5875
6323: oPop 3
6325: oAssign
6326: oGetLocal 1
6328: oPushResult
6329: oSetResult 6
6331: oPushResult
6332: oGetGlobal 4
6334: oPushResult
6335: oNodeSet
6336: oPop 3
6338: oGetLocal 1
6340: oPushResult
6341: oSetResult 7
6343: oPushResult
6344: oSetResult 1
6346: oPushResult
6347: oNodeSetInt
6348: oPop 3
6350: oGetLocal 1
6352: oPushResult
6353: oScopeDeclare
6354: oPop 1
6356: oGetAddrLocal 1
6358: oPushResult
6359: oSetResult 9
6361: oPushResult
6362: oSetResult 4
6364: oPushResult
6365: oIdAdd_False
6366: oPushResult
6367: oCall 5875
6369: oPop 3
6371: oAssign
6372: oGetLocal 1
6374: oPushResult
6375: oSetResult 6
6377: oPushResult
6378: oGetGlobal 4
6380: oPushResult
6381: oNodeSet
6382: oPop 3
6384: oGetLocal 1
6386: oPushResult
6387: oSetResult 7
6389: oPushResult
6390: oSetResult 0
6392: oPushResult
6393: oNodeSetInt
6394: oPop 3
6396: oGetLocal 1
6398: oPushResult
6399: oScopeDeclare
6400: oPop 1
6402: oReturn
