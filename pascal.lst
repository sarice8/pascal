   2: title: 'Pascal Compiler 1.1.5 -- Jan 01 ''90';
         
      %
      %  Pascal.ssl
      %
      %  Pascal Compiler for the Amiga, by Steve Rice.
      %
      %  HISTORY
      %    11Sep89   First version, framework of parser.
      %    18Sep89   Added some semantic mechanisms.
      %    21Sep89   Added simple type references; expressions generate code.
      %    22Sep89   Allocate variable addresses as they're declared.
      %    24Sep89   Added arrays, pointers.
      %    27Sep89   Added for statement.
      %    23Oct89   Fixed for statement, so CYCLE goes to next step.
      %    01Jan90   Added string literals
      %    09Sep22   I have returned.  Migrate symbol table to schema, to ease development.
      %    01Oct22   Language: Switch from cycle/exit (Mac Pascal extension) to continue/break (Borland).
      %
      %  NOTES
      %    -  The 'value' of a var symbol is its allocated address.
      %    -  References to vars of intrinsic types, and pointer types,
      %       pushes the value of the var on the expr stack.  Referenecs to
      %       vars of compound types (arrays, records...) pushes the address
      %       on the expr stack.
      %    -  Just as there is only one type table entry for a given (named) type,
      %       there is only one type table entry for a pointer to a named type.
      %       When a pointer type is declared, a field in the TT entry of the
      %       type pointed to will be set to indicate the TT entry of the pointer
      %       to that type (0 means none defined yet).  When evaluating the
      %       expression @x, the type in that field in the entry for the type of x
      %       will be used (unless it's 0, in which case a new TT entry will be
      %       created).
      %
      %
      %  MISSING
      %
      %    - Consider non-ISO extensions.  e.g. 
      %      Dynamic arrays.  Objects.  But, perhaps stick to my old goal, standard Pascal.
      %
      %  PASCAL DOCS
      %      Here's some handy language material:
      %      https://www.freepascal.org/docs-html/ref/ref.html
      %      https://www.freepascal.org/docs-html/prog/prog.html
      %      https://en.wikipedia.org/wiki/Turbo_Pascal
      %      https://en.wikipedia.org/wiki/Pascal_(programming_language)#Standards
      %      http://www.standardpascaline.org/
      %
      
   2: input:
   2:    pIdent
   2:    pIntLit
   2:    pStrLit
   2:    pCharLit
   2:    pAssign       ':='
   2:    pSemiColon    ';'
   2:    pEqual        '='
   2:    pNotEqual     '<>'
   2:    pLess         '<'
   2:    pGreater      '>'
   2:    pLessEqual    '<='
   2:    pGreaterEqual '>='
   2:    pColon        ':'
   2:    pComma        ','
   2:    pLParen       '('
   2:    pRParen       ')'
   2:    pLSquare      '['
   2:    pRSquare      ']'
   2:    pCarat        '^'
   2:    pAt           '@'
   2:    pDot          '.'
   2:    pDotDot       '..'
   2:    pTimes        '*'
   2:    pDivide       '/'
   2:    pPlus         '+'
   2:    pMinus        '-'
   2:    pEof
   2:    pInvalid
      
      %  keywords  (built-in types 'integer', 'byte', 'char', etc, are not keywords,
      %             type constructors 'array', 'record', 'set' are keywords,
      %             pseudo-procedures 'writeln', 'readln' are keywords)
      %
      %             forward/external/name/cdecl appear in method modifiers, in fpc grammar.
      %             I'm making them keywords to simplify parsing, but could reconsider.
      
   2:    pProgram
   2:    pProcedure
   2:    pFunction
   2:    pConst
   2:    pType
   2:    pVar
   2:    pLabel
   2:    pBegin
   2:    pEnd
   2:    pArray
   2:    pRecord
   2:    pSet
   2:    pOf
   2:    pIf
   2:    pThen
   2:    pElse
   2:    pFor
   2:    pTo
   2:    pDownto
   2:    pDo
   2:    pWhile
   2:    pRepeat
   2:    pUntil
   2:    pContinue
   2:    pBreak
   2:    pCase
   2:    pOtherwise
   2:    pGoto
   2:    pAnd
   2:    pOr
   2:    pNot
   2:    pUses
   2:    pUnit
   2:    pInterface
   2:    pImplementation
   2:    pInitialization
   2:    pFinalization
   2:    pWriteln
   2:    pWrite
   2:    pReadln
   2:    pRead
      
   2:    pForward
   2:    pExternal
   2:    pName
   2:    pCdecl
   2:    ;
      
      
   2: output:
      
      %  Instructions for a stack machine (all vars are 32-bit integers)
      
   2:    tPushGlobalI      % <ptr> - push int value read from ptr
   2:    tPushGlobalB      % <ptr> - push byte value read from ptr
   2:    tPushGlobalP      % <ptr> - push ptr value read from ptr
   2:    tPushLocalI       % <offset> - push int value read from local var in current scope
   2:    tPushLocalB       % <offset> - push byte value read from local var in current scope
   2:    tPushLocalP       % <offset> - push ptr value read from local var in current scope
   2:    tPushParamI       % <offset> - push int value read from param in current scope
   2:    tPushParamB       % <offset> - push byte value read from param in current scope
   2:    tPushParamP       % <offset> - push ptr value read from param in current scope
   2:    tPushUpLocalI     % <uplevels> <offset> - push int value read from local var in a parent static scope
   2:    tPushUpLocalB     % <uplevels> <offset> - push byte value read from local var in a parent static scope
   2:    tPushUpLocalP     % <uplevels> <offset> - push ptr value read from local var in a parent static scope
   2:    tPushUpParamI     % <uplevels> <offset> - push int value read from param in a parent static scope
   2:    tPushUpParamB     % <uplevels> <offset> - push byte value read from param in a parent static scope
   2:    tPushUpParamP     % <uplevels> <offset> - push ptr value read from param in a parent static scope
   2:    tPushConstI       % <int> - push int value on stack (NOTE, used for BOOLEAN too)
   2:    tPushAddrGlobal   % <offset> - push ptr to global var (same as tPushConstP)
   2:    tPushAddrLocal    % <offset> - push ptr to local var
   2:    tPushAddrParam    % <offset> - push ptr to formal param (used by method to see its param)
   2:    tPushAddrActual   % <offset> - push ptr to actual param, in actuals space (used by caller)
   2:    tPushAddrUpLocal  % <uplevels> <offset> - push ptr to local var in a parent static scope
   2:    tPushAddrUpParam  % <uplevels> <offset> - push ptr to formal param in a parent static scope
   2:    tSwap             % swap the top two entries on the stack
   2:    tFetchI           % pop ptr from stack, and push int value it points to
   2:    tFetchB           %    "      "      "     "     byte  "   "    "
   2:    tFetchP           %    "      "      "     "     ptr   "   "    "   
   2:    tAssignI          % assign int value on top of stack to addr under it (pop both)
   2:    tAssignB          %   "    byte   "    "   "  "   "    "    "   "   "
   2:    tAssignP          %   "    ptr    "    "   "  "   "    "    "   "   "
   2:    tCopy             % <#bytes> - copy bytes.  tos=src, 2nd=dest (pop 2)
   2:    tCastBtoI         % zero-extend uint8_t to int32_t
   2:    tCastItoB         % truncate int32_t to uint8_t
   2:    tIncI             % increment int value on top of expr stack
   2:    tDecI             % decrement int value on top of expr stack
   2:    tMultI            % multiply top two integers (replacing with result)
   2:    tDivI
   2:    tAddPI            % add ptr (2nd value) and int (top value), resulting in a ptr
   2:    tAddI
   2:    tSubP
   2:    tSubPI
   2:    tSubI
   2:    tNegI             % top entry *= -1
   2:    tNot              % negate top boolean
   2:    tEqualB
   2:    tNotEqualB
   2:    tGreaterB         % B is uint8_t, so these are unsigned comparisons
   2:    tLessB
   2:    tGreaterEqualB
   2:    tLessEqualB
   2:    tEqualI           % top two entries equal? (pop 2, push 1) (true=1)
   2:    tNotEqualI        %    NOTE, these all work for booleans too, but I'm moving to tEqualB etc for those
   2:    tGreaterI         % 2nd entry greater than top entry? (pop 2, push answer)
   2:    tLessI  
   2:    tGreaterEqualI
   2:    tLessEqualI
   2:    tEqualP           % two two pointer values equal? (pop 2, push 1) (true=1)
   2:    tNotEqualP
   2:    tGreaterP
   2:    tLessP
   2:    tGreaterEqualP
   2:    tLessEqualP
   2:    tAllocActuals     % <#bytes> - make space on call stack for actual params (adjusting call stack sp)
   2:    tAllocActualsCdecl  % <#bytes> - starting a call to a cdecl method.  tcode still describes my own calling convention.
   2:    tFreeActuals      % <#bytes> - discard space on call stack allocated by tAllocActuals
   2:    tCall             % <label#>
   2:    tCallCdecl        % <label#> - call a method using native (C) calling convention. Only supported for extern labels.
   2:    tReturn
   2:    tEnter            % <#bytes> - start a stack frame on the call stack, reserving #bytes of local variable space
   2:    tJump             % <label#>
   2:    tJumpTrue         % <label#>  (pops top of stack, jumps if true)
   2:    tJumpFalse        % <label#>  (pops top of stack, jumps if false)
   2:    tJumpCaseB        % <label#>  pops uint8_t, jumps to case indicated by table at label (consisting of tCase, tCaseRange, tCaseEnd)
   2:    tJumpCaseI        % <label#>  pops integer, jumps to case indicated by table at label
   2:    tJumpCaseS        % <label#>  pops pointer to ShortString, jumps to case indicated by table at label
   2:    tCase             % <int> <label#>  - case table entry: if match int, goto label.  For tJumpCaseS, int is offset into global data.
   2:    tCaseRange        % <lowint> <highint> <label#>  - case table entry: if lowint <= value <= highint, goto label.  For tJumpCaseS, offsets into global.
   2:    tCaseEnd          % <label#> - end of case table.  Label points to no-match code (otherwise clause or end of statement).
   2:    tLabel            % <label#> - define label# at the current address
   2:    tLabelAlias       % <label#> <aliasToLabel#> - defines label to be an alias of another label
   2:    tLabelExtern      % <label#> <offsetToStrLit> - defines label to mean an extern symbol, whose name is in global data
   2:    tWriteI           % for writeln : write integer on tos, pop
   2:    tWriteBool        %  "     "    : write TRUE/FALSE, pop
   2:    tWriteChar        %  "     "    : write char, pop
   2:    tWriteShortStr    %  "     "    : write ShortString whose addr is on tos, pop
   2:    tWritePChar       %  "     "    : write a null-terminated string whose addr is on tos, pop
   2:    tWriteP           %  "     "    : write ptr var whose addr is on tos, pop
   2:    tWriteEnum        %  "     "    : write enum name.  Name table on tos, value under it, pop both
   2:    tWriteCR          %  "     "    : write cr
   2:    tFile             % <file#> - pascal source file id, for debugging.  I haven't decided yet how I will communicate the corresponding filename.
   2:    tLine             % <line#> - pascal source line number, for debugging
      
      %  Other:
      
   2:    tSpace            % emit a hole, to be patched later
   2:    ;
      
   2: error:
   2:    eBadStatement
   2:    eNotConst
   2:    eNotType
   2:    eNotOrdinalType
   2:    eNotVar
   2:    eNotIntVar
   2:    eNotValue
   2:    eNotInteger
   2:    eNotBoolean
   2:    eNotPointer
   2:    eNotArray
   2:    eNotRecord
   2:    eNotRecordField
   2:    eTooManySubscripts
   2:    eTypeMismatch
   2:    eMissingParameter
   2:    eNotImplemented
   2:    eNotAllowed
   2:    eNotInALoop
   2:    eRecordEmpty
   2:    eNotCurrentFunction
   2:    eAlreadyDefined
   2:    eOnlyOneVarCanBeInitialized
   2:    eExternalMethodCannotBeNested
   2:    eCantFindUnitFile
   2:    eInternalScopeMismatch
   2:    eEnumValueNotAscending
   2:    eUsedButNotDefined
   2:    eCantUsePredSuccOnEnumWithValueGaps
   2:    eCantDereference
   2:    ;
      
   2: include 'pascal_schema.ssl'
      
      % Generated automatically by schema
      
   2: type node_type:
   2: 	nINVALID
   2: 	Object
   2: 	nWorkspace
   2: 	nModule
   2: 	nProgram
   2: 	nUnit
   2: 	nUnitImpl
   2: 	nScope
   2: 	nDeclaration
   2: 	nIdent
   2: 	nUnitRef
   2: 	nMethod
   2: 	nProc
   2: 	nFunc
   2: 	nBuiltInFunc
   2: 	nBuiltInProc
   2: 	nConst
   2: 	nEnumValue
   2: 	nConstStr
   2: 	nTypeDecl
   2: 	nVar
   2: 	nGlobalVar
   2: 	nLocalVar
   2: 	nRecordField
   2: 	nParam
   2: 	nTypedConst
   2: 	nLabel
   2: 	nType
   2: 	nFileType
   2: 	nIntegerType
   2: 	nByteType
   2: 	nBooleanType
   2: 	nBooleanFlowType
   2: 	nCharType
   2: 	nPointerType
   2: 	nUniversalPointerType
   2: 	nArrayType
   2: 	nSubrangeType
   2: 	nRecordType
   2: 	nStrLitType
   2: 	nShortStringType
   2: 	nEnumType
   2: 	nSetType
   2: 	;
      
   2: type node_attribute:
   2: 	qINVALID
   2: 	qUnits
   2: 	qProgram
   2: 	qGlobalSize
   2: 	qIdent
   2: 	qUsedUnits
   2: 	qChildScope
   2: 	qMainRoutineScope
   2: 	qImpl
   2: 	qPublicScope
   2: 	qPrivateScope
   2: 	qInitLabel
   2: 	qFinalLabel
   2: 	qInitRoutineScope
   2: 	qLevel
   2: 	qDecls
   2: 	qExtends
   2: 	qSize
   2: 	qAllocMode
   2: 	qInitCode
   2: 	qParentScope
   2: 	qType
   2: 	qValue
   2: 	qParams
   2: 	qBodyDefined
   2: 	qExternal
   2: 	qExternalName
   2: 	qCdecl
   2: 	qUsed
   2: 	qOldParams
   2: 	qOldType
   2: 	qResultOffset
   2: 	qNameOffset
   2: 	qValueStr
   2: 	qInOut
   2: 	qDefined
   2: 	qPointerType
   2: 	qBaseType
   2: 	qIndexType
   2: 	qLow
   2: 	qHigh
   2: 	qScope
   2: 	qCapacity
   2: 	qNameTable
   2: 	qHasGap
   2: 	;
      
      
   2: type Node:     % A pointer to a node in the schema database (symbol database)
   2:    Null = 0
   2:    ;
      
   2: type NodeIter:   % An iterator over nodes in a list, in the schema database
   2:    NullIter = 0
   2:    ;
      
   2: type NodeVec:  % A pointer to a vector of Node.  See mechanism node_vec_mech
   2:    NullVec = 0
   2:    ;
      
   2: type boolean:
   2:    false    = 0
   2:    true     = 1;
      
      % intrinsic types & type constructs
      
   2: type typ:
   2:    tyNone     = 0    % in ptrTyp field of TT, means no ptr to type defined
   2:    tyInteger
   2:    tyBoolean
   2:    tyChar
   2:    tyString
   2:    tyFile            % tyInteger..tyFile are scalars (types on their own)
   2:    tyPointer         % following are type constructor classes...
   2:    tyArray           %   (they are not type#'s)
   2:    tyRecord
   2:    tyParams          % like record; a collection of proc/func params
   2:    tySet;
      
   2: type Label:
   2:    labelNull = 0;
      
      % An output code stream.
   2: type Code:
   2:    codeNull = 0
   2:    codeDefault = 1
   2:    ;
      
      % A string
   2: type String:
   2:    stringNull = 0
   2:    ;
      
      % allocation modes for oScopeBegin
   2: type AllocMode:
   2:    allocGlobal = 0  % allocate from global data
   2:    allocDown        % allocate down the stack
   2:    allocUp          % allocate up the stack
   2:    ;
      
      % Some general schema node operations.
      % node_type and node_attribute are defined in generated file pascal_schema.ssl included above.
      %
   2: mechanism node_mech:
   2:     oNodeNew (node_type) >> Node         % create new node
   2:     oNodeSet (Node, node_attribute, Node)   % set Node attribute of node
   2:     oNodeSetString (Node, node_attribute, String)
   2:     oNodeSetInt (Node, node_attribute, int) % set int attribute of node
   2:     oNodeSetBoolean (Node, node_attribute, boolean)
   2:     oNodeSetLabel( Node, node_attribute, Label )  % set Label attribute of node
   2:     oNodeSetCode( Node, node_attribute, Code )    % set Code attribute of node
   2:     oNodeAddLast( Node, node_attribute, Node value )  % append to a List attribute of node
   2:     oNodeGet (Node, node_attribute) >> Node    % get Node attribute of node
   2:     oNodeGetString (Node, node_attribute) >> String
   2:     oNodeGetInt (Node, node_attribute) >> int  % get int attribute of node
   2:     oNodeGetBoolean (Node, node_attribute) >> boolean  % get int attribute of node
   2:     oNodeGetLabel (Node, node_attribute) >> Label      % get Label attribute of node
   2:     oNodeGetCode (Node, node_attribute) >> Code        % get code stream attribute of node
   2:     oNodeNull (Node) >> boolean          % is node null?
   2:     oNodeFind (Node, node_attribute listAttr, node_attribute valueAttr, int value) >> Node  % find node with value in list
   2:     oNodeGetIter (Node, node_attribute) >> NodeIter   % get an iterator over nodes in a List attribute
   2:     oNodeGetIterLast (Node, node_attribute) >> NodeIter  % get an iterator over nodes in a List, starting at last
   2:     oNodeIterValue (NodeIter) >> Node             % the node that iter is referring to (NodeNull if no more nodes)
   2:     oNodeIterNext (inout NodeIter)                % advance iterator through list
   2:     oNodeIterPrev (inout NodeIter)                % advance iterator backwards through list
   2:     oNodeType (Node) >> node_type        % return node type of node
   2:     oNodeEqual (Node, Node) >> boolean   % compare two nodes for equality
                                               % (i.e. same node, not just same contents)
   2:     ;
      
      
      % Manipulate a temporary vector of Node
      %
   2: mechanism node_vec_mech:
   2:     oNodeVecNew >> NodeVec
   2:     oNodeVecDelete( NodeVec nv )
   2:     oNodeVecAppend( NodeVec nv, Node n )
   2:     oNodeVecSize( NodeVec nv ) >> int                % how many elements
   2:     oNodeVecElement( NodeVec nv, int idx ) >> Node   % element at index idx (0..size-1)
   2:     ;
      
      
      
   2: mechanism emit_mech:
   2:     oEmitInt( int )              % emit int into the generated code
   2:     oEmitLabel( Label )
   2:     oEmitCode( Code )            % append a code stream to the current code stream
   2:     Here >> int                  % current address in the generated code
                                       %   (only usable in the default code stream)
   2:     oPatch( int addr, int val )  % patch an int into address in the generated code
                                       %   (only usable in the default code stream)
   2:     ;
      
   2: mechanism math:
   2:     inc (inout int)
   2:     dec (inout int)
   2:     negate (int) >> int
   2:     add( int x, int y ) >> int
   2:     subtract( int x, int y ) >> int     % x - y
   2:     multiply( int x, int y ) >> int     % x * y
   2:     equal( int x, int y ) >> boolean
   2:     equal_zero (int) >> boolean
   2:     equal_node( Node, Node ) >> boolean
   2:     equal_string( String, String ) >> boolean
   2:     equal_node_type (node_type, node_type) >> boolean     % Want equal_<type> for every type
   2:     equal_label( Label, Label ) >> boolean
   2:     equal_code( Code, Code ) >> boolean
   2:     greater( int x, int y ) >> boolean
   2:     oMININT >> int    % the minimum 32-bit integer.
   2:     oMAXINT >> int    % the maximum 32-bit integer.
   2:     ;
      
   2: mechanism more_builtins:      % These should be built-in SSL operations
   2:     TOKEN_VALUE >> int        % value of just accepted token, e.g. IntLit token
   2:     LAST_ID >> int            % id number of last accepted identifier
   2:     ID_STRING( int id ) >> String       % text name of identifier with given id
   2:     CURRENT_STRLIT >> String            % text value of just-accepted string literal
   2:     ;
      
   2: mechanism workspace_mech:
   2:     oWorkspaceNew >> Node
   2:     ;
      
   2: mechanism scope_mech:
   2:     oScopeBegin( int level, AllocMode )  % create a new scope. Subsequent declarations will go here.
                                               %  level = static scope depth (0 = globals)
   2:     oScopeEnter( Node scope )            % enter an existing scope.
   2:     oScopeEnd                            % end current scope. Subsequent declarations will go to previous scope.
   2:     oScopeCurrent >> Node                % returns current scope
   2:     oScopeDeclare( Node decl )           % add declaration to current scope.
   2:     oScopeDeclareAlloc( Node decl )      % add declaration to current scope, and allocate space according to its type
   2:     oScopeAllocType( Node theType ) >> int   % allocate space for type in current scope, and return its address
   2:     oScopeAlloc( int size, int align ) >> int % allocate bytes, with given alignment in bytes 
   2:     oScopeFind >> Node                   % find declaration of last accepted identifier.  Returns Null if not found.
   2:     oScopeFindRequire >> Node            % find declaration of last accepted identifier.  Error if not found.
   2:     oScopeFindInCurrentScope >> Node     % find declaration of last accepted identifier, only within the current scope.  Null if not found.
   2:     oScopeFindRequireInScope( Node scope ) >> Node  % find decl of last accepted identifier, only within the given scope.  Error it not found.
   2:     ;
      
   2: mechanism type_mech:
   2:     oTypeAdd( Node node )     % add the given nType to the type table
   2:     ;
      
   2: mechanism type_stack_mech:
   2:     oTypeSPush( Node node )
   2:     oTypeSPop
   2:     oTypeSTop >> Node
   2:     oTypeSNodeType >> node_type          % node_type of the node on top of type stack, skipping subranges
   2:     ;
      
      
   2: mechanism id_mech:
          % gets/adds a predefined id to the scanner's id table, and returns the id code
   2:     oId_mysystem >> int
   2:     oId_ShortStringAppendShortString >> int
   2:     oId_ShortStringAppendChar >> int
   2:     oId_ShortStringCmp >> int
   2:     oId_File >> int
   2:     oId_Integer >> int
   2:     oId_Boolean >> int
   2:     oId_Char >> int
   2:     oId_Byte >> int
   2:     oId_Pointer >> int
   2:     oId_ShortString >> int
   2:     oId_True >> int
   2:     oId_False >> int
   2:     oId_Nil >> int
   2:     oId_Ord >> int
   2:     oId_Chr >> int
   2:     oId_Pred >> int
   2:     oId_Succ >> int
   2:     oChangeIntLitToLabelIdent    % change current token from pIntLit to pIdent "_label_<intlit>"
   2:     ;
      
      
      
   2: mechanism label_mech:
   2:    oLabelNew >> Label
   2:    ;
      
   2: mechanism code_mech:
   2:    oCodeNew >> Code         % create a new empty code stream
   2:    oCodePush( Code )        % change the current output code stream to the given one
   2:    oCodePop                 % restore the current code stream to the previous one
   2:    ;
      
   2: mechanism include_mech:
   2:    oIncludeUnitFile( int id ) >> boolean  % search for <unit>.pas and include it.
                                                % returns false if can't find.
   2:    oIncludeEnd              % stop including the current file
   2:    ;
      
      
   2: mechanism count :
   2:    oCountPush(int)          % start a new counter, with initial value
   2:    oCountInc
   2:    oCountDec
   2:    oCountIsZero >> boolean
   2:    oCountPop;
      
      
   2: mechanism value :              % value stack, to calc. const expr's
   2:    oValuePush(int)             % push an explicit int lit
   2:    oValuePushString(String)    % push string onto value stack
   2:    oValueTop >> int            % get top value on value stack
   2:    oValueTopString >> String
   2:    oValueSwap                  % swap top two
   2:    oValuePop
   2:    oValueCharToString          % convert top value from char to string
   2:    oValueNegate                % negate top numeric value
   2:    oValueEqual
   2:    oValueNotEqual
   2:    oValueLess
   2:    oValueGreater
   2:    oValueLessEqual
   2:    oValueGreaterEqual
   2:    oValueOr                    % boolean or
   2:    oValueAnd
   2:    oValueNot                   % boolean not
   2:    oValueAdd
   2:    oValueSub
   2:    oValueMult
   2:    oValueDiv
   2:    ;
      
   2: mechanism string :
   2:    oStringAllocLit( String ) >> int      % alloc global space for strlit, return address
   2:    oStringAllocShortStringLit( String ) >> int  % alloc global space for ShortString, return address
   2:    ;
      
      % track labels for the loop we're in, if any
   2: mechanism loop_mech:
   2:    oLoopPush( Label continueLabel, Label breakLabel )
   2:    oLoopContinueLabel >> Label
   2:    oLoopBreakLabel >> Label
   2:    oLoopPop
   2:    ;
      
      % for hacky debugging
   2: mechanism msg_mech:
   2:    oMsg( int num )             % print message "oMsg <num>"
   2:    oMsgTrace( int num )        % print message "oMsg <num>" followed by ssl traceback
   2:    oMsgNode( Node node )       % print node
   2:    oMsgNodeLong( Node node )   % print node with more detail
   2:    oMsgNodeVec( NodeVec vec )  % print node vec
   2:    ;
      
      
   2: rules
      
      % ----------------------------- Global Variables ----------------------------
      
   2: Node    workspace              % root of database
   2: Node    globalScope            % scope for globals in the current module
   2: Node    initScope              % scope for temporaries global var init,
                                     % and program main stmt / unit initialization stmts
      
   2: int     mysystemId               % id of identifier "mysystem"
      
      % built-in nTypes
   2: Node    FileType
   2: Node    IntegerType
   2: Node    BooleanType
   2: Node    BooleanFlowType
   2: Node    CharType
   2: Node    PCharType
   2: Node    ByteType
   2: Node    UniversalPointerType
   2: Node    StrLitType
   2: Node    ShortStringType
      
      % nBuiltInFunc
   2: Node    BuiltIn_Ord
   2: Node    BuiltIn_Chr
   2: Node    BuiltIn_Pred
   2: Node    BuiltIn_Succ
      
      % Declarations in unit mysystem that the compiler may refer to directly.
      
   2: Node    System_ShortStringAppendShortString
   2: Node    System_ShortStringAppendChar
   2: Node    System_ShortStringCmp
      
      
      % -------------------------- Forward Declarations -------------------------
      
   2: Block( node_type varNodeType, Label labelForBody );
   2: BlockDecls( node_type varNodeType );
   2: BlockStmt( Label labelForBody, Node varScope, boolean isMain );
   2: VarDecl( node_type varNodeType );
   2: newType( node_type nt, int size ) >> Node;
   2: newIdent( node_type nt, int id ) >> Node;
   2: EmitValue( Node decl );
   2: TypeRef( out Node theType );
   2: EnumTypeRef( out Node resultType );
   2: PointerTypeTo( Node theType ) >> Node;
   2: OrdinalLow( Node theType ) >> int;
   2: OrdinalHigh( Node theType ) >> int;
   2: AssignStmt( Node decl );
   2: BooleanExprControlFlow( out Label falseLabel );
   2: ExprAllowFlow( out Label falseLabel );
   2: BoolExprAllowFlow( out Label falseLabel );
   2: BoolTermAllowFlow( out Label falseLabel );
   2: BoolFactorAllowFlow( out Label falseLabel );
   2: ArithExprAllowFlow( out Label falseLabel );
   2: TermAllowFlow( out Label falseLabel );
   2: FactorAllowFlow( out Label falseLabel );
   2: PrimaryAllowFlow( out Label falseLabel );
      
   2: VarExpr( Node decl );
   2: LValueVar( Node decl, boolean writeable );
   2: IncVar( Node decl );
   2: DecVar( Node decl );
      
   2: FlowToVal( inout Label falseLabel );
   2: ValToFlow( out Label falseLabel );
   2: MoveIntoTempShortString >> int;
      
   2: DeclLevel( Node decl ) >> int;
   2: DeclUpLevels( Node decl ) >> int;
      
      % ----------------------------- Start ----------------------------
      
   2: MainRule:
   4:    @Program
   7:    ;
      
   7: include 'pascal_unit.ssl'
      
      %
      %  Pascal Compiler
      %
      
      % ------------------------------ Units -----------------------------
      
      
      % The uses clause is a list of units required by the user program or unit.
      % We will find and compile the named units (unless already loaded).
      % We do not make the unit interface visible to the user, the caller will do so later.
   7: UsesClause( Node user ):
   9:    {
   9:       pIdent
  11:       @Uses( LAST_ID, user )
  20:       [
  20:          | ',' :
  22:          | * :  >
  29:       ]
  29:    }   
  31:    ';'
  34:    ;
      
      
      % Process an implicit "uses mysystem" in every module, except in the mysystem unit itself.
      % (I'm calling the unit mysystem rather than system, so fpc doesn't use it to replace its own system unit.)
      %
  34: UsesMySystem( Node user ):
  36:    [ equal( oNodeGetInt( user, qIdent ), mysystemId )
  53:       | true :  >>
  55:       | * :
  60:    ]
  60:    @Uses( mysystemId, user )
  71:    ;
      
      
      % After processing the mysystem unit interface, grab certain declarations from it
      % that the compiler may want to refer to later.
      %
  71: FindSelectSystemDecls( Node unit ):
  73:    [ equal( oNodeGetInt( unit, qIdent ), mysystemId )
  90:       | true :
  91:          System_ShortStringAppendShortString = oNodeFind( oScopeCurrent, qDecls, qIdent, oId_ShortStringAppendShortString )
 108:          System_ShortStringAppendChar = oNodeFind( oScopeCurrent, qDecls, qIdent, oId_ShortStringAppendChar )
 125:          System_ShortStringCmp = oNodeFind( oScopeCurrent, qDecls, qIdent, oId_ShortStringCmp )
 142:       | * :
 147:    ]
 148:    ;
      
      
      % The given user module uses a unit with the given id,
      % which may or may not have been loaded already.
      %
 148: Uses( int id, Node user ):
 150:    Node unit = @FindOrCompileUnit( id )
 161:    [ equal_node( unit, Null )
 171:       | false :
 172:          oNodeAddLast( user, qUsedUnits, unit )
      
               % Put a declaration in the current scope, naming the unit and pointing to it.
               % This is to allow references to  <unit>.<identifier_in_unit>
 184:          Node unitRef = oNodeNew( nUnitRef )
 194:          oNodeSetInt( unitRef, qIdent, oNodeGetInt( unit, qIdent ) )
 213:          oNodeSet( unitRef, qPublicScope, oNodeGet( unit, qPublicScope ) )
 232:          oScopeDeclare( unitRef )
 238:       | * :
 243:    ];
      
      
      % If the given decl is for an nUnitRef, the program is using syntax <unit>.<identifier>
      % Parse the rest of that to find the intended decl.
      %
 244: ResolveUnitRef( inout Node decl ):
 246:    [ oNodeType( decl )
 253:       | nUnitRef :
 254:          Node scope = oNodeGet( decl, qPublicScope )
 267:          '.'
 269:          pIdent
 271:          decl = oScopeFindRequireInScope( scope )
 281:       | * :
 286:    ];
      
      
 287: EnterUsedUnits( Node user ):
         % Make the used units' public scopes directly visible.
         % This is done after the units are all compiled, so they don't interfere with each other incorrectly.
         % Units later in the list have priority.
 289:    NodeIter unitIt = oNodeGetIter( user, qUsedUnits )
 302:    {
 302:       Node unit = oNodeIterValue( unitIt )
 312:       [ oNodeNull( unit )
 319:          | false :
 320:             oScopeEnter( oNodeGet( unit, qPublicScope ) )
 333:          | * :
 338:             >
 340:       ]
 340:       oNodeIterNext( unitIt )
 346:    }
 349:    ;
      
 349: EndUsedUnits( Node user ):
         % Leave the units' public scopes, so no longer visible.
 351:    NodeIter unitIt = oNodeGetIterLast( user, qUsedUnits )
 364:    {
 364:       Node unit = oNodeIterValue( unitIt )
 374:       [ oNodeNull( unit )
 381:          | false :
                  % Consistency check.  Make sure our scope enter / end have lined up correctly.
 382:             [ oNodeEqual( oScopeCurrent, oNodeGet( unit, qPublicScope ) )
 398:                | true :
 399:                | false :  #eInternalScopeMismatch
 403:             ]
 411:             oScopeEnd
 412:          | * :
 417:             >
 419:       ]
 419:       oNodeIterPrev( unitIt )
 425:    }
 428:    ;
      
      
 428: FindOrCompileUnit( int id ) >> Node:
         % We might have this unit loaded already
 430:    Node unit = oNodeFind( workspace, qUnits, qIdent, id )
 449:    [ equal_node( unit, Null )
 459:       | false :  >> unit
 463:       | * :
 468:    ]
      
         % If not, search for the source file on disk
 468:    boolean ok = oIncludeUnitFile( id )
 478:    [ ok
 481:       | false :  #eCantFindUnitFile  >> Null
 487:       | * :
 492:    ]
      
         % compile it, adding it into the workspace
         % then return it.
 492:    unit = @Unit
      
         % TO DO: ensure we are at pEof
         % end the include
 498:    oIncludeEnd
 499:    >> unit;
      
      
      
 503: Unit >> Node:
 505:    pUnit
 507:    pIdent
 509:    Node unit = oNodeNew( nUnit )
 519:    oNodeSetInt( unit, qIdent, LAST_ID )
 530:    Node unitImpl = oNodeNew( nUnitImpl )
 540:    oNodeSetInt( unitImpl, qIdent, LAST_ID )
 551:    oNodeSet( unit, qImpl, unitImpl )
 563:    ';'
      
         % mandatory sections
      
 565:    pInterface
 567:    @UsesMySystem( unit )
 574:    [
 574:       | pUses :   @UsesClause( unit )
 583:       | * :
 588:    ]
 588:    @EnterUsedUnits( unit )
      
 595:    oScopeBegin( 0, allocGlobal )
 604:    oNodeSet( unit, qPublicScope, oScopeCurrent )
 615:    globalScope = oScopeCurrent
      
         % A scope for temporaries needed by variable initialization
 620:    oScopeBegin( 0, allocDown )
 629:    initScope = oScopeCurrent
 634:    oNodeSet( unit, qInitRoutineScope, initScope )
 646:    oScopeEnd
      
 647:    @UnitInterface( unit )
 654:    oScopeEnd  % interface scope
      
 655:    pImplementation
 657:    @UsesMySystem( unitImpl )
 664:    [
 664:       | pUses :   @UsesClause( unitImpl )
 673:       | * :
 678:    ]
 678:    @EnterUsedUnits( unitImpl )
         % re-enter interface scope after impl's uses.  interface still has priority.
 685:    oScopeEnter( oNodeGet( unit, qPublicScope ) )
         
 698:    oScopeBegin( 0, allocGlobal )
 707:    oNodeSet( unit, qPrivateScope, oScopeCurrent )
 718:    oNodeSet( oScopeCurrent, qExtends, oNodeGet( unit, qPublicScope ) )
 736:    globalScope = oScopeCurrent
 741:    @UnitImplementation( unit )
      
 748:    [
 748:       | pInitialization :  @UnitInitialization( unit, true )   % init routine with statements from init section
 760:       | * :                @UnitInitialization( unit, false )  % implicit init routine
 775:    ]
 775:    [
 775:       | pFinalization :  @UnitFinalization( unit, true )
 787:       | * :              @UnitFinalization( unit, false )   % implicit final routine, may be handy later
 802:    ]
 802:    pEnd  '.'
      
 806:    oScopeEnd  % impl scope
 807:    oScopeEnd  % interface scope
 808:    @EndUsedUnits( unitImpl )  % used units scopes
 815:    @EndUsedUnits( unit )
 822:    oNodeAddLast( workspace, qUnits, unit )
 834:    >> unit;
      
      
 838: UnitInterface( Node unit ):
 840:    {[
 840:       | pConst :     @ConstDecl
 844:       | pType :      @TypeDecl
 848:       | pVar :       @VarDecl( nGlobalVar )
            % label declaration not allowed in interface
      
 857:       | pProcedure :
 859:          Node decl = @ProcHeaderDecl
               % despite syntax diagrams, fpc does allow external clause on methods in unit interface,
               % even though this clause is an alternative for the body statement.
 865:          [
 865:             | pExternal :
 867:                @ExternalDecl( decl )
 874:                ';'
 876:             | * :
 881:          ]
      
 881:       | pFunction :
 883:          Node decl = @FuncHeaderDecl
 889:          [
 889:             | pExternal :
 891:                @ExternalDecl( decl )
 898:                ';'
 900:             | * :
 905:          ]
      
 905:       | * :          >
 920:    ]}
 922:    @FindSelectSystemDecls( unit )
 930:    ;
      
 930: UnitImplementation( Node unit ):
 932:    @BlockDecls( nGlobalVar )
 940:    ;
      
      
 940: UnitInitialization( Node unit, boolean hasStmts ):
 942:    Label label = oLabelNew
 947:    .tLabel  oEmitLabel( label )
 955:    oNodeSetLabel( unit, qInitLabel, label )
      
 967:    int patchLS
 967:    .tEnter  patchLS = Here  .tSpace
      
         % insert any code for initialization of this unit's variables.
         
 976:    Node scope
 976:    Code initCode
      
 976:    scope = oNodeGet( unit, qPublicScope )
 989:    initCode = oNodeGetCode( scope, qInitCode )
1002:    oEmitCode( initCode )
1008:    oNodeSetCode( scope, qInitCode, codeNull )
      
1020:    scope = oNodeGet( unit, qPrivateScope )
1033:    initCode = oNodeGetCode( scope, qInitCode )
1046:    oEmitCode( initCode )
1052:    oNodeSetCode( scope, qInitCode, codeNull )
      
1064:    oScopeEnter( oNodeGet( unit, qInitRoutineScope ) )
      
1077:    [ hasStmts
1080:       | true :     
1081:          @Statement
1083:          {[
1083:             | ';' :  @Statement
1087:             | * :    >
1094:          ]}
1096:       | * :
1101:    ]
      
1101:    .tReturn
      
1103:    int localSpace = oNodeGetInt( oScopeCurrent, qSize )
1115:    oPatch( patchLS, localSpace )
1124:    oScopeEnd   % init routine scope, for temporaries
1126:    ;
      
      
1126: UnitFinalization( Node unit, boolean hasStmts ):
1128:    Label label = oLabelNew
1133:    .tLabel  oEmitLabel( label )
1141:    oNodeSetLabel( unit, qFinalLabel, label )
      
1153:    int patchLS
1153:    .tEnter  patchLS = Here  .tSpace
      
         % final routine scope, for temporaries
1162:    oScopeBegin( 0, allocDown )
      
1171:    [ hasStmts
1174:       | true :     
1175:          @Statement
1177:          {[
1177:             | ';' :  @Statement
1181:             | * :    >
1188:          ]}
1190:       | * :
1195:    ]
      
1195:    .tReturn
      
1197:    int localSpace = oNodeGetInt( oScopeCurrent, qSize )
1209:    oPatch( patchLS, localSpace )
1218:    oScopeEnd   % final routine scope, for temporaries
1220:    ;
      
      
1220: InitializeUnits:
         % call init routine of each loaded unit, in the order they were loaded
         % (used directly or indirectly by the main program).
1222:    NodeIter it = oNodeGetIter( workspace, qUnits )
1235:    {
1235:       Node unit = oNodeIterValue( it )
1245:       [ oNodeNull( unit )
1252:          | true :  >
1255:          | false :
1257:             .tAllocActuals  oEmitInt( 0 )  % not sure I need this. maybe for stack alignment.
1265:             .tCall  oEmitLabel( oNodeGetLabel( unit, qInitLabel ) )
1280:             .tFreeActuals  oEmitInt( 0 )
1288:             oNodeIterNext( it )
1294:       ]
1302:    };
      
      
1305: FinalizeUnits:
1307:    NodeIter it = oNodeGetIterLast( workspace, qUnits )
1320:    {
1320:       Node unit = oNodeIterValue( it )
1330:       [ oNodeNull( unit )
1337:          | true :  >
1340:          | false :
1342:             .tAllocActuals  oEmitInt( 0 )  % not sure I need this. maybe for stack alignment.
1350:             .tCall  oEmitLabel( oNodeGetLabel( unit, qFinalLabel ) )
1365:             .tFreeActuals  oEmitInt( 0 )
1373:             oNodeIterPrev( it )
1379:       ]
1387:    };
      
1390: include 'pascal_decl.ssl'
      %
      % Pascal Compiler
      %
      
      % ----------------------------- Declarations ----------------------------
      
      
      
      % modifers that may appear on a proc/function declaration.
      %
1390: MethodModifiers( Node decl ):
1392:    {[
1392:       | pCdecl :
1394:          oNodeSetBoolean( decl, qCdecl, true )
1406:          ';'
      
1408:       | * : >
1415:    ]}
1418:    ;
      
      
      % external method resides in an external object file
      % (or in my system, the built-in runtime library).
      % The method has a label, as usual, which callers will use.
      % But we define that label with .tLabelExtern rather than .tLabel.
      %
      % Note, I'll hold off on issuing the .tLabelExtern until we see that
      % the external method is actually called.  Otherwise we'd fill each output file
      % with all the external method names in my included libraries, which seems dumb.
      %
      % Note this is fpc syntax.  I'm not sure about other Pascals.
      %
1418: ExternalDecl( Node decl ):
1420:    [ equal_zero( @DeclLevel( decl ) )
1432:       | false :  #eExternalMethodCannotBeNested
1435:       | * :
1440:    ]
1440:    oNodeSetBoolean( decl, qExternal, true )
1452:    [
1452:       | pStrLit :
               % that was the optional library name containing the method.
               % TO DO: I'm currently ignoring this.
1454:          [
1454:             | pName :
1456:                pStrLit
                     % that was the optional method name defined in that library,
                     % which might differ from the Pascal name.
1458:                oNodeSetString( decl, qExternalName, CURRENT_STRLIT )
1469:             | * :
1474:          ]
1474:       | * :
1479:    ]
1480:    ;
      
      
1480: ProcHeaderDecl >> Node:
1482:    pIdent
      
         % If we already have a forward declaration, we'll modify that decl
         % instead of creating a second symbol table entry.
         % (Alternatively could delete or hide the old entry.)
1484:    boolean redeclaring = false
1490:    Node decl = oScopeFindInCurrentScope
      
1495:    [ oNodeNull( decl )
1502:       | true :
               % first declaration
1503:          decl = @newIdent( nProc, LAST_ID )
1516:          oNodeSetLabel( decl, qValue, oLabelNew )
      
1527:       | false :
               % we already have a declaration.
               % Keep it, and its label.
1529:          redeclaring = true
1535:          [ oNodeGetBoolean( decl, qBodyDefined )
1545:             | true : #eAlreadyDefined
1548:             | * :
1553:          ]
1553:          [ oNodeGetBoolean( decl, qExternal )
1563:             | true : #eAlreadyDefined
1566:             | * :
1571:          ]
1571:          [ oNodeType( decl )
1578:             | nProc :
1579:             | * : #eAlreadyDefined   % wrong kind
1586:          ]
               % Move the existing param scope aside, so we can check that the
               % new one is consistent.  And, the body will want to see the new one
               % since the names might differ.
               % TO DO: If qOldParams already set, we have multiple forward decls,
               % which I believe is supposed to be an error.
1586:          oNodeSet( decl, qOldParams, oNodeGet( decl, qParams ) )
1605:          oNodeSet( decl, qParams, Null )
1617:    ]
      
1625:    int level = @ScopeLevel
1631:    boolean nested = greater( level, 0 )
1644:    inc( level )
1650:    oScopeBegin( level, allocUp )
1659:    Node paramScope = oScopeCurrent
      
         % A nested method has a hidden first param for the parent static scope.
         % This won't appear in the param decls list, just reserve space for it.
         % It's first so the static chain is always at a fixed offset from the frame pointer.
1664:    [ nested
1667:       | true :
1668:          int offset = oScopeAllocType( @PointerTypeTo( IntegerType ) )   % arbitrary ptr type
1683:       | * :
1688:    ]
      
1688:    @FormalArgDecl
1690:    oNodeSet( decl, qParams, paramScope )
1702:    oScopeEnd
1703:    ';'
      
1705:    [ redeclaring
1708:       | false : oScopeDeclare( decl )
1715:       | true :  % TO DO: check that qParams is consistent with qOldParams
1717:    ]
      
1725:    @MethodModifiers( decl )
1732:    >> decl;
      
      
1736: ProcDecl:
1738:    Node decl = @ProcHeaderDecl
      
         % Body may be a statement, "forward", "external".
         % Note, this syntax is based on FPC, and I'm not sure if other Pascals are similar.
         % FPC says that forward, external, cdecl, name, etc are not reserved words -
         % I think this means the user may declare other things with those names, but if so the
         % original meaning is lost.  I'll make them keywords for simplicity, for now
         % (just not too happy about "name").
      
1744:    [
1744:       | pForward :
               % Nothing to do.  We simply won't set qBodyDefined.
      
1746:       | pExternal : @ExternalDecl( decl )
      
1755:       | * :
               % Body statement
      
               % Enter the params scope again, so params are visible in body.
               % TO DO: Perhaps I could mark the scope read-only at this point.
1762:          Node paramScope = oNodeGet( decl, qParams )
1775:          oScopeEnter( paramScope )
      
               % Start scope for declarations within the proc
1781:          int level = oNodeGetInt( paramScope, qLevel )
1794:          oScopeBegin( level, allocDown )
1803:          oNodeSet( decl, qChildScope, oScopeCurrent )
      
1814:          Label label = oNodeGetLabel( decl, qValue )
1827:          @Block( nLocalVar, label )
1837:          oNodeSetBoolean( decl, qBodyDefined, true )
1849:          oScopeEnd
      
1850:          oScopeEnd  % paramScope
1851:    ]
1851:    ';';
      
      
      
1854: FuncHeaderDecl >> Node:
1856:    pIdent
      
         % If we already have a forward declaration, we'll modify that decl
         % instead of creating a second symbol table entry.
         % (Alternatively could delete or hide the old entry.)
1858:    boolean redeclaring = false
1864:    Node decl = oScopeFindInCurrentScope
      
1869:    [ oNodeNull( decl )
1876:       | true :
               % first declaration
1877:          decl = @newIdent( nFunc, LAST_ID )
1890:          oNodeSetLabel( decl, qValue, oLabelNew )
      
1901:       | false :
               % we already have a declaration.
               % Keep it, and its label.
1903:          redeclaring = true
1909:          [ oNodeGetBoolean( decl, qBodyDefined )
1919:             | true : #eAlreadyDefined
1922:             | * :
1927:          ]
1927:          [ oNodeType( decl )
1934:             | nFunc :
1935:             | * : #eAlreadyDefined   % wrong kind
1942:          ]
               % Move the existing param scope and return value aside,
               % so we can check that the new one is consistent.
               % And, the body will want to see the new one since the names might differ.
               % TO DO: If qOldParams already set, we have multiple forward decls,
               % which I believe is supposed to be an error.
1942:          oNodeSet( decl, qOldParams, oNodeGet( decl, qParams ) )
1961:          oNodeSet( decl, qParams, Null )
1973:          oNodeSet( decl, qOldType, oNodeGet( decl, qType ) )
1992:          oNodeSet( decl, qType, Null )
2004:    ]
      
2012:    int level = @ScopeLevel
2018:    boolean nested = greater( level, 0 )
2031:    inc( level )
2037:    oScopeBegin( level, allocUp )
2046:    Node paramScope = oScopeCurrent
      
         % A nested method has a hidden first param for the parent static scope.
         % This won't appear in the param decls list, just reserve space for it.
         % It's first so the static chain is always at a fixed offset from the frame pointer.
2051:    [ nested
2054:       | true :
2055:          int offset = oScopeAllocType( @PointerTypeTo( IntegerType ) )   % arbitrary ptr type
2070:       | * :
2075:    ]
      
2075:    @FormalArgDecl
2077:    oNodeSet( decl, qParams, paramScope )
      
2089:    ':'
      
2091:    Node theType
2091:    @TypeRef( theType )
2098:    oNodeSet( decl, qType, theType )
      
         % The function's param space gets an additional pointer,
         % which will point to a temporary in the caller's scope.
         % This pointer is essentially a VAR param, but I won't create an nParam for it.
      
2110:    Node ptrType = @PointerTypeTo( theType )
2121:    oNodeSetInt( decl, qResultOffset, oScopeAllocType( ptrType ) )
2137:    oScopeEnd
2138:    ';'
      
2140:    [ redeclaring
2143:       | false : oScopeDeclare( decl )
2150:       | true :  % TO DO: check that qParams is consistent with qOldParams
                      % and qType is consistent with qOldType
2152:    ]
      
2160:    @MethodModifiers( decl )
      
2167:    >> decl;
      
      
2171: FuncDecl:
2173:    Node decl = @FuncHeaderDecl
      
         % Body may be a statement, "forward", "external".
2179:    [
2179:       | pForward :
               % Nothing to do.  We simply won't set qBodyDefined.
      
2181:       | pExternal : @ExternalDecl( decl )
      
2190:       | * :
               % Body statement
      
               % Enter the params scope again, so params are visible in body.
               % TO DO: Perhaps I could mark the scope read-only at this point.
2197:          Node paramScope = oNodeGet( decl, qParams )
2210:          oScopeEnter( paramScope )
      
               % Start scope for declarations within the func
2216:          int level = oNodeGetInt( paramScope, qLevel )
2229:          oScopeBegin( level, allocDown )
2238:          oNodeSet( decl, qChildScope, oScopeCurrent )
      
2249:          Label label = oNodeGetLabel( decl, qValue )
2262:          @Block( nLocalVar, label )
2272:          oNodeSetBoolean( decl, qBodyDefined, true )
2284:          oScopeEnd
      
2285:          oScopeEnd  % paramScope
2286:    ]
2286:    ';';
      
      
2289: FormalArgDecl:
2291:    [
2291:       | '(' :
2293:          {
2293:             NodeVec decls = oNodeVecNew
2298:             Node decl
2298:             boolean isInOut = false
      
2304:             [
2304:                | pVar : isInOut = true
2312:                | * :
2317:             ]
      
2317:             {  pIdent
      
2319:                decl = @newIdent( nParam, LAST_ID )
2332:                oNodeSetBoolean( decl, qInOut, isInOut )
2344:                oNodeVecAppend( decls, decl )
      
2353:                [
2353:                   | ':' : >
2357:                   | ',' :
2359:                ]
2367:             }
      
2369:             Node theType
2369:             @TypeRef( theType )
      
                  % VAR param is declared with its given type, but allocated as a pointer.
2376:             Node allocType
2376:             [ isInOut
2379:                | true :   allocType = @PointerTypeTo( theType )
2391:                | * :      allocType = theType
2402:             ]
      
2402:             int i = 0
2408:             {[ equal( i, oNodeVecSize( decls ) )
2422:                | false :
2423:                   decl = oNodeVecElement( decls, i )
      
2436:                   oNodeSet( decl, qType, theType )
2448:                   oScopeDeclare( decl )
2454:                   oNodeSetInt( decl, qValue, oScopeAllocType( allocType ) )
2470:                   inc( i )
2476:                | * :
2481:                   >
2483:             ]}
      
2485:             oNodeVecDelete( decls )
      
2491:             [
2491:                | ')' : >
2495:                | ';' :
2497:             ]
2505:          }
2507:       | * :
2512:    ];
      
      
2513: ConstDecl:
2515:    {[
2515:       | pIdent :
2517:          [
2517:             | ':' :
2519:                @TypedConstDecl
2521:             | * :
2526:                @TrueConstDecl
2528:          ]
2528:       | * :
2533:          >
2535:    ]};
      
      
      % Parse a true constant declaration (as opposed to a typed const declaration).
      % The "true constant" terminology comes from Delphi docs.  It refers to a const that is
      % evaluated at compile time, rather than at program startup time.
      %
      % We've just accepted the identifier.
      %
2538: TrueConstDecl:
2540:    int id = LAST_ID
2545:    '='
      
2547:    @ConstExpr
      
2549:    Node decl
2549:    [ oTypeSNodeType
2551:       | nBooleanType, nByteType, nCharType, nIntegerType, nEnumType,
2552:         nPointerType, nUniversalPointerType :
2552:          decl = @newIdent( nConst, id )
2566:          oNodeSetInt( decl, qValue, oValueTop )
2577:       | nStrLitType :
2579:          decl = @newIdent( nConstStr, id )
2593:          oNodeSetString( decl, qValueStr, oValueTopString )
2604:       | * :  #eNotAllowed
2625:    ]
2625:    oValuePop
2626:    oNodeSet( decl, qType, oTypeSTop )
2637:    oTypeSPop
2638:    oScopeDeclare( decl )
2644:    ';'
2647:    ;
      
      
      % Parse a typed const declaration.
      % We've just accepted the identifier and ':'
      %
2647: TypedConstDecl:
2649:    Node decl = @newIdent( nTypedConst, LAST_ID )
      
2662:    Node theType
2662:    @TypeRef( theType )
2669:    oNodeSet( decl, qType, theType )
      
         % Array and record consts are allocated in global memory,
         % with global offset stored as decl value.
         % Scalar consts are not allocated in memory, and their value is
         % stored directly as the decl value, as I do with "true constants".
         %
         % TO DO: I probably should store scalar consts in memory too, in case somebody
         % wants to get a pointer to them.  And anyway, typed constants can't be used in
         % constant expressions, so less need to store value in decl node.
      
         % TO DO: skip subranges, similar to oTypeSNodeType.
2681:    [ oNodeType( theType )
2688:       | nBooleanType, nByteType, nCharType, nIntegerType, nEnumType,
2689:         nPointerType, nUniversalPointerType :
               % Parse expression and store value in decl
2689:          '='
      
2691:          oTypeSPush( theType )
2697:          @ConstExpr
2699:          @ConstCoerceType
      
2701:          oNodeSetInt( decl, qValue, oValueTop )
2712:          oValuePop
2713:          oTypeSPop
2714:          oScopeDeclare( decl )
2720:          ';'
      
2722:       | nShortStringType, nFileType :
2724:          #eNotImplemented
      
2726:       | nArrayType, nRecordType :
               % Allocate global space, store address in decl.
               % Push into global scope init code stream (since we'll be issuing code
               % rather than creating static data, at the moment).
               % Parse expression and store in global memory.
2728:          oScopeEnter( globalScope )
2734:          int addr = oScopeAllocType( theType )
2744:          oScopeEnd
2745:          oCodePush( @GetOrCreateInitCode( globalScope ) )
2756:          oNodeSetInt( decl, qValue, addr )
2768:          '='
2770:          @TypedConstInit( theType, addr )
2780:          oCodePop
2781:          oScopeDeclare( decl )
2787:          ';'
2789:    ]
2816:    ;
      
      
      % Parse the initial value of a constant that's being stored in global memory.
      % (An array or record constant, and recursively all its elements.)
      % Given the type, and the address in global memory for the const value.
      % The caller has already pushed into the global init code stream.
      %
2816: TypedConstInit( Node theType, int addr ):
      
         % TO DO: skip subranges, similar to oTypeSNodeTYpe
2818:    [ oNodeType( theType )
2825:       | nArrayType :
2826:          Node baseType = oNodeGet( theType, qBaseType )
2839:          Node indexType = oNodeGet( theType, qIndexType )
2852:          int low = @OrdinalLow( indexType )
2863:          int high = @OrdinalHigh( indexType )
2874:          int elementSize = oNodeGetInt( baseType, qSize )
      
2887:          '('
               % Loop over elements
2889:          int i = low
2895:          {
2895:             @TypedConstInit( baseType, addr )
2905:             [ equal( i, high )
2915:                | true : >
2918:                | false :
2920:             ]
2928:             ','
2930:             addr = add( addr, elementSize )
2943:             inc( i )
2949:          }
2951:          ')'
      
2953:       | nRecordType :
2955:          '('
2957:          Node fieldScope = oNodeGet( theType, qScope )
               % Loop over zero or more named fields.  It's not necessary to name them all.
               % fpc says the names that are given should be in order, but I'm not requiring that.
               % Since this is global memory, uninitialized fields will be left as 0.
2970:          {
2970:             [
2970:                | pIdent :
2972:                | * :  >
2979:             ]
2979:             Node field = oScopeFindRequireInScope( fieldScope )
2989:             ':'
2991:             Node fieldType = oNodeGet( field, qType )
3004:             int fieldAddr = add( addr, oNodeGetInt( field, qValue ) )
3024:             @TypedConstInit( fieldType, fieldAddr )
3034:             [
3034:                | ';' :
3036:                | * :  >
3043:             ]
3043:          }
3045:          ')'
      
3047:       | nBooleanType, nByteType, nCharType:
3049:          .tPushAddrGlobal  oEmitInt( addr )
3057:          oTypeSPush( theType )
3063:          @ConstExpr
3065:          @ConstCoerceType
3067:          .tPushConstI  oEmitInt( oValueTop )
3074:          oValuePop
3075:          oTypeSPop
3076:          .tAssignB
      
3078:       | nIntegerType, nEnumType:
3080:          .tPushAddrGlobal  oEmitInt( addr )
3088:          oTypeSPush( theType )
3094:          @ConstExpr
3096:          @ConstCoerceType
3098:          .tPushConstI  oEmitInt( oValueTop )
3105:          oValuePop
3106:          oTypeSPop
3107:          .tAssignI
      
3109:       | nPointerType, nUniversalPointerType :
3111:          .tPushAddrGlobal  oEmitInt( addr )
3119:          oTypeSPush( theType )
3125:          @ConstExpr
3127:          @ConstCoerceType
3129:          .tPushConstI  oEmitInt( oValueTop )   % only allowing ptr constant Nil so don't need tPushConstP or link redirection
3136:          oValuePop
3137:          oTypeSPop
3138:          .tAssignP
      
3140:       | nShortStringType, nFileType :
3142:          #eNotImplemented
3144:    ]
3171:    ;
      
      
3171: TypeDecl:
3173:    {[
3173:       | pIdent :
3175:          Node decl = @newIdent( nTypeDecl, LAST_ID )
3188:          '='
3190:          Node theType
3190:          @TypeRef( theType )
3197:          oNodeSet( decl, qType, theType )
3209:          oScopeDeclare( decl )
3215:          ';'
3217:       | * :
3222:          >
3224:    ]};
      
3227: VarDecl( node_type varNodeType ):
3229:    {[
3229:       | pIdent :
3231:          NodeVec decls = oNodeVecNew
3236:          Node decl
3236:          {
3236:             decl = @newIdent( varNodeType, LAST_ID )
3249:             oNodeVecAppend( decls, decl )
3258:             [
3258:                | ',' :
3260:                   pIdent
3262:                | * :
3267:                   >
3269:             ]
3269:          }
3271:          ':'
3273:          Node theType
3273:          @TypeRef( theType )
      
3280:          int i = 0
3286:          {[ equal( i, oNodeVecSize( decls ) )
3300:             | false :
3301:                decl = oNodeVecElement( decls, i )
3314:                oNodeSet( decl, qType, theType )
3326:                oScopeDeclareAlloc( decl )
3332:                inc( i )
3338:             | * :
3343:               >
3345:          ]}
      
               % optional initialization
3347:          [
3347:             | '=' :
3349:                [ oNodeVecSize( decls )
3356:                   | 1 :
3357:                   | * :  #eOnlyOneVarCanBeInitialized
3364:                ]
      
                     % we need an initCode stream for this scope
3364:                Code initCode = @GetOrCreateInitCode( oScopeCurrent )
3374:                oCodePush( initCode )
      
                     % currently the global level has two scopes:
                     % the one for declarations e.g. vars and methods,
                     % and a second one for temporaries needed by the main block stmt.
                     % During evaluation of the init expr, we need to be in the 2nd scope
                     % in case the expression requires temporaries
                     % (so the temporaries get allocated in the right scope).
                     % TO DO: Maybe I should make the global scope the special case, instead.
3380:                boolean changedScope = false
3386:                [ equal_zero( @ScopeLevel )
3393:                   | true : oScopeEnter( initScope )
3400:                            changedScope = true
3406:                   | * :
3411:                ]
                     % generate assignment in initCode stream
3411:                @LValueVar( decl, true )
3421:                @Expr
3423:                @CoerceType
3425:                @Assign
3427:                [ changedScope
3430:                   | true : oScopeEnd
3432:                   | * :
3437:                ]
3437:                oCodePop
                   
3438:             | * :
3443:          ]
      
3443:          oNodeVecDelete( decls )
3449:          ';'
3451:       | * :
3456:          >
3458:    ]};
      
      
      % Parse a list of label declarations.
      % We'll create a tcode label at declaration time, for each user label.
      % If the user label is an integer, we'll record it as _label_<int> in the decl.
      %
3461: LabelDecl:
3463:    {
3463:       Node decl
3463:       [
3463:          | pIdent :
3465:          | pIntLit :
                  % Replace token with identifier "_label_<intlit>"
3467:             oChangeIntLitToLabelIdent
3468:       ]
3476:       decl = @newIdent( nLabel, LAST_ID )
            % TO DO: ensure not already declared in this scope.
            %        Or maybe that can be part of oScopeDeclare.
3489:       Label label = oLabelNew
3494:       oNodeSetLabel( decl, qValue, label )
3506:       oScopeDeclare( decl )
3512:       [
3512:          | ',' :
3514:          | * :
3519:             >
3521:       ]
3521:    }
3523:    ';'
3526:    ;
3526: include 'pascal_constexpr.ssl'
      %
      % Pascal Compiler
      %
      
      % --------------------------- Const Expressions --------------------------
      
      
      % Constant expressions are evaluated at compile time.
      % They are limited to constant literals, declared constants (not including TypedConstants!)
      % and a small selection of built-in functions. 
      %
      % The value of a constant expression is left on the Value Stack.
      % The type is left on the Type Stack.
      
3526: ConstExpr:
3528:    @ConstBoolExpr
3530:    {[
3530:       | '=' :
3532:          @ConstBoolTerm
3534:          @ConstMatchTypes
3536:          oTypeSPop  oTypeSPush( BooleanType )
3543:          oValueEqual
3544:       | '<>' :
3546:          @ConstBoolExpr
3548:          @ConstMatchTypes
3550:          oTypeSPop  oTypeSPush( BooleanType )
3557:          oValueNotEqual
3558:       | '<' :
3560:          @ConstBoolExpr
3562:          @ConstMatchTypes
3564:          oTypeSPop  oTypeSPush( BooleanType )
3571:          oValueLess
3572:       | '>' :
3574:          @ConstBoolExpr
3576:          @ConstMatchTypes
3578:          oTypeSPop  oTypeSPush( BooleanType )
3585:          oValueGreater
3586:       | '<=' :
3588:          @ConstBoolExpr
3590:          @ConstMatchTypes
3592:          oTypeSPop  oTypeSPush( BooleanType )
3599:          oValueLessEqual
3600:       | '>=' :
3602:          @ConstBoolExpr
3604:          @ConstMatchTypes
3606:          oTypeSPop  oTypeSPush( BooleanType )
3613:          oValueGreaterEqual
3614:       | * :  >
3631:    ]};
      
      
3634: ConstBoolExpr:
3636:    @ConstBoolTerm
3638:    {[
3638:       | pOr :
3640:          @ConstRequireBool
3642:          @ConstBoolTerm
3644:          @ConstRequireBoolPop
3646:          oValueOr
3647:       | * :  >
3654:    ]};
      
      
3657: ConstBoolTerm:
3659:    @ConstBoolFactor
3661:    {[
3661:       | pAnd :
3663:          @ConstRequireBool
3665:          @ConstBoolFactor
3667:          @ConstRequireBoolPop
3669:          oValueAnd
3670:       | * :  >
3677:    ]};
      
      
3680: ConstBoolFactor:
3682:    [
3682:       | pNot :
3684:          @ConstBoolFactor
3686:          @ConstRequireBool
3688:          oValueNot
3689:       | * :
3694:          @ConstArithExpr
3696:    ];
      
      
3697: ConstArithExpr:
3699:    @ConstTerm
3701:    {[
3701:       | '+' :
3703:          @ConstTerm
3705:          @ConstMatchTypes
3707:          oValueAdd
3708:       | '-' :
3710:          @ConstTerm
3712:          @ConstMatchTypes
3714:          oValueSub
3715:       | * :  >
3724:    ]};
      
      
3727: ConstTerm:
3729:    @ConstFactor
3731:    {[
3731:       | pTimes :
3733:          @ConstFactor
3735:          @ConstMatchTypes
3737:          oValueMult
3738:       | pDivide :
3740:          @ConstFactor
3742:          @ConstMatchTypes
3744:          oValueDiv
3745:       | * :  >
3754:    ]};
      
      
3757: ConstFactor:
3759:    [
3759:       | pPlus :
3761:          @ConstPrimary
3763:       | pMinus :
3765:          @ConstPrimary
3767:          oValueNegate
3768:       | * :
3775:          @ConstPrimary
3777:    ];
      
      
3778: ConstPrimary:
3780:    [
3780:       | pIntLit :
3782:          oValuePush( TOKEN_VALUE )
3787:          oTypeSPush( IntegerType )
3793:       | pCharLit :
3795:          oValuePush( TOKEN_VALUE )
3800:          oTypeSPush( CharType )
3806:       | pStrLit :
3808:          oValuePushString( CURRENT_STRLIT )
3813:          oTypeSPush( StrLitType )
3819:       | '(' :
3821:          @ConstExpr
3823:          ')'
3825:       | pIdent :
3827:          Node decl = oScopeFindRequire
3832:          @ResolveUnitRef( decl )
3839:          [ oNodeType( decl )
3846:             | nBuiltInFunc :
3847:                @ConstBuiltInFunc( decl )
3854:             | nConst :
3856:                oValuePush( oNodeGetInt( decl, qValue ) )
3869:                oTypeSPush( oNodeGet( decl, qType ) )
3882:             | nEnumValue :
3884:                oValuePush( oNodeGetInt( decl, qValue ) )
3897:                oTypeSPush( oNodeGet( decl, qType ) )
3910:             | * :
3919:                #eNotConst
3921:                oValuePush( 0 )
3927:                oTypeSPush( IntegerType )
3933:          ]
3933:       | '@' :
3935:          #eNotImplemented
3937:          oValuePush( 0 )
3943:          oTypeSPush( UniversalPointerType )
3949:       | * :
3964:          #eNotConst
3966:          oValuePush( 0 )
3972:          oTypeSPush( IntegerType )
3978:    ];
      
      
3979: ConstBuiltInFunc( Node decl ):
3981:    #eNotImplemented
3984:    ;
      
      
3984: ConstRequireBoolPop:
3986:    [ oTypeSNodeType
3988:       | nBooleanType :
3989:       | * :          #eNotBoolean
3996:    ]
3996:    oTypeSPop;
      
      
3998: ConstRequireBool:
4000:    [ oTypeSNodeType
4002:       | nBooleanType :
4003:       | * :          #eNotBoolean
4010:    ];
      
      
      % Require that the top two types on the type stack are matching (ignoring subranges).
      % Pop one of them, leaving only one.
      % The types refer to constant values on the Value Stack,
      % so any implicit conversion would occur there, not in code.
      %
      % Some implicit conversion is allowed for either of the types.
      % See also ConstCoerceType where only the top type may change.
      %
4011: ConstMatchTypes:
4013:    node_type nt = oTypeSNodeType
4018:    oTypeSPop
4019:    [ equal_node_type( nt, oTypeSNodeType )
4028:       | false :
               % Some implicit conversion is allowed even here
4029:          [ oTypeSNodeType
4031:             | nPointerType :
4032:                [ nt
4035:                   | nUniversalPointerType :  >>
4037:                   | * :
4042:                ]
4042:             | nUniversalPointerType :
4044:                [ nt
4047:                   | nPointerType :  >>
4049:                   | * :
4054:                ]
4054:             | nStrLitType :
4056:                [ nt
4059:                   | nCharType :
4060:                      oValueCharToString
4061:                      >>
4062:                   | * :
4067:                ]
4067:             | nCharType :
4069:                [ nt
4072:                   | nStrLitType :
4073:                      oValueSwap
4074:                      oValueCharToString
4075:                      oValueSwap
4076:                      oTypeSPop
4077:                      oTypeSPush( StrLitType )
4083:                      >>
4084:                   | * :
4089:                ]
4089:             | * :
4100:          ]
4100:          #eTypeMismatch
4102:       | * :
4107:    ];
      
      
      % Given two constant values on the value stack, and two types on the type stack.
      % Perform any necessary implicit conversions so the second value is the type of the
      % value under it.  Pop the top type, leaving only the desired type.
      %
4108: ConstCoerceType:
4110:    node_type nt = oTypeSNodeType
4115:    oTypeSPop
4116:    [ equal_node_type( nt, oTypeSNodeType )
4125:       | false :
               % Some implicit conversion is allowed even here
4126:          [ oTypeSNodeType
4128:             | nPointerType :
4129:                [ nt
4132:                   | nUniversalPointerType :  >>
4134:                   | * :
4139:                ]
4139:             | nUniversalPointerType :
4141:                [ nt
4144:                   | nPointerType :  >>
4146:                   | * :
4151:                ]
4151:             | nStrLitType :
4153:                [ nt
4156:                   | nCharType :
4157:                      oValueCharToString
4158:                      >>
4159:                   | * :
4164:                ]
4164:             | * :
4173:          ]
4173:          #eTypeMismatch
4175:       | * :
4180:    ];
      
4181: include 'pascal_expr.ssl'
      %
      % Pascal Compiler
      %
      
      
      % ------------------------------ Expressions -----------------------------
      
      
      % There are two wrappers leading into expression parsing:
      %   Expr()
      %   BooleanExprControlFlow( out Label falseLabel )
      %
      % Expr always produces a value on the runtime expr stack,
      % and pushes its type on the type stack.
      %
      % BooleanExprControlFlow always generates control-flow code.
      % It does not push a value on the runtime expr stack.
      % It does not push a type on the type stack.
      % The control flow code ends up at Here if the expr is true,
      % and jumps to falseLabel if the expr is false.
      % This rule allocates falseLabel, and passes it back.
      % The caller will need to define its location.
      %
      % The internal methods of expr parsing may produce a mix of
      % values and control flow, depending on the operators seen.
      % We don't always do one or the other, hoping to be efficient for
      % cases like   "func_call( bool_var1, bool_var2 )"
      % as well as  "if bool_expr1 or bool_expr2 then ...".
      % If a subexpression rule produces control flow, it will allocate a
      % falseLabel and pass it back up.  And it will push the
      % result type as BooleanFlowType, to distinguish from BooleanType
      % which corresponds with a boolean value on the expr stack.
      % 
      % Note that my expression parsing is broken into more levels than
      % grammars describe for Pascal precedence levels.  This follows my
      % original parser implementation.  I think my rationale was that
      % operators from the levels that I split up couldn't have been
      % mixed anyway, since they require different data types
      % (e.g. boolean vs int/real).  And splitting them up simplified
      % my code.  But, I should revisit this.
      %
      
      
      % Public entry point:
      %
      % Parse an expression, leaving a value on the runtime expr stack
      % and its type on the type stack.
      %
      % This rule does not export control flow (though it may generate
      % control flow internally for subexpressions).
      %
4181: Expr:
4183:    Label falseLabel = labelNull
      
4189:    @ExprAllowFlow( falseLabel )
4196:    @FlowToVal( falseLabel );
      
      
      % Public entry point:
      %
      % Parse a Boolean expression, producing control flow code rather than a value.
      % Does not leave a value on the runtime expr stack.
      % Does not leave a type on the type stack.
      %
      % If the expression is true, the code will fall through to the end (Here).
      % If the expression is false, the code will jump to the given falseLabel,
      % which this rule will allocate but not define the location for.
      % The caller must do so.
      %
4204: BooleanExprControlFlow( out Label falseLabel ):
4206:    @ExprAllowFlow( falseLabel )
4213:    [ oTypeSNodeType
4215:       | nBooleanFlowType :
4216:       | nBooleanType :
               % convert value to control flow
4218:          falseLabel = oLabelNew
4223:          .tJumpFalse  oEmitLabel( falseLabel )
4231:       | * :
4238:          #eNotBoolean
4240:    ]
4240:    oTypeSPop;
      
      
      % If the current expr result is control flow, convert it to a value.
      % falseLabel is the label that had been used by the control flow.
      % On return it will be set to labelNull.
      %
4242: FlowToVal( inout Label falseLabel ):
4244:    [ oTypeSNodeType
4246:       | nBooleanFlowType :
4247:          Label doneLabel = oLabelNew
4252:          .tPushConstI  oEmitInt( 1 )
4260:          .tJump  oEmitLabel( doneLabel )
4268:          .tLabel  oEmitLabel( falseLabel )
4276:          .tPushConstI  oEmitInt( 0 )
4284:          .tLabel  oEmitLabel( doneLabel )
4292:          oTypeSPop
4293:          oTypeSPush( BooleanType )
4299:          falseLabel = labelNull
4305:       | * :
4310:    ];
      
      
      % If the current expr result is boolean value, convert it to control flow.
      % falseLabel will be allocated by this rule and passed back.
      % The caller must define its location.
      %
4311: ValToFlow( out Label falseLabel ):
4313:    [ oTypeSNodeType
4315:       | nBooleanType :
4316:          falseLabel = oLabelNew
4321:          .tJumpFalse  oEmitLabel( falseLabel )
4329:          oTypeSPop
4330:          oTypeSPush( BooleanFlowType )
4336:       | * :
4341:    ];
      
      
      % Parse an expression.  It may produce a value on the expr stack,
      % or control flow, depending on what's seen in the expression.
      % Leaves the expression type on the type stack.
      %
      % If the expression produces control flow, the expression type will be
      % nBooleanFlowType.  In this case, a true value falls through to Here,
      % and a false value jumps to falseLabel.  This rule will allocate falseLabel
      % and return it, but will not define its location; the caller must do so.
      %
      % If the expression produces a value, the value will be left on the
      % expression stack, and the type will be some type other than nBooleanFlowType.
      % In this case, falseLabel is ignored.
      %
4342: ExprAllowFlow( out Label falseLabel ):
4344:    @BoolExprAllowFlow( falseLabel )
4351:    {[
4351:       | '=' :
4353:          @FlowToVal( falseLabel )
4360:          @PromoteToIntOptional
4362:          @BoolExprAllowFlow( falseLabel )
4369:          @FlowToVal( falseLabel )
4376:          @PromoteToIntOptional
4378:          @MatchTypes
4380:          [ oTypeSNodeType
4382:             | nBooleanType, nCharType :     .tEqualB
4385:             | nIntegerType, nEnumType :     .tEqualI
4389:             | nPointerType, nUniversalPointerType :    .tEqualP
4393:             | nShortStringType, nStrLitType :
4395:                @ShortStringCmp  .tPushConstI  oEmitInt( 0 )  .tEqualI
4407:             | * :                           #eNotAllowed
4428:          ]
4428:          oTypeSPop
4429:          oTypeSPush( BooleanType )
      
4435:       | '<>' :
4437:          @FlowToVal( falseLabel )
4444:          @PromoteToIntOptional
4446:          @BoolExprAllowFlow( falseLabel )
4453:          @FlowToVal( falseLabel )
4460:          @PromoteToIntOptional
4462:          @MatchTypes
4464:          [ oTypeSNodeType
4466:             | nBooleanType, nCharType :     .tNotEqualB
4469:             | nIntegerType, nEnumType :     .tNotEqualI
4473:             | nPointerType, nUniversalPointerType :    .tNotEqualP
4477:             | nShortStringType, nStrLitType :
4479:                @ShortStringCmp  .tPushConstI  oEmitInt( 0 )  .tNotEqualI
4491:             | * :                           #eNotAllowed
4512:          ]
4512:          oTypeSPop
4513:          oTypeSPush( BooleanType )
      
4519:       | '<' :
4521:          @FlowToVal( falseLabel )
4528:          @PromoteToIntOptional
4530:          @BoolExprAllowFlow( falseLabel )
4537:          @FlowToVal( falseLabel )
4544:          @PromoteToIntOptional
4546:          @MatchTypes
4548:          [ oTypeSNodeType
4550:             | nBooleanType, nCharType :     .tLessB
4553:             | nIntegerType, nEnumType :     .tLessI
4557:             | nPointerType, nUniversalPointerType :   .tLessP
4561:             | nShortStringType, nStrLitType :
4563:                @ShortStringCmp  .tPushConstI  oEmitInt( 0 )  .tLessI
4575:             | * :                           #eNotAllowed
4596:          ]
4596:          oTypeSPop
4597:          oTypeSPush( BooleanType )
      
4603:       | '>' :
4605:          @FlowToVal( falseLabel )
4612:          @PromoteToIntOptional
4614:          @BoolExprAllowFlow( falseLabel )
4621:          @FlowToVal( falseLabel )
4628:          @PromoteToIntOptional
4630:          @MatchTypes
4632:          [ oTypeSNodeType
4634:             | nBooleanType, nCharType :     .tGreaterB
4637:             | nIntegerType, nEnumType :     .tGreaterI
4641:             | nPointerType, nUniversalPointerType :   .tGreaterP
4645:             | nShortStringType, nStrLitType :
4647:                @ShortStringCmp  .tPushConstI  oEmitInt( 0 )  .tGreaterI
4659:             | * :                           #eNotAllowed
4680:          ]
4680:          oTypeSPop
4681:          oTypeSPush( BooleanType )
      
4687:       | '<=' :
4689:          @FlowToVal( falseLabel )
4696:          @PromoteToIntOptional
4698:          @BoolExprAllowFlow( falseLabel )
4705:          @FlowToVal( falseLabel )
4712:          @PromoteToIntOptional
4714:          @MatchTypes
4716:          [ oTypeSNodeType
4718:             | nBooleanType, nCharType :     .tLessEqualB
4721:             | nIntegerType, nEnumType :     .tLessEqualI
4725:             | nPointerType, nUniversalPointerType :   .tLessEqualP
4729:             | nShortStringType, nStrLitType :
4731:                @ShortStringCmp  .tPushConstI  oEmitInt( 0 )  .tLessEqualI
4743:             | * :                           #eNotAllowed
4764:          ]
4764:          oTypeSPop
4765:          oTypeSPush( BooleanType )
      
4771:       | '>=' :
4773:          @FlowToVal( falseLabel )
4780:          @PromoteToIntOptional
4782:          @BoolExprAllowFlow( falseLabel )
4789:          @FlowToVal( falseLabel )
4796:          @PromoteToIntOptional
4798:          @MatchTypes
4800:          [ oTypeSNodeType
4802:             | nBooleanType, nCharType :     .tGreaterEqualB
4805:             | nIntegerType, nEnumType :     .tGreaterEqualI
4809:             | nPointerType, nUniversalPointerType :   .tGreaterEqualP
4813:             | nShortStringType, nStrLitType :
4815:                @ShortStringCmp  .tPushConstI  oEmitInt( 0 )  .tGreaterEqualI
4827:             | * :                           #eNotAllowed
4848:          ]
4848:          oTypeSPop
4849:          oTypeSPush( BooleanType )
      
4855:       | * :
4870:          >
4872:    ]};
      
      
4875: BoolExprAllowFlow( out Label falseLabel ):
4877:    Label trueLabel = labelNull
      
4883:    @BoolTermAllowFlow( falseLabel )
4890:    {[
4890:       | pOr :
4892:          [ oTypeSNodeType
4894:             | nBooleanFlowType :
                     % We are true here. Jump ahead to done
4895:                [ equal_label( trueLabel, labelNull )
4905:                   | true :  trueLabel = oLabelNew
4911:                   | * :
4916:                ]
4916:                .tJump  oEmitLabel( trueLabel )
4924:             | nBooleanType :
4926:                @ValToFlow( falseLabel )
                     % We are true here. Jump ahead to done
4933:                [ equal_label( trueLabel, labelNull )
4943:                   | true :  trueLabel = oLabelNew
4949:                   | * :
4954:                ]
4954:                .tJump  oEmitLabel( trueLabel )
4962:             | * : #eNotBoolean
4971:          ]
4971:          oTypeSPop
      
               % false in previous term will jump here, to try this alternative term
4972:          .tLabel  oEmitLabel( falseLabel )
      
               % we'll get a new falseLabel for this term
4980:          falseLabel = labelNull
4986:          @BoolTermAllowFlow( falseLabel )
      
4993:          [ oTypeSNodeType
4995:             | nBooleanFlowType :
4996:             | nBooleanType :
4998:                @ValToFlow( falseLabel )
5005:             | * : #eNotBoolean
5014:          ]
      
5014:          oTypeSPop
5015:          oTypeSPush( BooleanFlowType )
      
5021:       | * :
5026:          >
5028:    ]}
      
         % any short-circuit trues jump here to the end
5030:    [ equal_label( trueLabel, labelNull )
5040:       | false :
5041:          .tLabel  oEmitLabel( trueLabel )
5049:       | * :
5054:    ]
5055:    ;
      
      
5055: BoolTermAllowFlow( out Label falseLabel ):
5057:    Label overallFalseLabel = labelNull
      
5063:    @BoolFactorAllowFlow( falseLabel )
5070:    {[
5070:       | pAnd :
5072:          [ oTypeSNodeType
5074:             | nBooleanFlowType :
5075:             | nBooleanType :
5077:                @ValToFlow( falseLabel )
5084:             | * :
5091:                #eNotBoolean
5093:          ]
5093:          oTypeSPop
      
               % We're going to have a different falseLabel for each term,
               % because we let each rule allocate its own (rather than accepting labels passed in).
               % And in this case we want them all to go to the same place,
               % to be determined by the caller.
               %
               % I'll allow for label aliases.  This will be more optimal than generating
               % multiple private false-handling code segments, that the true path would have to
               % jump around.  That would be hard to eliminate afterwards.
      
5094:          [ equal_label( overallFalseLabel, labelNull )
5104:             | true :
5105:                overallFalseLabel = oLabelNew
5110:                .tLabelAlias  oEmitLabel( falseLabel )  oEmitLabel( overallFalseLabel )
5124:                falseLabel = overallFalseLabel
5130:             | * :
5135:          ]
      
5135:          Label factorFalseLabel = labelNull
5141:          @BoolFactorAllowFlow( factorFalseLabel )
      
5148:          [ oTypeSNodeType
5150:             | nBooleanFlowType :
5151:             | nBooleanType :
5153:                @ValToFlow( factorFalseLabel )
5160:             | * : #eNotBoolean
5169:          ]
5169:         .tLabelAlias  oEmitLabel( factorFalseLabel )  oEmitLabel( overallFalseLabel )
      
5183:       | * :
5188:          >
5190:    ]};
      
      
5193: BoolFactorAllowFlow( out Label falseLabel ):
5195:    [
5195:       | pNot :
5197:          Label factorFalseLabel = labelNull
      
5203:          @BoolFactorAllowFlow( factorFalseLabel )
5210:          [ oTypeSNodeType
5212:             | nBooleanFlowType :
                     % We have control flow, and are sitting at the point that has value false.
5213:                falseLabel = oLabelNew
5218:                .tJump  oEmitLabel( falseLabel )
                     % The true path jumps here
5226:                .tLabel  oEmitLabel( factorFalseLabel )
      
5234:             | nBooleanType :
                     % I have a value.  I'll leave it as a value, rather than create control flow.
                     % See how this goes.
5236:                .tNot
      
5238:             | * : #eNotBoolean
5247:          ]
      
5247:       | * :
5252:          @ArithExprAllowFlow( falseLabel )
5259:    ];
      
      
5260: ArithExprAllowFlow( out Label falseLabel ):
5262:    boolean first = true
5268:    int tempStrOffset
      
5268:    @TermAllowFlow( falseLabel )
5275:    {[
5275:       | '+' :
5277:          [ oTypeSNodeType
5279:             | nIntegerType, nByteType :
5280:                @PromoteToIntPop
5282:                @TermAllowFlow( falseLabel )  % actually not allowing CF, will be caught by type check
      
5289:                [ oTypeSNodeType
5291:                   | nPointerType, nUniversalPointerType :
                           % int + ptr
5292:                      .tSwap
                           % leave only the ptr type on the type stack (int was already popped above)
5294:                      @PointerAddition
5296:                   | * :
5303:                      @PromoteToInt
5305:                      .tAddI
5307:                ]
      
5307:             | nShortStringType, nStrLitType, nCharType :
                     % String concatenation
5309:                [ first
5312:                   | true :  % move into a temp string, so subsequent term(s) can further modify it.
5313:                             tempStrOffset = @MoveIntoTempShortString
5319:                             first = false
5325:                   | * :
5330:                ]
5330:                @TermAllowFlow( falseLabel )  % actually not allowing CF, will be caught by type check
5337:                [ oTypeSNodeType
5339:                   | nShortStringType, nStrLitType :
5340:                      @ShortStringAppendShortString
                           % Have to re-push the temp string.
                           % If we ever have .tDup then the append method could do it and we wouldn't need this
5342:                      .tPushAddrLocal  oEmitInt( tempStrOffset )
5350:                      oTypeSPush( ShortStringType )
5356:                   | nCharType :
5358:                      @ShortStringAppendChar
                           % Have to re-push the temp string.
                           % If we ever have .tDup then the append method could do it and we wouldn't need this
5360:                      .tPushAddrLocal  oEmitInt( tempStrOffset )
5368:                      oTypeSPush( ShortStringType )
5374:                   | * :
5383:                      #eTypeMismatch
5385:                      oTypeSPop
5386:                ]
      
5386:             | nPointerType, nUniversalPointerType :
5388:                @TermAllowFlow( falseLabel )   % actually not allowing CF
5395:                @PromoteToIntPop
5397:                @PointerAddition
      
5399:             | * :
5416:                #eNotAllowed
5418:          ]
      
5418:       | '-' :
5420:          [ oTypeSNodeType
5422:             | nIntegerType, nByteType :
5423:                @PromoteToIntPop
5425:                @TermAllowFlow( falseLabel )
5432:                @PromoteToInt
5434:                .tSubI
      
5436:             | nPointerType, nUniversalPointerType :
5438:                @TermAllowFlow( falseLabel )
5445:                [ oTypeSNodeType
5447:                   | nIntegerType, nByteType :
5448:                      @PromoteToIntPop
5450:                      @PointerSubInt
5452:                   | nPointerType, nUniversalPointerType :
5454:                      @MatchTypes
5456:                      @PointerSubPointer
5458:                   | * :
5469:                      #eNotAllowed
5471:                ]
      
5471:             | * :  #eNotAllowed
      
5484:          ]
5484:       | * :
5491:          >
5493:    ]};
      
      
5496: TermAllowFlow( out Label falseLabel ):
5498:    @FactorAllowFlow( falseLabel )
5505:    {[
5505:       | pTimes :
5507:          @PromoteToIntPop
5509:          @FactorAllowFlow( falseLabel )  % actually not allowing CF, will be caught by type check
5516:          @PromoteToInt
5518:          .tMultI
5520:       | pDivide :
5522:          @PromoteToIntPop
5524:          @FactorAllowFlow( falseLabel )
5531:          @PromoteToInt
5533:          .tDivI
5535:       | * :
5542:          >
5544:    ]};
      
      
5547: FactorAllowFlow( out Label falseLabel ):
5549:    [
5549:       | pPlus :
5551:          @PrimaryAllowFlow( falseLabel )  % actually not allowing CF, will be caught by type check
               % TO DO: unary +/- is supposed to leave expression type as-is.
5558:          @PromoteToInt
5560:       | pMinus :
5562:          @PrimaryAllowFlow( falseLabel )
               % TO DO: unary +/- is supposed to leave expression type as-is.
5569:          @PromoteToInt
5571:          .tNegI
5573:       | * :
5580:          @PrimaryAllowFlow( falseLabel )
5587:    ];
      
      
5588: PrimaryAllowFlow( out Label falseLabel ):
5590:    [
5590:       | pIntLit :
5592:          .tPushConstI  oEmitInt( TOKEN_VALUE )
5599:          oTypeSPush( IntegerType )
      
5605:       | pCharLit :
5607:          .tPushConstI  oEmitInt( TOKEN_VALUE )
5614:          oTypeSPush( CharType )
      
5620:       | '(' :
5622:          @ExprAllowFlow( falseLabel )
5629:          ')'
      
5631:       | pStrLit :
5633:          int addr = oStringAllocShortStringLit( CURRENT_STRLIT )     % store in global data
5642:          .tPushAddrGlobal oEmitInt( addr )
               % TO DO: consider defining a ShortString type with the exact capacity used.
               % But, I don't think it should matter here, since nobody should be assigning to this string.
5650:          oTypeSPush( StrLitType )
               % This seems unlikely, but the strlit may be followed by
               % array indexing.  Handle this the same way we would with a variable expression (see VarExpr)
               % First, advance the pointer by index if any
5656:          @LValueIndexes
               % get final value of dereferencing, if any
5658:          @FetchVar
      
5660:       | pIdent :
5662:          Node decl = oScopeFindRequire
5667:          @ResolveUnitRef( decl )
5674:          Node theType
      
5674:          [ oNodeType( decl )
5681:             | nFunc :
5682:                @Call( decl )
      
5689:             | nBuiltInFunc :
5691:                @CallBuiltInFunc( decl )
      
5698:             | nConst, nEnumValue :
5700:                theType = oNodeGet( decl, qType )
5713:                oTypeSPush( theType )
5719:                [ oTypeSNodeType
5721:                   | nIntegerType, nEnumType, nBooleanType :
5722:                      .tPushConstI @EmitValue( decl )
5731:                   | nPointerType, nUniversalPointerType :
                           % We have one pointer const, Nil.  It's pushed as I.
                           % Sign-extending I to P won't hurt since it's 0.
5733:                      .tPushConstI @EmitValue( decl )
5742:                   | * :
5755:                      #eNotImplemented
5757:                ]
      
5757:             | nGlobalVar, nLocalVar, nParam, nTypedConst :
5759:                @VarExpr( decl )
      
5766:             | * :
5785:                #eNotValue
5787:                oTypeSPush( IntegerType )
5793:          ]
      
5793:       | '@' :        % @var -- pointer to var
5795:          pIdent
      
5797:          Node decl = oScopeFindRequire
5802:          @ResolveUnitRef( decl )
5809:          Node theType
      
               % writeable is false because we're not on the left hand side of an assignment,
               % or passign into a var parameter.  So it's ok to take the address of a typed const.
5809:          @LValueVar( decl, false )
      
               % The above leaves the pointed-to type on type stack.
               % Replace with ptr-to-<type>.
5819:          theType = oTypeSTop
5824:          oTypeSPop
5825:          Node ptrType = @PointerTypeTo( theType )
5836:          oTypeSPush( ptrType )
      
5842:       | * :
5857:          #eNotValue
5859:          oTypeSPush( IntegerType )
5865:    ];
      
      
      % Parse a variable expression, given the declaration of the
      % just-accepted identifier.
      % Leaves the value on the expression stack, and type on the type stack.
      %
5866: VarExpr( Node decl ):
5868:    Node theType = oNodeGet( decl, qType )
         % how many levels up the static scope? Will ignore for globals.
5881:    int uplevels = @DeclUpLevels( decl )
      
5892:    oTypeSPush( theType )
5898:    [ oTypeSNodeType
5900:       | nIntegerType, nEnumType :
5901:          [ oNodeType( decl )
5908:             | nGlobalVar, nTypedConst :   .tPushGlobalI  @EmitValue( decl )
5918:             | nLocalVar :
5920:                [ equal_zero( uplevels )
5927:                   | true :  .tPushLocalI  @EmitValue( decl )
5937:                   | * :     .tPushUpLocalI  oEmitInt( uplevels )  @EmitValue( decl )
5957:                ]
5957:             | nParam :
5959:                [ oNodeGetBoolean( decl, qInOut )
5969:                   | true :    % VAR param points to the var.  Auto dereference.
5970:                      [ equal_zero( uplevels )
5977:                         | true :  .tPushParamP  @EmitValue( decl )
5987:                         | * :     .tPushUpParamP  oEmitInt( uplevels )  @EmitValue( decl )
6007:                      ]
6007:                      .tFetchI
6009:                   | * :
6014:                      [ equal_zero( uplevels )
6021:                         | true :  .tPushParamI  @EmitValue( decl )
6031:                         | * :     .tPushUpParamI  oEmitInt( uplevels )  @EmitValue( decl )
6051:                      ]
6051:                ]
6051:          ]
      
6063:       | nBooleanType, nByteType, nCharType :
6065:          [ oNodeType( decl )
6072:             | nGlobalVar, nTypedConst :   .tPushGlobalB  @EmitValue( decl )
6082:             | nLocalVar :
6084:                [ equal_zero( uplevels )
6091:                   | true :  .tPushLocalB  @EmitValue( decl )
6101:                   | * :     .tPushUpLocalB  oEmitInt( uplevels )  @EmitValue( decl )
6121:                ]
6121:             | nParam :
6123:                [ oNodeGetBoolean( decl, qInOut )
6133:                   | true :    % VAR param points to the var.  Auto dereference.
6134:                      [ equal_zero( uplevels )
6141:                         | true :  .tPushParamP  @EmitValue( decl )
6151:                         | * :     .tPushUpParamP  oEmitInt( uplevels )  @EmitValue( decl )
6171:                      ]
6171:                      .tFetchB
6173:                   | * :
6178:                      [ equal_zero( uplevels )
6185:                         | true :  .tPushParamB  @EmitValue( decl )
6195:                         | * :     .tPushUpParamB  oEmitInt( uplevels )  @EmitValue( decl )
6215:                      ]
6215:                ]
6215:          ]
      
6227:       | nFileType :
6229:          #eNotImplemented
      
6231:       | nPointerType, nUniversalPointerType :
6233:          [ oNodeType( decl )
6240:             | nGlobalVar, nTypedConst :   .tPushGlobalP @EmitValue( decl )
6250:             | nLocalVar :
6252:                [ equal_zero( uplevels )
6259:                   | true :  .tPushLocalP  @EmitValue( decl )
6269:                   | * :     .tPushUpLocalP  oEmitInt( uplevels )  @EmitValue( decl )
6289:                ]
6289:             | nParam :
6291:                [ oNodeGetBoolean( decl, qInOut )
6301:                   | true :    % VAR param points to the var.  Auto dereference.
6302:                      [ equal_zero( uplevels )
6309:                         | true :  .tPushParamP  @EmitValue( decl )
6319:                         | * :     .tPushUpParamP  oEmitInt( uplevels )  @EmitValue( decl )
6339:                      ]
6339:                      .tFetchP
6341:                   | * :
6346:                      [ equal_zero( uplevels )
6353:                         | true :  .tPushParamP  @EmitValue( decl )
6363:                         | * :     .tPushUpParamP  oEmitInt( uplevels )  @EmitValue( decl )
6383:                      ]
6383:                ]               
6383:          ]
6395:          [
6395:             | '^' :             % dereferenced
6397:                oTypeSPop
6398:                oTypeSPush( oNodeGet( theType, qBaseType ) )
6411:                @LValueIndexes
6413:                @FetchVar
6415:             | '[' :             % dereferencing pointer like an array [0..] of baseType
6417:                @PointerArraySubscript
                     % modify addr for any subsequent subscripts, field references, etc
6419:                @LValueIndexes
6421:                @FetchVar
6423:             | * :               % just ptr value alone
6430:          ]
      
6430:       | nArrayType, nRecordType, nShortStringType :
               % compound type
               % first, push addr of start of var
6432:          [ oNodeType( decl )
6439:             | nGlobalVar, nTypedConst :   .tPushAddrGlobal @EmitValue( decl )
6449:             | nLocalVar :
6451:                [ equal_zero( uplevels )
6458:                   | true :  .tPushAddrLocal  @EmitValue( decl )
6468:                   | * :     .tPushAddrUpLocal  oEmitInt( uplevels )  @EmitValue( decl )
6488:                ]
6488:             | nParam :
6490:                [ oNodeGetBoolean( decl, qInOut )
6500:                   | true :    % VAR param points to the var.  Auto dereference.
6501:                      [ equal_zero( uplevels )
6508:                         | true :  .tPushParamP  @EmitValue( decl )
6518:                         | * :     .tPushUpParamP  oEmitInt( uplevels )  @EmitValue( decl )
6538:                      ]
6538:                   | * :
6543:                      [ equal_zero( uplevels )
6550:                         | true :  .tPushAddrParam  @EmitValue( decl )
6560:                         | * :     .tPushAddrUpParam  oEmitInt( uplevels )  @EmitValue( decl )
6580:                      ]
6580:                ]
6580:          ]
               % modify addr for subscripts, field references, etc
6592:          @LValueIndexes
               % get final value
6594:          @FetchVar
6596:    ];
      
      
      % Addr of start of var is on expr stack; type is on type stack.
      % Replace expr stack with value of var.
      % (In the case of compound vars, this remains as the addr of the var).
      
6623: FetchVar:
6625:    [ oTypeSNodeType
6627:       | nIntegerType, nEnumType :  .tFetchI
6630:       | nBooleanType, nByteType, nCharType :  .tFetchB
6634:       | nFileType :   #eNotImplemented
6638:       | nPointerType :             .tFetchP
6642:       | nUniversalPointerType :    #eCantDereference
6646:       | nArrayType, nRecordType, nStrLitType, nShortStringType :  % compound type; leave as addr
6648:    ];
      
      
      % Addr of start of var is already on run stack, and type is on type stack.
      % Read subscripts, record fields, etc, to get final addr on run stack, and final type
      % on type stack.
      
6677: LValueIndexes:
6679:    {[
6679:       | '[' :
6681:          [ oTypeSNodeType
6683:             | nArrayType :    @ArraySubscripts
6686:             | nPointerType :  @PointerArraySubscript
6690:             | nStrLitType, nShortStringType :  @ShortStringArraySubscript
6694:             | * :             #eNotArray
6707:          ]
6707:       | '.' :       @RecordFieldRef
6711:       | '^' :       @PointerDeref   % TO DO: I suspect I don't have logic right here
                                          % about precondition and using .tFetchP
                                          % Ideally this should take over for the ^ in VarExpr too.
6715:       | * :         >
6726:    ]};
      
      
6729: ArraySubscripts:
6731:    [ oTypeSNodeType
6733:       | nArrayType :
6734:       | * :       #eNotArray
6741:    ]
6741:    {
6741:       [ oTypeSNodeType
6743:          | nArrayType :
6744:          | * :    #eTooManySubscripts
6751:       ]
      
            % low subscript of this dimension
6751:       int low = @OrdinalLow( oNodeGet( oTypeSTop, qIndexType ) )
      
            % replace type stack with next dimension, or OF type
6768:       Node baseType
6768:       baseType = oNodeGet( oTypeSTop, qBaseType )
6780:       oTypeSPop
6781:       oTypeSPush( baseType )
      
6787:       @Expr
6789:       @RequireIntPop
            % adjust for low subscript
6791:       [ equal_zero( low )
6798:          | false :
6799:             .tPushConstI oEmitInt( low ) .tSubI
6809:          | * :
6814:       ]
      
            % multiply by element size
6814:       int size = oNodeGetInt( baseType, qSize )
6827:       [ equal( size, 1 )
6837:          | false :
6838:             .tPushConstI oEmitInt( size ) .tMultI
6848:          | * :
6853:       ]
      
            % update start address
6853:       .tAddPI
6855:       [
6855:          | ']' :  >
6859:          | ',' :
6861:       ]
6869:    };
      
      
      % pointer[index] - similar to array[index] where index counts from 0.
      % On entry, the pointer value is on the stack, and pointer type is on the type stack.
      % We've already accepted the '['.
      % On exit, the address of the pointed-to element is on the stack,
      % and the element type is on the type stack.
      %
6872: PointerArraySubscript:
6874:    [ oTypeSNodeType
6876:       | nPointerType :
6877:       | * :    #eCantDereference
6884:    ]
         % replace type stack with base type
6884:    Node baseType = oNodeGet( oTypeSTop, qBaseType )
6896:    oTypeSPop
6897:    oTypeSPush( baseType )
         
6903:    @Expr
6905:    @RequireIntPop
         % multiply by element size
6907:    int size = oNodeGetInt( baseType, qSize )
6920:    [ equal( size, 1 )
6930:       | false :
6931:          .tPushConstI  oEmitInt( size )  .tMultI
6941:       | * :
6946:    ]
         % update start address
6946:    .tAddPI
6948:    ']';
      
      
      % Specialization of array indexing for ShortString.
      % We treat the starting index as 0 so that str[1] sees the first string char,
      % past the length byte.
      %
6951: ShortStringArraySubscript:
6953:    [ oTypeSNodeType
6955:       | nStrLitType, nShortStringType :
6956:       | * :    #eCantDereference
6965:    ]
6965:    oTypeSPop
6966:    oTypeSPush( CharType )
6972:    @Expr
6974:    @RequireIntPop
6976:    .tAddPI
6978:    ']';
      
      
6981: RecordFieldRef:
6983:    [ oTypeSNodeType
6985:       | nRecordType :
6986:       | * :    #eNotRecord
6993:    ]
6993:    oScopeEnter( oNodeGet( oTypeSTop, qScope ) )
7005:    pIdent
7007:    Node field = oScopeFindRequire
         % oScopeFind searches all open scopes, so make sure we found nRecordField
         % which could only be seen in the local scope we entered above.
7012:    [ oNodeType( field )
7019:       | nRecordField :
7020:       | * :   #eNotRecordField
7027:    ]
7027:    oScopeEnd
7028:    int offset = oNodeGetInt( field, qValue )
7041:    [ equal_zero( offset )
7048:       | false :
7049:          .tPushConstI oEmitInt( offset ) .tAddPI
7059:       | * :
7064:    ]
      
         % replace the type on the type stack, with the field type
7064:    oTypeSPop
7065:    oTypeSPush( oNodeGet( field, qType ) )
7079:    ;
      
      
      % On entry, expr stack has ptr, and integer index above it.
      % The type stack has just the pointer type.
      % Pop those, and push the ptr advanced to that index
      % (scaled by the pointed-to element size).
      % Leaves the pointer type on the type stack.
      %
7079: PointerAddition:
7081:    Node elementType = oNodeGet( oTypeSTop, qBaseType )
7093:    int elementSize = oNodeGetInt( elementType, qSize )
7106:    [ equal( elementSize, 1 )
7116:       | false :
7117:          .tPushConstI  oEmitInt( elementSize )
7125:          .tMultI
7127:       | * :
7132:    ]
7132:    .tAddPI
7135:    ;
      
      
      % On entry, expr stack has ptr, and integer above it.
      % The type stack has just the pointer type.
      % Pop those, and push the ptr decremented by that integer
      % (scaled by the pointed-to element size).
      % Leaves the pointer type on the type stack.
      %
7135: PointerSubInt:
7137:    Node elementType = oNodeGet( oTypeSTop, qBaseType )
7149:    int elementSize = oNodeGetInt( elementType, qSize )
7162:    [ equal( elementSize, 1 )
7172:       | false :
7173:          .tPushConstI  oEmitInt( elementSize )
7181:          .tMultI
7183:       | * :
7188:    ]
7188:    .tSubPI
7191:    ;
      
      
      % On entry, expr stack has two pointers, P1 and P2 above it.
      % The type stack has the type of P1.  (The type of P2 was already matched to P1.)
      % Replace the pointers on the expression stack with P1 - P2, scaled by the
      % pointed-to element size.  Type stack switched to integer.
      % 
7191: PointerSubPointer:
7193:    .tSubP
7195:    Node elementType = oNodeGet( oTypeSTop, qBaseType )
7207:    int elementSize = oNodeGetInt( elementType, qSize )
7220:    [ equal( elementSize, 1 )
7230:       | false :
7231:          .tPushConstI  oEmitInt( elementSize )
7239:          .tDivI
7241:       | * :
7246:    ]
7246:    oTypeSPop
7247:    oTypeSPush( IntegerType )
7254:    ;
      
      % ptr deref on left side, i.e. BEFORE addr of ptr var is on stack,
      %                              AFTER addr of thing pointed to is on stack
7254: PointerDeref:
7256:    [ oTypeSNodeType
7258:       | nPointerType :
7259:       | nUniversalPointerType :   #eCantDereference
7263:       | * :       #eNotPointer
7272:    ]
7272:    .tFetchP           % now addr on stack is addr of what we're pointing to
      
7274:    Node theType = oTypeSTop
7279:    oTypeSPop
7280:    oTypeSPush( oNodeGet( theType, qBaseType ) )
7294:    ;
      
      
      % The expr stack contains a value whose type is on top of the type stack.
      % Generate code to coerce the value to the type under it in the type stack
      % (pop the type stack, leaving only the desired type).
      % This is used for assignment.
      %
7294: CoerceType:
7296:    node_type nt = oTypeSNodeType
7301:    oTypeSPop
7302:    [ equal_node_type( nt, oTypeSNodeType )
7311:       | false :
               % Can we implicitly convert the value to the desired type?
7312:          [ oTypeSNodeType
7314:             | nIntegerType :
7315:                [ nt
7318:                   | nByteType :   .tCastBtoI  >>
7322:                   | * :
7327:                ]
7327:             | nByteType :
7329:                [ nt
7332:                   | nIntegerType :   .tCastItoB  >>
7336:                   | * :
7341:                ]
7341:             | nPointerType :
7343:                [ nt
7346:                   | nUniversalPointerType :  >>
7348:                   | nStrLitType :
7350:                      [ equal_node( oTypeSTop, PCharType )
7359:                         | true :
                                 % PChar := 'strlit' i.e. point at strlit[1]
7360:                            .tPushConstI  oEmitInt(1)  .tAddPI  >>
7371:                         | * :
7376:                      ]
7376:                   | * :
7383:                ]
7383:             | nUniversalPointerType :
7385:                [ nt
7388:                   | nPointerType :  >>
7390:                   | * :
7395:                ]
7395:             | nShortStringType :
7397:                [ nt
7400:                   | nStrLitType :  >>
7402:                   | nCharType :
                           % Store char as a temp ShortString.
7404:                      oTypeSPush( CharType )
7410:                      int tempOffset = @MoveIntoTempShortString
7416:                      oTypeSPop
7417:                      >>
7418:                   | * :
7425:                ]
7425:             | * :
7438:          ]
7438:          #eTypeMismatch
7440:       | * :
7445:    ];
      
      
      % Require that the top two types on the type stack are matching (ignoring subranges).
      % Pop one of them, leaving only one.
      %
7446: MatchTypes:
7448:    node_type nt = oTypeSNodeType
7453:    oTypeSPop
7454:    [ equal_node_type( nt, oTypeSNodeType )
7463:       | false :
               % Some implicit conversion is allowed even here
7464:          [ oTypeSNodeType
7466:             | nPointerType :
7467:                [ nt
7470:                   | nUniversalPointerType :  >>
7472:                   | * :
7477:                ]
7477:             | nUniversalPointerType :
7479:                [ nt
7482:                   | nPointerType :  >>
7484:                   | * :
7489:                ]
7489:             | * :
7496:          ]
7496:          #eTypeMismatch
7498:       | * :
7503:    ];
      
      
      % Require that the top type on the type stack is integer (ignoring subranges).
      % Pop it.
      %
7504: RequireIntPop:
7506:    [ oTypeSNodeType
7508:       | nIntegerType :
7509:       | * :          #eNotInteger
7516:    ]
7516:    oTypeSPop;
      
7518: RequireInt:
7520:    [ oTypeSNodeType
7522:       | nIntegerType :
7523:       | * :          #eNotInteger
7530:    ];
      
      
      % Convert the top value to integer (if it isn't already).
      % It must be implicitly convertable to integer.
      % Pop the type stack.
      %
7531: PromoteToIntPop:
7533:    [ oTypeSNodeType
7535:       | nIntegerType :
7536:       | nByteType :        .tCastBtoI
7540:       | * :                #eNotInteger
7549:    ]
7549:    oTypeSPop;
      
      % Convert the top value to integer (if it isn't already).
      % It must be implicitly convertable to integer.
      % Leave integer on the type stack.
      %
7551: PromoteToInt:
7553:    [ oTypeSNodeType
7555:       | nIntegerType :
7556:       | nByteType :        .tCastBtoI
7560:                            oTypeSPop
7561:                            oTypeSPush( IntegerType )
7567:       | * :                #eNotInteger
7576:    ];
      
      
      % If the top value is implicitly convertable to integer, do so.
      % Otherwise leave it as-is.
      %
7577: PromoteToIntOptional:
7579:    [ oTypeSNodeType
7581:       | nByteType :        .tCastBtoI
7584:                            oTypeSPop
7585:                            oTypeSPush( IntegerType )
7591:       | * :
7596:    ];
      
      
7597: RequireBoolPop:
7599:    [ oTypeSNodeType
7601:       | nBooleanType :
7602:       | * :          #eNotBoolean
7609:    ]
7609:    oTypeSPop;
      
7611: RequireBool:
7613:    [ oTypeSNodeType
7615:       | nBooleanType :
7616:       | * :          #eNotBoolean
7623:    ];
      
      
7624: include 'pascal_stmt.ssl'
      %
      % Pascal Compiler
      %
      
      
      % ------------------------------ Statements -----------------------------
      
7624: Statement:
7626:    [
7626:       | pWriteln :     @WritelnStmt
7630:       | pWrite :       @WriteStmt
7634:       | pReadln :      @ReadlnStmt
7638:       | pRead :        @ReadStmt
7642:       | pIf :          @IfStmt
7646:       | pWhile :       @WhileStmt
7650:       | pFor :         @ForStmt
7654:       | pRepeat :      @RepeatStmt
7658:       | pBreak :       @BreakStmt
7662:       | pContinue :    @ContinueStmt
7666:       | pBegin :       @BeginStmt
7670:       | pIdent :       @LabelOrAssignOrCallStmt
7674:       | pCase :        @CaseStmt
7678:       | pGoto :        @GotoStmt
7682:       | pIntLit :      % should be an integer label
7684:                        oChangeIntLitToLabelIdent
7685:                        @LabelOrAssignOrCallStmt
7687:       | * :            % null statement : don't accept any tokens
7720:    ];
      
      
7721: LabelOrAssignOrCallStmt:
7723:    Node decl = oScopeFindRequire
7728:    @ResolveUnitRef( decl )
7735:    [ oNodeType( decl )
7742:       | nLabel :                          @LabelDefinition( decl )
7750:                                           @Statement
7752:       | nProc :                           @Call( decl )
7761:       | nGlobalVar, nLocalVar, nParam :   @AssignStmt( decl )
7770:       | nFunc :                           @AssignResultStmt( decl )
7779:       | * :                               #eBadStatement
7796:    ];
      
      
      % Parse a "label:" prefix in front of a statement.
      %
7797: LabelDefinition( Node decl ):
7799:    [ oNodeGetBoolean( decl, qDefined )
7809:       | true :  #eAlreadyDefined
7812:       | * :
7817:    ]
7817:    .tLabel  oEmitLabel( oNodeGetLabel( decl, qValue ) )
7832:    oNodeSetBoolean( decl, qDefined, true )
7844:    ':'
7847:    ;
      
      
      % Given decl, the just-accepted first identifier on the left hand side.
      %
7847: AssignStmt( Node decl ):
      
7849:    @LValueVar( decl, true )
7859:    ':=' 
7861:    @Expr
7863:    @CoerceType
7865:    @Assign
7868:    ;
      
      
      % Performs a raw assignment.
      % Given lvalue 2nd on stack, and expr value top of stack (already coerced to the lvalue type),
      % and type of both of these on the type stack,
      % perform the assignment and pop the type off the type stack.
      %
7868: Assign:
7870:    [ oTypeSNodeType
7872:       | nIntegerType, nEnumType :  .tAssignI
7875:       | nBooleanType, nByteType, nCharType :  .tAssignB
7879:       | nFileType :   #eNotImplemented
7883:       | nPointerType, nUniversalPointerType :  .tAssignP
            % compound var assigns; addrs of src, dest on stack
7887:       | nArrayType, nRecordType, nShortStringType :
                % TO DO: for ShortString, allow destination to be smaller capacity,
                % and truncate the copied value/length.
7889:           int size = oNodeGetInt( oTypeSTop, qSize )
7901:           .tCopy  oEmitInt( size )    % multi-word copy
7909:    ]
7935:    oTypeSPop
7937:    ;
      
      % Given nFunc for the just-accepted identifier on the left hand side.
      % Parse an assignment that represents assignment of the function result.
      %
7937: AssignResultStmt( Node funcDecl ):
         % Only allowed to assign the result of the immediately enclosing function, I think.
7939:    [ oNodeEqual( oNodeGet( funcDecl, qChildScope ), oScopeCurrent )
7955:       | false :   #eNotCurrentFunction
7958:       | * :
7963:    ]
      
         % Result value is stored in the caller's space, via a hidden VAR parameter.
7963:    .tPushParamP  oEmitInt( oNodeGetInt( funcDecl, qResultOffset ) )
7978:    oTypeSPush( oNodeGet( funcDecl, qType ) )
      
7991:    ':='
7993:    @Expr
7995:    @CoerceType
7997:    [ oTypeSNodeType
7999:       | nIntegerType, nEnumType : .tAssignI
8002:       | nBooleanType, nByteType, nCharType :  .tAssignB
8006:       | nFileType :   #eNotImplemented
8010:       | nPointerType, nUniversalPointerType :  .tAssignP
            % compound var assigns; addrs of src, dest on stack
8014:       | nArrayType, nRecordType, nShortStringType :
8016:           int size = oNodeGetInt( oTypeSTop, qSize )
8028:           .tCopy  oEmitInt( size )    % multi-word copy
8036:    ]
8062:    oTypeSPop
8064:    ;
      
      
      
      % Parse an lvalue expression, from scratch.
      % This is an expression that may appear on the left side of an assignment.
      % Leaves the address of the value on the expr stack,
      % and the type of the value at that address on the type stack.
      % If writeable is false, the expression won't be written to, so may access a
      % typed const.
      %
8064: LValueExpr( boolean writeable ):
         % At the moment, all lvalue expressions start with a variable name.
         % I think there can also be typecasts, not supported yet.  Check standard syntax.
8066:    pIdent
8068:    Node decl = oScopeFindRequire
8073:    @ResolveUnitRef( decl )
8080:    [ oNodeType( decl )
8087:       | nGlobalVar, nLocalVar, nParam, nTypedConst :
8088:       | * :  #eNotVar
8101:    ]
8101:    @LValueVar( decl, writeable )
8112:    ;
      
      
      % Parse an lvalue expression (e.g. left side of an assign statement)
      % that starts with the just-accepted identifier indicated by the given decl.
      % Leaves the lvalue address on the expression stack,
      % and the type of the value at that address on the type stack.
      %
8112: LValueVar( Node decl, boolean writeable ):
8114:    [ oNodeType( decl )
8121:       | nGlobalVar :   .tPushAddrGlobal @EmitValue( decl )
8131:       | nLocalVar :    .tPushAddrLocal @EmitValue( decl )
8142:       | nParam :
8144:          [ oNodeGetBoolean( decl, qInOut )
8154:             | true :   % VAR param points to variable.  No dereference.
8155:                        .tPushParamP @EmitValue( decl )
8164:             | * :      .tPushAddrParam @EmitValue( decl )
8178:          ]
8178:       | nTypedConst :
8180:          [ writeable
8183:             | false :  .tPushAddrGlobal @EmitValue( decl )                       
8193:             | * :      #eNotVar
8200:          ]
8200:       | * :            #eNotVar
8213:    ]
      
8213:    oTypeSPush( oNodeGet( decl, qType ) )
      
         % handle subscripts, if any.
         % There is one case that I'm not fitting into the pattern nicely, so need to
         % check for specially here:  if lvalue var is a pointer variable, and is
         % followed by [index], we need to dereference the pointer variable before applying
         % the index.  This is different from handling of [index] on an rvalue expression.
         % Right now I have LValueIndexes working for both lvalue and rvalue (composite types)
         % so can't easily add this behavior in there.
         % TO DO: probably I need separate rules LValueIndexes and RValueIndexes.
         %    This might also explain my confusion about handling of deref operator in LValueIndexes vs rvalue expr,
         %    and having separate rules might clear that up better.
      
8226:    [ oTypeSNodeType
8228:       | nPointerType :
8229:          [
8229:             | '[' :
                     % dereference the pointer var first
8231:                .tFetchP
8233:                @PointerArraySubscript
8235:             | * :
8240:          ]
8240:       | * :
8245:    ]
         % additional subscripts, if any
8245:    @LValueIndexes
8248:    ;
      
      
8248: IncVar( Node decl ):
8250:    @LValueVar( decl, true )
8260:    @RequireIntPop
8262:    @VarExpr( decl )
8269:    oTypeSPop
8270:    .tIncI
8272:    .tAssignI;
      
8275: DecVar( Node decl ):
8277:    @LValueVar( decl, true )
8287:    @RequireIntPop
8289:    @VarExpr( decl )
8296:    oTypeSPop
8297:    .tDecI
8299:    .tAssignI;
      
      
8302: IfStmt:
8304:    Label falseLabel = labelNull
      
8310:    @BooleanExprControlFlow( falseLabel )
8317:    pThen
8319:    @Statement
8321:    [
8321:       | pElse :
8323:          Label doneLabel = oLabelNew
      
8328:          .tJump  oEmitLabel( doneLabel )
8336:          .tLabel oEmitLabel( falseLabel )
8344:          @Statement
8346:          .tLabel oEmitLabel( doneLabel )
      
8354:       | * :
8359:          .tLabel oEmitLabel( falseLabel )
8367:    ];
      
      
8368: ForStmt:
8370:    pIdent
      
8372:    Node decl = oScopeFindRequire
         % TO DO: disallow use of a compound variable field.
         %        Could do that by disallowing use of LValueIndexes,
         %        or by double-checking the decl's qType here.
         % TO DO: I think I read somewhere that the variable must be in current scope.
8377:    @LValueVar( decl, true )
8387:    @RequireIntPop
      
8389:    ':='
      
8391:    @Expr
8393:    @RequireIntPop
8395:    .tAssignI
      
8397:    Label breakLabel = oLabelNew
      
8402:    Label checkLabel = oLabelNew
8407:    .tJump  oEmitLabel( checkLabel )
      
8415:    Label continueLabel = oLabelNew
8420:    .tLabel  oEmitLabel( continueLabel )
8428:    [
8428:       | pTo :
8430:          @IncVar( decl )
8437:          .tLabel  oEmitLabel( checkLabel )
8445:          @VarExpr( decl )  oTypeSPop
8453:          @Expr
8455:          @RequireIntPop
8457:          .tGreaterI
8459:          .tJumpTrue  oEmitLabel( breakLabel )
8467:       | pDownto :
8469:          @DecVar( decl )
8476:          .tLabel  oEmitLabel( checkLabel )
8484:          @VarExpr( decl )  oTypeSPop
8492:          @Expr
8494:          @RequireIntPop
8496:          .tLessI
8498:          .tJumpTrue  oEmitLabel( breakLabel )
8506:    ]
8514:    oLoopPush( continueLabel, breakLabel )
8523:    pDo
8525:    @Statement
8527:    .tJump  oEmitLabel( continueLabel )
8535:    .tLabel  oEmitLabel( breakLabel )
8543:    oLoopPop;
      
      
8545: RepeatStmt:
8547:    Label continueLabel = oLabelNew
8552:    .tLabel  oEmitLabel( continueLabel )
      
8560:    Label breakLabel = oLabelNew
      
8565:    oLoopPush( continueLabel, breakLabel )
8574:    @Statement
8576:    {[
8576:       | ';' :
8578:          @Statement
8580:       | pUntil :
8582:          Label falseLabel
8582:          @BooleanExprControlFlow( falseLabel )
8589:          .tLabelAlias  oEmitLabel( falseLabel )  oEmitLabel( continueLabel )
8603:          >
8605:    ]}
8615:    .tLabel  oEmitLabel( breakLabel )
8623:    oLoopPop;
      
      
8625: WhileStmt:
8627:    Label continueLabel = oLabelNew
8632:    .tLabel  oEmitLabel( continueLabel )
      
8640:    Label breakLabel
8640:    @BooleanExprControlFlow( breakLabel )
      
8647:    oLoopPush( continueLabel, breakLabel )
8656:    pDo
8658:    @Statement
8660:    .tJump  oEmitLabel( continueLabel )
8668:    .tLabel  oEmitLabel( breakLabel )
8676:    oLoopPop;
      
      
8678: ContinueStmt:                     % NOTE, for repeat..until, skips test (??)
8680:    [ equal_label( oLoopContinueLabel, labelNull )
8689:       | true :
8690:          #eNotInALoop
8692:       | false :
8694:          .tJump  oEmitLabel( oLoopContinueLabel )
8701:    ];
      
      
8710: BreakStmt:
8712:    [ equal_label( oLoopBreakLabel, labelNull )
8721:       | true :
8722:          #eNotInALoop
8724:       | false :
8726:          .tJump  oEmitLabel( oLoopBreakLabel )
8733:    ];
      
      
8742: CaseStmt:
8744:    Code tableCode = oCodeNew
8749:    Label tableLabel = oLabelNew
8754:    Label doneLabel = oLabelNew
8759:    Label otherwiseLabel = doneLabel
      
8765:    @Expr
         % Leave the expr type on the type stack throughout case statement
8767:    [ oTypeSNodeType
8769:       | nBooleanType, nByteType, nCharType :   .tJumpCaseB  oEmitLabel( tableLabel )
8778:       | nIntegerType, nEnumType :              .tJumpCaseI  oEmitLabel( tableLabel )
8788:       | nShortStringType, nStrLitType :        #eNotImplemented
8792:       | * :     #eNotAllowed
8811:    ]
8811:    pOf
      
8813:    {
8813:       [
8813:          | pOtherwise, pElse :
8815:             otherwiseLabel = oLabelNew
8820:             .tLabel  oEmitLabel( otherwiseLabel )
      
                  % A bit tricky:
                  % The otherwise clause allows multiple statements (unlike other cases).
                  % ';' might be separating statements in the otherwise clause,
                  % or might be an optional trailing ; after the last statement.
                  % I have to watch for End to know when the statements stop.
                  % (Note, the otherwise clause is the last part of the case statement.)
8828:             {[
8828:                | pEnd :  >
8832:                | * :
8837:                   @Statement
8839:                   [
8839:                      | ';' :
8841:                      | * :   pEnd  >
8850:                   ]
8850:             ]}
8852:             >
      
8854:          | pEnd :
                  % Reached end with no otherwise clause
8856:             >
      
8858:          | * :
8867:             Label caseLabel = oLabelNew
8872:             oCodePush( tableCode )
8878:             {
8878:                @ConstExpr
8880:                @ConstCoerceType
8882:                int val = oValueTop
8887:                oValuePop
8888:                [
8888:                   | '..' :  @ConstExpr
8892:                             @ConstCoerceType
8894:                             int highval = oValueTop
8899:                             oValuePop
8900:                             .tCaseRange  oEmitInt( val )  oEmitInt( highval )  oEmitLabel( caseLabel )
8920:                   | * :     .tCase  oEmitInt( val )  oEmitLabel( caseLabel )
8939:                ]
8939:                [
8939:                   | ',' :
8941:                   | * :  >
8948:                ]
8948:             }
8950:             oCodePop
8951:             ':'
8953:             .tLabel  oEmitLabel( caseLabel )
8961:             @Statement
8963:             .tJump  oEmitLabel( doneLabel )
                  % Swallow optional trailing ';'
8971:             [
8971:                | ';' :
8973:                | * :
8978:             ]
                  
8978:       ]
         
8978:    }
      
8980:    .tLabel  oEmitLabel( tableLabel )
8988:    oEmitCode( tableCode )
8994:    .tCaseEnd  oEmitLabel( otherwiseLabel )
9002:    .tLabel  oEmitLabel( doneLabel )
9010:    oTypeSPop
9012:    ;
      
      
9012: GotoStmt:
9014:    [
9014:       | pIdent :
9016:       | pIntLit :
               % Replace token with identifier "_label_<intlit>"
9018:          oChangeIntLitToLabelIdent
9019:    ]
      
         % Some pascals have rules about where you can jump (to a sibling statement or
         % higher level statement in the block, but not into a lower lower level statement.)
         % fpc just says "jumping into a nested statement can have strange effects."
         % I'm going to follow that and not prohibit any goto, as long as it's in the same block.
      
         % Label must be declared in the same block (same scope) it is used.
         % Some pascals allow non-local goto, but we do not.
         % That would require more tracking of dynamic scope, to unwind stack.
         % Note: in main program statement, this relies on the temporaries scope extending
         %  the main scope (where a label declaration would occur).
9027:    Node decl = oScopeFindRequireInScope( oScopeCurrent )
9036:    oNodeSetBoolean( decl, qUsed, true )
9048:    .tJump  oEmitLabel( oNodeGetLabel( decl, qValue ) )
9064:    ;
      
      
9064: BeginStmt:
9066:    @Statement
9068:    {[
9068:       | ';' :   @Statement
9072:       | pEnd :  >
9076:    ]};
      
      
9087: WritelnStmt:
9089:    @WriteStmt
9091:    .tWriteCR;
      
      
9094: WriteStmt:
9096:    [
9096:       | '(' :
9098:          {
9098:             @Expr
9100:             [ oTypeSNodeType
9102:                | nIntegerType :             .tWriteI
9105:                | nBooleanType :             .tWriteBool
9109:                | nByteType :                .tCastBtoI  .tWriteI
9115:                | nCharType :                .tWriteChar
9119:                | nShortStringType, nStrLitType :   .tWriteShortStr
9123:                | nFileType :                #eNotImplemented
9127:                | nEnumType :
                        % write name via table lookup
9129:                   .tPushAddrGlobal  oEmitInt( oNodeGetInt( oTypeSTop, qNameTable ) )
9143:                   .tWriteEnum
9145:                | nPointerType :
9147:                   [ equal_node( oTypeSTop, PCharType )
9156:                      | true :               .tWritePChar
9159:                      | * :                  .tWriteP
9166:                   ]
9166:                | nUniversalPointerType :    .tWriteP
9170:                | * :                        #eNotAllowed
9195:             ]
9195:             oTypeSPop
9196:             [
9196:                | ')' : >
9200:                | ',' :
9202:             ]
9210:          }
9212:       | * :
9217:    ];
      
      
9218: ReadlnStmt:      % ***
         % TO DO
9221:    ;
      
9221: ReadStmt:
         % TO DO
9224:    ;
9224: include 'pascal_str.ssl'
      %
      % Pascal Compiler
      %
      
      % ------------------------------ String Operations -----------------------------
      
      
      % Given a ShortString, StrLit, or Char on the expression stack
      % (and type on the type stack).  Move the value into a new temporary ShortString.
      % Leave that temp string and type on the stacks.
      % Also returns the offset of the temp string.
      %
9224: MoveIntoTempShortString >> int:
9226:    int tempOffset = oScopeAllocType( ShortStringType )
         % copy the value
9236:    [ oTypeSNodeType
9238:       | nShortStringType, nStrLitType :
9239:          .tPushAddrLocal  oEmitInt( tempOffset )
               % put temp addr under value addr
9247:          .tSwap
               % TO DO: we could just copy length + 1, but tCopy takes a fixed #bytes
9249:          .tCopy  oEmitInt( oNodeGetInt( ShortStringType, qSize ) )
9264:       | nCharType :
               % temp[0] = 1
9266:          .tPushAddrLocal  oEmitInt( tempOffset )
9274:          .tPushConstI  oEmitInt( 1 )
9282:          .tAssignB
               % temp[1] = value
9284:          .tPushAddrLocal  oEmitInt( add( tempOffset, 1 ) )
9299:          .tSwap
9301:          .tAssignB
9303:       | * :   #eTypeMismatch
9314:    ]
9314:    oTypeSPop
         % Leave the temp ShortString on the expr stack and type stack
9315:    .tPushAddrLocal  oEmitInt( tempOffset )
9323:    oTypeSPush( ShortStringType )
9329:    >> tempOffset;
      
      
      % Top of expr stack / type stack is ShortString B.
      % Under it is ShortString A.
      % Change A to append the contents of B to it (truncating if necessary).
      % Removes both A and B from the expr stack / type stack.
      %
9333: ShortStringAppendShortString:
         % TO DO: ideally I would do this directly with tcode.  But I think I need some more
         % enhancements for that to work well.   Meanwhile, generate a call to a method.
         % For the moment, I'll implement the method in Pascal, in the mysystem unit.
9335:    .tAllocActuals  oEmitInt( 16 )
9343:    .tPushAddrActual  oEmitInt( 8 )  .tSwap  .tAssignP
9355:    .tPushAddrActual  oEmitInt( 0 )  .tSwap  .tAssignP
9367:    .tCall   @EmitValue( System_ShortStringAppendShortString )
         % TO DO: Ideally I would leave A on the expr stack / type stack.
         %  But I can't really do that without dup, which I hesitate to add.
         %  I'll have the caller push A again themselves.
9376:    .tFreeActuals  oEmitInt( 16 )
9384:    oTypeSPop
9385:    oTypeSPop
9387:    ;
      
      % Top of expr stack / type stack is Char B.
      % Under it is ShortString A.
      % Change A to append char B to it (truncating if necessary).
      % Removes both A and B from the expr stack / type stack.
      %
9387: ShortStringAppendChar:
         % Note at the moment I don't align params
9389:    .tAllocActuals  oEmitInt( 12 )
9397:    .tPushAddrActual  oEmitInt( 8 )  .tSwap  .tAssignI
9409:    .tPushAddrActual  oEmitInt( 0 )  .tSwap  .tAssignP
9421:    .tCall  @EmitValue( System_ShortStringAppendChar )
9430:    .tFreeActuals  oEmitInt( 12 )
9438:    oTypeSPop
9439:    oTypeSPop
9441:    ;
      
      % Expr stack has ShortString A, and ShortString B above it.
      % Type stack has just the type of ShortString A.
      % Replaces the expr stack with the integer value of string comparison:
      % -1 if A < B,  0 if A = B,  1 if A > B
      % Leaves Integer on the type stack.
      %
9441: ShortStringCmp:
9443:    .tAllocActuals  oEmitInt( 24 )
9451:    .tPushAddrActual  oEmitInt( 8 )  .tSwap  .tAssignP
9463:    .tPushAddrActual  oEmitInt( 0 )  .tSwap  .tAssignP
9475:    int tempOffset = oScopeAllocType( IntegerType )
9485:    .tPushAddrActual  oEmitInt( 16 )  .tPushAddrLocal  oEmitInt( tempOffset )  .tAssignP
9503:    .tCall  @EmitValue( System_ShortStringCmp )
9512:    .tPushLocalI  oEmitInt( tempOffset )
9520:    .tFreeActuals  oEmitInt( 24 )
9528:    oTypeSPop
9529:    oTypeSPush( IntegerType )
9536:    ;
9536: include 'pascal_call.ssl'
      %
      % Pascal Compiler
      %
      
      % ------------------------------ Method Calls -----------------------------
      
      
      % Parse a call, given an nProc or nFunc for the just-accepted identifier.
      % If a func, this will also generate the code to push the return value on the expr stack,
      % and push the return type on the type stack.
      %
9536: Call( Node method ):
      
         % Prior to first call, issue extern label for a called method.
         % I don't want to issue .tLabelExtern for unused methods, that seems inefficient.
9538:    [ oNodeGetBoolean( method, qExternal )
9548:       | true :
9549:          [ oNodeGetBoolean( method, qUsed )
9559:             | false :
                     % define the extern label on first use
9560:                @DefineExternLabel( method )
9567:             | * :
9572:          ]
9572:      | * :
9577:    ]
9577:    oNodeSetBoolean( method, qUsed, true )
      
         % If the method has a cdecl modifier, the back end will need to use the native
         % calling convention, instead of my own.  But, the convention varies by platform,
         % so the front end won't assume what it needs.  I'll still generate the normal tcode
         % that copies values into actuals space on the stack.
         % However, to help the back end, I will at least use a different instruction for the
         % allocation of the actuals space, and for the actual call.
         %
         % p.s. I only support cdecl on external methods, because I don't have a way
         % to let my own Pascal methods read params passed in with the cdecl calling convention.
         %
9589:    boolean cdecl = oNodeGetBoolean( method, qCdecl )
      
         % If this is a function, we will allocate a temporary
         % in the current scope, to hold the result value.
         % And pass a pointer to that temporary as an extra parameter.
9602:    Node resultType
9602:    int tempOffset
      
9602:    boolean isFunc = equal_node_type( oNodeType( method ), nFunc )
      
9619:    [ isFunc
9622:       | true :
9623:          resultType = oNodeGet( method, qType )
9636:          tempOffset = oScopeAllocType( resultType )
               % TO DO: we could manage temp allocation, so temp space can be reused
               %        by different code branches.
9646:       | * :
9651:    ]
         
      
9651:    Node paramScope = oNodeGet( method, qParams )
9664:    int actualsSize = oNodeGetInt( paramScope, qSize )
9677:    [ cdecl
9680:       | true : .tAllocActualsCdecl  oEmitInt( actualsSize )
9689:       | false :  .tAllocActuals  oEmitInt( actualsSize )
9699:    ]
      
         % If method is nested, it takes a hidden first parameter:
         % a pointer to the frame of the static scope in which the method is declared.
         % The location of a scope's frame is equivalent to offset 0 in the scope's locals space
         % (since local offsets are relative to the scope's frame pointer).
         %
         % The nested method may be in a higher scope (upLevels > 1),
         % or a sibling of the method we're in (upLevels = 1),
         % or an immediate child of the current method (upLevels = 0).
         %
         % To understand the upLevels computation, remember that a method's declaration
         % and its contents (variables, nested functions, and body statement)
         % are in two different scopes.
      
9707:    [ greater( @DeclLevel( method ), 0 )
9722:       | true :
9723:          .tPushAddrActual  oEmitInt( 0 )    % hidden param is at param offset 0
9731:          .tPushAddrUpLocal  oEmitInt( @DeclUpLevels( method ) )  oEmitInt( 0 )
9750:          .tAssignP
9752:       | * :
9757:    ]
      
      
9757:    NodeIter paramIter = oNodeGetIter( paramScope, qDecls )
9770:    Node param = oNodeIterValue( paramIter )
9780:    [
9780:       | '(' :
            
9782:          {
9782:             [ oNodeNull( param )
9789:                | true : >
9792:                | * :
9797:             ]
      
9797:             int offset = oNodeGetInt( param, qValue )
      
                  % Assign actual value to spot in actuals space
9810:             .tPushAddrActual oEmitInt( offset )
9818:             oTypeSPush( oNodeGet( param, qType ) )
      
9831:             [ oNodeGetBoolean( param, qInOut )
9841:                | true :   % A VAR param.
                                % The actual is a pointer to the value.
                                % The type on the type stack (pushed above) is for the pointed-to value.
      
9842:                           @LValueExpr( true )
                                % Addr of the referenced variable is on the expr stack,
                                % type of the variable is on the type stack.
      
                                % Match types more exactly. It's not sufficient to be assign compatible
                                % since the method will be assigning to the actual using the param type.
                                % Maybe something like type contents must match, incl subrange bounds.
9849:                           @MatchTypes
      
9851:                           .tAssignP
      
9853:                | false :  @Expr
9857:                           @CoerceType
                                
                                % Assign to offset in actuals space
      
9859:                           [ oTypeSNodeType
9861:                              | nIntegerType, nEnumType : .tAssignI
9864:                              | nBooleanType, nByteType, nCharType :  .tAssignB
9868:                              | nFileType :   #eNotImplemented
9872:                              | nPointerType, nUniversalPointerType :  .tAssignP
9876:                              | nArrayType, nRecordType, nShortStringType :
                                       % compound types: copy value into actuals space
9878:                                  int size = oNodeGetInt( oTypeSTop, qSize )
9890:                                  .tCopy  oEmitInt( size )    % multi-word copy
9898:                           ]
9924:             ]
9932:             oTypeSPop
      
9933:             oNodeIterNext( paramIter )
9939:             param = oNodeIterValue( paramIter )
9949:             [ oNodeNull( param )
9956:                | true :  >
9959:                | false :
9961:             ]
      
9969:             ','
9971:          }
      
9973:          ')'
      
9975:       | * :
9980:    ]
      
9980:    [ oNodeNull( param )
9987:       | false :    #eMissingParameter
9990:       | * :
9995:    ]
      
9995:    [ isFunc
9998:       | true :
               % Pass result temp as an additional VAR parameter.
9999:          .tPushAddrActual oEmitInt( oNodeGetInt( method, qResultOffset ) )
10014:          .tPushAddrLocal  oEmitInt( tempOffset )
10022:          .tAssignP
10024:       | * :
10029:    ]
      
10029:    [ cdecl
10032:       | true :
10033:          .tCallCdecl  @EmitValue( method )
10042:       | false :
10044:          .tCall   @EmitValue( method )
10053:    ]
      
10061:    [ isFunc
10064:       | true :
               % push return value from temp
10065:          oTypeSPush( resultType )
      
10071:          [ oTypeSNodeType
10073:             | nIntegerType, nEnumType :   .tPushLocalI  oEmitInt( tempOffset )
10082:             | nBooleanType, nByteType, nCharType :   .tPushLocalB  oEmitInt( tempOffset )
10092:             | nFileType :  #eNotImplemented
10096:             | nPointerType, nUniversalPointerType :   .tPushLocalP  oEmitInt( tempOffset )
10106:             | nArrayType, nRecordType, nShortStringType :   % compound type: push address
10108:                                .tPushAddrLocal  oEmitInt( tempOffset )
10116:          ]
10142:       | * :
10147:    ]
         
10147:    .tFreeActuals  oEmitInt( actualsSize )
10156:    ;
      
      
      
      % Called on first use of an extern method
      %
10156: DefineExternLabel( Node method ):
         % The extern name might be given explicitly, otherwise the pascal method name.
10158:    int strAddr
10158:    String externalName = oNodeGetString( method, qExternalName )
10171:    [ equal_string( externalName, stringNull )
10181:       | true :
10182:          strAddr = oStringAllocLit( ID_STRING( oNodeGetInt( method, qIdent ) ) )
10203:       | false :
10205:          strAddr = oStringAllocLit( externalName )
10215:    ]
10223:    .tLabelExtern  @EmitValue( method )  oEmitInt( strAddr )
10239:    ;
      
      
      
      % Parse a call to a built-in function, identified by the just-accepted identifier.
      % This will also generate the code to push the return value on the expr stack,
      % and push the return type on the type stack.
      %
10239: CallBuiltInFunc( Node method ):
      
         % Ord(x)
10241:    [ oNodeEqual( method, BuiltIn_Ord )
10251:       | true :
               % parameter is any scalar type (including boolean, enum, char)
               % result is integer
10252:          '('
10254:          @Expr
10256:          [ oTypeSNodeType
10258:             | nIntegerType, nEnumType :
10259:             | nBooleanType, nByteType, nCharType :  .tCastBtoI
10263:             | * :  #eTypeMismatch
10278:          ]
10278:          oTypeSPop
10279:          oTypeSPush( IntegerType )
10285:          ')'
10287:          >>
10288:       | * :
10293:    ]
      
         % Chr(x)
10293:    [ oNodeEqual( method, BuiltIn_Chr )
10303:       | true :
               % parameter is integer
               % result is char
10304:          '('
10306:          @Expr
10308:          [ oTypeSNodeType
10310:             | nIntegerType :    .tCastItoB
10313:             | nByteType :
10315:             | * :  #eTypeMismatch
10324:          ]
10324:          oTypeSPop
10325:          oTypeSPush( CharType )
10331:          ')'
10333:          >>
10334:       | * :
10339:    ]
      
         % Pred(x)
10339:    [ oNodeEqual( method, BuiltIn_Pred )
10349:       | true :
               % parameter is any enum type, as long as it has values 0..N-1
               % result is the same enum type
10350:          '('
10352:          @Expr
10354:          [ oTypeSNodeType
10356:             | nEnumType :
                     % TO DO: does this skip past type aliases?
                     % TO DO: what if using pred/succ on a subrange type?
10357:                [ oNodeGetBoolean( oTypeSTop, qHasGap )
10366:                   | true :   #eCantUsePredSuccOnEnumWithValueGaps
10369:                   | * :
10374:                ]
10374:             | * :  #eTypeMismatch
10381:          ]
10381:          .tDecI
10383:          ')'
10385:          >>
10386:       | * :
10391:    ]
      
         % Succ(x)
10391:    [ oNodeEqual( method, BuiltIn_Succ )
10401:       | true :
               % parameter is any enum type, as long as it has values 0..N-1
               % result is the same enum type
10402:          '('
10404:          @Expr
10406:          [ oTypeSNodeType
10408:             | nEnumType :
                     % TO DO: does this skip past type aliases?
                     % TO DO: what if using pred/succ on a subrange type?
10409:                [ oNodeGetBoolean( oTypeSTop, qHasGap )
10418:                   | true :   #eCantUsePredSuccOnEnumWithValueGaps
10421:                   | * :
10426:                ]
10426:             | * :  #eTypeMismatch
10433:          ]
10433:          .tIncI
10435:          ')'
10437:          >>
10438:       | * :
10443:    ]
      
10443:    #eNotImplemented
10446:    ;
      
10446: include 'pascal_type.ssl'
      %
      % Pascal Compiler
      %
      
      % ------------------------------ Types -----------------------------
      
      
      % Create and return a new nType of the given node_type, adding it to the type table.
      %
10446: newType( node_type nt, int size ) >> Node:
10448:   Node node = oNodeNew( nt )
10458:   oNodeSetInt( node, qSize, size )
10470:   oTypeAdd( node )
10476:   >> node
10480:   ;
      
      
      % Parse a type reference, returning the nType.
      % This will add types to the type table, as needed.
      %
      % Style question - at the moment I think callers look clearer if we use
      % an out param here, rather than a return value.
      %
10480: TypeRef( out Node resultType ):
10482:    [
10482:       | pIdent :           % previously named type (including intrinsics)
10484:          Node decl = oScopeFindRequire
10489:          @ResolveUnitRef( decl )
10496:          [ oNodeType( decl )
10503:             | nTypeDecl :
10504:                resultType = oNodeGet( decl, qType )
10517:             | * :
10522:                #eNotType
10524:                resultType = IntegerType
10530:          ]
         
10530:       | pArray :
10532:          '['
      
               % A multi-dimensional array is represented as a chain
               %    array [subrange1] of array [subrange2] of elementType
      
               % First, we build a vector of nArray's, each with one subrange as its index type,
               % but without setting the "of" type or size.
      
10534:          NodeVec dimensions = oNodeVecNew
      
10539:          {
                  % to do: probably should use general subrange parsing, incl minimal size value
                  %   In fact, supposed to parse ordinal_type here.  all ordinal types have a static low, high.
                  %   Not necessary to be a subrange.
      
10539:             Node subrange = oNodeNew( nSubrangeType )
      
10549:             @ConstExpr
10551:             oNodeSetInt( subrange, qLow, oValueTop )
10562:             oValuePop
10563:             '..'
10565:             @ConstExpr
10567:             oNodeSetInt( subrange, qHigh, oValueTop )
10578:             oValuePop
      
10579:             @ConstMatchTypes
10581:             oNodeSet( subrange, qBaseType, oTypeSTop )
10592:             oNodeSetInt( subrange, qSize, oNodeGetInt( oTypeSTop, qSize ) )
10610:             oTypeSPop
10611:             oTypeAdd( subrange )
      
10617:             Node a = oNodeNew( nArrayType )
10627:             oNodeSet( a, qIndexType, subrange )
      
10639:             oNodeVecAppend( dimensions, a )
                  % I'll hold off on adding 'a' to the type table since not fully formed yet
      
10648:             [
10648:                | ']' : >
10652:                | ',' :
10654:             ]
10662:          }
      
10664:          pOf
10666:          Node baseType
10666:          @TypeRef( baseType )
      
               % Work backwards through the dimensions,
               % hooking up the 'of' type and calculating the size.
               % At each iteration, baseType is the 'of' type.
      
10673:          int dim = oNodeVecSize( dimensions )
      
10683:          {
10683:              dec(dim)
      
10689:              Node a = oNodeVecElement( dimensions, dim )
      
10702:              oNodeSet( a, qBaseType, baseType )
10714:              Node subrange = oNodeGet( a, qIndexType )
10727:              int width = subtract( oNodeGetInt( subrange, qHigh ), oNodeGetInt( subrange, qLow ) )
10754:              inc( width )
10760:              oNodeSetInt( a, qSize, multiply( width, oNodeGetInt( baseType, qSize ) ) )
      
10786:              oTypeAdd( a )
10792:              baseType = a
      
10798:              [ equal_zero(dim)
10805:                  | true:  >
10808:                  | *:
10813:              ]
10813:          }
      
10815:          resultType = oNodeVecElement( dimensions, 0 )
10828:          oNodeVecDelete( dimensions )
      
10834:       | '^' :
10836:          Node theType
10836:          @TypeRef( theType )
10843:          resultType = @PointerTypeTo( theType )
      
10854:       | pRecord :
10856:          resultType = oNodeNew( nRecordType )
10866:          oScopeBegin( -1, allocUp )    % level is meaningless here
      
10875:          @VarDecl( nRecordField )
      
10882:          int size = oNodeGetInt( oScopeCurrent, qSize )
               % to do: padding
10894:          [ equal_zero( size )
10901:             | true : #eRecordEmpty
10904:             | * :
10909:          ]
      
10909:          pEnd
      
10911:          oNodeSet( resultType, qScope, oScopeCurrent )
10922:          oNodeSetInt( resultType, qSize, size )
10934:          oScopeEnd
10935:          oTypeAdd( resultType )
      
      
10941:       | '(' :
               % An enum type declaration.
10943:          @EnumTypeRef( resultType )
      
      
            % *** TO DO: following type constructors are not implemented *** 
10950:       | pSet :
10952:          pOf
10954:          Node theType
10954:          @TypeRef( theType )
10961:          #eNotImplemented
10963:       | * :       % this works for cases except where expr starts with an id
10978:          @ConstExpr '..' @ConstExpr
10984:          @ConstMatchTypes
10986:          #eNotImplemented
10988:    ];
      
      
      % Parse an enum type.
      % We've already accepted the '('
      % Returns the new type.
      %
10989: EnumTypeRef( out Node resultType ):
      
10991:    resultType = oNodeNew( nEnumType )
11001:    int value = 0
11007:    int numValues = 0
11013:    boolean first = true
      
         % We'll declare the enum values in two scopes: the current scope, and a scope nested in the enum type.
         % That will let programs use either <val> or <enumType>.<val>
11019:    Node outerScope = oScopeCurrent
11024:    oScopeBegin( -1, allocUp )   % level is meaningless, and we won't use allocate
      
11033:    {
            % TO DO: assert that name not already seen in this scope, i.e. this enum.
            %  And possibly not in the outerScope either, since that probably wouldn't count as shadowing.
            %  It might be in some other higher/used scope.
11033:       pIdent
11035:       Node decl = @newIdent( nEnumValue, LAST_ID )
11048:       Node decl2 = @newIdent( nEnumValue, LAST_ID )
11061:       oNodeSet( decl, qType, resultType )
11073:       oNodeSet( decl2, qType, resultType )
      
            % build up name table, for i/o
11085:       int nameOffset = oStringAllocLit( ID_STRING( LAST_ID ) )
11098:       oNodeSetInt( decl, qNameOffset, nameOffset )
11110:       oNodeSetInt( decl2, qNameOffset, nameOffset )
11122:       [
11122:          | '=', ':=' :
11124:             oTypeSPush( IntegerType )
11130:             @ConstExpr
11132:             @ConstCoerceType
11134:             oTypeSPop
                  % value must be ascending
                  % this obviously doesn't apply to the first value
11135:             [ equal_zero( numValues )
11142:                | false :
11143:                   [ greater( oValueTop, value )
11152:                      | false :   #eEnumValueNotAscending
11155:                      | * :
11160:                   ]
11160:                | * :
11165:             ]
11165:             [ equal( value, oValueTop )
11174:                | false :
                        % The values differ from 0..N-1.  pred/succ may not be used with this type.
11175:                   oNodeSetBoolean( resultType, qHasGap, true )
11187:                | * :
11192:             ]
11192:             value = oValueTop
11197:             oValuePop
11198:          | * :
11205:       ]
11205:       oNodeSetInt( decl, qValue, value )
11217:       oNodeSetInt( decl2, qValue, value )
11229:       oScopeDeclare( decl )
      
11235:       oScopeEnter( outerScope )
11241:       oScopeDeclare( decl2 )
11247:       oScopeEnd
      
11248:       inc( value )
11254:       inc( numValues )
11260:       [
11260:          | ',' :
11262:          | * :    >
11269:       ]
11269:    }
11271:    ')'
      
11273:    oNodeSet( resultType, qScope, oScopeCurrent )
11284:    oNodeSetInt( resultType, qSize, 4 )   % always integer sized
11296:    oScopeEnd
      
         % Finish creation of the name table
         %    struct {
         %      int    value;
         %      int    padding;
         %      char*  name;
         %    } table[ numValues + 1 ];
         %  final entry will have name == nullptr
         %
         % I'll need to generate init code, to store pointers in global data,
         % since I don't have a relocation mechanism for static data at the moment.
11297:    oCodePush( @GetOrCreateInitCode( globalScope ) )
11308:    oScopeEnter( globalScope )
11314:    int size = multiply( add( numValues, 1 ), 16 )
11334:    int addr = oScopeAlloc( size, 8 )
11347:    oScopeEnd
11348:    oNodeSetInt( resultType, qNameTable, addr )
         % loop over enum values
11360:    NodeIter it = oNodeGetIter( oNodeGet( resultType, qScope ), qDecls )
11380:    {
11380:       Node enumValue = oNodeIterValue( it )
11390:       [ oNodeNull( enumValue )
11397:          | true :  >
11400:          | * :
11405:       ]
11405:       .tPushAddrGlobal  oEmitInt( addr )
11413:       .tPushConstI  oEmitInt( oNodeGetInt( enumValue, qValue ) )
11428:       .tAssignI
11430:       addr = add( addr, 8 )
11443:       .tPushAddrGlobal  oEmitInt( addr )
11451:       .tPushAddrGlobal  oEmitInt( oNodeGetInt( enumValue, qNameOffset ) )
11466:       .tAssignP
11468:       addr = add( addr, 8 )
11481:       oNodeIterNext( it )
11487:    }
         % final table entry
11489:    .tPushAddrGlobal  oEmitInt( addr )
11497:    .tPushConstI  oEmitInt( 0 )
11505:    .tAssignI
11507:    addr = add( addr, 8 )
11520:    .tPushAddrGlobal  oEmitInt( addr )
11528:    .tPushConstI  oEmitInt( 0 )
11536:    .tAssignP
11538:    addr = add( addr, 8 )
11551:    oCodePop
      
11552:    oTypeAdd( resultType )
11559:    ;
      
      
      
      % Return an nType representing a pointer to the given type.
      % (Creates a new type if necessary.)
      %
11559: PointerTypeTo( Node theType ) >> Node:
11561:    Node ptrType = oNodeGet( theType, qPointerType )
11574:    [ oNodeNull( ptrType )
11581:       | true :
11582:          ptrType = oNodeNew( nPointerType )
11592:          oNodeSet( ptrType, qBaseType, theType )
11604:          oNodeSetInt( ptrType, qSize, 8 )
11616:          oTypeAdd( ptrType )
11622:          oNodeSet( theType, qPointerType, ptrType )
11634:       | * :
11639:    ]
11639:    >> ptrType;
      
      
      
      % Return the low value of an ordinal type
      %
11643: OrdinalLow( Node theType ) >> int:
11645:    [ oNodeType( theType )
11652:       | nIntegerType :  >> oMININT
11655:       | nBooleanType :  >> 0
11660:       | nCharType :     >> 0
11665:       | nEnumType :
11667:          Node enumScope = oNodeGet( theType, qScope )
11680:          Node first = oNodeIterValue( oNodeGetIter( enumScope, qDecls ) )
11697:          >> oNodeGetInt( first, qValue )
11707:       | nSubrangeType : >> oNodeGetInt( theType, qLow )
11719:       | * :             #eNotOrdinalType
11734:                         >> 0
11737:    ];
      
      
      % Return the high value of an ordinal type
      %
11738: OrdinalHigh( Node theType ) >> int:
11740:    [ oNodeType( theType )
11747:       | nIntegerType :  >> oMAXINT
11750:       | nBooleanType :  >> 1
11755:       | nCharType :     >> 255
11760:       | nEnumType :
11762:          Node enumScope = oNodeGet( theType, qScope )
11775:          Node last = oNodeIterValue( oNodeGetIterLast( enumScope, qDecls ) )
11792:          >> oNodeGetInt( last, qValue )
11802:       | nSubrangeType : >> oNodeGetInt( theType, qHigh )
11814:       | * :             #eNotOrdinalType
11829:                         >> 0
11832:    ];
      
      
      
11833: Program:
11835:    Node t
      
11835:    workspace = oWorkspaceNew
      
         % root scope is used for builtins e.g. Integer,
         % and is a parent to any used units, and the program's own global scope.
11840:    oScopeBegin( 0, allocGlobal )
11849:    Node rootScope = oScopeCurrent
      
11854:    @installBuiltIns
      
         % Start by calling the main program routine.
      
         % This dummy call to main needs to look like a normal method itself,
         % so jit can align the stack properly.  So we need .tEnter,
         % and .tAllocActuals / .tFreeActuals.
11856:    .tEnter  oEmitInt( 0 )
11864:    Label mainLabel = oLabelNew
      
11869:    .tAllocActuals  oEmitInt( 0 )
11877:    .tCall  oEmitLabel( mainLabel )
11885:    .tFreeActuals  oEmitInt( 0 )
11893:    .tReturn
      
11895:    pProgram
11897:    pIdent
      
11899:    Node program = oNodeNew( nProgram )
11909:    oNodeSetInt( program, qIdent, LAST_ID )
11920:    oNodeSet( workspace, qProgram, program )
      
      
11932:    [
11932:       | '(' :
11934:          pIdent      % input, output files
      
11936:          t = @newIdent( nVar, LAST_ID )
11949:          oNodeSet( t, qType, FileType )
11961:          oScopeDeclareAlloc( t )
               % TO DO: I shouldn't declare the files in root scope.
               %        Should save them for program's global scope.
      
11967:          ','
11969:          pIdent
      
11971:          t = @newIdent( nVar, LAST_ID )
11984:          oNodeSet( t, qType, FileType )
11996:          oScopeDeclareAlloc( t )
      
12002:          ')'
12004:       | * :
12009:    ]
12009:    ';'
      
12011:    @UsesMySystem( program )
         % The uses clause may only appear once, immediately after the program declaration.
12018:    [
12018:       | pUses :  @UsesClause( program )
12027:       | * :
12032:    ]
12032:    @EnterUsedUnits( program )
      
         % Global scope for the program, below any used units.
12039:    oScopeBegin( 0, allocGlobal )
12048:    globalScope = oScopeCurrent
      
         % A new scope just for temporaries in the main routine
         % Create it up front, in case it's needed by variable initialization exprs.
         % But we won't stay in it here.
         % Note we say it extends the global scope, so that during main statement evaluation
         % any user labels declared in the global scope are considered to be part of the current scope.
12053:    oScopeBegin( 0, allocDown )
12062:    oNodeSet( oScopeCurrent, qExtends, globalScope )
12073:    initScope = oScopeCurrent
12078:    oNodeSet( program, qMainRoutineScope, initScope )
12090:    oScopeEnd
      
12091:    @BlockDecls( nGlobalVar )
      
      
12098:    oScopeEnter( initScope )
      
         % The block statement includes a stack frame, and enter/return,
         % even for the main routine.
         % That will be necessary for temporaries allocated in the main routine.
      
         % isMain means we'll generate calls to the unit init/final methods in here too.
         % Alternatively we could do that in a higher level method that calls main.
12104:    boolean isMain = true
12110:    @BlockStmt( mainLabel, globalScope, isMain )
      
12123:    oScopeEnd   % main routine scope
      
12124:    '.'
12126:    @CheckForUndefinedLabels
12128:    oScopeEnd   % global scope
12129:    @EndUsedUnits( program )   % used units scopes
12137:    ;
      
      
      
      
12137: Block( node_type varNodeType, Label labelForBody ):
12139:    @BlockDecls( varNodeType )
12146:    @BlockStmt( labelForBody, oScopeCurrent, false )
12158:    @CheckForUndefinedLabels
12161:    ;
      
      
12161: BlockDecls( node_type varNodeType ):
12163:    {[
12163:       | pConst :     @ConstDecl
12167:       | pType :      @TypeDecl
12171:       | pVar :       @VarDecl( varNodeType )
12180:       | pLabel :     @LabelDecl
12184:       | pProcedure : @ProcDecl
12188:       | pFunction :  @FuncDecl
12192:       | * :          >
12209:    ]}
12211:    @CheckForUndefinedMethods
12214:    ;
      
      
      % were there any procedures or functions declared in this scope
      % that were never defined?
12214: CheckForUndefinedMethods:
         % TO DO
         % Note: disregard methods marked external
12217:    ;
      
      % were there any labels declared in the current scope, and used,
      % but never defined (as the prefix of a stement)?
      %
12217: CheckForUndefinedLabels:
12219:    NodeIter it = oNodeGetIter( oScopeCurrent, qDecls )
12231:    {
12231:       Node decl = oNodeIterValue( it )
12241:       [ oNodeNull( decl )
12248:          | false :
12249:          | * :  >
12256:       ]
12256:       [ oNodeType( decl )
12263:          | nLabel :
12264:             [ oNodeGetBoolean( decl, qDefined )
12274:                | false :
12275:                   [ oNodeGetBoolean( decl, qUsed )
12285:                      | true :    #eUsedButNotDefined  % TO DO: give the decl in the message
12288:                      | * :
12293:                   ]
12293:                | * :
12298:             ]
12298:          | * :
12303:       ]
12303:       oNodeIterNext( it )
12309:    }
12312:    ;
      
      
      % Given the scope of vars in this block.
      % Usually it's the current scope, but it's a bit different for the main statement.
      %
12312: BlockStmt( Label labelForBody, Node varScope, boolean isMain ):
12314:    .tLabel  oEmitLabel( labelForBody )
      
         % Proc, func, and main routine all start with tEnter
         % to create a stack frame.  This will be used for temporaries
         % (and local vars in the case of proc, func).
      
12322:    int patchLS
12322:    .tEnter  patchLS = Here  .tSpace
      
         % If we're generating the program main method,
         % add in calls to the loaded units' initialization and finalization.
12331:    [ isMain
12334:       | true :  @InitializeUnits
12337:       | * :
12342:    ]
      
         % insert any code for initialization of this scope's variables
12342:    Code initCode = oNodeGetCode( varScope, qInitCode )
12355:    oEmitCode( initCode )
12361:    oNodeSetCode( varScope, qInitCode, codeNull )
      
12373:    @Statement
      
12375:    [ isMain
12378:       | true :  @FinalizeUnits
12381:       | * :
12386:    ]
      
12386:    .tReturn
      
12388:    int localSpace = oNodeGetInt( oScopeCurrent, qSize )
12400:    oPatch( patchLS, localSpace )
12410:    ;
      
      
      % We need an initCode code stream for the given scope.
      % Create it if not present yet.  Return it.
      % (This will be used for variable initialization.)
      %
12410: GetOrCreateInitCode( Node scope ) >> Code:
12412:    Code initCode = oNodeGetCode( scope, qInitCode )
12425:    [ equal_code( initCode, codeNull )
12435:       | true :
12436:          initCode = oCodeNew
12441:          oNodeSetCode( scope, qInitCode, initCode )
12453:       | * :
12458:    ]
12458:    >> initCode;
      
      
      
      
      
      % -------------------------------- Utilities -------------------------------
      
      % Return the static scope level of the current scope
      %
12462: ScopeLevel >> int:
12464:    >> oNodeGetInt( oScopeCurrent, qLevel );
      
      % Return the static scope level of the given declaration
      %
12474: DeclLevel( Node decl ) >> int:
12476:    >> oNodeGetInt( oNodeGet( decl, qParentScope ), qLevel );
         
      
      % How many levels higher is the given declaration from the current scope?
      %
12494: DeclUpLevels( Node decl ) >> int:
12496:    >> subtract( @ScopeLevel, @DeclLevel( decl ) );
      
      
      
      
      % Create and return a new nIdent of the given node_type, with the given ident id.
      % Does not add it to any scope.
      %
12512: newIdent( node_type nt, int id ) >> Node:
12514:   Node t = oNodeNew( nt )
12524:   oNodeSetInt( t, qIdent, id )
12536:   >> t
12540:   ;
      
      
      % Emit the value in a declaration.
      % For a constant integer, this is the constant value.
      % For a global variable, this is the global address.
      % For a local variable, this is the local address relative to the call stack frame.
      %
12540: EmitValue( Node decl ):
12542:     oEmitInt( oNodeGetInt( decl, qValue ));
      
      
12556: DeclareBuiltInFunc( int id ) >> Node:
12558:    Node decl = @newIdent( nBuiltInFunc, id )
12572:    oScopeDeclare( decl )
12578:    >> decl;
      
      
12582: installBuiltIns:
      
         % "mysystem" is the name of a unit that will be available everywhere.
         % Add its name to the id table so we can easily spot the name later.
12584:    mysystemId = oId_mysystem
      
         % install built-in types
12589:    FileType = @newType( nFileType, 4 )
12603:    IntegerType = @newType( nIntegerType, 4 )
12617:    BooleanType = @newType( nBooleanType, 1 )
12631:    BooleanFlowType = @newType( nBooleanFlowType, 1 )
12645:    CharType = @newType( nCharType, 1 )
12659:    PCharType = @PointerTypeTo( CharType )
12670:    ByteType = @newType( nByteType, 1 )
         % Universal pointer says base type Byte, but this is only for the sake of
         % pointer arithmetic.  It doesn't matter otherwise, because this type cannot be dereferened.
12684:    UniversalPointerType = @newType( nUniversalPointerType, 8 )
12698:    oNodeSet( UniversalPointerType, qBaseType, ByteType )
         % StrLitType is stored with both a length byte and null termination, so it can be assigned to
         % both a ShortString and a PChar.  StrLits longer than 255 characters appear truncated when
         % referenced as a ShortString, but not when referenced as a PChar.
12710:    StrLitType = @newType( nStrLitType, 256 )
         % ShortString is the original Pascal string type: an array of characters, not null-terminated,
         % with the first byte recording the current length.
         % The default ShortString type has capacity for 255 characters.  The user may define
         % additional ShortString types with smaller capacities.
         % The first character can be accessed as myString[1].
12724:    ShortStringType = @newType( nShortStringType, 256 )
12738:    oNodeSetInt( ShortStringType, qCapacity, 255 )
      
         % Declare those type identifiers.
         % SSL doesn't support strings, so need help from operations e.g. oId_File
      
12750:    Node t
      
12750:    t = @newIdent( nTypeDecl, oId_File )
12763:    oNodeSet( t, qType, FileType )
12775:    oScopeDeclare( t )
      
12781:    t = @newIdent( nTypeDecl, oId_Integer )
12794:    oNodeSet( t, qType, IntegerType )
12806:    oScopeDeclare( t )
      
12812:    t = @newIdent( nTypeDecl, oId_Boolean )
12825:    oNodeSet( t, qType, BooleanType )
12837:    oScopeDeclare( t )
      
12843:    t = @newIdent( nTypeDecl, oId_Char )
12856:    oNodeSet( t, qType, CharType )
12868:    oScopeDeclare( t )
      
12874:    t = @newIdent( nTypeDecl, oId_Byte )
12887:    oNodeSet( t, qType, ByteType )
12899:    oScopeDeclare( t )
      
12905:    t = @newIdent( nTypeDecl, oId_Pointer )
12918:    oNodeSet( t, qType, UniversalPointerType )
12930:    oScopeDeclare( t )
      
12936:    t = @newIdent( nTypeDecl, oId_ShortString )
12949:    oNodeSet( t, qType, ShortStringType )
12961:    oScopeDeclare( t )
      
         % Built-in constants
      
12967:    t = @newIdent( nConst, oId_True )
12980:    oNodeSet( t, qType, BooleanType )
12992:    oNodeSetInt( t, qValue, 1 )
13004:    oScopeDeclare( t )
      
13010:    t = @newIdent( nConst, oId_False )
13023:    oNodeSet( t, qType, BooleanType )
13035:    oNodeSetInt( t, qValue, 0 )
13047:    oScopeDeclare( t )
      
13053:    t = @newIdent( nConst, oId_Nil )
13066:    oNodeSet( t, qType, UniversalPointerType )
13078:    oNodeSetInt( t, qValue, 0 )
13090:    oScopeDeclare( t )
      
         % Built-in methods
         % These aren't declared like normal methods, because they may have
         % special rules for parameter types (e.g. any scalar type).
         % Calls to these methods will be handled specially by the compiler.
      
13096:    BuiltIn_Ord = @DeclareBuiltInFunc( oId_Ord )
13106:    BuiltIn_Chr = @DeclareBuiltInFunc( oId_Chr )
13116:    BuiltIn_Pred = @DeclareBuiltInFunc( oId_Pred )
13126:    BuiltIn_Succ = @DeclareBuiltInFunc( oId_Succ )
13137:    ;
      
13137: end
      
13137: 

Generated code:

   0: oGlobalSpace 22
   2: oLocalSpace 0
   4: oCall 11833
   6: oReturn
   7: oLocalSpace 0
   9: oInput 0
  11: LAST_ID
  12: oPushResult
  13: oGetParam 1
  15: oPushResult
  16: oCall 148
  18: oPop 2
  20: oInputChoice 24
  22: oJumpForward 29
  24: Choice Lookup Table
          13     22
  27: oJumpForward 31
  29: oJumpBack 9
  31: oInput 5
  33: oReturn
  34: oLocalSpace 0
  36: oGetParam 1
  38: oPushResult
  39: oSetResult 4
  41: oPushResult
  42: oNodeGetInt
  43: oPop 2
  45: oPushResult
  46: oGetGlobal 4
  48: oPushResult
  49: equal
  50: oPop 2
  52: oChoice 57
  54: oReturn
  55: oJumpForward 60
  57: Choice Lookup Table
           1     54
  60: oGetGlobal 4
  62: oPushResult
  63: oGetParam 1
  65: oPushResult
  66: oCall 148
  68: oPop 2
  70: oReturn
  71: oLocalSpace 0
  73: oGetParam 1
  75: oPushResult
  76: oSetResult 4
  78: oPushResult
  79: oNodeGetInt
  80: oPop 2
  82: oPushResult
  83: oGetGlobal 4
  85: oPushResult
  86: equal
  87: oPop 2
  89: oChoice 144
  91: oGetAddrGlobal 19
  93: oPushResult
  94: oScopeCurrent
  95: oPushResult
  96: oSetResult 15
  98: oPushResult
  99: oSetResult 4
 101: oPushResult
 102: oId_ShortStringAppendShortString
 103: oPushResult
 104: oNodeFind
 105: oPop 4
 107: oAssign
 108: oGetAddrGlobal 20
 110: oPushResult
 111: oScopeCurrent
 112: oPushResult
 113: oSetResult 15
 115: oPushResult
 116: oSetResult 4
 118: oPushResult
 119: oId_ShortStringAppendChar
 120: oPushResult
 121: oNodeFind
 122: oPop 4
 124: oAssign
 125: oGetAddrGlobal 21
 127: oPushResult
 128: oScopeCurrent
 129: oPushResult
 130: oSetResult 15
 132: oPushResult
 133: oSetResult 4
 135: oPushResult
 136: oId_ShortStringCmp
 137: oPushResult
 138: oNodeFind
 139: oPop 4
 141: oAssign
 142: oJumpForward 147
 144: Choice Lookup Table
           1     91
 147: oReturn
 148: oLocalSpace 2
 150: oGetAddrLocal 1
 152: oPushResult
 153: oGetParam 2
 155: oPushResult
 156: oCall 428
 158: oPop 1
 160: oAssign
 161: oGetLocal 1
 163: oPushResult
 164: oSetResult 0
 166: oPushResult
 167: equal_node
 168: oPop 2
 170: oChoice 240
 172: oGetParam 1
 174: oPushResult
 175: oSetResult 5
 177: oPushResult
 178: oGetLocal 1
 180: oPushResult
 181: oNodeAddLast
 182: oPop 3
 184: oGetAddrLocal 2
 186: oPushResult
 187: oSetResult 10
 189: oPushResult
 190: oNodeNew
 191: oPop 1
 193: oAssign
 194: oGetLocal 2
 196: oPushResult
 197: oSetResult 4
 199: oPushResult
 200: oGetLocal 1
 202: oPushResult
 203: oSetResult 4
 205: oPushResult
 206: oNodeGetInt
 207: oPop 2
 209: oPushResult
 210: oNodeSetInt
 211: oPop 3
 213: oGetLocal 2
 215: oPushResult
 216: oSetResult 9
 218: oPushResult
 219: oGetLocal 1
 221: oPushResult
 222: oSetResult 9
 224: oPushResult
 225: oNodeGet
 226: oPop 2
 228: oPushResult
 229: oNodeSet
 230: oPop 3
 232: oGetLocal 2
 234: oPushResult
 235: oScopeDeclare
 236: oPop 1
 238: oJumpForward 243
 240: Choice Lookup Table
           0    172
 243: oReturn
 244: oLocalSpace 1
 246: oGetFromParam 1
 248: oPushResult
 249: oNodeType
 250: oPop 1
 252: oChoice 283
 254: oGetAddrLocal 1
 256: oPushResult
 257: oGetFromParam 1
 259: oPushResult
 260: oSetResult 9
 262: oPushResult
 263: oNodeGet
 264: oPop 2
 266: oAssign
 267: oInput 20
 269: oInput 0
 271: oGetParam 1
 273: oPushResult
 274: oGetLocal 1
 276: oPushResult
 277: oScopeFindRequireInScope
 278: oPop 1
 280: oAssign
 281: oJumpForward 286
 283: Choice Lookup Table
          10    254
 286: oReturn
 287: oLocalSpace 2
 289: oGetAddrLocal 1
 291: oPushResult
 292: oGetParam 1
 294: oPushResult
 295: oSetResult 5
 297: oPushResult
 298: oNodeGetIter
 299: oPop 2
 301: oAssign
 302: oGetAddrLocal 2
 304: oPushResult
 305: oGetLocal 1
 307: oPushResult
 308: oNodeIterValue
 309: oPop 1
 311: oAssign
 312: oGetLocal 2
 314: oPushResult
 315: oNodeNull
 316: oPop 1
 318: oChoice 335
 320: oGetLocal 2
 322: oPushResult
 323: oSetResult 9
 325: oPushResult
 326: oNodeGet
 327: oPop 2
 329: oPushResult
 330: oScopeEnter
 331: oPop 1
 333: oJumpForward 340
 335: Choice Lookup Table
           0    320
 338: oJumpForward 348
 340: oGetAddrLocal 1
 342: oPushResult
 343: oNodeIterNext
 344: oPop 1
 346: oJumpBack 302
 348: oReturn
 349: oLocalSpace 2
 351: oGetAddrLocal 1
 353: oPushResult
 354: oGetParam 1
 356: oPushResult
 357: oSetResult 5
 359: oPushResult
 360: oNodeGetIterLast
 361: oPop 2
 363: oAssign
 364: oGetAddrLocal 2
 366: oPushResult
 367: oGetLocal 1
 369: oPushResult
 370: oNodeIterValue
 371: oPop 1
 373: oAssign
 374: oGetLocal 2
 376: oPushResult
 377: oNodeNull
 378: oPop 1
 380: oChoice 414
 382: oScopeCurrent
 383: oPushResult
 384: oGetLocal 2
 386: oPushResult
 387: oSetResult 9
 389: oPushResult
 390: oNodeGet
 391: oPop 2
 393: oPushResult
 394: oNodeEqual
 395: oPop 2
 397: oChoice 405
 399: oJumpForward 411
 401: oError 25
 403: oJumpForward 411
 405: Choice Lookup Table
           0    401
           1    399
 410: oEndChoice
 411: oScopeEnd
 412: oJumpForward 419
 414: Choice Lookup Table
           0    382
 417: oJumpForward 427
 419: oGetAddrLocal 1
 421: oPushResult
 422: oNodeIterPrev
 423: oPop 1
 425: oJumpBack 364
 427: oReturn
 428: oLocalSpace 2
 430: oGetAddrLocal 1
 432: oPushResult
 433: oGetGlobal 1
 435: oPushResult
 436: oSetResult 1
 438: oPushResult
 439: oSetResult 4
 441: oPushResult
 442: oGetParam 1
 444: oPushResult
 445: oNodeFind
 446: oPop 4
 448: oAssign
 449: oGetLocal 1
 451: oPushResult
 452: oSetResult 0
 454: oPushResult
 455: equal_node
 456: oPop 2
 458: oChoice 465
 460: oGetLocal 1
 462: oReturn
 463: oJumpForward 468
 465: Choice Lookup Table
           0    460
 468: oGetAddrLocal 2
 470: oPushResult
 471: oGetParam 1
 473: oPushResult
 474: oIncludeUnitFile
 475: oPop 1
 477: oAssign
 478: oGetLocal 2
 480: oChoice 489
 482: oError 24
 484: oSetResult 0
 486: oReturn
 487: oJumpForward 492
 489: Choice Lookup Table
           0    482
 492: oGetAddrLocal 1
 494: oPushResult
 495: oCall 503
 497: oAssign
 498: oIncludeEnd
 499: oGetLocal 1
 501: oReturn
 502: oReturn
 503: oLocalSpace 2
 505: oInput 60
 507: oInput 0
 509: oGetAddrLocal 1
 511: oPushResult
 512: oSetResult 5
 514: oPushResult
 515: oNodeNew
 516: oPop 1
 518: oAssign
 519: oGetLocal 1
 521: oPushResult
 522: oSetResult 4
 524: oPushResult
 525: LAST_ID
 526: oPushResult
 527: oNodeSetInt
 528: oPop 3
 530: oGetAddrLocal 2
 532: oPushResult
 533: oSetResult 6
 535: oPushResult
 536: oNodeNew
 537: oPop 1
 539: oAssign
 540: oGetLocal 2
 542: oPushResult
 543: oSetResult 4
 545: oPushResult
 546: LAST_ID
 547: oPushResult
 548: oNodeSetInt
 549: oPop 3
 551: oGetLocal 1
 553: oPushResult
 554: oSetResult 8
 556: oPushResult
 557: oGetLocal 2
 559: oPushResult
 560: oNodeSet
 561: oPop 3
 563: oInput 5
 565: oInput 61
 567: oGetLocal 1
 569: oPushResult
 570: oCall 34
 572: oPop 1
 574: oInputChoice 585
 576: oGetLocal 1
 578: oPushResult
 579: oCall 7
 581: oPop 1
 583: oJumpForward 588
 585: Choice Lookup Table
          59    576
 588: oGetLocal 1
 590: oPushResult
 591: oCall 287
 593: oPop 1
 595: oSetResult 0
 597: oPushResult
 598: oSetResult 0
 600: oPushResult
 601: oScopeBegin
 602: oPop 2
 604: oGetLocal 1
 606: oPushResult
 607: oSetResult 9
 609: oPushResult
 610: oScopeCurrent
 611: oPushResult
 612: oNodeSet
 613: oPop 3
 615: oGetAddrGlobal 2
 617: oPushResult
 618: oScopeCurrent
 619: oAssign
 620: oSetResult 0
 622: oPushResult
 623: oSetResult 1
 625: oPushResult
 626: oScopeBegin
 627: oPop 2
 629: oGetAddrGlobal 3
 631: oPushResult
 632: oScopeCurrent
 633: oAssign
 634: oGetLocal 1
 636: oPushResult
 637: oSetResult 13
 639: oPushResult
 640: oGetGlobal 3
 642: oPushResult
 643: oNodeSet
 644: oPop 3
 646: oScopeEnd
 647: oGetLocal 1
 649: oPushResult
 650: oCall 838
 652: oPop 1
 654: oScopeEnd
 655: oInput 62
 657: oGetLocal 2
 659: oPushResult
 660: oCall 34
 662: oPop 1
 664: oInputChoice 675
 666: oGetLocal 2
 668: oPushResult
 669: oCall 7
 671: oPop 1
 673: oJumpForward 678
 675: Choice Lookup Table
          59    666
 678: oGetLocal 2
 680: oPushResult
 681: oCall 287
 683: oPop 1
 685: oGetLocal 1
 687: oPushResult
 688: oSetResult 9
 690: oPushResult
 691: oNodeGet
 692: oPop 2
 694: oPushResult
 695: oScopeEnter
 696: oPop 1
 698: oSetResult 0
 700: oPushResult
 701: oSetResult 0
 703: oPushResult
 704: oScopeBegin
 705: oPop 2
 707: oGetLocal 1
 709: oPushResult
 710: oSetResult 10
 712: oPushResult
 713: oScopeCurrent
 714: oPushResult
 715: oNodeSet
 716: oPop 3
 718: oScopeCurrent
 719: oPushResult
 720: oSetResult 16
 722: oPushResult
 723: oGetLocal 1
 725: oPushResult
 726: oSetResult 9
 728: oPushResult
 729: oNodeGet
 730: oPop 2
 732: oPushResult
 733: oNodeSet
 734: oPop 3
 736: oGetAddrGlobal 2
 738: oPushResult
 739: oScopeCurrent
 740: oAssign
 741: oGetLocal 1
 743: oPushResult
 744: oCall 930
 746: oPop 1
 748: oInputChoice 762
 750: oGetLocal 1
 752: oPushResult
 753: oSetResult 1
 755: oPushResult
 756: oCall 940
 758: oPop 2
 760: oJumpForward 775
 762: Choice Lookup Table
          63    750
 765: oGetLocal 1
 767: oPushResult
 768: oSetResult 0
 770: oPushResult
 771: oCall 940
 773: oPop 2
 775: oInputChoice 789
 777: oGetLocal 1
 779: oPushResult
 780: oSetResult 1
 782: oPushResult
 783: oCall 1126
 785: oPop 2
 787: oJumpForward 802
 789: Choice Lookup Table
          64    777
 792: oGetLocal 1
 794: oPushResult
 795: oSetResult 0
 797: oPushResult
 798: oCall 1126
 800: oPop 2
 802: oInput 36
 804: oInput 20
 806: oScopeEnd
 807: oScopeEnd
 808: oGetLocal 2
 810: oPushResult
 811: oCall 349
 813: oPop 1
 815: oGetLocal 1
 817: oPushResult
 818: oCall 349
 820: oPop 1
 822: oGetGlobal 1
 824: oPushResult
 825: oSetResult 1
 827: oPushResult
 828: oGetLocal 1
 830: oPushResult
 831: oNodeAddLast
 832: oPop 3
 834: oGetLocal 1
 836: oReturn
 837: oReturn
 838: oLocalSpace 2
 840: oInputChoice 907
 842: oCall 2513
 844: oJumpForward 920
 846: oCall 3171
 848: oJumpForward 920
 850: oSetResult 21
 852: oPushResult
 853: oCall 3227
 855: oPop 1
 857: oJumpForward 920
 859: oGetAddrLocal 1
 861: oPushResult
 862: oCall 1480
 864: oAssign
 865: oInputChoice 878
 867: oGetLocal 1
 869: oPushResult
 870: oCall 1418
 872: oPop 1
 874: oInput 5
 876: oJumpForward 881
 878: Choice Lookup Table
          70    867
 881: oJumpForward 920
 883: oGetAddrLocal 2
 885: oPushResult
 886: oCall 1854
 888: oAssign
 889: oInputChoice 902
 891: oGetLocal 2
 893: oPushResult
 894: oCall 1418
 896: oPop 1
 898: oInput 5
 900: oJumpForward 905
 902: Choice Lookup Table
          70    891
 905: oJumpForward 920
 907: Choice Lookup Table
          30    883
          29    859
          33    850
          32    846
          31    842
 918: oJumpForward 922
 920: oJumpBack 840
 922: oGetParam 1
 924: oPushResult
 925: oCall 71
 927: oPop 1
 929: oReturn
 930: oLocalSpace 0
 932: oSetResult 21
 934: oPushResult
 935: oCall 12161
 937: oPop 1
 939: oReturn
 940: oLocalSpace 5
 942: oGetAddrLocal 1
 944: oPushResult
 945: oLabelNew
 946: oAssign
 947: oEmit 77
 949: oGetLocal 1
 951: oPushResult
 952: oEmitLabel
 953: oPop 1
 955: oGetParam 2
 957: oPushResult
 958: oSetResult 11
 960: oPushResult
 961: oGetLocal 1
 963: oPushResult
 964: oNodeSetLabel
 965: oPop 3
 967: oEmit 67
 969: oGetAddrLocal 2
 971: oPushResult
 972: Here
 973: oAssign
 974: oEmit 90
 976: oGetAddrLocal 3
 978: oPushResult
 979: oGetParam 2
 981: oPushResult
 982: oSetResult 9
 984: oPushResult
 985: oNodeGet
 986: oPop 2
 988: oAssign
 989: oGetAddrLocal 4
 991: oPushResult
 992: oGetLocal 3
 994: oPushResult
 995: oSetResult 19
 997: oPushResult
 998: oNodeGetCode
 999: oPop 2
1001: oAssign
1002: oGetLocal 4
1004: oPushResult
1005: oEmitCode
1006: oPop 1
1008: oGetLocal 3
1010: oPushResult
1011: oSetResult 19
1013: oPushResult
1014: oSetResult 0
1016: oPushResult
1017: oNodeSetCode
1018: oPop 3
1020: oGetAddrLocal 3
1022: oPushResult
1023: oGetParam 2
1025: oPushResult
1026: oSetResult 10
1028: oPushResult
1029: oNodeGet
1030: oPop 2
1032: oAssign
1033: oGetAddrLocal 4
1035: oPushResult
1036: oGetLocal 3
1038: oPushResult
1039: oSetResult 19
1041: oPushResult
1042: oNodeGetCode
1043: oPop 2
1045: oAssign
1046: oGetLocal 4
1048: oPushResult
1049: oEmitCode
1050: oPop 1
1052: oGetLocal 3
1054: oPushResult
1055: oSetResult 19
1057: oPushResult
1058: oSetResult 0
1060: oPushResult
1061: oNodeSetCode
1062: oPop 3
1064: oGetParam 2
1066: oPushResult
1067: oSetResult 13
1069: oPushResult
1070: oNodeGet
1071: oPop 2
1073: oPushResult
1074: oScopeEnter
1075: oPop 1
1077: oGetParam 1
1079: oChoice 1098
1081: oCall 7624
1083: oInputChoice 1089
1085: oCall 7624
1087: oJumpForward 1094
1089: Choice Lookup Table
           5   1085
1092: oJumpForward 1096
1094: oJumpBack 1083
1096: oJumpForward 1101
1098: Choice Lookup Table
           1   1081
1101: oEmit 66
1103: oGetAddrLocal 5
1105: oPushResult
1106: oScopeCurrent
1107: oPushResult
1108: oSetResult 17
1110: oPushResult
1111: oNodeGetInt
1112: oPop 2
1114: oAssign
1115: oGetLocal 2
1117: oPushResult
1118: oGetLocal 5
1120: oPushResult
1121: oPatch
1122: oPop 2
1124: oScopeEnd
1125: oReturn
1126: oLocalSpace 3
1128: oGetAddrLocal 1
1130: oPushResult
1131: oLabelNew
1132: oAssign
1133: oEmit 77
1135: oGetLocal 1
1137: oPushResult
1138: oEmitLabel
1139: oPop 1
1141: oGetParam 2
1143: oPushResult
1144: oSetResult 12
1146: oPushResult
1147: oGetLocal 1
1149: oPushResult
1150: oNodeSetLabel
1151: oPop 3
1153: oEmit 67
1155: oGetAddrLocal 2
1157: oPushResult
1158: Here
1159: oAssign
1160: oEmit 90
1162: oSetResult 0
1164: oPushResult
1165: oSetResult 1
1167: oPushResult
1168: oScopeBegin
1169: oPop 2
1171: oGetParam 1
1173: oChoice 1192
1175: oCall 7624
1177: oInputChoice 1183
1179: oCall 7624
1181: oJumpForward 1188
1183: Choice Lookup Table
           5   1179
1186: oJumpForward 1190
1188: oJumpBack 1177
1190: oJumpForward 1195
1192: Choice Lookup Table
           1   1175
1195: oEmit 66
1197: oGetAddrLocal 3
1199: oPushResult
1200: oScopeCurrent
1201: oPushResult
1202: oSetResult 17
1204: oPushResult
1205: oNodeGetInt
1206: oPop 2
1208: oAssign
1209: oGetLocal 2
1211: oPushResult
1212: oGetLocal 3
1214: oPushResult
1215: oPatch
1216: oPop 2
1218: oScopeEnd
1219: oReturn
1220: oLocalSpace 2
1222: oGetAddrLocal 1
1224: oPushResult
1225: oGetGlobal 1
1227: oPushResult
1228: oSetResult 1
1230: oPushResult
1231: oNodeGetIter
1232: oPop 2
1234: oAssign
1235: oGetAddrLocal 2
1237: oPushResult
1238: oGetLocal 1
1240: oPushResult
1241: oNodeIterValue
1242: oPop 1
1244: oAssign
1245: oGetLocal 2
1247: oPushResult
1248: oNodeNull
1249: oPop 1
1251: oChoice 1296
1253: oJumpForward 1304
1255: oJumpForward 1302
1257: oEmit 61
1259: oSetResult 0
1261: oPushResult
1262: oEmitInt
1263: oPop 1
1265: oEmit 64
1267: oGetLocal 2
1269: oPushResult
1270: oSetResult 11
1272: oPushResult
1273: oNodeGetLabel
1274: oPop 2
1276: oPushResult
1277: oEmitLabel
1278: oPop 1
1280: oEmit 63
1282: oSetResult 0
1284: oPushResult
1285: oEmitInt
1286: oPop 1
1288: oGetAddrLocal 1
1290: oPushResult
1291: oNodeIterNext
1292: oPop 1
1294: oJumpForward 1302
1296: Choice Lookup Table
           0   1257
           1   1253
1301: oEndChoice
1302: oJumpBack 1235
1304: oReturn
1305: oLocalSpace 2
1307: oGetAddrLocal 1
1309: oPushResult
1310: oGetGlobal 1
1312: oPushResult
1313: oSetResult 1
1315: oPushResult
1316: oNodeGetIterLast
1317: oPop 2
1319: oAssign
1320: oGetAddrLocal 2
1322: oPushResult
1323: oGetLocal 1
1325: oPushResult
1326: oNodeIterValue
1327: oPop 1
1329: oAssign
1330: oGetLocal 2
1332: oPushResult
1333: oNodeNull
1334: oPop 1
1336: oChoice 1381
1338: oJumpForward 1389
1340: oJumpForward 1387
1342: oEmit 61
1344: oSetResult 0
1346: oPushResult
1347: oEmitInt
1348: oPop 1
1350: oEmit 64
1352: oGetLocal 2
1354: oPushResult
1355: oSetResult 12
1357: oPushResult
1358: oNodeGetLabel
1359: oPop 2
1361: oPushResult
1362: oEmitLabel
1363: oPop 1
1365: oEmit 63
1367: oSetResult 0
1369: oPushResult
1370: oEmitInt
1371: oPop 1
1373: oGetAddrLocal 1
1375: oPushResult
1376: oNodeIterPrev
1377: oPop 1
1379: oJumpForward 1387
1381: Choice Lookup Table
           0   1342
           1   1338
1386: oEndChoice
1387: oJumpBack 1320
1389: oReturn
1390: oLocalSpace 0
1392: oInputChoice 1410
1394: oGetParam 1
1396: oPushResult
1397: oSetResult 27
1399: oPushResult
1400: oSetResult 1
1402: oPushResult
1403: oNodeSetBoolean
1404: oPop 3
1406: oInput 5
1408: oJumpForward 1415
1410: Choice Lookup Table
          72   1394
1413: oJumpForward 1417
1415: oJumpBack 1392
1417: oReturn
1418: oLocalSpace 0
1420: oGetParam 1
1422: oPushResult
1423: oCall 12474
1425: oPop 1
1427: oPushResult
1428: equal_zero
1429: oPop 1
1431: oChoice 1437
1433: oError 23
1435: oJumpForward 1440
1437: Choice Lookup Table
           0   1433
1440: oGetParam 1
1442: oPushResult
1443: oSetResult 25
1445: oPushResult
1446: oSetResult 1
1448: oPushResult
1449: oNodeSetBoolean
1450: oPop 3
1452: oInputChoice 1476
1454: oInputChoice 1471
1456: oInput 2
1458: oGetParam 1
1460: oPushResult
1461: oSetResult 26
1463: oPushResult
1464: CURRENT_STRLIT
1465: oPushResult
1466: oNodeSetString
1467: oPop 3
1469: oJumpForward 1474
1471: Choice Lookup Table
          71   1456
1474: oJumpForward 1479
1476: Choice Lookup Table
           2   1454
1479: oReturn
1480: oLocalSpace 6
1482: oInput 0
1484: oGetAddrLocal 1
1486: oPushResult
1487: oSetResult 0
1489: oAssign
1490: oGetAddrLocal 2
1492: oPushResult
1493: oScopeFindInCurrentScope
1494: oAssign
1495: oGetLocal 2
1497: oPushResult
1498: oNodeNull
1499: oPop 1
1501: oChoice 1619
1503: oGetAddrLocal 2
1505: oPushResult
1506: oSetResult 12
1508: oPushResult
1509: LAST_ID
1510: oPushResult
1511: oCall 12512
1513: oPop 2
1515: oAssign
1516: oGetLocal 2
1518: oPushResult
1519: oSetResult 22
1521: oPushResult
1522: oLabelNew
1523: oPushResult
1524: oNodeSetLabel
1525: oPop 3
1527: oJumpForward 1625
1529: oGetAddrLocal 1
1531: oPushResult
1532: oSetResult 1
1534: oAssign
1535: oGetLocal 2
1537: oPushResult
1538: oSetResult 24
1540: oPushResult
1541: oNodeGetBoolean
1542: oPop 2
1544: oChoice 1550
1546: oError 21
1548: oJumpForward 1553
1550: Choice Lookup Table
           1   1546
1553: oGetLocal 2
1555: oPushResult
1556: oSetResult 25
1558: oPushResult
1559: oNodeGetBoolean
1560: oPop 2
1562: oChoice 1568
1564: oError 21
1566: oJumpForward 1571
1568: Choice Lookup Table
           1   1564
1571: oGetLocal 2
1573: oPushResult
1574: oNodeType
1575: oPop 1
1577: oChoice 1581
1579: oJumpForward 1586
1581: Choice Lookup Table
          12   1579
1584: oError 21
1586: oGetLocal 2
1588: oPushResult
1589: oSetResult 29
1591: oPushResult
1592: oGetLocal 2
1594: oPushResult
1595: oSetResult 23
1597: oPushResult
1598: oNodeGet
1599: oPop 2
1601: oPushResult
1602: oNodeSet
1603: oPop 3
1605: oGetLocal 2
1607: oPushResult
1608: oSetResult 23
1610: oPushResult
1611: oSetResult 0
1613: oPushResult
1614: oNodeSet
1615: oPop 3
1617: oJumpForward 1625
1619: Choice Lookup Table
           0   1529
           1   1503
1624: oEndChoice
1625: oGetAddrLocal 3
1627: oPushResult
1628: oCall 12462
1630: oAssign
1631: oGetAddrLocal 4
1633: oPushResult
1634: oGetLocal 3
1636: oPushResult
1637: oSetResult 0
1639: oPushResult
1640: greater
1641: oPop 2
1643: oAssign
1644: oGetAddrLocal 3
1646: oPushResult
1647: inc
1648: oPop 1
1650: oGetLocal 3
1652: oPushResult
1653: oSetResult 2
1655: oPushResult
1656: oScopeBegin
1657: oPop 2
1659: oGetAddrLocal 5
1661: oPushResult
1662: oScopeCurrent
1663: oAssign
1664: oGetLocal 4
1666: oChoice 1685
1668: oGetAddrLocal 6
1670: oPushResult
1671: oGetGlobal 6
1673: oPushResult
1674: oCall 11559
1676: oPop 1
1678: oPushResult
1679: oScopeAllocType
1680: oPop 1
1682: oAssign
1683: oJumpForward 1688
1685: Choice Lookup Table
           1   1668
1688: oCall 2289
1690: oGetLocal 2
1692: oPushResult
1693: oSetResult 23
1695: oPushResult
1696: oGetLocal 5
1698: oPushResult
1699: oNodeSet
1700: oPop 3
1702: oScopeEnd
1703: oInput 5
1705: oGetLocal 1
1707: oChoice 1719
1709: oGetLocal 2
1711: oPushResult
1712: oScopeDeclare
1713: oPop 1
1715: oJumpForward 1725
1717: oJumpForward 1725
1719: Choice Lookup Table
           1   1717
           0   1709
1724: oEndChoice
1725: oGetLocal 2
1727: oPushResult
1728: oCall 1390
1730: oPop 1
1732: oGetLocal 2
1734: oReturn
1735: oReturn
1736: oLocalSpace 4
1738: oGetAddrLocal 1
1740: oPushResult
1741: oCall 1480
1743: oAssign
1744: oInputChoice 1757
1746: oJumpForward 1851
1748: oGetLocal 1
1750: oPushResult
1751: oCall 1418
1753: oPop 1
1755: oJumpForward 1851
1757: Choice Lookup Table
          70   1748
          69   1746
1762: oGetAddrLocal 2
1764: oPushResult
1765: oGetLocal 1
1767: oPushResult
1768: oSetResult 23
1770: oPushResult
1771: oNodeGet
1772: oPop 2
1774: oAssign
1775: oGetLocal 2
1777: oPushResult
1778: oScopeEnter
1779: oPop 1
1781: oGetAddrLocal 3
1783: oPushResult
1784: oGetLocal 2
1786: oPushResult
1787: oSetResult 14
1789: oPushResult
1790: oNodeGetInt
1791: oPop 2
1793: oAssign
1794: oGetLocal 3
1796: oPushResult
1797: oSetResult 1
1799: oPushResult
1800: oScopeBegin
1801: oPop 2
1803: oGetLocal 1
1805: oPushResult
1806: oSetResult 6
1808: oPushResult
1809: oScopeCurrent
1810: oPushResult
1811: oNodeSet
1812: oPop 3
1814: oGetAddrLocal 4
1816: oPushResult
1817: oGetLocal 1
1819: oPushResult
1820: oSetResult 22
1822: oPushResult
1823: oNodeGetLabel
1824: oPop 2
1826: oAssign
1827: oSetResult 22
1829: oPushResult
1830: oGetLocal 4
1832: oPushResult
1833: oCall 12137
1835: oPop 2
1837: oGetLocal 1
1839: oPushResult
1840: oSetResult 24
1842: oPushResult
1843: oSetResult 1
1845: oPushResult
1846: oNodeSetBoolean
1847: oPop 3
1849: oScopeEnd
1850: oScopeEnd
1851: oInput 5
1853: oReturn
1854: oLocalSpace 8
1856: oInput 0
1858: oGetAddrLocal 1
1860: oPushResult
1861: oSetResult 0
1863: oAssign
1864: oGetAddrLocal 2
1866: oPushResult
1867: oScopeFindInCurrentScope
1868: oAssign
1869: oGetLocal 2
1871: oPushResult
1872: oNodeNull
1873: oPop 1
1875: oChoice 2006
1877: oGetAddrLocal 2
1879: oPushResult
1880: oSetResult 13
1882: oPushResult
1883: LAST_ID
1884: oPushResult
1885: oCall 12512
1887: oPop 2
1889: oAssign
1890: oGetLocal 2
1892: oPushResult
1893: oSetResult 22
1895: oPushResult
1896: oLabelNew
1897: oPushResult
1898: oNodeSetLabel
1899: oPop 3
1901: oJumpForward 2012
1903: oGetAddrLocal 1
1905: oPushResult
1906: oSetResult 1
1908: oAssign
1909: oGetLocal 2
1911: oPushResult
1912: oSetResult 24
1914: oPushResult
1915: oNodeGetBoolean
1916: oPop 2
1918: oChoice 1924
1920: oError 21
1922: oJumpForward 1927
1924: Choice Lookup Table
           1   1920
1927: oGetLocal 2
1929: oPushResult
1930: oNodeType
1931: oPop 1
1933: oChoice 1937
1935: oJumpForward 1942
1937: Choice Lookup Table
          13   1935
1940: oError 21
1942: oGetLocal 2
1944: oPushResult
1945: oSetResult 29
1947: oPushResult
1948: oGetLocal 2
1950: oPushResult
1951: oSetResult 23
1953: oPushResult
1954: oNodeGet
1955: oPop 2
1957: oPushResult
1958: oNodeSet
1959: oPop 3
1961: oGetLocal 2
1963: oPushResult
1964: oSetResult 23
1966: oPushResult
1967: oSetResult 0
1969: oPushResult
1970: oNodeSet
1971: oPop 3
1973: oGetLocal 2
1975: oPushResult
1976: oSetResult 30
1978: oPushResult
1979: oGetLocal 2
1981: oPushResult
1982: oSetResult 21
1984: oPushResult
1985: oNodeGet
1986: oPop 2
1988: oPushResult
1989: oNodeSet
1990: oPop 3
1992: oGetLocal 2
1994: oPushResult
1995: oSetResult 21
1997: oPushResult
1998: oSetResult 0
2000: oPushResult
2001: oNodeSet
2002: oPop 3
2004: oJumpForward 2012
2006: Choice Lookup Table
           0   1903
           1   1877
2011: oEndChoice
2012: oGetAddrLocal 3
2014: oPushResult
2015: oCall 12462
2017: oAssign
2018: oGetAddrLocal 4
2020: oPushResult
2021: oGetLocal 3
2023: oPushResult
2024: oSetResult 0
2026: oPushResult
2027: greater
2028: oPop 2
2030: oAssign
2031: oGetAddrLocal 3
2033: oPushResult
2034: inc
2035: oPop 1
2037: oGetLocal 3
2039: oPushResult
2040: oSetResult 2
2042: oPushResult
2043: oScopeBegin
2044: oPop 2
2046: oGetAddrLocal 5
2048: oPushResult
2049: oScopeCurrent
2050: oAssign
2051: oGetLocal 4
2053: oChoice 2072
2055: oGetAddrLocal 6
2057: oPushResult
2058: oGetGlobal 6
2060: oPushResult
2061: oCall 11559
2063: oPop 1
2065: oPushResult
2066: oScopeAllocType
2067: oPop 1
2069: oAssign
2070: oJumpForward 2075
2072: Choice Lookup Table
           1   2055
2075: oCall 2289
2077: oGetLocal 2
2079: oPushResult
2080: oSetResult 23
2082: oPushResult
2083: oGetLocal 5
2085: oPushResult
2086: oNodeSet
2087: oPop 3
2089: oInput 12
2091: oGetAddrLocal 7
2093: oPushResult
2094: oCall 10480
2096: oPop 1
2098: oGetLocal 2
2100: oPushResult
2101: oSetResult 21
2103: oPushResult
2104: oGetLocal 7
2106: oPushResult
2107: oNodeSet
2108: oPop 3
2110: oGetAddrLocal 8
2112: oPushResult
2113: oGetLocal 7
2115: oPushResult
2116: oCall 11559
2118: oPop 1
2120: oAssign
2121: oGetLocal 2
2123: oPushResult
2124: oSetResult 31
2126: oPushResult
2127: oGetLocal 8
2129: oPushResult
2130: oScopeAllocType
2131: oPop 1
2133: oPushResult
2134: oNodeSetInt
2135: oPop 3
2137: oScopeEnd
2138: oInput 5
2140: oGetLocal 1
2142: oChoice 2154
2144: oGetLocal 2
2146: oPushResult
2147: oScopeDeclare
2148: oPop 1
2150: oJumpForward 2160
2152: oJumpForward 2160
2154: Choice Lookup Table
           1   2152
           0   2144
2159: oEndChoice
2160: oGetLocal 2
2162: oPushResult
2163: oCall 1390
2165: oPop 1
2167: oGetLocal 2
2169: oReturn
2170: oReturn
2171: oLocalSpace 4
2173: oGetAddrLocal 1
2175: oPushResult
2176: oCall 1854
2178: oAssign
2179: oInputChoice 2192
2181: oJumpForward 2286
2183: oGetLocal 1
2185: oPushResult
2186: oCall 1418
2188: oPop 1
2190: oJumpForward 2286
2192: Choice Lookup Table
          70   2183
          69   2181
2197: oGetAddrLocal 2
2199: oPushResult
2200: oGetLocal 1
2202: oPushResult
2203: oSetResult 23
2205: oPushResult
2206: oNodeGet
2207: oPop 2
2209: oAssign
2210: oGetLocal 2
2212: oPushResult
2213: oScopeEnter
2214: oPop 1
2216: oGetAddrLocal 3
2218: oPushResult
2219: oGetLocal 2
2221: oPushResult
2222: oSetResult 14
2224: oPushResult
2225: oNodeGetInt
2226: oPop 2
2228: oAssign
2229: oGetLocal 3
2231: oPushResult
2232: oSetResult 1
2234: oPushResult
2235: oScopeBegin
2236: oPop 2
2238: oGetLocal 1
2240: oPushResult
2241: oSetResult 6
2243: oPushResult
2244: oScopeCurrent
2245: oPushResult
2246: oNodeSet
2247: oPop 3
2249: oGetAddrLocal 4
2251: oPushResult
2252: oGetLocal 1
2254: oPushResult
2255: oSetResult 22
2257: oPushResult
2258: oNodeGetLabel
2259: oPop 2
2261: oAssign
2262: oSetResult 22
2264: oPushResult
2265: oGetLocal 4
2267: oPushResult
2268: oCall 12137
2270: oPop 2
2272: oGetLocal 1
2274: oPushResult
2275: oSetResult 24
2277: oPushResult
2278: oSetResult 1
2280: oPushResult
2281: oNodeSetBoolean
2282: oPop 3
2284: oScopeEnd
2285: oScopeEnd
2286: oInput 5
2288: oReturn
2289: oLocalSpace 6
2291: oInputChoice 2509
2293: oGetAddrLocal 1
2295: oPushResult
2296: oNodeVecNew
2297: oAssign
2298: oGetAddrLocal 3
2300: oPushResult
2301: oSetResult 0
2303: oAssign
2304: oInputChoice 2314
2306: oGetAddrLocal 3
2308: oPushResult
2309: oSetResult 1
2311: oAssign
2312: oJumpForward 2317
2314: Choice Lookup Table
          33   2306
2317: oInput 0
2319: oGetAddrLocal 2
2321: oPushResult
2322: oSetResult 24
2324: oPushResult
2325: LAST_ID
2326: oPushResult
2327: oCall 12512
2329: oPop 2
2331: oAssign
2332: oGetLocal 2
2334: oPushResult
2335: oSetResult 34
2337: oPushResult
2338: oGetLocal 3
2340: oPushResult
2341: oNodeSetBoolean
2342: oPop 3
2344: oGetLocal 1
2346: oPushResult
2347: oGetLocal 2
2349: oPushResult
2350: oNodeVecAppend
2351: oPop 2
2353: oInputChoice 2361
2355: oJumpForward 2369
2357: oJumpForward 2367
2359: oJumpForward 2367
2361: Choice Lookup Table
          13   2359
          12   2355
2366: oEndChoice
2367: oJumpBack 2317
2369: oGetAddrLocal 4
2371: oPushResult
2372: oCall 10480
2374: oPop 1
2376: oGetLocal 3
2378: oChoice 2393
2380: oGetAddrLocal 5
2382: oPushResult
2383: oGetLocal 4
2385: oPushResult
2386: oCall 11559
2388: oPop 1
2390: oAssign
2391: oJumpForward 2402
2393: Choice Lookup Table
           1   2380
2396: oGetAddrLocal 5
2398: oPushResult
2399: oGetLocal 4
2401: oAssign
2402: oGetAddrLocal 6
2404: oPushResult
2405: oSetResult 0
2407: oAssign
2408: oGetLocal 6
2410: oPushResult
2411: oGetLocal 1
2413: oPushResult
2414: oNodeVecSize
2415: oPop 1
2417: oPushResult
2418: equal
2419: oPop 2
2421: oChoice 2478
2423: oGetAddrLocal 2
2425: oPushResult
2426: oGetLocal 1
2428: oPushResult
2429: oGetLocal 6
2431: oPushResult
2432: oNodeVecElement
2433: oPop 2
2435: oAssign
2436: oGetLocal 2
2438: oPushResult
2439: oSetResult 21
2441: oPushResult
2442: oGetLocal 4
2444: oPushResult
2445: oNodeSet
2446: oPop 3
2448: oGetLocal 2
2450: oPushResult
2451: oScopeDeclare
2452: oPop 1
2454: oGetLocal 2
2456: oPushResult
2457: oSetResult 22
2459: oPushResult
2460: oGetLocal 5
2462: oPushResult
2463: oScopeAllocType
2464: oPop 1
2466: oPushResult
2467: oNodeSetInt
2468: oPop 3
2470: oGetAddrLocal 6
2472: oPushResult
2473: inc
2474: oPop 1
2476: oJumpForward 2483
2478: Choice Lookup Table
           0   2423
2481: oJumpForward 2485
2483: oJumpBack 2408
2485: oGetLocal 1
2487: oPushResult
2488: oNodeVecDelete
2489: oPop 1
2491: oInputChoice 2499
2493: oJumpForward 2507
2495: oJumpForward 2505
2497: oJumpForward 2505
2499: Choice Lookup Table
           5   2497
          15   2493
2504: oEndChoice
2505: oJumpBack 2293
2507: oJumpForward 2512
2509: Choice Lookup Table
          14   2293
2512: oReturn
2513: oLocalSpace 0
2515: oInputChoice 2530
2517: oInputChoice 2523
2519: oCall 2647
2521: oJumpForward 2528
2523: Choice Lookup Table
          12   2519
2526: oCall 2538
2528: oJumpForward 2535
2530: Choice Lookup Table
           0   2517
2533: oJumpForward 2537
2535: oJumpBack 2515
2537: oReturn
2538: oLocalSpace 2
2540: oGetAddrLocal 1
2542: oPushResult
2543: LAST_ID
2544: oAssign
2545: oInput 6
2547: oCall 3526
2549: oTypeSNodeType
2550: oChoice 2606
2552: oGetAddrLocal 2
2554: oPushResult
2555: oSetResult 16
2557: oPushResult
2558: oGetLocal 1
2560: oPushResult
2561: oCall 12512
2563: oPop 2
2565: oAssign
2566: oGetLocal 2
2568: oPushResult
2569: oSetResult 22
2571: oPushResult
2572: oValueTop
2573: oPushResult
2574: oNodeSetInt
2575: oPop 3
2577: oJumpForward 2625
2579: oGetAddrLocal 2
2581: oPushResult
2582: oSetResult 18
2584: oPushResult
2585: oGetLocal 1
2587: oPushResult
2588: oCall 12512
2590: oPop 2
2592: oAssign
2593: oGetLocal 2
2595: oPushResult
2596: oSetResult 33
2598: oPushResult
2599: oValueTopString
2600: oPushResult
2601: oNodeSetString
2602: oPop 3
2604: oJumpForward 2625
2606: Choice Lookup Table
          39   2579
          35   2552
          34   2552
          41   2552
          29   2552
          33   2552
          30   2552
          31   2552
2623: oError 17
2625: oValuePop
2626: oGetLocal 2
2628: oPushResult
2629: oSetResult 21
2631: oPushResult
2632: oTypeSTop
2633: oPushResult
2634: oNodeSet
2635: oPop 3
2637: oTypeSPop
2638: oGetLocal 2
2640: oPushResult
2641: oScopeDeclare
2642: oPop 1
2644: oInput 5
2646: oReturn
2647: oLocalSpace 3
2649: oGetAddrLocal 1
2651: oPushResult
2652: oSetResult 25
2654: oPushResult
2655: LAST_ID
2656: oPushResult
2657: oCall 12512
2659: oPop 2
2661: oAssign
2662: oGetAddrLocal 2
2664: oPushResult
2665: oCall 10480
2667: oPop 1
2669: oGetLocal 1
2671: oPushResult
2672: oSetResult 21
2674: oPushResult
2675: oGetLocal 2
2677: oPushResult
2678: oNodeSet
2679: oPop 3
2681: oGetLocal 2
2683: oPushResult
2684: oNodeType
2685: oPop 1
2687: oChoice 2791
2689: oInput 6
2691: oGetLocal 2
2693: oPushResult
2694: oTypeSPush
2695: oPop 1
2697: oCall 3526
2699: oCall 4108
2701: oGetLocal 1
2703: oPushResult
2704: oSetResult 22
2706: oPushResult
2707: oValueTop
2708: oPushResult
2709: oNodeSetInt
2710: oPop 3
2712: oValuePop
2713: oTypeSPop
2714: oGetLocal 1
2716: oPushResult
2717: oScopeDeclare
2718: oPop 1
2720: oInput 5
2722: oJumpForward 2815
2724: oError 16
2726: oJumpForward 2815
2728: oGetGlobal 2
2730: oPushResult
2731: oScopeEnter
2732: oPop 1
2734: oGetAddrLocal 3
2736: oPushResult
2737: oGetLocal 2
2739: oPushResult
2740: oScopeAllocType
2741: oPop 1
2743: oAssign
2744: oScopeEnd
2745: oGetGlobal 2
2747: oPushResult
2748: oCall 12410
2750: oPop 1
2752: oPushResult
2753: oCodePush
2754: oPop 1
2756: oGetLocal 1
2758: oPushResult
2759: oSetResult 22
2761: oPushResult
2762: oGetLocal 3
2764: oPushResult
2765: oNodeSetInt
2766: oPop 3
2768: oInput 6
2770: oGetLocal 2
2772: oPushResult
2773: oGetLocal 3
2775: oPushResult
2776: oCall 2816
2778: oPop 2
2780: oCodePop
2781: oGetLocal 1
2783: oPushResult
2784: oScopeDeclare
2785: oPop 1
2787: oInput 5
2789: oJumpForward 2815
2791: Choice Lookup Table
          38   2728
          36   2728
          28   2724
          40   2724
          35   2689
          34   2689
          41   2689
          29   2689
          33   2689
          30   2689
          31   2689
2814: oEndChoice
2815: oReturn
2816: oLocalSpace 10
2818: oGetParam 2
2820: oPushResult
2821: oNodeType
2822: oPop 1
2824: oChoice 3146
2826: oGetAddrLocal 1
2828: oPushResult
2829: oGetParam 2
2831: oPushResult
2832: oSetResult 37
2834: oPushResult
2835: oNodeGet
2836: oPop 2
2838: oAssign
2839: oGetAddrLocal 2
2841: oPushResult
2842: oGetParam 2
2844: oPushResult
2845: oSetResult 38
2847: oPushResult
2848: oNodeGet
2849: oPop 2
2851: oAssign
2852: oGetAddrLocal 3
2854: oPushResult
2855: oGetLocal 2
2857: oPushResult
2858: oCall 11643
2860: oPop 1
2862: oAssign
2863: oGetAddrLocal 4
2865: oPushResult
2866: oGetLocal 2
2868: oPushResult
2869: oCall 11738
2871: oPop 1
2873: oAssign
2874: oGetAddrLocal 5
2876: oPushResult
2877: oGetLocal 1
2879: oPushResult
2880: oSetResult 17
2882: oPushResult
2883: oNodeGetInt
2884: oPop 2
2886: oAssign
2887: oInput 14
2889: oGetAddrLocal 6
2891: oPushResult
2892: oGetLocal 3
2894: oAssign
2895: oGetLocal 1
2897: oPushResult
2898: oGetParam 1
2900: oPushResult
2901: oCall 2816
2903: oPop 2
2905: oGetLocal 6
2907: oPushResult
2908: oGetLocal 4
2910: oPushResult
2911: equal
2912: oPop 2
2914: oChoice 2922
2916: oJumpForward 2951
2918: oJumpForward 2928
2920: oJumpForward 2928
2922: Choice Lookup Table
           0   2920
           1   2916
2927: oEndChoice
2928: oInput 13
2930: oGetAddrParam 1
2932: oPushResult
2933: oGetParam 1
2935: oPushResult
2936: oGetLocal 5
2938: oPushResult
2939: add
2940: oPop 2
2942: oAssign
2943: oGetAddrLocal 6
2945: oPushResult
2946: inc
2947: oPop 1
2949: oJumpBack 2895
2951: oInput 15
2953: oJumpForward 3170
2955: oInput 14
2957: oGetAddrLocal 7
2959: oPushResult
2960: oGetParam 2
2962: oPushResult
2963: oSetResult 41
2965: oPushResult
2966: oNodeGet
2967: oPop 2
2969: oAssign
2970: oInputChoice 2974
2972: oJumpForward 2979
2974: Choice Lookup Table
           0   2972
2977: oJumpForward 3045
2979: oGetAddrLocal 8
2981: oPushResult
2982: oGetLocal 7
2984: oPushResult
2985: oScopeFindRequireInScope
2986: oPop 1
2988: oAssign
2989: oInput 12
2991: oGetAddrLocal 9
2993: oPushResult
2994: oGetLocal 8
2996: oPushResult
2997: oSetResult 21
2999: oPushResult
3000: oNodeGet
3001: oPop 2
3003: oAssign
3004: oGetAddrLocal 10
3006: oPushResult
3007: oGetParam 1
3009: oPushResult
3010: oGetLocal 8
3012: oPushResult
3013: oSetResult 22
3015: oPushResult
3016: oNodeGetInt
3017: oPop 2
3019: oPushResult
3020: add
3021: oPop 2
3023: oAssign
3024: oGetLocal 9
3026: oPushResult
3027: oGetLocal 10
3029: oPushResult
3030: oCall 2816
3032: oPop 2
3034: oInputChoice 3038
3036: oJumpForward 3043
3038: Choice Lookup Table
           5   3036
3041: oJumpForward 3045
3043: oJumpBack 2970
3045: oInput 15
3047: oJumpForward 3170
3049: oEmit 16
3051: oGetParam 1
3053: oPushResult
3054: oEmitInt
3055: oPop 1
3057: oGetParam 2
3059: oPushResult
3060: oTypeSPush
3061: oPop 1
3063: oCall 3526
3065: oCall 4108
3067: oEmit 15
3069: oValueTop
3070: oPushResult
3071: oEmitInt
3072: oPop 1
3074: oValuePop
3075: oTypeSPop
3076: oEmit 27
3078: oJumpForward 3170
3080: oEmit 16
3082: oGetParam 1
3084: oPushResult
3085: oEmitInt
3086: oPop 1
3088: oGetParam 2
3090: oPushResult
3091: oTypeSPush
3092: oPop 1
3094: oCall 3526
3096: oCall 4108
3098: oEmit 15
3100: oValueTop
3101: oPushResult
3102: oEmitInt
3103: oPop 1
3105: oValuePop
3106: oTypeSPop
3107: oEmit 26
3109: oJumpForward 3170
3111: oEmit 16
3113: oGetParam 1
3115: oPushResult
3116: oEmitInt
3117: oPop 1
3119: oGetParam 2
3121: oPushResult
3122: oTypeSPush
3123: oPop 1
3125: oCall 3526
3127: oCall 4108
3129: oEmit 15
3131: oValueTop
3132: oPushResult
3133: oEmitInt
3134: oPop 1
3136: oValuePop
3137: oTypeSPop
3138: oEmit 28
3140: oJumpForward 3170
3142: oError 16
3144: oJumpForward 3170
3146: Choice Lookup Table
          28   3142
          40   3142
          35   3111
          34   3111
          41   3080
          29   3080
          33   3049
          30   3049
          31   3049
          38   2955
          36   2826
3169: oEndChoice
3170: oReturn
3171: oLocalSpace 2
3173: oInputChoice 3219
3175: oGetAddrLocal 1
3177: oPushResult
3178: oSetResult 19
3180: oPushResult
3181: LAST_ID
3182: oPushResult
3183: oCall 12512
3185: oPop 2
3187: oAssign
3188: oInput 6
3190: oGetAddrLocal 2
3192: oPushResult
3193: oCall 10480
3195: oPop 1
3197: oGetLocal 1
3199: oPushResult
3200: oSetResult 21
3202: oPushResult
3203: oGetLocal 2
3205: oPushResult
3206: oNodeSet
3207: oPop 3
3209: oGetLocal 1
3211: oPushResult
3212: oScopeDeclare
3213: oPop 1
3215: oInput 5
3217: oJumpForward 3224
3219: Choice Lookup Table
           0   3175
3222: oJumpForward 3226
3224: oJumpBack 3173
3226: oReturn
3227: oLocalSpace 6
3229: oInputChoice 3453
3231: oGetAddrLocal 1
3233: oPushResult
3234: oNodeVecNew
3235: oAssign
3236: oGetAddrLocal 2
3238: oPushResult
3239: oGetParam 1
3241: oPushResult
3242: LAST_ID
3243: oPushResult
3244: oCall 12512
3246: oPop 2
3248: oAssign
3249: oGetLocal 1
3251: oPushResult
3252: oGetLocal 2
3254: oPushResult
3255: oNodeVecAppend
3256: oPop 2
3258: oInputChoice 3264
3260: oInput 0
3262: oJumpForward 3269
3264: Choice Lookup Table
          13   3260
3267: oJumpForward 3271
3269: oJumpBack 3236
3271: oInput 12
3273: oGetAddrLocal 3
3275: oPushResult
3276: oCall 10480
3278: oPop 1
3280: oGetAddrLocal 4
3282: oPushResult
3283: oSetResult 0
3285: oAssign
3286: oGetLocal 4
3288: oPushResult
3289: oGetLocal 1
3291: oPushResult
3292: oNodeVecSize
3293: oPop 1
3295: oPushResult
3296: equal
3297: oPop 2
3299: oChoice 3340
3301: oGetAddrLocal 2
3303: oPushResult
3304: oGetLocal 1
3306: oPushResult
3307: oGetLocal 4
3309: oPushResult
3310: oNodeVecElement
3311: oPop 2
3313: oAssign
3314: oGetLocal 2
3316: oPushResult
3317: oSetResult 21
3319: oPushResult
3320: oGetLocal 3
3322: oPushResult
3323: oNodeSet
3324: oPop 3
3326: oGetLocal 2
3328: oPushResult
3329: oScopeDeclareAlloc
3330: oPop 1
3332: oGetAddrLocal 4
3334: oPushResult
3335: inc
3336: oPop 1
3338: oJumpForward 3345
3340: Choice Lookup Table
           0   3301
3343: oJumpForward 3347
3345: oJumpBack 3286
3347: oInputChoice 3440
3349: oGetLocal 1
3351: oPushResult
3352: oNodeVecSize
3353: oPop 1
3355: oChoice 3359
3357: oJumpForward 3364
3359: Choice Lookup Table
           1   3357
3362: oError 22
3364: oGetAddrLocal 5
3366: oPushResult
3367: oScopeCurrent
3368: oPushResult
3369: oCall 12410
3371: oPop 1
3373: oAssign
3374: oGetLocal 5
3376: oPushResult
3377: oCodePush
3378: oPop 1
3380: oGetAddrLocal 6
3382: oPushResult
3383: oSetResult 0
3385: oAssign
3386: oCall 12462
3388: oPushResult
3389: equal_zero
3390: oPop 1
3392: oChoice 3408
3394: oGetGlobal 3
3396: oPushResult
3397: oScopeEnter
3398: oPop 1
3400: oGetAddrLocal 6
3402: oPushResult
3403: oSetResult 1
3405: oAssign
3406: oJumpForward 3411
3408: Choice Lookup Table
           1   3394
3411: oGetLocal 2
3413: oPushResult
3414: oSetResult 1
3416: oPushResult
3417: oCall 8112
3419: oPop 2
3421: oCall 4181
3423: oCall 7294
3425: oCall 7868
3427: oGetLocal 6
3429: oChoice 3434
3431: oScopeEnd
3432: oJumpForward 3437
3434: Choice Lookup Table
           1   3431
3437: oCodePop
3438: oJumpForward 3443
3440: Choice Lookup Table
           6   3349
3443: oGetLocal 1
3445: oPushResult
3446: oNodeVecDelete
3447: oPop 1
3449: oInput 5
3451: oJumpForward 3458
3453: Choice Lookup Table
           0   3231
3456: oJumpForward 3460
3458: oJumpBack 3229
3460: oReturn
3461: oLocalSpace 2
3463: oInputChoice 3470
3465: oJumpForward 3476
3467: oChangeIntLitToLabelIdent
3468: oJumpForward 3476
3470: Choice Lookup Table
           1   3467
           0   3465
3475: oEndChoice
3476: oGetAddrLocal 1
3478: oPushResult
3479: oSetResult 26
3481: oPushResult
3482: LAST_ID
3483: oPushResult
3484: oCall 12512
3486: oPop 2
3488: oAssign
3489: oGetAddrLocal 2
3491: oPushResult
3492: oLabelNew
3493: oAssign
3494: oGetLocal 1
3496: oPushResult
3497: oSetResult 22
3499: oPushResult
3500: oGetLocal 2
3502: oPushResult
3503: oNodeSetLabel
3504: oPop 3
3506: oGetLocal 1
3508: oPushResult
3509: oScopeDeclare
3510: oPop 1
3512: oInputChoice 3516
3514: oJumpForward 3521
3516: Choice Lookup Table
          13   3514
3519: oJumpForward 3523
3521: oJumpBack 3463
3523: oInput 5
3525: oReturn
3526: oLocalSpace 0
3528: oCall 3634
3530: oInputChoice 3616
3532: oCall 3657
3534: oCall 4011
3536: oTypeSPop
3537: oGetGlobal 7
3539: oPushResult
3540: oTypeSPush
3541: oPop 1
3543: oValueEqual
3544: oJumpForward 3631
3546: oCall 3634
3548: oCall 4011
3550: oTypeSPop
3551: oGetGlobal 7
3553: oPushResult
3554: oTypeSPush
3555: oPop 1
3557: oValueNotEqual
3558: oJumpForward 3631
3560: oCall 3634
3562: oCall 4011
3564: oTypeSPop
3565: oGetGlobal 7
3567: oPushResult
3568: oTypeSPush
3569: oPop 1
3571: oValueLess
3572: oJumpForward 3631
3574: oCall 3634
3576: oCall 4011
3578: oTypeSPop
3579: oGetGlobal 7
3581: oPushResult
3582: oTypeSPush
3583: oPop 1
3585: oValueGreater
3586: oJumpForward 3631
3588: oCall 3634
3590: oCall 4011
3592: oTypeSPop
3593: oGetGlobal 7
3595: oPushResult
3596: oTypeSPush
3597: oPop 1
3599: oValueLessEqual
3600: oJumpForward 3631
3602: oCall 3634
3604: oCall 4011
3606: oTypeSPop
3607: oGetGlobal 7
3609: oPushResult
3610: oTypeSPush
3611: oPop 1
3613: oValueGreaterEqual
3614: oJumpForward 3631
3616: Choice Lookup Table
          11   3602
          10   3588
           9   3574
           8   3560
           7   3546
           6   3532
3629: oJumpForward 3633
3631: oJumpBack 3530
3633: oReturn
3634: oLocalSpace 0
3636: oCall 3657
3638: oInputChoice 3649
3640: oCall 3998
3642: oCall 3657
3644: oCall 3984
3646: oValueOr
3647: oJumpForward 3654
3649: Choice Lookup Table
          57   3640
3652: oJumpForward 3656
3654: oJumpBack 3638
3656: oReturn
3657: oLocalSpace 0
3659: oCall 3680
3661: oInputChoice 3672
3663: oCall 3998
3665: oCall 3680
3667: oCall 3984
3669: oValueAnd
3670: oJumpForward 3677
3672: Choice Lookup Table
          56   3663
3675: oJumpForward 3679
3677: oJumpBack 3661
3679: oReturn
3680: oLocalSpace 0
3682: oInputChoice 3691
3684: oCall 3680
3686: oCall 3998
3688: oValueNot
3689: oJumpForward 3696
3691: Choice Lookup Table
          58   3684
3694: oCall 3697
3696: oReturn
3697: oLocalSpace 0
3699: oCall 3727
3701: oInputChoice 3717
3703: oCall 3727
3705: oCall 4011
3707: oValueAdd
3708: oJumpForward 3724
3710: oCall 3727
3712: oCall 4011
3714: oValueSub
3715: oJumpForward 3724
3717: Choice Lookup Table
          25   3710
          24   3703
3722: oJumpForward 3726
3724: oJumpBack 3701
3726: oReturn
3727: oLocalSpace 0
3729: oCall 3757
3731: oInputChoice 3747
3733: oCall 3757
3735: oCall 4011
3737: oValueMult
3738: oJumpForward 3754
3740: oCall 3757
3742: oCall 4011
3744: oValueDiv
3745: oJumpForward 3754
3747: Choice Lookup Table
          23   3740
          22   3733
3752: oJumpForward 3756
3754: oJumpBack 3731
3756: oReturn
3757: oLocalSpace 0
3759: oInputChoice 3770
3761: oCall 3778
3763: oJumpForward 3777
3765: oCall 3778
3767: oValueNegate
3768: oJumpForward 3777
3770: Choice Lookup Table
          25   3765
          24   3761
3775: oCall 3778
3777: oReturn
3778: oLocalSpace 1
3780: oInputChoice 3951
3782: TOKEN_VALUE
3783: oPushResult
3784: oValuePush
3785: oPop 1
3787: oGetGlobal 6
3789: oPushResult
3790: oTypeSPush
3791: oPop 1
3793: oJumpForward 3978
3795: TOKEN_VALUE
3796: oPushResult
3797: oValuePush
3798: oPop 1
3800: oGetGlobal 9
3802: oPushResult
3803: oTypeSPush
3804: oPop 1
3806: oJumpForward 3978
3808: CURRENT_STRLIT
3809: oPushResult
3810: oValuePushString
3811: oPop 1
3813: oGetGlobal 13
3815: oPushResult
3816: oTypeSPush
3817: oPop 1
3819: oJumpForward 3978
3821: oCall 3526
3823: oInput 15
3825: oJumpForward 3978
3827: oGetAddrLocal 1
3829: oPushResult
3830: oScopeFindRequire
3831: oAssign
3832: oGetAddrLocal 1
3834: oPushResult
3835: oCall 244
3837: oPop 1
3839: oGetLocal 1
3841: oPushResult
3842: oNodeType
3843: oPop 1
3845: oChoice 3912
3847: oGetLocal 1
3849: oPushResult
3850: oCall 3979
3852: oPop 1
3854: oJumpForward 3933
3856: oGetLocal 1
3858: oPushResult
3859: oSetResult 22
3861: oPushResult
3862: oNodeGetInt
3863: oPop 2
3865: oPushResult
3866: oValuePush
3867: oPop 1
3869: oGetLocal 1
3871: oPushResult
3872: oSetResult 21
3874: oPushResult
3875: oNodeGet
3876: oPop 2
3878: oPushResult
3879: oTypeSPush
3880: oPop 1
3882: oJumpForward 3933
3884: oGetLocal 1
3886: oPushResult
3887: oSetResult 22
3889: oPushResult
3890: oNodeGetInt
3891: oPop 2
3893: oPushResult
3894: oValuePush
3895: oPop 1
3897: oGetLocal 1
3899: oPushResult
3900: oSetResult 21
3902: oPushResult
3903: oNodeGet
3904: oPop 2
3906: oPushResult
3907: oTypeSPush
3908: oPop 1
3910: oJumpForward 3933
3912: Choice Lookup Table
          17   3884
          16   3856
          14   3847
3919: oError 1
3921: oSetResult 0
3923: oPushResult
3924: oValuePush
3925: oPop 1
3927: oGetGlobal 6
3929: oPushResult
3930: oTypeSPush
3931: oPop 1
3933: oJumpForward 3978
3935: oError 16
3937: oSetResult 0
3939: oPushResult
3940: oValuePush
3941: oPop 1
3943: oGetGlobal 12
3945: oPushResult
3946: oTypeSPush
3947: oPop 1
3949: oJumpForward 3978
3951: Choice Lookup Table
          19   3935
           0   3827
          14   3821
           2   3808
           3   3795
           1   3782
3964: oError 1
3966: oSetResult 0
3968: oPushResult
3969: oValuePush
3970: oPop 1
3972: oGetGlobal 6
3974: oPushResult
3975: oTypeSPush
3976: oPop 1
3978: oReturn
3979: oLocalSpace 0
3981: oError 16
3983: oReturn
3984: oLocalSpace 0
3986: oTypeSNodeType
3987: oChoice 3991
3989: oJumpForward 3996
3991: Choice Lookup Table
          31   3989
3994: oError 8
3996: oTypeSPop
3997: oReturn
3998: oLocalSpace 0
4000: oTypeSNodeType
4001: oChoice 4005
4003: oJumpForward 4010
4005: Choice Lookup Table
          31   4003
4008: oError 8
4010: oReturn
4011: oLocalSpace 1
4013: oGetAddrLocal 1
4015: oPushResult
4016: oTypeSNodeType
4017: oAssign
4018: oTypeSPop
4019: oGetLocal 1
4021: oPushResult
4022: oTypeSNodeType
4023: oPushResult
4024: equal_node_type
4025: oPop 2
4027: oChoice 4104
4029: oTypeSNodeType
4030: oChoice 4091
4032: oGetLocal 1
4034: oChoice 4039
4036: oReturn
4037: oJumpForward 4042
4039: Choice Lookup Table
          35   4036
4042: oJumpForward 4100
4044: oGetLocal 1
4046: oChoice 4051
4048: oReturn
4049: oJumpForward 4054
4051: Choice Lookup Table
          34   4048
4054: oJumpForward 4100
4056: oGetLocal 1
4058: oChoice 4064
4060: oValueCharToString
4061: oReturn
4062: oJumpForward 4067
4064: Choice Lookup Table
          33   4060
4067: oJumpForward 4100
4069: oGetLocal 1
4071: oChoice 4086
4073: oValueSwap
4074: oValueCharToString
4075: oValueSwap
4076: oTypeSPop
4077: oGetGlobal 13
4079: oPushResult
4080: oTypeSPush
4081: oPop 1
4083: oReturn
4084: oJumpForward 4089
4086: Choice Lookup Table
          39   4073
4089: oJumpForward 4100
4091: Choice Lookup Table
          33   4069
          39   4056
          35   4044
          34   4032
4100: oError 14
4102: oJumpForward 4107
4104: Choice Lookup Table
           0   4029
4107: oReturn
4108: oLocalSpace 1
4110: oGetAddrLocal 1
4112: oPushResult
4113: oTypeSNodeType
4114: oAssign
4115: oTypeSPop
4116: oGetLocal 1
4118: oPushResult
4119: oTypeSNodeType
4120: oPushResult
4121: equal_node_type
4122: oPop 2
4124: oChoice 4177
4126: oTypeSNodeType
4127: oChoice 4166
4129: oGetLocal 1
4131: oChoice 4136
4133: oReturn
4134: oJumpForward 4139
4136: Choice Lookup Table
          35   4133
4139: oJumpForward 4173
4141: oGetLocal 1
4143: oChoice 4148
4145: oReturn
4146: oJumpForward 4151
4148: Choice Lookup Table
          34   4145
4151: oJumpForward 4173
4153: oGetLocal 1
4155: oChoice 4161
4157: oValueCharToString
4158: oReturn
4159: oJumpForward 4164
4161: Choice Lookup Table
          33   4157
4164: oJumpForward 4173
4166: Choice Lookup Table
          39   4153
          35   4141
          34   4129
4173: oError 14
4175: oJumpForward 4180
4177: Choice Lookup Table
           0   4126
4180: oReturn
4181: oLocalSpace 1
4183: oGetAddrLocal 1
4185: oPushResult
4186: oSetResult 0
4188: oAssign
4189: oGetAddrLocal 1
4191: oPushResult
4192: oCall 4342
4194: oPop 1
4196: oGetAddrLocal 1
4198: oPushResult
4199: oCall 4242
4201: oPop 1
4203: oReturn
4204: oLocalSpace 0
4206: oGetParam 1
4208: oPushResult
4209: oCall 4342
4211: oPop 1
4213: oTypeSNodeType
4214: oChoice 4233
4216: oJumpForward 4240
4218: oGetParam 1
4220: oPushResult
4221: oLabelNew
4222: oAssign
4223: oEmit 70
4225: oGetFromParam 1
4227: oPushResult
4228: oEmitLabel
4229: oPop 1
4231: oJumpForward 4240
4233: Choice Lookup Table
          31   4218
          32   4216
4238: oError 8
4240: oTypeSPop
4241: oReturn
4242: oLocalSpace 1
4244: oTypeSNodeType
4245: oChoice 4307
4247: oGetAddrLocal 1
4249: oPushResult
4250: oLabelNew
4251: oAssign
4252: oEmit 15
4254: oSetResult 1
4256: oPushResult
4257: oEmitInt
4258: oPop 1
4260: oEmit 68
4262: oGetLocal 1
4264: oPushResult
4265: oEmitLabel
4266: oPop 1
4268: oEmit 77
4270: oGetFromParam 1
4272: oPushResult
4273: oEmitLabel
4274: oPop 1
4276: oEmit 15
4278: oSetResult 0
4280: oPushResult
4281: oEmitInt
4282: oPop 1
4284: oEmit 77
4286: oGetLocal 1
4288: oPushResult
4289: oEmitLabel
4290: oPop 1
4292: oTypeSPop
4293: oGetGlobal 7
4295: oPushResult
4296: oTypeSPush
4297: oPop 1
4299: oGetParam 1
4301: oPushResult
4302: oSetResult 0
4304: oAssign
4305: oJumpForward 4310
4307: Choice Lookup Table
          32   4247
4310: oReturn
4311: oLocalSpace 0
4313: oTypeSNodeType
4314: oChoice 4338
4316: oGetParam 1
4318: oPushResult
4319: oLabelNew
4320: oAssign
4321: oEmit 70
4323: oGetFromParam 1
4325: oPushResult
4326: oEmitLabel
4327: oPop 1
4329: oTypeSPop
4330: oGetGlobal 8
4332: oPushResult
4333: oTypeSPush
4334: oPop 1
4336: oJumpForward 4341
4338: Choice Lookup Table
          31   4316
4341: oReturn
4342: oLocalSpace 0
4344: oGetParam 1
4346: oPushResult
4347: oCall 4875
4349: oPop 1
4351: oInputChoice 4857
4353: oGetParam 1
4355: oPushResult
4356: oCall 4242
4358: oPop 1
4360: oCall 7577
4362: oGetParam 1
4364: oPushResult
4365: oCall 4875
4367: oPop 1
4369: oGetParam 1
4371: oPushResult
4372: oCall 4242
4374: oPop 1
4376: oCall 7577
4378: oCall 7446
4380: oTypeSNodeType
4381: oChoice 4409
4383: oEmit 43
4385: oJumpForward 4428
4387: oEmit 49
4389: oJumpForward 4428
4391: oEmit 55
4393: oJumpForward 4428
4395: oCall 9441
4397: oEmit 15
4399: oSetResult 0
4401: oPushResult
4402: oEmitInt
4403: oPop 1
4405: oEmit 49
4407: oJumpForward 4428
4409: Choice Lookup Table
          39   4395
          40   4395
          35   4391
          34   4391
          41   4387
          29   4387
          33   4383
          31   4383
4426: oError 17
4428: oTypeSPop
4429: oGetGlobal 7
4431: oPushResult
4432: oTypeSPush
4433: oPop 1
4435: oJumpForward 4872
4437: oGetParam 1
4439: oPushResult
4440: oCall 4242
4442: oPop 1
4444: oCall 7577
4446: oGetParam 1
4448: oPushResult
4449: oCall 4875
4451: oPop 1
4453: oGetParam 1
4455: oPushResult
4456: oCall 4242
4458: oPop 1
4460: oCall 7577
4462: oCall 7446
4464: oTypeSNodeType
4465: oChoice 4493
4467: oEmit 44
4469: oJumpForward 4512
4471: oEmit 50
4473: oJumpForward 4512
4475: oEmit 56
4477: oJumpForward 4512
4479: oCall 9441
4481: oEmit 15
4483: oSetResult 0
4485: oPushResult
4486: oEmitInt
4487: oPop 1
4489: oEmit 50
4491: oJumpForward 4512
4493: Choice Lookup Table
          39   4479
          40   4479
          35   4475
          34   4475
          41   4471
          29   4471
          33   4467
          31   4467
4510: oError 17
4512: oTypeSPop
4513: oGetGlobal 7
4515: oPushResult
4516: oTypeSPush
4517: oPop 1
4519: oJumpForward 4872
4521: oGetParam 1
4523: oPushResult
4524: oCall 4242
4526: oPop 1
4528: oCall 7577
4530: oGetParam 1
4532: oPushResult
4533: oCall 4875
4535: oPop 1
4537: oGetParam 1
4539: oPushResult
4540: oCall 4242
4542: oPop 1
4544: oCall 7577
4546: oCall 7446
4548: oTypeSNodeType
4549: oChoice 4577
4551: oEmit 46
4553: oJumpForward 4596
4555: oEmit 52
4557: oJumpForward 4596
4559: oEmit 58
4561: oJumpForward 4596
4563: oCall 9441
4565: oEmit 15
4567: oSetResult 0
4569: oPushResult
4570: oEmitInt
4571: oPop 1
4573: oEmit 52
4575: oJumpForward 4596
4577: Choice Lookup Table
          39   4563
          40   4563
          35   4559
          34   4559
          41   4555
          29   4555
          33   4551
          31   4551
4594: oError 17
4596: oTypeSPop
4597: oGetGlobal 7
4599: oPushResult
4600: oTypeSPush
4601: oPop 1
4603: oJumpForward 4872
4605: oGetParam 1
4607: oPushResult
4608: oCall 4242
4610: oPop 1
4612: oCall 7577
4614: oGetParam 1
4616: oPushResult
4617: oCall 4875
4619: oPop 1
4621: oGetParam 1
4623: oPushResult
4624: oCall 4242
4626: oPop 1
4628: oCall 7577
4630: oCall 7446
4632: oTypeSNodeType
4633: oChoice 4661
4635: oEmit 45
4637: oJumpForward 4680
4639: oEmit 51
4641: oJumpForward 4680
4643: oEmit 57
4645: oJumpForward 4680
4647: oCall 9441
4649: oEmit 15
4651: oSetResult 0
4653: oPushResult
4654: oEmitInt
4655: oPop 1
4657: oEmit 51
4659: oJumpForward 4680
4661: Choice Lookup Table
          39   4647
          40   4647
          35   4643
          34   4643
          41   4639
          29   4639
          33   4635
          31   4635
4678: oError 17
4680: oTypeSPop
4681: oGetGlobal 7
4683: oPushResult
4684: oTypeSPush
4685: oPop 1
4687: oJumpForward 4872
4689: oGetParam 1
4691: oPushResult
4692: oCall 4242
4694: oPop 1
4696: oCall 7577
4698: oGetParam 1
4700: oPushResult
4701: oCall 4875
4703: oPop 1
4705: oGetParam 1
4707: oPushResult
4708: oCall 4242
4710: oPop 1
4712: oCall 7577
4714: oCall 7446
4716: oTypeSNodeType
4717: oChoice 4745
4719: oEmit 48
4721: oJumpForward 4764
4723: oEmit 54
4725: oJumpForward 4764
4727: oEmit 60
4729: oJumpForward 4764
4731: oCall 9441
4733: oEmit 15
4735: oSetResult 0
4737: oPushResult
4738: oEmitInt
4739: oPop 1
4741: oEmit 54
4743: oJumpForward 4764
4745: Choice Lookup Table
          39   4731
          40   4731
          35   4727
          34   4727
          41   4723
          29   4723
          33   4719
          31   4719
4762: oError 17
4764: oTypeSPop
4765: oGetGlobal 7
4767: oPushResult
4768: oTypeSPush
4769: oPop 1
4771: oJumpForward 4872
4773: oGetParam 1
4775: oPushResult
4776: oCall 4242
4778: oPop 1
4780: oCall 7577
4782: oGetParam 1
4784: oPushResult
4785: oCall 4875
4787: oPop 1
4789: oGetParam 1
4791: oPushResult
4792: oCall 4242
4794: oPop 1
4796: oCall 7577
4798: oCall 7446
4800: oTypeSNodeType
4801: oChoice 4829
4803: oEmit 47
4805: oJumpForward 4848
4807: oEmit 53
4809: oJumpForward 4848
4811: oEmit 59
4813: oJumpForward 4848
4815: oCall 9441
4817: oEmit 15
4819: oSetResult 0
4821: oPushResult
4822: oEmitInt
4823: oPop 1
4825: oEmit 53
4827: oJumpForward 4848
4829: Choice Lookup Table
          39   4815
          40   4815
          35   4811
          34   4811
          41   4807
          29   4807
          33   4803
          31   4803
4846: oError 17
4848: oTypeSPop
4849: oGetGlobal 7
4851: oPushResult
4852: oTypeSPush
4853: oPop 1
4855: oJumpForward 4872
4857: Choice Lookup Table
          11   4773
          10   4689
           9   4605
           8   4521
           7   4437
           6   4353
4870: oJumpForward 4874
4872: oJumpBack 4351
4874: oReturn
4875: oLocalSpace 1
4877: oGetAddrLocal 1
4879: oPushResult
4880: oSetResult 0
4882: oAssign
4883: oGetParam 1
4885: oPushResult
4886: oCall 5055
4888: oPop 1
4890: oInputChoice 5023
4892: oTypeSNodeType
4893: oChoice 4964
4895: oGetLocal 1
4897: oPushResult
4898: oSetResult 0
4900: oPushResult
4901: equal_label
4902: oPop 2
4904: oChoice 4913
4906: oGetAddrLocal 1
4908: oPushResult
4909: oLabelNew
4910: oAssign
4911: oJumpForward 4916
4913: Choice Lookup Table
           1   4906
4916: oEmit 68
4918: oGetLocal 1
4920: oPushResult
4921: oEmitLabel
4922: oPop 1
4924: oJumpForward 4971
4926: oGetParam 1
4928: oPushResult
4929: oCall 4311
4931: oPop 1
4933: oGetLocal 1
4935: oPushResult
4936: oSetResult 0
4938: oPushResult
4939: equal_label
4940: oPop 2
4942: oChoice 4951
4944: oGetAddrLocal 1
4946: oPushResult
4947: oLabelNew
4948: oAssign
4949: oJumpForward 4954
4951: Choice Lookup Table
           1   4944
4954: oEmit 68
4956: oGetLocal 1
4958: oPushResult
4959: oEmitLabel
4960: oPop 1
4962: oJumpForward 4971
4964: Choice Lookup Table
          31   4926
          32   4895
4969: oError 8
4971: oTypeSPop
4972: oEmit 77
4974: oGetFromParam 1
4976: oPushResult
4977: oEmitLabel
4978: oPop 1
4980: oGetParam 1
4982: oPushResult
4983: oSetResult 0
4985: oAssign
4986: oGetParam 1
4988: oPushResult
4989: oCall 5055
4991: oPop 1
4993: oTypeSNodeType
4994: oChoice 5007
4996: oJumpForward 5014
4998: oGetParam 1
5000: oPushResult
5001: oCall 4311
5003: oPop 1
5005: oJumpForward 5014
5007: Choice Lookup Table
          31   4998
          32   4996
5012: oError 8
5014: oTypeSPop
5015: oGetGlobal 8
5017: oPushResult
5018: oTypeSPush
5019: oPop 1
5021: oJumpForward 5028
5023: Choice Lookup Table
          57   4892
5026: oJumpForward 5030
5028: oJumpBack 4890
5030: oGetLocal 1
5032: oPushResult
5033: oSetResult 0
5035: oPushResult
5036: equal_label
5037: oPop 2
5039: oChoice 5051
5041: oEmit 77
5043: oGetLocal 1
5045: oPushResult
5046: oEmitLabel
5047: oPop 1
5049: oJumpForward 5054
5051: Choice Lookup Table
           0   5041
5054: oReturn
5055: oLocalSpace 2
5057: oGetAddrLocal 1
5059: oPushResult
5060: oSetResult 0
5062: oAssign
5063: oGetParam 1
5065: oPushResult
5066: oCall 5193
5068: oPop 1
5070: oInputChoice 5185
5072: oTypeSNodeType
5073: oChoice 5086
5075: oJumpForward 5093
5077: oGetParam 1
5079: oPushResult
5080: oCall 4311
5082: oPop 1
5084: oJumpForward 5093
5086: Choice Lookup Table
          31   5077
          32   5075
5091: oError 8
5093: oTypeSPop
5094: oGetLocal 1
5096: oPushResult
5097: oSetResult 0
5099: oPushResult
5100: equal_label
5101: oPop 2
5103: oChoice 5132
5105: oGetAddrLocal 1
5107: oPushResult
5108: oLabelNew
5109: oAssign
5110: oEmit 78
5112: oGetFromParam 1
5114: oPushResult
5115: oEmitLabel
5116: oPop 1
5118: oGetLocal 1
5120: oPushResult
5121: oEmitLabel
5122: oPop 1
5124: oGetParam 1
5126: oPushResult
5127: oGetLocal 1
5129: oAssign
5130: oJumpForward 5135
5132: Choice Lookup Table
           1   5105
5135: oGetAddrLocal 2
5137: oPushResult
5138: oSetResult 0
5140: oAssign
5141: oGetAddrLocal 2
5143: oPushResult
5144: oCall 5193
5146: oPop 1
5148: oTypeSNodeType
5149: oChoice 5162
5151: oJumpForward 5169
5153: oGetAddrLocal 2
5155: oPushResult
5156: oCall 4311
5158: oPop 1
5160: oJumpForward 5169
5162: Choice Lookup Table
          31   5153
          32   5151
5167: oError 8
5169: oEmit 78
5171: oGetLocal 2
5173: oPushResult
5174: oEmitLabel
5175: oPop 1
5177: oGetLocal 1
5179: oPushResult
5180: oEmitLabel
5181: oPop 1
5183: oJumpForward 5190
5185: Choice Lookup Table
          56   5072
5188: oJumpForward 5192
5190: oJumpBack 5070
5192: oReturn
5193: oLocalSpace 1
5195: oInputChoice 5249
5197: oGetAddrLocal 1
5199: oPushResult
5200: oSetResult 0
5202: oAssign
5203: oGetAddrLocal 1
5205: oPushResult
5206: oCall 5193
5208: oPop 1
5210: oTypeSNodeType
5211: oChoice 5240
5213: oGetParam 1
5215: oPushResult
5216: oLabelNew
5217: oAssign
5218: oEmit 68
5220: oGetFromParam 1
5222: oPushResult
5223: oEmitLabel
5224: oPop 1
5226: oEmit 77
5228: oGetLocal 1
5230: oPushResult
5231: oEmitLabel
5232: oPop 1
5234: oJumpForward 5247
5236: oEmit 42
5238: oJumpForward 5247
5240: Choice Lookup Table
          31   5236
          32   5213
5245: oError 8
5247: oJumpForward 5259
5249: Choice Lookup Table
          58   5197
5252: oGetParam 1
5254: oPushResult
5255: oCall 5260
5257: oPop 1
5259: oReturn
5260: oLocalSpace 2
5262: oGetAddrLocal 1
5264: oPushResult
5265: oSetResult 1
5267: oAssign
5268: oGetParam 1
5270: oPushResult
5271: oCall 5496
5273: oPop 1
5275: oInputChoice 5486
5277: oTypeSNodeType
5278: oChoice 5401
5280: oCall 7531
5282: oGetParam 1
5284: oPushResult
5285: oCall 5496
5287: oPop 1
5289: oTypeSNodeType
5290: oChoice 5298
5292: oEmit 22
5294: oCall 7079
5296: oJumpForward 5307
5298: Choice Lookup Table
          35   5292
          34   5292
5303: oCall 7551
5305: oEmit 37
5307: oJumpForward 5418
5309: oGetLocal 1
5311: oChoice 5327
5313: oGetAddrLocal 2
5315: oPushResult
5316: oCall 9224
5318: oAssign
5319: oGetAddrLocal 1
5321: oPushResult
5322: oSetResult 0
5324: oAssign
5325: oJumpForward 5330
5327: Choice Lookup Table
           1   5313
5330: oGetParam 1
5332: oPushResult
5333: oCall 5496
5335: oPop 1
5337: oTypeSNodeType
5338: oChoice 5376
5340: oCall 9333
5342: oEmit 17
5344: oGetLocal 2
5346: oPushResult
5347: oEmitInt
5348: oPop 1
5350: oGetGlobal 14
5352: oPushResult
5353: oTypeSPush
5354: oPop 1
5356: oJumpForward 5386
5358: oCall 9387
5360: oEmit 17
5362: oGetLocal 2
5364: oPushResult
5365: oEmitInt
5366: oPop 1
5368: oGetGlobal 14
5370: oPushResult
5371: oTypeSPush
5372: oPop 1
5374: oJumpForward 5386
5376: Choice Lookup Table
          33   5358
          39   5340
          40   5340
5383: oError 14
5385: oTypeSPop
5386: oJumpForward 5418
5388: oGetParam 1
5390: oPushResult
5391: oCall 5496
5393: oPop 1
5395: oCall 7531
5397: oCall 7079
5399: oJumpForward 5418
5401: Choice Lookup Table
          35   5388
          34   5388
          33   5309
          39   5309
          40   5309
          30   5280
          29   5280
5416: oError 17
5418: oJumpForward 5493
5420: oTypeSNodeType
5421: oChoice 5473
5423: oCall 7531
5425: oGetParam 1
5427: oPushResult
5428: oCall 5496
5430: oPop 1
5432: oCall 7551
5434: oEmit 40
5436: oJumpForward 5484
5438: oGetParam 1
5440: oPushResult
5441: oCall 5496
5443: oPop 1
5445: oTypeSNodeType
5446: oChoice 5460
5448: oCall 7531
5450: oCall 7135
5452: oJumpForward 5471
5454: oCall 7446
5456: oCall 7191
5458: oJumpForward 5471
5460: Choice Lookup Table
          35   5454
          34   5454
          30   5448
          29   5448
5469: oError 17
5471: oJumpForward 5484
5473: Choice Lookup Table
          35   5438
          34   5438
          30   5423
          29   5423
5482: oError 17
5484: oJumpForward 5493
5486: Choice Lookup Table
          25   5420
          24   5277
5491: oJumpForward 5495
5493: oJumpBack 5275
5495: oReturn
5496: oLocalSpace 0
5498: oGetParam 1
5500: oPushResult
5501: oCall 5547
5503: oPop 1
5505: oInputChoice 5537
5507: oCall 7531
5509: oGetParam 1
5511: oPushResult
5512: oCall 5547
5514: oPop 1
5516: oCall 7551
5518: oEmit 34
5520: oJumpForward 5544
5522: oCall 7531
5524: oGetParam 1
5526: oPushResult
5527: oCall 5547
5529: oPop 1
5531: oCall 7551
5533: oEmit 35
5535: oJumpForward 5544
5537: Choice Lookup Table
          23   5522
          22   5507
5542: oJumpForward 5546
5544: oJumpBack 5505
5546: oReturn
5547: oLocalSpace 0
5549: oInputChoice 5575
5551: oGetParam 1
5553: oPushResult
5554: oCall 5588
5556: oPop 1
5558: oCall 7551
5560: oJumpForward 5587
5562: oGetParam 1
5564: oPushResult
5565: oCall 5588
5567: oPop 1
5569: oCall 7551
5571: oEmit 41
5573: oJumpForward 5587
5575: Choice Lookup Table
          25   5562
          24   5551
5580: oGetParam 1
5582: oPushResult
5583: oCall 5588
5585: oPop 1
5587: oReturn
5588: oLocalSpace 6
5590: oInputChoice 5844
5592: oEmit 15
5594: TOKEN_VALUE
5595: oPushResult
5596: oEmitInt
5597: oPop 1
5599: oGetGlobal 6
5601: oPushResult
5602: oTypeSPush
5603: oPop 1
5605: oJumpForward 5865
5607: oEmit 15
5609: TOKEN_VALUE
5610: oPushResult
5611: oEmitInt
5612: oPop 1
5614: oGetGlobal 9
5616: oPushResult
5617: oTypeSPush
5618: oPop 1
5620: oJumpForward 5865
5622: oGetParam 1
5624: oPushResult
5625: oCall 4342
5627: oPop 1
5629: oInput 15
5631: oJumpForward 5865
5633: oGetAddrLocal 1
5635: oPushResult
5636: CURRENT_STRLIT
5637: oPushResult
5638: oStringAllocShortStringLit
5639: oPop 1
5641: oAssign
5642: oEmit 16
5644: oGetLocal 1
5646: oPushResult
5647: oEmitInt
5648: oPop 1
5650: oGetGlobal 13
5652: oPushResult
5653: oTypeSPush
5654: oPop 1
5656: oCall 6677
5658: oCall 6623
5660: oJumpForward 5865
5662: oGetAddrLocal 2
5664: oPushResult
5665: oScopeFindRequire
5666: oAssign
5667: oGetAddrLocal 2
5669: oPushResult
5670: oCall 244
5672: oPop 1
5674: oGetLocal 2
5676: oPushResult
5677: oNodeType
5678: oPop 1
5680: oChoice 5768
5682: oGetLocal 2
5684: oPushResult
5685: oCall 9536
5687: oPop 1
5689: oJumpForward 5793
5691: oGetLocal 2
5693: oPushResult
5694: oCall 10239
5696: oPop 1
5698: oJumpForward 5793
5700: oGetAddrLocal 3
5702: oPushResult
5703: oGetLocal 2
5705: oPushResult
5706: oSetResult 21
5708: oPushResult
5709: oNodeGet
5710: oPop 2
5712: oAssign
5713: oGetLocal 3
5715: oPushResult
5716: oTypeSPush
5717: oPop 1
5719: oTypeSNodeType
5720: oChoice 5744
5722: oEmit 15
5724: oGetLocal 2
5726: oPushResult
5727: oCall 12540
5729: oPop 1
5731: oJumpForward 5757
5733: oEmit 15
5735: oGetLocal 2
5737: oPushResult
5738: oCall 12540
5740: oPop 1
5742: oJumpForward 5757
5744: Choice Lookup Table
          35   5733
          34   5733
          31   5722
          41   5722
          29   5722
5755: oError 16
5757: oJumpForward 5793
5759: oGetLocal 2
5761: oPushResult
5762: oCall 5866
5764: oPop 1
5766: oJumpForward 5793
5768: Choice Lookup Table
          25   5759
          24   5759
          22   5759
          21   5759
          17   5700
          16   5700
          14   5691
          13   5682
5785: oError 6
5787: oGetGlobal 6
5789: oPushResult
5790: oTypeSPush
5791: oPop 1
5793: oJumpForward 5865
5795: oInput 0
5797: oGetAddrLocal 4
5799: oPushResult
5800: oScopeFindRequire
5801: oAssign
5802: oGetAddrLocal 4
5804: oPushResult
5805: oCall 244
5807: oPop 1
5809: oGetLocal 4
5811: oPushResult
5812: oSetResult 0
5814: oPushResult
5815: oCall 8112
5817: oPop 2
5819: oGetAddrLocal 5
5821: oPushResult
5822: oTypeSTop
5823: oAssign
5824: oTypeSPop
5825: oGetAddrLocal 6
5827: oPushResult
5828: oGetLocal 5
5830: oPushResult
5831: oCall 11559
5833: oPop 1
5835: oAssign
5836: oGetLocal 6
5838: oPushResult
5839: oTypeSPush
5840: oPop 1
5842: oJumpForward 5865
5844: Choice Lookup Table
          19   5795
           0   5662
           2   5633
          14   5622
           3   5607
           1   5592
5857: oError 6
5859: oGetGlobal 6
5861: oPushResult
5862: oTypeSPush
5863: oPop 1
5865: oReturn
5866: oLocalSpace 2
5868: oGetAddrLocal 1
5870: oPushResult
5871: oGetParam 1
5873: oPushResult
5874: oSetResult 21
5876: oPushResult
5877: oNodeGet
5878: oPop 2
5880: oAssign
5881: oGetAddrLocal 2
5883: oPushResult
5884: oGetParam 1
5886: oPushResult
5887: oCall 12494
5889: oPop 1
5891: oAssign
5892: oGetLocal 1
5894: oPushResult
5895: oTypeSPush
5896: oPop 1
5898: oTypeSNodeType
5899: oChoice 6598
5901: oGetParam 1
5903: oPushResult
5904: oNodeType
5905: oPop 1
5907: oChoice 6053
5909: oEmit 0
5911: oGetParam 1
5913: oPushResult
5914: oCall 12540
5916: oPop 1
5918: oJumpForward 6063
5920: oGetLocal 2
5922: oPushResult
5923: equal_zero
5924: oPop 1
5926: oChoice 5939
5928: oEmit 3
5930: oGetParam 1
5932: oPushResult
5933: oCall 12540
5935: oPop 1
5937: oJumpForward 5957
5939: Choice Lookup Table
           1   5928
5942: oEmit 9
5944: oGetLocal 2
5946: oPushResult
5947: oEmitInt
5948: oPop 1
5950: oGetParam 1
5952: oPushResult
5953: oCall 12540
5955: oPop 1
5957: oJumpForward 6063
5959: oGetParam 1
5961: oPushResult
5962: oSetResult 34
5964: oPushResult
5965: oNodeGetBoolean
5966: oPop 2
5968: oChoice 6011
5970: oGetLocal 2
5972: oPushResult
5973: equal_zero
5974: oPop 1
5976: oChoice 5989
5978: oEmit 8
5980: oGetParam 1
5982: oPushResult
5983: oCall 12540
5985: oPop 1
5987: oJumpForward 6007
5989: Choice Lookup Table
           1   5978
5992: oEmit 14
5994: oGetLocal 2
5996: oPushResult
5997: oEmitInt
5998: oPop 1
6000: oGetParam 1
6002: oPushResult
6003: oCall 12540
6005: oPop 1
6007: oEmit 23
6009: oJumpForward 6051
6011: Choice Lookup Table
           1   5970
6014: oGetLocal 2
6016: oPushResult
6017: equal_zero
6018: oPop 1
6020: oChoice 6033
6022: oEmit 6
6024: oGetParam 1
6026: oPushResult
6027: oCall 12540
6029: oPop 1
6031: oJumpForward 6051
6033: Choice Lookup Table
           1   6022
6036: oEmit 12
6038: oGetLocal 2
6040: oPushResult
6041: oEmitInt
6042: oPop 1
6044: oGetParam 1
6046: oPushResult
6047: oCall 12540
6049: oPop 1
6051: oJumpForward 6063
6053: Choice Lookup Table
          24   5959
          22   5920
          25   5909
          21   5909
6062: oEndChoice
6063: oJumpForward 6622
6065: oGetParam 1
6067: oPushResult
6068: oNodeType
6069: oPop 1
6071: oChoice 6217
6073: oEmit 1
6075: oGetParam 1
6077: oPushResult
6078: oCall 12540
6080: oPop 1
6082: oJumpForward 6227
6084: oGetLocal 2
6086: oPushResult
6087: equal_zero
6088: oPop 1
6090: oChoice 6103
6092: oEmit 4
6094: oGetParam 1
6096: oPushResult
6097: oCall 12540
6099: oPop 1
6101: oJumpForward 6121
6103: Choice Lookup Table
           1   6092
6106: oEmit 10
6108: oGetLocal 2
6110: oPushResult
6111: oEmitInt
6112: oPop 1
6114: oGetParam 1
6116: oPushResult
6117: oCall 12540
6119: oPop 1
6121: oJumpForward 6227
6123: oGetParam 1
6125: oPushResult
6126: oSetResult 34
6128: oPushResult
6129: oNodeGetBoolean
6130: oPop 2
6132: oChoice 6175
6134: oGetLocal 2
6136: oPushResult
6137: equal_zero
6138: oPop 1
6140: oChoice 6153
6142: oEmit 8
6144: oGetParam 1
6146: oPushResult
6147: oCall 12540
6149: oPop 1
6151: oJumpForward 6171
6153: Choice Lookup Table
           1   6142
6156: oEmit 14
6158: oGetLocal 2
6160: oPushResult
6161: oEmitInt
6162: oPop 1
6164: oGetParam 1
6166: oPushResult
6167: oCall 12540
6169: oPop 1
6171: oEmit 24
6173: oJumpForward 6215
6175: Choice Lookup Table
           1   6134
6178: oGetLocal 2
6180: oPushResult
6181: equal_zero
6182: oPop 1
6184: oChoice 6197
6186: oEmit 7
6188: oGetParam 1
6190: oPushResult
6191: oCall 12540
6193: oPop 1
6195: oJumpForward 6215
6197: Choice Lookup Table
           1   6186
6200: oEmit 13
6202: oGetLocal 2
6204: oPushResult
6205: oEmitInt
6206: oPop 1
6208: oGetParam 1
6210: oPushResult
6211: oCall 12540
6213: oPop 1
6215: oJumpForward 6227
6217: Choice Lookup Table
          24   6123
          22   6084
          25   6073
          21   6073
6226: oEndChoice
6227: oJumpForward 6622
6229: oError 16
6231: oJumpForward 6622
6233: oGetParam 1
6235: oPushResult
6236: oNodeType
6237: oPop 1
6239: oChoice 6385
6241: oEmit 2
6243: oGetParam 1
6245: oPushResult
6246: oCall 12540
6248: oPop 1
6250: oJumpForward 6395
6252: oGetLocal 2
6254: oPushResult
6255: equal_zero
6256: oPop 1
6258: oChoice 6271
6260: oEmit 5
6262: oGetParam 1
6264: oPushResult
6265: oCall 12540
6267: oPop 1
6269: oJumpForward 6289
6271: Choice Lookup Table
           1   6260
6274: oEmit 11
6276: oGetLocal 2
6278: oPushResult
6279: oEmitInt
6280: oPop 1
6282: oGetParam 1
6284: oPushResult
6285: oCall 12540
6287: oPop 1
6289: oJumpForward 6395
6291: oGetParam 1
6293: oPushResult
6294: oSetResult 34
6296: oPushResult
6297: oNodeGetBoolean
6298: oPop 2
6300: oChoice 6343
6302: oGetLocal 2
6304: oPushResult
6305: equal_zero
6306: oPop 1
6308: oChoice 6321
6310: oEmit 8
6312: oGetParam 1
6314: oPushResult
6315: oCall 12540
6317: oPop 1
6319: oJumpForward 6339
6321: Choice Lookup Table
           1   6310
6324: oEmit 14
6326: oGetLocal 2
6328: oPushResult
6329: oEmitInt
6330: oPop 1
6332: oGetParam 1
6334: oPushResult
6335: oCall 12540
6337: oPop 1
6339: oEmit 25
6341: oJumpForward 6383
6343: Choice Lookup Table
           1   6302
6346: oGetLocal 2
6348: oPushResult
6349: equal_zero
6350: oPop 1
6352: oChoice 6365
6354: oEmit 8
6356: oGetParam 1
6358: oPushResult
6359: oCall 12540
6361: oPop 1
6363: oJumpForward 6383
6365: Choice Lookup Table
           1   6354
6368: oEmit 14
6370: oGetLocal 2
6372: oPushResult
6373: oEmitInt
6374: oPop 1
6376: oGetParam 1
6378: oPushResult
6379: oCall 12540
6381: oPop 1
6383: oJumpForward 6395
6385: Choice Lookup Table
          24   6291
          22   6252
          25   6241
          21   6241
6394: oEndChoice
6395: oInputChoice 6425
6397: oTypeSPop
6398: oGetLocal 1
6400: oPushResult
6401: oSetResult 37
6403: oPushResult
6404: oNodeGet
6405: oPop 2
6407: oPushResult
6408: oTypeSPush
6409: oPop 1
6411: oCall 6677
6413: oCall 6623
6415: oJumpForward 6430
6417: oCall 6872
6419: oCall 6677
6421: oCall 6623
6423: oJumpForward 6430
6425: Choice Lookup Table
          16   6417
          18   6397
6430: oJumpForward 6622
6432: oGetParam 1
6434: oPushResult
6435: oNodeType
6436: oPop 1
6438: oChoice 6582
6440: oEmit 16
6442: oGetParam 1
6444: oPushResult
6445: oCall 12540
6447: oPop 1
6449: oJumpForward 6592
6451: oGetLocal 2
6453: oPushResult
6454: equal_zero
6455: oPop 1
6457: oChoice 6470
6459: oEmit 17
6461: oGetParam 1
6463: oPushResult
6464: oCall 12540
6466: oPop 1
6468: oJumpForward 6488
6470: Choice Lookup Table
           1   6459
6473: oEmit 20
6475: oGetLocal 2
6477: oPushResult
6478: oEmitInt
6479: oPop 1
6481: oGetParam 1
6483: oPushResult
6484: oCall 12540
6486: oPop 1
6488: oJumpForward 6592
6490: oGetParam 1
6492: oPushResult
6493: oSetResult 34
6495: oPushResult
6496: oNodeGetBoolean
6497: oPop 2
6499: oChoice 6540
6501: oGetLocal 2
6503: oPushResult
6504: equal_zero
6505: oPop 1
6507: oChoice 6520
6509: oEmit 8
6511: oGetParam 1
6513: oPushResult
6514: oCall 12540
6516: oPop 1
6518: oJumpForward 6538
6520: Choice Lookup Table
           1   6509
6523: oEmit 14
6525: oGetLocal 2
6527: oPushResult
6528: oEmitInt
6529: oPop 1
6531: oGetParam 1
6533: oPushResult
6534: oCall 12540
6536: oPop 1
6538: oJumpForward 6580
6540: Choice Lookup Table
           1   6501
6543: oGetLocal 2
6545: oPushResult
6546: equal_zero
6547: oPop 1
6549: oChoice 6562
6551: oEmit 18
6553: oGetParam 1
6555: oPushResult
6556: oCall 12540
6558: oPop 1
6560: oJumpForward 6580
6562: Choice Lookup Table
           1   6551
6565: oEmit 21
6567: oGetLocal 2
6569: oPushResult
6570: oEmitInt
6571: oPop 1
6573: oGetParam 1
6575: oPushResult
6576: oCall 12540
6578: oPop 1
6580: oJumpForward 6592
6582: Choice Lookup Table
          24   6490
          22   6451
          25   6440
          21   6440
6591: oEndChoice
6592: oCall 6677
6594: oCall 6623
6596: oJumpForward 6622
6598: Choice Lookup Table
          40   6432
          38   6432
          36   6432
          35   6233
          34   6233
          28   6229
          33   6065
          30   6065
          31   6065
          41   5901
          29   5901
6621: oEndChoice
6622: oReturn
6623: oLocalSpace 0
6625: oTypeSNodeType
6626: oChoice 6650
6628: oEmit 23
6630: oJumpForward 6676
6632: oEmit 24
6634: oJumpForward 6676
6636: oError 16
6638: oJumpForward 6676
6640: oEmit 25
6642: oJumpForward 6676
6644: oError 29
6646: oJumpForward 6676
6648: oJumpForward 6676
6650: Choice Lookup Table
          40   6648
          39   6648
          38   6648
          36   6648
          35   6644
          34   6640
          28   6636
          33   6632
          30   6632
          31   6632
          41   6628
          29   6628
6675: oEndChoice
6676: oReturn
6677: oLocalSpace 0
6679: oInputChoice 6717
6681: oTypeSNodeType
6682: oChoice 6696
6684: oCall 6729
6686: oJumpForward 6707
6688: oCall 6872
6690: oJumpForward 6707
6692: oCall 6951
6694: oJumpForward 6707
6696: Choice Lookup Table
          40   6692
          39   6692
          34   6688
          36   6684
6705: oError 10
6707: oJumpForward 6726
6709: oCall 6981
6711: oJumpForward 6726
6713: oCall 7254
6715: oJumpForward 6726
6717: Choice Lookup Table
          18   6713
          20   6709
          16   6681
6724: oJumpForward 6728
6726: oJumpBack 6679
6728: oReturn
6729: oLocalSpace 3
6731: oTypeSNodeType
6732: oChoice 6736
6734: oJumpForward 6741
6736: Choice Lookup Table
          36   6734
6739: oError 10
6741: oTypeSNodeType
6742: oChoice 6746
6744: oJumpForward 6751
6746: Choice Lookup Table
          36   6744
6749: oError 13
6751: oGetAddrLocal 1
6753: oPushResult
6754: oTypeSTop
6755: oPushResult
6756: oSetResult 38
6758: oPushResult
6759: oNodeGet
6760: oPop 2
6762: oPushResult
6763: oCall 11643
6765: oPop 1
6767: oAssign
6768: oGetAddrLocal 2
6770: oPushResult
6771: oTypeSTop
6772: oPushResult
6773: oSetResult 37
6775: oPushResult
6776: oNodeGet
6777: oPop 2
6779: oAssign
6780: oTypeSPop
6781: oGetLocal 2
6783: oPushResult
6784: oTypeSPush
6785: oPop 1
6787: oCall 4181
6789: oCall 7504
6791: oGetLocal 1
6793: oPushResult
6794: equal_zero
6795: oPop 1
6797: oChoice 6811
6799: oEmit 15
6801: oGetLocal 1
6803: oPushResult
6804: oEmitInt
6805: oPop 1
6807: oEmit 40
6809: oJumpForward 6814
6811: Choice Lookup Table
           0   6799
6814: oGetAddrLocal 3
6816: oPushResult
6817: oGetLocal 2
6819: oPushResult
6820: oSetResult 17
6822: oPushResult
6823: oNodeGetInt
6824: oPop 2
6826: oAssign
6827: oGetLocal 3
6829: oPushResult
6830: oSetResult 1
6832: oPushResult
6833: equal
6834: oPop 2
6836: oChoice 6850
6838: oEmit 15
6840: oGetLocal 3
6842: oPushResult
6843: oEmitInt
6844: oPop 1
6846: oEmit 34
6848: oJumpForward 6853
6850: Choice Lookup Table
           0   6838
6853: oEmit 36
6855: oInputChoice 6863
6857: oJumpForward 6871
6859: oJumpForward 6869
6861: oJumpForward 6869
6863: Choice Lookup Table
          13   6861
          17   6857
6868: oEndChoice
6869: oJumpBack 6741
6871: oReturn
6872: oLocalSpace 2
6874: oTypeSNodeType
6875: oChoice 6879
6877: oJumpForward 6884
6879: Choice Lookup Table
          34   6877
6882: oError 29
6884: oGetAddrLocal 1
6886: oPushResult
6887: oTypeSTop
6888: oPushResult
6889: oSetResult 37
6891: oPushResult
6892: oNodeGet
6893: oPop 2
6895: oAssign
6896: oTypeSPop
6897: oGetLocal 1
6899: oPushResult
6900: oTypeSPush
6901: oPop 1
6903: oCall 4181
6905: oCall 7504
6907: oGetAddrLocal 2
6909: oPushResult
6910: oGetLocal 1
6912: oPushResult
6913: oSetResult 17
6915: oPushResult
6916: oNodeGetInt
6917: oPop 2
6919: oAssign
6920: oGetLocal 2
6922: oPushResult
6923: oSetResult 1
6925: oPushResult
6926: equal
6927: oPop 2
6929: oChoice 6943
6931: oEmit 15
6933: oGetLocal 2
6935: oPushResult
6936: oEmitInt
6937: oPop 1
6939: oEmit 34
6941: oJumpForward 6946
6943: Choice Lookup Table
           0   6931
6946: oEmit 36
6948: oInput 17
6950: oReturn
6951: oLocalSpace 0
6953: oTypeSNodeType
6954: oChoice 6958
6956: oJumpForward 6965
6958: Choice Lookup Table
          40   6956
          39   6956
6963: oError 29
6965: oTypeSPop
6966: oGetGlobal 9
6968: oPushResult
6969: oTypeSPush
6970: oPop 1
6972: oCall 4181
6974: oCall 7504
6976: oEmit 36
6978: oInput 17
6980: oReturn
6981: oLocalSpace 2
6983: oTypeSNodeType
6984: oChoice 6988
6986: oJumpForward 6993
6988: Choice Lookup Table
          38   6986
6991: oError 11
6993: oTypeSTop
6994: oPushResult
6995: oSetResult 41
6997: oPushResult
6998: oNodeGet
6999: oPop 2
7001: oPushResult
7002: oScopeEnter
7003: oPop 1
7005: oInput 0
7007: oGetAddrLocal 1
7009: oPushResult
7010: oScopeFindRequire
7011: oAssign
7012: oGetLocal 1
7014: oPushResult
7015: oNodeType
7016: oPop 1
7018: oChoice 7022
7020: oJumpForward 7027
7022: Choice Lookup Table
          23   7020
7025: oError 12
7027: oScopeEnd
7028: oGetAddrLocal 2
7030: oPushResult
7031: oGetLocal 1
7033: oPushResult
7034: oSetResult 22
7036: oPushResult
7037: oNodeGetInt
7038: oPop 2
7040: oAssign
7041: oGetLocal 2
7043: oPushResult
7044: equal_zero
7045: oPop 1
7047: oChoice 7061
7049: oEmit 15
7051: oGetLocal 2
7053: oPushResult
7054: oEmitInt
7055: oPop 1
7057: oEmit 36
7059: oJumpForward 7064
7061: Choice Lookup Table
           0   7049
7064: oTypeSPop
7065: oGetLocal 1
7067: oPushResult
7068: oSetResult 21
7070: oPushResult
7071: oNodeGet
7072: oPop 2
7074: oPushResult
7075: oTypeSPush
7076: oPop 1
7078: oReturn
7079: oLocalSpace 2
7081: oGetAddrLocal 1
7083: oPushResult
7084: oTypeSTop
7085: oPushResult
7086: oSetResult 37
7088: oPushResult
7089: oNodeGet
7090: oPop 2
7092: oAssign
7093: oGetAddrLocal 2
7095: oPushResult
7096: oGetLocal 1
7098: oPushResult
7099: oSetResult 17
7101: oPushResult
7102: oNodeGetInt
7103: oPop 2
7105: oAssign
7106: oGetLocal 2
7108: oPushResult
7109: oSetResult 1
7111: oPushResult
7112: equal
7113: oPop 2
7115: oChoice 7129
7117: oEmit 15
7119: oGetLocal 2
7121: oPushResult
7122: oEmitInt
7123: oPop 1
7125: oEmit 34
7127: oJumpForward 7132
7129: Choice Lookup Table
           0   7117
7132: oEmit 36
7134: oReturn
7135: oLocalSpace 2
7137: oGetAddrLocal 1
7139: oPushResult
7140: oTypeSTop
7141: oPushResult
7142: oSetResult 37
7144: oPushResult
7145: oNodeGet
7146: oPop 2
7148: oAssign
7149: oGetAddrLocal 2
7151: oPushResult
7152: oGetLocal 1
7154: oPushResult
7155: oSetResult 17
7157: oPushResult
7158: oNodeGetInt
7159: oPop 2
7161: oAssign
7162: oGetLocal 2
7164: oPushResult
7165: oSetResult 1
7167: oPushResult
7168: equal
7169: oPop 2
7171: oChoice 7185
7173: oEmit 15
7175: oGetLocal 2
7177: oPushResult
7178: oEmitInt
7179: oPop 1
7181: oEmit 34
7183: oJumpForward 7188
7185: Choice Lookup Table
           0   7173
7188: oEmit 39
7190: oReturn
7191: oLocalSpace 2
7193: oEmit 38
7195: oGetAddrLocal 1
7197: oPushResult
7198: oTypeSTop
7199: oPushResult
7200: oSetResult 37
7202: oPushResult
7203: oNodeGet
7204: oPop 2
7206: oAssign
7207: oGetAddrLocal 2
7209: oPushResult
7210: oGetLocal 1
7212: oPushResult
7213: oSetResult 17
7215: oPushResult
7216: oNodeGetInt
7217: oPop 2
7219: oAssign
7220: oGetLocal 2
7222: oPushResult
7223: oSetResult 1
7225: oPushResult
7226: equal
7227: oPop 2
7229: oChoice 7243
7231: oEmit 15
7233: oGetLocal 2
7235: oPushResult
7236: oEmitInt
7237: oPop 1
7239: oEmit 35
7241: oJumpForward 7246
7243: Choice Lookup Table
           0   7231
7246: oTypeSPop
7247: oGetGlobal 6
7249: oPushResult
7250: oTypeSPush
7251: oPop 1
7253: oReturn
7254: oLocalSpace 1
7256: oTypeSNodeType
7257: oChoice 7265
7259: oJumpForward 7272
7261: oError 29
7263: oJumpForward 7272
7265: Choice Lookup Table
          35   7261
          34   7259
7270: oError 9
7272: oEmit 25
7274: oGetAddrLocal 1
7276: oPushResult
7277: oTypeSTop
7278: oAssign
7279: oTypeSPop
7280: oGetLocal 1
7282: oPushResult
7283: oSetResult 37
7285: oPushResult
7286: oNodeGet
7287: oPop 2
7289: oPushResult
7290: oTypeSPush
7291: oPop 1
7293: oReturn
7294: oLocalSpace 2
7296: oGetAddrLocal 1
7298: oPushResult
7299: oTypeSNodeType
7300: oAssign
7301: oTypeSPop
7302: oGetLocal 1
7304: oPushResult
7305: oTypeSNodeType
7306: oPushResult
7307: equal_node_type
7308: oPop 2
7310: oChoice 7442
7312: oTypeSNodeType
7313: oChoice 7427
7315: oGetLocal 1
7317: oChoice 7324
7319: oEmit 30
7321: oReturn
7322: oJumpForward 7327
7324: Choice Lookup Table
          30   7319
7327: oJumpForward 7438
7329: oGetLocal 1
7331: oChoice 7338
7333: oEmit 31
7335: oReturn
7336: oJumpForward 7341
7338: Choice Lookup Table
          29   7333
7341: oJumpForward 7438
7343: oGetLocal 1
7345: oChoice 7378
7347: oReturn
7348: oJumpForward 7383
7350: oTypeSTop
7351: oPushResult
7352: oGetGlobal 10
7354: oPushResult
7355: equal_node
7356: oPop 2
7358: oChoice 7373
7360: oEmit 15
7362: oSetResult 1
7364: oPushResult
7365: oEmitInt
7366: oPop 1
7368: oEmit 36
7370: oReturn
7371: oJumpForward 7376
7373: Choice Lookup Table
           1   7360
7376: oJumpForward 7383
7378: Choice Lookup Table
          39   7350
          35   7347
7383: oJumpForward 7438
7385: oGetLocal 1
7387: oChoice 7392
7389: oReturn
7390: oJumpForward 7395
7392: Choice Lookup Table
          34   7389
7395: oJumpForward 7438
7397: oGetLocal 1
7399: oChoice 7420
7401: oReturn
7402: oJumpForward 7425
7404: oGetGlobal 9
7406: oPushResult
7407: oTypeSPush
7408: oPop 1
7410: oGetAddrLocal 2
7412: oPushResult
7413: oCall 9224
7415: oAssign
7416: oTypeSPop
7417: oReturn
7418: oJumpForward 7425
7420: Choice Lookup Table
          33   7404
          39   7401
7425: oJumpForward 7438
7427: Choice Lookup Table
          40   7397
          35   7385
          34   7343
          30   7329
          29   7315
7438: oError 14
7440: oJumpForward 7445
7442: Choice Lookup Table
           0   7312
7445: oReturn
7446: oLocalSpace 1
7448: oGetAddrLocal 1
7450: oPushResult
7451: oTypeSNodeType
7452: oAssign
7453: oTypeSPop
7454: oGetLocal 1
7456: oPushResult
7457: oTypeSNodeType
7458: oPushResult
7459: equal_node_type
7460: oPop 2
7462: oChoice 7500
7464: oTypeSNodeType
7465: oChoice 7491
7467: oGetLocal 1
7469: oChoice 7474
7471: oReturn
7472: oJumpForward 7477
7474: Choice Lookup Table
          35   7471
7477: oJumpForward 7496
7479: oGetLocal 1
7481: oChoice 7486
7483: oReturn
7484: oJumpForward 7489
7486: Choice Lookup Table
          34   7483
7489: oJumpForward 7496
7491: Choice Lookup Table
          35   7479
          34   7467
7496: oError 14
7498: oJumpForward 7503
7500: Choice Lookup Table
           0   7464
7503: oReturn
7504: oLocalSpace 0
7506: oTypeSNodeType
7507: oChoice 7511
7509: oJumpForward 7516
7511: Choice Lookup Table
          29   7509
7514: oError 7
7516: oTypeSPop
7517: oReturn
7518: oLocalSpace 0
7520: oTypeSNodeType
7521: oChoice 7525
7523: oJumpForward 7530
7525: Choice Lookup Table
          29   7523
7528: oError 7
7530: oReturn
7531: oLocalSpace 0
7533: oTypeSNodeType
7534: oChoice 7542
7536: oJumpForward 7549
7538: oEmit 30
7540: oJumpForward 7549
7542: Choice Lookup Table
          30   7538
          29   7536
7547: oError 7
7549: oTypeSPop
7550: oReturn
7551: oLocalSpace 0
7553: oTypeSNodeType
7554: oChoice 7569
7556: oJumpForward 7576
7558: oEmit 30
7560: oTypeSPop
7561: oGetGlobal 6
7563: oPushResult
7564: oTypeSPush
7565: oPop 1
7567: oJumpForward 7576
7569: Choice Lookup Table
          30   7558
          29   7556
7574: oError 7
7576: oReturn
7577: oLocalSpace 0
7579: oTypeSNodeType
7580: oChoice 7593
7582: oEmit 30
7584: oTypeSPop
7585: oGetGlobal 6
7587: oPushResult
7588: oTypeSPush
7589: oPop 1
7591: oJumpForward 7596
7593: Choice Lookup Table
          30   7582
7596: oReturn
7597: oLocalSpace 0
7599: oTypeSNodeType
7600: oChoice 7604
7602: oJumpForward 7609
7604: Choice Lookup Table
          31   7602
7607: oError 8
7609: oTypeSPop
7610: oReturn
7611: oLocalSpace 0
7613: oTypeSNodeType
7614: oChoice 7618
7616: oJumpForward 7623
7618: Choice Lookup Table
          31   7616
7621: oError 8
7623: oReturn
7624: oLocalSpace 0
7626: oInputChoice 7689
7628: oCall 9087
7630: oJumpForward 7720
7632: oCall 9094
7634: oJumpForward 7720
7636: oCall 9218
7638: oJumpForward 7720
7640: oCall 9221
7642: oJumpForward 7720
7644: oCall 8302
7646: oJumpForward 7720
7648: oCall 8625
7650: oJumpForward 7720
7652: oCall 8368
7654: oJumpForward 7720
7656: oCall 8545
7658: oJumpForward 7720
7660: oCall 8710
7662: oJumpForward 7720
7664: oCall 8678
7666: oJumpForward 7720
7668: oCall 9064
7670: oJumpForward 7720
7672: oCall 7721
7674: oJumpForward 7720
7676: oCall 8742
7678: oJumpForward 7720
7680: oCall 9012
7682: oJumpForward 7720
7684: oChangeIntLitToLabelIdent
7685: oCall 7721
7687: oJumpForward 7720
7689: Choice Lookup Table
           1   7684
          55   7680
          53   7676
           0   7672
          35   7668
          51   7664
          52   7660
          49   7656
          44   7652
          48   7648
          41   7644
          68   7640
          67   7636
          66   7632
          65   7628
7720: oReturn
7721: oLocalSpace 1
7723: oGetAddrLocal 1
7725: oPushResult
7726: oScopeFindRequire
7727: oAssign
7728: oGetAddrLocal 1
7730: oPushResult
7731: oCall 244
7733: oPop 1
7735: oGetLocal 1
7737: oPushResult
7738: oNodeType
7739: oPop 1
7741: oChoice 7781
7743: oGetLocal 1
7745: oPushResult
7746: oCall 7797
7748: oPop 1
7750: oCall 7624
7752: oJumpForward 7796
7754: oGetLocal 1
7756: oPushResult
7757: oCall 9536
7759: oPop 1
7761: oJumpForward 7796
7763: oGetLocal 1
7765: oPushResult
7766: oCall 7847
7768: oPop 1
7770: oJumpForward 7796
7772: oGetLocal 1
7774: oPushResult
7775: oCall 7937
7777: oPop 1
7779: oJumpForward 7796
7781: Choice Lookup Table
          13   7772
          24   7763
          22   7763
          21   7763
          12   7754
          26   7743
7794: oError 0
7796: oReturn
7797: oLocalSpace 0
7799: oGetParam 1
7801: oPushResult
7802: oSetResult 35
7804: oPushResult
7805: oNodeGetBoolean
7806: oPop 2
7808: oChoice 7814
7810: oError 21
7812: oJumpForward 7817
7814: Choice Lookup Table
           1   7810
7817: oEmit 77
7819: oGetParam 1
7821: oPushResult
7822: oSetResult 22
7824: oPushResult
7825: oNodeGetLabel
7826: oPop 2
7828: oPushResult
7829: oEmitLabel
7830: oPop 1
7832: oGetParam 1
7834: oPushResult
7835: oSetResult 35
7837: oPushResult
7838: oSetResult 1
7840: oPushResult
7841: oNodeSetBoolean
7842: oPop 3
7844: oInput 12
7846: oReturn
7847: oLocalSpace 0
7849: oGetParam 1
7851: oPushResult
7852: oSetResult 1
7854: oPushResult
7855: oCall 8112
7857: oPop 2
7859: oInput 4
7861: oCall 4181
7863: oCall 7294
7865: oCall 7868
7867: oReturn
7868: oLocalSpace 1
7870: oTypeSNodeType
7871: oChoice 7911
7873: oEmit 26
7875: oJumpForward 7935
7877: oEmit 27
7879: oJumpForward 7935
7881: oError 16
7883: oJumpForward 7935
7885: oEmit 28
7887: oJumpForward 7935
7889: oGetAddrLocal 1
7891: oPushResult
7892: oTypeSTop
7893: oPushResult
7894: oSetResult 17
7896: oPushResult
7897: oNodeGetInt
7898: oPop 2
7900: oAssign
7901: oEmit 29
7903: oGetLocal 1
7905: oPushResult
7906: oEmitInt
7907: oPop 1
7909: oJumpForward 7935
7911: Choice Lookup Table
          40   7889
          38   7889
          36   7889
          35   7885
          34   7885
          28   7881
          33   7877
          30   7877
          31   7877
          41   7873
          29   7873
7934: oEndChoice
7935: oTypeSPop
7936: oReturn
7937: oLocalSpace 1
7939: oGetParam 1
7941: oPushResult
7942: oSetResult 6
7944: oPushResult
7945: oNodeGet
7946: oPop 2
7948: oPushResult
7949: oScopeCurrent
7950: oPushResult
7951: oNodeEqual
7952: oPop 2
7954: oChoice 7960
7956: oError 20
7958: oJumpForward 7963
7960: Choice Lookup Table
           0   7956
7963: oEmit 8
7965: oGetParam 1
7967: oPushResult
7968: oSetResult 31
7970: oPushResult
7971: oNodeGetInt
7972: oPop 2
7974: oPushResult
7975: oEmitInt
7976: oPop 1
7978: oGetParam 1
7980: oPushResult
7981: oSetResult 21
7983: oPushResult
7984: oNodeGet
7985: oPop 2
7987: oPushResult
7988: oTypeSPush
7989: oPop 1
7991: oInput 4
7993: oCall 4181
7995: oCall 7294
7997: oTypeSNodeType
7998: oChoice 8038
8000: oEmit 26
8002: oJumpForward 8062
8004: oEmit 27
8006: oJumpForward 8062
8008: oError 16
8010: oJumpForward 8062
8012: oEmit 28
8014: oJumpForward 8062
8016: oGetAddrLocal 1
8018: oPushResult
8019: oTypeSTop
8020: oPushResult
8021: oSetResult 17
8023: oPushResult
8024: oNodeGetInt
8025: oPop 2
8027: oAssign
8028: oEmit 29
8030: oGetLocal 1
8032: oPushResult
8033: oEmitInt
8034: oPop 1
8036: oJumpForward 8062
8038: Choice Lookup Table
          40   8016
          38   8016
          36   8016
          35   8012
          34   8012
          28   8008
          33   8004
          30   8004
          31   8004
          41   8000
          29   8000
8061: oEndChoice
8062: oTypeSPop
8063: oReturn
8064: oLocalSpace 1
8066: oInput 0
8068: oGetAddrLocal 1
8070: oPushResult
8071: oScopeFindRequire
8072: oAssign
8073: oGetAddrLocal 1
8075: oPushResult
8076: oCall 244
8078: oPop 1
8080: oGetLocal 1
8082: oPushResult
8083: oNodeType
8084: oPop 1
8086: oChoice 8090
8088: oJumpForward 8101
8090: Choice Lookup Table
          25   8088
          24   8088
          22   8088
          21   8088
8099: oError 4
8101: oGetLocal 1
8103: oPushResult
8104: oGetParam 1
8106: oPushResult
8107: oCall 8112
8109: oPop 2
8111: oReturn
8112: oLocalSpace 0
8114: oGetParam 2
8116: oPushResult
8117: oNodeType
8118: oPop 1
8120: oChoice 8202
8122: oEmit 16
8124: oGetParam 2
8126: oPushResult
8127: oCall 12540
8129: oPop 1
8131: oJumpForward 8213
8133: oEmit 17
8135: oGetParam 2
8137: oPushResult
8138: oCall 12540
8140: oPop 1
8142: oJumpForward 8213
8144: oGetParam 2
8146: oPushResult
8147: oSetResult 34
8149: oPushResult
8150: oNodeGetBoolean
8151: oPop 2
8153: oChoice 8166
8155: oEmit 8
8157: oGetParam 2
8159: oPushResult
8160: oCall 12540
8162: oPop 1
8164: oJumpForward 8178
8166: Choice Lookup Table
           1   8155
8169: oEmit 18
8171: oGetParam 2
8173: oPushResult
8174: oCall 12540
8176: oPop 1
8178: oJumpForward 8213
8180: oGetParam 1
8182: oChoice 8195
8184: oEmit 16
8186: oGetParam 2
8188: oPushResult
8189: oCall 12540
8191: oPop 1
8193: oJumpForward 8200
8195: Choice Lookup Table
           0   8184
8198: oError 4
8200: oJumpForward 8213
8202: Choice Lookup Table
          25   8180
          24   8144
          22   8133
          21   8122
8211: oError 4
8213: oGetParam 2
8215: oPushResult
8216: oSetResult 21
8218: oPushResult
8219: oNodeGet
8220: oPop 2
8222: oPushResult
8223: oTypeSPush
8224: oPop 1
8226: oTypeSNodeType
8227: oChoice 8242
8229: oInputChoice 8237
8231: oEmit 25
8233: oCall 6872
8235: oJumpForward 8240
8237: Choice Lookup Table
          16   8231
8240: oJumpForward 8245
8242: Choice Lookup Table
          34   8229
8245: oCall 6677
8247: oReturn
8248: oLocalSpace 0
8250: oGetParam 1
8252: oPushResult
8253: oSetResult 1
8255: oPushResult
8256: oCall 8112
8258: oPop 2
8260: oCall 7504
8262: oGetParam 1
8264: oPushResult
8265: oCall 5866
8267: oPop 1
8269: oTypeSPop
8270: oEmit 32
8272: oEmit 26
8274: oReturn
8275: oLocalSpace 0
8277: oGetParam 1
8279: oPushResult
8280: oSetResult 1
8282: oPushResult
8283: oCall 8112
8285: oPop 2
8287: oCall 7504
8289: oGetParam 1
8291: oPushResult
8292: oCall 5866
8294: oPop 1
8296: oTypeSPop
8297: oEmit 33
8299: oEmit 26
8301: oReturn
8302: oLocalSpace 2
8304: oGetAddrLocal 1
8306: oPushResult
8307: oSetResult 0
8309: oAssign
8310: oGetAddrLocal 1
8312: oPushResult
8313: oCall 4204
8315: oPop 1
8317: oInput 42
8319: oCall 7624
8321: oInputChoice 8356
8323: oGetAddrLocal 2
8325: oPushResult
8326: oLabelNew
8327: oAssign
8328: oEmit 68
8330: oGetLocal 2
8332: oPushResult
8333: oEmitLabel
8334: oPop 1
8336: oEmit 77
8338: oGetLocal 1
8340: oPushResult
8341: oEmitLabel
8342: oPop 1
8344: oCall 7624
8346: oEmit 77
8348: oGetLocal 2
8350: oPushResult
8351: oEmitLabel
8352: oPop 1
8354: oJumpForward 8367
8356: Choice Lookup Table
          43   8323
8359: oEmit 77
8361: oGetLocal 1
8363: oPushResult
8364: oEmitLabel
8365: oPop 1
8367: oReturn
8368: oLocalSpace 4
8370: oInput 0
8372: oGetAddrLocal 1
8374: oPushResult
8375: oScopeFindRequire
8376: oAssign
8377: oGetLocal 1
8379: oPushResult
8380: oSetResult 1
8382: oPushResult
8383: oCall 8112
8385: oPop 2
8387: oCall 7504
8389: oInput 4
8391: oCall 4181
8393: oCall 7504
8395: oEmit 26
8397: oGetAddrLocal 2
8399: oPushResult
8400: oLabelNew
8401: oAssign
8402: oGetAddrLocal 3
8404: oPushResult
8405: oLabelNew
8406: oAssign
8407: oEmit 68
8409: oGetLocal 3
8411: oPushResult
8412: oEmitLabel
8413: oPop 1
8415: oGetAddrLocal 4
8417: oPushResult
8418: oLabelNew
8419: oAssign
8420: oEmit 77
8422: oGetLocal 4
8424: oPushResult
8425: oEmitLabel
8426: oPop 1
8428: oInputChoice 8508
8430: oGetLocal 1
8432: oPushResult
8433: oCall 8248
8435: oPop 1
8437: oEmit 77
8439: oGetLocal 3
8441: oPushResult
8442: oEmitLabel
8443: oPop 1
8445: oGetLocal 1
8447: oPushResult
8448: oCall 5866
8450: oPop 1
8452: oTypeSPop
8453: oCall 4181
8455: oCall 7504
8457: oEmit 51
8459: oEmit 69
8461: oGetLocal 2
8463: oPushResult
8464: oEmitLabel
8465: oPop 1
8467: oJumpForward 8514
8469: oGetLocal 1
8471: oPushResult
8472: oCall 8275
8474: oPop 1
8476: oEmit 77
8478: oGetLocal 3
8480: oPushResult
8481: oEmitLabel
8482: oPop 1
8484: oGetLocal 1
8486: oPushResult
8487: oCall 5866
8489: oPop 1
8491: oTypeSPop
8492: oCall 4181
8494: oCall 7504
8496: oEmit 52
8498: oEmit 69
8500: oGetLocal 2
8502: oPushResult
8503: oEmitLabel
8504: oPop 1
8506: oJumpForward 8514
8508: Choice Lookup Table
          46   8469
          45   8430
8513: oEndChoice
8514: oGetLocal 4
8516: oPushResult
8517: oGetLocal 2
8519: oPushResult
8520: oLoopPush
8521: oPop 2
8523: oInput 47
8525: oCall 7624
8527: oEmit 68
8529: oGetLocal 4
8531: oPushResult
8532: oEmitLabel
8533: oPop 1
8535: oEmit 77
8537: oGetLocal 2
8539: oPushResult
8540: oEmitLabel
8541: oPop 1
8543: oLoopPop
8544: oReturn
8545: oLocalSpace 3
8547: oGetAddrLocal 1
8549: oPushResult
8550: oLabelNew
8551: oAssign
8552: oEmit 77
8554: oGetLocal 1
8556: oPushResult
8557: oEmitLabel
8558: oPop 1
8560: oGetAddrLocal 2
8562: oPushResult
8563: oLabelNew
8564: oAssign
8565: oGetLocal 1
8567: oPushResult
8568: oGetLocal 2
8570: oPushResult
8571: oLoopPush
8572: oPop 2
8574: oCall 7624
8576: oInputChoice 8607
8578: oCall 7624
8580: oJumpForward 8613
8582: oGetAddrLocal 3
8584: oPushResult
8585: oCall 4204
8587: oPop 1
8589: oEmit 78
8591: oGetLocal 3
8593: oPushResult
8594: oEmitLabel
8595: oPop 1
8597: oGetLocal 1
8599: oPushResult
8600: oEmitLabel
8601: oPop 1
8603: oJumpForward 8615
8605: oJumpForward 8613
8607: Choice Lookup Table
          50   8582
           5   8578
8612: oEndChoice
8613: oJumpBack 8576
8615: oEmit 77
8617: oGetLocal 2
8619: oPushResult
8620: oEmitLabel
8621: oPop 1
8623: oLoopPop
8624: oReturn
8625: oLocalSpace 2
8627: oGetAddrLocal 1
8629: oPushResult
8630: oLabelNew
8631: oAssign
8632: oEmit 77
8634: oGetLocal 1
8636: oPushResult
8637: oEmitLabel
8638: oPop 1
8640: oGetAddrLocal 2
8642: oPushResult
8643: oCall 4204
8645: oPop 1
8647: oGetLocal 1
8649: oPushResult
8650: oGetLocal 2
8652: oPushResult
8653: oLoopPush
8654: oPop 2
8656: oInput 47
8658: oCall 7624
8660: oEmit 68
8662: oGetLocal 1
8664: oPushResult
8665: oEmitLabel
8666: oPop 1
8668: oEmit 77
8670: oGetLocal 2
8672: oPushResult
8673: oEmitLabel
8674: oPop 1
8676: oLoopPop
8677: oReturn
8678: oLocalSpace 0
8680: oLoopContinueLabel
8681: oPushResult
8682: oSetResult 0
8684: oPushResult
8685: equal_label
8686: oPop 2
8688: oChoice 8703
8690: oError 18
8692: oJumpForward 8709
8694: oEmit 68
8696: oLoopContinueLabel
8697: oPushResult
8698: oEmitLabel
8699: oPop 1
8701: oJumpForward 8709
8703: Choice Lookup Table
           0   8694
           1   8690
8708: oEndChoice
8709: oReturn
8710: oLocalSpace 0
8712: oLoopBreakLabel
8713: oPushResult
8714: oSetResult 0
8716: oPushResult
8717: equal_label
8718: oPop 2
8720: oChoice 8735
8722: oError 18
8724: oJumpForward 8741
8726: oEmit 68
8728: oLoopBreakLabel
8729: oPushResult
8730: oEmitLabel
8731: oPop 1
8733: oJumpForward 8741
8735: Choice Lookup Table
           0   8726
           1   8722
8740: oEndChoice
8741: oReturn
8742: oLocalSpace 7
8744: oGetAddrLocal 1
8746: oPushResult
8747: oCodeNew
8748: oAssign
8749: oGetAddrLocal 2
8751: oPushResult
8752: oLabelNew
8753: oAssign
8754: oGetAddrLocal 3
8756: oPushResult
8757: oLabelNew
8758: oAssign
8759: oGetAddrLocal 4
8761: oPushResult
8762: oGetLocal 3
8764: oAssign
8765: oCall 4181
8767: oTypeSNodeType
8768: oChoice 8794
8770: oEmit 71
8772: oGetLocal 2
8774: oPushResult
8775: oEmitLabel
8776: oPop 1
8778: oJumpForward 8811
8780: oEmit 72
8782: oGetLocal 2
8784: oPushResult
8785: oEmitLabel
8786: oPop 1
8788: oJumpForward 8811
8790: oError 16
8792: oJumpForward 8811
8794: Choice Lookup Table
          39   8790
          40   8790
          41   8780
          29   8780
          33   8770
          30   8770
          31   8770
8809: oError 17
8811: oInput 40
8813: oInputChoice 8860
8815: oGetAddrLocal 4
8817: oPushResult
8818: oLabelNew
8819: oAssign
8820: oEmit 77
8822: oGetLocal 4
8824: oPushResult
8825: oEmitLabel
8826: oPop 1
8828: oInputChoice 8834
8830: oJumpForward 8852
8832: oJumpForward 8850
8834: Choice Lookup Table
          36   8830
8837: oCall 7624
8839: oInputChoice 8843
8841: oJumpForward 8850
8843: Choice Lookup Table
           5   8841
8846: oInput 36
8848: oJumpForward 8852
8850: oJumpBack 8828
8852: oJumpForward 8980
8854: oJumpForward 8978
8856: oJumpForward 8980
8858: oJumpForward 8978
8860: Choice Lookup Table
          36   8856
          43   8815
          54   8815
8867: oGetAddrLocal 5
8869: oPushResult
8870: oLabelNew
8871: oAssign
8872: oGetLocal 1
8874: oPushResult
8875: oCodePush
8876: oPop 1
8878: oCall 3526
8880: oCall 4108
8882: oGetAddrLocal 6
8884: oPushResult
8885: oValueTop
8886: oAssign
8887: oValuePop
8888: oInputChoice 8922
8890: oCall 3526
8892: oCall 4108
8894: oGetAddrLocal 7
8896: oPushResult
8897: oValueTop
8898: oAssign
8899: oValuePop
8900: oEmit 75
8902: oGetLocal 6
8904: oPushResult
8905: oEmitInt
8906: oPop 1
8908: oGetLocal 7
8910: oPushResult
8911: oEmitInt
8912: oPop 1
8914: oGetLocal 5
8916: oPushResult
8917: oEmitLabel
8918: oPop 1
8920: oJumpForward 8939
8922: Choice Lookup Table
          21   8890
8925: oEmit 74
8927: oGetLocal 6
8929: oPushResult
8930: oEmitInt
8931: oPop 1
8933: oGetLocal 5
8935: oPushResult
8936: oEmitLabel
8937: oPop 1
8939: oInputChoice 8943
8941: oJumpForward 8948
8943: Choice Lookup Table
          13   8941
8946: oJumpForward 8950
8948: oJumpBack 8878
8950: oCodePop
8951: oInput 12
8953: oEmit 77
8955: oGetLocal 5
8957: oPushResult
8958: oEmitLabel
8959: oPop 1
8961: oCall 7624
8963: oEmit 68
8965: oGetLocal 3
8967: oPushResult
8968: oEmitLabel
8969: oPop 1
8971: oInputChoice 8975
8973: oJumpForward 8978
8975: Choice Lookup Table
           5   8973
8978: oJumpBack 8813
8980: oEmit 77
8982: oGetLocal 2
8984: oPushResult
8985: oEmitLabel
8986: oPop 1
8988: oGetLocal 1
8990: oPushResult
8991: oEmitCode
8992: oPop 1
8994: oEmit 76
8996: oGetLocal 4
8998: oPushResult
8999: oEmitLabel
9000: oPop 1
9002: oEmit 77
9004: oGetLocal 3
9006: oPushResult
9007: oEmitLabel
9008: oPop 1
9010: oTypeSPop
9011: oReturn
9012: oLocalSpace 1
9014: oInputChoice 9021
9016: oJumpForward 9027
9018: oChangeIntLitToLabelIdent
9019: oJumpForward 9027
9021: Choice Lookup Table
           1   9018
           0   9016
9026: oEndChoice
9027: oGetAddrLocal 1
9029: oPushResult
9030: oScopeCurrent
9031: oPushResult
9032: oScopeFindRequireInScope
9033: oPop 1
9035: oAssign
9036: oGetLocal 1
9038: oPushResult
9039: oSetResult 28
9041: oPushResult
9042: oSetResult 1
9044: oPushResult
9045: oNodeSetBoolean
9046: oPop 3
9048: oEmit 68
9050: oGetLocal 1
9052: oPushResult
9053: oSetResult 22
9055: oPushResult
9056: oNodeGetLabel
9057: oPop 2
9059: oPushResult
9060: oEmitLabel
9061: oPop 1
9063: oReturn
9064: oLocalSpace 0
9066: oCall 7624
9068: oInputChoice 9078
9070: oCall 7624
9072: oJumpForward 9084
9074: oJumpForward 9086
9076: oJumpForward 9084
9078: Choice Lookup Table
          36   9074
           5   9070
9083: oEndChoice
9084: oJumpBack 9068
9086: oReturn
9087: oLocalSpace 0
9089: oCall 9094
9091: oEmit 87
9093: oReturn
9094: oLocalSpace 0
9096: oInputChoice 9214
9098: oCall 4181
9100: oTypeSNodeType
9101: oChoice 9172
9103: oEmit 80
9105: oJumpForward 9195
9107: oEmit 81
9109: oJumpForward 9195
9111: oEmit 30
9113: oEmit 80
9115: oJumpForward 9195
9117: oEmit 82
9119: oJumpForward 9195
9121: oEmit 83
9123: oJumpForward 9195
9125: oError 16
9127: oJumpForward 9195
9129: oEmit 16
9131: oTypeSTop
9132: oPushResult
9133: oSetResult 43
9135: oPushResult
9136: oNodeGetInt
9137: oPop 2
9139: oPushResult
9140: oEmitInt
9141: oPop 1
9143: oEmit 86
9145: oJumpForward 9195
9147: oTypeSTop
9148: oPushResult
9149: oGetGlobal 10
9151: oPushResult
9152: equal_node
9153: oPop 2
9155: oChoice 9161
9157: oEmit 84
9159: oJumpForward 9166
9161: Choice Lookup Table
           1   9157
9164: oEmit 85
9166: oJumpForward 9195
9168: oEmit 85
9170: oJumpForward 9195
9172: Choice Lookup Table
          35   9168
          34   9147
          41   9129
          28   9125
          39   9121
          40   9121
          33   9117
          30   9111
          31   9107
          29   9103
9193: oError 17
9195: oTypeSPop
9196: oInputChoice 9204
9198: oJumpForward 9212
9200: oJumpForward 9210
9202: oJumpForward 9210
9204: Choice Lookup Table
          13   9202
          15   9198
9209: oEndChoice
9210: oJumpBack 9098
9212: oJumpForward 9217
9214: Choice Lookup Table
          14   9098
9217: oReturn
9218: oLocalSpace 0
9220: oReturn
9221: oLocalSpace 0
9223: oReturn
9224: oLocalSpace 1
9226: oGetAddrLocal 1
9228: oPushResult
9229: oGetGlobal 14
9231: oPushResult
9232: oScopeAllocType
9233: oPop 1
9235: oAssign
9236: oTypeSNodeType
9237: oChoice 9305
9239: oEmit 17
9241: oGetLocal 1
9243: oPushResult
9244: oEmitInt
9245: oPop 1
9247: oEmit 22
9249: oEmit 29
9251: oGetGlobal 14
9253: oPushResult
9254: oSetResult 17
9256: oPushResult
9257: oNodeGetInt
9258: oPop 2
9260: oPushResult
9261: oEmitInt
9262: oPop 1
9264: oJumpForward 9314
9266: oEmit 17
9268: oGetLocal 1
9270: oPushResult
9271: oEmitInt
9272: oPop 1
9274: oEmit 15
9276: oSetResult 1
9278: oPushResult
9279: oEmitInt
9280: oPop 1
9282: oEmit 27
9284: oEmit 17
9286: oGetLocal 1
9288: oPushResult
9289: oSetResult 1
9291: oPushResult
9292: add
9293: oPop 2
9295: oPushResult
9296: oEmitInt
9297: oPop 1
9299: oEmit 22
9301: oEmit 27
9303: oJumpForward 9314
9305: Choice Lookup Table
          33   9266
          39   9239
          40   9239
9312: oError 14
9314: oTypeSPop
9315: oEmit 17
9317: oGetLocal 1
9319: oPushResult
9320: oEmitInt
9321: oPop 1
9323: oGetGlobal 14
9325: oPushResult
9326: oTypeSPush
9327: oPop 1
9329: oGetLocal 1
9331: oReturn
9332: oReturn
9333: oLocalSpace 0
9335: oEmit 61
9337: oSetResult 16
9339: oPushResult
9340: oEmitInt
9341: oPop 1
9343: oEmit 19
9345: oSetResult 8
9347: oPushResult
9348: oEmitInt
9349: oPop 1
9351: oEmit 22
9353: oEmit 28
9355: oEmit 19
9357: oSetResult 0
9359: oPushResult
9360: oEmitInt
9361: oPop 1
9363: oEmit 22
9365: oEmit 28
9367: oEmit 64
9369: oGetGlobal 19
9371: oPushResult
9372: oCall 12540
9374: oPop 1
9376: oEmit 63
9378: oSetResult 16
9380: oPushResult
9381: oEmitInt
9382: oPop 1
9384: oTypeSPop
9385: oTypeSPop
9386: oReturn
9387: oLocalSpace 0
9389: oEmit 61
9391: oSetResult 12
9393: oPushResult
9394: oEmitInt
9395: oPop 1
9397: oEmit 19
9399: oSetResult 8
9401: oPushResult
9402: oEmitInt
9403: oPop 1
9405: oEmit 22
9407: oEmit 26
9409: oEmit 19
9411: oSetResult 0
9413: oPushResult
9414: oEmitInt
9415: oPop 1
9417: oEmit 22
9419: oEmit 28
9421: oEmit 64
9423: oGetGlobal 20
9425: oPushResult
9426: oCall 12540
9428: oPop 1
9430: oEmit 63
9432: oSetResult 12
9434: oPushResult
9435: oEmitInt
9436: oPop 1
9438: oTypeSPop
9439: oTypeSPop
9440: oReturn
9441: oLocalSpace 1
9443: oEmit 61
9445: oSetResult 24
9447: oPushResult
9448: oEmitInt
9449: oPop 1
9451: oEmit 19
9453: oSetResult 8
9455: oPushResult
9456: oEmitInt
9457: oPop 1
9459: oEmit 22
9461: oEmit 28
9463: oEmit 19
9465: oSetResult 0
9467: oPushResult
9468: oEmitInt
9469: oPop 1
9471: oEmit 22
9473: oEmit 28
9475: oGetAddrLocal 1
9477: oPushResult
9478: oGetGlobal 6
9480: oPushResult
9481: oScopeAllocType
9482: oPop 1
9484: oAssign
9485: oEmit 19
9487: oSetResult 16
9489: oPushResult
9490: oEmitInt
9491: oPop 1
9493: oEmit 17
9495: oGetLocal 1
9497: oPushResult
9498: oEmitInt
9499: oPop 1
9501: oEmit 28
9503: oEmit 64
9505: oGetGlobal 21
9507: oPushResult
9508: oCall 12540
9510: oPop 1
9512: oEmit 3
9514: oGetLocal 1
9516: oPushResult
9517: oEmitInt
9518: oPop 1
9520: oEmit 63
9522: oSetResult 24
9524: oPushResult
9525: oEmitInt
9526: oPop 1
9528: oTypeSPop
9529: oGetGlobal 6
9531: oPushResult
9532: oTypeSPush
9533: oPop 1
9535: oReturn
9536: oLocalSpace 10
9538: oGetParam 1
9540: oPushResult
9541: oSetResult 25
9543: oPushResult
9544: oNodeGetBoolean
9545: oPop 2
9547: oChoice 9574
9549: oGetParam 1
9551: oPushResult
9552: oSetResult 28
9554: oPushResult
9555: oNodeGetBoolean
9556: oPop 2
9558: oChoice 9569
9560: oGetParam 1
9562: oPushResult
9563: oCall 10156
9565: oPop 1
9567: oJumpForward 9572
9569: Choice Lookup Table
           0   9560
9572: oJumpForward 9577
9574: Choice Lookup Table
           1   9549
9577: oGetParam 1
9579: oPushResult
9580: oSetResult 28
9582: oPushResult
9583: oSetResult 1
9585: oPushResult
9586: oNodeSetBoolean
9587: oPop 3
9589: oGetAddrLocal 1
9591: oPushResult
9592: oGetParam 1
9594: oPushResult
9595: oSetResult 27
9597: oPushResult
9598: oNodeGetBoolean
9599: oPop 2
9601: oAssign
9602: oGetAddrLocal 4
9604: oPushResult
9605: oGetParam 1
9607: oPushResult
9608: oNodeType
9609: oPop 1
9611: oPushResult
9612: oSetResult 13
9614: oPushResult
9615: equal_node_type
9616: oPop 2
9618: oAssign
9619: oGetLocal 4
9621: oChoice 9648
9623: oGetAddrLocal 2
9625: oPushResult
9626: oGetParam 1
9628: oPushResult
9629: oSetResult 21
9631: oPushResult
9632: oNodeGet
9633: oPop 2
9635: oAssign
9636: oGetAddrLocal 3
9638: oPushResult
9639: oGetLocal 2
9641: oPushResult
9642: oScopeAllocType
9643: oPop 1
9645: oAssign
9646: oJumpForward 9651
9648: Choice Lookup Table
           1   9623
9651: oGetAddrLocal 5
9653: oPushResult
9654: oGetParam 1
9656: oPushResult
9657: oSetResult 23
9659: oPushResult
9660: oNodeGet
9661: oPop 2
9663: oAssign
9664: oGetAddrLocal 6
9666: oPushResult
9667: oGetLocal 5
9669: oPushResult
9670: oSetResult 17
9672: oPushResult
9673: oNodeGetInt
9674: oPop 2
9676: oAssign
9677: oGetLocal 1
9679: oChoice 9701
9681: oEmit 62
9683: oGetLocal 6
9685: oPushResult
9686: oEmitInt
9687: oPop 1
9689: oJumpForward 9707
9691: oEmit 61
9693: oGetLocal 6
9695: oPushResult
9696: oEmitInt
9697: oPop 1
9699: oJumpForward 9707
9701: Choice Lookup Table
           0   9691
           1   9681
9706: oEndChoice
9707: oGetParam 1
9709: oPushResult
9710: oCall 12474
9712: oPop 1
9714: oPushResult
9715: oSetResult 0
9717: oPushResult
9718: greater
9719: oPop 2
9721: oChoice 9754
9723: oEmit 19
9725: oSetResult 0
9727: oPushResult
9728: oEmitInt
9729: oPop 1
9731: oEmit 20
9733: oGetParam 1
9735: oPushResult
9736: oCall 12494
9738: oPop 1
9740: oPushResult
9741: oEmitInt
9742: oPop 1
9744: oSetResult 0
9746: oPushResult
9747: oEmitInt
9748: oPop 1
9750: oEmit 28
9752: oJumpForward 9757
9754: Choice Lookup Table
           1   9723
9757: oGetAddrLocal 7
9759: oPushResult
9760: oGetLocal 5
9762: oPushResult
9763: oSetResult 15
9765: oPushResult
9766: oNodeGetIter
9767: oPop 2
9769: oAssign
9770: oGetAddrLocal 8
9772: oPushResult
9773: oGetLocal 7
9775: oPushResult
9776: oNodeIterValue
9777: oPop 1
9779: oAssign
9780: oInputChoice 9977
9782: oGetLocal 8
9784: oPushResult
9785: oNodeNull
9786: oPop 1
9788: oChoice 9794
9790: oJumpForward 9973
9792: oJumpForward 9797
9794: Choice Lookup Table
           1   9790
9797: oGetAddrLocal 9
9799: oPushResult
9800: oGetLocal 8
9802: oPushResult
9803: oSetResult 22
9805: oPushResult
9806: oNodeGetInt
9807: oPop 2
9809: oAssign
9810: oEmit 19
9812: oGetLocal 9
9814: oPushResult
9815: oEmitInt
9816: oPop 1
9818: oGetLocal 8
9820: oPushResult
9821: oSetResult 21
9823: oPushResult
9824: oNodeGet
9825: oPop 2
9827: oPushResult
9828: oTypeSPush
9829: oPop 1
9831: oGetLocal 8
9833: oPushResult
9834: oSetResult 34
9836: oPushResult
9837: oNodeGetBoolean
9838: oPop 2
9840: oChoice 9926
9842: oSetResult 1
9844: oPushResult
9845: oCall 8064
9847: oPop 1
9849: oCall 7446
9851: oEmit 28
9853: oJumpForward 9932
9855: oCall 4181
9857: oCall 7294
9859: oTypeSNodeType
9860: oChoice 9900
9862: oEmit 26
9864: oJumpForward 9924
9866: oEmit 27
9868: oJumpForward 9924
9870: oError 16
9872: oJumpForward 9924
9874: oEmit 28
9876: oJumpForward 9924
9878: oGetAddrLocal 10
9880: oPushResult
9881: oTypeSTop
9882: oPushResult
9883: oSetResult 17
9885: oPushResult
9886: oNodeGetInt
9887: oPop 2
9889: oAssign
9890: oEmit 29
9892: oGetLocal 10
9894: oPushResult
9895: oEmitInt
9896: oPop 1
9898: oJumpForward 9924
9900: Choice Lookup Table
          40   9878
          38   9878
          36   9878
          35   9874
          34   9874
          28   9870
          33   9866
          30   9866
          31   9866
          41   9862
          29   9862
9923: oEndChoice
9924: oJumpForward 9932
9926: Choice Lookup Table
           0   9855
           1   9842
9931: oEndChoice
9932: oTypeSPop
9933: oGetAddrLocal 7
9935: oPushResult
9936: oNodeIterNext
9937: oPop 1
9939: oGetAddrLocal 8
9941: oPushResult
9942: oGetLocal 7
9944: oPushResult
9945: oNodeIterValue
9946: oPop 1
9948: oAssign
9949: oGetLocal 8
9951: oPushResult
9952: oNodeNull
9953: oPop 1
9955: oChoice 9963
9957: oJumpForward 9973
9959: oJumpForward 9969
9961: oJumpForward 9969
9963: Choice Lookup Table
           0   9961
           1   9957
9968: oEndChoice
9969: oInput 13
9971: oJumpBack 9782
9973: oInput 15
9975: oJumpForward 9980
9977: Choice Lookup Table
          14   9782
9980: oGetLocal 8
9982: oPushResult
9983: oNodeNull
9984: oPop 1
9986: oChoice 9992
9988: oError 15
9990: oJumpForward 9995
9992: Choice Lookup Table
           0   9988
9995: oGetLocal 4
9997: oChoice 10026
9999: oEmit 19
10001: oGetParam 1
10003: oPushResult
10004: oSetResult 31
10006: oPushResult
10007: oNodeGetInt
10008: oPop 2
10010: oPushResult
10011: oEmitInt
10012: oPop 1
10014: oEmit 17
10016: oGetLocal 3
10018: oPushResult
10019: oEmitInt
10020: oPop 1
10022: oEmit 28
10024: oJumpForward 10029
10026: Choice Lookup Table
           1   9999
10029: oGetLocal 1
10031: oChoice 10055
10033: oEmit 65
10035: oGetParam 1
10037: oPushResult
10038: oCall 12540
10040: oPop 1
10042: oJumpForward 10061
10044: oEmit 64
10046: oGetParam 1
10048: oPushResult
10049: oCall 12540
10051: oPop 1
10053: oJumpForward 10061
10055: Choice Lookup Table
           0   10044
           1   10033
10060: oEndChoice
10061: oGetLocal 4
10063: oChoice 10144
10065: oGetLocal 2
10067: oPushResult
10068: oTypeSPush
10069: oPop 1
10071: oTypeSNodeType
10072: oChoice 10118
10074: oEmit 3
10076: oGetLocal 3
10078: oPushResult
10079: oEmitInt
10080: oPop 1
10082: oJumpForward 10142
10084: oEmit 4
10086: oGetLocal 3
10088: oPushResult
10089: oEmitInt
10090: oPop 1
10092: oJumpForward 10142
10094: oError 16
10096: oJumpForward 10142
10098: oEmit 5
10100: oGetLocal 3
10102: oPushResult
10103: oEmitInt
10104: oPop 1
10106: oJumpForward 10142
10108: oEmit 17
10110: oGetLocal 3
10112: oPushResult
10113: oEmitInt
10114: oPop 1
10116: oJumpForward 10142
10118: Choice Lookup Table
          40   10108
          38   10108
          36   10108
          35   10098
          34   10098
          28   10094
          33   10084
          30   10084
          31   10084
          41   10074
          29   10074
10141: oEndChoice
10142: oJumpForward 10147
10144: Choice Lookup Table
           1   10065
10147: oEmit 63
10149: oGetLocal 6
10151: oPushResult
10152: oEmitInt
10153: oPop 1
10155: oReturn
10156: oLocalSpace 2
10158: oGetAddrLocal 2
10160: oPushResult
10161: oGetParam 1
10163: oPushResult
10164: oSetResult 26
10166: oPushResult
10167: oNodeGetString
10168: oPop 2
10170: oAssign
10171: oGetLocal 2
10173: oPushResult
10174: oSetResult 0
10176: oPushResult
10177: equal_string
10178: oPop 2
10180: oChoice 10217
10182: oGetAddrLocal 1
10184: oPushResult
10185: oGetParam 1
10187: oPushResult
10188: oSetResult 4
10190: oPushResult
10191: oNodeGetInt
10192: oPop 2
10194: oPushResult
10195: ID_STRING
10196: oPop 1
10198: oPushResult
10199: oStringAllocLit
10200: oPop 1
10202: oAssign
10203: oJumpForward 10223
10205: oGetAddrLocal 1
10207: oPushResult
10208: oGetLocal 2
10210: oPushResult
10211: oStringAllocLit
10212: oPop 1
10214: oAssign
10215: oJumpForward 10223
10217: Choice Lookup Table
           0   10205
           1   10182
10222: oEndChoice
10223: oEmit 79
10225: oGetParam 1
10227: oPushResult
10228: oCall 12540
10230: oPop 1
10232: oGetLocal 1
10234: oPushResult
10235: oEmitInt
10236: oPop 1
10238: oReturn
10239: oLocalSpace 0
10241: oGetParam 1
10243: oPushResult
10244: oGetGlobal 15
10246: oPushResult
10247: oNodeEqual
10248: oPop 2
10250: oChoice 10290
10252: oInput 14
10254: oCall 4181
10256: oTypeSNodeType
10257: oChoice 10265
10259: oJumpForward 10278
10261: oEmit 30
10263: oJumpForward 10278
10265: Choice Lookup Table
          33   10261
          30   10261
          31   10261
          41   10259
          29   10259
10276: oError 14
10278: oTypeSPop
10279: oGetGlobal 6
10281: oPushResult
10282: oTypeSPush
10283: oPop 1
10285: oInput 15
10287: oReturn
10288: oJumpForward 10293
10290: Choice Lookup Table
           1   10252
10293: oGetParam 1
10295: oPushResult
10296: oGetGlobal 16
10298: oPushResult
10299: oNodeEqual
10300: oPop 2
10302: oChoice 10336
10304: oInput 14
10306: oCall 4181
10308: oTypeSNodeType
10309: oChoice 10317
10311: oEmit 31
10313: oJumpForward 10324
10315: oJumpForward 10324
10317: Choice Lookup Table
          30   10315
          29   10311
10322: oError 14
10324: oTypeSPop
10325: oGetGlobal 9
10327: oPushResult
10328: oTypeSPush
10329: oPop 1
10331: oInput 15
10333: oReturn
10334: oJumpForward 10339
10336: Choice Lookup Table
           1   10304
10339: oGetParam 1
10341: oPushResult
10342: oGetGlobal 17
10344: oPushResult
10345: oNodeEqual
10346: oPop 2
10348: oChoice 10388
10350: oInput 14
10352: oCall 4181
10354: oTypeSNodeType
10355: oChoice 10376
10357: oTypeSTop
10358: oPushResult
10359: oSetResult 44
10361: oPushResult
10362: oNodeGetBoolean
10363: oPop 2
10365: oChoice 10371
10367: oError 28
10369: oJumpForward 10374
10371: Choice Lookup Table
           1   10367
10374: oJumpForward 10381
10376: Choice Lookup Table
          41   10357
10379: oError 14
10381: oEmit 33
10383: oInput 15
10385: oReturn
10386: oJumpForward 10391
10388: Choice Lookup Table
           1   10350
10391: oGetParam 1
10393: oPushResult
10394: oGetGlobal 18
10396: oPushResult
10397: oNodeEqual
10398: oPop 2
10400: oChoice 10440
10402: oInput 14
10404: oCall 4181
10406: oTypeSNodeType
10407: oChoice 10428
10409: oTypeSTop
10410: oPushResult
10411: oSetResult 44
10413: oPushResult
10414: oNodeGetBoolean
10415: oPop 2
10417: oChoice 10423
10419: oError 28
10421: oJumpForward 10426
10423: Choice Lookup Table
           1   10419
10426: oJumpForward 10433
10428: Choice Lookup Table
          41   10409
10431: oError 14
10433: oEmit 32
10435: oInput 15
10437: oReturn
10438: oJumpForward 10443
10440: Choice Lookup Table
           1   10402
10443: oError 16
10445: oReturn
10446: oLocalSpace 1
10448: oGetAddrLocal 1
10450: oPushResult
10451: oGetParam 2
10453: oPushResult
10454: oNodeNew
10455: oPop 1
10457: oAssign
10458: oGetLocal 1
10460: oPushResult
10461: oSetResult 17
10463: oPushResult
10464: oGetParam 1
10466: oPushResult
10467: oNodeSetInt
10468: oPop 3
10470: oGetLocal 1
10472: oPushResult
10473: oTypeAdd
10474: oPop 1
10476: oGetLocal 1
10478: oReturn
10479: oReturn
10480: oLocalSpace 12
10482: oInputChoice 10965
10484: oGetAddrLocal 1
10486: oPushResult
10487: oScopeFindRequire
10488: oAssign
10489: oGetAddrLocal 1
10491: oPushResult
10492: oCall 244
10494: oPop 1
10496: oGetLocal 1
10498: oPushResult
10499: oNodeType
10500: oPop 1
10502: oChoice 10519
10504: oGetParam 1
10506: oPushResult
10507: oGetLocal 1
10509: oPushResult
10510: oSetResult 21
10512: oPushResult
10513: oNodeGet
10514: oPop 2
10516: oAssign
10517: oJumpForward 10530
10519: Choice Lookup Table
          19   10504
10522: oError 2
10524: oGetParam 1
10526: oPushResult
10527: oGetGlobal 6
10529: oAssign
10530: oJumpForward 10988
10532: oInput 16
10534: oGetAddrLocal 2
10536: oPushResult
10537: oNodeVecNew
10538: oAssign
10539: oGetAddrLocal 3
10541: oPushResult
10542: oSetResult 37
10544: oPushResult
10545: oNodeNew
10546: oPop 1
10548: oAssign
10549: oCall 3526
10551: oGetLocal 3
10553: oPushResult
10554: oSetResult 39
10556: oPushResult
10557: oValueTop
10558: oPushResult
10559: oNodeSetInt
10560: oPop 3
10562: oValuePop
10563: oInput 21
10565: oCall 3526
10567: oGetLocal 3
10569: oPushResult
10570: oSetResult 40
10572: oPushResult
10573: oValueTop
10574: oPushResult
10575: oNodeSetInt
10576: oPop 3
10578: oValuePop
10579: oCall 4011
10581: oGetLocal 3
10583: oPushResult
10584: oSetResult 37
10586: oPushResult
10587: oTypeSTop
10588: oPushResult
10589: oNodeSet
10590: oPop 3
10592: oGetLocal 3
10594: oPushResult
10595: oSetResult 17
10597: oPushResult
10598: oTypeSTop
10599: oPushResult
10600: oSetResult 17
10602: oPushResult
10603: oNodeGetInt
10604: oPop 2
10606: oPushResult
10607: oNodeSetInt
10608: oPop 3
10610: oTypeSPop
10611: oGetLocal 3
10613: oPushResult
10614: oTypeAdd
10615: oPop 1
10617: oGetAddrLocal 4
10619: oPushResult
10620: oSetResult 36
10622: oPushResult
10623: oNodeNew
10624: oPop 1
10626: oAssign
10627: oGetLocal 4
10629: oPushResult
10630: oSetResult 38
10632: oPushResult
10633: oGetLocal 3
10635: oPushResult
10636: oNodeSet
10637: oPop 3
10639: oGetLocal 2
10641: oPushResult
10642: oGetLocal 4
10644: oPushResult
10645: oNodeVecAppend
10646: oPop 2
10648: oInputChoice 10656
10650: oJumpForward 10664
10652: oJumpForward 10662
10654: oJumpForward 10662
10656: Choice Lookup Table
          13   10654
          17   10650
10661: oEndChoice
10662: oJumpBack 10539
10664: oInput 40
10666: oGetAddrLocal 5
10668: oPushResult
10669: oCall 10480
10671: oPop 1
10673: oGetAddrLocal 6
10675: oPushResult
10676: oGetLocal 2
10678: oPushResult
10679: oNodeVecSize
10680: oPop 1
10682: oAssign
10683: oGetAddrLocal 6
10685: oPushResult
10686: dec
10687: oPop 1
10689: oGetAddrLocal 7
10691: oPushResult
10692: oGetLocal 2
10694: oPushResult
10695: oGetLocal 6
10697: oPushResult
10698: oNodeVecElement
10699: oPop 2
10701: oAssign
10702: oGetLocal 7
10704: oPushResult
10705: oSetResult 37
10707: oPushResult
10708: oGetLocal 5
10710: oPushResult
10711: oNodeSet
10712: oPop 3
10714: oGetAddrLocal 8
10716: oPushResult
10717: oGetLocal 7
10719: oPushResult
10720: oSetResult 38
10722: oPushResult
10723: oNodeGet
10724: oPop 2
10726: oAssign
10727: oGetAddrLocal 9
10729: oPushResult
10730: oGetLocal 8
10732: oPushResult
10733: oSetResult 40
10735: oPushResult
10736: oNodeGetInt
10737: oPop 2
10739: oPushResult
10740: oGetLocal 8
10742: oPushResult
10743: oSetResult 39
10745: oPushResult
10746: oNodeGetInt
10747: oPop 2
10749: oPushResult
10750: subtract
10751: oPop 2
10753: oAssign
10754: oGetAddrLocal 9
10756: oPushResult
10757: inc
10758: oPop 1
10760: oGetLocal 7
10762: oPushResult
10763: oSetResult 17
10765: oPushResult
10766: oGetLocal 9
10768: oPushResult
10769: oGetLocal 5
10771: oPushResult
10772: oSetResult 17
10774: oPushResult
10775: oNodeGetInt
10776: oPop 2
10778: oPushResult
10779: multiply
10780: oPop 2
10782: oPushResult
10783: oNodeSetInt
10784: oPop 3
10786: oGetLocal 7
10788: oPushResult
10789: oTypeAdd
10790: oPop 1
10792: oGetAddrLocal 5
10794: oPushResult
10795: oGetLocal 7
10797: oAssign
10798: oGetLocal 6
10800: oPushResult
10801: equal_zero
10802: oPop 1
10804: oChoice 10810
10806: oJumpForward 10815
10808: oJumpForward 10813
10810: Choice Lookup Table
           1   10806
10813: oJumpBack 10683
10815: oGetParam 1
10817: oPushResult
10818: oGetLocal 2
10820: oPushResult
10821: oSetResult 0
10823: oPushResult
10824: oNodeVecElement
10825: oPop 2
10827: oAssign
10828: oGetLocal 2
10830: oPushResult
10831: oNodeVecDelete
10832: oPop 1
10834: oJumpForward 10988
10836: oGetAddrLocal 10
10838: oPushResult
10839: oCall 10480
10841: oPop 1
10843: oGetParam 1
10845: oPushResult
10846: oGetLocal 10
10848: oPushResult
10849: oCall 11559
10851: oPop 1
10853: oAssign
10854: oJumpForward 10988
10856: oGetParam 1
10858: oPushResult
10859: oSetResult 38
10861: oPushResult
10862: oNodeNew
10863: oPop 1
10865: oAssign
10866: oSetResult -1
10868: oPushResult
10869: oSetResult 2
10871: oPushResult
10872: oScopeBegin
10873: oPop 2
10875: oSetResult 23
10877: oPushResult
10878: oCall 3227
10880: oPop 1
10882: oGetAddrLocal 11
10884: oPushResult
10885: oScopeCurrent
10886: oPushResult
10887: oSetResult 17
10889: oPushResult
10890: oNodeGetInt
10891: oPop 2
10893: oAssign
10894: oGetLocal 11
10896: oPushResult
10897: equal_zero
10898: oPop 1
10900: oChoice 10906
10902: oError 19
10904: oJumpForward 10909
10906: Choice Lookup Table
           1   10902
10909: oInput 36
10911: oGetFromParam 1
10913: oPushResult
10914: oSetResult 41
10916: oPushResult
10917: oScopeCurrent
10918: oPushResult
10919: oNodeSet
10920: oPop 3
10922: oGetFromParam 1
10924: oPushResult
10925: oSetResult 17
10927: oPushResult
10928: oGetLocal 11
10930: oPushResult
10931: oNodeSetInt
10932: oPop 3
10934: oScopeEnd
10935: oGetFromParam 1
10937: oPushResult
10938: oTypeAdd
10939: oPop 1
10941: oJumpForward 10988
10943: oGetParam 1
10945: oPushResult
10946: oCall 10989
10948: oPop 1
10950: oJumpForward 10988
10952: oInput 40
10954: oGetAddrLocal 12
10956: oPushResult
10957: oCall 10480
10959: oPop 1
10961: oError 16
10963: oJumpForward 10988
10965: Choice Lookup Table
          39   10952
          14   10943
          38   10856
          18   10836
          37   10532
           0   10484
10978: oCall 3526
10980: oInput 21
10982: oCall 3526
10984: oCall 4011
10986: oError 16
10988: oReturn
10989: oLocalSpace 11
10991: oGetParam 1
10993: oPushResult
10994: oSetResult 41
10996: oPushResult
10997: oNodeNew
10998: oPop 1
11000: oAssign
11001: oGetAddrLocal 1
11003: oPushResult
11004: oSetResult 0
11006: oAssign
11007: oGetAddrLocal 2
11009: oPushResult
11010: oSetResult 0
11012: oAssign
11013: oGetAddrLocal 3
11015: oPushResult
11016: oSetResult 1
11018: oAssign
11019: oGetAddrLocal 4
11021: oPushResult
11022: oScopeCurrent
11023: oAssign
11024: oSetResult -1
11026: oPushResult
11027: oSetResult 2
11029: oPushResult
11030: oScopeBegin
11031: oPop 2
11033: oInput 0
11035: oGetAddrLocal 5
11037: oPushResult
11038: oSetResult 17
11040: oPushResult
11041: LAST_ID
11042: oPushResult
11043: oCall 12512
11045: oPop 2
11047: oAssign
11048: oGetAddrLocal 6
11050: oPushResult
11051: oSetResult 17
11053: oPushResult
11054: LAST_ID
11055: oPushResult
11056: oCall 12512
11058: oPop 2
11060: oAssign
11061: oGetLocal 5
11063: oPushResult
11064: oSetResult 21
11066: oPushResult
11067: oGetFromParam 1
11069: oPushResult
11070: oNodeSet
11071: oPop 3
11073: oGetLocal 6
11075: oPushResult
11076: oSetResult 21
11078: oPushResult
11079: oGetFromParam 1
11081: oPushResult
11082: oNodeSet
11083: oPop 3
11085: oGetAddrLocal 7
11087: oPushResult
11088: LAST_ID
11089: oPushResult
11090: ID_STRING
11091: oPop 1
11093: oPushResult
11094: oStringAllocLit
11095: oPop 1
11097: oAssign
11098: oGetLocal 5
11100: oPushResult
11101: oSetResult 32
11103: oPushResult
11104: oGetLocal 7
11106: oPushResult
11107: oNodeSetInt
11108: oPop 3
11110: oGetLocal 6
11112: oPushResult
11113: oSetResult 32
11115: oPushResult
11116: oGetLocal 7
11118: oPushResult
11119: oNodeSetInt
11120: oPop 3
11122: oInputChoice 11200
11124: oGetGlobal 6
11126: oPushResult
11127: oTypeSPush
11128: oPop 1
11130: oCall 3526
11132: oCall 4108
11134: oTypeSPop
11135: oGetLocal 2
11137: oPushResult
11138: equal_zero
11139: oPop 1
11141: oChoice 11162
11143: oValueTop
11144: oPushResult
11145: oGetLocal 1
11147: oPushResult
11148: greater
11149: oPop 2
11151: oChoice 11157
11153: oError 26
11155: oJumpForward 11160
11157: Choice Lookup Table
           0   11153
11160: oJumpForward 11165
11162: Choice Lookup Table
           0   11143
11165: oGetLocal 1
11167: oPushResult
11168: oValueTop
11169: oPushResult
11170: equal
11171: oPop 2
11173: oChoice 11189
11175: oGetFromParam 1
11177: oPushResult
11178: oSetResult 44
11180: oPushResult
11181: oSetResult 1
11183: oPushResult
11184: oNodeSetBoolean
11185: oPop 3
11187: oJumpForward 11192
11189: Choice Lookup Table
           0   11175
11192: oGetAddrLocal 1
11194: oPushResult
11195: oValueTop
11196: oAssign
11197: oValuePop
11198: oJumpForward 11205
11200: Choice Lookup Table
           4   11124
           6   11124
11205: oGetLocal 5
11207: oPushResult
11208: oSetResult 22
11210: oPushResult
11211: oGetLocal 1
11213: oPushResult
11214: oNodeSetInt
11215: oPop 3
11217: oGetLocal 6
11219: oPushResult
11220: oSetResult 22
11222: oPushResult
11223: oGetLocal 1
11225: oPushResult
11226: oNodeSetInt
11227: oPop 3
11229: oGetLocal 5
11231: oPushResult
11232: oScopeDeclare
11233: oPop 1
11235: oGetLocal 4
11237: oPushResult
11238: oScopeEnter
11239: oPop 1
11241: oGetLocal 6
11243: oPushResult
11244: oScopeDeclare
11245: oPop 1
11247: oScopeEnd
11248: oGetAddrLocal 1
11250: oPushResult
11251: inc
11252: oPop 1
11254: oGetAddrLocal 2
11256: oPushResult
11257: inc
11258: oPop 1
11260: oInputChoice 11264
11262: oJumpForward 11269
11264: Choice Lookup Table
          13   11262
11267: oJumpForward 11271
11269: oJumpBack 11033
11271: oInput 15
11273: oGetFromParam 1
11275: oPushResult
11276: oSetResult 41
11278: oPushResult
11279: oScopeCurrent
11280: oPushResult
11281: oNodeSet
11282: oPop 3
11284: oGetFromParam 1
11286: oPushResult
11287: oSetResult 17
11289: oPushResult
11290: oSetResult 4
11292: oPushResult
11293: oNodeSetInt
11294: oPop 3
11296: oScopeEnd
11297: oGetGlobal 2
11299: oPushResult
11300: oCall 12410
11302: oPop 1
11304: oPushResult
11305: oCodePush
11306: oPop 1
11308: oGetGlobal 2
11310: oPushResult
11311: oScopeEnter
11312: oPop 1
11314: oGetAddrLocal 8
11316: oPushResult
11317: oGetLocal 2
11319: oPushResult
11320: oSetResult 1
11322: oPushResult
11323: add
11324: oPop 2
11326: oPushResult
11327: oSetResult 16
11329: oPushResult
11330: multiply
11331: oPop 2
11333: oAssign
11334: oGetAddrLocal 9
11336: oPushResult
11337: oGetLocal 8
11339: oPushResult
11340: oSetResult 8
11342: oPushResult
11343: oScopeAlloc
11344: oPop 2
11346: oAssign
11347: oScopeEnd
11348: oGetFromParam 1
11350: oPushResult
11351: oSetResult 43
11353: oPushResult
11354: oGetLocal 9
11356: oPushResult
11357: oNodeSetInt
11358: oPop 3
11360: oGetAddrLocal 10
11362: oPushResult
11363: oGetFromParam 1
11365: oPushResult
11366: oSetResult 41
11368: oPushResult
11369: oNodeGet
11370: oPop 2
11372: oPushResult
11373: oSetResult 15
11375: oPushResult
11376: oNodeGetIter
11377: oPop 2
11379: oAssign
11380: oGetAddrLocal 11
11382: oPushResult
11383: oGetLocal 10
11385: oPushResult
11386: oNodeIterValue
11387: oPop 1
11389: oAssign
11390: oGetLocal 11
11392: oPushResult
11393: oNodeNull
11394: oPop 1
11396: oChoice 11402
11398: oJumpForward 11489
11400: oJumpForward 11405
11402: Choice Lookup Table
           1   11398
11405: oEmit 16
11407: oGetLocal 9
11409: oPushResult
11410: oEmitInt
11411: oPop 1
11413: oEmit 15
11415: oGetLocal 11
11417: oPushResult
11418: oSetResult 22
11420: oPushResult
11421: oNodeGetInt
11422: oPop 2
11424: oPushResult
11425: oEmitInt
11426: oPop 1
11428: oEmit 26
11430: oGetAddrLocal 9
11432: oPushResult
11433: oGetLocal 9
11435: oPushResult
11436: oSetResult 8
11438: oPushResult
11439: add
11440: oPop 2
11442: oAssign
11443: oEmit 16
11445: oGetLocal 9
11447: oPushResult
11448: oEmitInt
11449: oPop 1
11451: oEmit 16
11453: oGetLocal 11
11455: oPushResult
11456: oSetResult 32
11458: oPushResult
11459: oNodeGetInt
11460: oPop 2
11462: oPushResult
11463: oEmitInt
11464: oPop 1
11466: oEmit 28
11468: oGetAddrLocal 9
11470: oPushResult
11471: oGetLocal 9
11473: oPushResult
11474: oSetResult 8
11476: oPushResult
11477: add
11478: oPop 2
11480: oAssign
11481: oGetAddrLocal 10
11483: oPushResult
11484: oNodeIterNext
11485: oPop 1
11487: oJumpBack 11380
11489: oEmit 16
11491: oGetLocal 9
11493: oPushResult
11494: oEmitInt
11495: oPop 1
11497: oEmit 15
11499: oSetResult 0
11501: oPushResult
11502: oEmitInt
11503: oPop 1
11505: oEmit 26
11507: oGetAddrLocal 9
11509: oPushResult
11510: oGetLocal 9
11512: oPushResult
11513: oSetResult 8
11515: oPushResult
11516: add
11517: oPop 2
11519: oAssign
11520: oEmit 16
11522: oGetLocal 9
11524: oPushResult
11525: oEmitInt
11526: oPop 1
11528: oEmit 15
11530: oSetResult 0
11532: oPushResult
11533: oEmitInt
11534: oPop 1
11536: oEmit 28
11538: oGetAddrLocal 9
11540: oPushResult
11541: oGetLocal 9
11543: oPushResult
11544: oSetResult 8
11546: oPushResult
11547: add
11548: oPop 2
11550: oAssign
11551: oCodePop
11552: oGetFromParam 1
11554: oPushResult
11555: oTypeAdd
11556: oPop 1
11558: oReturn
11559: oLocalSpace 1
11561: oGetAddrLocal 1
11563: oPushResult
11564: oGetParam 1
11566: oPushResult
11567: oSetResult 36
11569: oPushResult
11570: oNodeGet
11571: oPop 2
11573: oAssign
11574: oGetLocal 1
11576: oPushResult
11577: oNodeNull
11578: oPop 1
11580: oChoice 11636
11582: oGetAddrLocal 1
11584: oPushResult
11585: oSetResult 34
11587: oPushResult
11588: oNodeNew
11589: oPop 1
11591: oAssign
11592: oGetLocal 1
11594: oPushResult
11595: oSetResult 37
11597: oPushResult
11598: oGetParam 1
11600: oPushResult
11601: oNodeSet
11602: oPop 3
11604: oGetLocal 1
11606: oPushResult
11607: oSetResult 17
11609: oPushResult
11610: oSetResult 8
11612: oPushResult
11613: oNodeSetInt
11614: oPop 3
11616: oGetLocal 1
11618: oPushResult
11619: oTypeAdd
11620: oPop 1
11622: oGetParam 1
11624: oPushResult
11625: oSetResult 36
11627: oPushResult
11628: oGetLocal 1
11630: oPushResult
11631: oNodeSet
11632: oPop 3
11634: oJumpForward 11639
11636: Choice Lookup Table
           1   11582
11639: oGetLocal 1
11641: oReturn
11642: oReturn
11643: oLocalSpace 2
11645: oGetParam 1
11647: oPushResult
11648: oNodeType
11649: oPop 1
11651: oChoice 11721
11653: oMININT
11654: oReturn
11655: oJumpForward 11737
11657: oSetResult 0
11659: oReturn
11660: oJumpForward 11737
11662: oSetResult 0
11664: oReturn
11665: oJumpForward 11737
11667: oGetAddrLocal 1
11669: oPushResult
11670: oGetParam 1
11672: oPushResult
11673: oSetResult 41
11675: oPushResult
11676: oNodeGet
11677: oPop 2
11679: oAssign
11680: oGetAddrLocal 2
11682: oPushResult
11683: oGetLocal 1
11685: oPushResult
11686: oSetResult 15
11688: oPushResult
11689: oNodeGetIter
11690: oPop 2
11692: oPushResult
11693: oNodeIterValue
11694: oPop 1
11696: oAssign
11697: oGetLocal 2
11699: oPushResult
11700: oSetResult 22
11702: oPushResult
11703: oNodeGetInt
11704: oPop 2
11706: oReturn
11707: oJumpForward 11737
11709: oGetParam 1
11711: oPushResult
11712: oSetResult 39
11714: oPushResult
11715: oNodeGetInt
11716: oPop 2
11718: oReturn
11719: oJumpForward 11737
11721: Choice Lookup Table
          37   11709
          41   11667
          33   11662
          31   11657
          29   11653
11732: oError 3
11734: oSetResult 0
11736: oReturn
11737: oReturn
11738: oLocalSpace 2
11740: oGetParam 1
11742: oPushResult
11743: oNodeType
11744: oPop 1
11746: oChoice 11816
11748: oMAXINT
11749: oReturn
11750: oJumpForward 11832
11752: oSetResult 1
11754: oReturn
11755: oJumpForward 11832
11757: oSetResult 255
11759: oReturn
11760: oJumpForward 11832
11762: oGetAddrLocal 1
11764: oPushResult
11765: oGetParam 1
11767: oPushResult
11768: oSetResult 41
11770: oPushResult
11771: oNodeGet
11772: oPop 2
11774: oAssign
11775: oGetAddrLocal 2
11777: oPushResult
11778: oGetLocal 1
11780: oPushResult
11781: oSetResult 15
11783: oPushResult
11784: oNodeGetIterLast
11785: oPop 2
11787: oPushResult
11788: oNodeIterValue
11789: oPop 1
11791: oAssign
11792: oGetLocal 2
11794: oPushResult
11795: oSetResult 22
11797: oPushResult
11798: oNodeGetInt
11799: oPop 2
11801: oReturn
11802: oJumpForward 11832
11804: oGetParam 1
11806: oPushResult
11807: oSetResult 40
11809: oPushResult
11810: oNodeGetInt
11811: oPop 2
11813: oReturn
11814: oJumpForward 11832
11816: Choice Lookup Table
          37   11804
          41   11762
          33   11757
          31   11752
          29   11748
11827: oError 3
11829: oSetResult 0
11831: oReturn
11832: oReturn
11833: oLocalSpace 5
11835: oGetAddrGlobal 1
11837: oPushResult
11838: oWorkspaceNew
11839: oAssign
11840: oSetResult 0
11842: oPushResult
11843: oSetResult 0
11845: oPushResult
11846: oScopeBegin
11847: oPop 2
11849: oGetAddrLocal 2
11851: oPushResult
11852: oScopeCurrent
11853: oAssign
11854: oCall 12582
11856: oEmit 67
11858: oSetResult 0
11860: oPushResult
11861: oEmitInt
11862: oPop 1
11864: oGetAddrLocal 3
11866: oPushResult
11867: oLabelNew
11868: oAssign
11869: oEmit 61
11871: oSetResult 0
11873: oPushResult
11874: oEmitInt
11875: oPop 1
11877: oEmit 64
11879: oGetLocal 3
11881: oPushResult
11882: oEmitLabel
11883: oPop 1
11885: oEmit 63
11887: oSetResult 0
11889: oPushResult
11890: oEmitInt
11891: oPop 1
11893: oEmit 66
11895: oInput 28
11897: oInput 0
11899: oGetAddrLocal 4
11901: oPushResult
11902: oSetResult 4
11904: oPushResult
11905: oNodeNew
11906: oPop 1
11908: oAssign
11909: oGetLocal 4
11911: oPushResult
11912: oSetResult 4
11914: oPushResult
11915: LAST_ID
11916: oPushResult
11917: oNodeSetInt
11918: oPop 3
11920: oGetGlobal 1
11922: oPushResult
11923: oSetResult 2
11925: oPushResult
11926: oGetLocal 4
11928: oPushResult
11929: oNodeSet
11930: oPop 3
11932: oInputChoice 12006
11934: oInput 0
11936: oGetAddrLocal 1
11938: oPushResult
11939: oSetResult 20
11941: oPushResult
11942: LAST_ID
11943: oPushResult
11944: oCall 12512
11946: oPop 2
11948: oAssign
11949: oGetLocal 1
11951: oPushResult
11952: oSetResult 21
11954: oPushResult
11955: oGetGlobal 5
11957: oPushResult
11958: oNodeSet
11959: oPop 3
11961: oGetLocal 1
11963: oPushResult
11964: oScopeDeclareAlloc
11965: oPop 1
11967: oInput 13
11969: oInput 0
11971: oGetAddrLocal 1
11973: oPushResult
11974: oSetResult 20
11976: oPushResult
11977: LAST_ID
11978: oPushResult
11979: oCall 12512
11981: oPop 2
11983: oAssign
11984: oGetLocal 1
11986: oPushResult
11987: oSetResult 21
11989: oPushResult
11990: oGetGlobal 5
11992: oPushResult
11993: oNodeSet
11994: oPop 3
11996: oGetLocal 1
11998: oPushResult
11999: oScopeDeclareAlloc
12000: oPop 1
12002: oInput 15
12004: oJumpForward 12009
12006: Choice Lookup Table
          14   11934
12009: oInput 5
12011: oGetLocal 4
12013: oPushResult
12014: oCall 34
12016: oPop 1
12018: oInputChoice 12029
12020: oGetLocal 4
12022: oPushResult
12023: oCall 7
12025: oPop 1
12027: oJumpForward 12032
12029: Choice Lookup Table
          59   12020
12032: oGetLocal 4
12034: oPushResult
12035: oCall 287
12037: oPop 1
12039: oSetResult 0
12041: oPushResult
12042: oSetResult 0
12044: oPushResult
12045: oScopeBegin
12046: oPop 2
12048: oGetAddrGlobal 2
12050: oPushResult
12051: oScopeCurrent
12052: oAssign
12053: oSetResult 0
12055: oPushResult
12056: oSetResult 1
12058: oPushResult
12059: oScopeBegin
12060: oPop 2
12062: oScopeCurrent
12063: oPushResult
12064: oSetResult 16
12066: oPushResult
12067: oGetGlobal 2
12069: oPushResult
12070: oNodeSet
12071: oPop 3
12073: oGetAddrGlobal 3
12075: oPushResult
12076: oScopeCurrent
12077: oAssign
12078: oGetLocal 4
12080: oPushResult
12081: oSetResult 7
12083: oPushResult
12084: oGetGlobal 3
12086: oPushResult
12087: oNodeSet
12088: oPop 3
12090: oScopeEnd
12091: oSetResult 21
12093: oPushResult
12094: oCall 12161
12096: oPop 1
12098: oGetGlobal 3
12100: oPushResult
12101: oScopeEnter
12102: oPop 1
12104: oGetAddrLocal 5
12106: oPushResult
12107: oSetResult 1
12109: oAssign
12110: oGetLocal 3
12112: oPushResult
12113: oGetGlobal 2
12115: oPushResult
12116: oGetLocal 5
12118: oPushResult
12119: oCall 12312
12121: oPop 3
12123: oScopeEnd
12124: oInput 20
12126: oCall 12217
12128: oScopeEnd
12129: oGetLocal 4
12131: oPushResult
12132: oCall 349
12134: oPop 1
12136: oReturn
12137: oLocalSpace 0
12139: oGetParam 2
12141: oPushResult
12142: oCall 12161
12144: oPop 1
12146: oGetParam 1
12148: oPushResult
12149: oScopeCurrent
12150: oPushResult
12151: oSetResult 0
12153: oPushResult
12154: oCall 12312
12156: oPop 3
12158: oCall 12217
12160: oReturn
12161: oLocalSpace 0
12163: oInputChoice 12194
12165: oCall 2513
12167: oJumpForward 12209
12169: oCall 3171
12171: oJumpForward 12209
12173: oGetParam 1
12175: oPushResult
12176: oCall 3227
12178: oPop 1
12180: oJumpForward 12209
12182: oCall 3461
12184: oJumpForward 12209
12186: oCall 1736
12188: oJumpForward 12209
12190: oCall 2171
12192: oJumpForward 12209
12194: Choice Lookup Table
          30   12190
          29   12186
          34   12182
          33   12173
          32   12169
          31   12165
12207: oJumpForward 12211
12209: oJumpBack 12163
12211: oCall 12214
12213: oReturn
12214: oLocalSpace 0
12216: oReturn
12217: oLocalSpace 2
12219: oGetAddrLocal 1
12221: oPushResult
12222: oScopeCurrent
12223: oPushResult
12224: oSetResult 15
12226: oPushResult
12227: oNodeGetIter
12228: oPop 2
12230: oAssign
12231: oGetAddrLocal 2
12233: oPushResult
12234: oGetLocal 1
12236: oPushResult
12237: oNodeIterValue
12238: oPop 1
12240: oAssign
12241: oGetLocal 2
12243: oPushResult
12244: oNodeNull
12245: oPop 1
12247: oChoice 12251
12249: oJumpForward 12256
12251: Choice Lookup Table
           0   12249
12254: oJumpForward 12311
12256: oGetLocal 2
12258: oPushResult
12259: oNodeType
12260: oPop 1
12262: oChoice 12300
12264: oGetLocal 2
12266: oPushResult
12267: oSetResult 35
12269: oPushResult
12270: oNodeGetBoolean
12271: oPop 2
12273: oChoice 12295
12275: oGetLocal 2
12277: oPushResult
12278: oSetResult 28
12280: oPushResult
12281: oNodeGetBoolean
12282: oPop 2
12284: oChoice 12290
12286: oError 27
12288: oJumpForward 12293
12290: Choice Lookup Table
           1   12286
12293: oJumpForward 12298
12295: Choice Lookup Table
           0   12275
12298: oJumpForward 12303
12300: Choice Lookup Table
          26   12264
12303: oGetAddrLocal 1
12305: oPushResult
12306: oNodeIterNext
12307: oPop 1
12309: oJumpBack 12231
12311: oReturn
12312: oLocalSpace 3
12314: oEmit 77
12316: oGetParam 3
12318: oPushResult
12319: oEmitLabel
12320: oPop 1
12322: oEmit 67
12324: oGetAddrLocal 1
12326: oPushResult
12327: Here
12328: oAssign
12329: oEmit 90
12331: oGetParam 1
12333: oChoice 12339
12335: oCall 1220
12337: oJumpForward 12342
12339: Choice Lookup Table
           1   12335
12342: oGetAddrLocal 2
12344: oPushResult
12345: oGetParam 2
12347: oPushResult
12348: oSetResult 19
12350: oPushResult
12351: oNodeGetCode
12352: oPop 2
12354: oAssign
12355: oGetLocal 2
12357: oPushResult
12358: oEmitCode
12359: oPop 1
12361: oGetParam 2
12363: oPushResult
12364: oSetResult 19
12366: oPushResult
12367: oSetResult 0
12369: oPushResult
12370: oNodeSetCode
12371: oPop 3
12373: oCall 7624
12375: oGetParam 1
12377: oChoice 12383
12379: oCall 1305
12381: oJumpForward 12386
12383: Choice Lookup Table
           1   12379
12386: oEmit 66
12388: oGetAddrLocal 3
12390: oPushResult
12391: oScopeCurrent
12392: oPushResult
12393: oSetResult 17
12395: oPushResult
12396: oNodeGetInt
12397: oPop 2
12399: oAssign
12400: oGetLocal 1
12402: oPushResult
12403: oGetLocal 3
12405: oPushResult
12406: oPatch
12407: oPop 2
12409: oReturn
12410: oLocalSpace 1
12412: oGetAddrLocal 1
12414: oPushResult
12415: oGetParam 1
12417: oPushResult
12418: oSetResult 19
12420: oPushResult
12421: oNodeGetCode
12422: oPop 2
12424: oAssign
12425: oGetLocal 1
12427: oPushResult
12428: oSetResult 0
12430: oPushResult
12431: equal_code
12432: oPop 2
12434: oChoice 12455
12436: oGetAddrLocal 1
12438: oPushResult
12439: oCodeNew
12440: oAssign
12441: oGetParam 1
12443: oPushResult
12444: oSetResult 19
12446: oPushResult
12447: oGetLocal 1
12449: oPushResult
12450: oNodeSetCode
12451: oPop 3
12453: oJumpForward 12458
12455: Choice Lookup Table
           1   12436
12458: oGetLocal 1
12460: oReturn
12461: oReturn
12462: oLocalSpace 0
12464: oScopeCurrent
12465: oPushResult
12466: oSetResult 14
12468: oPushResult
12469: oNodeGetInt
12470: oPop 2
12472: oReturn
12473: oReturn
12474: oLocalSpace 0
12476: oGetParam 1
12478: oPushResult
12479: oSetResult 20
12481: oPushResult
12482: oNodeGet
12483: oPop 2
12485: oPushResult
12486: oSetResult 14
12488: oPushResult
12489: oNodeGetInt
12490: oPop 2
12492: oReturn
12493: oReturn
12494: oLocalSpace 0
12496: oCall 12462
12498: oPushResult
12499: oGetParam 1
12501: oPushResult
12502: oCall 12474
12504: oPop 1
12506: oPushResult
12507: subtract
12508: oPop 2
12510: oReturn
12511: oReturn
12512: oLocalSpace 1
12514: oGetAddrLocal 1
12516: oPushResult
12517: oGetParam 2
12519: oPushResult
12520: oNodeNew
12521: oPop 1
12523: oAssign
12524: oGetLocal 1
12526: oPushResult
12527: oSetResult 4
12529: oPushResult
12530: oGetParam 1
12532: oPushResult
12533: oNodeSetInt
12534: oPop 3
12536: oGetLocal 1
12538: oReturn
12539: oReturn
12540: oLocalSpace 0
12542: oGetParam 1
12544: oPushResult
12545: oSetResult 22
12547: oPushResult
12548: oNodeGetInt
12549: oPop 2
12551: oPushResult
12552: oEmitInt
12553: oPop 1
12555: oReturn
12556: oLocalSpace 1
12558: oGetAddrLocal 1
12560: oPushResult
12561: oSetResult 14
12563: oPushResult
12564: oGetParam 1
12566: oPushResult
12567: oCall 12512
12569: oPop 2
12571: oAssign
12572: oGetLocal 1
12574: oPushResult
12575: oScopeDeclare
12576: oPop 1
12578: oGetLocal 1
12580: oReturn
12581: oReturn
12582: oLocalSpace 1
12584: oGetAddrGlobal 4
12586: oPushResult
12587: oId_mysystem
12588: oAssign
12589: oGetAddrGlobal 5
12591: oPushResult
12592: oSetResult 28
12594: oPushResult
12595: oSetResult 4
12597: oPushResult
12598: oCall 10446
12600: oPop 2
12602: oAssign
12603: oGetAddrGlobal 6
12605: oPushResult
12606: oSetResult 29
12608: oPushResult
12609: oSetResult 4
12611: oPushResult
12612: oCall 10446
12614: oPop 2
12616: oAssign
12617: oGetAddrGlobal 7
12619: oPushResult
12620: oSetResult 31
12622: oPushResult
12623: oSetResult 1
12625: oPushResult
12626: oCall 10446
12628: oPop 2
12630: oAssign
12631: oGetAddrGlobal 8
12633: oPushResult
12634: oSetResult 32
12636: oPushResult
12637: oSetResult 1
12639: oPushResult
12640: oCall 10446
12642: oPop 2
12644: oAssign
12645: oGetAddrGlobal 9
12647: oPushResult
12648: oSetResult 33
12650: oPushResult
12651: oSetResult 1
12653: oPushResult
12654: oCall 10446
12656: oPop 2
12658: oAssign
12659: oGetAddrGlobal 10
12661: oPushResult
12662: oGetGlobal 9
12664: oPushResult
12665: oCall 11559
12667: oPop 1
12669: oAssign
12670: oGetAddrGlobal 11
12672: oPushResult
12673: oSetResult 30
12675: oPushResult
12676: oSetResult 1
12678: oPushResult
12679: oCall 10446
12681: oPop 2
12683: oAssign
12684: oGetAddrGlobal 12
12686: oPushResult
12687: oSetResult 35
12689: oPushResult
12690: oSetResult 8
12692: oPushResult
12693: oCall 10446
12695: oPop 2
12697: oAssign
12698: oGetGlobal 12
12700: oPushResult
12701: oSetResult 37
12703: oPushResult
12704: oGetGlobal 11
12706: oPushResult
12707: oNodeSet
12708: oPop 3
12710: oGetAddrGlobal 13
12712: oPushResult
12713: oSetResult 39
12715: oPushResult
12716: oSetResult 256
12718: oPushResult
12719: oCall 10446
12721: oPop 2
12723: oAssign
12724: oGetAddrGlobal 14
12726: oPushResult
12727: oSetResult 40
12729: oPushResult
12730: oSetResult 256
12732: oPushResult
12733: oCall 10446
12735: oPop 2
12737: oAssign
12738: oGetGlobal 14
12740: oPushResult
12741: oSetResult 42
12743: oPushResult
12744: oSetResult 255
12746: oPushResult
12747: oNodeSetInt
12748: oPop 3
12750: oGetAddrLocal 1
12752: oPushResult
12753: oSetResult 19
12755: oPushResult
12756: oId_File
12757: oPushResult
12758: oCall 12512
12760: oPop 2
12762: oAssign
12763: oGetLocal 1
12765: oPushResult
12766: oSetResult 21
12768: oPushResult
12769: oGetGlobal 5
12771: oPushResult
12772: oNodeSet
12773: oPop 3
12775: oGetLocal 1
12777: oPushResult
12778: oScopeDeclare
12779: oPop 1
12781: oGetAddrLocal 1
12783: oPushResult
12784: oSetResult 19
12786: oPushResult
12787: oId_Integer
12788: oPushResult
12789: oCall 12512
12791: oPop 2
12793: oAssign
12794: oGetLocal 1
12796: oPushResult
12797: oSetResult 21
12799: oPushResult
12800: oGetGlobal 6
12802: oPushResult
12803: oNodeSet
12804: oPop 3
12806: oGetLocal 1
12808: oPushResult
12809: oScopeDeclare
12810: oPop 1
12812: oGetAddrLocal 1
12814: oPushResult
12815: oSetResult 19
12817: oPushResult
12818: oId_Boolean
12819: oPushResult
12820: oCall 12512
12822: oPop 2
12824: oAssign
12825: oGetLocal 1
12827: oPushResult
12828: oSetResult 21
12830: oPushResult
12831: oGetGlobal 7
12833: oPushResult
12834: oNodeSet
12835: oPop 3
12837: oGetLocal 1
12839: oPushResult
12840: oScopeDeclare
12841: oPop 1
12843: oGetAddrLocal 1
12845: oPushResult
12846: oSetResult 19
12848: oPushResult
12849: oId_Char
12850: oPushResult
12851: oCall 12512
12853: oPop 2
12855: oAssign
12856: oGetLocal 1
12858: oPushResult
12859: oSetResult 21
12861: oPushResult
12862: oGetGlobal 9
12864: oPushResult
12865: oNodeSet
12866: oPop 3
12868: oGetLocal 1
12870: oPushResult
12871: oScopeDeclare
12872: oPop 1
12874: oGetAddrLocal 1
12876: oPushResult
12877: oSetResult 19
12879: oPushResult
12880: oId_Byte
12881: oPushResult
12882: oCall 12512
12884: oPop 2
12886: oAssign
12887: oGetLocal 1
12889: oPushResult
12890: oSetResult 21
12892: oPushResult
12893: oGetGlobal 11
12895: oPushResult
12896: oNodeSet
12897: oPop 3
12899: oGetLocal 1
12901: oPushResult
12902: oScopeDeclare
12903: oPop 1
12905: oGetAddrLocal 1
12907: oPushResult
12908: oSetResult 19
12910: oPushResult
12911: oId_Pointer
12912: oPushResult
12913: oCall 12512
12915: oPop 2
12917: oAssign
12918: oGetLocal 1
12920: oPushResult
12921: oSetResult 21
12923: oPushResult
12924: oGetGlobal 12
12926: oPushResult
12927: oNodeSet
12928: oPop 3
12930: oGetLocal 1
12932: oPushResult
12933: oScopeDeclare
12934: oPop 1
12936: oGetAddrLocal 1
12938: oPushResult
12939: oSetResult 19
12941: oPushResult
12942: oId_ShortString
12943: oPushResult
12944: oCall 12512
12946: oPop 2
12948: oAssign
12949: oGetLocal 1
12951: oPushResult
12952: oSetResult 21
12954: oPushResult
12955: oGetGlobal 14
12957: oPushResult
12958: oNodeSet
12959: oPop 3
12961: oGetLocal 1
12963: oPushResult
12964: oScopeDeclare
12965: oPop 1
12967: oGetAddrLocal 1
12969: oPushResult
12970: oSetResult 16
12972: oPushResult
12973: oId_True
12974: oPushResult
12975: oCall 12512
12977: oPop 2
12979: oAssign
12980: oGetLocal 1
12982: oPushResult
12983: oSetResult 21
12985: oPushResult
12986: oGetGlobal 7
12988: oPushResult
12989: oNodeSet
12990: oPop 3
12992: oGetLocal 1
12994: oPushResult
12995: oSetResult 22
12997: oPushResult
12998: oSetResult 1
13000: oPushResult
13001: oNodeSetInt
13002: oPop 3
13004: oGetLocal 1
13006: oPushResult
13007: oScopeDeclare
13008: oPop 1
13010: oGetAddrLocal 1
13012: oPushResult
13013: oSetResult 16
13015: oPushResult
13016: oId_False
13017: oPushResult
13018: oCall 12512
13020: oPop 2
13022: oAssign
13023: oGetLocal 1
13025: oPushResult
13026: oSetResult 21
13028: oPushResult
13029: oGetGlobal 7
13031: oPushResult
13032: oNodeSet
13033: oPop 3
13035: oGetLocal 1
13037: oPushResult
13038: oSetResult 22
13040: oPushResult
13041: oSetResult 0
13043: oPushResult
13044: oNodeSetInt
13045: oPop 3
13047: oGetLocal 1
13049: oPushResult
13050: oScopeDeclare
13051: oPop 1
13053: oGetAddrLocal 1
13055: oPushResult
13056: oSetResult 16
13058: oPushResult
13059: oId_Nil
13060: oPushResult
13061: oCall 12512
13063: oPop 2
13065: oAssign
13066: oGetLocal 1
13068: oPushResult
13069: oSetResult 21
13071: oPushResult
13072: oGetGlobal 12
13074: oPushResult
13075: oNodeSet
13076: oPop 3
13078: oGetLocal 1
13080: oPushResult
13081: oSetResult 22
13083: oPushResult
13084: oSetResult 0
13086: oPushResult
13087: oNodeSetInt
13088: oPop 3
13090: oGetLocal 1
13092: oPushResult
13093: oScopeDeclare
13094: oPop 1
13096: oGetAddrGlobal 15
13098: oPushResult
13099: oId_Ord
13100: oPushResult
13101: oCall 12556
13103: oPop 1
13105: oAssign
13106: oGetAddrGlobal 16
13108: oPushResult
13109: oId_Chr
13110: oPushResult
13111: oCall 12556
13113: oPop 1
13115: oAssign
13116: oGetAddrGlobal 17
13118: oPushResult
13119: oId_Pred
13120: oPushResult
13121: oCall 12556
13123: oPop 1
13125: oAssign
13126: oGetAddrGlobal 18
13128: oPushResult
13129: oId_Succ
13130: oPushResult
13131: oCall 12556
13133: oPop 1
13135: oAssign
13136: oReturn
