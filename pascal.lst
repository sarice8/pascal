   2: title: 'Pascal Compiler 1.1.5 -- Jan 01 ''90';
         
      %
      %  Pascal.ssl
      %
      %  Pascal Compiler for the Amiga, by Steve Rice.
      %
      %  HISTORY
      %    11Sep89   First version, framework of parser.
      %    18Sep89   Added some semantic mechanisms.
      %    21Sep89   Added simple type references; expressions generate code.
      %    22Sep89   Allocate variable addresses as they're declared.
      %    24Sep89   Added arrays, pointers.
      %    27Sep89   Added for statement.
      %    23Oct89   Fixed for statement, so CYCLE goes to next step.
      %    01Jan90   Added string literals
      %    09Sep22   I have returned.  Migrate symbol table to schema, to ease development.
      %    01Oct22   Language: Switch from cycle/exit (Mac Pascal extension) to continue/break (Borland).
      %
      %  NOTES
      %    -  The 'value' of a var symbol is its allocated address.
      %    -  References to vars of intrinsic types, and pointer types,
      %       pushes the value of the var on the expr stack.  Referenecs to
      %       vars of compound types (arrays, records...) pushes the address
      %       on the expr stack.
      %    -  Just as there is only one type table entry for a given (named) type,
      %       there is only one type table entry for a pointer to a named type.
      %       When a pointer type is declared, a field in the TT entry of the
      %       type pointed to will be set to indicate the TT entry of the pointer
      %       to that type (0 means none defined yet).  When evaluating the
      %       expression ^x, the type in that field in the entry for the type of x
      %       will be used (unless it's 0, in which case a new TT entry will be
      %       created).
      %
      %
      %  MISSING
      %
      %    - Forward declaration of proceudres and functions.
      %      Only one forward declaration should be allowed.
      %      I will overwrite the nMethod info with the final addr and param names when the true body is seen.
      %      If a call is made to a foward declared method, add the forward decl node & Here to patch table.
      % 
      %    - procedure and function declarations may be nested within other procs/funcs!
      %      They are allowed to see locals within those parent scopes.
      %      Pass a hidden parameter to nested methods, to follow up to parent scopes as needed.
      %      Need a level counter at each scope, and uplevels count on reference to local/param.
      %      
      %    - Consider non-ISO extensions.  e.g. see "Units" e.g. from Turbo Pascal wikipedia page.
      %      Dynamic arrays.  Objects.  But, perhaps stick to my old goal, standard Pascal.
      %
      %
      %  PASCAL DOCS
      %      Here's some handy language material:
      %      https://www.freepascal.org/docs-html/ref/ref.html
      %      https://www.freepascal.org/docs-html/prog/prog.html
      %      https://en.wikipedia.org/wiki/Turbo_Pascal
      %      https://en.wikipedia.org/wiki/Pascal_(programming_language)#Standards
      %      http://www.standardpascaline.org/
      %
      
   2: input:
   2:    pIdent
   2:    pIntLit
   2:    pStrLit
   2:    pAssign       ':='
   2:    pSemiColon    ';'
   2:    pEqual        '='
   2:    pNotEqual     '<>'
   2:    pLess         '<'
   2:    pGreater      '>'
   2:    pLessEqual    '<='
   2:    pGreaterEqual '>='
   2:    pColon        ':'
   2:    pComma        ','
   2:    pLParen       '('
   2:    pRParen       ')'
   2:    pLSquare      '['
   2:    pRSquare      ']'
   2:    pCarat        '^'
   2:    pAt           '@'
   2:    pDot          '.'
   2:    pDotDot       '..'
   2:    pTimes        '*'
   2:    pDivide       '/'
   2:    pPlus         '+'
   2:    pMinus        '-'
   2:    pEof
   2:    pInvalid
      
      %  keywords  (built-in types 'integer', 'char', etc, are not keywords,
      %             type constructors 'array', 'record', 'set' are keywords,
      %             pseudo-procedures 'writeln', 'readln' are keywords)
      %
      %             forward/external/name/cdecl appear in method modifiers, in fpc grammar.
      %             I'm making them keywords to simplify parsing, but could reconsider.
      
   2:    pProgram
   2:    pProcedure
   2:    pFunction
   2:    pConst
   2:    pType
   2:    pVar
   2:    pBegin
   2:    pEnd
   2:    pArray
   2:    pRecord
   2:    pSet
   2:    pOf
   2:    pIf
   2:    pThen
   2:    pElse
   2:    pFor
   2:    pTo
   2:    pDownto
   2:    pDo
   2:    pWhile
   2:    pRepeat
   2:    pUntil
   2:    pContinue
   2:    pBreak
   2:    pReturn
   2:    pAnd
   2:    pOr
   2:    pNot
   2:    pWriteln
   2:    pWrite
   2:    pReadln
   2:    pRead
   2:    pForward
   2:    pExternal
   2:    pName
   2:    pCdecl
   2:    ;
      
      
   2: output:
      
      %  Instructions for a stack machine (all vars are 32-bit integers)
      
   2:    tPushGlobalI      % <ptr> - push int value read from ptr
   2:    tPushGlobalB      % <ptr> - push byte value read from ptr
   2:    tPushGlobalP      % <ptr> - push ptr value read from ptr
   2:    tPushLocalI       % <offset> - push int value read from local var
   2:    tPushLocalB       % <offset> - push byte value read from local var
   2:    tPushLocalP       % <offset> - push ptr value read from local var
   2:    tPushParamI       % <offset> - push int value read from local var
   2:    tPushParamB       % <offset> - push byte value read from local var
   2:    tPushParamP       % <offset> - push ptr value read from local var
      
   2:    tPushConstI       % <int> - push int value on stack (NOTE, used for BOOLEAN too)
   2:    tPushAddrGlobal   % <offset> - push ptr to global var (same as tPushConstP)
   2:    tPushAddrLocal    % <offset> - push ptr to local var
   2:    tPushAddrParam    % <offset> - push ptr to formal param (used by method to see its param)
   2:    tPushAddrActual   % <offset> - push ptr to actual param, in actuals space (used by caller)
   2:    tFetchI           % pop ptr from stack, and push int value it points to
   2:    tFetchB           %    "      "      "     "     byte  "   "    "
   2:    tFetchP           %    "      "      "     "     ptr   "   "    "   
   2:    tAssignI          % assign int value on top of stack to addr under it (pop both)
   2:    tAssignB          %   "    byte   "    "   "  "   "    "    "   "   "
   2:    tAssignP          %   "    ptr    "    "   "  "   "    "    "   "   "
   2:    tCopy             % <#bytes> - copy bytes.  tos=src, 2nd=dest (pop 2)
   2:    tIncI             % increment int value on top of expr stack
   2:    tDecI             % decrement int value on top of expr stack
   2:    tMultI            % multiply top two integers (replacing with result)
   2:    tDivI
   2:    tAddPI            % add ptr (2nd value) and int (top value), resulting in a ptr
   2:    tAddI
   2:    tSubI
   2:    tNegI             % top entry *= -1
   2:    tNot              % negate top boolean
   2:    tEqualI           % top two entries equal? (pop 2, push 1) (true=1)
   2:    tNotEqualI        %    NOTE, these all work for booleans too
   2:    tGreaterI         % 2nd entry greater than top entry? (pop 2, push answer)
   2:    tLessI  
   2:    tGreaterEqualI
   2:    tLessEqualI
   2:    tEqualP           % two two pointer values equal? (pop 2, push 1) (true=1)
   2:    tNotEqualP
   2:    tAllocActuals     % <#bytes> - make space on call stack for actual params (adjusting call stack sp)
   2:    tFreeActuals      % <#bytes> - discard space on call stack allocated by tAllocActuals
   2:    tCall             % <label#>
   2:    tReturn
   2:    tEnter            % <#bytes> - start a stack frame on the call stack, reserving #bytes of local variable space
   2:    tJump             % <label#>
   2:    tJumpTrue         % <label#>  (pops top of stack, jumps if true)
   2:    tJumpFalse        % <label#>  (pops top of stack, jumps if false)
   2:    tLabel            % <label#> - define label# at the current address
   2:    tLabelAlias       % <label#> <aliasToLabel#> - defines label to be an alias of another label
   2:    tWriteI           % for writeln : write integer on tos, pop
   2:    tWriteBool        %  "     "    : write TRUE/FALSE, pop
   2:    tWriteStr         %  "     "    : write string whose addr is on tos, pop
   2:    tWriteP           %  "     "    : write ptr var whose addr is on tos, pop
   2:    tWriteCR          %  "     "    : write cr
      
      %  Other:
      
   2:    tSpace            % emit a hole, to be patched later
   2:    ;
      
   2: error:
   2:    eBadStatement
   2:    eNotConst
   2:    eNotType
   2:    eNotOrdinalType
   2:    eNotVar
   2:    eNotIntVar
   2:    eNotValue
   2:    eNotInteger
   2:    eNotBoolean
   2:    eNotPointer
   2:    eNotArray
   2:    eNotRecord
   2:    eNotRecordField
   2:    eTooManySubscripts
   2:    eTypeMismatch
   2:    eMissingParameter
   2:    eNotImplemented
   2:    eNotAllowed
   2:    eNotInALoop
   2:    eRecordEmpty
   2:    eNotCurrentFunction
   2:    eAlreadyDefined
   2:    ;
      
   2: include 'pascal_schema.ssl'
      
      % Generated automatically by schema
      
   2: type node_type:
   2: 	nINVALID
   2: 	Object
   2: 	nScope
   2: 	nDeclaration
   2: 	nIdent
   2: 	nProgram
   2: 	nMethod
   2: 	nProc
   2: 	nFunc
   2: 	nConst
   2: 	nTypeDecl
   2: 	nVar
   2: 	nGlobalVar
   2: 	nLocalVar
   2: 	nRecordField
   2: 	nParam
   2: 	nType
   2: 	nFileType
   2: 	nIntegerType
   2: 	nBooleanType
   2: 	nBooleanCFType
   2: 	nCharType
   2: 	nStringType
   2: 	nPointerType
   2: 	nArrayType
   2: 	nSubrangeType
   2: 	nRecordType
   2: 	nEnumType
   2: 	nSetType
   2: 	;
      
   2: type node_attribute:
   2: 	qINVALID
   2: 	qDecls
   2: 	qSize
   2: 	qAllocDown
   2: 	qIdent
   2: 	qType
   2: 	qValue
   2: 	qMainRoutineScope
   2: 	qParams
   2: 	qChildScope
   2: 	qBodyDefined
   2: 	qExternal
   2: 	qCdecl
   2: 	qOldParams
   2: 	qOldType
   2: 	qResultOffset
   2: 	qInOut
   2: 	qPointerType
   2: 	qBaseType
   2: 	qIndexType
   2: 	qLow
   2: 	qHigh
   2: 	qScope
   2: 	;
      
      
   2: type Node:     % A pointer to a node in the schema database (symbol database)
   2:     Null = 0
   2:     ;
      
   2: type NodeVec:  % A pointer to a vector of Node.  See mechanism node_vec_mech
   2:     NullVec = 0
   2:     ;
      
   2: type boolean:
   2:    false    = 0
   2:    true     = 1;
      
   2: type kind:           % kind of identifier
   2:    kUndefined        % not yet added to symbol table
   2:    kProgram
   2:    kProc
   2:    kFunc
   2:    kConst
   2:    kType
   2:    kVar;
      
      % intrinsic types & type constructs
      
   2: type typ:
   2:    tyNone     = 0    % in ptrTyp field of TT, means no ptr to type defined
   2:    tyInteger
   2:    tyBoolean
   2:    tyChar
   2:    tyString
   2:    tyFile            % tyInteger..tyFile are scalars (types on their own)
   2:    tyPointer         % following are type constructor classes...
   2:    tyArray           %   (they are not type#'s)
   2:    tyRecord
   2:    tyParams          % like record; a collection of proc/func params
   2:    tySet;
      
   2: type Label:
   2:    labelNull;
      
      
      % Some general schema node operations.
      % node_type and node_attribute are defined in generated file pascal_schema.ssl included above.
      %
   2: mechanism node_mech:
   2:     oNodeNew (node_type) >> Node         % create new node
   2:     oNodeSet (Node, node_attribute, Node)   % set Node attribute of node
   2:     oNodeSetInt (Node, node_attribute, int) % set int attribute of node
   2:     oNodeSetBoolean (Node, node_attribute, boolean)
   2:     oNodeSetKind (Node, node_attribute, kind) % set attribute of node  *** MIGHT NOT NEED
   2:     oNodeSetLabel( Node, node_attribute, Label )  % set Label attribute of node
   2:     oNodeGet (Node, node_attribute) >> Node    % get Node attribute of node
   2:     oNodeGetInt (Node, node_attribute) >> int  % get int attribute of node
   2:     oNodeGetBoolean (Node, node_attribute) >> boolean  % get int attribute of node
   2:     oNodeGetLabel (Node, node_attribute) >> Label      % get Label attribute of node
   2:     oNodeNull (Node) >> boolean          % is node null?
   2:     oNodeNext (inout Node)               % advance Node to next in list
   2:     oNodeType (Node) >> node_type        % return node type of node
   2:     oNodeEqual (Node, Node) >> boolean   % compare two nodes for equality
                                               % (i.e. same node, not just same contents)
   2:     ;
      
      
      % Manipulate a temporary vector of Node
      %
   2: mechanism node_vec_mech:
   2:     oNodeVecNew >> NodeVec
   2:     oNodeVecDelete( NodeVec nv )
   2:     oNodeVecAppend( NodeVec nv, Node n )
   2:     oNodeVecSize( NodeVec nv ) >> int                % how many elements
   2:     oNodeVecElement( NodeVec nv, int idx ) >> Node   % element at index idx (0..size-1)
   2:     ;
      
      
      
   2: mechanism emit_mech:
   2:     oEmitInt( int )              % emit int into the generated code
   2:     oEmitLabel( Label )
   2:     Here >> int                  % current address in the generated code
   2:     oPatch( int addr, int val )  % patch an int into address in the generated code
   2:     ;
      
   2: mechanism math:
   2:     inc (inout int)
   2:     dec (inout int)
   2:     negate (int) >> int
   2:     subtract( int x, int y ) >> int     % x - y
   2:     multiply( int x, int y ) >> int     % x * y
   2:     equal( int x, int y ) >> boolean
   2:     equal_zero (int) >> boolean
   2:     equal_node_type (node_type, node_type) >> boolean     % Want equal_<type> for every type
   2:     equal_label( Label, Label ) >> boolean
   2:     oMININT >> int    % the minimum 32-bit integer.  necessary because ssl literal ints are currently (silently) short (!)
   2:     ;
      
   2: mechanism more_builtins:      % These should be built-in SSL operations
   2:     TOKEN_VALUE >> int        % value of just accepted token, e.g. IntLit token
   2:     LAST_ID >> int            % id number of last accepted identifier
   2:     ;
      
   2: mechanism scope_mech:
   2:     oScopeBegin                          % create a new scope. Subsequent declarations will go here.
   2:     oScopeEnter( Node scope )            % enter an existing scope.
   2:     oScopeEnd                            % end current scope. Subsequent declarations will go to previous scope.
   2:     oScopeCurrent >> Node                % returns current scope
   2:     oScopeDeclare( Node decl )           % add declaration to current scope.
   2:     oScopeDeclareAlloc( Node decl )      % add declaration to current scope, and allocate space according to its type
   2:     oScopeAllocType( Node theType ) >> int   % allocate space for type in current scope, and return its address
   2:     oScopeFind >> Node                   % find declaration of last accepted identifier.  Returns Null if not found.
   2:     oScopeFindRequire >> Node            % find declaration of last accepted identifier.  Error if not found.
   2:     oScopeFindInCurrentScope >> Node     % find declaration of last accepted identifier, only within the current scope.  Null if not found.
   2:     ;
      
      
   2: mechanism type_mech:
   2:     oTypeAdd( Node node )     % add the given nType to the type table
   2:     ;
      
   2: mechanism type_stack_mech:
   2:     oTypeSPush( Node node )
   2:     oTypeSPop
   2:     oTypeSTop >> Node
   2:     oTypeSNodeType >> node_type          % node_type of the node on top of type stack, skipping subranges
   2:     ;
      
      
   2: mechanism id_mech:
          % adds a predefined id to the scanner's id table, and returns the id code
   2:     oIdAdd_File >> int
   2:     oIdAdd_Integer >> int
   2:     oIdAdd_Boolean >> int
   2:     oIdAdd_Char >> int
   2:     oIdAdd_String >> int
   2:     oIdAdd_True >> int
   2:     oIdAdd_False >> int
   2:     ;
      
      
      
   2: mechanism label_mech:
   2:    oLabelNew >> Label
   2:    ;
      
   2: mechanism count :
   2:    oCountPush(int)          % start a new counter, with initial value
   2:    oCountInc
   2:    oCountDec
   2:    oCountIsZero >> boolean
   2:    oCountPop;
      
      
   2: mechanism value :              % value stack, to calc. const expr's
   2:    oValuePush(int)             % push an explicit int lit
   2:    oValueNegate                % negate top value
   2:    oValueTop >> int            % get top value on value stack
   2:    oValuePop;
      
   2: mechanism string :
   2:    oStringAllocLit;            % alloc data space for strlit, push address
                                     %   on value stack
      
      % track labels for the loop we're in, if any
   2: mechanism loop_mech:
   2:    oLoopPush( Label continueLabel, Label breakLabel )
   2:    oLoopContinueLabel >> Label
   2:    oLoopBreakLabel >> Label
   2:    oLoopPop
   2:    ;
      
      % for hacky debugging
   2: mechanism msg_mech:
   2:    oMsg( int num )             % print message "oMsg <num>"
   2:    oMsgTrace( int num )        % print message "oMsg <num>" followed by ssl traceback
   2:    oMsgNode( Node node )       % print node
   2:    oMsgNodeVec( NodeVec vec )  % print node vec
   2:    ;
      
      
   2: rules
      
      % ----------------------------- Global Variables ----------------------------
      
   2: Node    globalScope            % global nScope
      
      % built-in nTypes
   2: Node    FileType
   2: Node    IntegerType
   2: Node    BooleanType
   2: Node    BooleanCFType
   2: Node    CharType
   2: Node    StringType
      
      % -------------------------- Forward Declarations -------------------------
      
   2: Block( node_type varNodeType, Label labelForBody );
   2: BlockDecls( node_type varNodeType );
   2: BlockStmt( Label labelForBody );
   2: VarDecl( node_type varNodeType );
   2: newType( node_type nt, int size ) >> Node;
   2: newIdent( node_type nt, kind k, int id ) >> Node;
   2: EmitValue( Node decl );
   2: TypeRef( out Node theType );
   2: PointerTypeTo( Node theType ) >> Node;
   2: OrdinalLow( Node theType ) >> int;
   2: AssignStmt( Node decl );
   2: BooleanExprControlFlow( out Label falseLabel );
   2: ExprAllowCF( out Label falseLabel );
   2: BoolExprAllowCF( out Label falseLabel );
   2: BoolTermAllowCF( out Label falseLabel );
   2: BoolFactorAllowCF( out Label falseLabel );
   2: ArithExprAllowCF( out Label falseLabel );
   2: TermAllowCF( out Label falseLabel );
   2: FactorAllowCF( out Label falseLabel );
   2: PrimaryAllowCF( out Label falseLabel );
      
      
      
   2: VarExpr( Node decl );
   2: LValueVar( Node decl );
   2: IncVar( Node decl );
   2: DecVar( Node decl );
      
   2: CFToVal( inout Label falseLabel );
   2: ValToCF( out Label falseLabel );
      
      % ----------------------------- Declarations ----------------------------
      
   2: Program:
   4:    Node t
      
   4:    oScopeBegin
   5:    globalScope = oScopeCurrent
      
  10:    @installBuiltIns
      
         % Start by calling the main program routine
  12:    Label mainLabel = oLabelNew
      
  17:    .tCall  oEmitLabel( mainLabel )
  25:    .tReturn
      
  27:    pProgram
  29:    pIdent
      
  31:    Node progDecl = @newIdent( nProgram, kProgram, LAST_ID )
  47:    oScopeDeclare( progDecl )
      
  53:    [
  53:       | '(' :
  55:          pIdent      % input, output files
      
  57:          t = @newIdent( nVar, kVar, LAST_ID )
  73:          oNodeSet( t, qType, FileType )
  85:          oScopeDeclareAlloc( t )
      
  91:          ','
  93:          pIdent
      
  95:          t = @newIdent( nVar, kVar, LAST_ID )
 111:          oNodeSet( t, qType, FileType )
 123:          oScopeDeclareAlloc( t )
      
 129:          ')'
 131:       | * :
 136:    ]
 136:    ';'
      
 138:    @BlockDecls( nGlobalVar )
      
         % a new scope just for temporaries in the main routine
 145:    oScopeBegin
 146:    oNodeSetBoolean( oScopeCurrent, qAllocDown, true )
 157:    oNodeSet( progDecl, qMainRoutineScope, oScopeCurrent )
      
         % The block statement includes a stack frame, and enter/return,
         % even for the main routine.
         % That will be necessary for temporaries allocated in the main routine.
 168:    @BlockStmt( mainLabel )
      
 175:    oScopeEnd   % main routine scope
      
 176:    '.'
 178:    oScopeEnd   % global scope
 180:    ;
      
      
 180: Block( node_type varNodeType, Label labelForBody ):
 182:    @BlockDecls( varNodeType )
 189:    @BlockStmt( labelForBody )
 197:    ;
      
      
 197: BlockDecls( node_type varNodeType ):
 199:    {[
 199:       | pConst :     @ConstDecl
 203:       | pType :      @TypeDecl
 207:       | pVar :       @VarDecl( varNodeType )
 216:       | pProcedure : @ProcDecl
 220:       | pFunction :  @FuncDecl
 224:       | * :          >
 239:    ]}
 241:    @CheckForUndefinedMethods
 244:    ;
      
      
      % were there any procedures or functions declared in this scope
      % that were never defined?
 244: CheckForUndefinedMethods:
         % TO DO
         % Note: disregard methods marked external
 247:    ;
      
      
      
 247: BlockStmt( Label labelForBody ):
 249:    .tLabel  oEmitLabel( labelForBody )
      
         % Proc, func, and main routine all start with tEnter
         % to create a stack frame.  This will be used for temporaries
         % (and local vars in the case of proc, func).
      
 257:    int patchLS
 257:    .tEnter  patchLS = Here  .tSpace
      
 266:    @Statement
 268:    .tReturn
      
 270:    int localSpace = oNodeGetInt( oScopeCurrent, qSize )
 282:    oPatch( patchLS, localSpace )
 292:    ;
      
      
      % modifers that may appear on a proc/function declaration.
      %
 292: MethodModifiers( Node decl ):
 294:    {[
 294:       | pCdecl :
 296:          oNodeSetBoolean( decl, qCdecl, true )
 308:          ';'
      
 310:       | * : >
 317:    ]}
 320:    ;
      
      
 320: ExternalDecl( Node decl ):
 322:    oNodeSetBoolean( decl, qExternal, true )
         % TO DO
         % Declares a method that resides in an external object file.
         % Note this is fpc syntax.  I'm not sure about other Pascals.
 334:    [
 334:       | pStrLit :
               % that was the optional library name containing the method.
 336:          [
 336:             | pName :
 338:                pStrLit
                     % that was the optional method name defined in that library,
                     % which might differ from the Pascal name.
 340:             | * :
 345:          ]
 345:       | * :
 350:    ];
      
      
 351: ProcDecl:
 353:    pIdent
      
         % If we already have a forward declaration, we'll modify that decl
         % instead of creating a second symbol table entry.
         % (Alternatively could delete or hide the old entry.)
 355:    boolean redeclaring = false
 361:    Node decl = oScopeFindInCurrentScope
      
 366:    [ oNodeNull( decl )
 373:       | true :
               % first declaration
 374:          decl = @newIdent( nProc, kProc, LAST_ID )
 390:          oNodeSetLabel( decl, qValue, oLabelNew )
      
 401:       | false :
               % we already have a declaration.
               % Keep it, and its label.
 403:          redeclaring = true
 409:          [ oNodeGetBoolean( decl, qBodyDefined )
 419:             | true : #eAlreadyDefined
 422:             | * :
 427:          ]
 427:          [ oNodeType( decl )
 434:             | nProc :
 435:             | * : #eAlreadyDefined   % wrong kind
 442:          ]
               % Move the existing param scope aside, so we can check that the
               % new one is consistent.  And, the body will want to see the new one
               % since the names might differ.
               % TO DO: If qOldParams already set, we have multiple forward decls,
               % which I believe is supposed to be an error.
 442:          oNodeSet( decl, qOldParams, oNodeGet( decl, qParams ) )
 461:          oNodeSet( decl, qParams, Null )
 473:    ]
      
 481:    oScopeBegin
 482:    Node paramScope = oScopeCurrent
      
 487:    @FormalArgDecl
 489:    oNodeSet( decl, qParams, paramScope )
 501:    oScopeEnd
 502:    ';'
      
 504:    [ redeclaring
 507:       | false : oScopeDeclare( decl )
 514:       | true :  % TO DO: check that qParams is consistent with qOldParams
 516:    ]
      
 524:    @MethodModifiers( decl )
      
         % Body may be a statement, "forward", "external".
         % Note, this syntax is based on FPC, and I'm not sure if other Pascals are similar.
         % FPC says that forward, external, cdecl, name, etc are not reserved words -
         % I think this means the user may declare other things with those names, but if so the
         % original meaning is lost.  I'll make them keywords for simplicity, for now
         % (just not too happy about "name").
      
 531:    [
 531:       | pForward :
               % Nothing to do.  We simply won't set qBodyDefined.
      
 533:       | pExternal : @ExternalDecl( decl )
      
 542:       | * :
               % Body statement
      
               % Enter the params scope again, so params are visible in body.
               % TO DO: Perhaps I could mark the scope read-only at this point.
 549:          oScopeEnter( paramScope )
      
               % Start scope for declarations within the proc
 555:          oScopeBegin
 556:          oNodeSetBoolean( oScopeCurrent, qAllocDown, true )
 567:          oNodeSet( decl, qChildScope, oScopeCurrent )
      
 578:          Label label = oNodeGetLabel( decl, qValue )
 591:          @Block( nLocalVar, label )
 601:          oNodeSetBoolean( decl, qBodyDefined, true )
 613:          oScopeEnd
      
 614:          oScopeEnd  % paramScope
 615:    ]
 615:    ';';
      
      
 618: FuncDecl:
 620:    pIdent
      
         % If we already have a forward declaration, we'll modify that decl
         % instead of creating a second symbol table entry.
         % (Alternatively could delete or hide the old entry.)
 622:    boolean redeclaring = false
 628:    Node decl = oScopeFindInCurrentScope
      
 633:    [ oNodeNull( decl )
 640:       | true :
               % first declaration
 641:          decl = @newIdent( nFunc, kFunc, LAST_ID )
 657:          oNodeSetLabel( decl, qValue, oLabelNew )
      
 668:       | false :
               % we already have a declaration.
               % Keep it, and its label.
 670:          redeclaring = true
 676:          [ oNodeGetBoolean( decl, qBodyDefined )
 686:             | true : #eAlreadyDefined
 689:             | * :
 694:          ]
 694:          [ oNodeType( decl )
 701:             | nFunc :
 702:             | * : #eAlreadyDefined   % wrong kind
 709:          ]
               % Move the existing param scope and return value aside,
               % so we can check that the new one is consistent.
               % And, the body will want to see the new one since the names might differ.
               % TO DO: If qOldParams already set, we have multiple forward decls,
               % which I believe is supposed to be an error.
 709:          oNodeSet( decl, qOldParams, oNodeGet( decl, qParams ) )
 728:          oNodeSet( decl, qParams, Null )
 740:          oNodeSet( decl, qOldType, oNodeGet( decl, qType ) )
 759:          oNodeSet( decl, qType, Null )
 771:    ]
      
 779:    oScopeBegin
 780:    Node paramScope = oScopeCurrent
      
 785:    @FormalArgDecl
 787:    oNodeSet( decl, qParams, paramScope )
      
 799:    ':'
      
 801:    Node theType
 801:    @TypeRef( theType )
 808:    oNodeSet( decl, qType, theType )
      
         % The function's param space gets an additional pointer,
         % which will point to a temporary in the caller's scope.
         % This pointer is essentially a VAR param, but I won't create an nParam for it.
      
 820:    Node ptrType = @PointerTypeTo( theType )
 831:    oNodeSetInt( decl, qResultOffset, oScopeAllocType( ptrType ) )
 847:    oScopeEnd
 848:    ';'
      
 850:    [ redeclaring
 853:       | false : oScopeDeclare( decl )
 860:       | true :  % TO DO: check that qParams is consistent with qOldParams
                      % and qType is consistent with qOldType
 862:    ]
      
 870:    @MethodModifiers( decl )
      
         % Body may be a statement, "forward", "external".
 877:    [
 877:       | pForward :
               % Nothing to do.  We simply won't set qBodyDefined.
      
 879:       | pExternal : @ExternalDecl( decl )
      
 888:       | * :
               % Body statement
      
               % Enter the params scope again, so params are visible in body.
               % TO DO: Perhaps I could mark the scope read-only at this point.
 895:          oScopeEnter( paramScope )
      
 901:          oScopeBegin
 902:          oNodeSetBoolean( oScopeCurrent, qAllocDown, true )
 913:          oNodeSet( decl, qChildScope, oScopeCurrent )
      
 924:          Label label = oNodeGetLabel( decl, qValue )
 937:          @Block( nLocalVar, label )
 947:          oNodeSetBoolean( decl, qBodyDefined, true )
 959:          oScopeEnd
      
 960:          oScopeEnd  % paramScope
 961:    ]
 961:    ';';
      
      
 964: FormalArgDecl:
 966:    [
 966:       | '(' :
 968:          {
 968:             NodeVec decls = oNodeVecNew
 973:             Node decl
 973:             boolean isInOut = false
      
 979:             [
 979:                | pVar : isInOut = true
 987:                | * :
 992:             ]
      
 992:             {  pIdent
      
 994:                decl = @newIdent( nParam, kVar, LAST_ID )
1010:                oNodeSetBoolean( decl, qInOut, isInOut )
1022:                oNodeVecAppend( decls, decl )
      
1031:                [
1031:                   | ':' : >
1035:                   | ',' :
1037:                ]
1045:             }
      
1047:             Node theType
1047:             @TypeRef( theType )
      
                  % VAR param is declared with its given type, but allocated as a pointer.
1054:             Node allocType
1054:             [ isInOut
1057:                | true :   allocType = @PointerTypeTo( theType )
1069:                | * :      allocType = theType
1080:             ]
      
1080:             int i = 0
1086:             {[ equal( i, oNodeVecSize( decls ) )
1100:                | false :
1101:                   decl = oNodeVecElement( decls, i )
      
1114:                   oNodeSet( decl, qType, theType )
1126:                   oScopeDeclare( decl )
1132:                   oNodeSetInt( decl, qValue, oScopeAllocType( allocType ) )
1148:                   inc( i )
1154:                | * :
1159:                   >
1161:             ]}
      
1163:             oNodeVecDelete( decls )
      
1169:             [
1169:                | ')' : >
1173:                | ';' :
1175:             ]
1183:          }
1185:       | * :
1190:    ];
      
1191: ConstDecl:
1193:    {[
1193:       | pIdent :
1195:          Node decl = @newIdent( nConst, kConst, LAST_ID )
1211:          '='
      
1213:          @ConstExpr
               % TO DO: currently ConstExpr leaves int result on oValue stack
1215:          int val = oValueTop
1220:          oValuePop
1221:          oNodeSetInt( decl, qValue, val )
      
               % TO DO: different types.  Currently assumes int!
1233:          oNodeSet( decl, qType, IntegerType )
      
1245:          oScopeDeclare( decl )
1251:          ';'
1253:       | * :
1258:          >
1260:    ]};
      
1263: TypeDecl:
1265:    {[
1265:       | pIdent :
1267:          Node decl = @newIdent( nTypeDecl, kType, LAST_ID )
1283:          '='
1285:          Node theType
1285:          @TypeRef( theType )
1292:          oNodeSet( decl, qType, theType )
1304:          oScopeDeclare( decl )
1310:          ';'
1312:       | * :
1317:          >
1319:    ]};
      
1322: VarDecl( node_type varNodeType ):
1324:    {[
1324:       | pIdent :
1326:          NodeVec decls = oNodeVecNew
1331:          Node decl
1331:          {
1331:             decl = @newIdent( varNodeType, kVar, LAST_ID )
1347:             oNodeVecAppend( decls, decl )
1356:             [
1356:                | ',' :
1358:                   pIdent
1360:                | * :
1365:                   >
1367:             ]
1367:          }
1369:          ':'
1371:          Node theType
1371:          @TypeRef( theType )
      
1378:          int i = 0
1384:          {[ equal( i, oNodeVecSize( decls ) )
1398:            | false :
1399:              decl = oNodeVecElement( decls, i )
1412:              oNodeSet( decl, qType, theType )
1424:              oScopeDeclareAlloc( decl )
1430:              inc( i )
1436:             | * :
1441:               >
1443:          ]}
      
1445:          oNodeVecDelete( decls )
1451:          ';'
1453:       | * :
1458:          >
1460:    ]};
      
      
      % Parse a type reference, returning the nType.
      % This will add types to the type table, as needed.
      %
      % Style question - at the moment I think callers look clearer if we use
      % an out param here, rather than a return value.
      %
1463: TypeRef( out Node resultType ):
1465:    [
1465:       | pIdent :           % previously named type (including intrinsics)
1467:          Node decl = oScopeFindRequire
1472:          [ oNodeType( decl )
1479:            | nTypeDecl :
1480:                resultType = oNodeGet( decl, qType )
1493:            | * :
1498:                #eNotType
1500:                resultType = IntegerType
1506:          ]
         
1506:       | pArray :
1508:          '['
      
               % A multi-dimensional array is represented as a chain
               %    array [subrange1] of array [subrange2] of elementType
      
               % First, we build a vector of nArray's, each with one subrange as its index type,
               % but without setting the "of" type or size.
      
1510:          NodeVec dimensions = oNodeVecNew
      
1515:          {
                  % to do: probably should use general subrange parsing, incl minimal size value
                  %   In fact, supposed to parse ordinal_type here.  all ordinal types have a static low, high.
                  %   Not necessary to be a subrange.
      
1515:             Node subrange = oNodeNew( nSubrangeType )
                  % TO DO: currently assuming subrange of integer
1525:             oNodeSet( subrange, qBaseType, IntegerType )
      
                  % TO DO: currently ConstExpr leaves int result on oValue stack
1537:             @ConstExpr
1539:             oNodeSetInt( subrange, qLow, oValueTop )
1550:             oValuePop
1551:             '..'
1553:             @ConstExpr
1555:             oNodeSetInt( subrange, qHigh, oValueTop )
1566:             oValuePop
1567:             oNodeSetInt( subrange, qSize, 4 )   % maybe don't need
      
1579:             oTypeAdd( subrange )
      
1585:             Node a = oNodeNew( nArrayType )
1595:             oNodeSet( a, qIndexType, subrange )
      
1607:             oNodeVecAppend( dimensions, a )
                  % I'll hold off on adding 'a' to the type table since not fully formed yet
      
1616:             [
1616:                | ']' : >
1620:                | ',' :
1622:             ]
1630:          }
      
1632:          pOf
1634:          Node baseType
1634:          @TypeRef( baseType )
      
               % Work backwards through the dimensions,
               % hooking up the 'of' type and calculating the size.
               % At each iteration, baseType is the 'of' type.
      
1641:          int dim = oNodeVecSize( dimensions )
      
1651:          {
1651:              dec(dim)
      
1657:              Node a = oNodeVecElement( dimensions, dim )
      
1670:              oNodeSet( a, qBaseType, baseType )
1682:              Node subrange = oNodeGet( a, qIndexType )
1695:              int width = subtract( oNodeGetInt( subrange, qHigh ), oNodeGetInt( subrange, qLow ) )
1722:              inc( width )
1728:              oNodeSetInt( a, qSize, multiply( width, oNodeGetInt( baseType, qSize ) ) )
      
1754:              oTypeAdd( a )
1760:              baseType = a
      
1766:              [ equal_zero(dim)
1773:                  | true:  >
1776:                  | *:
1781:              ]
1781:          }
      
1783:          resultType = oNodeVecElement( dimensions, 0 )
1796:          oNodeVecDelete( dimensions )
      
1802:       | '^' :
1804:          Node theType
1804:          @TypeRef( theType )
1811:          resultType = @PointerTypeTo( theType )
      
1822:       | pRecord :
1824:          resultType = oNodeNew( nRecordType )
1834:          oScopeBegin
      
1835:          @VarDecl( nRecordField )
      
1842:          int size = oNodeGetInt( oScopeCurrent, qSize )
               % to do: padding
1854:          [ equal_zero( size )
1861:             | true : #eRecordEmpty
1864:             | * :
1869:          ]
      
1869:          pEnd
      
1871:          oNodeSet( resultType, qScope, oScopeCurrent )
1882:          oNodeSetInt( resultType, qSize, size )
1894:          oScopeEnd
1895:          oTypeAdd( resultType )
      
      
            % *** TO DO: following type constructors are not implemented *** 
            % *** TO DO: also missing declaration of enum type
1901:       | pSet :
1903:          pOf
1905:          Node theType
1905:          @TypeRef( theType )
1912:       | * :       % this works for cases except where expr starts with an id
1925:          @ConstExpr '..' @ConstExpr
1931:    ];
      
      
      % --------------------------- Const Expressions --------------------------
      
      % Constant expressions: currently, only literal integers or previously
      % named constant integers are supported, possibly with a negation.
      % Constant expressions are evaluated at compile time.
      
1932: ConstExpr:
1934:    [
1934:       | pIntLit :
1936:          oValuePush( TOKEN_VALUE )
1941:       | pIdent :
1943:          Node decl = oScopeFindRequire
1948:          [ oNodeType( decl )
1955:             | nConst :
1956:                oValuePush( oNodeGetInt( decl, qValue ) )
1969:             | * :
1974:                #eNotConst
1976:                oValuePush( 0 )
1982:          ]
1982:       | pMinus :
1984:          @ConstExpr
1986:          oValueNegate
1987:    ];
      
      
      
      % ------------------------------ Expressions -----------------------------
      
      % There are two wrappers leading into expression parsing:
      %   Expr()
      %   BooleanExprControlFlow( out Label falseLabel )
      %
      % Expr always produces a value on the runtime expr stack,
      % and pushes its type on the type stack.
      %
      % BooleanExprControlFlow always generates control-flow code.
      % It does not push a value on the runtime expr stack.
      % It does not push a type on the type stack.
      % The control flow code ends up at Here if the expr is true,
      % and jumps to falseLabel if the expr is false.
      % This rule allocates falseLabel, and passes it back.
      % The caller will need to define its location.
      %
      % The internal methods of expr parsing may produce a mix of
      % values and control flow, depending on the operators seen.
      % We don't always do one or the other, hoping to be efficient for
      % cases like   "func_call( bool_var1, bool_var2 )"
      % as well as  "if bool_expr1 or bool_expr2 then ...".
      % If a subexpression rule produces control flow, it will allocate a
      % falseLabel and pass it back up.  And it will push the
      % result type as BooleanCFType, to distinguish from BooleanType
      % which corresponds with a boolean value on the expr stack.
      % 
      % Note that my expression parsing is broken into more levels than
      % grammars describe for Pascal precedence levels.  This follows my
      % original parser implementation.  I think my rationale was that
      % operators from the levels that I split up couldn't have been
      % mixed anyway, since they require different data types
      % (e.g. boolean vs int/real).  And splitting them up simplified
      % my code.  But, I should revisit this.
      %
      
      
      % Public entry point:
      %
      % Parse an expression, leaving a value on the runtime expr stack
      % and its type on the type stack.
      %
      % This rule does not export control flow (though it may generate
      % control flow internally for subexpressions).
      %
1998: Expr:
2000:    Label falseLabel = labelNull
      
2006:    @ExprAllowCF( falseLabel )
2013:    @CFToVal( falseLabel );
      
      
      % Public entry point:
      %
      % Parse a Boolean expression, producing control flow code rather than a value.
      % Does not leave a value on the runtime expr stack.
      % Does not leave a type on the type stack.
      %
      % If the expression is true, the code will fall through to the end (Here).
      % If the expression is false, the code will jump to the given falseLabel,
      % which this rule will allocate but not define the location for.
      % The caller must do so.
      %
2021: BooleanExprControlFlow( out Label falseLabel ):
2023:    @ExprAllowCF( falseLabel )
2030:    [ oTypeSNodeType
2032:       | nBooleanCFType :
2033:       | nBooleanType :
               % convert value to control flow
2035:          falseLabel = oLabelNew
2040:          .tJumpFalse  oEmitLabel( falseLabel )
2048:       | * :
2055:          #eNotBoolean
2057:    ]
2057:    oTypeSPop;
      
      
      % If the current expr result is control flow, convert it to a value.
      % falseLabel is the label that had been used by the control flow.
      % On return it will be set to labelNull.
      %
2059: CFToVal( inout Label falseLabel ):
2061:    [ oTypeSNodeType
2063:       | nBooleanCFType :
2064:          Label doneLabel = oLabelNew
2069:          .tPushConstI  oEmitInt( 1 )
2077:          .tJump  oEmitLabel( doneLabel )
2085:          .tLabel  oEmitLabel( falseLabel )
2093:          .tPushConstI  oEmitInt( 0 )
2101:          .tLabel  oEmitLabel( doneLabel )
2109:          oTypeSPop
2110:          oTypeSPush( BooleanType )
2116:          falseLabel = labelNull
2122:       | * :
2127:    ];
      
      
      % If the current expr result is boolean value, convert it to control flow.
      % falseLabel will be allocated by this rule and passed back.
      % The caller must define its location.
      %
2128: ValToCF( out Label falseLabel ):
2130:    [ oTypeSNodeType
2132:       | nBooleanType :
2133:          falseLabel = oLabelNew
2138:          .tJumpFalse  oEmitLabel( falseLabel )
2146:          oTypeSPop
2147:          oTypeSPush( BooleanCFType )
2153:       | * :
2158:    ];
      
      
      % Parse an expression.  It may produce a value on the expr stack,
      % or control flow, depending on what's seen in the expression.
      % Leaves the expression type on the type stack.
      %
      % If the expression produces control flow, the expression type will be
      % nBooleanCFType.  In this case, a true value falls through to Here,
      % and a false value jumps to falseLabel.  This rule will allocate falseLabel
      % and return it, but will not define its location; the caller must do so.
      %
      % If the expression produces a value, the value will be left on the
      % expression stack, and the type will be some type other than nBooleanCFType.
      % In this case, falseLabel is ignored.
      %
2159: ExprAllowCF( out Label falseLabel ):
2161:    @BoolExprAllowCF( falseLabel )
2168:    {[
2168:       | '=' :
2170:          @CFToVal( falseLabel )
2177:          @BoolExprAllowCF( falseLabel )
2184:          @CFToVal( falseLabel )
2191:          @MatchTypes
2193:          [ oTypeSNodeType
2195:             | nIntegerType, nBooleanType :  .tEqualI
2198:             | nPointerType :                .tEqualP
2202:             | nCharType, nStringType :      #eNotImplemented
2206:             | * :                           #eNotAllowed
2221:          ]
2221:          oTypeSPop
2222:          oTypeSPush( BooleanType )
      
2228:       | '<>' :
2230:          @CFToVal( falseLabel )
2237:          @BoolExprAllowCF( falseLabel )
2244:          @CFToVal( falseLabel )
2251:          @MatchTypes
2253:          [ oTypeSNodeType
2255:             | nIntegerType, nBooleanType :  .tNotEqualI
2258:             | nPointerType :                .tNotEqualP
2262:             | nCharType, nStringType :      #eNotImplemented
2266:             | * :                           #eNotAllowed
2281:          ]
2281:          oTypeSPop
2282:          oTypeSPush( BooleanType )
      
2288:       | '<' :
2290:          @CFToVal( falseLabel )
2297:          @BoolExprAllowCF( falseLabel )
2304:          @CFToVal( falseLabel )
2311:          @MatchTypes
2313:          [ oTypeSNodeType
2315:             | nIntegerType, nBooleanType :  .tLessI
2318:             | nCharType, nStringType :      #eNotImplemented
2322:             | * :                           #eNotAllowed
2335:          ]
2335:          oTypeSPop
2336:          oTypeSPush( BooleanType )
      
2342:       | '>' :
2344:          @CFToVal( falseLabel )
2351:          @BoolExprAllowCF( falseLabel )
2358:          @CFToVal( falseLabel )
2365:          @MatchTypes
2367:          [ oTypeSNodeType
2369:             | nIntegerType, nBooleanType :  .tGreaterI
2372:             | nCharType, nStringType :      #eNotImplemented
2376:             | * :                           #eNotAllowed
2389:          ]
2389:          oTypeSPop
2390:          oTypeSPush( BooleanType )
      
2396:       | '<=' :
2398:          @CFToVal( falseLabel )
2405:          @BoolExprAllowCF( falseLabel )
2412:          @CFToVal( falseLabel )
2419:          @MatchTypes
2421:          [ oTypeSNodeType
2423:             | nIntegerType, nBooleanType :  .tLessEqualI
2426:             | nCharType, nStringType :      #eNotImplemented
2430:             | * :                           #eNotAllowed
2443:          ]
2443:          oTypeSPop
2444:          oTypeSPush( BooleanType )
      
2450:       | '>=' :
2452:          @CFToVal( falseLabel )
2459:          @BoolExprAllowCF( falseLabel )
2466:          @CFToVal( falseLabel )
2473:          @MatchTypes
2475:          [ oTypeSNodeType
2477:             | nIntegerType, nBooleanType :  .tGreaterEqualI
2480:             | nCharType, nStringType :      #eNotImplemented
2484:             | * :                           #eNotAllowed
2497:          ]
2497:          oTypeSPop
2498:          oTypeSPush( BooleanType )
      
2504:       | * :
2519:          >
2521:    ]};
      
      
2524: BoolExprAllowCF( out Label falseLabel ):
2526:    Label trueLabel = labelNull
      
2532:    @BoolTermAllowCF( falseLabel )
2539:    {[
2539:       | pOr :
2541:          [ oTypeSNodeType
2543:             | nBooleanCFType :
                     % We are true here. Jump ahead to done
2544:                [ equal_label( trueLabel, labelNull )
2554:                   | true :  trueLabel = oLabelNew
2560:                   | * :
2565:                ]
2565:                .tJump  oEmitLabel( trueLabel )
2573:             | nBooleanType :
2575:                @ValToCF( falseLabel )
                     % We might be true here. If so, jump ahead to done
2582:                [ equal_label( trueLabel, labelNull )
2592:                   | true :  trueLabel = oLabelNew
2598:                   | * :
2603:                ]
2603:                .tJumpTrue  oEmitLabel( trueLabel )
2611:             | * : #eNotBoolean
2620:          ]
2620:          oTypeSPop
      
               % false in previous term will jump here, to try this alternative term
2621:          .tLabel  oEmitLabel( falseLabel )
      
               % we'll get a new falseLabel for this term
2629:          falseLabel = labelNull
2635:          @BoolTermAllowCF( falseLabel )
      
2642:          [ oTypeSNodeType
2644:             | nBooleanCFType :
2645:             | nBooleanType :
2647:                @ValToCF( falseLabel )
2654:             | * : #eNotBoolean
2663:          ]
      
2663:          oTypeSPop
2664:          oTypeSPush( BooleanCFType )
      
2670:       | * :
2675:          >
2677:    ]}
      
         % any short-circuit trues jump here to the end
2679:    [ equal_label( trueLabel, labelNull )
2689:       | false :
2690:          .tLabel  oEmitLabel( trueLabel )
2698:       | * :
2703:    ]
2704:    ;
      
      
2704: BoolTermAllowCF( out Label falseLabel ):
2706:    Label overallFalseLabel = labelNull
      
2712:    @BoolFactorAllowCF( falseLabel )
2719:    {[
2719:       | pAnd :
2721:          [ oTypeSNodeType
2723:             | nBooleanCFType :
2724:             | nBooleanType :
2726:                @ValToCF( falseLabel )
2733:             | * :
2740:                #eNotBoolean
2742:          ]
2742:          oTypeSPop
      
               % We're going to have a different falseLabel for each term,
               % because we let each rule allocate its own (rather than accepting labels passed in).
               % And in this case we want them all to go to the same place,
               % to be determined by the caller.
               %
               % I'll allow for label aliases.  This will be more optimal than generating
               % multiple private false-handling code segments, that the true path would have to
               % jump around.  That would be hard to eliminate afterwards.
      
2743:          [ equal_label( overallFalseLabel, labelNull )
2753:             | true :
2754:                overallFalseLabel = oLabelNew
2759:                .tLabelAlias  oEmitLabel( falseLabel )  oEmitLabel( overallFalseLabel )
2773:                falseLabel = overallFalseLabel
2779:             | * :
2784:          ]
      
2784:          Label factorFalseLabel = labelNull
2790:          @BoolFactorAllowCF( factorFalseLabel )
      
2797:          [ oTypeSNodeType
2799:             | nBooleanCFType :
2800:             | nBooleanType :
2802:                @ValToCF( factorFalseLabel )
2809:             | * : #eNotBoolean
2818:          ]
2818:         .tLabelAlias  oEmitLabel( factorFalseLabel )  oEmitLabel( overallFalseLabel )
      
2832:       | * :
2837:          >
2839:    ]};
      
2842: BoolFactorAllowCF( out Label falseLabel ):
2844:    [
2844:       | pNot :
2846:          Label factorFalseLabel = labelNull
      
2852:          @BoolFactorAllowCF( factorFalseLabel )
2859:          [ oTypeSNodeType
2861:             | nBooleanCFType :
                     % We have control flow, and are sitting at the point that has value false.
2862:                falseLabel = oLabelNew
2867:                .tJump  oEmitLabel( falseLabel )
                     % The true path jumps here
2875:                .tLabel  oEmitLabel( factorFalseLabel )
      
2883:             | nBooleanType :
                     % I have a value.  I'll leave it as a value, rather than create control flow.
                     % See how this goes.
2885:                .tNot
      
2887:             | * : #eNotBoolean
2896:          ]
      
2896:       | * :
2901:          @ArithExprAllowCF( falseLabel )
2908:    ];
      
2909: ArithExprAllowCF( out Label falseLabel ):
2911:    @TermAllowCF( falseLabel )
2918:    {[
2918:       | pPlus :
2920:          @RequireIntPop
2922:          @TermAllowCF( falseLabel )  % actually not allowing CF, will be caught by type check
2929:          @RequireInt
2931:          .tAddI
2933:       | pMinus :
2935:          @RequireIntPop
2937:          @TermAllowCF( falseLabel )
2944:          @RequireInt
2946:          .tSubI
2948:       | * :
2955:          >
2957:    ]};
      
2960: TermAllowCF( out Label falseLabel ):
2962:    @FactorAllowCF( falseLabel )
2969:    {[
2969:       | pTimes :
2971:          @RequireIntPop
2973:          @FactorAllowCF( falseLabel )  % actually not allowing CF, will be caught by type check
2980:          @RequireInt
2982:          .tMultI
2984:       | pDivide :
2986:          @RequireIntPop
2988:          @FactorAllowCF( falseLabel )
2995:          @RequireInt
2997:          .tDivI
2999:       | * :
3006:          >
3008:    ]};
      
3011: FactorAllowCF( out Label falseLabel ):
3013:    [
3013:       | pPlus :
3015:          @PrimaryAllowCF( falseLabel )  % actually not allowing CF, will be caught by type check
3022:          @RequireInt
3024:       | pMinus :
3026:          @PrimaryAllowCF( falseLabel )
3033:          @RequireInt
3035:          .tNegI
3037:       | * :
3044:          @PrimaryAllowCF( falseLabel )
3051:    ];
      
3052: PrimaryAllowCF( out Label falseLabel ):
3054:    [
3054:       | pIntLit :
3056:          .tPushConstI  oEmitInt( TOKEN_VALUE )
3063:          oTypeSPush( IntegerType )
      
3069:       | '(' :
3071:          @ExprAllowCF( falseLabel )
3078:          ')'
      
3080:       | pStrLit :
3082:          oStringAllocLit     % store in global data, push offset on value stack
3083:          .tPushAddrGlobal oEmitInt( oValueTop )  oValuePop
               % TO DO: do we need to create a type with the literal's length?
3091:          oTypeSPush( StringType )
      
3097:       | pIdent :
3099:          Node decl = oScopeFindRequire
3104:          Node theType
      
3104:          [ oNodeType( decl )
3111:             | nFunc :
      
3112:                @Call( decl )
      
3119:             | nConst :
3121:                theType = oNodeGet( decl, qType )
3134:                oTypeSPush( theType )
3140:                [ oTypeSNodeType
3142:                   | nIntegerType, nBooleanType :
3143:                      .tPushConstI @EmitValue( decl )
3152:                   | * :
3159:                      #eNotImplemented
3161:                ]
      
3161:             | nGlobalVar, nLocalVar, nParam :
3163:                @VarExpr( decl )
      
3170:             | * :
3183:                #eNotValue
3185:                oTypeSPush( IntegerType )
3191:          ]
      
3191:       | '@' :        % @var -- pointer to var
3193:          pIdent
      
3195:          Node decl = oScopeFindRequire
3200:          Node theType
      
3200:          @LValueVar( decl )
      
               % The above leaves the pointed-to type on type stack.
               % Replace with ptr-to-<type>.
3207:          theType = oTypeSTop
3212:          oTypeSPop
3213:          Node ptrType = @PointerTypeTo( theType )
3224:          oTypeSPush( ptrType )
      
3230:       | * :
3243:          #eNotValue
3245:          oTypeSPush( IntegerType )
3251:    ];
      
      
      % Parse a variable expression, given the declaration of the
      % just-accepted identifier.
      % Leaves the value on the expression stack, and type on the type stack.
      %
3252: VarExpr( Node decl ):
3254:    Node theType = oNodeGet( decl, qType )
3267:    oTypeSPush( theType )
3273:    [ oTypeSNodeType
3275:       | nIntegerType :
3276:          [ oNodeType( decl )
3283:             | nGlobalVar :   .tPushGlobalI @EmitValue( decl )
3293:             | nLocalVar :    .tPushLocalI @EmitValue( decl )
3304:             | nParam :
3306:                [ oNodeGetBoolean( decl, qInOut )
3316:                   | true :    % VAR param points to the var.  Auto dereference.
3317:                               .tPushParamP @EmitValue( decl )
3326:                               .tFetchI
3328:                   | * :       .tPushParamI @EmitValue( decl )
3342:                ]
3342:          ]
      
3352:       | nBooleanType :
3354:          [ oNodeType( decl )
3361:             | nGlobalVar :   .tPushGlobalB @EmitValue( decl )
3371:             | nLocalVar :    .tPushLocalB @EmitValue( decl )
3382:             | nParam :
3384:                [ oNodeGetBoolean( decl, qInOut )
3394:                   | true :    % VAR param points to the var.  Auto derefernce.
3395:                               .tPushParamP @EmitValue( decl )
3404:                               .tFetchB
3406:                   | * :       .tPushParamB @EmitValue( decl )
3420:                ]
3420:          ]
      
3430:       | nCharType, nStringType, nFileType :
3432:          #eNotImplemented
      
3434:       | nPointerType :
3436:          [ oNodeType( decl )
3443:             | nGlobalVar :   .tPushGlobalP @EmitValue( decl )
3453:             | nLocalVar :    .tPushLocalP @EmitValue( decl )
3464:             | nParam :
3466:                [ oNodeGetBoolean( decl, qInOut )
3476:                   | true :    % VAR param points to the var.  Auto derefernce.
3477:                               .tPushParamP @EmitValue( decl )
3486:                               .tFetchP
3488:                   | * :       .tPushParamP @EmitValue( decl )
3502:                ]
3502:          ]
3512:          [
3512:             | '^' :             % dereferenced
3514:                oTypeSPop
3515:                oTypeSPush( oNodeGet( theType, qBaseType ) )
3528:                @LValueIndexes
3530:                @FetchVar
3532:             | * :               % just ptr value alone
3537:          ]
      
3537:       | * :
               % compound type
               % first, push addr of start of var
3552:          [ oNodeType( decl )
3559:             | nGlobalVar :   .tPushAddrGlobal @EmitValue( decl )
3569:             | nLocalVar :    .tPushAddrLocal @EmitValue( decl )
3580:             | nParam :
3582:                [ oNodeGetBoolean( decl, qInOut )
3592:                   | true :    % VAR param points to the var.  Auto derefernce.
3593:                               .tPushParamP @EmitValue( decl )
3602:                   | * :       .tPushAddrParam @EmitValue( decl )
3616:                ]
3616:          ]
               % modify addr for subscripts, field references, etc
3626:          @LValueIndexes
               % get final value
3628:          @FetchVar
3630:    ];
      
      
      % Addr of start of var is on expr stack; type is on type stack.
      % Replace expr stack with value of var.
      % (In the case of compound vars, this remains as the addr of the var).
      
3631: FetchVar:
3633:    [ oTypeSNodeType
3635:       | nIntegerType :   .tFetchI
3638:       | nBooleanType :   .tFetchB
3642:       | nCharType, nStringType, nFileType : #eNotImplemented
3646:       | nPointerType :   .tFetchP
3650:       | * :              % compound type; leave as addr
3665:    ];
      
      
      % Addr of start of var is already on run stack, and type is on type stack.
      % Read subscripts, record fields, etc, to get final addr on run stack, and final type
      % on type stack.
      
3666: LValueIndexes:
3668:    {[
3668:       | '[' :       @ArraySubscripts
3672:       | '.' :       @RecordFieldRef
3676:       | '^' :       @PointerDeref
3680:       | * :         >
3691:    ]};
      
3694: ArraySubscripts:
3696:    [ oTypeSNodeType
3698:       | nArrayType :
3699:       | * :       #eNotArray
3706:    ]
3706:    {
3706:       [ oTypeSNodeType
3708:          | nArrayType :
3709:          | * :    #eTooManySubscripts
3716:       ]
      
            % low subscript of this dimension
3716:       int low = @OrdinalLow( oNodeGet( oTypeSTop, qIndexType ) )
      
            % replace type stack with next dimension, or OF type
3733:       Node baseType
3733:       baseType = oNodeGet( oTypeSTop, qBaseType )
3745:       oTypeSPop
3746:       oTypeSPush( baseType )
      
3752:       @Expr
3754:       @RequireIntPop
            % adjust for low subscript
3756:       [ equal_zero( low )
3763:          | false :
3764:             .tPushConstI oEmitInt( low ) .tSubI
3774:          | * :
3779:       ]
      
            % multiply by element size
3779:       int size = oNodeGetInt( baseType, qSize )
3792:       [ equal( size, 1 )
3802:          | false :
3803:             .tPushConstI oEmitInt( size ) .tMultI
3813:          | * :
3818:       ]
      
            % update start address
3818:       .tAddPI
3820:       [
3820:          | ']' :  >
3824:          | ',' :
3826:       ]
3834:    };
      
      
3837: RecordFieldRef:
3839:    [ oTypeSNodeType
3841:       | nRecordType :
3842:       | * :    #eNotRecord
3849:    ]
3849:    oScopeEnter( oNodeGet( oTypeSTop, qScope ) )
3861:    pIdent
3863:    Node field = oScopeFindRequire
         % oScopeFind searches all open scopes, so make sure we found nRecordField
         % which could only be seen in the local scope we entered above.
3868:    [ oNodeType( field )
3875:       | nRecordField :
3876:       | * :   #eNotRecordField
3883:    ]
3883:    oScopeEnd
3884:    int offset = oNodeGetInt( field, qValue )
3897:    [ equal_zero( offset )
3904:       | false :
3905:          .tPushConstI oEmitInt( offset ) .tAddPI
3915:       | * :
3920:    ]
      
         % replace the type on the type stack, with the field type
3920:    oTypeSPop
3921:    oTypeSPush( oNodeGet( field, qType ) )
3935:    ;
      
      
      % ptr deref on left side, i.e. BEFORE addr of ptr var is on stack,
      %                              AFTER addr of thing pointed to is on stack
3935: PointerDeref:
3937:    [ oTypeSNodeType
3939:       | nPointerType :
3940:       | * :       #eNotPointer
3947:    ]
3947:    .tFetchP           % now addr on stack is addr of what we're pointing to
      
3949:    Node theType = oTypeSTop
3954:    oTypeSPop
3955:    oTypeSPush( oNodeGet( theType, qBaseType ) )
3969:    ;
      
      
      % The expr stack contains a value whose type is on top of the type stack.
      % Generate code to coerce the value to the type under it in the type stack
      % (pop the type stack, leaving only the desired type).
      % This is used for assignment.
      %
3969: CoerceType:
         % TO DO: not implemented yet.  For now I require exact type match.
3971:    @MatchTypes
3974:    ;
      
      
      % Parse a call, given an nProc or nFunc for the just-accepted identifier.
      % If a func, this will also generate the code to push the return value on the expr stack,
      % and push the return type on the type stack.
      %
3974: Call( Node method ):
      
         % If this is a function, we will allocate a temporary
         % in the current scope, to hold the result value.
         % And pass a pointer to that temporary as an extra parameter.
3976:    Node resultType
3976:    int tempOffset
      
3976:    boolean isFunc = equal_node_type( oNodeType( method ), nFunc )
      
3993:    [ isFunc
3996:       | true :
3997:          resultType = oNodeGet( method, qType )
4010:          tempOffset = oScopeAllocType( resultType )
               % TO DO: we could manage temp allocation, so temp space can be reused
               %        by different code branches.
4020:       | * :
4025:    ]
         
      
4025:    Node paramScope = oNodeGet( method, qParams )
4038:    int actualsSize = oNodeGetInt( paramScope, qSize )
4051:    .tAllocActuals  oEmitInt( actualsSize )
      
4059:    Node param = oNodeGet( paramScope, qDecls )
4072:    [
4072:       | '(' :
            
4074:          {
4074:             [ oNodeNull( param )
4081:                | true : >
4084:                | * :
4089:             ]
      
4089:             int offset = oNodeGetInt( param, qValue )
      
                  % Assign actual value to spot in actuals space
4102:             .tPushAddrActual oEmitInt( offset )
4110:             oTypeSPush( oNodeGet( param, qType ) )
      
4123:             [ oNodeGetBoolean( param, qInOut )
4133:                | true :   % A VAR param.
                                % The actual is a pointer to the value.
                                % The type on the type stack (pushed above) is for the pointed-to value.
      
4134:                           @LValueExpr
                                % Addr of the referenced variable is on the expr stack,
                                % type of the variable is on the type stack.
      
                                % Match types more exactly. It's not sufficient to be assign compatible
                                % since the method will be assigning to the actual using the param type.
                                % Maybe something like type contents must match, incl subrange bounds.
4136:                           @MatchTypes
      
4138:                           .tAssignP
      
4140:                | false :  @Expr
4144:                           @CoerceType
                                
                                % Assign to offset in actuals space
      
4146:                           [ oTypeSNodeType
4148:                              | nIntegerType :            .tAssignI
4151:                              | nBooleanType :            .tAssignB
4155:                              | nCharType, nStringType, nFileType :   #eNotImplemented
4159:                              | nPointerType :            .tAssignP
4163:                              | * :
                                       % compound types: copy value into actuals space
4178:                                  int size = oNodeGetInt( oTypeSTop, qSize )
4190:                                  .tCopy  oEmitInt( size )    % multi-word copy
4198:                           ]
4198:             ]
4206:             oTypeSPop
      
4207:             oNodeNext( param )
4213:             [ oNodeNull( param )
4220:                | true :  >
4223:                | false :
4225:             ]
      
4233:             ','
4235:          }
      
4237:          ')'
      
4239:       | * :
4244:    ]
      
4244:    [ oNodeNull( param )
4251:       | false :    #eMissingParameter
4254:       | * :
4259:    ]
      
4259:    [ isFunc
4262:       | true :
               % Pass result temp as an additional VAR parameter.
4263:          .tPushAddrActual oEmitInt( oNodeGetInt( method, qResultOffset ) )
4278:          .tPushAddrLocal  oEmitInt( tempOffset )
4286:          .tAssignP
4288:       | * :
4293:    ]
      
4293:    .tCall   @EmitValue( method )
      
4302:    [ isFunc
4305:       | true :
               % push return value from temp
4306:          oTypeSPush( resultType )
4312:          .tPushAddrLocal  oEmitInt( tempOffset )
4320:          @FetchVar
4322:       | * :
4327:    ]
         
4327:    .tFreeActuals  oEmitInt( actualsSize )
4336:    ;
      
      
      % ------------------------------ Statements -----------------------------
      
4336: Statement:
4338:    [
4338:       | pWriteln :     @WritelnStmt
4342:       | pWrite :       @WriteStmt
4346:       | pReadln :      @ReadlnStmt
4350:       | pRead :        @ReadStmt
4354:       | pIf :          @IfStmt
4358:       | pWhile :       @WhileStmt
4362:       | pFor :         @ForStmt
4366:       | pRepeat :      @RepeatStmt
4370:       | pBreak :       @BreakStmt
4374:       | pContinue :    @ContinueStmt
4378:       | pBegin :       @BeginStmt
4382:       | pIdent :       @AssignOrCallStmt
4386:       | * :            % null statement : don't accept any tokens
4413:    ];
      
      
4414: AssignOrCallStmt:
4416:    Node decl = oScopeFindRequire
4421:    [ oNodeType( decl )
4428:       | nProc :                           @Call( decl )
4436:       | nGlobalVar, nLocalVar, nParam :   @AssignStmt( decl )
4445:       | nFunc :                           @AssignResultStmt( decl )
4454:       | * :                               #eBadStatement
4469:    ];
      
      
      % Given decl, the just-accepted first identifier on the left hand side.
      %
4470: AssignStmt( Node decl ):
      
4472:    @LValueVar( decl )
      
4479:    ':=' 
4481:    @Expr
4483:    @MatchTypes
4485:    [ oTypeSNodeType
4487:       | nIntegerType :            .tAssignI
4490:       | nBooleanType :            .tAssignB
4494:       | nCharType, nStringType, nFileType :   #eNotImplemented
      
            % compound var assigns; addrs of src, dest on stack
4498:       | nPointerType :            .tAssignP
4502:       | * :
4517:           int size = oNodeGetInt( oTypeSTop, qSize )
4529:           .tCopy  oEmitInt( size )    % multi-word copy
4537:    ]
4537:    oTypeSPop
4539:    ;
      
      
      % Given nFunc for the just-accepted identifier on the left hand side.
      % Parse an assignment that represents assignment of the function result.
      %
4539: AssignResultStmt( Node funcDecl ):
         % Only allowed to assign the result of the immediately enclosing function, I think.
4541:    [ oNodeEqual( oNodeGet( funcDecl, qChildScope ), oScopeCurrent )
4557:       | false :   #eNotCurrentFunction
4560:       | * :
4565:    ]
      
         % Result value is stored in the caller's space, via a hidden VAR parameter.
4565:    .tPushParamP  oEmitInt( oNodeGetInt( funcDecl, qResultOffset ) )
4580:    oTypeSPush( oNodeGet( funcDecl, qType ) )
      
4593:    ':='
4595:    @Expr
4597:    @MatchTypes
4599:    [ oTypeSNodeType
4601:       | nIntegerType :            .tAssignI
4604:       | nBooleanType :            .tAssignB
4608:       | nCharType, nStringType, nFileType :   #eNotImplemented
      
            % compound var assigns; addrs of src, dest on stack
4612:       | nPointerType :            .tAssignP
4616:       | * :
4631:           int size = oNodeGetInt( oTypeSTop, qSize )
4643:           .tCopy  oEmitInt( size )    % multi-word copy
4651:    ]
4651:    oTypeSPop
4653:    ;
      
      
      
      % Parse an lvalue expression, from scratch.
      % This is an expression that may appear on the left side of an assignment.
      % Leaves the address of the value on the expr stack,
      % and the type of the value at that address on the type stack.
      %
4653: LValueExpr:
         % At the moment, all lvalue expressions start with a variable name.
         % I think there can also be typecasts, not supported yet.  Check standard syntax.
4655:    pIdent
4657:    Node decl = oScopeFindRequire
4662:    [ oNodeType( decl )
4669:       | nGlobalVar, nLocalVar, nParam :
4670:       | * :  #eNotVar
4681:    ]
4681:    @LValueVar( decl )
4689:    ;
      
      
      % Parse an lvalue expression (e.g. left side of an assign statement)
      % that starts with the just-accepted identifier indicated by the given decl.
      % Leaves the lvalue address on the expression stack,
      % and the type of the value at that address on the type stack.
      %
4689: LValueVar( Node decl ):
4691:    [ oNodeType( decl )
4698:       | nGlobalVar :   .tPushAddrGlobal @EmitValue( decl )
4708:       | nLocalVar :    .tPushAddrLocal @EmitValue( decl )
4719:       | nParam :
4721:          [ oNodeGetBoolean( decl, qInOut )
4731:             | true :   % VAR param points to variable.  No dereference.
4732:                        .tPushParamP @EmitValue( decl )
4741:             | * :      .tPushAddrParam @EmitValue( decl )
4755:          ]
4755:       | * :            #eNotVar
4766:    ]
      
4766:    oTypeSPush( oNodeGet( decl, qType ) )
4779:    @LValueIndexes        % handle subscripts, if any
4782:    ;
      
      
4782: IncVar( Node decl ):
4784:    @LValueVar( decl )
4791:    @RequireIntPop
4793:    @VarExpr( decl )
4800:    oTypeSPop
4801:    .tIncI
4803:    .tAssignI;
      
4806: DecVar( Node decl ):
4808:    @LValueVar( decl )
4815:    @RequireIntPop
4817:    @VarExpr( decl )
4824:    oTypeSPop
4825:    .tDecI
4827:    .tAssignI;
      
      
4830: IfStmt:
4832:    Label falseLabel = labelNull
      
4838:    @BooleanExprControlFlow( falseLabel )
4845:    pThen
4847:    @Statement
4849:    [
4849:       | pElse :
4851:          Label doneLabel = oLabelNew
      
4856:          .tJump  oEmitLabel( doneLabel )
4864:          .tLabel oEmitLabel( falseLabel )
4872:          @Statement
4874:          .tLabel oEmitLabel( doneLabel )
      
4882:       | * :
4887:          .tLabel oEmitLabel( falseLabel )
4895:    ];
      
      
4896: ForStmt:
4898:    pIdent
      
4900:    Node decl = oScopeFindRequire
         % TO DO: disallow use of a compound variable field.
         %        Could do that by disallowing use of LValueIndexes,
         %        or by double-checking the decl's qType here.
4905:    @LValueVar( decl )
4912:    @RequireIntPop
      
4914:    ':='
      
4916:    @Expr
4918:    @RequireIntPop
4920:    .tAssignI
      
4922:    Label breakLabel = oLabelNew
      
4927:    Label checkLabel = oLabelNew
4932:    .tJump  oEmitLabel( checkLabel )
      
4940:    Label continueLabel = oLabelNew
4945:    .tLabel  oEmitLabel( continueLabel )
4953:    [
4953:       | pTo :
4955:          @IncVar( decl )
4962:          .tLabel  oEmitLabel( checkLabel )
4970:          @VarExpr( decl )  oTypeSPop
4978:          @Expr
4980:          @RequireIntPop
4982:          .tGreaterI
4984:          .tJumpTrue  oEmitLabel( breakLabel )
4992:       | pDownto :
4994:          @DecVar( decl )
5001:          .tLabel  oEmitLabel( checkLabel )
5009:          @VarExpr( decl )  oTypeSPop
5017:          @Expr
5019:          @RequireIntPop
5021:          .tLessI
5023:          .tJumpTrue  oEmitLabel( breakLabel )
5031:    ]
5039:    oLoopPush( continueLabel, breakLabel )
5048:    pDo
5050:    @Statement
5052:    .tJump  oEmitLabel( continueLabel )
5060:    .tLabel  oEmitLabel( breakLabel )
5068:    oLoopPop;
      
      
5070: RepeatStmt:
5072:    Label continueLabel = oLabelNew
5077:    .tLabel  oEmitLabel( continueLabel )
      
5085:    Label breakLabel = oLabelNew
      
5090:    oLoopPush( continueLabel, breakLabel )
5099:    @Statement
5101:    {[
5101:       | ';' :
5103:          @Statement
5105:       | pUntil :
5107:          Label falseLabel
5107:          @BooleanExprControlFlow( falseLabel )
5114:          .tLabelAlias  oEmitLabel( falseLabel )  oEmitLabel( continueLabel )
5128:          >
5130:    ]}
5140:    .tLabel  oEmitLabel( breakLabel )
5148:    oLoopPop;
      
      
5150: WhileStmt:
5152:    Label continueLabel = oLabelNew
5157:    .tLabel  oEmitLabel( continueLabel )
      
5165:    Label breakLabel
5165:    @BooleanExprControlFlow( breakLabel )
      
5172:    oLoopPush( continueLabel, breakLabel )
5181:    pDo
5183:    @Statement
5185:    .tJump  oEmitLabel( continueLabel )
5193:    .tLabel  oEmitLabel( breakLabel )
5201:    oLoopPop;
      
      
5203: ContinueStmt:                     % NOTE, for repeat..until, skips test (??)
5205:    [ equal_label( oLoopContinueLabel, labelNull )
5214:       | true :
5215:          #eNotInALoop
5217:       | false :
5219:          .tJump  oEmitLabel( oLoopContinueLabel )
5226:    ];
      
      
5235: BreakStmt:
5237:    [ equal_label( oLoopBreakLabel, labelNull )
5246:       | true :
5247:          #eNotInALoop
5249:       | false :
5251:          .tJump  oEmitLabel( oLoopBreakLabel )
5258:    ];
      
      
5267: BeginStmt:
5269:    @Statement
5271:    {[
5271:       | ';' :   @Statement
5275:       | pEnd :  >
5279:    ]};
      
      
5290: WritelnStmt:
5292:    @WriteStmt
5294:    .tWriteCR;
      
      
5297: WriteStmt:
5299:    [
5299:       | '(' :
5301:          {
5301:             @Expr
5303:             [ oTypeSNodeType
5305:                | nIntegerType :             .tWriteI
5308:                | nBooleanType :             .tWriteBool
5312:                | nStringType :              .tWriteStr
5316:                | nCharType, nFileType :     #eNotImplemented
5320:                | nPointerType :             .tWriteP
5324:                | * :                        #eNotAllowed
5341:             ]
5341:             oTypeSPop
5342:             [
5342:                | ')' : >
5346:                | ',' :
5348:             ]
5356:          }
5358:       | * :
5363:    ];
      
      
5364: ReadlnStmt:      % ***
         % TO DO
5367:    ;
      
5367: ReadStmt:
         % TO DO
5370:    ;
      
      % -------------------------------- Utilities -------------------------------
      
      
      % Require that the top two types on the type stack are matching (ignoring subranges).
      % Pop one of them, leaving only one.
      %
5370: MatchTypes:
5372:    node_type nt = oTypeSNodeType
5377:    oTypeSPop
5378:    [ equal_node_type( nt, oTypeSNodeType )
5387:       | false :
5388:          #eTypeMismatch
5390:       | * :
5395:    ];
      
      
      % Require that the top type on the type stack is integer (ignoring subranges).
      % Pop it.
      %
5396: RequireIntPop:
5398:    [ oTypeSNodeType
5400:       | nIntegerType :
5401:       | * :          #eNotInteger
5408:    ]
5408:    oTypeSPop;
      
5410: RequireInt:
5412:    [ oTypeSNodeType
5414:       | nIntegerType :
5415:       | * :          #eNotInteger
5422:    ];
      
5423: RequireBoolPop:
5425:    [ oTypeSNodeType
5427:       | nBooleanType :
5428:       | * :          #eNotBoolean
5435:    ]
5435:    oTypeSPop;
      
5437: RequireBool:
5439:    [ oTypeSNodeType
5441:       | nBooleanType :
5442:       | * :          #eNotBoolean
5449:    ];
      
      
      % Create and return a new nType of the given node_type, adding it to the type table.
      %
5450: newType( node_type nt, int size ) >> Node:
5452:   Node node = oNodeNew( nt )
5462:   oNodeSetInt( node, qSize, size )
5474:   oTypeAdd( node )
5480:   >> node
5484:   ;
      
      
      % Create and return a new nIdent of the given node_type, with the given ident id.
      % Does not add it to any scope.
      %
5484: newIdent( node_type nt, kind k, int id ) >> Node:
5486:   Node t = oNodeNew( nt )
5496:   oNodeSetInt( t, qIdent, id )
5508:   >> t
5512:   ;
      
      
      % Return an nType representing a pointer to the given type.
      % (Creates a new type if necessary.)
      %
5512: PointerTypeTo( Node theType ) >> Node:
5514:    Node ptrType = oNodeGet( theType, qPointerType )
5527:    [ oNodeNull( ptrType )
5534:       | true :
5535:          ptrType = oNodeNew( nPointerType )
5545:          oNodeSet( ptrType, qBaseType, theType )
5557:          oNodeSetInt( ptrType, qSize, 8 )
5569:          oTypeAdd( ptrType )
5575:          oNodeSet( theType, qPointerType, ptrType )
5587:       | * :
5592:    ]
5592:    >> ptrType;
      
      
      % Return the low value of an ordinal type
      %
5596: OrdinalLow( Node theType ) >> int:
5598:    [ oNodeType( theType )
5605:       | nIntegerType :  >> oMININT    % NOTE ssl literals are limited to 16 bit at the moment, though values are 32 bit ok. So need a mechanism.
5608:       | nBooleanType :  >> 0
5613:       | nCharType :     >> 0
5618:       | nSubrangeType : >> oNodeGetInt( theType, qLow )
5630:       | * :             #eNotOrdinalType
5643:                         >> 0
5646:    ];
      
      
      
      % Emit the value in a declaration.
      % For a constant integer, this is the constant value.
      % For a global variable, this is the global address.
      % For a local variable, this is the local address relative to the call stack frame.
      %
5647: EmitValue( Node decl ):
5649:     oEmitInt( oNodeGetInt( decl, qValue ));
      
      
5663: installBuiltIns:
      
         % install built-in types
5665:    FileType = @newType( nFileType, 4 )
5679:    IntegerType = @newType( nIntegerType, 4 )
5693:    BooleanType = @newType( nBooleanType, 1 )
5707:    BooleanCFType = @newType( nBooleanCFType, 1 )
5721:    CharType = @newType( nCharType, 1 )
5735:    StringType = @newType( nStringType, 256 )    % string with default length 256
      
         % Declare those type identifiers.
         % SSL doesn't support strings, so need help from operations e.g. oIdAdd_File
      
5749:    Node t
      
5749:    t = @newIdent( nTypeDecl, kType, oIdAdd_File )
5765:    oNodeSet( t, qType, FileType )
5777:    oScopeDeclare( t )
      
5783:    t = @newIdent( nTypeDecl, kType, oIdAdd_Integer )
5799:    oNodeSet( t, qType, IntegerType )
5811:    oScopeDeclare( t )
      
5817:    t = @newIdent( nTypeDecl, kType, oIdAdd_Boolean )
5833:    oNodeSet( t, qType, BooleanType )
5845:    oScopeDeclare( t )
      
5851:    t = @newIdent( nTypeDecl, kType, oIdAdd_Char )
5867:    oNodeSet( t, qType, CharType )
5879:    oScopeDeclare( t )
      
5885:    t = @newIdent( nTypeDecl, kType, oIdAdd_String )
5901:    oNodeSet( t, qType, StringType )
5913:    oScopeDeclare( t )
      
         % Built-in constants
      
5919:    t = @newIdent( nConst, kConst, oIdAdd_True )
5935:    oNodeSet( t, qType, BooleanType )
5947:    oNodeSetInt( t, qValue, 1 )
5959:    oScopeDeclare( t )
      
5965:    t = @newIdent( nConst, kConst, oIdAdd_False )
5981:    oNodeSet( t, qType, BooleanType )
5993:    oNodeSetInt( t, qValue, 0 )
6005:    oScopeDeclare( t )
      
6012:    ;
      
6012: end
      
6012: 

Generated code:

   0: oGlobalSpace 8
   2: oLocalSpace 3
   4: oScopeBegin
   5: oGetAddrGlobal 1
   7: oPushResult
   8: oScopeCurrent
   9: oAssign
  10: oCall 5663
  12: oGetAddrLocal 2
  14: oPushResult
  15: oLabelNew
  16: oAssign
  17: oEmit 40
  19: oGetLocal 2
  21: oPushResult
  22: oEmitLabel
  23: oPop 1
  25: oEmit 41
  27: oInput 27
  29: oInput 0
  31: oGetAddrLocal 3
  33: oPushResult
  34: oSetResult 5
  36: oPushResult
  37: oSetResult 1
  39: oPushResult
  40: LAST_ID
  41: oPushResult
  42: oCall 5484
  44: oPop 3
  46: oAssign
  47: oGetLocal 3
  49: oPushResult
  50: oScopeDeclare
  51: oPop 1
  53: oInputChoice 133
  55: oInput 0
  57: oGetAddrLocal 1
  59: oPushResult
  60: oSetResult 11
  62: oPushResult
  63: oSetResult 6
  65: oPushResult
  66: LAST_ID
  67: oPushResult
  68: oCall 5484
  70: oPop 3
  72: oAssign
  73: oGetLocal 1
  75: oPushResult
  76: oSetResult 5
  78: oPushResult
  79: oGetGlobal 2
  81: oPushResult
  82: oNodeSet
  83: oPop 3
  85: oGetLocal 1
  87: oPushResult
  88: oScopeDeclareAlloc
  89: oPop 1
  91: oInput 12
  93: oInput 0
  95: oGetAddrLocal 1
  97: oPushResult
  98: oSetResult 11
 100: oPushResult
 101: oSetResult 6
 103: oPushResult
 104: LAST_ID
 105: oPushResult
 106: oCall 5484
 108: oPop 3
 110: oAssign
 111: oGetLocal 1
 113: oPushResult
 114: oSetResult 5
 116: oPushResult
 117: oGetGlobal 2
 119: oPushResult
 120: oNodeSet
 121: oPop 3
 123: oGetLocal 1
 125: oPushResult
 126: oScopeDeclareAlloc
 127: oPop 1
 129: oInput 14
 131: oJumpForward 136
 133: Choice Lookup Table
          13     55
 136: oInput 4
 138: oSetResult 12
 140: oPushResult
 141: oCall 197
 143: oPop 1
 145: oScopeBegin
 146: oScopeCurrent
 147: oPushResult
 148: oSetResult 3
 150: oPushResult
 151: oSetResult 1
 153: oPushResult
 154: oNodeSetBoolean
 155: oPop 3
 157: oGetLocal 3
 159: oPushResult
 160: oSetResult 7
 162: oPushResult
 163: oScopeCurrent
 164: oPushResult
 165: oNodeSet
 166: oPop 3
 168: oGetLocal 2
 170: oPushResult
 171: oCall 247
 173: oPop 1
 175: oScopeEnd
 176: oInput 19
 178: oScopeEnd
 179: oReturn
 180: oLocalSpace 0
 182: oGetParam 2
 184: oPushResult
 185: oCall 197
 187: oPop 1
 189: oGetParam 1
 191: oPushResult
 192: oCall 247
 194: oPop 1
 196: oReturn
 197: oLocalSpace 0
 199: oInputChoice 226
 201: oCall 1191
 203: oJumpForward 239
 205: oCall 1263
 207: oJumpForward 239
 209: oGetParam 1
 211: oPushResult
 212: oCall 1322
 214: oPop 1
 216: oJumpForward 239
 218: oCall 351
 220: oJumpForward 239
 222: oCall 618
 224: oJumpForward 239
 226: Choice Lookup Table
          29    222
          28    218
          32    209
          31    205
          30    201
 237: oJumpForward 241
 239: oJumpBack 199
 241: oCall 244
 243: oReturn
 244: oLocalSpace 0
 246: oReturn
 247: oLocalSpace 2
 249: oEmit 46
 251: oGetParam 1
 253: oPushResult
 254: oEmitLabel
 255: oPop 1
 257: oEmit 42
 259: oGetAddrLocal 1
 261: oPushResult
 262: Here
 263: oAssign
 264: oEmit 53
 266: oCall 4336
 268: oEmit 41
 270: oGetAddrLocal 2
 272: oPushResult
 273: oScopeCurrent
 274: oPushResult
 275: oSetResult 2
 277: oPushResult
 278: oNodeGetInt
 279: oPop 2
 281: oAssign
 282: oGetLocal 1
 284: oPushResult
 285: oGetLocal 2
 287: oPushResult
 288: oPatch
 289: oPop 2
 291: oReturn
 292: oLocalSpace 0
 294: oInputChoice 312
 296: oGetParam 1
 298: oPushResult
 299: oSetResult 12
 301: oPushResult
 302: oSetResult 1
 304: oPushResult
 305: oNodeSetBoolean
 306: oPop 3
 308: oInput 4
 310: oJumpForward 317
 312: Choice Lookup Table
          62    296
 315: oJumpForward 319
 317: oJumpBack 294
 319: oReturn
 320: oLocalSpace 0
 322: oGetParam 1
 324: oPushResult
 325: oSetResult 11
 327: oPushResult
 328: oSetResult 1
 330: oPushResult
 331: oNodeSetBoolean
 332: oPop 3
 334: oInputChoice 347
 336: oInputChoice 342
 338: oInput 2
 340: oJumpForward 345
 342: Choice Lookup Table
          61    338
 345: oJumpForward 350
 347: Choice Lookup Table
           2    336
 350: oReturn
 351: oLocalSpace 4
 353: oInput 0
 355: oGetAddrLocal 1
 357: oPushResult
 358: oSetResult 0
 360: oAssign
 361: oGetAddrLocal 2
 363: oPushResult
 364: oScopeFindInCurrentScope
 365: oAssign
 366: oGetLocal 2
 368: oPushResult
 369: oNodeNull
 370: oPop 1
 372: oChoice 475
 374: oGetAddrLocal 2
 376: oPushResult
 377: oSetResult 7
 379: oPushResult
 380: oSetResult 2
 382: oPushResult
 383: LAST_ID
 384: oPushResult
 385: oCall 5484
 387: oPop 3
 389: oAssign
 390: oGetLocal 2
 392: oPushResult
 393: oSetResult 6
 395: oPushResult
 396: oLabelNew
 397: oPushResult
 398: oNodeSetLabel
 399: oPop 3
 401: oJumpForward 481
 403: oGetAddrLocal 1
 405: oPushResult
 406: oSetResult 1
 408: oAssign
 409: oGetLocal 2
 411: oPushResult
 412: oSetResult 10
 414: oPushResult
 415: oNodeGetBoolean
 416: oPop 2
 418: oChoice 424
 420: oError 21
 422: oJumpForward 427
 424: Choice Lookup Table
           1    420
 427: oGetLocal 2
 429: oPushResult
 430: oNodeType
 431: oPop 1
 433: oChoice 437
 435: oJumpForward 442
 437: Choice Lookup Table
           7    435
 440: oError 21
 442: oGetLocal 2
 444: oPushResult
 445: oSetResult 13
 447: oPushResult
 448: oGetLocal 2
 450: oPushResult
 451: oSetResult 8
 453: oPushResult
 454: oNodeGet
 455: oPop 2
 457: oPushResult
 458: oNodeSet
 459: oPop 3
 461: oGetLocal 2
 463: oPushResult
 464: oSetResult 8
 466: oPushResult
 467: oSetResult 0
 469: oPushResult
 470: oNodeSet
 471: oPop 3
 473: oJumpForward 481
 475: Choice Lookup Table
           0    403
           1    374
 480: oEndChoice
 481: oScopeBegin
 482: oGetAddrLocal 3
 484: oPushResult
 485: oScopeCurrent
 486: oAssign
 487: oCall 964
 489: oGetLocal 2
 491: oPushResult
 492: oSetResult 8
 494: oPushResult
 495: oGetLocal 3
 497: oPushResult
 498: oNodeSet
 499: oPop 3
 501: oScopeEnd
 502: oInput 4
 504: oGetLocal 1
 506: oChoice 518
 508: oGetLocal 2
 510: oPushResult
 511: oScopeDeclare
 512: oPop 1
 514: oJumpForward 524
 516: oJumpForward 524
 518: Choice Lookup Table
           1    516
           0    508
 523: oEndChoice
 524: oGetLocal 2
 526: oPushResult
 527: oCall 292
 529: oPop 1
 531: oInputChoice 544
 533: oJumpForward 615
 535: oGetLocal 2
 537: oPushResult
 538: oCall 320
 540: oPop 1
 542: oJumpForward 615
 544: Choice Lookup Table
          60    535
          59    533
 549: oGetLocal 3
 551: oPushResult
 552: oScopeEnter
 553: oPop 1
 555: oScopeBegin
 556: oScopeCurrent
 557: oPushResult
 558: oSetResult 3
 560: oPushResult
 561: oSetResult 1
 563: oPushResult
 564: oNodeSetBoolean
 565: oPop 3
 567: oGetLocal 2
 569: oPushResult
 570: oSetResult 9
 572: oPushResult
 573: oScopeCurrent
 574: oPushResult
 575: oNodeSet
 576: oPop 3
 578: oGetAddrLocal 4
 580: oPushResult
 581: oGetLocal 2
 583: oPushResult
 584: oSetResult 6
 586: oPushResult
 587: oNodeGetLabel
 588: oPop 2
 590: oAssign
 591: oSetResult 13
 593: oPushResult
 594: oGetLocal 4
 596: oPushResult
 597: oCall 180
 599: oPop 2
 601: oGetLocal 2
 603: oPushResult
 604: oSetResult 10
 606: oPushResult
 607: oSetResult 1
 609: oPushResult
 610: oNodeSetBoolean
 611: oPop 3
 613: oScopeEnd
 614: oScopeEnd
 615: oInput 4
 617: oReturn
 618: oLocalSpace 6
 620: oInput 0
 622: oGetAddrLocal 1
 624: oPushResult
 625: oSetResult 0
 627: oAssign
 628: oGetAddrLocal 2
 630: oPushResult
 631: oScopeFindInCurrentScope
 632: oAssign
 633: oGetLocal 2
 635: oPushResult
 636: oNodeNull
 637: oPop 1
 639: oChoice 773
 641: oGetAddrLocal 2
 643: oPushResult
 644: oSetResult 8
 646: oPushResult
 647: oSetResult 3
 649: oPushResult
 650: LAST_ID
 651: oPushResult
 652: oCall 5484
 654: oPop 3
 656: oAssign
 657: oGetLocal 2
 659: oPushResult
 660: oSetResult 6
 662: oPushResult
 663: oLabelNew
 664: oPushResult
 665: oNodeSetLabel
 666: oPop 3
 668: oJumpForward 779
 670: oGetAddrLocal 1
 672: oPushResult
 673: oSetResult 1
 675: oAssign
 676: oGetLocal 2
 678: oPushResult
 679: oSetResult 10
 681: oPushResult
 682: oNodeGetBoolean
 683: oPop 2
 685: oChoice 691
 687: oError 21
 689: oJumpForward 694
 691: Choice Lookup Table
           1    687
 694: oGetLocal 2
 696: oPushResult
 697: oNodeType
 698: oPop 1
 700: oChoice 704
 702: oJumpForward 709
 704: Choice Lookup Table
           8    702
 707: oError 21
 709: oGetLocal 2
 711: oPushResult
 712: oSetResult 13
 714: oPushResult
 715: oGetLocal 2
 717: oPushResult
 718: oSetResult 8
 720: oPushResult
 721: oNodeGet
 722: oPop 2
 724: oPushResult
 725: oNodeSet
 726: oPop 3
 728: oGetLocal 2
 730: oPushResult
 731: oSetResult 8
 733: oPushResult
 734: oSetResult 0
 736: oPushResult
 737: oNodeSet
 738: oPop 3
 740: oGetLocal 2
 742: oPushResult
 743: oSetResult 14
 745: oPushResult
 746: oGetLocal 2
 748: oPushResult
 749: oSetResult 5
 751: oPushResult
 752: oNodeGet
 753: oPop 2
 755: oPushResult
 756: oNodeSet
 757: oPop 3
 759: oGetLocal 2
 761: oPushResult
 762: oSetResult 5
 764: oPushResult
 765: oSetResult 0
 767: oPushResult
 768: oNodeSet
 769: oPop 3
 771: oJumpForward 779
 773: Choice Lookup Table
           0    670
           1    641
 778: oEndChoice
 779: oScopeBegin
 780: oGetAddrLocal 3
 782: oPushResult
 783: oScopeCurrent
 784: oAssign
 785: oCall 964
 787: oGetLocal 2
 789: oPushResult
 790: oSetResult 8
 792: oPushResult
 793: oGetLocal 3
 795: oPushResult
 796: oNodeSet
 797: oPop 3
 799: oInput 11
 801: oGetAddrLocal 4
 803: oPushResult
 804: oCall 1463
 806: oPop 1
 808: oGetLocal 2
 810: oPushResult
 811: oSetResult 5
 813: oPushResult
 814: oGetLocal 4
 816: oPushResult
 817: oNodeSet
 818: oPop 3
 820: oGetAddrLocal 5
 822: oPushResult
 823: oGetLocal 4
 825: oPushResult
 826: oCall 5512
 828: oPop 1
 830: oAssign
 831: oGetLocal 2
 833: oPushResult
 834: oSetResult 15
 836: oPushResult
 837: oGetLocal 5
 839: oPushResult
 840: oScopeAllocType
 841: oPop 1
 843: oPushResult
 844: oNodeSetInt
 845: oPop 3
 847: oScopeEnd
 848: oInput 4
 850: oGetLocal 1
 852: oChoice 864
 854: oGetLocal 2
 856: oPushResult
 857: oScopeDeclare
 858: oPop 1
 860: oJumpForward 870
 862: oJumpForward 870
 864: Choice Lookup Table
           1    862
           0    854
 869: oEndChoice
 870: oGetLocal 2
 872: oPushResult
 873: oCall 292
 875: oPop 1
 877: oInputChoice 890
 879: oJumpForward 961
 881: oGetLocal 2
 883: oPushResult
 884: oCall 320
 886: oPop 1
 888: oJumpForward 961
 890: Choice Lookup Table
          60    881
          59    879
 895: oGetLocal 3
 897: oPushResult
 898: oScopeEnter
 899: oPop 1
 901: oScopeBegin
 902: oScopeCurrent
 903: oPushResult
 904: oSetResult 3
 906: oPushResult
 907: oSetResult 1
 909: oPushResult
 910: oNodeSetBoolean
 911: oPop 3
 913: oGetLocal 2
 915: oPushResult
 916: oSetResult 9
 918: oPushResult
 919: oScopeCurrent
 920: oPushResult
 921: oNodeSet
 922: oPop 3
 924: oGetAddrLocal 6
 926: oPushResult
 927: oGetLocal 2
 929: oPushResult
 930: oSetResult 6
 932: oPushResult
 933: oNodeGetLabel
 934: oPop 2
 936: oAssign
 937: oSetResult 13
 939: oPushResult
 940: oGetLocal 6
 942: oPushResult
 943: oCall 180
 945: oPop 2
 947: oGetLocal 2
 949: oPushResult
 950: oSetResult 10
 952: oPushResult
 953: oSetResult 1
 955: oPushResult
 956: oNodeSetBoolean
 957: oPop 3
 959: oScopeEnd
 960: oScopeEnd
 961: oInput 4
 963: oReturn
 964: oLocalSpace 6
 966: oInputChoice 1187
 968: oGetAddrLocal 1
 970: oPushResult
 971: oNodeVecNew
 972: oAssign
 973: oGetAddrLocal 3
 975: oPushResult
 976: oSetResult 0
 978: oAssign
 979: oInputChoice 989
 981: oGetAddrLocal 3
 983: oPushResult
 984: oSetResult 1
 986: oAssign
 987: oJumpForward 992
 989: Choice Lookup Table
          32    981
 992: oInput 0
 994: oGetAddrLocal 2
 996: oPushResult
 997: oSetResult 15
 999: oPushResult
1000: oSetResult 6
1002: oPushResult
1003: LAST_ID
1004: oPushResult
1005: oCall 5484
1007: oPop 3
1009: oAssign
1010: oGetLocal 2
1012: oPushResult
1013: oSetResult 16
1015: oPushResult
1016: oGetLocal 3
1018: oPushResult
1019: oNodeSetBoolean
1020: oPop 3
1022: oGetLocal 1
1024: oPushResult
1025: oGetLocal 2
1027: oPushResult
1028: oNodeVecAppend
1029: oPop 2
1031: oInputChoice 1039
1033: oJumpForward 1047
1035: oJumpForward 1045
1037: oJumpForward 1045
1039: Choice Lookup Table
          12   1037
          11   1033
1044: oEndChoice
1045: oJumpBack 992
1047: oGetAddrLocal 4
1049: oPushResult
1050: oCall 1463
1052: oPop 1
1054: oGetLocal 3
1056: oChoice 1071
1058: oGetAddrLocal 5
1060: oPushResult
1061: oGetLocal 4
1063: oPushResult
1064: oCall 5512
1066: oPop 1
1068: oAssign
1069: oJumpForward 1080
1071: Choice Lookup Table
           1   1058
1074: oGetAddrLocal 5
1076: oPushResult
1077: oGetLocal 4
1079: oAssign
1080: oGetAddrLocal 6
1082: oPushResult
1083: oSetResult 0
1085: oAssign
1086: oGetLocal 6
1088: oPushResult
1089: oGetLocal 1
1091: oPushResult
1092: oNodeVecSize
1093: oPop 1
1095: oPushResult
1096: equal
1097: oPop 2
1099: oChoice 1156
1101: oGetAddrLocal 2
1103: oPushResult
1104: oGetLocal 1
1106: oPushResult
1107: oGetLocal 6
1109: oPushResult
1110: oNodeVecElement
1111: oPop 2
1113: oAssign
1114: oGetLocal 2
1116: oPushResult
1117: oSetResult 5
1119: oPushResult
1120: oGetLocal 4
1122: oPushResult
1123: oNodeSet
1124: oPop 3
1126: oGetLocal 2
1128: oPushResult
1129: oScopeDeclare
1130: oPop 1
1132: oGetLocal 2
1134: oPushResult
1135: oSetResult 6
1137: oPushResult
1138: oGetLocal 5
1140: oPushResult
1141: oScopeAllocType
1142: oPop 1
1144: oPushResult
1145: oNodeSetInt
1146: oPop 3
1148: oGetAddrLocal 6
1150: oPushResult
1151: inc
1152: oPop 1
1154: oJumpForward 1161
1156: Choice Lookup Table
           0   1101
1159: oJumpForward 1163
1161: oJumpBack 1086
1163: oGetLocal 1
1165: oPushResult
1166: oNodeVecDelete
1167: oPop 1
1169: oInputChoice 1177
1171: oJumpForward 1185
1173: oJumpForward 1183
1175: oJumpForward 1183
1177: Choice Lookup Table
           4   1175
          14   1171
1182: oEndChoice
1183: oJumpBack 968
1185: oJumpForward 1190
1187: Choice Lookup Table
          13    968
1190: oReturn
1191: oLocalSpace 2
1193: oInputChoice 1255
1195: oGetAddrLocal 1
1197: oPushResult
1198: oSetResult 9
1200: oPushResult
1201: oSetResult 4
1203: oPushResult
1204: LAST_ID
1205: oPushResult
1206: oCall 5484
1208: oPop 3
1210: oAssign
1211: oInput 5
1213: oCall 1932
1215: oGetAddrLocal 2
1217: oPushResult
1218: oValueTop
1219: oAssign
1220: oValuePop
1221: oGetLocal 1
1223: oPushResult
1224: oSetResult 6
1226: oPushResult
1227: oGetLocal 2
1229: oPushResult
1230: oNodeSetInt
1231: oPop 3
1233: oGetLocal 1
1235: oPushResult
1236: oSetResult 5
1238: oPushResult
1239: oGetGlobal 3
1241: oPushResult
1242: oNodeSet
1243: oPop 3
1245: oGetLocal 1
1247: oPushResult
1248: oScopeDeclare
1249: oPop 1
1251: oInput 4
1253: oJumpForward 1260
1255: Choice Lookup Table
           0   1195
1258: oJumpForward 1262
1260: oJumpBack 1193
1262: oReturn
1263: oLocalSpace 2
1265: oInputChoice 1314
1267: oGetAddrLocal 1
1269: oPushResult
1270: oSetResult 10
1272: oPushResult
1273: oSetResult 5
1275: oPushResult
1276: LAST_ID
1277: oPushResult
1278: oCall 5484
1280: oPop 3
1282: oAssign
1283: oInput 5
1285: oGetAddrLocal 2
1287: oPushResult
1288: oCall 1463
1290: oPop 1
1292: oGetLocal 1
1294: oPushResult
1295: oSetResult 5
1297: oPushResult
1298: oGetLocal 2
1300: oPushResult
1301: oNodeSet
1302: oPop 3
1304: oGetLocal 1
1306: oPushResult
1307: oScopeDeclare
1308: oPop 1
1310: oInput 4
1312: oJumpForward 1319
1314: Choice Lookup Table
           0   1267
1317: oJumpForward 1321
1319: oJumpBack 1265
1321: oReturn
1322: oLocalSpace 4
1324: oInputChoice 1455
1326: oGetAddrLocal 1
1328: oPushResult
1329: oNodeVecNew
1330: oAssign
1331: oGetAddrLocal 2
1333: oPushResult
1334: oGetParam 1
1336: oPushResult
1337: oSetResult 6
1339: oPushResult
1340: LAST_ID
1341: oPushResult
1342: oCall 5484
1344: oPop 3
1346: oAssign
1347: oGetLocal 1
1349: oPushResult
1350: oGetLocal 2
1352: oPushResult
1353: oNodeVecAppend
1354: oPop 2
1356: oInputChoice 1362
1358: oInput 0
1360: oJumpForward 1367
1362: Choice Lookup Table
          12   1358
1365: oJumpForward 1369
1367: oJumpBack 1331
1369: oInput 11
1371: oGetAddrLocal 3
1373: oPushResult
1374: oCall 1463
1376: oPop 1
1378: oGetAddrLocal 4
1380: oPushResult
1381: oSetResult 0
1383: oAssign
1384: oGetLocal 4
1386: oPushResult
1387: oGetLocal 1
1389: oPushResult
1390: oNodeVecSize
1391: oPop 1
1393: oPushResult
1394: equal
1395: oPop 2
1397: oChoice 1438
1399: oGetAddrLocal 2
1401: oPushResult
1402: oGetLocal 1
1404: oPushResult
1405: oGetLocal 4
1407: oPushResult
1408: oNodeVecElement
1409: oPop 2
1411: oAssign
1412: oGetLocal 2
1414: oPushResult
1415: oSetResult 5
1417: oPushResult
1418: oGetLocal 3
1420: oPushResult
1421: oNodeSet
1422: oPop 3
1424: oGetLocal 2
1426: oPushResult
1427: oScopeDeclareAlloc
1428: oPop 1
1430: oGetAddrLocal 4
1432: oPushResult
1433: inc
1434: oPop 1
1436: oJumpForward 1443
1438: Choice Lookup Table
           0   1399
1441: oJumpForward 1445
1443: oJumpBack 1384
1445: oGetLocal 1
1447: oPushResult
1448: oNodeVecDelete
1449: oPop 1
1451: oInput 4
1453: oJumpForward 1460
1455: Choice Lookup Table
           0   1326
1458: oJumpForward 1462
1460: oJumpBack 1324
1462: oReturn
1463: oLocalSpace 12
1465: oInputChoice 1914
1467: oGetAddrLocal 1
1469: oPushResult
1470: oScopeFindRequire
1471: oAssign
1472: oGetLocal 1
1474: oPushResult
1475: oNodeType
1476: oPop 1
1478: oChoice 1495
1480: oGetParam 1
1482: oPushResult
1483: oGetLocal 1
1485: oPushResult
1486: oSetResult 5
1488: oPushResult
1489: oNodeGet
1490: oPop 2
1492: oAssign
1493: oJumpForward 1506
1495: Choice Lookup Table
          10   1480
1498: oError 2
1500: oGetParam 1
1502: oPushResult
1503: oGetGlobal 3
1505: oAssign
1506: oJumpForward 1931
1508: oInput 15
1510: oGetAddrLocal 2
1512: oPushResult
1513: oNodeVecNew
1514: oAssign
1515: oGetAddrLocal 3
1517: oPushResult
1518: oSetResult 25
1520: oPushResult
1521: oNodeNew
1522: oPop 1
1524: oAssign
1525: oGetLocal 3
1527: oPushResult
1528: oSetResult 18
1530: oPushResult
1531: oGetGlobal 3
1533: oPushResult
1534: oNodeSet
1535: oPop 3
1537: oCall 1932
1539: oGetLocal 3
1541: oPushResult
1542: oSetResult 20
1544: oPushResult
1545: oValueTop
1546: oPushResult
1547: oNodeSetInt
1548: oPop 3
1550: oValuePop
1551: oInput 20
1553: oCall 1932
1555: oGetLocal 3
1557: oPushResult
1558: oSetResult 21
1560: oPushResult
1561: oValueTop
1562: oPushResult
1563: oNodeSetInt
1564: oPop 3
1566: oValuePop
1567: oGetLocal 3
1569: oPushResult
1570: oSetResult 2
1572: oPushResult
1573: oSetResult 4
1575: oPushResult
1576: oNodeSetInt
1577: oPop 3
1579: oGetLocal 3
1581: oPushResult
1582: oTypeAdd
1583: oPop 1
1585: oGetAddrLocal 4
1587: oPushResult
1588: oSetResult 24
1590: oPushResult
1591: oNodeNew
1592: oPop 1
1594: oAssign
1595: oGetLocal 4
1597: oPushResult
1598: oSetResult 19
1600: oPushResult
1601: oGetLocal 3
1603: oPushResult
1604: oNodeSet
1605: oPop 3
1607: oGetLocal 2
1609: oPushResult
1610: oGetLocal 4
1612: oPushResult
1613: oNodeVecAppend
1614: oPop 2
1616: oInputChoice 1624
1618: oJumpForward 1632
1620: oJumpForward 1630
1622: oJumpForward 1630
1624: Choice Lookup Table
          12   1622
          16   1618
1629: oEndChoice
1630: oJumpBack 1515
1632: oInput 38
1634: oGetAddrLocal 5
1636: oPushResult
1637: oCall 1463
1639: oPop 1
1641: oGetAddrLocal 6
1643: oPushResult
1644: oGetLocal 2
1646: oPushResult
1647: oNodeVecSize
1648: oPop 1
1650: oAssign
1651: oGetAddrLocal 6
1653: oPushResult
1654: dec
1655: oPop 1
1657: oGetAddrLocal 7
1659: oPushResult
1660: oGetLocal 2
1662: oPushResult
1663: oGetLocal 6
1665: oPushResult
1666: oNodeVecElement
1667: oPop 2
1669: oAssign
1670: oGetLocal 7
1672: oPushResult
1673: oSetResult 18
1675: oPushResult
1676: oGetLocal 5
1678: oPushResult
1679: oNodeSet
1680: oPop 3
1682: oGetAddrLocal 8
1684: oPushResult
1685: oGetLocal 7
1687: oPushResult
1688: oSetResult 19
1690: oPushResult
1691: oNodeGet
1692: oPop 2
1694: oAssign
1695: oGetAddrLocal 9
1697: oPushResult
1698: oGetLocal 8
1700: oPushResult
1701: oSetResult 21
1703: oPushResult
1704: oNodeGetInt
1705: oPop 2
1707: oPushResult
1708: oGetLocal 8
1710: oPushResult
1711: oSetResult 20
1713: oPushResult
1714: oNodeGetInt
1715: oPop 2
1717: oPushResult
1718: subtract
1719: oPop 2
1721: oAssign
1722: oGetAddrLocal 9
1724: oPushResult
1725: inc
1726: oPop 1
1728: oGetLocal 7
1730: oPushResult
1731: oSetResult 2
1733: oPushResult
1734: oGetLocal 9
1736: oPushResult
1737: oGetLocal 5
1739: oPushResult
1740: oSetResult 2
1742: oPushResult
1743: oNodeGetInt
1744: oPop 2
1746: oPushResult
1747: multiply
1748: oPop 2
1750: oPushResult
1751: oNodeSetInt
1752: oPop 3
1754: oGetLocal 7
1756: oPushResult
1757: oTypeAdd
1758: oPop 1
1760: oGetAddrLocal 5
1762: oPushResult
1763: oGetLocal 7
1765: oAssign
1766: oGetLocal 6
1768: oPushResult
1769: equal_zero
1770: oPop 1
1772: oChoice 1778
1774: oJumpForward 1783
1776: oJumpForward 1781
1778: Choice Lookup Table
           1   1774
1781: oJumpBack 1651
1783: oGetParam 1
1785: oPushResult
1786: oGetLocal 2
1788: oPushResult
1789: oSetResult 0
1791: oPushResult
1792: oNodeVecElement
1793: oPop 2
1795: oAssign
1796: oGetLocal 2
1798: oPushResult
1799: oNodeVecDelete
1800: oPop 1
1802: oJumpForward 1931
1804: oGetAddrLocal 10
1806: oPushResult
1807: oCall 1463
1809: oPop 1
1811: oGetParam 1
1813: oPushResult
1814: oGetLocal 10
1816: oPushResult
1817: oCall 5512
1819: oPop 1
1821: oAssign
1822: oJumpForward 1931
1824: oGetParam 1
1826: oPushResult
1827: oSetResult 26
1829: oPushResult
1830: oNodeNew
1831: oPop 1
1833: oAssign
1834: oScopeBegin
1835: oSetResult 14
1837: oPushResult
1838: oCall 1322
1840: oPop 1
1842: oGetAddrLocal 11
1844: oPushResult
1845: oScopeCurrent
1846: oPushResult
1847: oSetResult 2
1849: oPushResult
1850: oNodeGetInt
1851: oPop 2
1853: oAssign
1854: oGetLocal 11
1856: oPushResult
1857: equal_zero
1858: oPop 1
1860: oChoice 1866
1862: oError 19
1864: oJumpForward 1869
1866: Choice Lookup Table
           1   1862
1869: oInput 34
1871: oGetFromParam 1
1873: oPushResult
1874: oSetResult 22
1876: oPushResult
1877: oScopeCurrent
1878: oPushResult
1879: oNodeSet
1880: oPop 3
1882: oGetFromParam 1
1884: oPushResult
1885: oSetResult 2
1887: oPushResult
1888: oGetLocal 11
1890: oPushResult
1891: oNodeSetInt
1892: oPop 3
1894: oScopeEnd
1895: oGetFromParam 1
1897: oPushResult
1898: oTypeAdd
1899: oPop 1
1901: oJumpForward 1931
1903: oInput 38
1905: oGetAddrLocal 12
1907: oPushResult
1908: oCall 1463
1910: oPop 1
1912: oJumpForward 1931
1914: Choice Lookup Table
          37   1903
          36   1824
          17   1804
          35   1508
           0   1467
1925: oCall 1932
1927: oInput 20
1929: oCall 1932
1931: oReturn
1932: oLocalSpace 1
1934: oInputChoice 1989
1936: TOKEN_VALUE
1937: oPushResult
1938: oValuePush
1939: oPop 1
1941: oJumpForward 1997
1943: oGetAddrLocal 1
1945: oPushResult
1946: oScopeFindRequire
1947: oAssign
1948: oGetLocal 1
1950: oPushResult
1951: oNodeType
1952: oPop 1
1954: oChoice 1971
1956: oGetLocal 1
1958: oPushResult
1959: oSetResult 6
1961: oPushResult
1962: oNodeGetInt
1963: oPop 2
1965: oPushResult
1966: oValuePush
1967: oPop 1
1969: oJumpForward 1982
1971: Choice Lookup Table
           9   1956
1974: oError 1
1976: oSetResult 0
1978: oPushResult
1979: oValuePush
1980: oPop 1
1982: oJumpForward 1997
1984: oCall 1932
1986: oValueNegate
1987: oJumpForward 1997
1989: Choice Lookup Table
          24   1984
           0   1943
           1   1936
1996: oEndChoice
1997: oReturn
1998: oLocalSpace 1
2000: oGetAddrLocal 1
2002: oPushResult
2003: oSetResult 0
2005: oAssign
2006: oGetAddrLocal 1
2008: oPushResult
2009: oCall 2159
2011: oPop 1
2013: oGetAddrLocal 1
2015: oPushResult
2016: oCall 2059
2018: oPop 1
2020: oReturn
2021: oLocalSpace 0
2023: oGetParam 1
2025: oPushResult
2026: oCall 2159
2028: oPop 1
2030: oTypeSNodeType
2031: oChoice 2050
2033: oJumpForward 2057
2035: oGetParam 1
2037: oPushResult
2038: oLabelNew
2039: oAssign
2040: oEmit 45
2042: oGetFromParam 1
2044: oPushResult
2045: oEmitLabel
2046: oPop 1
2048: oJumpForward 2057
2050: Choice Lookup Table
          19   2035
          20   2033
2055: oError 8
2057: oTypeSPop
2058: oReturn
2059: oLocalSpace 1
2061: oTypeSNodeType
2062: oChoice 2124
2064: oGetAddrLocal 1
2066: oPushResult
2067: oLabelNew
2068: oAssign
2069: oEmit 9
2071: oSetResult 1
2073: oPushResult
2074: oEmitInt
2075: oPop 1
2077: oEmit 43
2079: oGetLocal 1
2081: oPushResult
2082: oEmitLabel
2083: oPop 1
2085: oEmit 46
2087: oGetFromParam 1
2089: oPushResult
2090: oEmitLabel
2091: oPop 1
2093: oEmit 9
2095: oSetResult 0
2097: oPushResult
2098: oEmitInt
2099: oPop 1
2101: oEmit 46
2103: oGetLocal 1
2105: oPushResult
2106: oEmitLabel
2107: oPop 1
2109: oTypeSPop
2110: oGetGlobal 4
2112: oPushResult
2113: oTypeSPush
2114: oPop 1
2116: oGetParam 1
2118: oPushResult
2119: oSetResult 0
2121: oAssign
2122: oJumpForward 2127
2124: Choice Lookup Table
          20   2064
2127: oReturn
2128: oLocalSpace 0
2130: oTypeSNodeType
2131: oChoice 2155
2133: oGetParam 1
2135: oPushResult
2136: oLabelNew
2137: oAssign
2138: oEmit 45
2140: oGetFromParam 1
2142: oPushResult
2143: oEmitLabel
2144: oPop 1
2146: oTypeSPop
2147: oGetGlobal 5
2149: oPushResult
2150: oTypeSPush
2151: oPop 1
2153: oJumpForward 2158
2155: Choice Lookup Table
          19   2133
2158: oReturn
2159: oLocalSpace 0
2161: oGetParam 1
2163: oPushResult
2164: oCall 2524
2166: oPop 1
2168: oInputChoice 2506
2170: oGetParam 1
2172: oPushResult
2173: oCall 2059
2175: oPop 1
2177: oGetParam 1
2179: oPushResult
2180: oCall 2524
2182: oPop 1
2184: oGetParam 1
2186: oPushResult
2187: oCall 2059
2189: oPop 1
2191: oCall 5370
2193: oTypeSNodeType
2194: oChoice 2208
2196: oEmit 30
2198: oJumpForward 2221
2200: oEmit 36
2202: oJumpForward 2221
2204: oError 16
2206: oJumpForward 2221
2208: Choice Lookup Table
          22   2204
          21   2204
          23   2200
          19   2196
          18   2196
2219: oError 17
2221: oTypeSPop
2222: oGetGlobal 4
2224: oPushResult
2225: oTypeSPush
2226: oPop 1
2228: oJumpForward 2521
2230: oGetParam 1
2232: oPushResult
2233: oCall 2059
2235: oPop 1
2237: oGetParam 1
2239: oPushResult
2240: oCall 2524
2242: oPop 1
2244: oGetParam 1
2246: oPushResult
2247: oCall 2059
2249: oPop 1
2251: oCall 5370
2253: oTypeSNodeType
2254: oChoice 2268
2256: oEmit 31
2258: oJumpForward 2281
2260: oEmit 37
2262: oJumpForward 2281
2264: oError 16
2266: oJumpForward 2281
2268: Choice Lookup Table
          22   2264
          21   2264
          23   2260
          19   2256
          18   2256
2279: oError 17
2281: oTypeSPop
2282: oGetGlobal 4
2284: oPushResult
2285: oTypeSPush
2286: oPop 1
2288: oJumpForward 2521
2290: oGetParam 1
2292: oPushResult
2293: oCall 2059
2295: oPop 1
2297: oGetParam 1
2299: oPushResult
2300: oCall 2524
2302: oPop 1
2304: oGetParam 1
2306: oPushResult
2307: oCall 2059
2309: oPop 1
2311: oCall 5370
2313: oTypeSNodeType
2314: oChoice 2324
2316: oEmit 33
2318: oJumpForward 2335
2320: oError 16
2322: oJumpForward 2335
2324: Choice Lookup Table
          22   2320
          21   2320
          19   2316
          18   2316
2333: oError 17
2335: oTypeSPop
2336: oGetGlobal 4
2338: oPushResult
2339: oTypeSPush
2340: oPop 1
2342: oJumpForward 2521
2344: oGetParam 1
2346: oPushResult
2347: oCall 2059
2349: oPop 1
2351: oGetParam 1
2353: oPushResult
2354: oCall 2524
2356: oPop 1
2358: oGetParam 1
2360: oPushResult
2361: oCall 2059
2363: oPop 1
2365: oCall 5370
2367: oTypeSNodeType
2368: oChoice 2378
2370: oEmit 32
2372: oJumpForward 2389
2374: oError 16
2376: oJumpForward 2389
2378: Choice Lookup Table
          22   2374
          21   2374
          19   2370
          18   2370
2387: oError 17
2389: oTypeSPop
2390: oGetGlobal 4
2392: oPushResult
2393: oTypeSPush
2394: oPop 1
2396: oJumpForward 2521
2398: oGetParam 1
2400: oPushResult
2401: oCall 2059
2403: oPop 1
2405: oGetParam 1
2407: oPushResult
2408: oCall 2524
2410: oPop 1
2412: oGetParam 1
2414: oPushResult
2415: oCall 2059
2417: oPop 1
2419: oCall 5370
2421: oTypeSNodeType
2422: oChoice 2432
2424: oEmit 35
2426: oJumpForward 2443
2428: oError 16
2430: oJumpForward 2443
2432: Choice Lookup Table
          22   2428
          21   2428
          19   2424
          18   2424
2441: oError 17
2443: oTypeSPop
2444: oGetGlobal 4
2446: oPushResult
2447: oTypeSPush
2448: oPop 1
2450: oJumpForward 2521
2452: oGetParam 1
2454: oPushResult
2455: oCall 2059
2457: oPop 1
2459: oGetParam 1
2461: oPushResult
2462: oCall 2524
2464: oPop 1
2466: oGetParam 1
2468: oPushResult
2469: oCall 2059
2471: oPop 1
2473: oCall 5370
2475: oTypeSNodeType
2476: oChoice 2486
2478: oEmit 34
2480: oJumpForward 2497
2482: oError 16
2484: oJumpForward 2497
2486: Choice Lookup Table
          22   2482
          21   2482
          19   2478
          18   2478
2495: oError 17
2497: oTypeSPop
2498: oGetGlobal 4
2500: oPushResult
2501: oTypeSPush
2502: oPop 1
2504: oJumpForward 2521
2506: Choice Lookup Table
          10   2452
           9   2398
           8   2344
           7   2290
           6   2230
           5   2170
2519: oJumpForward 2523
2521: oJumpBack 2168
2523: oReturn
2524: oLocalSpace 1
2526: oGetAddrLocal 1
2528: oPushResult
2529: oSetResult 0
2531: oAssign
2532: oGetParam 1
2534: oPushResult
2535: oCall 2704
2537: oPop 1
2539: oInputChoice 2672
2541: oTypeSNodeType
2542: oChoice 2613
2544: oGetLocal 1
2546: oPushResult
2547: oSetResult 0
2549: oPushResult
2550: equal_label
2551: oPop 2
2553: oChoice 2562
2555: oGetAddrLocal 1
2557: oPushResult
2558: oLabelNew
2559: oAssign
2560: oJumpForward 2565
2562: Choice Lookup Table
           1   2555
2565: oEmit 43
2567: oGetLocal 1
2569: oPushResult
2570: oEmitLabel
2571: oPop 1
2573: oJumpForward 2620
2575: oGetParam 1
2577: oPushResult
2578: oCall 2128
2580: oPop 1
2582: oGetLocal 1
2584: oPushResult
2585: oSetResult 0
2587: oPushResult
2588: equal_label
2589: oPop 2
2591: oChoice 2600
2593: oGetAddrLocal 1
2595: oPushResult
2596: oLabelNew
2597: oAssign
2598: oJumpForward 2603
2600: Choice Lookup Table
           1   2593
2603: oEmit 44
2605: oGetLocal 1
2607: oPushResult
2608: oEmitLabel
2609: oPop 1
2611: oJumpForward 2620
2613: Choice Lookup Table
          19   2575
          20   2544
2618: oError 8
2620: oTypeSPop
2621: oEmit 46
2623: oGetFromParam 1
2625: oPushResult
2626: oEmitLabel
2627: oPop 1
2629: oGetParam 1
2631: oPushResult
2632: oSetResult 0
2634: oAssign
2635: oGetParam 1
2637: oPushResult
2638: oCall 2704
2640: oPop 1
2642: oTypeSNodeType
2643: oChoice 2656
2645: oJumpForward 2663
2647: oGetParam 1
2649: oPushResult
2650: oCall 2128
2652: oPop 1
2654: oJumpForward 2663
2656: Choice Lookup Table
          19   2647
          20   2645
2661: oError 8
2663: oTypeSPop
2664: oGetGlobal 5
2666: oPushResult
2667: oTypeSPush
2668: oPop 1
2670: oJumpForward 2677
2672: Choice Lookup Table
          53   2541
2675: oJumpForward 2679
2677: oJumpBack 2539
2679: oGetLocal 1
2681: oPushResult
2682: oSetResult 0
2684: oPushResult
2685: equal_label
2686: oPop 2
2688: oChoice 2700
2690: oEmit 46
2692: oGetLocal 1
2694: oPushResult
2695: oEmitLabel
2696: oPop 1
2698: oJumpForward 2703
2700: Choice Lookup Table
           0   2690
2703: oReturn
2704: oLocalSpace 2
2706: oGetAddrLocal 1
2708: oPushResult
2709: oSetResult 0
2711: oAssign
2712: oGetParam 1
2714: oPushResult
2715: oCall 2842
2717: oPop 1
2719: oInputChoice 2834
2721: oTypeSNodeType
2722: oChoice 2735
2724: oJumpForward 2742
2726: oGetParam 1
2728: oPushResult
2729: oCall 2128
2731: oPop 1
2733: oJumpForward 2742
2735: Choice Lookup Table
          19   2726
          20   2724
2740: oError 8
2742: oTypeSPop
2743: oGetLocal 1
2745: oPushResult
2746: oSetResult 0
2748: oPushResult
2749: equal_label
2750: oPop 2
2752: oChoice 2781
2754: oGetAddrLocal 1
2756: oPushResult
2757: oLabelNew
2758: oAssign
2759: oEmit 47
2761: oGetFromParam 1
2763: oPushResult
2764: oEmitLabel
2765: oPop 1
2767: oGetLocal 1
2769: oPushResult
2770: oEmitLabel
2771: oPop 1
2773: oGetParam 1
2775: oPushResult
2776: oGetLocal 1
2778: oAssign
2779: oJumpForward 2784
2781: Choice Lookup Table
           1   2754
2784: oGetAddrLocal 2
2786: oPushResult
2787: oSetResult 0
2789: oAssign
2790: oGetAddrLocal 2
2792: oPushResult
2793: oCall 2842
2795: oPop 1
2797: oTypeSNodeType
2798: oChoice 2811
2800: oJumpForward 2818
2802: oGetAddrLocal 2
2804: oPushResult
2805: oCall 2128
2807: oPop 1
2809: oJumpForward 2818
2811: Choice Lookup Table
          19   2802
          20   2800
2816: oError 8
2818: oEmit 47
2820: oGetLocal 2
2822: oPushResult
2823: oEmitLabel
2824: oPop 1
2826: oGetLocal 1
2828: oPushResult
2829: oEmitLabel
2830: oPop 1
2832: oJumpForward 2839
2834: Choice Lookup Table
          52   2721
2837: oJumpForward 2841
2839: oJumpBack 2719
2841: oReturn
2842: oLocalSpace 1
2844: oInputChoice 2898
2846: oGetAddrLocal 1
2848: oPushResult
2849: oSetResult 0
2851: oAssign
2852: oGetAddrLocal 1
2854: oPushResult
2855: oCall 2842
2857: oPop 1
2859: oTypeSNodeType
2860: oChoice 2889
2862: oGetParam 1
2864: oPushResult
2865: oLabelNew
2866: oAssign
2867: oEmit 43
2869: oGetFromParam 1
2871: oPushResult
2872: oEmitLabel
2873: oPop 1
2875: oEmit 46
2877: oGetLocal 1
2879: oPushResult
2880: oEmitLabel
2881: oPop 1
2883: oJumpForward 2896
2885: oEmit 29
2887: oJumpForward 2896
2889: Choice Lookup Table
          19   2885
          20   2862
2894: oError 8
2896: oJumpForward 2908
2898: Choice Lookup Table
          54   2846
2901: oGetParam 1
2903: oPushResult
2904: oCall 2909
2906: oPop 1
2908: oReturn
2909: oLocalSpace 0
2911: oGetParam 1
2913: oPushResult
2914: oCall 2960
2916: oPop 1
2918: oInputChoice 2950
2920: oCall 5396
2922: oGetParam 1
2924: oPushResult
2925: oCall 2960
2927: oPop 1
2929: oCall 5410
2931: oEmit 26
2933: oJumpForward 2957
2935: oCall 5396
2937: oGetParam 1
2939: oPushResult
2940: oCall 2960
2942: oPop 1
2944: oCall 5410
2946: oEmit 27
2948: oJumpForward 2957
2950: Choice Lookup Table
          24   2935
          23   2920
2955: oJumpForward 2959
2957: oJumpBack 2918
2959: oReturn
2960: oLocalSpace 0
2962: oGetParam 1
2964: oPushResult
2965: oCall 3011
2967: oPop 1
2969: oInputChoice 3001
2971: oCall 5396
2973: oGetParam 1
2975: oPushResult
2976: oCall 3011
2978: oPop 1
2980: oCall 5410
2982: oEmit 23
2984: oJumpForward 3008
2986: oCall 5396
2988: oGetParam 1
2990: oPushResult
2991: oCall 3011
2993: oPop 1
2995: oCall 5410
2997: oEmit 24
2999: oJumpForward 3008
3001: Choice Lookup Table
          22   2986
          21   2971
3006: oJumpForward 3010
3008: oJumpBack 2969
3010: oReturn
3011: oLocalSpace 0
3013: oInputChoice 3039
3015: oGetParam 1
3017: oPushResult
3018: oCall 3052
3020: oPop 1
3022: oCall 5410
3024: oJumpForward 3051
3026: oGetParam 1
3028: oPushResult
3029: oCall 3052
3031: oPop 1
3033: oCall 5410
3035: oEmit 28
3037: oJumpForward 3051
3039: Choice Lookup Table
          24   3026
          23   3015
3044: oGetParam 1
3046: oPushResult
3047: oCall 3052
3049: oPop 1
3051: oReturn
3052: oLocalSpace 5
3054: oInputChoice 3232
3056: oEmit 9
3058: TOKEN_VALUE
3059: oPushResult
3060: oEmitInt
3061: oPop 1
3063: oGetGlobal 3
3065: oPushResult
3066: oTypeSPush
3067: oPop 1
3069: oJumpForward 3251
3071: oGetParam 1
3073: oPushResult
3074: oCall 2159
3076: oPop 1
3078: oInput 14
3080: oJumpForward 3251
3082: oStringAllocLit
3083: oEmit 10
3085: oValueTop
3086: oPushResult
3087: oEmitInt
3088: oPop 1
3090: oValuePop
3091: oGetGlobal 7
3093: oPushResult
3094: oTypeSPush
3095: oPop 1
3097: oJumpForward 3251
3099: oGetAddrLocal 1
3101: oPushResult
3102: oScopeFindRequire
3103: oAssign
3104: oGetLocal 1
3106: oPushResult
3107: oNodeType
3108: oPop 1
3110: oChoice 3172
3112: oGetLocal 1
3114: oPushResult
3115: oCall 3974
3117: oPop 1
3119: oJumpForward 3191
3121: oGetAddrLocal 2
3123: oPushResult
3124: oGetLocal 1
3126: oPushResult
3127: oSetResult 5
3129: oPushResult
3130: oNodeGet
3131: oPop 2
3133: oAssign
3134: oGetLocal 2
3136: oPushResult
3137: oTypeSPush
3138: oPop 1
3140: oTypeSNodeType
3141: oChoice 3154
3143: oEmit 9
3145: oGetLocal 1
3147: oPushResult
3148: oCall 5647
3150: oPop 1
3152: oJumpForward 3161
3154: Choice Lookup Table
          19   3143
          18   3143
3159: oError 16
3161: oJumpForward 3191
3163: oGetLocal 1
3165: oPushResult
3166: oCall 3252
3168: oPop 1
3170: oJumpForward 3191
3172: Choice Lookup Table
          15   3163
          13   3163
          12   3163
           9   3121
           8   3112
3183: oError 6
3185: oGetGlobal 3
3187: oPushResult
3188: oTypeSPush
3189: oPop 1
3191: oJumpForward 3251
3193: oInput 0
3195: oGetAddrLocal 3
3197: oPushResult
3198: oScopeFindRequire
3199: oAssign
3200: oGetLocal 3
3202: oPushResult
3203: oCall 4689
3205: oPop 1
3207: oGetAddrLocal 4
3209: oPushResult
3210: oTypeSTop
3211: oAssign
3212: oTypeSPop
3213: oGetAddrLocal 5
3215: oPushResult
3216: oGetLocal 4
3218: oPushResult
3219: oCall 5512
3221: oPop 1
3223: oAssign
3224: oGetLocal 5
3226: oPushResult
3227: oTypeSPush
3228: oPop 1
3230: oJumpForward 3251
3232: Choice Lookup Table
          18   3193
           0   3099
           2   3082
          13   3071
           1   3056
3243: oError 6
3245: oGetGlobal 3
3247: oPushResult
3248: oTypeSPush
3249: oPop 1
3251: oReturn
3252: oLocalSpace 1
3254: oGetAddrLocal 1
3256: oPushResult
3257: oGetParam 1
3259: oPushResult
3260: oSetResult 5
3262: oPushResult
3263: oNodeGet
3264: oPop 2
3266: oAssign
3267: oGetLocal 1
3269: oPushResult
3270: oTypeSPush
3271: oPop 1
3273: oTypeSNodeType
3274: oChoice 3539
3276: oGetParam 1
3278: oPushResult
3279: oNodeType
3280: oPop 1
3282: oChoice 3344
3284: oEmit 0
3286: oGetParam 1
3288: oPushResult
3289: oCall 5647
3291: oPop 1
3293: oJumpForward 3352
3295: oEmit 3
3297: oGetParam 1
3299: oPushResult
3300: oCall 5647
3302: oPop 1
3304: oJumpForward 3352
3306: oGetParam 1
3308: oPushResult
3309: oSetResult 16
3311: oPushResult
3312: oNodeGetBoolean
3313: oPop 2
3315: oChoice 3330
3317: oEmit 8
3319: oGetParam 1
3321: oPushResult
3322: oCall 5647
3324: oPop 1
3326: oEmit 14
3328: oJumpForward 3342
3330: Choice Lookup Table
           1   3317
3333: oEmit 6
3335: oGetParam 1
3337: oPushResult
3338: oCall 5647
3340: oPop 1
3342: oJumpForward 3352
3344: Choice Lookup Table
          15   3306
          13   3295
          12   3284
3351: oEndChoice
3352: oJumpForward 3630
3354: oGetParam 1
3356: oPushResult
3357: oNodeType
3358: oPop 1
3360: oChoice 3422
3362: oEmit 1
3364: oGetParam 1
3366: oPushResult
3367: oCall 5647
3369: oPop 1
3371: oJumpForward 3430
3373: oEmit 4
3375: oGetParam 1
3377: oPushResult
3378: oCall 5647
3380: oPop 1
3382: oJumpForward 3430
3384: oGetParam 1
3386: oPushResult
3387: oSetResult 16
3389: oPushResult
3390: oNodeGetBoolean
3391: oPop 2
3393: oChoice 3408
3395: oEmit 8
3397: oGetParam 1
3399: oPushResult
3400: oCall 5647
3402: oPop 1
3404: oEmit 15
3406: oJumpForward 3420
3408: Choice Lookup Table
           1   3395
3411: oEmit 7
3413: oGetParam 1
3415: oPushResult
3416: oCall 5647
3418: oPop 1
3420: oJumpForward 3430
3422: Choice Lookup Table
          15   3384
          13   3373
          12   3362
3429: oEndChoice
3430: oJumpForward 3630
3432: oError 16
3434: oJumpForward 3630
3436: oGetParam 1
3438: oPushResult
3439: oNodeType
3440: oPop 1
3442: oChoice 3504
3444: oEmit 2
3446: oGetParam 1
3448: oPushResult
3449: oCall 5647
3451: oPop 1
3453: oJumpForward 3512
3455: oEmit 5
3457: oGetParam 1
3459: oPushResult
3460: oCall 5647
3462: oPop 1
3464: oJumpForward 3512
3466: oGetParam 1
3468: oPushResult
3469: oSetResult 16
3471: oPushResult
3472: oNodeGetBoolean
3473: oPop 2
3475: oChoice 3490
3477: oEmit 8
3479: oGetParam 1
3481: oPushResult
3482: oCall 5647
3484: oPop 1
3486: oEmit 16
3488: oJumpForward 3502
3490: Choice Lookup Table
           1   3477
3493: oEmit 8
3495: oGetParam 1
3497: oPushResult
3498: oCall 5647
3500: oPop 1
3502: oJumpForward 3512
3504: Choice Lookup Table
          15   3466
          13   3455
          12   3444
3511: oEndChoice
3512: oInputChoice 3534
3514: oTypeSPop
3515: oGetLocal 1
3517: oPushResult
3518: oSetResult 18
3520: oPushResult
3521: oNodeGet
3522: oPop 2
3524: oPushResult
3525: oTypeSPush
3526: oPop 1
3528: oCall 3666
3530: oCall 3631
3532: oJumpForward 3537
3534: Choice Lookup Table
          17   3514
3537: oJumpForward 3630
3539: Choice Lookup Table
          23   3436
          17   3432
          22   3432
          21   3432
          19   3354
          18   3276
3552: oGetParam 1
3554: oPushResult
3555: oNodeType
3556: oPop 1
3558: oChoice 3618
3560: oEmit 10
3562: oGetParam 1
3564: oPushResult
3565: oCall 5647
3567: oPop 1
3569: oJumpForward 3626
3571: oEmit 11
3573: oGetParam 1
3575: oPushResult
3576: oCall 5647
3578: oPop 1
3580: oJumpForward 3626
3582: oGetParam 1
3584: oPushResult
3585: oSetResult 16
3587: oPushResult
3588: oNodeGetBoolean
3589: oPop 2
3591: oChoice 3604
3593: oEmit 8
3595: oGetParam 1
3597: oPushResult
3598: oCall 5647
3600: oPop 1
3602: oJumpForward 3616
3604: Choice Lookup Table
           1   3593
3607: oEmit 12
3609: oGetParam 1
3611: oPushResult
3612: oCall 5647
3614: oPop 1
3616: oJumpForward 3626
3618: Choice Lookup Table
          15   3582
          13   3571
          12   3560
3625: oEndChoice
3626: oCall 3666
3628: oCall 3631
3630: oReturn
3631: oLocalSpace 0
3633: oTypeSNodeType
3634: oChoice 3652
3636: oEmit 14
3638: oJumpForward 3665
3640: oEmit 15
3642: oJumpForward 3665
3644: oError 16
3646: oJumpForward 3665
3648: oEmit 16
3650: oJumpForward 3665
3652: Choice Lookup Table
          23   3648
          17   3644
          22   3644
          21   3644
          19   3640
          18   3636
3665: oReturn
3666: oLocalSpace 0
3668: oInputChoice 3682
3670: oCall 3694
3672: oJumpForward 3691
3674: oCall 3837
3676: oJumpForward 3691
3678: oCall 3935
3680: oJumpForward 3691
3682: Choice Lookup Table
          17   3678
          19   3674
          15   3670
3689: oJumpForward 3693
3691: oJumpBack 3668
3693: oReturn
3694: oLocalSpace 3
3696: oTypeSNodeType
3697: oChoice 3701
3699: oJumpForward 3706
3701: Choice Lookup Table
          24   3699
3704: oError 10
3706: oTypeSNodeType
3707: oChoice 3711
3709: oJumpForward 3716
3711: Choice Lookup Table
          24   3709
3714: oError 13
3716: oGetAddrLocal 1
3718: oPushResult
3719: oTypeSTop
3720: oPushResult
3721: oSetResult 19
3723: oPushResult
3724: oNodeGet
3725: oPop 2
3727: oPushResult
3728: oCall 5596
3730: oPop 1
3732: oAssign
3733: oGetAddrLocal 2
3735: oPushResult
3736: oTypeSTop
3737: oPushResult
3738: oSetResult 18
3740: oPushResult
3741: oNodeGet
3742: oPop 2
3744: oAssign
3745: oTypeSPop
3746: oGetLocal 2
3748: oPushResult
3749: oTypeSPush
3750: oPop 1
3752: oCall 1998
3754: oCall 5396
3756: oGetLocal 1
3758: oPushResult
3759: equal_zero
3760: oPop 1
3762: oChoice 3776
3764: oEmit 9
3766: oGetLocal 1
3768: oPushResult
3769: oEmitInt
3770: oPop 1
3772: oEmit 27
3774: oJumpForward 3779
3776: Choice Lookup Table
           0   3764
3779: oGetAddrLocal 3
3781: oPushResult
3782: oGetLocal 2
3784: oPushResult
3785: oSetResult 2
3787: oPushResult
3788: oNodeGetInt
3789: oPop 2
3791: oAssign
3792: oGetLocal 3
3794: oPushResult
3795: oSetResult 1
3797: oPushResult
3798: equal
3799: oPop 2
3801: oChoice 3815
3803: oEmit 9
3805: oGetLocal 3
3807: oPushResult
3808: oEmitInt
3809: oPop 1
3811: oEmit 23
3813: oJumpForward 3818
3815: Choice Lookup Table
           0   3803
3818: oEmit 25
3820: oInputChoice 3828
3822: oJumpForward 3836
3824: oJumpForward 3834
3826: oJumpForward 3834
3828: Choice Lookup Table
          12   3826
          16   3822
3833: oEndChoice
3834: oJumpBack 3706
3836: oReturn
3837: oLocalSpace 2
3839: oTypeSNodeType
3840: oChoice 3844
3842: oJumpForward 3849
3844: Choice Lookup Table
          26   3842
3847: oError 11
3849: oTypeSTop
3850: oPushResult
3851: oSetResult 22
3853: oPushResult
3854: oNodeGet
3855: oPop 2
3857: oPushResult
3858: oScopeEnter
3859: oPop 1
3861: oInput 0
3863: oGetAddrLocal 1
3865: oPushResult
3866: oScopeFindRequire
3867: oAssign
3868: oGetLocal 1
3870: oPushResult
3871: oNodeType
3872: oPop 1
3874: oChoice 3878
3876: oJumpForward 3883
3878: Choice Lookup Table
          14   3876
3881: oError 12
3883: oScopeEnd
3884: oGetAddrLocal 2
3886: oPushResult
3887: oGetLocal 1
3889: oPushResult
3890: oSetResult 6
3892: oPushResult
3893: oNodeGetInt
3894: oPop 2
3896: oAssign
3897: oGetLocal 2
3899: oPushResult
3900: equal_zero
3901: oPop 1
3903: oChoice 3917
3905: oEmit 9
3907: oGetLocal 2
3909: oPushResult
3910: oEmitInt
3911: oPop 1
3913: oEmit 25
3915: oJumpForward 3920
3917: Choice Lookup Table
           0   3905
3920: oTypeSPop
3921: oGetLocal 1
3923: oPushResult
3924: oSetResult 5
3926: oPushResult
3927: oNodeGet
3928: oPop 2
3930: oPushResult
3931: oTypeSPush
3932: oPop 1
3934: oReturn
3935: oLocalSpace 1
3937: oTypeSNodeType
3938: oChoice 3942
3940: oJumpForward 3947
3942: Choice Lookup Table
          23   3940
3945: oError 9
3947: oEmit 16
3949: oGetAddrLocal 1
3951: oPushResult
3952: oTypeSTop
3953: oAssign
3954: oTypeSPop
3955: oGetLocal 1
3957: oPushResult
3958: oSetResult 18
3960: oPushResult
3961: oNodeGet
3962: oPop 2
3964: oPushResult
3965: oTypeSPush
3966: oPop 1
3968: oReturn
3969: oLocalSpace 0
3971: oCall 5370
3973: oReturn
3974: oLocalSpace 8
3976: oGetAddrLocal 3
3978: oPushResult
3979: oGetParam 1
3981: oPushResult
3982: oNodeType
3983: oPop 1
3985: oPushResult
3986: oSetResult 8
3988: oPushResult
3989: equal_node_type
3990: oPop 2
3992: oAssign
3993: oGetLocal 3
3995: oChoice 4022
3997: oGetAddrLocal 1
3999: oPushResult
4000: oGetParam 1
4002: oPushResult
4003: oSetResult 5
4005: oPushResult
4006: oNodeGet
4007: oPop 2
4009: oAssign
4010: oGetAddrLocal 2
4012: oPushResult
4013: oGetLocal 1
4015: oPushResult
4016: oScopeAllocType
4017: oPop 1
4019: oAssign
4020: oJumpForward 4025
4022: Choice Lookup Table
           1   3997
4025: oGetAddrLocal 4
4027: oPushResult
4028: oGetParam 1
4030: oPushResult
4031: oSetResult 8
4033: oPushResult
4034: oNodeGet
4035: oPop 2
4037: oAssign
4038: oGetAddrLocal 5
4040: oPushResult
4041: oGetLocal 4
4043: oPushResult
4044: oSetResult 2
4046: oPushResult
4047: oNodeGetInt
4048: oPop 2
4050: oAssign
4051: oEmit 38
4053: oGetLocal 5
4055: oPushResult
4056: oEmitInt
4057: oPop 1
4059: oGetAddrLocal 6
4061: oPushResult
4062: oGetLocal 4
4064: oPushResult
4065: oSetResult 1
4067: oPushResult
4068: oNodeGet
4069: oPop 2
4071: oAssign
4072: oInputChoice 4241
4074: oGetLocal 6
4076: oPushResult
4077: oNodeNull
4078: oPop 1
4080: oChoice 4086
4082: oJumpForward 4237
4084: oJumpForward 4089
4086: Choice Lookup Table
           1   4082
4089: oGetAddrLocal 7
4091: oPushResult
4092: oGetLocal 6
4094: oPushResult
4095: oSetResult 6
4097: oPushResult
4098: oNodeGetInt
4099: oPop 2
4101: oAssign
4102: oEmit 13
4104: oGetLocal 7
4106: oPushResult
4107: oEmitInt
4108: oPop 1
4110: oGetLocal 6
4112: oPushResult
4113: oSetResult 5
4115: oPushResult
4116: oNodeGet
4117: oPop 2
4119: oPushResult
4120: oTypeSPush
4121: oPop 1
4123: oGetLocal 6
4125: oPushResult
4126: oSetResult 16
4128: oPushResult
4129: oNodeGetBoolean
4130: oPop 2
4132: oChoice 4200
4134: oCall 4653
4136: oCall 5370
4138: oEmit 19
4140: oJumpForward 4206
4142: oCall 1998
4144: oCall 3969
4146: oTypeSNodeType
4147: oChoice 4165
4149: oEmit 17
4151: oJumpForward 4198
4153: oEmit 18
4155: oJumpForward 4198
4157: oError 16
4159: oJumpForward 4198
4161: oEmit 19
4163: oJumpForward 4198
4165: Choice Lookup Table
          23   4161
          17   4157
          22   4157
          21   4157
          19   4153
          18   4149
4178: oGetAddrLocal 8
4180: oPushResult
4181: oTypeSTop
4182: oPushResult
4183: oSetResult 2
4185: oPushResult
4186: oNodeGetInt
4187: oPop 2
4189: oAssign
4190: oEmit 20
4192: oGetLocal 8
4194: oPushResult
4195: oEmitInt
4196: oPop 1
4198: oJumpForward 4206
4200: Choice Lookup Table
           0   4142
           1   4134
4205: oEndChoice
4206: oTypeSPop
4207: oGetAddrLocal 6
4209: oPushResult
4210: oNodeNext
4211: oPop 1
4213: oGetLocal 6
4215: oPushResult
4216: oNodeNull
4217: oPop 1
4219: oChoice 4227
4221: oJumpForward 4237
4223: oJumpForward 4233
4225: oJumpForward 4233
4227: Choice Lookup Table
           0   4225
           1   4221
4232: oEndChoice
4233: oInput 12
4235: oJumpBack 4074
4237: oInput 14
4239: oJumpForward 4244
4241: Choice Lookup Table
          13   4074
4244: oGetLocal 6
4246: oPushResult
4247: oNodeNull
4248: oPop 1
4250: oChoice 4256
4252: oError 15
4254: oJumpForward 4259
4256: Choice Lookup Table
           0   4252
4259: oGetLocal 3
4261: oChoice 4290
4263: oEmit 13
4265: oGetParam 1
4267: oPushResult
4268: oSetResult 15
4270: oPushResult
4271: oNodeGetInt
4272: oPop 2
4274: oPushResult
4275: oEmitInt
4276: oPop 1
4278: oEmit 11
4280: oGetLocal 2
4282: oPushResult
4283: oEmitInt
4284: oPop 1
4286: oEmit 19
4288: oJumpForward 4293
4290: Choice Lookup Table
           1   4263
4293: oEmit 40
4295: oGetParam 1
4297: oPushResult
4298: oCall 5647
4300: oPop 1
4302: oGetLocal 3
4304: oChoice 4324
4306: oGetLocal 1
4308: oPushResult
4309: oTypeSPush
4310: oPop 1
4312: oEmit 11
4314: oGetLocal 2
4316: oPushResult
4317: oEmitInt
4318: oPop 1
4320: oCall 3631
4322: oJumpForward 4327
4324: Choice Lookup Table
           1   4306
4327: oEmit 39
4329: oGetLocal 5
4331: oPushResult
4332: oEmitInt
4333: oPop 1
4335: oReturn
4336: oLocalSpace 0
4338: oInputChoice 4388
4340: oCall 5290
4342: oJumpForward 4413
4344: oCall 5297
4346: oJumpForward 4413
4348: oCall 5364
4350: oJumpForward 4413
4352: oCall 5367
4354: oJumpForward 4413
4356: oCall 4830
4358: oJumpForward 4413
4360: oCall 5150
4362: oJumpForward 4413
4364: oCall 4896
4366: oJumpForward 4413
4368: oCall 5070
4370: oJumpForward 4413
4372: oCall 5235
4374: oJumpForward 4413
4376: oCall 5203
4378: oJumpForward 4413
4380: oCall 5267
4382: oJumpForward 4413
4384: oCall 4414
4386: oJumpForward 4413
4388: Choice Lookup Table
           0   4384
          33   4380
          49   4376
          50   4372
          47   4368
          42   4364
          46   4360
          39   4356
          58   4352
          57   4348
          56   4344
          55   4340
4413: oReturn
4414: oLocalSpace 1
4416: oGetAddrLocal 1
4418: oPushResult
4419: oScopeFindRequire
4420: oAssign
4421: oGetLocal 1
4423: oPushResult
4424: oNodeType
4425: oPop 1
4427: oChoice 4456
4429: oGetLocal 1
4431: oPushResult
4432: oCall 3974
4434: oPop 1
4436: oJumpForward 4469
4438: oGetLocal 1
4440: oPushResult
4441: oCall 4470
4443: oPop 1
4445: oJumpForward 4469
4447: oGetLocal 1
4449: oPushResult
4450: oCall 4539
4452: oPop 1
4454: oJumpForward 4469
4456: Choice Lookup Table
           8   4447
          15   4438
          13   4438
          12   4438
           7   4429
4467: oError 0
4469: oReturn
4470: oLocalSpace 1
4472: oGetParam 1
4474: oPushResult
4475: oCall 4689
4477: oPop 1
4479: oInput 3
4481: oCall 1998
4483: oCall 5370
4485: oTypeSNodeType
4486: oChoice 4504
4488: oEmit 17
4490: oJumpForward 4537
4492: oEmit 18
4494: oJumpForward 4537
4496: oError 16
4498: oJumpForward 4537
4500: oEmit 19
4502: oJumpForward 4537
4504: Choice Lookup Table
          23   4500
          17   4496
          22   4496
          21   4496
          19   4492
          18   4488
4517: oGetAddrLocal 1
4519: oPushResult
4520: oTypeSTop
4521: oPushResult
4522: oSetResult 2
4524: oPushResult
4525: oNodeGetInt
4526: oPop 2
4528: oAssign
4529: oEmit 20
4531: oGetLocal 1
4533: oPushResult
4534: oEmitInt
4535: oPop 1
4537: oTypeSPop
4538: oReturn
4539: oLocalSpace 1
4541: oGetParam 1
4543: oPushResult
4544: oSetResult 9
4546: oPushResult
4547: oNodeGet
4548: oPop 2
4550: oPushResult
4551: oScopeCurrent
4552: oPushResult
4553: oNodeEqual
4554: oPop 2
4556: oChoice 4562
4558: oError 20
4560: oJumpForward 4565
4562: Choice Lookup Table
           0   4558
4565: oEmit 8
4567: oGetParam 1
4569: oPushResult
4570: oSetResult 15
4572: oPushResult
4573: oNodeGetInt
4574: oPop 2
4576: oPushResult
4577: oEmitInt
4578: oPop 1
4580: oGetParam 1
4582: oPushResult
4583: oSetResult 5
4585: oPushResult
4586: oNodeGet
4587: oPop 2
4589: oPushResult
4590: oTypeSPush
4591: oPop 1
4593: oInput 3
4595: oCall 1998
4597: oCall 5370
4599: oTypeSNodeType
4600: oChoice 4618
4602: oEmit 17
4604: oJumpForward 4651
4606: oEmit 18
4608: oJumpForward 4651
4610: oError 16
4612: oJumpForward 4651
4614: oEmit 19
4616: oJumpForward 4651
4618: Choice Lookup Table
          23   4614
          17   4610
          22   4610
          21   4610
          19   4606
          18   4602
4631: oGetAddrLocal 1
4633: oPushResult
4634: oTypeSTop
4635: oPushResult
4636: oSetResult 2
4638: oPushResult
4639: oNodeGetInt
4640: oPop 2
4642: oAssign
4643: oEmit 20
4645: oGetLocal 1
4647: oPushResult
4648: oEmitInt
4649: oPop 1
4651: oTypeSPop
4652: oReturn
4653: oLocalSpace 1
4655: oInput 0
4657: oGetAddrLocal 1
4659: oPushResult
4660: oScopeFindRequire
4661: oAssign
4662: oGetLocal 1
4664: oPushResult
4665: oNodeType
4666: oPop 1
4668: oChoice 4672
4670: oJumpForward 4681
4672: Choice Lookup Table
          15   4670
          13   4670
          12   4670
4679: oError 4
4681: oGetLocal 1
4683: oPushResult
4684: oCall 4689
4686: oPop 1
4688: oReturn
4689: oLocalSpace 0
4691: oGetParam 1
4693: oPushResult
4694: oNodeType
4695: oPop 1
4697: oChoice 4757
4699: oEmit 10
4701: oGetParam 1
4703: oPushResult
4704: oCall 5647
4706: oPop 1
4708: oJumpForward 4766
4710: oEmit 11
4712: oGetParam 1
4714: oPushResult
4715: oCall 5647
4717: oPop 1
4719: oJumpForward 4766
4721: oGetParam 1
4723: oPushResult
4724: oSetResult 16
4726: oPushResult
4727: oNodeGetBoolean
4728: oPop 2
4730: oChoice 4743
4732: oEmit 8
4734: oGetParam 1
4736: oPushResult
4737: oCall 5647
4739: oPop 1
4741: oJumpForward 4755
4743: Choice Lookup Table
           1   4732
4746: oEmit 12
4748: oGetParam 1
4750: oPushResult
4751: oCall 5647
4753: oPop 1
4755: oJumpForward 4766
4757: Choice Lookup Table
          15   4721
          13   4710
          12   4699
4764: oError 4
4766: oGetParam 1
4768: oPushResult
4769: oSetResult 5
4771: oPushResult
4772: oNodeGet
4773: oPop 2
4775: oPushResult
4776: oTypeSPush
4777: oPop 1
4779: oCall 3666
4781: oReturn
4782: oLocalSpace 0
4784: oGetParam 1
4786: oPushResult
4787: oCall 4689
4789: oPop 1
4791: oCall 5396
4793: oGetParam 1
4795: oPushResult
4796: oCall 3252
4798: oPop 1
4800: oTypeSPop
4801: oEmit 21
4803: oEmit 17
4805: oReturn
4806: oLocalSpace 0
4808: oGetParam 1
4810: oPushResult
4811: oCall 4689
4813: oPop 1
4815: oCall 5396
4817: oGetParam 1
4819: oPushResult
4820: oCall 3252
4822: oPop 1
4824: oTypeSPop
4825: oEmit 22
4827: oEmit 17
4829: oReturn
4830: oLocalSpace 2
4832: oGetAddrLocal 1
4834: oPushResult
4835: oSetResult 0
4837: oAssign
4838: oGetAddrLocal 1
4840: oPushResult
4841: oCall 2021
4843: oPop 1
4845: oInput 40
4847: oCall 4336
4849: oInputChoice 4884
4851: oGetAddrLocal 2
4853: oPushResult
4854: oLabelNew
4855: oAssign
4856: oEmit 43
4858: oGetLocal 2
4860: oPushResult
4861: oEmitLabel
4862: oPop 1
4864: oEmit 46
4866: oGetLocal 1
4868: oPushResult
4869: oEmitLabel
4870: oPop 1
4872: oCall 4336
4874: oEmit 46
4876: oGetLocal 2
4878: oPushResult
4879: oEmitLabel
4880: oPop 1
4882: oJumpForward 4895
4884: Choice Lookup Table
          41   4851
4887: oEmit 46
4889: oGetLocal 1
4891: oPushResult
4892: oEmitLabel
4893: oPop 1
4895: oReturn
4896: oLocalSpace 4
4898: oInput 0
4900: oGetAddrLocal 1
4902: oPushResult
4903: oScopeFindRequire
4904: oAssign
4905: oGetLocal 1
4907: oPushResult
4908: oCall 4689
4910: oPop 1
4912: oCall 5396
4914: oInput 3
4916: oCall 1998
4918: oCall 5396
4920: oEmit 17
4922: oGetAddrLocal 2
4924: oPushResult
4925: oLabelNew
4926: oAssign
4927: oGetAddrLocal 3
4929: oPushResult
4930: oLabelNew
4931: oAssign
4932: oEmit 43
4934: oGetLocal 3
4936: oPushResult
4937: oEmitLabel
4938: oPop 1
4940: oGetAddrLocal 4
4942: oPushResult
4943: oLabelNew
4944: oAssign
4945: oEmit 46
4947: oGetLocal 4
4949: oPushResult
4950: oEmitLabel
4951: oPop 1
4953: oInputChoice 5033
4955: oGetLocal 1
4957: oPushResult
4958: oCall 4782
4960: oPop 1
4962: oEmit 46
4964: oGetLocal 3
4966: oPushResult
4967: oEmitLabel
4968: oPop 1
4970: oGetLocal 1
4972: oPushResult
4973: oCall 3252
4975: oPop 1
4977: oTypeSPop
4978: oCall 1998
4980: oCall 5396
4982: oEmit 32
4984: oEmit 44
4986: oGetLocal 2
4988: oPushResult
4989: oEmitLabel
4990: oPop 1
4992: oJumpForward 5039
4994: oGetLocal 1
4996: oPushResult
4997: oCall 4806
4999: oPop 1
5001: oEmit 46
5003: oGetLocal 3
5005: oPushResult
5006: oEmitLabel
5007: oPop 1
5009: oGetLocal 1
5011: oPushResult
5012: oCall 3252
5014: oPop 1
5016: oTypeSPop
5017: oCall 1998
5019: oCall 5396
5021: oEmit 33
5023: oEmit 44
5025: oGetLocal 2
5027: oPushResult
5028: oEmitLabel
5029: oPop 1
5031: oJumpForward 5039
5033: Choice Lookup Table
          44   4994
          43   4955
5038: oEndChoice
5039: oGetLocal 4
5041: oPushResult
5042: oGetLocal 2
5044: oPushResult
5045: oLoopPush
5046: oPop 2
5048: oInput 45
5050: oCall 4336
5052: oEmit 43
5054: oGetLocal 4
5056: oPushResult
5057: oEmitLabel
5058: oPop 1
5060: oEmit 46
5062: oGetLocal 2
5064: oPushResult
5065: oEmitLabel
5066: oPop 1
5068: oLoopPop
5069: oReturn
5070: oLocalSpace 3
5072: oGetAddrLocal 1
5074: oPushResult
5075: oLabelNew
5076: oAssign
5077: oEmit 46
5079: oGetLocal 1
5081: oPushResult
5082: oEmitLabel
5083: oPop 1
5085: oGetAddrLocal 2
5087: oPushResult
5088: oLabelNew
5089: oAssign
5090: oGetLocal 1
5092: oPushResult
5093: oGetLocal 2
5095: oPushResult
5096: oLoopPush
5097: oPop 2
5099: oCall 4336
5101: oInputChoice 5132
5103: oCall 4336
5105: oJumpForward 5138
5107: oGetAddrLocal 3
5109: oPushResult
5110: oCall 2021
5112: oPop 1
5114: oEmit 47
5116: oGetLocal 3
5118: oPushResult
5119: oEmitLabel
5120: oPop 1
5122: oGetLocal 1
5124: oPushResult
5125: oEmitLabel
5126: oPop 1
5128: oJumpForward 5140
5130: oJumpForward 5138
5132: Choice Lookup Table
          48   5107
           4   5103
5137: oEndChoice
5138: oJumpBack 5101
5140: oEmit 46
5142: oGetLocal 2
5144: oPushResult
5145: oEmitLabel
5146: oPop 1
5148: oLoopPop
5149: oReturn
5150: oLocalSpace 2
5152: oGetAddrLocal 1
5154: oPushResult
5155: oLabelNew
5156: oAssign
5157: oEmit 46
5159: oGetLocal 1
5161: oPushResult
5162: oEmitLabel
5163: oPop 1
5165: oGetAddrLocal 2
5167: oPushResult
5168: oCall 2021
5170: oPop 1
5172: oGetLocal 1
5174: oPushResult
5175: oGetLocal 2
5177: oPushResult
5178: oLoopPush
5179: oPop 2
5181: oInput 45
5183: oCall 4336
5185: oEmit 43
5187: oGetLocal 1
5189: oPushResult
5190: oEmitLabel
5191: oPop 1
5193: oEmit 46
5195: oGetLocal 2
5197: oPushResult
5198: oEmitLabel
5199: oPop 1
5201: oLoopPop
5202: oReturn
5203: oLocalSpace 0
5205: oLoopContinueLabel
5206: oPushResult
5207: oSetResult 0
5209: oPushResult
5210: equal_label
5211: oPop 2
5213: oChoice 5228
5215: oError 18
5217: oJumpForward 5234
5219: oEmit 43
5221: oLoopContinueLabel
5222: oPushResult
5223: oEmitLabel
5224: oPop 1
5226: oJumpForward 5234
5228: Choice Lookup Table
           0   5219
           1   5215
5233: oEndChoice
5234: oReturn
5235: oLocalSpace 0
5237: oLoopBreakLabel
5238: oPushResult
5239: oSetResult 0
5241: oPushResult
5242: equal_label
5243: oPop 2
5245: oChoice 5260
5247: oError 18
5249: oJumpForward 5266
5251: oEmit 43
5253: oLoopBreakLabel
5254: oPushResult
5255: oEmitLabel
5256: oPop 1
5258: oJumpForward 5266
5260: Choice Lookup Table
           0   5251
           1   5247
5265: oEndChoice
5266: oReturn
5267: oLocalSpace 0
5269: oCall 4336
5271: oInputChoice 5281
5273: oCall 4336
5275: oJumpForward 5287
5277: oJumpForward 5289
5279: oJumpForward 5287
5281: Choice Lookup Table
          34   5277
           4   5273
5286: oEndChoice
5287: oJumpBack 5271
5289: oReturn
5290: oLocalSpace 0
5292: oCall 5297
5294: oEmit 52
5296: oReturn
5297: oLocalSpace 0
5299: oInputChoice 5360
5301: oCall 1998
5303: oTypeSNodeType
5304: oChoice 5326
5306: oEmit 48
5308: oJumpForward 5341
5310: oEmit 49
5312: oJumpForward 5341
5314: oEmit 50
5316: oJumpForward 5341
5318: oError 16
5320: oJumpForward 5341
5322: oEmit 51
5324: oJumpForward 5341
5326: Choice Lookup Table
          23   5322
          17   5318
          21   5318
          22   5314
          19   5310
          18   5306
5339: oError 17
5341: oTypeSPop
5342: oInputChoice 5350
5344: oJumpForward 5358
5346: oJumpForward 5356
5348: oJumpForward 5356
5350: Choice Lookup Table
          12   5348
          14   5344
5355: oEndChoice
5356: oJumpBack 5301
5358: oJumpForward 5363
5360: Choice Lookup Table
          13   5301
5363: oReturn
5364: oLocalSpace 0
5366: oReturn
5367: oLocalSpace 0
5369: oReturn
5370: oLocalSpace 1
5372: oGetAddrLocal 1
5374: oPushResult
5375: oTypeSNodeType
5376: oAssign
5377: oTypeSPop
5378: oGetLocal 1
5380: oPushResult
5381: oTypeSNodeType
5382: oPushResult
5383: equal_node_type
5384: oPop 2
5386: oChoice 5392
5388: oError 14
5390: oJumpForward 5395
5392: Choice Lookup Table
           0   5388
5395: oReturn
5396: oLocalSpace 0
5398: oTypeSNodeType
5399: oChoice 5403
5401: oJumpForward 5408
5403: Choice Lookup Table
          18   5401
5406: oError 7
5408: oTypeSPop
5409: oReturn
5410: oLocalSpace 0
5412: oTypeSNodeType
5413: oChoice 5417
5415: oJumpForward 5422
5417: Choice Lookup Table
          18   5415
5420: oError 7
5422: oReturn
5423: oLocalSpace 0
5425: oTypeSNodeType
5426: oChoice 5430
5428: oJumpForward 5435
5430: Choice Lookup Table
          19   5428
5433: oError 8
5435: oTypeSPop
5436: oReturn
5437: oLocalSpace 0
5439: oTypeSNodeType
5440: oChoice 5444
5442: oJumpForward 5449
5444: Choice Lookup Table
          19   5442
5447: oError 8
5449: oReturn
5450: oLocalSpace 1
5452: oGetAddrLocal 1
5454: oPushResult
5455: oGetParam 2
5457: oPushResult
5458: oNodeNew
5459: oPop 1
5461: oAssign
5462: oGetLocal 1
5464: oPushResult
5465: oSetResult 2
5467: oPushResult
5468: oGetParam 1
5470: oPushResult
5471: oNodeSetInt
5472: oPop 3
5474: oGetLocal 1
5476: oPushResult
5477: oTypeAdd
5478: oPop 1
5480: oGetLocal 1
5482: oReturn
5483: oReturn
5484: oLocalSpace 1
5486: oGetAddrLocal 1
5488: oPushResult
5489: oGetParam 3
5491: oPushResult
5492: oNodeNew
5493: oPop 1
5495: oAssign
5496: oGetLocal 1
5498: oPushResult
5499: oSetResult 4
5501: oPushResult
5502: oGetParam 1
5504: oPushResult
5505: oNodeSetInt
5506: oPop 3
5508: oGetLocal 1
5510: oReturn
5511: oReturn
5512: oLocalSpace 1
5514: oGetAddrLocal 1
5516: oPushResult
5517: oGetParam 1
5519: oPushResult
5520: oSetResult 17
5522: oPushResult
5523: oNodeGet
5524: oPop 2
5526: oAssign
5527: oGetLocal 1
5529: oPushResult
5530: oNodeNull
5531: oPop 1
5533: oChoice 5589
5535: oGetAddrLocal 1
5537: oPushResult
5538: oSetResult 23
5540: oPushResult
5541: oNodeNew
5542: oPop 1
5544: oAssign
5545: oGetLocal 1
5547: oPushResult
5548: oSetResult 18
5550: oPushResult
5551: oGetParam 1
5553: oPushResult
5554: oNodeSet
5555: oPop 3
5557: oGetLocal 1
5559: oPushResult
5560: oSetResult 2
5562: oPushResult
5563: oSetResult 8
5565: oPushResult
5566: oNodeSetInt
5567: oPop 3
5569: oGetLocal 1
5571: oPushResult
5572: oTypeAdd
5573: oPop 1
5575: oGetParam 1
5577: oPushResult
5578: oSetResult 17
5580: oPushResult
5581: oGetLocal 1
5583: oPushResult
5584: oNodeSet
5585: oPop 3
5587: oJumpForward 5592
5589: Choice Lookup Table
           1   5535
5592: oGetLocal 1
5594: oReturn
5595: oReturn
5596: oLocalSpace 0
5598: oGetParam 1
5600: oPushResult
5601: oNodeType
5602: oPop 1
5604: oChoice 5632
5606: oMININT
5607: oReturn
5608: oJumpForward 5646
5610: oSetResult 0
5612: oReturn
5613: oJumpForward 5646
5615: oSetResult 0
5617: oReturn
5618: oJumpForward 5646
5620: oGetParam 1
5622: oPushResult
5623: oSetResult 20
5625: oPushResult
5626: oNodeGetInt
5627: oPop 2
5629: oReturn
5630: oJumpForward 5646
5632: Choice Lookup Table
          25   5620
          21   5615
          19   5610
          18   5606
5641: oError 3
5643: oSetResult 0
5645: oReturn
5646: oReturn
5647: oLocalSpace 0
5649: oGetParam 1
5651: oPushResult
5652: oSetResult 6
5654: oPushResult
5655: oNodeGetInt
5656: oPop 2
5658: oPushResult
5659: oEmitInt
5660: oPop 1
5662: oReturn
5663: oLocalSpace 1
5665: oGetAddrGlobal 2
5667: oPushResult
5668: oSetResult 17
5670: oPushResult
5671: oSetResult 4
5673: oPushResult
5674: oCall 5450
5676: oPop 2
5678: oAssign
5679: oGetAddrGlobal 3
5681: oPushResult
5682: oSetResult 18
5684: oPushResult
5685: oSetResult 4
5687: oPushResult
5688: oCall 5450
5690: oPop 2
5692: oAssign
5693: oGetAddrGlobal 4
5695: oPushResult
5696: oSetResult 19
5698: oPushResult
5699: oSetResult 1
5701: oPushResult
5702: oCall 5450
5704: oPop 2
5706: oAssign
5707: oGetAddrGlobal 5
5709: oPushResult
5710: oSetResult 20
5712: oPushResult
5713: oSetResult 1
5715: oPushResult
5716: oCall 5450
5718: oPop 2
5720: oAssign
5721: oGetAddrGlobal 6
5723: oPushResult
5724: oSetResult 21
5726: oPushResult
5727: oSetResult 1
5729: oPushResult
5730: oCall 5450
5732: oPop 2
5734: oAssign
5735: oGetAddrGlobal 7
5737: oPushResult
5738: oSetResult 22
5740: oPushResult
5741: oSetResult 256
5743: oPushResult
5744: oCall 5450
5746: oPop 2
5748: oAssign
5749: oGetAddrLocal 1
5751: oPushResult
5752: oSetResult 10
5754: oPushResult
5755: oSetResult 5
5757: oPushResult
5758: oIdAdd_File
5759: oPushResult
5760: oCall 5484
5762: oPop 3
5764: oAssign
5765: oGetLocal 1
5767: oPushResult
5768: oSetResult 5
5770: oPushResult
5771: oGetGlobal 2
5773: oPushResult
5774: oNodeSet
5775: oPop 3
5777: oGetLocal 1
5779: oPushResult
5780: oScopeDeclare
5781: oPop 1
5783: oGetAddrLocal 1
5785: oPushResult
5786: oSetResult 10
5788: oPushResult
5789: oSetResult 5
5791: oPushResult
5792: oIdAdd_Integer
5793: oPushResult
5794: oCall 5484
5796: oPop 3
5798: oAssign
5799: oGetLocal 1
5801: oPushResult
5802: oSetResult 5
5804: oPushResult
5805: oGetGlobal 3
5807: oPushResult
5808: oNodeSet
5809: oPop 3
5811: oGetLocal 1
5813: oPushResult
5814: oScopeDeclare
5815: oPop 1
5817: oGetAddrLocal 1
5819: oPushResult
5820: oSetResult 10
5822: oPushResult
5823: oSetResult 5
5825: oPushResult
5826: oIdAdd_Boolean
5827: oPushResult
5828: oCall 5484
5830: oPop 3
5832: oAssign
5833: oGetLocal 1
5835: oPushResult
5836: oSetResult 5
5838: oPushResult
5839: oGetGlobal 4
5841: oPushResult
5842: oNodeSet
5843: oPop 3
5845: oGetLocal 1
5847: oPushResult
5848: oScopeDeclare
5849: oPop 1
5851: oGetAddrLocal 1
5853: oPushResult
5854: oSetResult 10
5856: oPushResult
5857: oSetResult 5
5859: oPushResult
5860: oIdAdd_Char
5861: oPushResult
5862: oCall 5484
5864: oPop 3
5866: oAssign
5867: oGetLocal 1
5869: oPushResult
5870: oSetResult 5
5872: oPushResult
5873: oGetGlobal 6
5875: oPushResult
5876: oNodeSet
5877: oPop 3
5879: oGetLocal 1
5881: oPushResult
5882: oScopeDeclare
5883: oPop 1
5885: oGetAddrLocal 1
5887: oPushResult
5888: oSetResult 10
5890: oPushResult
5891: oSetResult 5
5893: oPushResult
5894: oIdAdd_String
5895: oPushResult
5896: oCall 5484
5898: oPop 3
5900: oAssign
5901: oGetLocal 1
5903: oPushResult
5904: oSetResult 5
5906: oPushResult
5907: oGetGlobal 7
5909: oPushResult
5910: oNodeSet
5911: oPop 3
5913: oGetLocal 1
5915: oPushResult
5916: oScopeDeclare
5917: oPop 1
5919: oGetAddrLocal 1
5921: oPushResult
5922: oSetResult 9
5924: oPushResult
5925: oSetResult 4
5927: oPushResult
5928: oIdAdd_True
5929: oPushResult
5930: oCall 5484
5932: oPop 3
5934: oAssign
5935: oGetLocal 1
5937: oPushResult
5938: oSetResult 5
5940: oPushResult
5941: oGetGlobal 4
5943: oPushResult
5944: oNodeSet
5945: oPop 3
5947: oGetLocal 1
5949: oPushResult
5950: oSetResult 6
5952: oPushResult
5953: oSetResult 1
5955: oPushResult
5956: oNodeSetInt
5957: oPop 3
5959: oGetLocal 1
5961: oPushResult
5962: oScopeDeclare
5963: oPop 1
5965: oGetAddrLocal 1
5967: oPushResult
5968: oSetResult 9
5970: oPushResult
5971: oSetResult 4
5973: oPushResult
5974: oIdAdd_False
5975: oPushResult
5976: oCall 5484
5978: oPop 3
5980: oAssign
5981: oGetLocal 1
5983: oPushResult
5984: oSetResult 5
5986: oPushResult
5987: oGetGlobal 4
5989: oPushResult
5990: oNodeSet
5991: oPop 3
5993: oGetLocal 1
5995: oPushResult
5996: oSetResult 6
5998: oPushResult
5999: oSetResult 0
6001: oPushResult
6002: oNodeSetInt
6003: oPop 3
6005: oGetLocal 1
6007: oPushResult
6008: oScopeDeclare
6009: oPop 1
6011: oReturn
