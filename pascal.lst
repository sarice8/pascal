   2: title: 'Pascal Compiler 1.1.5 -- Jan 01 ''90';
         
      %
      %  Pascal.ssl
      %
      %  Pascal Compiler for the Amiga, by Steve Rice.
      %
      %  HISTORY
      %    11Sep89   First version, framework of parser.
      %    18Sep89   Added some semantic mechanisms.
      %    21Sep89   Added simple type references; expressions generate code.
      %    22Sep89   Allocate variable addresses as they're declared.
      %    24Sep89   Added arrays, pointers.
      %    27Sep89   Added for statement.
      %    23Oct89   Fixed for statement, so CYCLE goes to next step.
      %    01Jan90   Added string literals
      %    09Sep22   I have returned.  Migrate symbol table to schema, to ease development.
      %    01Oct22   Language: Switch from cycle/exit (Mac Pascal extension) to continue/break (Borland).
      %
      %  NOTES
      %    -  The 'value' of a var symbol is its allocated address.
      %    -  References to vars of intrinsic types, and pointer types,
      %       pushes the value of the var on the expr stack.  Referenecs to
      %       vars of compound types (arrays, records...) pushes the address
      %       on the expr stack.
      %    -  Just as there is only one type table entry for a given (named) type,
      %       there is only one type table entry for a pointer to a named type.
      %       When a pointer type is declared, a field in the TT entry of the
      %       type pointed to will be set to indicate the TT entry of the pointer
      %       to that type (0 means none defined yet).  When evaluating the
      %       expression @x, the type in that field in the entry for the type of x
      %       will be used (unless it's 0, in which case a new TT entry will be
      %       created).
      %
      %
      %  MISSING
      %
      %    - Consider non-ISO extensions.  e.g. 
      %      Dynamic arrays.  Objects.  But, perhaps stick to my old goal, standard Pascal.
      %
      %  PASCAL DOCS
      %      Here's some handy language material:
      %      https://www.freepascal.org/docs-html/ref/ref.html
      %      https://www.freepascal.org/docs-html/prog/prog.html
      %      https://en.wikipedia.org/wiki/Turbo_Pascal
      %      https://en.wikipedia.org/wiki/Pascal_(programming_language)#Standards
      %      http://www.standardpascaline.org/
      %
      
   2: input:
   2:    pIdent
   2:    pIntLit
   2:    pStrLit
   2:    pCharLit
   2:    pAssign       ':='
   2:    pSemiColon    ';'
   2:    pEqual        '='
   2:    pNotEqual     '<>'
   2:    pLess         '<'
   2:    pGreater      '>'
   2:    pLessEqual    '<='
   2:    pGreaterEqual '>='
   2:    pColon        ':'
   2:    pComma        ','
   2:    pLParen       '('
   2:    pRParen       ')'
   2:    pLSquare      '['
   2:    pRSquare      ']'
   2:    pCarat        '^'
   2:    pAt           '@'
   2:    pDot          '.'
   2:    pDotDot       '..'
   2:    pTimes        '*'
   2:    pDivide       '/'
   2:    pPlus         '+'
   2:    pMinus        '-'
   2:    pEof
   2:    pInvalid
      
      %  keywords  (built-in types 'integer', 'byte', 'char', etc, are not keywords,
      %             type constructors 'array', 'record', 'set' are keywords,
      %             pseudo-procedures 'writeln', 'readln' are keywords)
      %
      %             forward/external/name/cdecl appear in method modifiers, in fpc grammar.
      %             I'm making them keywords to simplify parsing, but could reconsider.
      
   2:    pProgram
   2:    pProcedure
   2:    pFunction
   2:    pConst
   2:    pType
   2:    pVar
   2:    pLabel
   2:    pBegin
   2:    pEnd
   2:    pArray
   2:    pRecord
   2:    pSet
   2:    pOf
   2:    pIf
   2:    pThen
   2:    pElse
   2:    pFor
   2:    pTo
   2:    pDownto
   2:    pDo
   2:    pWhile
   2:    pRepeat
   2:    pUntil
   2:    pContinue
   2:    pBreak
   2:    pCase
   2:    pOtherwise
   2:    pGoto
   2:    pAnd
   2:    pOr
   2:    pNot
   2:    pUses
   2:    pUnit
   2:    pInterface
   2:    pImplementation
   2:    pInitialization
   2:    pFinalization
   2:    pWriteln
   2:    pWrite
   2:    pReadln
   2:    pRead
      
   2:    pForward
   2:    pExternal
   2:    pName
   2:    pCdecl
   2:    ;
      
      
   2: output:
      
      %  Instructions for a stack machine (all vars are 32-bit integers)
      
   2:    tPushGlobalI      % <ptr> - push int value read from ptr
   2:    tPushGlobalB      % <ptr> - push byte value read from ptr
   2:    tPushGlobalP      % <ptr> - push ptr value read from ptr
   2:    tPushLocalI       % <offset> - push int value read from local var in current scope
   2:    tPushLocalB       % <offset> - push byte value read from local var in current scope
   2:    tPushLocalP       % <offset> - push ptr value read from local var in current scope
   2:    tPushParamI       % <offset> - push int value read from param in current scope
   2:    tPushParamB       % <offset> - push byte value read from param in current scope
   2:    tPushParamP       % <offset> - push ptr value read from param in current scope
   2:    tPushUpLocalI     % <uplevels> <offset> - push int value read from local var in a parent static scope
   2:    tPushUpLocalB     % <uplevels> <offset> - push byte value read from local var in a parent static scope
   2:    tPushUpLocalP     % <uplevels> <offset> - push ptr value read from local var in a parent static scope
   2:    tPushUpParamI     % <uplevels> <offset> - push int value read from param in a parent static scope
   2:    tPushUpParamB     % <uplevels> <offset> - push byte value read from param in a parent static scope
   2:    tPushUpParamP     % <uplevels> <offset> - push ptr value read from param in a parent static scope
   2:    tPushConstI       % <int> - push int value on stack (NOTE, used for BOOLEAN too)
   2:    tPushAddrGlobal   % <offset> - push ptr to global var (same as tPushConstP)
   2:    tPushAddrLocal    % <offset> - push ptr to local var
   2:    tPushAddrParam    % <offset> - push ptr to formal param (used by method to see its param)
   2:    tPushAddrActual   % <offset> - push ptr to actual param, in actuals space (used by caller)
   2:    tPushAddrUpLocal  % <uplevels> <offset> - push ptr to local var in a parent static scope
   2:    tPushAddrUpParam  % <uplevels> <offset> - push ptr to formal param in a parent static scope
   2:    tSwap             % swap the top two entries on the stack
   2:    tFetchI           % pop ptr from stack, and push int value it points to
   2:    tFetchB           %    "      "      "     "     byte  "   "    "
   2:    tFetchP           %    "      "      "     "     ptr   "   "    "   
   2:    tAssignI          % assign int value on top of stack to addr under it (pop both)
   2:    tAssignB          %   "    byte   "    "   "  "   "    "    "   "   "
   2:    tAssignP          %   "    ptr    "    "   "  "   "    "    "   "   "
   2:    tCopy             % <#bytes> - copy bytes.  tos=src, 2nd=dest (pop 2)
   2:    tCastBtoI         % zero-extend uint8_t to int32_t
   2:    tCastItoB         % truncate int32_t to uint8_t
   2:    tIncI             % increment int value on top of expr stack
   2:    tDecI             % decrement int value on top of expr stack
   2:    tMultI            % multiply top two integers (replacing with result)
   2:    tDivI
   2:    tAddPI            % add ptr (2nd value) and int (top value), resulting in a ptr
   2:    tAddI
   2:    tSubP
   2:    tSubPI
   2:    tSubI
   2:    tNegI             % top entry *= -1
   2:    tNot              % negate top boolean
   2:    tEqualB
   2:    tNotEqualB
   2:    tGreaterB         % B is uint8_t, so these are unsigned comparisons
   2:    tLessB
   2:    tGreaterEqualB
   2:    tLessEqualB
   2:    tEqualI           % top two entries equal? (pop 2, push 1) (true=1)
   2:    tNotEqualI        %    NOTE, these all work for booleans too, but I'm moving to tEqualB etc for those
   2:    tGreaterI         % 2nd entry greater than top entry? (pop 2, push answer)
   2:    tLessI  
   2:    tGreaterEqualI
   2:    tLessEqualI
   2:    tEqualP           % two two pointer values equal? (pop 2, push 1) (true=1)
   2:    tNotEqualP
   2:    tGreaterP
   2:    tLessP
   2:    tGreaterEqualP
   2:    tLessEqualP
   2:    tAllocActuals     % <#bytes> - make space on call stack for actual params (adjusting call stack sp)
   2:    tAllocActualsCdecl  % <#bytes> - starting a call to a cdecl method.  tcode still describes my own calling convention.
   2:    tFreeActuals      % <#bytes> - discard space on call stack allocated by tAllocActuals
   2:    tCall             % <label#>
   2:    tCallCdecl        % <label#> - call a method using native (C) calling convention. Only supported for extern labels.
   2:    tReturn
   2:    tEnter            % <#bytes> - start a stack frame on the call stack, reserving #bytes of local variable space
   2:    tJump             % <label#>
   2:    tJumpTrue         % <label#>  (pops top of stack, jumps if true)
   2:    tJumpFalse        % <label#>  (pops top of stack, jumps if false)
   2:    tJumpCaseB        % <label#>  pops uint8_t, jumps to case indicated by table at label (consisting of tCase, tCaseRange, tCaseEnd)
   2:    tJumpCaseI        % <label#>  pops integer, jumps to case indicated by table at label
   2:    tJumpCaseS        % <label#>  pops pointer to ShortString, jumps to case indicated by table at label
   2:    tCase             % <int> <label#>  - case table entry: if match int, goto label.  For tJumpCaseS, int is offset into global data.
   2:    tCaseRange        % <lowint> <highint> <label#>  - case table entry: if lowint <= value <= highint, goto label.  For tJumpCaseS, offsets into global.
   2:    tCaseEnd          % <label#> - end of case table.  Label points to no-match code (otherwise clause or end of statement).
   2:    tLabel            % <label#> - define label# at the current address
   2:    tLabelAlias       % <label#> <aliasToLabel#> - defines label to be an alias of another label
   2:    tLabelExtern      % <label#> <offsetToStrLit> - defines label to mean an extern symbol, whose name is in global data
   2:    tWriteI           % for writeln : write integer on tos, pop
   2:    tWriteBool        %  "     "    : write TRUE/FALSE, pop
   2:    tWriteChar        %  "     "    : write char, pop
   2:    tWriteShortStr    %  "     "    : write ShortString whose addr is on tos, pop
   2:    tWritePChar       %  "     "    : write a null-terminated string whose addr is on tos, pop
   2:    tWriteP           %  "     "    : write ptr var whose addr is on tos, pop
   2:    tWriteEnum        %  "     "    : write enum name.  Name table on tos, value under it, pop both
   2:    tWriteCR          %  "     "    : write cr
   2:    tFile             % <file#> - pascal source file id, for debugging.  I haven't decided yet how I will communicate the corresponding filename.
   2:    tLine             % <line#> - pascal source line number, for debugging
      
      %  Other:
      
   2:    tSpace            % emit a hole, to be patched later
   2:    ;
      
   2: error:
   2:    eBadStatement
   2:    eNotConst
   2:    eNotType
   2:    eNotOrdinalType
   2:    eNotVar
   2:    eNotIntVar
   2:    eNotValue
   2:    eNotInteger
   2:    eNotBoolean
   2:    eNotPointer
   2:    eNotArray
   2:    eNotRecord
   2:    eNotRecordField
   2:    eTooManySubscripts
   2:    eTypeMismatch
   2:    eMissingParameter
   2:    eNotImplemented
   2:    eNotAllowed
   2:    eNotInALoop
   2:    eRecordEmpty
   2:    eNotCurrentFunction
   2:    eAlreadyDefined
   2:    eOnlyOneVarCanBeInitialized
   2:    eExternalMethodCannotBeNested
   2:    eCantFindUnitFile
   2:    eInternalScopeMismatch
   2:    eEnumValueNotAscending
   2:    eUsedButNotDefined
   2:    eCantUsePredSuccOnEnumWithValueGaps
   2:    eCantDereference
   2:    ;
      
   2: include 'pascal_schema.ssl'
      
      % Generated automatically by schema
      
   2: type node_type:
   2: 	nINVALID
   2: 	Object
   2: 	nWorkspace
   2: 	nModule
   2: 	nProgram
   2: 	nUnit
   2: 	nUnitImpl
   2: 	nScope
   2: 	nDeclaration
   2: 	nIdent
   2: 	nUnitRef
   2: 	nMethod
   2: 	nProc
   2: 	nFunc
   2: 	nBuiltInFunc
   2: 	nBuiltInProc
   2: 	nConst
   2: 	nEnumValue
   2: 	nTypeDecl
   2: 	nVar
   2: 	nGlobalVar
   2: 	nLocalVar
   2: 	nRecordField
   2: 	nParam
   2: 	nTypedConst
   2: 	nLabel
   2: 	nType
   2: 	nFileType
   2: 	nIntegerType
   2: 	nByteType
   2: 	nBooleanType
   2: 	nBooleanFlowType
   2: 	nCharType
   2: 	nPointerType
   2: 	nUniversalPointerType
   2: 	nArrayType
   2: 	nSubrangeType
   2: 	nRecordType
   2: 	nStrLitType
   2: 	nShortStringType
   2: 	nEnumType
   2: 	nSetType
   2: 	;
      
   2: type node_attribute:
   2: 	qINVALID
   2: 	qUnits
   2: 	qProgram
   2: 	qGlobalSize
   2: 	qIdent
   2: 	qUsedUnits
   2: 	qChildScope
   2: 	qMainRoutineScope
   2: 	qImpl
   2: 	qPublicScope
   2: 	qPrivateScope
   2: 	qInitLabel
   2: 	qFinalLabel
   2: 	qInitRoutineScope
   2: 	qLevel
   2: 	qDecls
   2: 	qExtends
   2: 	qSize
   2: 	qAllocMode
   2: 	qInitCode
   2: 	qParentScope
   2: 	qType
   2: 	qValue
   2: 	qParams
   2: 	qBodyDefined
   2: 	qExternal
   2: 	qExternalName
   2: 	qCdecl
   2: 	qUsed
   2: 	qOldParams
   2: 	qOldType
   2: 	qResultOffset
   2: 	qNameOffset
   2: 	qInOut
   2: 	qDefined
   2: 	qPointerType
   2: 	qBaseType
   2: 	qIndexType
   2: 	qLow
   2: 	qHigh
   2: 	qScope
   2: 	qCapacity
   2: 	qNameTable
   2: 	qHasGap
   2: 	;
      
      
   2: type Node:     % A pointer to a node in the schema database (symbol database)
   2:    Null = 0
   2:    ;
      
   2: type NodeIter:   % An iterator over nodes in a list, in the schema database
   2:    NullIter = 0
   2:    ;
      
   2: type NodeVec:  % A pointer to a vector of Node.  See mechanism node_vec_mech
   2:    NullVec = 0
   2:    ;
      
   2: type boolean:
   2:    false    = 0
   2:    true     = 1;
      
      % intrinsic types & type constructs
      
   2: type typ:
   2:    tyNone     = 0    % in ptrTyp field of TT, means no ptr to type defined
   2:    tyInteger
   2:    tyBoolean
   2:    tyChar
   2:    tyString
   2:    tyFile            % tyInteger..tyFile are scalars (types on their own)
   2:    tyPointer         % following are type constructor classes...
   2:    tyArray           %   (they are not type#'s)
   2:    tyRecord
   2:    tyParams          % like record; a collection of proc/func params
   2:    tySet;
      
   2: type Label:
   2:    labelNull = 0;
      
      % An output code stream.
   2: type Code:
   2:    codeNull = 0
   2:    codeDefault = 1
   2:    ;
      
      % A string
   2: type String:
   2:    stringNull = 0
   2:    ;
      
      % allocation modes for oScopeBegin
   2: type AllocMode:
   2:    allocGlobal = 0  % allocate from global data
   2:    allocDown        % allocate down the stack
   2:    allocUp          % allocate up the stack
   2:    ;
      
      % Some general schema node operations.
      % node_type and node_attribute are defined in generated file pascal_schema.ssl included above.
      %
   2: mechanism node_mech:
   2:     oNodeNew (node_type) >> Node         % create new node
   2:     oNodeSet (Node, node_attribute, Node)   % set Node attribute of node
   2:     oNodeSetString (Node, node_attribute, String)
   2:     oNodeSetInt (Node, node_attribute, int) % set int attribute of node
   2:     oNodeSetBoolean (Node, node_attribute, boolean)
   2:     oNodeSetLabel( Node, node_attribute, Label )  % set Label attribute of node
   2:     oNodeSetCode( Node, node_attribute, Code )    % set Code attribute of node
   2:     oNodeAddLast( Node, node_attribute, Node value )  % append to a List attribute of node
   2:     oNodeGet (Node, node_attribute) >> Node    % get Node attribute of node
   2:     oNodeGetString (Node, node_attribute) >> String
   2:     oNodeGetInt (Node, node_attribute) >> int  % get int attribute of node
   2:     oNodeGetBoolean (Node, node_attribute) >> boolean  % get int attribute of node
   2:     oNodeGetLabel (Node, node_attribute) >> Label      % get Label attribute of node
   2:     oNodeGetCode (Node, node_attribute) >> Code        % get code stream attribute of node
   2:     oNodeNull (Node) >> boolean          % is node null?
   2:     oNodeFind (Node, node_attribute listAttr, node_attribute valueAttr, int value) >> Node  % find node with value in list
   2:     oNodeGetIter (Node, node_attribute) >> NodeIter   % get an iterator over nodes in a List attribute
   2:     oNodeGetIterLast (Node, node_attribute) >> NodeIter  % get an iterator over nodes in a List, starting at last
   2:     oNodeIterValue (NodeIter) >> Node             % the node that iter is referring to (NodeNull if no more nodes)
   2:     oNodeIterNext (inout NodeIter)                % advance iterator through list
   2:     oNodeIterPrev (inout NodeIter)                % advance iterator backwards through list
   2:     oNodeType (Node) >> node_type        % return node type of node
   2:     oNodeEqual (Node, Node) >> boolean   % compare two nodes for equality
                                               % (i.e. same node, not just same contents)
   2:     ;
      
      
      % Manipulate a temporary vector of Node
      %
   2: mechanism node_vec_mech:
   2:     oNodeVecNew >> NodeVec
   2:     oNodeVecDelete( NodeVec nv )
   2:     oNodeVecAppend( NodeVec nv, Node n )
   2:     oNodeVecSize( NodeVec nv ) >> int                % how many elements
   2:     oNodeVecElement( NodeVec nv, int idx ) >> Node   % element at index idx (0..size-1)
   2:     ;
      
      
      
   2: mechanism emit_mech:
   2:     oEmitInt( int )              % emit int into the generated code
   2:     oEmitLabel( Label )
   2:     oEmitCode( Code )            % append a code stream to the current code stream
   2:     Here >> int                  % current address in the generated code
                                       %   (only usable in the default code stream)
   2:     oPatch( int addr, int val )  % patch an int into address in the generated code
                                       %   (only usable in the default code stream)
   2:     ;
      
   2: mechanism math:
   2:     inc (inout int)
   2:     dec (inout int)
   2:     negate (int) >> int
   2:     add( int x, int y ) >> int
   2:     subtract( int x, int y ) >> int     % x - y
   2:     multiply( int x, int y ) >> int     % x * y
   2:     equal( int x, int y ) >> boolean
   2:     equal_zero (int) >> boolean
   2:     equal_node( Node, Node ) >> boolean
   2:     equal_string( String, String ) >> boolean
   2:     equal_node_type (node_type, node_type) >> boolean     % Want equal_<type> for every type
   2:     equal_label( Label, Label ) >> boolean
   2:     equal_code( Code, Code ) >> boolean
   2:     greater( int x, int y ) >> boolean
   2:     oMININT >> int    % the minimum 32-bit integer.
   2:     oMAXINT >> int    % the maximum 32-bit integer.
   2:     ;
      
   2: mechanism more_builtins:      % These should be built-in SSL operations
   2:     TOKEN_VALUE >> int        % value of just accepted token, e.g. IntLit token
   2:     LAST_ID >> int            % id number of last accepted identifier
   2:     ID_STRING( int id ) >> String       % text name of identifier with given id
   2:     CURRENT_STRLIT >> String            % text value of just-accepted string literal
   2:     ;
      
   2: mechanism workspace_mech:
   2:     oWorkspaceNew >> Node
   2:     ;
      
   2: mechanism scope_mech:
   2:     oScopeBegin( int level, AllocMode )  % create a new scope. Subsequent declarations will go here.
                                               %  level = static scope depth (0 = globals)
   2:     oScopeEnter( Node scope )            % enter an existing scope.
   2:     oScopeEnd                            % end current scope. Subsequent declarations will go to previous scope.
   2:     oScopeCurrent >> Node                % returns current scope
   2:     oScopeDeclare( Node decl )           % add declaration to current scope.
   2:     oScopeDeclareAlloc( Node decl )      % add declaration to current scope, and allocate space according to its type
   2:     oScopeAllocType( Node theType ) >> int   % allocate space for type in current scope, and return its address
   2:     oScopeAlloc( int size, int align ) >> int % allocate bytes, with given alignment in bytes 
   2:     oScopeFind >> Node                   % find declaration of last accepted identifier.  Returns Null if not found.
   2:     oScopeFindRequire >> Node            % find declaration of last accepted identifier.  Error if not found.
   2:     oScopeFindInCurrentScope >> Node     % find declaration of last accepted identifier, only within the current scope.  Null if not found.
   2:     oScopeFindRequireInScope( Node scope ) >> Node  % find decl of last accepted identifier, only within the given scope.  Error it not found.
   2:     ;
      
   2: mechanism type_mech:
   2:     oTypeAdd( Node node )     % add the given nType to the type table
   2:     ;
      
   2: mechanism type_stack_mech:
   2:     oTypeSPush( Node node )
   2:     oTypeSPop
   2:     oTypeSTop >> Node
   2:     oTypeSNodeType >> node_type          % node_type of the node on top of type stack, skipping subranges
   2:     ;
      
      
   2: mechanism id_mech:
          % gets/adds a predefined id to the scanner's id table, and returns the id code
   2:     oId_mysystem >> int
   2:     oId_ShortStringAppendShortString >> int
   2:     oId_ShortStringAppendChar >> int
   2:     oId_ShortStringCmp >> int
   2:     oId_File >> int
   2:     oId_Integer >> int
   2:     oId_Boolean >> int
   2:     oId_Char >> int
   2:     oId_Byte >> int
   2:     oId_Pointer >> int
   2:     oId_ShortString >> int
   2:     oId_True >> int
   2:     oId_False >> int
   2:     oId_Nil >> int
   2:     oId_Ord >> int
   2:     oId_Chr >> int
   2:     oId_Pred >> int
   2:     oId_Succ >> int
   2:     oChangeIntLitToLabelIdent    % change current token from pIntLit to pIdent "_label_<intlit>"
   2:     ;
      
      
      
   2: mechanism label_mech:
   2:    oLabelNew >> Label
   2:    ;
      
   2: mechanism code_mech:
   2:    oCodeNew >> Code         % create a new empty code stream
   2:    oCodePush( Code )        % change the current output code stream to the given one
   2:    oCodePop                 % restore the current code stream to the previous one
   2:    ;
      
   2: mechanism include_mech:
   2:    oIncludeUnitFile( int id ) >> boolean  % search for <unit>.pas and include it.
                                                % returns false if can't find.
   2:    oIncludeEnd              % stop including the current file
   2:    ;
      
      
   2: mechanism count :
   2:    oCountPush(int)          % start a new counter, with initial value
   2:    oCountInc
   2:    oCountDec
   2:    oCountIsZero >> boolean
   2:    oCountPop;
      
      
   2: mechanism value :              % value stack, to calc. const expr's
   2:    oValuePush(int)             % push an explicit int lit
   2:    oValueTop >> int            % get top value on value stack
   2:    oValuePop
   2:    oValueNegate                % negate top numeric value
   2:    oValueEqual
   2:    oValueNotEqual
   2:    oValueLess
   2:    oValueGreater
   2:    oValueLessEqual
   2:    oValueGreaterEqual
   2:    oValueOr                    % boolean or
   2:    oValueAnd
   2:    oValueNot                   % boolean not
   2:    oValueAdd
   2:    oValueSub
   2:    oValueMult
   2:    oValueDiv
   2:    ;
      
   2: mechanism string :
   2:    oStringAllocLit( String ) >> int      % alloc global space for strlit, return address
   2:    oStringAllocShortStringLit( String ) >> int  % alloc global space for ShortString, return address
   2:    ;
      
      % track labels for the loop we're in, if any
   2: mechanism loop_mech:
   2:    oLoopPush( Label continueLabel, Label breakLabel )
   2:    oLoopContinueLabel >> Label
   2:    oLoopBreakLabel >> Label
   2:    oLoopPop
   2:    ;
      
      % for hacky debugging
   2: mechanism msg_mech:
   2:    oMsg( int num )             % print message "oMsg <num>"
   2:    oMsgTrace( int num )        % print message "oMsg <num>" followed by ssl traceback
   2:    oMsgNode( Node node )       % print node
   2:    oMsgNodeLong( Node node )   % print node with more detail
   2:    oMsgNodeVec( NodeVec vec )  % print node vec
   2:    ;
      
      
   2: rules
      
      % ----------------------------- Global Variables ----------------------------
      
   2: Node    workspace              % root of database
   2: Node    globalScope            % scope for globals in the current module
   2: Node    initScope              % scope for temporaries global var init,
                                     % and program main stmt / unit initialization stmts
      
   2: int     mysystemId               % id of identifier "mysystem"
      
      % built-in nTypes
   2: Node    FileType
   2: Node    IntegerType
   2: Node    BooleanType
   2: Node    BooleanFlowType
   2: Node    CharType
   2: Node    PCharType
   2: Node    ByteType
   2: Node    UniversalPointerType
   2: Node    StrLitType
   2: Node    ShortStringType
      
      % nBuiltInFunc
   2: Node    BuiltIn_Ord
   2: Node    BuiltIn_Chr
   2: Node    BuiltIn_Pred
   2: Node    BuiltIn_Succ
      
      % Declarations in unit mysystem that the compiler may refer to directly.
      
   2: Node    System_ShortStringAppendShortString
   2: Node    System_ShortStringAppendChar
   2: Node    System_ShortStringCmp
      
      
      % -------------------------- Forward Declarations -------------------------
      
   2: Block( node_type varNodeType, Label labelForBody );
   2: BlockDecls( node_type varNodeType );
   2: BlockStmt( Label labelForBody, Node varScope, boolean isMain );
   2: VarDecl( node_type varNodeType );
   2: newType( node_type nt, int size ) >> Node;
   2: newIdent( node_type nt, int id ) >> Node;
   2: EmitValue( Node decl );
   2: TypeRef( out Node theType );
   2: EnumTypeRef( out Node resultType );
   2: PointerTypeTo( Node theType ) >> Node;
   2: OrdinalLow( Node theType ) >> int;
   2: OrdinalHigh( Node theType ) >> int;
   2: AssignStmt( Node decl );
   2: BooleanExprControlFlow( out Label falseLabel );
   2: ExprAllowFlow( out Label falseLabel );
   2: BoolExprAllowFlow( out Label falseLabel );
   2: BoolTermAllowFlow( out Label falseLabel );
   2: BoolFactorAllowFlow( out Label falseLabel );
   2: ArithExprAllowFlow( out Label falseLabel );
   2: TermAllowFlow( out Label falseLabel );
   2: FactorAllowFlow( out Label falseLabel );
   2: PrimaryAllowFlow( out Label falseLabel );
      
   2: VarExpr( Node decl );
   2: LValueVar( Node decl, boolean writeable );
   2: IncVar( Node decl );
   2: DecVar( Node decl );
      
   2: FlowToVal( inout Label falseLabel );
   2: ValToFlow( out Label falseLabel );
   2: MoveIntoTempShortString >> int;
      
   2: DeclLevel( Node decl ) >> int;
   2: DeclUpLevels( Node decl ) >> int;
      
      % ----------------------------- Declarations ----------------------------
      
   2: Program:
   4:    Node t
      
   4:    workspace = oWorkspaceNew
      
         % root scope is used for builtins e.g. Integer,
         % and is a parent to any used units, and the program's own global scope.
   9:    oScopeBegin( 0, allocGlobal )
  18:    Node rootScope = oScopeCurrent
      
  23:    @installBuiltIns
      
         % Start by calling the main program routine.
      
         % This dummy call to main needs to look like a normal method itself,
         % so jit can align the stack properly.  So we need .tEnter,
         % and .tAllocActuals / .tFreeActuals.
  25:    .tEnter  oEmitInt( 0 )
  33:    Label mainLabel = oLabelNew
      
  38:    .tAllocActuals  oEmitInt( 0 )
  46:    .tCall  oEmitLabel( mainLabel )
  54:    .tFreeActuals  oEmitInt( 0 )
  62:    .tReturn
      
  64:    pProgram
  66:    pIdent
      
  68:    Node program = oNodeNew( nProgram )
  78:    oNodeSetInt( program, qIdent, LAST_ID )
  89:    oNodeSet( workspace, qProgram, program )
      
      
 101:    [
 101:       | '(' :
 103:          pIdent      % input, output files
      
 105:          t = @newIdent( nVar, LAST_ID )
 118:          oNodeSet( t, qType, FileType )
 130:          oScopeDeclareAlloc( t )
               % TO DO: I shouldn't declare the files in root scope.
               %        Should save them for program's global scope.
      
 136:          ','
 138:          pIdent
      
 140:          t = @newIdent( nVar, LAST_ID )
 153:          oNodeSet( t, qType, FileType )
 165:          oScopeDeclareAlloc( t )
      
 171:          ')'
 173:       | * :
 178:    ]
 178:    ';'
      
 180:    @UsesMySystem( program )
         % The uses clause may only appear once, immediately after the program declaration.
 187:    [
 187:       | pUses :  @UsesClause( program )
 196:       | * :
 201:    ]
 201:    @EnterUsedUnits( program )
      
         % Global scope for the program, below any used units.
 208:    oScopeBegin( 0, allocGlobal )
 217:    globalScope = oScopeCurrent
      
         % A new scope just for temporaries in the main routine
         % Create it up front, in case it's needed by variable initialization exprs.
         % But we won't stay in it here.
         % Note we say it extends the global scope, so that during main statement evaluation
         % any user labels declared in the global scope are considered to be part of the current scope.
 222:    oScopeBegin( 0, allocDown )
 231:    oNodeSet( oScopeCurrent, qExtends, globalScope )
 242:    initScope = oScopeCurrent
 247:    oNodeSet( program, qMainRoutineScope, initScope )
 259:    oScopeEnd
      
 260:    @BlockDecls( nGlobalVar )
      
      
 267:    oScopeEnter( initScope )
      
         % The block statement includes a stack frame, and enter/return,
         % even for the main routine.
         % That will be necessary for temporaries allocated in the main routine.
      
         % isMain means we'll generate calls to the unit init/final methods in here too.
         % Alternatively we could do that in a higher level method that calls main.
 273:    boolean isMain = true
 279:    @BlockStmt( mainLabel, globalScope, isMain )
      
 292:    oScopeEnd   % main routine scope
      
 293:    '.'
 295:    @CheckForUndefinedLabels
 297:    oScopeEnd   % global scope
 298:    @EndUsedUnits( program )   % used units scopes
 306:    ;
      
      
      % The uses clause is a list of units required by the user program or unit.
      % We will find and compile the named units (unless already loaded).
      % We do not make the unit interface visible to the user, the caller will do so later.
 306: UsesClause( Node user ):
 308:    {
 308:       pIdent
 310:       @Uses( LAST_ID, user )
 319:       [
 319:          | ',' :
 321:          | * :  >
 328:       ]
 328:    }   
 330:    ';'
 333:    ;
      
      
      % Process an implicit "uses mysystem" in every module, except in the mysystem unit itself.
      % (I'm calling the unit mysystem rather than system, so fpc doesn't use it to replace its own system unit.)
      %
 333: UsesMySystem( Node user ):
 335:    [ equal( oNodeGetInt( user, qIdent ), mysystemId )
 352:       | true :  >>
 354:       | * :
 359:    ]
 359:    @Uses( mysystemId, user )
 370:    ;
      
      
      % After processing the mysystem unit interface, grab certain declarations from it
      % that the compiler may want to refer to later.
      %
 370: FindSelectSystemDecls( Node unit ):
 372:    [ equal( oNodeGetInt( unit, qIdent ), mysystemId )
 389:       | true :
 390:          System_ShortStringAppendShortString = oNodeFind( oScopeCurrent, qDecls, qIdent, oId_ShortStringAppendShortString )
 407:          System_ShortStringAppendChar = oNodeFind( oScopeCurrent, qDecls, qIdent, oId_ShortStringAppendChar )
 424:          System_ShortStringCmp = oNodeFind( oScopeCurrent, qDecls, qIdent, oId_ShortStringCmp )
 441:       | * :
 446:    ]
 447:    ;
      
      
      % The given user module uses a unit with the given id,
      % which may or may not have been loaded already.
      %
 447: Uses( int id, Node user ):
 449:    Node unit = @FindOrCompileUnit( id )
 460:    [ equal_node( unit, Null )
 470:       | false :
 471:          oNodeAddLast( user, qUsedUnits, unit )
      
               % Put a declaration in the current scope, naming the unit and pointing to it.
               % This is to allow references to  <unit>.<identifier_in_unit>
 483:          Node unitRef = oNodeNew( nUnitRef )
 493:          oNodeSetInt( unitRef, qIdent, oNodeGetInt( unit, qIdent ) )
 512:          oNodeSet( unitRef, qPublicScope, oNodeGet( unit, qPublicScope ) )
 531:          oScopeDeclare( unitRef )
 537:       | * :
 542:    ];
      
      
      % If the given decl is for an nUnitRef, the program is using syntax <unit>.<identifier>
      % Parse the rest of that to find the intended decl.
      %
 543: ResolveUnitRef( inout Node decl ):
 545:    [ oNodeType( decl )
 552:       | nUnitRef :
 553:          Node scope = oNodeGet( decl, qPublicScope )
 566:          '.'
 568:          pIdent
 570:          decl = oScopeFindRequireInScope( scope )
 580:       | * :
 585:    ];
      
      
 586: EnterUsedUnits( Node user ):
         % Make the used units' public scopes directly visible.
         % This is done after the units are all compiled, so they don't interfere with each other incorrectly.
         % Units later in the list have priority.
 588:    NodeIter unitIt = oNodeGetIter( user, qUsedUnits )
 601:    {
 601:       Node unit = oNodeIterValue( unitIt )
 611:       [ oNodeNull( unit )
 618:          | false :
 619:             oScopeEnter( oNodeGet( unit, qPublicScope ) )
 632:          | * :
 637:             >
 639:       ]
 639:       oNodeIterNext( unitIt )
 645:    }
 648:    ;
      
 648: EndUsedUnits( Node user ):
         % Leave the units' public scopes, so no longer visible.
 650:    NodeIter unitIt = oNodeGetIterLast( user, qUsedUnits )
 663:    {
 663:       Node unit = oNodeIterValue( unitIt )
 673:       [ oNodeNull( unit )
 680:          | false :
                  % Consistency check.  Make sure our scope enter / end have lined up correctly.
 681:             [ oNodeEqual( oScopeCurrent, oNodeGet( unit, qPublicScope ) )
 697:                | true :
 698:                | false :  #eInternalScopeMismatch
 702:             ]
 710:             oScopeEnd
 711:          | * :
 716:             >
 718:       ]
 718:       oNodeIterPrev( unitIt )
 724:    }
 727:    ;
      
      
 727: FindOrCompileUnit( int id ) >> Node:
         % We might have this unit loaded already
 729:    Node unit = oNodeFind( workspace, qUnits, qIdent, id )
 748:    [ equal_node( unit, Null )
 758:       | false :  >> unit
 762:       | * :
 767:    ]
      
         % If not, search for the source file on disk
 767:    boolean ok = oIncludeUnitFile( id )
 777:    [ ok
 780:       | false :  #eCantFindUnitFile  >> Null
 786:       | * :
 791:    ]
      
         % compile it, adding it into the workspace
         % then return it.
 791:    unit = @Unit
      
         % TO DO: ensure we are at pEof
         % end the include
 797:    oIncludeEnd
 798:    >> unit;
      
      
      
 802: Unit >> Node:
 804:    pUnit
 806:    pIdent
 808:    Node unit = oNodeNew( nUnit )
 818:    oNodeSetInt( unit, qIdent, LAST_ID )
 829:    Node unitImpl = oNodeNew( nUnitImpl )
 839:    oNodeSetInt( unitImpl, qIdent, LAST_ID )
 850:    oNodeSet( unit, qImpl, unitImpl )
 862:    ';'
      
         % mandatory sections
      
 864:    pInterface
 866:    @UsesMySystem( unit )
 873:    [
 873:       | pUses :   @UsesClause( unit )
 882:       | * :
 887:    ]
 887:    @EnterUsedUnits( unit )
      
 894:    oScopeBegin( 0, allocGlobal )
 903:    oNodeSet( unit, qPublicScope, oScopeCurrent )
 914:    globalScope = oScopeCurrent
      
         % A scope for temporaries needed by variable initialization
 919:    oScopeBegin( 0, allocDown )
 928:    initScope = oScopeCurrent
 933:    oNodeSet( unit, qInitRoutineScope, initScope )
 945:    oScopeEnd
      
 946:    @UnitInterface( unit )
 953:    oScopeEnd  % interface scope
      
 954:    pImplementation
 956:    @UsesMySystem( unitImpl )
 963:    [
 963:       | pUses :   @UsesClause( unitImpl )
 972:       | * :
 977:    ]
 977:    @EnterUsedUnits( unitImpl )
         % re-enter interface scope after impl's uses.  interface still has priority.
 984:    oScopeEnter( oNodeGet( unit, qPublicScope ) )
         
 997:    oScopeBegin( 0, allocGlobal )
1006:    oNodeSet( unit, qPrivateScope, oScopeCurrent )
1017:    oNodeSet( oScopeCurrent, qExtends, oNodeGet( unit, qPublicScope ) )
1035:    globalScope = oScopeCurrent
1040:    @UnitImplementation( unit )
      
1047:    [
1047:       | pInitialization :  @UnitInitialization( unit, true )   % init routine with statements from init section
1059:       | * :                @UnitInitialization( unit, false )  % implicit init routine
1074:    ]
1074:    [
1074:       | pFinalization :  @UnitFinalization( unit, true )
1086:       | * :              @UnitFinalization( unit, false )   % implicit final routine, may be handy later
1101:    ]
1101:    pEnd  '.'
      
1105:    oScopeEnd  % impl scope
1106:    oScopeEnd  % interface scope
1107:    @EndUsedUnits( unitImpl )  % used units scopes
1114:    @EndUsedUnits( unit )
1121:    oNodeAddLast( workspace, qUnits, unit )
1133:    >> unit;
      
      
1137: UnitInterface( Node unit ):
1139:    {[
1139:       | pConst :     @ConstDecl
1143:       | pType :      @TypeDecl
1147:       | pVar :       @VarDecl( nGlobalVar )
            % label declaration not allowed in interface
      
1156:       | pProcedure :
1158:          Node decl = @ProcHeaderDecl
               % despite syntax diagrams, fpc does allow external clause on methods in unit interface,
               % even though this clause is an alternative for the body statement.
1164:          [
1164:             | pExternal :
1166:                @ExternalDecl( decl )
1173:                ';'
1175:             | * :
1180:          ]
      
1180:       | pFunction :
1182:          Node decl = @FuncHeaderDecl
1188:          [
1188:             | pExternal :
1190:                @ExternalDecl( decl )
1197:                ';'
1199:             | * :
1204:          ]
      
1204:       | * :          >
1219:    ]}
1221:    @FindSelectSystemDecls( unit )
1229:    ;
      
1229: UnitImplementation( Node unit ):
1231:    @BlockDecls( nGlobalVar )
1239:    ;
      
      
1239: UnitInitialization( Node unit, boolean hasStmts ):
1241:    Label label = oLabelNew
1246:    .tLabel  oEmitLabel( label )
1254:    oNodeSetLabel( unit, qInitLabel, label )
      
1266:    int patchLS
1266:    .tEnter  patchLS = Here  .tSpace
      
         % insert any code for initialization of this unit's variables.
         
1275:    Node scope
1275:    Code initCode
      
1275:    scope = oNodeGet( unit, qPublicScope )
1288:    initCode = oNodeGetCode( scope, qInitCode )
1301:    oEmitCode( initCode )
1307:    oNodeSetCode( scope, qInitCode, codeNull )
      
1319:    scope = oNodeGet( unit, qPrivateScope )
1332:    initCode = oNodeGetCode( scope, qInitCode )
1345:    oEmitCode( initCode )
1351:    oNodeSetCode( scope, qInitCode, codeNull )
      
1363:    oScopeEnter( oNodeGet( unit, qInitRoutineScope ) )
      
1376:    [ hasStmts
1379:       | true :     
1380:          @Statement
1382:          {[
1382:             | ';' :  @Statement
1386:             | * :    >
1393:          ]}
1395:       | * :
1400:    ]
      
1400:    .tReturn
      
1402:    int localSpace = oNodeGetInt( oScopeCurrent, qSize )
1414:    oPatch( patchLS, localSpace )
1423:    oScopeEnd   % init routine scope, for temporaries
1425:    ;
      
      
1425: UnitFinalization( Node unit, boolean hasStmts ):
1427:    Label label = oLabelNew
1432:    .tLabel  oEmitLabel( label )
1440:    oNodeSetLabel( unit, qFinalLabel, label )
      
1452:    int patchLS
1452:    .tEnter  patchLS = Here  .tSpace
      
         % final routine scope, for temporaries
1461:    oScopeBegin( 0, allocDown )
      
1470:    [ hasStmts
1473:       | true :     
1474:          @Statement
1476:          {[
1476:             | ';' :  @Statement
1480:             | * :    >
1487:          ]}
1489:       | * :
1494:    ]
      
1494:    .tReturn
      
1496:    int localSpace = oNodeGetInt( oScopeCurrent, qSize )
1508:    oPatch( patchLS, localSpace )
1517:    oScopeEnd   % final routine scope, for temporaries
1519:    ;
      
      
1519: Block( node_type varNodeType, Label labelForBody ):
1521:    @BlockDecls( varNodeType )
1528:    @BlockStmt( labelForBody, oScopeCurrent, false )
1540:    @CheckForUndefinedLabels
1543:    ;
      
      
1543: BlockDecls( node_type varNodeType ):
1545:    {[
1545:       | pConst :     @ConstDecl
1549:       | pType :      @TypeDecl
1553:       | pVar :       @VarDecl( varNodeType )
1562:       | pLabel :     @LabelDecl
1566:       | pProcedure : @ProcDecl
1570:       | pFunction :  @FuncDecl
1574:       | * :          >
1591:    ]}
1593:    @CheckForUndefinedMethods
1596:    ;
      
      
      % were there any procedures or functions declared in this scope
      % that were never defined?
1596: CheckForUndefinedMethods:
         % TO DO
         % Note: disregard methods marked external
1599:    ;
      
      % were there any labels declared in the current scope, and used,
      % but never defined (as the prefix of a stement)?
      %
1599: CheckForUndefinedLabels:
1601:    NodeIter it = oNodeGetIter( oScopeCurrent, qDecls )
1613:    {
1613:       Node decl = oNodeIterValue( it )
1623:       [ oNodeNull( decl )
1630:          | false :
1631:          | * :  >
1638:       ]
1638:       [ oNodeType( decl )
1645:          | nLabel :
1646:             [ oNodeGetBoolean( decl, qDefined )
1656:                | false :
1657:                   [ oNodeGetBoolean( decl, qUsed )
1667:                      | true :    #eUsedButNotDefined  % TO DO: give the decl in the message
1670:                      | * :
1675:                   ]
1675:                | * :
1680:             ]
1680:          | * :
1685:       ]
1685:       oNodeIterNext( it )
1691:    }
1694:    ;
      
      
1694: InitializeUnits:
         % call init routine of each loaded unit, in the order they were loaded
         % (used directly or indirectly by the main program).
1696:    NodeIter it = oNodeGetIter( workspace, qUnits )
1709:    {
1709:       Node unit = oNodeIterValue( it )
1719:       [ oNodeNull( unit )
1726:          | true :  >
1729:          | false :
1731:             .tAllocActuals  oEmitInt( 0 )  % not sure I need this. maybe for stack alignment.
1739:             .tCall  oEmitLabel( oNodeGetLabel( unit, qInitLabel ) )
1754:             .tFreeActuals  oEmitInt( 0 )
1762:             oNodeIterNext( it )
1768:       ]
1776:    };
      
      
1779: FinalizeUnits:
1781:    NodeIter it = oNodeGetIterLast( workspace, qUnits )
1794:    {
1794:       Node unit = oNodeIterValue( it )
1804:       [ oNodeNull( unit )
1811:          | true :  >
1814:          | false :
1816:             .tAllocActuals  oEmitInt( 0 )  % not sure I need this. maybe for stack alignment.
1824:             .tCall  oEmitLabel( oNodeGetLabel( unit, qFinalLabel ) )
1839:             .tFreeActuals  oEmitInt( 0 )
1847:             oNodeIterPrev( it )
1853:       ]
1861:    };
      
      
      % Given the scope of vars in this block.
      % Usually it's the current scope, but it's a bit different for the main statement.
      %
1864: BlockStmt( Label labelForBody, Node varScope, boolean isMain ):
1866:    .tLabel  oEmitLabel( labelForBody )
      
         % Proc, func, and main routine all start with tEnter
         % to create a stack frame.  This will be used for temporaries
         % (and local vars in the case of proc, func).
      
1874:    int patchLS
1874:    .tEnter  patchLS = Here  .tSpace
      
         % If we're generating the program main method,
         % add in calls to the loaded units' initialization and finalization.
1883:    [ isMain
1886:       | true :  @InitializeUnits
1889:       | * :
1894:    ]
      
         % insert any code for initialization of this scope's variables
1894:    Code initCode = oNodeGetCode( varScope, qInitCode )
1907:    oEmitCode( initCode )
1913:    oNodeSetCode( varScope, qInitCode, codeNull )
      
1925:    @Statement
      
1927:    [ isMain
1930:       | true :  @FinalizeUnits
1933:       | * :
1938:    ]
      
1938:    .tReturn
      
1940:    int localSpace = oNodeGetInt( oScopeCurrent, qSize )
1952:    oPatch( patchLS, localSpace )
1962:    ;
      
      
      % modifers that may appear on a proc/function declaration.
      %
1962: MethodModifiers( Node decl ):
1964:    {[
1964:       | pCdecl :
1966:          oNodeSetBoolean( decl, qCdecl, true )
1978:          ';'
      
1980:       | * : >
1987:    ]}
1990:    ;
      
      
      % We need an initCode code stream for the given scope.
      % Create it if not present yet.  Return it.
      % (This will be used for variable initialization.)
      %
1990: GetOrCreateInitCode( Node scope ) >> Code:
1992:    Code initCode = oNodeGetCode( scope, qInitCode )
2005:    [ equal_code( initCode, codeNull )
2015:       | true :
2016:          initCode = oCodeNew
2021:          oNodeSetCode( scope, qInitCode, initCode )
2033:       | * :
2038:    ]
2038:    >> initCode;
      
      
      % external method resides in an external object file
      % (or in my system, the built-in runtime library).
      % The method has a label, as usual, which callers will use.
      % But we define that label with .tLabelExtern rather than .tLabel.
      %
      % Note, I'll hold off on issuing the .tLabelExtern until we see that
      % the external method is actually called.  Otherwise we'd fill each output file
      % with all the external method names in my included libraries, which seems dumb.
      %
      % Note this is fpc syntax.  I'm not sure about other Pascals.
      %
2042: ExternalDecl( Node decl ):
2044:    [ equal_zero( @DeclLevel( decl ) )
2056:       | false :  #eExternalMethodCannotBeNested
2059:       | * :
2064:    ]
2064:    oNodeSetBoolean( decl, qExternal, true )
2076:    [
2076:       | pStrLit :
               % that was the optional library name containing the method.
               % TO DO: I'm currently ignoring this.
2078:          [
2078:             | pName :
2080:                pStrLit
                     % that was the optional method name defined in that library,
                     % which might differ from the Pascal name.
2082:                oNodeSetString( decl, qExternalName, CURRENT_STRLIT )
2093:             | * :
2098:          ]
2098:       | * :
2103:    ]
2104:    ;
      
      
2104: ProcHeaderDecl >> Node:
2106:    pIdent
      
         % If we already have a forward declaration, we'll modify that decl
         % instead of creating a second symbol table entry.
         % (Alternatively could delete or hide the old entry.)
2108:    boolean redeclaring = false
2114:    Node decl = oScopeFindInCurrentScope
      
2119:    [ oNodeNull( decl )
2126:       | true :
               % first declaration
2127:          decl = @newIdent( nProc, LAST_ID )
2140:          oNodeSetLabel( decl, qValue, oLabelNew )
      
2151:       | false :
               % we already have a declaration.
               % Keep it, and its label.
2153:          redeclaring = true
2159:          [ oNodeGetBoolean( decl, qBodyDefined )
2169:             | true : #eAlreadyDefined
2172:             | * :
2177:          ]
2177:          [ oNodeGetBoolean( decl, qExternal )
2187:             | true : #eAlreadyDefined
2190:             | * :
2195:          ]
2195:          [ oNodeType( decl )
2202:             | nProc :
2203:             | * : #eAlreadyDefined   % wrong kind
2210:          ]
               % Move the existing param scope aside, so we can check that the
               % new one is consistent.  And, the body will want to see the new one
               % since the names might differ.
               % TO DO: If qOldParams already set, we have multiple forward decls,
               % which I believe is supposed to be an error.
2210:          oNodeSet( decl, qOldParams, oNodeGet( decl, qParams ) )
2229:          oNodeSet( decl, qParams, Null )
2241:    ]
      
2249:    int level = @ScopeLevel
2255:    boolean nested = greater( level, 0 )
2268:    inc( level )
2274:    oScopeBegin( level, allocUp )
2283:    Node paramScope = oScopeCurrent
      
         % A nested method has a hidden first param for the parent static scope.
         % This won't appear in the param decls list, just reserve space for it.
         % It's first so the static chain is always at a fixed offset from the frame pointer.
2288:    [ nested
2291:       | true :
2292:          int offset = oScopeAllocType( @PointerTypeTo( IntegerType ) )   % arbitrary ptr type
2307:       | * :
2312:    ]
      
2312:    @FormalArgDecl
2314:    oNodeSet( decl, qParams, paramScope )
2326:    oScopeEnd
2327:    ';'
      
2329:    [ redeclaring
2332:       | false : oScopeDeclare( decl )
2339:       | true :  % TO DO: check that qParams is consistent with qOldParams
2341:    ]
      
2349:    @MethodModifiers( decl )
2356:    >> decl;
      
      
2360: ProcDecl:
2362:    Node decl = @ProcHeaderDecl
      
         % Body may be a statement, "forward", "external".
         % Note, this syntax is based on FPC, and I'm not sure if other Pascals are similar.
         % FPC says that forward, external, cdecl, name, etc are not reserved words -
         % I think this means the user may declare other things with those names, but if so the
         % original meaning is lost.  I'll make them keywords for simplicity, for now
         % (just not too happy about "name").
      
2368:    [
2368:       | pForward :
               % Nothing to do.  We simply won't set qBodyDefined.
      
2370:       | pExternal : @ExternalDecl( decl )
      
2379:       | * :
               % Body statement
      
               % Enter the params scope again, so params are visible in body.
               % TO DO: Perhaps I could mark the scope read-only at this point.
2386:          Node paramScope = oNodeGet( decl, qParams )
2399:          oScopeEnter( paramScope )
      
               % Start scope for declarations within the proc
2405:          int level = oNodeGetInt( paramScope, qLevel )
2418:          oScopeBegin( level, allocDown )
2427:          oNodeSet( decl, qChildScope, oScopeCurrent )
      
2438:          Label label = oNodeGetLabel( decl, qValue )
2451:          @Block( nLocalVar, label )
2461:          oNodeSetBoolean( decl, qBodyDefined, true )
2473:          oScopeEnd
      
2474:          oScopeEnd  % paramScope
2475:    ]
2475:    ';';
      
      
      
2478: FuncHeaderDecl >> Node:
2480:    pIdent
      
         % If we already have a forward declaration, we'll modify that decl
         % instead of creating a second symbol table entry.
         % (Alternatively could delete or hide the old entry.)
2482:    boolean redeclaring = false
2488:    Node decl = oScopeFindInCurrentScope
      
2493:    [ oNodeNull( decl )
2500:       | true :
               % first declaration
2501:          decl = @newIdent( nFunc, LAST_ID )
2514:          oNodeSetLabel( decl, qValue, oLabelNew )
      
2525:       | false :
               % we already have a declaration.
               % Keep it, and its label.
2527:          redeclaring = true
2533:          [ oNodeGetBoolean( decl, qBodyDefined )
2543:             | true : #eAlreadyDefined
2546:             | * :
2551:          ]
2551:          [ oNodeType( decl )
2558:             | nFunc :
2559:             | * : #eAlreadyDefined   % wrong kind
2566:          ]
               % Move the existing param scope and return value aside,
               % so we can check that the new one is consistent.
               % And, the body will want to see the new one since the names might differ.
               % TO DO: If qOldParams already set, we have multiple forward decls,
               % which I believe is supposed to be an error.
2566:          oNodeSet( decl, qOldParams, oNodeGet( decl, qParams ) )
2585:          oNodeSet( decl, qParams, Null )
2597:          oNodeSet( decl, qOldType, oNodeGet( decl, qType ) )
2616:          oNodeSet( decl, qType, Null )
2628:    ]
      
2636:    int level = @ScopeLevel
2642:    boolean nested = greater( level, 0 )
2655:    inc( level )
2661:    oScopeBegin( level, allocUp )
2670:    Node paramScope = oScopeCurrent
      
         % A nested method has a hidden first param for the parent static scope.
         % This won't appear in the param decls list, just reserve space for it.
         % It's first so the static chain is always at a fixed offset from the frame pointer.
2675:    [ nested
2678:       | true :
2679:          int offset = oScopeAllocType( @PointerTypeTo( IntegerType ) )   % arbitrary ptr type
2694:       | * :
2699:    ]
      
2699:    @FormalArgDecl
2701:    oNodeSet( decl, qParams, paramScope )
      
2713:    ':'
      
2715:    Node theType
2715:    @TypeRef( theType )
2722:    oNodeSet( decl, qType, theType )
      
         % The function's param space gets an additional pointer,
         % which will point to a temporary in the caller's scope.
         % This pointer is essentially a VAR param, but I won't create an nParam for it.
      
2734:    Node ptrType = @PointerTypeTo( theType )
2745:    oNodeSetInt( decl, qResultOffset, oScopeAllocType( ptrType ) )
2761:    oScopeEnd
2762:    ';'
      
2764:    [ redeclaring
2767:       | false : oScopeDeclare( decl )
2774:       | true :  % TO DO: check that qParams is consistent with qOldParams
                      % and qType is consistent with qOldType
2776:    ]
      
2784:    @MethodModifiers( decl )
      
2791:    >> decl;
      
      
2795: FuncDecl:
2797:    Node decl = @FuncHeaderDecl
      
         % Body may be a statement, "forward", "external".
2803:    [
2803:       | pForward :
               % Nothing to do.  We simply won't set qBodyDefined.
      
2805:       | pExternal : @ExternalDecl( decl )
      
2814:       | * :
               % Body statement
      
               % Enter the params scope again, so params are visible in body.
               % TO DO: Perhaps I could mark the scope read-only at this point.
2821:          Node paramScope = oNodeGet( decl, qParams )
2834:          oScopeEnter( paramScope )
      
               % Start scope for declarations within the func
2840:          int level = oNodeGetInt( paramScope, qLevel )
2853:          oScopeBegin( level, allocDown )
2862:          oNodeSet( decl, qChildScope, oScopeCurrent )
      
2873:          Label label = oNodeGetLabel( decl, qValue )
2886:          @Block( nLocalVar, label )
2896:          oNodeSetBoolean( decl, qBodyDefined, true )
2908:          oScopeEnd
      
2909:          oScopeEnd  % paramScope
2910:    ]
2910:    ';';
      
      
2913: FormalArgDecl:
2915:    [
2915:       | '(' :
2917:          {
2917:             NodeVec decls = oNodeVecNew
2922:             Node decl
2922:             boolean isInOut = false
      
2928:             [
2928:                | pVar : isInOut = true
2936:                | * :
2941:             ]
      
2941:             {  pIdent
      
2943:                decl = @newIdent( nParam, LAST_ID )
2956:                oNodeSetBoolean( decl, qInOut, isInOut )
2968:                oNodeVecAppend( decls, decl )
      
2977:                [
2977:                   | ':' : >
2981:                   | ',' :
2983:                ]
2991:             }
      
2993:             Node theType
2993:             @TypeRef( theType )
      
                  % VAR param is declared with its given type, but allocated as a pointer.
3000:             Node allocType
3000:             [ isInOut
3003:                | true :   allocType = @PointerTypeTo( theType )
3015:                | * :      allocType = theType
3026:             ]
      
3026:             int i = 0
3032:             {[ equal( i, oNodeVecSize( decls ) )
3046:                | false :
3047:                   decl = oNodeVecElement( decls, i )
      
3060:                   oNodeSet( decl, qType, theType )
3072:                   oScopeDeclare( decl )
3078:                   oNodeSetInt( decl, qValue, oScopeAllocType( allocType ) )
3094:                   inc( i )
3100:                | * :
3105:                   >
3107:             ]}
      
3109:             oNodeVecDelete( decls )
      
3115:             [
3115:                | ')' : >
3119:                | ';' :
3121:             ]
3129:          }
3131:       | * :
3136:    ];
      
      
3137: ConstDecl:
3139:    {[
3139:       | pIdent :
3141:          [
3141:             | ':' :
3143:                @TypedConstDecl
3145:             | * :
3150:                @TrueConstDecl
3152:          ]
3152:       | * :
3157:          >
3159:    ]};
      
      
      % Parse a true constant declaration (as opposed to a typed const declaration).
      % The "true constant" terminology comes from Delphi docs.  It refers to a const that is
      % evaluated at compile time, rather than at program startup time.
      %
      % We've just accepted the identifier.
      %
3162: TrueConstDecl:
3164:    Node decl = @newIdent( nConst, LAST_ID )
3177:    '='
      
3179:    @ConstExpr
         % TO DO: string type
3181:    oNodeSetInt( decl, qValue, oValueTop )
3192:    oValuePop
3193:    oNodeSet( decl, qType, oTypeSTop )
3204:    oTypeSPop
      
3205:    oScopeDeclare( decl )
3211:    ';'
3214:    ;
      
      
      % Parse a typed const declaration.
      % We've just accepted the identifier and ':'
      %
3214: TypedConstDecl:
3216:    Node decl = @newIdent( nTypedConst, LAST_ID )
      
3229:    Node theType
3229:    @TypeRef( theType )
3236:    oNodeSet( decl, qType, theType )
      
         % Array and record consts are allocated in global memory,
         % with global offset stored as decl value.
         % Scalar consts are not allocated in memory, and their value is
         % stored directly as the decl value, as I do with "true constants".
         %
         % TO DO: I probably should store scalar consts in memory too, in case somebody
         % wants to get a pointer to them.  And anyway, typed constants can't be used in
         % constant expressions, so less need to store value in decl node.
      
         % TO DO: skip subranges, similar to oTypeSNodeType.
3248:    [ oNodeType( theType )
3255:       | nBooleanType, nByteType, nCharType, nIntegerType, nEnumType,
3256:         nPointerType, nUniversalPointerType :
               % Parse expression and store value in decl
3256:          '='
      
3258:          oTypeSPush( theType )
3264:          @ConstExpr
3266:          @ConstMatchTypes
      
3268:          oNodeSetInt( decl, qValue, oValueTop )
3279:          oValuePop
3280:          oTypeSPop
3281:          oScopeDeclare( decl )
3287:          ';'
      
3289:       | nShortStringType, nFileType :
3291:          #eNotImplemented
      
3293:       | nArrayType, nRecordType :
               % Allocate global space, store address in decl.
               % Push into global scope init code stream (since we'll be issuing code
               % rather than creating static data, at the moment).
               % Parse expression and store in global memory.
3295:          oScopeEnter( globalScope )
3301:          int addr = oScopeAllocType( theType )
3311:          oScopeEnd
3312:          oCodePush( @GetOrCreateInitCode( globalScope ) )
3323:          oNodeSetInt( decl, qValue, addr )
3335:          '='
3337:          @TypedConstInit( theType, addr )
3347:          oCodePop
3348:          oScopeDeclare( decl )
3354:          ';'
3356:    ]
3383:    ;
      
      
      % Parse the initial value of a constant that's being stored in global memory.
      % (An array or record constant, and recursively all its elements.)
      % Given the type, and the address in global memory for the const value.
      % The caller has already pushed into the global init code stream.
      %
3383: TypedConstInit( Node theType, int addr ):
      
         % TO DO: skip subranges, similar to oTypeSNodeTYpe
3385:    [ oNodeType( theType )
3392:       | nArrayType :
3393:          Node baseType = oNodeGet( theType, qBaseType )
3406:          Node indexType = oNodeGet( theType, qIndexType )
3419:          int low = @OrdinalLow( indexType )
3430:          int high = @OrdinalHigh( indexType )
3441:          int elementSize = oNodeGetInt( baseType, qSize )
      
3454:          '('
               % Loop over elements
3456:          int i = low
3462:          {
3462:             @TypedConstInit( baseType, addr )
3472:             [ equal( i, high )
3482:                | true : >
3485:                | false :
3487:             ]
3495:             ','
3497:             addr = add( addr, elementSize )
3510:             inc( i )
3516:          }
3518:          ')'
      
3520:       | nRecordType :
3522:          '('
3524:          Node fieldScope = oNodeGet( theType, qScope )
               % Loop over zero or more named fields.  It's not necessary to name them all.
               % fpc says the names that are given should be in order, but I'm not requiring that.
               % Since this is global memory, uninitialized fields will be left as 0.
3537:          {
3537:             [
3537:                | pIdent :
3539:                | * :  >
3546:             ]
3546:             Node field = oScopeFindRequireInScope( fieldScope )
3556:             ':'
3558:             Node fieldType = oNodeGet( field, qType )
3571:             int fieldAddr = add( addr, oNodeGetInt( field, qValue ) )
3591:             @TypedConstInit( fieldType, fieldAddr )
3601:             [
3601:                | ';' :
3603:                | * :  >
3610:             ]
3610:          }
3612:          ')'
      
3614:       | nBooleanType, nByteType, nCharType:
3616:          .tPushAddrGlobal  oEmitInt( addr )
3624:          oTypeSPush( theType )
3630:          @ConstExpr
3632:          @ConstMatchTypes
3634:          .tPushConstI  oEmitInt( oValueTop )
3641:          oValuePop
3642:          oTypeSPop
3643:          .tAssignB
      
3645:       | nIntegerType, nEnumType:
3647:          .tPushAddrGlobal  oEmitInt( addr )
3655:          oTypeSPush( theType )
3661:          @ConstExpr
3663:          .tPushConstI  oEmitInt( oValueTop )
3670:          oValuePop
3671:          oTypeSPop
3672:          .tAssignI
      
3674:       | nPointerType, nUniversalPointerType :
3676:          .tPushAddrGlobal  oEmitInt( addr )
3684:          oTypeSPush( theType )
3690:          @ConstExpr
3692:          .tPushConstI  oEmitInt( oValueTop )   % only allowing ptr constant Nil so don't need tPushConstP or link redirection
3699:          oValuePop
3700:          oTypeSPop
3701:          .tAssignP
      
3703:       | nShortStringType, nFileType :
3705:          #eNotImplemented
3707:    ]
3734:    ;
      
      
3734: TypeDecl:
3736:    {[
3736:       | pIdent :
3738:          Node decl = @newIdent( nTypeDecl, LAST_ID )
3751:          '='
3753:          Node theType
3753:          @TypeRef( theType )
3760:          oNodeSet( decl, qType, theType )
3772:          oScopeDeclare( decl )
3778:          ';'
3780:       | * :
3785:          >
3787:    ]};
      
3790: VarDecl( node_type varNodeType ):
3792:    {[
3792:       | pIdent :
3794:          NodeVec decls = oNodeVecNew
3799:          Node decl
3799:          {
3799:             decl = @newIdent( varNodeType, LAST_ID )
3812:             oNodeVecAppend( decls, decl )
3821:             [
3821:                | ',' :
3823:                   pIdent
3825:                | * :
3830:                   >
3832:             ]
3832:          }
3834:          ':'
3836:          Node theType
3836:          @TypeRef( theType )
      
3843:          int i = 0
3849:          {[ equal( i, oNodeVecSize( decls ) )
3863:             | false :
3864:                decl = oNodeVecElement( decls, i )
3877:                oNodeSet( decl, qType, theType )
3889:                oScopeDeclareAlloc( decl )
3895:                inc( i )
3901:             | * :
3906:               >
3908:          ]}
      
               % optional initialization
3910:          [
3910:             | '=' :
3912:                [ oNodeVecSize( decls )
3919:                   | 1 :
3920:                   | * :  #eOnlyOneVarCanBeInitialized
3927:                ]
      
                     % we need an initCode stream for this scope
3927:                Code initCode = @GetOrCreateInitCode( oScopeCurrent )
3937:                oCodePush( initCode )
      
                     % currently the global level has two scopes:
                     % the one for declarations e.g. vars and methods,
                     % and a second one for temporaries needed by the main block stmt.
                     % During evaluation of the init expr, we need to be in the 2nd scope
                     % in case the expression requires temporaries
                     % (so the temporaries get allocated in the right scope).
                     % TO DO: Maybe I should make the global scope the special case, instead.
3943:                boolean changedScope = false
3949:                [ equal_zero( @ScopeLevel )
3956:                   | true : oScopeEnter( initScope )
3963:                            changedScope = true
3969:                   | * :
3974:                ]
                     % generate assignment in initCode stream
3974:                @LValueVar( decl, true )
3984:                @Expr
3986:                @CoerceType
3988:                @Assign
3990:                [ changedScope
3993:                   | true : oScopeEnd
3995:                   | * :
4000:                ]
4000:                oCodePop
                   
4001:             | * :
4006:          ]
      
4006:          oNodeVecDelete( decls )
4012:          ';'
4014:       | * :
4019:          >
4021:    ]};
      
      
      % Parse a list of label declarations.
      % We'll create a tcode label at declaration time, for each user label.
      % If the user label is an integer, we'll record it as _label_<int> in the decl.
      %
4024: LabelDecl:
4026:    {
4026:       Node decl
4026:       [
4026:          | pIdent :
4028:          | pIntLit :
                  % Replace token with identifier "_label_<intlit>"
4030:             oChangeIntLitToLabelIdent
4031:       ]
4039:       decl = @newIdent( nLabel, LAST_ID )
            % TO DO: ensure not already declared in this scope.
            %        Or maybe that can be part of oScopeDeclare.
4052:       Label label = oLabelNew
4057:       oNodeSetLabel( decl, qValue, label )
4069:       oScopeDeclare( decl )
4075:       [
4075:          | ',' :
4077:          | * :
4082:             >
4084:       ]
4084:    }
4086:    ';'
4089:    ;
      
      
      % Parse a type reference, returning the nType.
      % This will add types to the type table, as needed.
      %
      % Style question - at the moment I think callers look clearer if we use
      % an out param here, rather than a return value.
      %
4089: TypeRef( out Node resultType ):
4091:    [
4091:       | pIdent :           % previously named type (including intrinsics)
4093:          Node decl = oScopeFindRequire
4098:          @ResolveUnitRef( decl )
4105:          [ oNodeType( decl )
4112:             | nTypeDecl :
4113:                resultType = oNodeGet( decl, qType )
4126:             | * :
4131:                #eNotType
4133:                resultType = IntegerType
4139:          ]
         
4139:       | pArray :
4141:          '['
      
               % A multi-dimensional array is represented as a chain
               %    array [subrange1] of array [subrange2] of elementType
      
               % First, we build a vector of nArray's, each with one subrange as its index type,
               % but without setting the "of" type or size.
      
4143:          NodeVec dimensions = oNodeVecNew
      
4148:          {
                  % to do: probably should use general subrange parsing, incl minimal size value
                  %   In fact, supposed to parse ordinal_type here.  all ordinal types have a static low, high.
                  %   Not necessary to be a subrange.
      
4148:             Node subrange = oNodeNew( nSubrangeType )
      
4158:             @ConstExpr
4160:             oNodeSetInt( subrange, qLow, oValueTop )
4171:             oValuePop
4172:             '..'
4174:             @ConstExpr
4176:             oNodeSetInt( subrange, qHigh, oValueTop )
4187:             oValuePop
      
4188:             @ConstMatchTypes
4190:             oNodeSet( subrange, qBaseType, oTypeSTop )
4201:             oNodeSetInt( subrange, qSize, oNodeGetInt( oTypeSTop, qSize ) )
4219:             oTypeSPop
4220:             oTypeAdd( subrange )
      
4226:             Node a = oNodeNew( nArrayType )
4236:             oNodeSet( a, qIndexType, subrange )
      
4248:             oNodeVecAppend( dimensions, a )
                  % I'll hold off on adding 'a' to the type table since not fully formed yet
      
4257:             [
4257:                | ']' : >
4261:                | ',' :
4263:             ]
4271:          }
      
4273:          pOf
4275:          Node baseType
4275:          @TypeRef( baseType )
      
               % Work backwards through the dimensions,
               % hooking up the 'of' type and calculating the size.
               % At each iteration, baseType is the 'of' type.
      
4282:          int dim = oNodeVecSize( dimensions )
      
4292:          {
4292:              dec(dim)
      
4298:              Node a = oNodeVecElement( dimensions, dim )
      
4311:              oNodeSet( a, qBaseType, baseType )
4323:              Node subrange = oNodeGet( a, qIndexType )
4336:              int width = subtract( oNodeGetInt( subrange, qHigh ), oNodeGetInt( subrange, qLow ) )
4363:              inc( width )
4369:              oNodeSetInt( a, qSize, multiply( width, oNodeGetInt( baseType, qSize ) ) )
      
4395:              oTypeAdd( a )
4401:              baseType = a
      
4407:              [ equal_zero(dim)
4414:                  | true:  >
4417:                  | *:
4422:              ]
4422:          }
      
4424:          resultType = oNodeVecElement( dimensions, 0 )
4437:          oNodeVecDelete( dimensions )
      
4443:       | '^' :
4445:          Node theType
4445:          @TypeRef( theType )
4452:          resultType = @PointerTypeTo( theType )
      
4463:       | pRecord :
4465:          resultType = oNodeNew( nRecordType )
4475:          oScopeBegin( -1, allocUp )    % level is meaningless here
      
4484:          @VarDecl( nRecordField )
      
4491:          int size = oNodeGetInt( oScopeCurrent, qSize )
               % to do: padding
4503:          [ equal_zero( size )
4510:             | true : #eRecordEmpty
4513:             | * :
4518:          ]
      
4518:          pEnd
      
4520:          oNodeSet( resultType, qScope, oScopeCurrent )
4531:          oNodeSetInt( resultType, qSize, size )
4543:          oScopeEnd
4544:          oTypeAdd( resultType )
      
      
4550:       | '(' :
               % An enum type declaration.
4552:          @EnumTypeRef( resultType )
      
      
            % *** TO DO: following type constructors are not implemented *** 
4559:       | pSet :
4561:          pOf
4563:          Node theType
4563:          @TypeRef( theType )
4570:          #eNotImplemented
4572:       | * :       % this works for cases except where expr starts with an id
4587:          @ConstExpr '..' @ConstExpr
4593:          @ConstMatchTypes
4595:          #eNotImplemented
4597:    ];
      
      
      % Parse an enum type.
      % We've already accepted the '('
      % Returns the new type.
      %
4598: EnumTypeRef( out Node resultType ):
      
4600:    resultType = oNodeNew( nEnumType )
4610:    int value = 0
4616:    int numValues = 0
4622:    boolean first = true
      
         % We'll declare the enum values in two scopes: the current scope, and a scope nested in the enum type.
         % That will let programs use either <val> or <enumType>.<val>
4628:    Node outerScope = oScopeCurrent
4633:    oScopeBegin( -1, allocUp )   % level is meaningless, and we won't use allocate
      
4642:    {
            % TO DO: assert that name not already seen in this scope, i.e. this enum.
            %  And possibly not in the outerScope either, since that probably wouldn't count as shadowing.
            %  It might be in some other higher/used scope.
4642:       pIdent
4644:       Node decl = @newIdent( nEnumValue, LAST_ID )
4657:       Node decl2 = @newIdent( nEnumValue, LAST_ID )
4670:       oNodeSet( decl, qType, resultType )
4682:       oNodeSet( decl2, qType, resultType )
      
            % build up name table, for i/o
4694:       int nameOffset = oStringAllocLit( ID_STRING( LAST_ID ) )
4707:       oNodeSetInt( decl, qNameOffset, nameOffset )
4719:       oNodeSetInt( decl2, qNameOffset, nameOffset )
4731:       [
4731:          | '=', ':=' :
4733:             oTypeSPush( IntegerType )
4739:             @ConstExpr
4741:             @ConstMatchTypes
4743:             oTypeSPop
                  % value must be ascending
                  % this obviously doesn't apply to the first value
4744:             [ equal_zero( numValues )
4751:                | false :
4752:                   [ greater( oValueTop, value )
4761:                      | false :   #eEnumValueNotAscending
4764:                      | * :
4769:                   ]
4769:                | * :
4774:             ]
4774:             [ equal( value, oValueTop )
4783:                | false :
                        % The values differ from 0..N-1.  pred/succ may not be used with this type.
4784:                   oNodeSetBoolean( resultType, qHasGap, true )
4796:                | * :
4801:             ]
4801:             value = oValueTop
4806:             oValuePop
4807:          | * :
4814:       ]
4814:       oNodeSetInt( decl, qValue, value )
4826:       oNodeSetInt( decl2, qValue, value )
4838:       oScopeDeclare( decl )
      
4844:       oScopeEnter( outerScope )
4850:       oScopeDeclare( decl2 )
4856:       oScopeEnd
      
4857:       inc( value )
4863:       inc( numValues )
4869:       [
4869:          | ',' :
4871:          | * :    >
4878:       ]
4878:    }
4880:    ')'
      
4882:    oNodeSet( resultType, qScope, oScopeCurrent )
4893:    oNodeSetInt( resultType, qSize, 4 )   % always integer sized
4905:    oScopeEnd
      
         % Finish creation of the name table
         %    struct {
         %      int    value;
         %      int    padding;
         %      char*  name;
         %    } table[ numValues + 1 ];
         %  final entry will have name == nullptr
         %
         % I'll need to generate init code, to store pointers in global data,
         % since I don't have a relocation mechanism for static data at the moment.
4906:    oCodePush( @GetOrCreateInitCode( globalScope ) )
4917:    oScopeEnter( globalScope )
4923:    int size = multiply( add( numValues, 1 ), 16 )
4943:    int addr = oScopeAlloc( size, 8 )
4956:    oScopeEnd
4957:    oNodeSetInt( resultType, qNameTable, addr )
         % loop over enum values
4969:    NodeIter it = oNodeGetIter( oNodeGet( resultType, qScope ), qDecls )
4989:    {
4989:       Node enumValue = oNodeIterValue( it )
4999:       [ oNodeNull( enumValue )
5006:          | true :  >
5009:          | * :
5014:       ]
5014:       .tPushAddrGlobal  oEmitInt( addr )
5022:       .tPushConstI  oEmitInt( oNodeGetInt( enumValue, qValue ) )
5037:       .tAssignI
5039:       addr = add( addr, 8 )
5052:       .tPushAddrGlobal  oEmitInt( addr )
5060:       .tPushAddrGlobal  oEmitInt( oNodeGetInt( enumValue, qNameOffset ) )
5075:       .tAssignP
5077:       addr = add( addr, 8 )
5090:       oNodeIterNext( it )
5096:    }
         % final table entry
5098:    .tPushAddrGlobal  oEmitInt( addr )
5106:    .tPushConstI  oEmitInt( 0 )
5114:    .tAssignI
5116:    addr = add( addr, 8 )
5129:    .tPushAddrGlobal  oEmitInt( addr )
5137:    .tPushConstI  oEmitInt( 0 )
5145:    .tAssignP
5147:    addr = add( addr, 8 )
5160:    oCodePop
      
5161:    oTypeAdd( resultType )
5168:    ;
      
      
      % --------------------------- Const Expressions --------------------------
      
      % Constant expressions are evaluated at compile time.
      % They are limited to constant literals, declared constants (not including TypedConstants!)
      % and a small selection of built-in functions. 
      %
      % The value of a constant expression is left on the Value Stack.
      % The type is left on the Type Stack.
      
5168: ConstExpr:
5170:    @ConstBoolExpr
5172:    {[
5172:       | '=' :
5174:          @ConstBoolTerm
5176:          @ConstMatchTypes
5178:          oTypeSPop  oTypeSPush( BooleanType )
5185:          oValueEqual
5186:       | '<>' :
5188:          @ConstBoolExpr
5190:          @ConstMatchTypes
5192:          oTypeSPop  oTypeSPush( BooleanType )
5199:          oValueNotEqual
5200:       | '<' :
5202:          @ConstBoolExpr
5204:          @ConstMatchTypes
5206:          oTypeSPop  oTypeSPush( BooleanType )
5213:          oValueLess
5214:       | '>' :
5216:          @ConstBoolExpr
5218:          @ConstMatchTypes
5220:          oTypeSPop  oTypeSPush( BooleanType )
5227:          oValueGreater
5228:       | '<=' :
5230:          @ConstBoolExpr
5232:          @ConstMatchTypes
5234:          oTypeSPop  oTypeSPush( BooleanType )
5241:          oValueLessEqual
5242:       | '>=' :
5244:          @ConstBoolExpr
5246:          @ConstMatchTypes
5248:          oTypeSPop  oTypeSPush( BooleanType )
5255:          oValueGreaterEqual
5256:       | * :  >
5273:    ]};
      
      
5276: ConstBoolExpr:
5278:    @ConstBoolTerm
5280:    {[
5280:       | pOr :
5282:          @ConstRequireBool
5284:          @ConstBoolTerm
5286:          @ConstRequireBoolPop
5288:          oValueOr
5289:       | * :  >
5296:    ]};
      
      
5299: ConstBoolTerm:
5301:    @ConstBoolFactor
5303:    {[
5303:       | pAnd :
5305:          @ConstRequireBool
5307:          @ConstBoolFactor
5309:          @ConstRequireBoolPop
5311:          oValueAnd
5312:       | * :  >
5319:    ]};
      
      
5322: ConstBoolFactor:
5324:    [
5324:       | pNot :
5326:          @ConstBoolFactor
5328:          @ConstRequireBool
5330:          oValueNot
5331:       | * :
5336:          @ConstArithExpr
5338:    ];
      
      
5339: ConstArithExpr:
5341:    @ConstTerm
5343:    {[
5343:       | '+' :
5345:          @ConstTerm
5347:          @ConstMatchTypes
5349:          oValueAdd
5350:       | '-' :
5352:          @ConstTerm
5354:          @ConstMatchTypes
5356:          oValueSub
5357:       | * :  >
5366:    ]};
      
      
5369: ConstTerm:
5371:    @ConstFactor
5373:    {[
5373:       | pTimes :
5375:          @ConstFactor
5377:          @ConstMatchTypes
5379:          oValueMult
5380:       | pDivide :
5382:          @ConstFactor
5384:          @ConstMatchTypes
5386:          oValueDiv
5387:       | * :  >
5396:    ]};
      
      
5399: ConstFactor:
5401:    [
5401:       | pPlus :
5403:          @ConstPrimary
5405:       | pMinus :
5407:          @ConstPrimary
5409:          oValueNegate
5410:       | * :
5417:          @ConstPrimary
5419:    ];
      
      
5420: ConstPrimary:
5422:    [
5422:       | pIntLit :
5424:          oValuePush( TOKEN_VALUE )
5429:          oTypeSPush( IntegerType )
5435:       | pCharLit :
5437:          oValuePush( TOKEN_VALUE )
5442:          oTypeSPush( CharType )
5448:       | pStrLit :
5450:          #eNotImplemented
5452:          oValuePush( 0 )
5458:          oTypeSPush( ShortStringType )
5464:       | '(' :
5466:          @ConstExpr
5468:          ')'
5470:       | pIdent :
5472:          Node decl = oScopeFindRequire
5477:          @ResolveUnitRef( decl )
5484:          [ oNodeType( decl )
5491:             | nBuiltInFunc :
5492:                @ConstBuiltInFunc( decl )
5499:             | nConst, nEnumValue :
5501:                oValuePush( oNodeGetInt( decl, qValue ) )
5514:                oTypeSPush( oNodeGet( decl, qType ) )
5527:             | * :
5536:                #eNotConst
5538:                oValuePush( 0 )
5544:                oTypeSPush( IntegerType )
5550:          ]
5550:       | '@' :
5552:          #eNotImplemented
5554:          oValuePush( 0 )
5560:          oTypeSPush( UniversalPointerType )
5566:       | * :
5581:          #eNotConst
5583:          oValuePush( 0 )
5589:          oTypeSPush( IntegerType )
5595:    ];
      
      
5596: ConstBuiltInFunc( Node decl ):
5598:    #eNotImplemented
5601:    ;
      
      
5601: ConstRequireBoolPop:
5603:    [ oTypeSNodeType
5605:       | nBooleanType :
5606:       | * :          #eNotBoolean
5613:    ]
5613:    oTypeSPop;
      
      
5615: ConstRequireBool:
5617:    [ oTypeSNodeType
5619:       | nBooleanType :
5620:       | * :          #eNotBoolean
5627:    ];
      
      
      % Require that the top two types on the type stack are matching (ignoring subranges).
      % Pop one of them, leaving only one.
      % The types refer to constant values on the Value Stack,
      % so any implicit conversion would occur there, not in code.
      %
      % TO DO: maybe I should say, require that the top type is compatible with the type under it.
      %        And always leave the type under it as the final type?
      %
      % TO DO: should be more strict about what I mean by MatchTypes vs
      %        CoerceTypes.  And when is either used.
      %
5628: ConstMatchTypes:
         % TO DO: implicit conversion from Char to String
5630:    node_type nt = oTypeSNodeType
5635:    oTypeSPop
5636:    [ equal_node_type( nt, oTypeSNodeType )
5645:       | false :
               % Some implicit conversion is allowed even here
5646:          [ oTypeSNodeType
5648:             | nPointerType :
5649:                [ nt
5652:                   | nUniversalPointerType :  >>
5654:                   | * :
5659:                ]
5659:             | nUniversalPointerType :
5661:                [ nt
5664:                   | nPointerType :  >>
5666:                   | * :
5671:                ]
5671:             | * :
5678:          ]
5678:          #eTypeMismatch
5680:       | * :
5685:    ];
      
      
      
      
      % ------------------------------ Expressions -----------------------------
      
      % There are two wrappers leading into expression parsing:
      %   Expr()
      %   BooleanExprControlFlow( out Label falseLabel )
      %
      % Expr always produces a value on the runtime expr stack,
      % and pushes its type on the type stack.
      %
      % BooleanExprControlFlow always generates control-flow code.
      % It does not push a value on the runtime expr stack.
      % It does not push a type on the type stack.
      % The control flow code ends up at Here if the expr is true,
      % and jumps to falseLabel if the expr is false.
      % This rule allocates falseLabel, and passes it back.
      % The caller will need to define its location.
      %
      % The internal methods of expr parsing may produce a mix of
      % values and control flow, depending on the operators seen.
      % We don't always do one or the other, hoping to be efficient for
      % cases like   "func_call( bool_var1, bool_var2 )"
      % as well as  "if bool_expr1 or bool_expr2 then ...".
      % If a subexpression rule produces control flow, it will allocate a
      % falseLabel and pass it back up.  And it will push the
      % result type as BooleanFlowType, to distinguish from BooleanType
      % which corresponds with a boolean value on the expr stack.
      % 
      % Note that my expression parsing is broken into more levels than
      % grammars describe for Pascal precedence levels.  This follows my
      % original parser implementation.  I think my rationale was that
      % operators from the levels that I split up couldn't have been
      % mixed anyway, since they require different data types
      % (e.g. boolean vs int/real).  And splitting them up simplified
      % my code.  But, I should revisit this.
      %
      
      
      % Public entry point:
      %
      % Parse an expression, leaving a value on the runtime expr stack
      % and its type on the type stack.
      %
      % This rule does not export control flow (though it may generate
      % control flow internally for subexpressions).
      %
5686: Expr:
5688:    Label falseLabel = labelNull
      
5694:    @ExprAllowFlow( falseLabel )
5701:    @FlowToVal( falseLabel );
      
      
      % Public entry point:
      %
      % Parse a Boolean expression, producing control flow code rather than a value.
      % Does not leave a value on the runtime expr stack.
      % Does not leave a type on the type stack.
      %
      % If the expression is true, the code will fall through to the end (Here).
      % If the expression is false, the code will jump to the given falseLabel,
      % which this rule will allocate but not define the location for.
      % The caller must do so.
      %
5709: BooleanExprControlFlow( out Label falseLabel ):
5711:    @ExprAllowFlow( falseLabel )
5718:    [ oTypeSNodeType
5720:       | nBooleanFlowType :
5721:       | nBooleanType :
               % convert value to control flow
5723:          falseLabel = oLabelNew
5728:          .tJumpFalse  oEmitLabel( falseLabel )
5736:       | * :
5743:          #eNotBoolean
5745:    ]
5745:    oTypeSPop;
      
      
      % If the current expr result is control flow, convert it to a value.
      % falseLabel is the label that had been used by the control flow.
      % On return it will be set to labelNull.
      %
5747: FlowToVal( inout Label falseLabel ):
5749:    [ oTypeSNodeType
5751:       | nBooleanFlowType :
5752:          Label doneLabel = oLabelNew
5757:          .tPushConstI  oEmitInt( 1 )
5765:          .tJump  oEmitLabel( doneLabel )
5773:          .tLabel  oEmitLabel( falseLabel )
5781:          .tPushConstI  oEmitInt( 0 )
5789:          .tLabel  oEmitLabel( doneLabel )
5797:          oTypeSPop
5798:          oTypeSPush( BooleanType )
5804:          falseLabel = labelNull
5810:       | * :
5815:    ];
      
      
      % If the current expr result is boolean value, convert it to control flow.
      % falseLabel will be allocated by this rule and passed back.
      % The caller must define its location.
      %
5816: ValToFlow( out Label falseLabel ):
5818:    [ oTypeSNodeType
5820:       | nBooleanType :
5821:          falseLabel = oLabelNew
5826:          .tJumpFalse  oEmitLabel( falseLabel )
5834:          oTypeSPop
5835:          oTypeSPush( BooleanFlowType )
5841:       | * :
5846:    ];
      
      
      % Parse an expression.  It may produce a value on the expr stack,
      % or control flow, depending on what's seen in the expression.
      % Leaves the expression type on the type stack.
      %
      % If the expression produces control flow, the expression type will be
      % nBooleanFlowType.  In this case, a true value falls through to Here,
      % and a false value jumps to falseLabel.  This rule will allocate falseLabel
      % and return it, but will not define its location; the caller must do so.
      %
      % If the expression produces a value, the value will be left on the
      % expression stack, and the type will be some type other than nBooleanFlowType.
      % In this case, falseLabel is ignored.
      %
5847: ExprAllowFlow( out Label falseLabel ):
5849:    @BoolExprAllowFlow( falseLabel )
5856:    {[
5856:       | '=' :
5858:          @FlowToVal( falseLabel )
5865:          @PromoteToIntOptional
5867:          @BoolExprAllowFlow( falseLabel )
5874:          @FlowToVal( falseLabel )
5881:          @PromoteToIntOptional
5883:          @MatchTypes
5885:          [ oTypeSNodeType
5887:             | nBooleanType, nCharType :     .tEqualB
5890:             | nIntegerType, nEnumType :     .tEqualI
5894:             | nPointerType, nUniversalPointerType :    .tEqualP
5898:             | nShortStringType, nStrLitType :
5900:                @ShortStringCmp  .tPushConstI  oEmitInt( 0 )  .tEqualI
5912:             | * :                           #eNotAllowed
5933:          ]
5933:          oTypeSPop
5934:          oTypeSPush( BooleanType )
      
5940:       | '<>' :
5942:          @FlowToVal( falseLabel )
5949:          @PromoteToIntOptional
5951:          @BoolExprAllowFlow( falseLabel )
5958:          @FlowToVal( falseLabel )
5965:          @PromoteToIntOptional
5967:          @MatchTypes
5969:          [ oTypeSNodeType
5971:             | nBooleanType, nCharType :     .tNotEqualB
5974:             | nIntegerType, nEnumType :     .tNotEqualI
5978:             | nPointerType, nUniversalPointerType :    .tNotEqualP
5982:             | nShortStringType, nStrLitType :
5984:                @ShortStringCmp  .tPushConstI  oEmitInt( 0 )  .tNotEqualI
5996:             | * :                           #eNotAllowed
6017:          ]
6017:          oTypeSPop
6018:          oTypeSPush( BooleanType )
      
6024:       | '<' :
6026:          @FlowToVal( falseLabel )
6033:          @PromoteToIntOptional
6035:          @BoolExprAllowFlow( falseLabel )
6042:          @FlowToVal( falseLabel )
6049:          @PromoteToIntOptional
6051:          @MatchTypes
6053:          [ oTypeSNodeType
6055:             | nBooleanType, nCharType :     .tLessB
6058:             | nIntegerType, nEnumType :     .tLessI
6062:             | nPointerType, nUniversalPointerType :   .tLessP
6066:             | nShortStringType, nStrLitType :
6068:                @ShortStringCmp  .tPushConstI  oEmitInt( 0 )  .tLessI
6080:             | * :                           #eNotAllowed
6101:          ]
6101:          oTypeSPop
6102:          oTypeSPush( BooleanType )
      
6108:       | '>' :
6110:          @FlowToVal( falseLabel )
6117:          @PromoteToIntOptional
6119:          @BoolExprAllowFlow( falseLabel )
6126:          @FlowToVal( falseLabel )
6133:          @PromoteToIntOptional
6135:          @MatchTypes
6137:          [ oTypeSNodeType
6139:             | nBooleanType, nCharType :     .tGreaterB
6142:             | nIntegerType, nEnumType :     .tGreaterI
6146:             | nPointerType, nUniversalPointerType :   .tGreaterP
6150:             | nShortStringType, nStrLitType :
6152:                @ShortStringCmp  .tPushConstI  oEmitInt( 0 )  .tGreaterI
6164:             | * :                           #eNotAllowed
6185:          ]
6185:          oTypeSPop
6186:          oTypeSPush( BooleanType )
      
6192:       | '<=' :
6194:          @FlowToVal( falseLabel )
6201:          @PromoteToIntOptional
6203:          @BoolExprAllowFlow( falseLabel )
6210:          @FlowToVal( falseLabel )
6217:          @PromoteToIntOptional
6219:          @MatchTypes
6221:          [ oTypeSNodeType
6223:             | nBooleanType, nCharType :     .tLessEqualB
6226:             | nIntegerType, nEnumType :     .tLessEqualI
6230:             | nPointerType, nUniversalPointerType :   .tLessEqualP
6234:             | nShortStringType, nStrLitType :
6236:                @ShortStringCmp  .tPushConstI  oEmitInt( 0 )  .tLessEqualI
6248:             | * :                           #eNotAllowed
6269:          ]
6269:          oTypeSPop
6270:          oTypeSPush( BooleanType )
      
6276:       | '>=' :
6278:          @FlowToVal( falseLabel )
6285:          @PromoteToIntOptional
6287:          @BoolExprAllowFlow( falseLabel )
6294:          @FlowToVal( falseLabel )
6301:          @PromoteToIntOptional
6303:          @MatchTypes
6305:          [ oTypeSNodeType
6307:             | nBooleanType, nCharType :     .tGreaterEqualB
6310:             | nIntegerType, nEnumType :     .tGreaterEqualI
6314:             | nPointerType, nUniversalPointerType :   .tGreaterEqualP
6318:             | nShortStringType, nStrLitType :
6320:                @ShortStringCmp  .tPushConstI  oEmitInt( 0 )  .tGreaterEqualI
6332:             | * :                           #eNotAllowed
6353:          ]
6353:          oTypeSPop
6354:          oTypeSPush( BooleanType )
      
6360:       | * :
6375:          >
6377:    ]};
      
      
6380: BoolExprAllowFlow( out Label falseLabel ):
6382:    Label trueLabel = labelNull
      
6388:    @BoolTermAllowFlow( falseLabel )
6395:    {[
6395:       | pOr :
6397:          [ oTypeSNodeType
6399:             | nBooleanFlowType :
                     % We are true here. Jump ahead to done
6400:                [ equal_label( trueLabel, labelNull )
6410:                   | true :  trueLabel = oLabelNew
6416:                   | * :
6421:                ]
6421:                .tJump  oEmitLabel( trueLabel )
6429:             | nBooleanType :
6431:                @ValToFlow( falseLabel )
                     % We are true here. Jump ahead to done
6438:                [ equal_label( trueLabel, labelNull )
6448:                   | true :  trueLabel = oLabelNew
6454:                   | * :
6459:                ]
6459:                .tJump  oEmitLabel( trueLabel )
6467:             | * : #eNotBoolean
6476:          ]
6476:          oTypeSPop
      
               % false in previous term will jump here, to try this alternative term
6477:          .tLabel  oEmitLabel( falseLabel )
      
               % we'll get a new falseLabel for this term
6485:          falseLabel = labelNull
6491:          @BoolTermAllowFlow( falseLabel )
      
6498:          [ oTypeSNodeType
6500:             | nBooleanFlowType :
6501:             | nBooleanType :
6503:                @ValToFlow( falseLabel )
6510:             | * : #eNotBoolean
6519:          ]
      
6519:          oTypeSPop
6520:          oTypeSPush( BooleanFlowType )
      
6526:       | * :
6531:          >
6533:    ]}
      
         % any short-circuit trues jump here to the end
6535:    [ equal_label( trueLabel, labelNull )
6545:       | false :
6546:          .tLabel  oEmitLabel( trueLabel )
6554:       | * :
6559:    ]
6560:    ;
      
      
6560: BoolTermAllowFlow( out Label falseLabel ):
6562:    Label overallFalseLabel = labelNull
      
6568:    @BoolFactorAllowFlow( falseLabel )
6575:    {[
6575:       | pAnd :
6577:          [ oTypeSNodeType
6579:             | nBooleanFlowType :
6580:             | nBooleanType :
6582:                @ValToFlow( falseLabel )
6589:             | * :
6596:                #eNotBoolean
6598:          ]
6598:          oTypeSPop
      
               % We're going to have a different falseLabel for each term,
               % because we let each rule allocate its own (rather than accepting labels passed in).
               % And in this case we want them all to go to the same place,
               % to be determined by the caller.
               %
               % I'll allow for label aliases.  This will be more optimal than generating
               % multiple private false-handling code segments, that the true path would have to
               % jump around.  That would be hard to eliminate afterwards.
      
6599:          [ equal_label( overallFalseLabel, labelNull )
6609:             | true :
6610:                overallFalseLabel = oLabelNew
6615:                .tLabelAlias  oEmitLabel( falseLabel )  oEmitLabel( overallFalseLabel )
6629:                falseLabel = overallFalseLabel
6635:             | * :
6640:          ]
      
6640:          Label factorFalseLabel = labelNull
6646:          @BoolFactorAllowFlow( factorFalseLabel )
      
6653:          [ oTypeSNodeType
6655:             | nBooleanFlowType :
6656:             | nBooleanType :
6658:                @ValToFlow( factorFalseLabel )
6665:             | * : #eNotBoolean
6674:          ]
6674:         .tLabelAlias  oEmitLabel( factorFalseLabel )  oEmitLabel( overallFalseLabel )
      
6688:       | * :
6693:          >
6695:    ]};
      
6698: BoolFactorAllowFlow( out Label falseLabel ):
6700:    [
6700:       | pNot :
6702:          Label factorFalseLabel = labelNull
      
6708:          @BoolFactorAllowFlow( factorFalseLabel )
6715:          [ oTypeSNodeType
6717:             | nBooleanFlowType :
                     % We have control flow, and are sitting at the point that has value false.
6718:                falseLabel = oLabelNew
6723:                .tJump  oEmitLabel( falseLabel )
                     % The true path jumps here
6731:                .tLabel  oEmitLabel( factorFalseLabel )
      
6739:             | nBooleanType :
                     % I have a value.  I'll leave it as a value, rather than create control flow.
                     % See how this goes.
6741:                .tNot
      
6743:             | * : #eNotBoolean
6752:          ]
      
6752:       | * :
6757:          @ArithExprAllowFlow( falseLabel )
6764:    ];
      
6765: ArithExprAllowFlow( out Label falseLabel ):
6767:    boolean first = true
6773:    int tempStrOffset
      
6773:    @TermAllowFlow( falseLabel )
6780:    {[
6780:       | '+' :
6782:          [ oTypeSNodeType
6784:             | nIntegerType, nByteType :
6785:                @PromoteToIntPop
6787:                @TermAllowFlow( falseLabel )  % actually not allowing CF, will be caught by type check
      
6794:                [ oTypeSNodeType
6796:                   | nPointerType, nUniversalPointerType :
                           % int + ptr
6797:                      .tSwap
                           % leave only the ptr type on the type stack (int was already popped above)
6799:                      @PointerAddition
6801:                   | * :
6808:                      @PromoteToInt
6810:                      .tAddI
6812:                ]
      
6812:             | nShortStringType, nStrLitType, nCharType :
                     % String concatenation
6814:                [ first
6817:                   | true :  % move into a temp string, so subsequent term(s) can further modify it.
6818:                             tempStrOffset = @MoveIntoTempShortString
6824:                             first = false
6830:                   | * :
6835:                ]
6835:                @TermAllowFlow( falseLabel )  % actually not allowing CF, will be caught by type check
6842:                [ oTypeSNodeType
6844:                   | nShortStringType, nStrLitType :
6845:                      @ShortStringAppendShortString
                           % Have to re-push the temp string.
                           % If we ever have .tDup then the append method could do it and we wouldn't need this
6847:                      .tPushAddrLocal  oEmitInt( tempStrOffset )
6855:                      oTypeSPush( ShortStringType )
6861:                   | nCharType :
6863:                      @ShortStringAppendChar
                           % Have to re-push the temp string.
                           % If we ever have .tDup then the append method could do it and we wouldn't need this
6865:                      .tPushAddrLocal  oEmitInt( tempStrOffset )
6873:                      oTypeSPush( ShortStringType )
6879:                   | * :
6888:                      #eTypeMismatch
6890:                      oTypeSPop
6891:                ]
      
6891:             | nPointerType, nUniversalPointerType :
6893:                @TermAllowFlow( falseLabel )   % actually not allowing CF
6900:                @PromoteToIntPop
6902:                @PointerAddition
      
6904:             | * :
6921:                #eNotAllowed
6923:          ]
      
6923:       | '-' :
6925:          [ oTypeSNodeType
6927:             | nIntegerType, nByteType :
6928:                @PromoteToIntPop
6930:                @TermAllowFlow( falseLabel )
6937:                @PromoteToInt
6939:                .tSubI
      
6941:             | nPointerType, nUniversalPointerType :
6943:                @TermAllowFlow( falseLabel )
6950:                [ oTypeSNodeType
6952:                   | nIntegerType, nByteType :
6953:                      @PromoteToIntPop
6955:                      @PointerSubInt
6957:                   | nPointerType, nUniversalPointerType :
6959:                      @MatchTypes
6961:                      @PointerSubPointer
6963:                   | * :
6974:                      #eNotAllowed
6976:                ]
      
6976:             | * :  #eNotAllowed
      
6989:          ]
6989:       | * :
6996:          >
6998:    ]};
      
7001: TermAllowFlow( out Label falseLabel ):
7003:    @FactorAllowFlow( falseLabel )
7010:    {[
7010:       | pTimes :
7012:          @PromoteToIntPop
7014:          @FactorAllowFlow( falseLabel )  % actually not allowing CF, will be caught by type check
7021:          @PromoteToInt
7023:          .tMultI
7025:       | pDivide :
7027:          @PromoteToIntPop
7029:          @FactorAllowFlow( falseLabel )
7036:          @PromoteToInt
7038:          .tDivI
7040:       | * :
7047:          >
7049:    ]};
      
7052: FactorAllowFlow( out Label falseLabel ):
7054:    [
7054:       | pPlus :
7056:          @PrimaryAllowFlow( falseLabel )  % actually not allowing CF, will be caught by type check
               % TO DO: unary +/- is supposed to leave expression type as-is.
7063:          @PromoteToInt
7065:       | pMinus :
7067:          @PrimaryAllowFlow( falseLabel )
               % TO DO: unary +/- is supposed to leave expression type as-is.
7074:          @PromoteToInt
7076:          .tNegI
7078:       | * :
7085:          @PrimaryAllowFlow( falseLabel )
7092:    ];
      
7093: PrimaryAllowFlow( out Label falseLabel ):
7095:    [
7095:       | pIntLit :
7097:          .tPushConstI  oEmitInt( TOKEN_VALUE )
7104:          oTypeSPush( IntegerType )
      
7110:       | pCharLit :
7112:          .tPushConstI  oEmitInt( TOKEN_VALUE )
7119:          oTypeSPush( CharType )
      
7125:       | '(' :
7127:          @ExprAllowFlow( falseLabel )
7134:          ')'
      
7136:       | pStrLit :
7138:          int addr = oStringAllocShortStringLit( CURRENT_STRLIT )     % store in global data
7147:          .tPushAddrGlobal oEmitInt( addr )
               % TO DO: consider defining a ShortString type with the exact capacity used.
               % But, I don't think it should matter here, since nobody should be assigning to this string.
7155:          oTypeSPush( StrLitType )
               % This seems unlikely, but the strlit may be followed by
               % array indexing.  Handle this the same way we would with a variable expression (see VarExpr)
               % First, advance the pointer by index if any
7161:          @LValueIndexes
               % get final value of dereferencing, if any
7163:          @FetchVar
      
7165:       | pIdent :
7167:          Node decl = oScopeFindRequire
7172:          @ResolveUnitRef( decl )
7179:          Node theType
      
7179:          [ oNodeType( decl )
7186:             | nFunc :
7187:                @Call( decl )
      
7194:             | nBuiltInFunc :
7196:                @CallBuiltInFunc( decl )
      
7203:             | nConst, nEnumValue :
7205:                theType = oNodeGet( decl, qType )
7218:                oTypeSPush( theType )
7224:                [ oTypeSNodeType
7226:                   | nIntegerType, nEnumType, nBooleanType :
7227:                      .tPushConstI @EmitValue( decl )
7236:                   | nPointerType, nUniversalPointerType :
                           % We have one pointer const, Nil.  It's pushed as I.
                           % Sign-extending I to P won't hurt since it's 0.
7238:                      .tPushConstI @EmitValue( decl )
7247:                   | * :
7260:                      #eNotImplemented
7262:                ]
      
7262:             | nGlobalVar, nLocalVar, nParam, nTypedConst :
7264:                @VarExpr( decl )
      
7271:             | * :
7290:                #eNotValue
7292:                oTypeSPush( IntegerType )
7298:          ]
      
7298:       | '@' :        % @var -- pointer to var
7300:          pIdent
      
7302:          Node decl = oScopeFindRequire
7307:          @ResolveUnitRef( decl )
7314:          Node theType
      
               % writeable is false because we're not on the left hand side of an assignment,
               % or passign into a var parameter.  So it's ok to take the address of a typed const.
7314:          @LValueVar( decl, false )
      
               % The above leaves the pointed-to type on type stack.
               % Replace with ptr-to-<type>.
7324:          theType = oTypeSTop
7329:          oTypeSPop
7330:          Node ptrType = @PointerTypeTo( theType )
7341:          oTypeSPush( ptrType )
      
7347:       | * :
7362:          #eNotValue
7364:          oTypeSPush( IntegerType )
7370:    ];
      
      
      % Parse a variable expression, given the declaration of the
      % just-accepted identifier.
      % Leaves the value on the expression stack, and type on the type stack.
      %
7371: VarExpr( Node decl ):
7373:    Node theType = oNodeGet( decl, qType )
         % how many levels up the static scope? Will ignore for globals.
7386:    int uplevels = @DeclUpLevels( decl )
      
7397:    oTypeSPush( theType )
7403:    [ oTypeSNodeType
7405:       | nIntegerType, nEnumType :
7406:          [ oNodeType( decl )
7413:             | nGlobalVar, nTypedConst :   .tPushGlobalI  @EmitValue( decl )
7423:             | nLocalVar :
7425:                [ equal_zero( uplevels )
7432:                   | true :  .tPushLocalI  @EmitValue( decl )
7442:                   | * :     .tPushUpLocalI  oEmitInt( uplevels )  @EmitValue( decl )
7462:                ]
7462:             | nParam :
7464:                [ oNodeGetBoolean( decl, qInOut )
7474:                   | true :    % VAR param points to the var.  Auto dereference.
7475:                      [ equal_zero( uplevels )
7482:                         | true :  .tPushParamP  @EmitValue( decl )
7492:                         | * :     .tPushUpParamP  oEmitInt( uplevels )  @EmitValue( decl )
7512:                      ]
7512:                      .tFetchI
7514:                   | * :
7519:                      [ equal_zero( uplevels )
7526:                         | true :  .tPushParamI  @EmitValue( decl )
7536:                         | * :     .tPushUpParamI  oEmitInt( uplevels )  @EmitValue( decl )
7556:                      ]
7556:                ]
7556:          ]
      
7568:       | nBooleanType, nByteType, nCharType :
7570:          [ oNodeType( decl )
7577:             | nGlobalVar, nTypedConst :   .tPushGlobalB  @EmitValue( decl )
7587:             | nLocalVar :
7589:                [ equal_zero( uplevels )
7596:                   | true :  .tPushLocalB  @EmitValue( decl )
7606:                   | * :     .tPushUpLocalB  oEmitInt( uplevels )  @EmitValue( decl )
7626:                ]
7626:             | nParam :
7628:                [ oNodeGetBoolean( decl, qInOut )
7638:                   | true :    % VAR param points to the var.  Auto dereference.
7639:                      [ equal_zero( uplevels )
7646:                         | true :  .tPushParamP  @EmitValue( decl )
7656:                         | * :     .tPushUpParamP  oEmitInt( uplevels )  @EmitValue( decl )
7676:                      ]
7676:                      .tFetchB
7678:                   | * :
7683:                      [ equal_zero( uplevels )
7690:                         | true :  .tPushParamB  @EmitValue( decl )
7700:                         | * :     .tPushUpParamB  oEmitInt( uplevels )  @EmitValue( decl )
7720:                      ]
7720:                ]
7720:          ]
      
7732:       | nFileType :
7734:          #eNotImplemented
      
7736:       | nPointerType, nUniversalPointerType :
7738:          [ oNodeType( decl )
7745:             | nGlobalVar, nTypedConst :   .tPushGlobalP @EmitValue( decl )
7755:             | nLocalVar :
7757:                [ equal_zero( uplevels )
7764:                   | true :  .tPushLocalP  @EmitValue( decl )
7774:                   | * :     .tPushUpLocalP  oEmitInt( uplevels )  @EmitValue( decl )
7794:                ]
7794:             | nParam :
7796:                [ oNodeGetBoolean( decl, qInOut )
7806:                   | true :    % VAR param points to the var.  Auto dereference.
7807:                      [ equal_zero( uplevels )
7814:                         | true :  .tPushParamP  @EmitValue( decl )
7824:                         | * :     .tPushUpParamP  oEmitInt( uplevels )  @EmitValue( decl )
7844:                      ]
7844:                      .tFetchP
7846:                   | * :
7851:                      [ equal_zero( uplevels )
7858:                         | true :  .tPushParamP  @EmitValue( decl )
7868:                         | * :     .tPushUpParamP  oEmitInt( uplevels )  @EmitValue( decl )
7888:                      ]
7888:                ]               
7888:          ]
7900:          [
7900:             | '^' :             % dereferenced
7902:                oTypeSPop
7903:                oTypeSPush( oNodeGet( theType, qBaseType ) )
7916:                @LValueIndexes
7918:                @FetchVar
7920:             | '[' :             % dereferencing pointer like an array [0..] of baseType
7922:                @PointerArraySubscript
                     % modify addr for any subsequent subscripts, field references, etc
7924:                @LValueIndexes
7926:                @FetchVar
7928:             | * :               % just ptr value alone
7935:          ]
      
7935:       | nArrayType, nRecordType, nShortStringType :
               % compound type
               % first, push addr of start of var
7937:          [ oNodeType( decl )
7944:             | nGlobalVar, nTypedConst :   .tPushAddrGlobal @EmitValue( decl )
7954:             | nLocalVar :
7956:                [ equal_zero( uplevels )
7963:                   | true :  .tPushAddrLocal  @EmitValue( decl )
7973:                   | * :     .tPushAddrUpLocal  oEmitInt( uplevels )  @EmitValue( decl )
7993:                ]
7993:             | nParam :
7995:                [ oNodeGetBoolean( decl, qInOut )
8005:                   | true :    % VAR param points to the var.  Auto dereference.
8006:                      [ equal_zero( uplevels )
8013:                         | true :  .tPushParamP  @EmitValue( decl )
8023:                         | * :     .tPushUpParamP  oEmitInt( uplevels )  @EmitValue( decl )
8043:                      ]
8043:                   | * :
8048:                      [ equal_zero( uplevels )
8055:                         | true :  .tPushAddrParam  @EmitValue( decl )
8065:                         | * :     .tPushAddrUpParam  oEmitInt( uplevels )  @EmitValue( decl )
8085:                      ]
8085:                ]
8085:          ]
               % modify addr for subscripts, field references, etc
8097:          @LValueIndexes
               % get final value
8099:          @FetchVar
8101:    ];
      
      
      % Addr of start of var is on expr stack; type is on type stack.
      % Replace expr stack with value of var.
      % (In the case of compound vars, this remains as the addr of the var).
      
8128: FetchVar:
8130:    [ oTypeSNodeType
8132:       | nIntegerType, nEnumType :  .tFetchI
8135:       | nBooleanType, nByteType, nCharType :  .tFetchB
8139:       | nFileType :   #eNotImplemented
8143:       | nPointerType :             .tFetchP
8147:       | nUniversalPointerType :    #eCantDereference
8151:       | nArrayType, nRecordType, nStrLitType, nShortStringType :  % compound type; leave as addr
8153:    ];
      
      
      % Addr of start of var is already on run stack, and type is on type stack.
      % Read subscripts, record fields, etc, to get final addr on run stack, and final type
      % on type stack.
      
8182: LValueIndexes:
8184:    {[
8184:       | '[' :
8186:          [ oTypeSNodeType
8188:             | nArrayType :    @ArraySubscripts
8191:             | nPointerType :  @PointerArraySubscript
8195:             | nStrLitType, nShortStringType :  @ShortStringArraySubscript
8199:             | * :             #eNotArray
8212:          ]
8212:       | '.' :       @RecordFieldRef
8216:       | '^' :       @PointerDeref   % TO DO: I suspect I don't have logic right here
                                          % about precondition and using .tFetchP
                                          % Ideally this should take over for the ^ in VarExpr too.
8220:       | * :         >
8231:    ]};
      
8234: ArraySubscripts:
8236:    [ oTypeSNodeType
8238:       | nArrayType :
8239:       | * :       #eNotArray
8246:    ]
8246:    {
8246:       [ oTypeSNodeType
8248:          | nArrayType :
8249:          | * :    #eTooManySubscripts
8256:       ]
      
            % low subscript of this dimension
8256:       int low = @OrdinalLow( oNodeGet( oTypeSTop, qIndexType ) )
      
            % replace type stack with next dimension, or OF type
8273:       Node baseType
8273:       baseType = oNodeGet( oTypeSTop, qBaseType )
8285:       oTypeSPop
8286:       oTypeSPush( baseType )
      
8292:       @Expr
8294:       @RequireIntPop
            % adjust for low subscript
8296:       [ equal_zero( low )
8303:          | false :
8304:             .tPushConstI oEmitInt( low ) .tSubI
8314:          | * :
8319:       ]
      
            % multiply by element size
8319:       int size = oNodeGetInt( baseType, qSize )
8332:       [ equal( size, 1 )
8342:          | false :
8343:             .tPushConstI oEmitInt( size ) .tMultI
8353:          | * :
8358:       ]
      
            % update start address
8358:       .tAddPI
8360:       [
8360:          | ']' :  >
8364:          | ',' :
8366:       ]
8374:    };
      
      
      % pointer[index] - similar to array[index] where index counts from 0.
      % On entry, the pointer value is on the stack, and pointer type is on the type stack.
      % We've already accepted the '['.
      % On exit, the address of the pointed-to element is on the stack,
      % and the element type is on the type stack.
      %
8377: PointerArraySubscript:
8379:    [ oTypeSNodeType
8381:       | nPointerType :
8382:       | * :    #eCantDereference
8389:    ]
         % replace type stack with base type
8389:    Node baseType = oNodeGet( oTypeSTop, qBaseType )
8401:    oTypeSPop
8402:    oTypeSPush( baseType )
         
8408:    @Expr
8410:    @RequireIntPop
         % multiply by element size
8412:    int size = oNodeGetInt( baseType, qSize )
8425:    [ equal( size, 1 )
8435:       | false :
8436:          .tPushConstI  oEmitInt( size )  .tMultI
8446:       | * :
8451:    ]
         % update start address
8451:    .tAddPI
8453:    ']';
      
      
      % Specialization of array indexing for ShortString.
      % We treat the starting index as 0 so that str[1] sees the first string char,
      % past the length byte.
      %
8456: ShortStringArraySubscript:
8458:    [ oTypeSNodeType
8460:       | nStrLitType, nShortStringType :
8461:       | * :    #eCantDereference
8470:    ]
8470:    oTypeSPop
8471:    oTypeSPush( CharType )
8477:    @Expr
8479:    @RequireIntPop
8481:    .tAddPI
8483:    ']';
      
      
8486: RecordFieldRef:
8488:    [ oTypeSNodeType
8490:       | nRecordType :
8491:       | * :    #eNotRecord
8498:    ]
8498:    oScopeEnter( oNodeGet( oTypeSTop, qScope ) )
8510:    pIdent
8512:    Node field = oScopeFindRequire
         % oScopeFind searches all open scopes, so make sure we found nRecordField
         % which could only be seen in the local scope we entered above.
8517:    [ oNodeType( field )
8524:       | nRecordField :
8525:       | * :   #eNotRecordField
8532:    ]
8532:    oScopeEnd
8533:    int offset = oNodeGetInt( field, qValue )
8546:    [ equal_zero( offset )
8553:       | false :
8554:          .tPushConstI oEmitInt( offset ) .tAddPI
8564:       | * :
8569:    ]
      
         % replace the type on the type stack, with the field type
8569:    oTypeSPop
8570:    oTypeSPush( oNodeGet( field, qType ) )
8584:    ;
      
      
      % On entry, expr stack has ptr, and integer index above it.
      % The type stack has just the pointer type.
      % Pop those, and push the ptr advanced to that index
      % (scaled by the pointed-to element size).
      % Leaves the pointer type on the type stack.
      %
8584: PointerAddition:
8586:    Node elementType = oNodeGet( oTypeSTop, qBaseType )
8598:    int elementSize = oNodeGetInt( elementType, qSize )
8611:    [ equal( elementSize, 1 )
8621:       | false :
8622:          .tPushConstI  oEmitInt( elementSize )
8630:          .tMultI
8632:       | * :
8637:    ]
8637:    .tAddPI
8640:    ;
      
      
      % On entry, expr stack has ptr, and integer above it.
      % The type stack has just the pointer type.
      % Pop those, and push the ptr decremented by that integer
      % (scaled by the pointed-to element size).
      % Leaves the pointer type on the type stack.
      %
8640: PointerSubInt:
8642:    Node elementType = oNodeGet( oTypeSTop, qBaseType )
8654:    int elementSize = oNodeGetInt( elementType, qSize )
8667:    [ equal( elementSize, 1 )
8677:       | false :
8678:          .tPushConstI  oEmitInt( elementSize )
8686:          .tMultI
8688:       | * :
8693:    ]
8693:    .tSubPI
8696:    ;
      
      
      % On entry, expr stack has two pointers, P1 and P2 above it.
      % The type stack has the type of P1.  (The type of P2 was already matched to P1.)
      % Replace the pointers on the expression stack with P1 - P2, scaled by the
      % pointed-to element size.  Type stack switched to integer.
      % 
8696: PointerSubPointer:
8698:    .tSubP
8700:    Node elementType = oNodeGet( oTypeSTop, qBaseType )
8712:    int elementSize = oNodeGetInt( elementType, qSize )
8725:    [ equal( elementSize, 1 )
8735:       | false :
8736:          .tPushConstI  oEmitInt( elementSize )
8744:          .tDivI
8746:       | * :
8751:    ]
8751:    oTypeSPop
8752:    oTypeSPush( IntegerType )
8759:    ;
      
      % ptr deref on left side, i.e. BEFORE addr of ptr var is on stack,
      %                              AFTER addr of thing pointed to is on stack
8759: PointerDeref:
8761:    [ oTypeSNodeType
8763:       | nPointerType :
8764:       | nUniversalPointerType :   #eCantDereference
8768:       | * :       #eNotPointer
8777:    ]
8777:    .tFetchP           % now addr on stack is addr of what we're pointing to
      
8779:    Node theType = oTypeSTop
8784:    oTypeSPop
8785:    oTypeSPush( oNodeGet( theType, qBaseType ) )
8799:    ;
      
      
      % The expr stack contains a value whose type is on top of the type stack.
      % Generate code to coerce the value to the type under it in the type stack
      % (pop the type stack, leaving only the desired type).
      % This is used for assignment.
      %
8799: CoerceType:
8801:    node_type nt = oTypeSNodeType
8806:    oTypeSPop
8807:    [ equal_node_type( nt, oTypeSNodeType )
8816:       | false :
               % Can we implicitly convert the value to the desired type?
8817:          [ oTypeSNodeType
8819:             | nIntegerType :
8820:                [ nt
8823:                   | nByteType :   .tCastBtoI  >>
8827:                   | * :
8832:                ]
8832:             | nByteType :
8834:                [ nt
8837:                   | nIntegerType :   .tCastItoB  >>
8841:                   | * :
8846:                ]
8846:             | nPointerType :
8848:                [ nt
8851:                   | nUniversalPointerType :  >>
8853:                   | nStrLitType :
8855:                      [ equal_node( oTypeSTop, PCharType )
8864:                         | true :
                                 % PChar := 'strlit' i.e. point at strlit[1]
8865:                            .tPushConstI  oEmitInt(1)  .tAddPI  >>
8876:                         | * :
8881:                      ]
8881:                   | * :
8888:                ]
8888:             | nUniversalPointerType :
8890:                [ nt
8893:                   | nPointerType :  >>
8895:                   | * :
8900:                ]
8900:             | nShortStringType :
8902:                [ nt
8905:                   | nStrLitType :  >>
8907:                   | nCharType :
                           % Store char as a temp ShortString.
8909:                      oTypeSPush( CharType )
8915:                      int tempOffset = @MoveIntoTempShortString
8921:                      oTypeSPop
8922:                      >>
8923:                   | * :
8930:                ]
8930:             | * :
8943:          ]
8943:          #eTypeMismatch
8945:       | * :
8950:    ];
      
      
      % Given a ShortString, StrLit, or Char on the expression stack
      % (and type on the type stack).  Move the value into a new temporary ShortString.
      % Leave that temp string and type on the stacks.
      % Also returns the offset of the temp string.
      %
8951: MoveIntoTempShortString >> int:
8953:    int tempOffset = oScopeAllocType( ShortStringType )
         % copy the value
8963:    [ oTypeSNodeType
8965:       | nShortStringType, nStrLitType :
8966:          .tPushAddrLocal  oEmitInt( tempOffset )
               % put temp addr under value addr
8974:          .tSwap
               % TO DO: we could just copy length + 1, but tCopy takes a fixed #bytes
8976:          .tCopy  oEmitInt( oNodeGetInt( ShortStringType, qSize ) )
8991:       | nCharType :
               % temp[0] = 1
8993:          .tPushAddrLocal  oEmitInt( tempOffset )
9001:          .tPushConstI  oEmitInt( 1 )
9009:          .tAssignB
               % temp[1] = value
9011:          .tPushAddrLocal  oEmitInt( add( tempOffset, 1 ) )
9026:          .tSwap
9028:          .tAssignB
9030:       | * :   #eTypeMismatch
9041:    ]
9041:    oTypeSPop
         % Leave the temp ShortString on the expr stack and type stack
9042:    .tPushAddrLocal  oEmitInt( tempOffset )
9050:    oTypeSPush( ShortStringType )
9056:    >> tempOffset;
      
      
      % Top of expr stack / type stack is ShortString B.
      % Under it is ShortString A.
      % Change A to append the contents of B to it (truncating if necessary).
      % Removes both A and B from the expr stack / type stack.
      %
9060: ShortStringAppendShortString:
         % TO DO: ideally I would do this directly with tcode.  But I think I need some more
         % enhancements for that to work well.   Meanwhile, generate a call to a method.
         % For the moment, I'll implement the method in Pascal, in the mysystem unit.
9062:    .tAllocActuals  oEmitInt( 16 )
9070:    .tPushAddrActual  oEmitInt( 8 )  .tSwap  .tAssignP
9082:    .tPushAddrActual  oEmitInt( 0 )  .tSwap  .tAssignP
9094:    .tCall   @EmitValue( System_ShortStringAppendShortString )
         % TO DO: Ideally I would leave A on the expr stack / type stack.
         %  But I can't really do that without dup, which I hesitate to add.
         %  I'll have the caller push A again themselves.
9103:    .tFreeActuals  oEmitInt( 16 )
9111:    oTypeSPop
9112:    oTypeSPop
9114:    ;
      
      % Top of expr stack / type stack is Char B.
      % Under it is ShortString A.
      % Change A to append char B to it (truncating if necessary).
      % Removes both A and B from the expr stack / type stack.
      %
9114: ShortStringAppendChar:
         % Note at the moment I don't align params
9116:    .tAllocActuals  oEmitInt( 12 )
9124:    .tPushAddrActual  oEmitInt( 8 )  .tSwap  .tAssignI
9136:    .tPushAddrActual  oEmitInt( 0 )  .tSwap  .tAssignP
9148:    .tCall  @EmitValue( System_ShortStringAppendChar )
9157:    .tFreeActuals  oEmitInt( 12 )
9165:    oTypeSPop
9166:    oTypeSPop
9168:    ;
      
      % Expr stack has ShortString A, and ShortString B above it.
      % Type stack has just the type of ShortString A.
      % Replaces the expr stack with the integer value of string comparison:
      % -1 if A < B,  0 if A = B,  1 if A > B
      % Leaves Integer on the type stack.
      %
9168: ShortStringCmp:
9170:    .tAllocActuals  oEmitInt( 24 )
9178:    .tPushAddrActual  oEmitInt( 8 )  .tSwap  .tAssignP
9190:    .tPushAddrActual  oEmitInt( 0 )  .tSwap  .tAssignP
9202:    int tempOffset = oScopeAllocType( IntegerType )
9212:    .tPushAddrActual  oEmitInt( 16 )  .tPushAddrLocal  oEmitInt( tempOffset )  .tAssignP
9230:    .tCall  @EmitValue( System_ShortStringCmp )
9239:    .tPushLocalI  oEmitInt( tempOffset )
9247:    .tFreeActuals  oEmitInt( 24 )
9255:    oTypeSPop
9256:    oTypeSPush( IntegerType )
9263:    ;
      
      
      % Called on first use of an extern method
      %
9263: DefineExternLabel( Node method ):
         % The extern name might be given explicitly, otherwise the pascal method name.
9265:    int strAddr
9265:    String externalName = oNodeGetString( method, qExternalName )
9278:    [ equal_string( externalName, stringNull )
9288:       | true :
9289:          strAddr = oStringAllocLit( ID_STRING( oNodeGetInt( method, qIdent ) ) )
9310:       | false :
9312:          strAddr = oStringAllocLit( externalName )
9322:    ]
9330:    .tLabelExtern  @EmitValue( method )  oEmitInt( strAddr )
9346:    ;
      
      
      % Parse a call, given an nProc or nFunc for the just-accepted identifier.
      % If a func, this will also generate the code to push the return value on the expr stack,
      % and push the return type on the type stack.
      %
9346: Call( Node method ):
      
         % Prior to first call, issue extern label for a called method.
         % I don't want to issue .tLabelExtern for unused methods, that seems inefficient.
9348:    [ oNodeGetBoolean( method, qExternal )
9358:       | true :
9359:          [ oNodeGetBoolean( method, qUsed )
9369:             | false :
                     % define the extern label on first use
9370:                @DefineExternLabel( method )
9377:             | * :
9382:          ]
9382:      | * :
9387:    ]
9387:    oNodeSetBoolean( method, qUsed, true )
      
         % If the method has a cdecl modifier, the back end will need to use the native
         % calling convention, instead of my own.  But, the convention varies by platform,
         % so the front end won't assume what it needs.  I'll still generate the normal tcode
         % that copies values into actuals space on the stack.
         % However, to help the back end, I will at least use a different instruction for the
         % allocation of the actuals space, and for the actual call.
         %
         % p.s. I only support cdecl on external methods, because I don't have a way
         % to let my own Pascal methods read params passed in with the cdecl calling convention.
         %
9399:    boolean cdecl = oNodeGetBoolean( method, qCdecl )
      
         % If this is a function, we will allocate a temporary
         % in the current scope, to hold the result value.
         % And pass a pointer to that temporary as an extra parameter.
9412:    Node resultType
9412:    int tempOffset
      
9412:    boolean isFunc = equal_node_type( oNodeType( method ), nFunc )
      
9429:    [ isFunc
9432:       | true :
9433:          resultType = oNodeGet( method, qType )
9446:          tempOffset = oScopeAllocType( resultType )
               % TO DO: we could manage temp allocation, so temp space can be reused
               %        by different code branches.
9456:       | * :
9461:    ]
         
      
9461:    Node paramScope = oNodeGet( method, qParams )
9474:    int actualsSize = oNodeGetInt( paramScope, qSize )
9487:    [ cdecl
9490:       | true : .tAllocActualsCdecl  oEmitInt( actualsSize )
9499:       | false :  .tAllocActuals  oEmitInt( actualsSize )
9509:    ]
      
         % If method is nested, it takes a hidden first parameter:
         % a pointer to the frame of the static scope in which the method is declared.
         % The location of a scope's frame is equivalent to offset 0 in the scope's locals space
         % (since local offsets are relative to the scope's frame pointer).
         %
         % The nested method may be in a higher scope (upLevels > 1),
         % or a sibling of the method we're in (upLevels = 1),
         % or an immediate child of the current method (upLevels = 0).
         %
         % To understand the upLevels computation, remember that a method's declaration
         % and its contents (variables, nested functions, and body statement)
         % are in two different scopes.
      
9517:    [ greater( @DeclLevel( method ), 0 )
9532:       | true :
9533:          .tPushAddrActual  oEmitInt( 0 )    % hidden param is at param offset 0
9541:          .tPushAddrUpLocal  oEmitInt( @DeclUpLevels( method ) )  oEmitInt( 0 )
9560:          .tAssignP
9562:       | * :
9567:    ]
      
      
9567:    NodeIter paramIter = oNodeGetIter( paramScope, qDecls )
9580:    Node param = oNodeIterValue( paramIter )
9590:    [
9590:       | '(' :
            
9592:          {
9592:             [ oNodeNull( param )
9599:                | true : >
9602:                | * :
9607:             ]
      
9607:             int offset = oNodeGetInt( param, qValue )
      
                  % Assign actual value to spot in actuals space
9620:             .tPushAddrActual oEmitInt( offset )
9628:             oTypeSPush( oNodeGet( param, qType ) )
      
9641:             [ oNodeGetBoolean( param, qInOut )
9651:                | true :   % A VAR param.
                                % The actual is a pointer to the value.
                                % The type on the type stack (pushed above) is for the pointed-to value.
      
9652:                           @LValueExpr( true )
                                % Addr of the referenced variable is on the expr stack,
                                % type of the variable is on the type stack.
      
                                % Match types more exactly. It's not sufficient to be assign compatible
                                % since the method will be assigning to the actual using the param type.
                                % Maybe something like type contents must match, incl subrange bounds.
9659:                           @MatchTypes
      
9661:                           .tAssignP
      
9663:                | false :  @Expr
9667:                           @CoerceType
                                
                                % Assign to offset in actuals space
      
9669:                           [ oTypeSNodeType
9671:                              | nIntegerType, nEnumType : .tAssignI
9674:                              | nBooleanType, nByteType, nCharType :  .tAssignB
9678:                              | nFileType :   #eNotImplemented
9682:                              | nPointerType, nUniversalPointerType :  .tAssignP
9686:                              | nArrayType, nRecordType, nShortStringType :
                                       % compound types: copy value into actuals space
9688:                                  int size = oNodeGetInt( oTypeSTop, qSize )
9700:                                  .tCopy  oEmitInt( size )    % multi-word copy
9708:                           ]
9734:             ]
9742:             oTypeSPop
      
9743:             oNodeIterNext( paramIter )
9749:             param = oNodeIterValue( paramIter )
9759:             [ oNodeNull( param )
9766:                | true :  >
9769:                | false :
9771:             ]
      
9779:             ','
9781:          }
      
9783:          ')'
      
9785:       | * :
9790:    ]
      
9790:    [ oNodeNull( param )
9797:       | false :    #eMissingParameter
9800:       | * :
9805:    ]
      
9805:    [ isFunc
9808:       | true :
               % Pass result temp as an additional VAR parameter.
9809:          .tPushAddrActual oEmitInt( oNodeGetInt( method, qResultOffset ) )
9824:          .tPushAddrLocal  oEmitInt( tempOffset )
9832:          .tAssignP
9834:       | * :
9839:    ]
      
9839:    [ cdecl
9842:       | true :
9843:          .tCallCdecl  @EmitValue( method )
9852:       | false :
9854:          .tCall   @EmitValue( method )
9863:    ]
      
9871:    [ isFunc
9874:       | true :
               % push return value from temp
9875:          oTypeSPush( resultType )
      
9881:          [ oTypeSNodeType
9883:             | nIntegerType, nEnumType :   .tPushLocalI  oEmitInt( tempOffset )
9892:             | nBooleanType, nByteType, nCharType :   .tPushLocalB  oEmitInt( tempOffset )
9902:             | nFileType :  #eNotImplemented
9906:             | nPointerType, nUniversalPointerType :   .tPushLocalP  oEmitInt( tempOffset )
9916:             | nArrayType, nRecordType, nShortStringType :   % compound type: push address
9918:                                .tPushAddrLocal  oEmitInt( tempOffset )
9926:          ]
9952:       | * :
9957:    ]
         
9957:    .tFreeActuals  oEmitInt( actualsSize )
9966:    ;
      
      
      % Parse a call to a built-in function, identified by the just-accepted identifier.
      % This will also generate the code to push the return value on the expr stack,
      % and push the return type on the type stack.
      %
9966: CallBuiltInFunc( Node method ):
      
         % Ord(x)
9968:    [ oNodeEqual( method, BuiltIn_Ord )
9978:       | true :
               % parameter is any scalar type (including boolean, enum, char)
               % result is integer
9979:          '('
9981:          @Expr
9983:          [ oTypeSNodeType
9985:             | nIntegerType, nEnumType :
9986:             | nBooleanType, nByteType, nCharType :  .tCastBtoI
9990:             | * :  #eTypeMismatch
10005:          ]
10005:          oTypeSPop
10006:          oTypeSPush( IntegerType )
10012:          ')'
10014:          >>
10015:       | * :
10020:    ]
      
         % Chr(x)
10020:    [ oNodeEqual( method, BuiltIn_Chr )
10030:       | true :
               % parameter is integer
               % result is char
10031:          '('
10033:          @Expr
10035:          [ oTypeSNodeType
10037:             | nIntegerType :    .tCastItoB
10040:             | nByteType :
10042:             | * :  #eTypeMismatch
10051:          ]
10051:          oTypeSPop
10052:          oTypeSPush( CharType )
10058:          ')'
10060:          >>
10061:       | * :
10066:    ]
      
         % Pred(x)
10066:    [ oNodeEqual( method, BuiltIn_Pred )
10076:       | true :
               % parameter is any enum type, as long as it has values 0..N-1
               % result is the same enum type
10077:          '('
10079:          @Expr
10081:          [ oTypeSNodeType
10083:             | nEnumType :
                     % TO DO: does this skip past type aliases?
                     % TO DO: what if using pred/succ on a subrange type?
10084:                [ oNodeGetBoolean( oTypeSTop, qHasGap )
10093:                   | true :   #eCantUsePredSuccOnEnumWithValueGaps
10096:                   | * :
10101:                ]
10101:             | * :  #eTypeMismatch
10108:          ]
10108:          .tDecI
10110:          ')'
10112:          >>
10113:       | * :
10118:    ]
      
         % Succ(x)
10118:    [ oNodeEqual( method, BuiltIn_Succ )
10128:       | true :
               % parameter is any enum type, as long as it has values 0..N-1
               % result is the same enum type
10129:          '('
10131:          @Expr
10133:          [ oTypeSNodeType
10135:             | nEnumType :
                     % TO DO: does this skip past type aliases?
                     % TO DO: what if using pred/succ on a subrange type?
10136:                [ oNodeGetBoolean( oTypeSTop, qHasGap )
10145:                   | true :   #eCantUsePredSuccOnEnumWithValueGaps
10148:                   | * :
10153:                ]
10153:             | * :  #eTypeMismatch
10160:          ]
10160:          .tIncI
10162:          ')'
10164:          >>
10165:       | * :
10170:    ]
      
10170:    #eNotImplemented
10173:    ;
      
      
      % ------------------------------ Statements -----------------------------
      
10173: Statement:
10175:    [
10175:       | pWriteln :     @WritelnStmt
10179:       | pWrite :       @WriteStmt
10183:       | pReadln :      @ReadlnStmt
10187:       | pRead :        @ReadStmt
10191:       | pIf :          @IfStmt
10195:       | pWhile :       @WhileStmt
10199:       | pFor :         @ForStmt
10203:       | pRepeat :      @RepeatStmt
10207:       | pBreak :       @BreakStmt
10211:       | pContinue :    @ContinueStmt
10215:       | pBegin :       @BeginStmt
10219:       | pIdent :       @LabelOrAssignOrCallStmt
10223:       | pCase :        @CaseStmt
10227:       | pGoto :        @GotoStmt
10231:       | pIntLit :      % should be an integer label
10233:                        oChangeIntLitToLabelIdent
10234:                        @LabelOrAssignOrCallStmt
10236:       | * :            % null statement : don't accept any tokens
10269:    ];
      
      
10270: LabelOrAssignOrCallStmt:
10272:    Node decl = oScopeFindRequire
10277:    @ResolveUnitRef( decl )
10284:    [ oNodeType( decl )
10291:       | nLabel :                          @LabelDefinition( decl )
10299:                                           @Statement
10301:       | nProc :                           @Call( decl )
10310:       | nGlobalVar, nLocalVar, nParam :   @AssignStmt( decl )
10319:       | nFunc :                           @AssignResultStmt( decl )
10328:       | * :                               #eBadStatement
10345:    ];
      
      
      % Parse a "label:" prefix in front of a statement.
      %
10346: LabelDefinition( Node decl ):
10348:    [ oNodeGetBoolean( decl, qDefined )
10358:       | true :  #eAlreadyDefined
10361:       | * :
10366:    ]
10366:    .tLabel  oEmitLabel( oNodeGetLabel( decl, qValue ) )
10381:    oNodeSetBoolean( decl, qDefined, true )
10393:    ':'
10396:    ;
      
      
      % Given decl, the just-accepted first identifier on the left hand side.
      %
10396: AssignStmt( Node decl ):
      
10398:    @LValueVar( decl, true )
10408:    ':=' 
10410:    @Expr
10412:    @CoerceType
10414:    @Assign
10417:    ;
      
      
      % Performs a raw assignment.
      % Given lvalue 2nd on stack, and expr value top of stack (already coerced to the lvalue type),
      % and type of both of these on the type stack,
      % perform the assignment and pop the type off the type stack.
      %
10417: Assign:
10419:    [ oTypeSNodeType
10421:       | nIntegerType, nEnumType :  .tAssignI
10424:       | nBooleanType, nByteType, nCharType :  .tAssignB
10428:       | nFileType :   #eNotImplemented
10432:       | nPointerType, nUniversalPointerType :  .tAssignP
            % compound var assigns; addrs of src, dest on stack
10436:       | nArrayType, nRecordType, nShortStringType :
                % TO DO: for ShortString, allow destination to be smaller capacity,
                % and truncate the copied value/length.
10438:           int size = oNodeGetInt( oTypeSTop, qSize )
10450:           .tCopy  oEmitInt( size )    % multi-word copy
10458:    ]
10484:    oTypeSPop
10486:    ;
      
      % Given nFunc for the just-accepted identifier on the left hand side.
      % Parse an assignment that represents assignment of the function result.
      %
10486: AssignResultStmt( Node funcDecl ):
         % Only allowed to assign the result of the immediately enclosing function, I think.
10488:    [ oNodeEqual( oNodeGet( funcDecl, qChildScope ), oScopeCurrent )
10504:       | false :   #eNotCurrentFunction
10507:       | * :
10512:    ]
      
         % Result value is stored in the caller's space, via a hidden VAR parameter.
10512:    .tPushParamP  oEmitInt( oNodeGetInt( funcDecl, qResultOffset ) )
10527:    oTypeSPush( oNodeGet( funcDecl, qType ) )
      
10540:    ':='
10542:    @Expr
10544:    @CoerceType
10546:    [ oTypeSNodeType
10548:       | nIntegerType, nEnumType : .tAssignI
10551:       | nBooleanType, nByteType, nCharType :  .tAssignB
10555:       | nFileType :   #eNotImplemented
10559:       | nPointerType, nUniversalPointerType :  .tAssignP
            % compound var assigns; addrs of src, dest on stack
10563:       | nArrayType, nRecordType, nShortStringType :
10565:           int size = oNodeGetInt( oTypeSTop, qSize )
10577:           .tCopy  oEmitInt( size )    % multi-word copy
10585:    ]
10611:    oTypeSPop
10613:    ;
      
      
      
      % Parse an lvalue expression, from scratch.
      % This is an expression that may appear on the left side of an assignment.
      % Leaves the address of the value on the expr stack,
      % and the type of the value at that address on the type stack.
      % If writeable is false, the expression won't be written to, so may access a
      % typed const.
      %
10613: LValueExpr( boolean writeable ):
         % At the moment, all lvalue expressions start with a variable name.
         % I think there can also be typecasts, not supported yet.  Check standard syntax.
10615:    pIdent
10617:    Node decl = oScopeFindRequire
10622:    @ResolveUnitRef( decl )
10629:    [ oNodeType( decl )
10636:       | nGlobalVar, nLocalVar, nParam, nTypedConst :
10637:       | * :  #eNotVar
10650:    ]
10650:    @LValueVar( decl, writeable )
10661:    ;
      
      
      % Parse an lvalue expression (e.g. left side of an assign statement)
      % that starts with the just-accepted identifier indicated by the given decl.
      % Leaves the lvalue address on the expression stack,
      % and the type of the value at that address on the type stack.
      %
10661: LValueVar( Node decl, boolean writeable ):
10663:    [ oNodeType( decl )
10670:       | nGlobalVar :   .tPushAddrGlobal @EmitValue( decl )
10680:       | nLocalVar :    .tPushAddrLocal @EmitValue( decl )
10691:       | nParam :
10693:          [ oNodeGetBoolean( decl, qInOut )
10703:             | true :   % VAR param points to variable.  No dereference.
10704:                        .tPushParamP @EmitValue( decl )
10713:             | * :      .tPushAddrParam @EmitValue( decl )
10727:          ]
10727:       | nTypedConst :
10729:          [ writeable
10732:             | false :  .tPushAddrGlobal @EmitValue( decl )                       
10742:             | * :      #eNotVar
10749:          ]
10749:       | * :            #eNotVar
10762:    ]
      
10762:    oTypeSPush( oNodeGet( decl, qType ) )
      
         % handle subscripts, if any.
         % There is one case that I'm not fitting into the pattern nicely, so need to
         % check for specially here:  if lvalue var is a pointer variable, and is
         % followed by [index], we need to dereference the pointer variable before applying
         % the index.  This is different from handling of [index] on an rvalue expression.
         % Right now I have LValueIndexes working for both lvalue and rvalue (composite types)
         % so can't easily add this behavior in there.
         % TO DO: probably I need separate rules LValueIndexes and RValueIndexes.
         %    This might also explain my confusion about handling of deref operator in LValueIndexes vs rvalue expr,
         %    and having separate rules might clear that up better.
      
10775:    [ oTypeSNodeType
10777:       | nPointerType :
10778:          [
10778:             | '[' :
                     % dereference the pointer var first
10780:                .tFetchP
10782:                @PointerArraySubscript
10784:             | * :
10789:          ]
10789:       | * :
10794:    ]
         % additional subscripts, if any
10794:    @LValueIndexes
10797:    ;
      
      
10797: IncVar( Node decl ):
10799:    @LValueVar( decl, true )
10809:    @RequireIntPop
10811:    @VarExpr( decl )
10818:    oTypeSPop
10819:    .tIncI
10821:    .tAssignI;
      
10824: DecVar( Node decl ):
10826:    @LValueVar( decl, true )
10836:    @RequireIntPop
10838:    @VarExpr( decl )
10845:    oTypeSPop
10846:    .tDecI
10848:    .tAssignI;
      
      
10851: IfStmt:
10853:    Label falseLabel = labelNull
      
10859:    @BooleanExprControlFlow( falseLabel )
10866:    pThen
10868:    @Statement
10870:    [
10870:       | pElse :
10872:          Label doneLabel = oLabelNew
      
10877:          .tJump  oEmitLabel( doneLabel )
10885:          .tLabel oEmitLabel( falseLabel )
10893:          @Statement
10895:          .tLabel oEmitLabel( doneLabel )
      
10903:       | * :
10908:          .tLabel oEmitLabel( falseLabel )
10916:    ];
      
      
10917: ForStmt:
10919:    pIdent
      
10921:    Node decl = oScopeFindRequire
         % TO DO: disallow use of a compound variable field.
         %        Could do that by disallowing use of LValueIndexes,
         %        or by double-checking the decl's qType here.
         % TO DO: I think I read somewhere that the variable must be in current scope.
10926:    @LValueVar( decl, true )
10936:    @RequireIntPop
      
10938:    ':='
      
10940:    @Expr
10942:    @RequireIntPop
10944:    .tAssignI
      
10946:    Label breakLabel = oLabelNew
      
10951:    Label checkLabel = oLabelNew
10956:    .tJump  oEmitLabel( checkLabel )
      
10964:    Label continueLabel = oLabelNew
10969:    .tLabel  oEmitLabel( continueLabel )
10977:    [
10977:       | pTo :
10979:          @IncVar( decl )
10986:          .tLabel  oEmitLabel( checkLabel )
10994:          @VarExpr( decl )  oTypeSPop
11002:          @Expr
11004:          @RequireIntPop
11006:          .tGreaterI
11008:          .tJumpTrue  oEmitLabel( breakLabel )
11016:       | pDownto :
11018:          @DecVar( decl )
11025:          .tLabel  oEmitLabel( checkLabel )
11033:          @VarExpr( decl )  oTypeSPop
11041:          @Expr
11043:          @RequireIntPop
11045:          .tLessI
11047:          .tJumpTrue  oEmitLabel( breakLabel )
11055:    ]
11063:    oLoopPush( continueLabel, breakLabel )
11072:    pDo
11074:    @Statement
11076:    .tJump  oEmitLabel( continueLabel )
11084:    .tLabel  oEmitLabel( breakLabel )
11092:    oLoopPop;
      
      
11094: RepeatStmt:
11096:    Label continueLabel = oLabelNew
11101:    .tLabel  oEmitLabel( continueLabel )
      
11109:    Label breakLabel = oLabelNew
      
11114:    oLoopPush( continueLabel, breakLabel )
11123:    @Statement
11125:    {[
11125:       | ';' :
11127:          @Statement
11129:       | pUntil :
11131:          Label falseLabel
11131:          @BooleanExprControlFlow( falseLabel )
11138:          .tLabelAlias  oEmitLabel( falseLabel )  oEmitLabel( continueLabel )
11152:          >
11154:    ]}
11164:    .tLabel  oEmitLabel( breakLabel )
11172:    oLoopPop;
      
      
11174: WhileStmt:
11176:    Label continueLabel = oLabelNew
11181:    .tLabel  oEmitLabel( continueLabel )
      
11189:    Label breakLabel
11189:    @BooleanExprControlFlow( breakLabel )
      
11196:    oLoopPush( continueLabel, breakLabel )
11205:    pDo
11207:    @Statement
11209:    .tJump  oEmitLabel( continueLabel )
11217:    .tLabel  oEmitLabel( breakLabel )
11225:    oLoopPop;
      
      
11227: ContinueStmt:                     % NOTE, for repeat..until, skips test (??)
11229:    [ equal_label( oLoopContinueLabel, labelNull )
11238:       | true :
11239:          #eNotInALoop
11241:       | false :
11243:          .tJump  oEmitLabel( oLoopContinueLabel )
11250:    ];
      
      
11259: BreakStmt:
11261:    [ equal_label( oLoopBreakLabel, labelNull )
11270:       | true :
11271:          #eNotInALoop
11273:       | false :
11275:          .tJump  oEmitLabel( oLoopBreakLabel )
11282:    ];
      
      
11291: CaseStmt:
11293:    Code tableCode = oCodeNew
11298:    Label tableLabel = oLabelNew
11303:    Label doneLabel = oLabelNew
11308:    Label otherwiseLabel = doneLabel
      
11314:    @Expr
         % Leave the expr type on the type stack throughout case statement
11316:    [ oTypeSNodeType
11318:       | nBooleanType, nByteType, nCharType :   .tJumpCaseB  oEmitLabel( tableLabel )
11327:       | nIntegerType, nEnumType :              .tJumpCaseI  oEmitLabel( tableLabel )
11337:       | nShortStringType, nStrLitType :        #eNotImplemented
11341:       | * :     #eNotAllowed
11360:    ]
11360:    pOf
      
11362:    {
11362:       [
11362:          | pOtherwise, pElse :
11364:             otherwiseLabel = oLabelNew
11369:             .tLabel  oEmitLabel( otherwiseLabel )
      
                  % A bit tricky:
                  % The otherwise clause allows multiple statements (unlike other cases).
                  % ';' might be separating statements in the otherwise clause,
                  % or might be an optional trailing ; after the last statement.
                  % I have to watch for End to know when the statements stop.
                  % (Note, the otherwise clause is the last part of the case statement.)
11377:             {[
11377:                | pEnd :  >
11381:                | * :
11386:                   @Statement
11388:                   [
11388:                      | ';' :
11390:                      | * :   pEnd  >
11399:                   ]
11399:             ]}
11401:             >
      
11403:          | pEnd :
                  % Reached end with no otherwise clause
11405:             >
      
11407:          | * :
11416:             Label caseLabel = oLabelNew
11421:             oCodePush( tableCode )
11427:             {
11427:                @ConstExpr
11429:                @ConstMatchTypes
11431:                int val = oValueTop
11436:                oValuePop
11437:                [
11437:                   | '..' :  @ConstExpr
11441:                             @ConstMatchTypes
11443:                             int highval = oValueTop
11448:                             oValuePop
11449:                             .tCaseRange  oEmitInt( val )  oEmitInt( highval )  oEmitLabel( caseLabel )
11469:                   | * :     .tCase  oEmitInt( val )  oEmitLabel( caseLabel )
11488:                ]
11488:                [
11488:                   | ',' :
11490:                   | * :  >
11497:                ]
11497:             }
11499:             oCodePop
11500:             ':'
11502:             .tLabel  oEmitLabel( caseLabel )
11510:             @Statement
11512:             .tJump  oEmitLabel( doneLabel )
                  % Swallow optional trailing ';'
11520:             [
11520:                | ';' :
11522:                | * :
11527:             ]
                  
11527:       ]
         
11527:    }
      
11529:    .tLabel  oEmitLabel( tableLabel )
11537:    oEmitCode( tableCode )
11543:    .tCaseEnd  oEmitLabel( otherwiseLabel )
11551:    .tLabel  oEmitLabel( doneLabel )
11559:    oTypeSPop
11561:    ;
      
      
11561: GotoStmt:
11563:    [
11563:       | pIdent :
11565:       | pIntLit :
               % Replace token with identifier "_label_<intlit>"
11567:          oChangeIntLitToLabelIdent
11568:    ]
      
         % Some pascals have rules about where you can jump (to a sibling statement or
         % higher level statement in the block, but not into a lower lower level statement.)
         % fpc just says "jumping into a nested statement can have strange effects."
         % I'm going to follow that and not prohibit any goto, as long as it's in the same block.
      
         % Label must be declared in the same block (same scope) it is used.
         % Some pascals allow non-local goto, but we do not.
         % That would require more tracking of dynamic scope, to unwind stack.
         % Note: in main program statement, this relies on the temporaries scope extending
         %  the main scope (where a label declaration would occur).
11576:    Node decl = oScopeFindRequireInScope( oScopeCurrent )
11585:    oNodeSetBoolean( decl, qUsed, true )
11597:    .tJump  oEmitLabel( oNodeGetLabel( decl, qValue ) )
11613:    ;
      
      
11613: BeginStmt:
11615:    @Statement
11617:    {[
11617:       | ';' :   @Statement
11621:       | pEnd :  >
11625:    ]};
      
      
11636: WritelnStmt:
11638:    @WriteStmt
11640:    .tWriteCR;
      
      
11643: WriteStmt:
11645:    [
11645:       | '(' :
11647:          {
11647:             @Expr
11649:             [ oTypeSNodeType
11651:                | nIntegerType :             .tWriteI
11654:                | nBooleanType :             .tWriteBool
11658:                | nByteType :                .tCastBtoI  .tWriteI
11664:                | nCharType :                .tWriteChar
11668:                | nShortStringType, nStrLitType :   .tWriteShortStr
11672:                | nFileType :                #eNotImplemented
11676:                | nEnumType :
                        % write name via table lookup
11678:                   .tPushAddrGlobal  oEmitInt( oNodeGetInt( oTypeSTop, qNameTable ) )
11692:                   .tWriteEnum
11694:                | nPointerType :
11696:                   [ equal_node( oTypeSTop, PCharType )
11705:                      | true :               .tWritePChar
11708:                      | * :                  .tWriteP
11715:                   ]
11715:                | nUniversalPointerType :    .tWriteP
11719:                | * :                        #eNotAllowed
11744:             ]
11744:             oTypeSPop
11745:             [
11745:                | ')' : >
11749:                | ',' :
11751:             ]
11759:          }
11761:       | * :
11766:    ];
      
      
11767: ReadlnStmt:      % ***
         % TO DO
11770:    ;
      
11770: ReadStmt:
         % TO DO
11773:    ;
      
      % -------------------------------- Utilities -------------------------------
      
      % Return the static scope level of the current scope
      %
11773: ScopeLevel >> int:
11775:    >> oNodeGetInt( oScopeCurrent, qLevel );
      
      % Return the static scope level of the given declaration
      %
11785: DeclLevel( Node decl ) >> int:
11787:    >> oNodeGetInt( oNodeGet( decl, qParentScope ), qLevel );
         
      
      % How many levels higher is the given declaration from the current scope?
      %
11805: DeclUpLevels( Node decl ) >> int:
11807:    >> subtract( @ScopeLevel, @DeclLevel( decl ) );
      
      
      % Require that the top two types on the type stack are matching (ignoring subranges).
      % Pop one of them, leaving only one.
      %
11823: MatchTypes:
11825:    node_type nt = oTypeSNodeType
11830:    oTypeSPop
11831:    [ equal_node_type( nt, oTypeSNodeType )
11840:       | false :
               % Some implicit conversion is allowed even here
11841:          [ oTypeSNodeType
11843:             | nPointerType :
11844:                [ nt
11847:                   | nUniversalPointerType :  >>
11849:                   | * :
11854:                ]
11854:             | nUniversalPointerType :
11856:                [ nt
11859:                   | nPointerType :  >>
11861:                   | * :
11866:                ]
11866:             | * :
11873:          ]
11873:          #eTypeMismatch
11875:       | * :
11880:    ];
      
      
      % Require that the top type on the type stack is integer (ignoring subranges).
      % Pop it.
      %
11881: RequireIntPop:
11883:    [ oTypeSNodeType
11885:       | nIntegerType :
11886:       | * :          #eNotInteger
11893:    ]
11893:    oTypeSPop;
      
11895: RequireInt:
11897:    [ oTypeSNodeType
11899:       | nIntegerType :
11900:       | * :          #eNotInteger
11907:    ];
      
      
      % Convert the top value to integer (if it isn't already).
      % It must be implicitly convertable to integer.
      % Pop the type stack.
      %
11908: PromoteToIntPop:
11910:    [ oTypeSNodeType
11912:       | nIntegerType :
11913:       | nByteType :        .tCastBtoI
11917:       | * :                #eNotInteger
11926:    ]
11926:    oTypeSPop;
      
      % Convert the top value to integer (if it isn't already).
      % It must be implicitly convertable to integer.
      % Leave integer on the type stack.
      %
11928: PromoteToInt:
11930:    [ oTypeSNodeType
11932:       | nIntegerType :
11933:       | nByteType :        .tCastBtoI
11937:                            oTypeSPop
11938:                            oTypeSPush( IntegerType )
11944:       | * :                #eNotInteger
11953:    ];
      
      
      % If the top value is implicitly convertable to integer, do so.
      % Otherwise leave it as-is.
      %
11954: PromoteToIntOptional:
11956:    [ oTypeSNodeType
11958:       | nByteType :        .tCastBtoI
11961:                            oTypeSPop
11962:                            oTypeSPush( IntegerType )
11968:       | * :
11973:    ];
      
      
      
      
11974: RequireBoolPop:
11976:    [ oTypeSNodeType
11978:       | nBooleanType :
11979:       | * :          #eNotBoolean
11986:    ]
11986:    oTypeSPop;
      
11988: RequireBool:
11990:    [ oTypeSNodeType
11992:       | nBooleanType :
11993:       | * :          #eNotBoolean
12000:    ];
      
      
      % Create and return a new nType of the given node_type, adding it to the type table.
      %
12001: newType( node_type nt, int size ) >> Node:
12003:   Node node = oNodeNew( nt )
12013:   oNodeSetInt( node, qSize, size )
12025:   oTypeAdd( node )
12031:   >> node
12035:   ;
      
      
      % Create and return a new nIdent of the given node_type, with the given ident id.
      % Does not add it to any scope.
      %
12035: newIdent( node_type nt, int id ) >> Node:
12037:   Node t = oNodeNew( nt )
12047:   oNodeSetInt( t, qIdent, id )
12059:   >> t
12063:   ;
      
      
      % Return an nType representing a pointer to the given type.
      % (Creates a new type if necessary.)
      %
12063: PointerTypeTo( Node theType ) >> Node:
12065:    Node ptrType = oNodeGet( theType, qPointerType )
12078:    [ oNodeNull( ptrType )
12085:       | true :
12086:          ptrType = oNodeNew( nPointerType )
12096:          oNodeSet( ptrType, qBaseType, theType )
12108:          oNodeSetInt( ptrType, qSize, 8 )
12120:          oTypeAdd( ptrType )
12126:          oNodeSet( theType, qPointerType, ptrType )
12138:       | * :
12143:    ]
12143:    >> ptrType;
      
      
      % Return the low value of an ordinal type
      %
12147: OrdinalLow( Node theType ) >> int:
12149:    [ oNodeType( theType )
12156:       | nIntegerType :  >> oMININT
12159:       | nBooleanType :  >> 0
12164:       | nCharType :     >> 0
12169:       | nEnumType :
12171:          Node enumScope = oNodeGet( theType, qScope )
12184:          Node first = oNodeIterValue( oNodeGetIter( enumScope, qDecls ) )
12201:          >> oNodeGetInt( first, qValue )
12211:       | nSubrangeType : >> oNodeGetInt( theType, qLow )
12223:       | * :             #eNotOrdinalType
12238:                         >> 0
12241:    ];
      
      
      % Return the high value of an ordinal type
      %
12242: OrdinalHigh( Node theType ) >> int:
12244:    [ oNodeType( theType )
12251:       | nIntegerType :  >> oMAXINT
12254:       | nBooleanType :  >> 1
12259:       | nCharType :     >> 255
12264:       | nEnumType :
12266:          Node enumScope = oNodeGet( theType, qScope )
12279:          Node last = oNodeIterValue( oNodeGetIterLast( enumScope, qDecls ) )
12296:          >> oNodeGetInt( last, qValue )
12306:       | nSubrangeType : >> oNodeGetInt( theType, qHigh )
12318:       | * :             #eNotOrdinalType
12333:                         >> 0
12336:    ];
      
      
      % Emit the value in a declaration.
      % For a constant integer, this is the constant value.
      % For a global variable, this is the global address.
      % For a local variable, this is the local address relative to the call stack frame.
      %
12337: EmitValue( Node decl ):
12339:     oEmitInt( oNodeGetInt( decl, qValue ));
      
      
12353: DeclareBuiltInFunc( int id ) >> Node:
12355:    Node decl = @newIdent( nBuiltInFunc, id )
12369:    oScopeDeclare( decl )
12375:    >> decl;
      
      
12379: installBuiltIns:
      
         % "mysystem" is the name of a unit that will be available everywhere.
         % Add its name to the id table so we can easily spot the name later.
12381:    mysystemId = oId_mysystem
      
         % install built-in types
12386:    FileType = @newType( nFileType, 4 )
12400:    IntegerType = @newType( nIntegerType, 4 )
12414:    BooleanType = @newType( nBooleanType, 1 )
12428:    BooleanFlowType = @newType( nBooleanFlowType, 1 )
12442:    CharType = @newType( nCharType, 1 )
12456:    PCharType = @PointerTypeTo( CharType )
12467:    ByteType = @newType( nByteType, 1 )
         % Universal pointer says base type Byte, but this is only for the sake of
         % pointer arithmetic.  It doesn't matter otherwise, because this type cannot be dereferened.
12481:    UniversalPointerType = @newType( nUniversalPointerType, 8 )
12495:    oNodeSet( UniversalPointerType, qBaseType, ByteType )
         % StrLitType is stored with both a length byte and null termination, so it can be assigned to
         % both a ShortString and a PChar.  StrLits longer than 255 characters appear truncated when
         % referenced as a ShortString, but not when referenced as a PChar.
12507:    StrLitType = @newType( nStrLitType, 256 )
         % ShortString is the original Pascal string type: an array of characters, not null-terminated,
         % with the first byte recording the current length.
         % The default ShortString type has capacity for 255 characters.  The user may define
         % additional ShortString types with smaller capacities.
         % The first character can be accessed as myString[1].
12521:    ShortStringType = @newType( nShortStringType, 256 )
12535:    oNodeSetInt( ShortStringType, qCapacity, 255 )
      
         % Declare those type identifiers.
         % SSL doesn't support strings, so need help from operations e.g. oId_File
      
12547:    Node t
      
12547:    t = @newIdent( nTypeDecl, oId_File )
12560:    oNodeSet( t, qType, FileType )
12572:    oScopeDeclare( t )
      
12578:    t = @newIdent( nTypeDecl, oId_Integer )
12591:    oNodeSet( t, qType, IntegerType )
12603:    oScopeDeclare( t )
      
12609:    t = @newIdent( nTypeDecl, oId_Boolean )
12622:    oNodeSet( t, qType, BooleanType )
12634:    oScopeDeclare( t )
      
12640:    t = @newIdent( nTypeDecl, oId_Char )
12653:    oNodeSet( t, qType, CharType )
12665:    oScopeDeclare( t )
      
12671:    t = @newIdent( nTypeDecl, oId_Byte )
12684:    oNodeSet( t, qType, ByteType )
12696:    oScopeDeclare( t )
      
12702:    t = @newIdent( nTypeDecl, oId_Pointer )
12715:    oNodeSet( t, qType, UniversalPointerType )
12727:    oScopeDeclare( t )
      
12733:    t = @newIdent( nTypeDecl, oId_ShortString )
12746:    oNodeSet( t, qType, ShortStringType )
12758:    oScopeDeclare( t )
      
         % Built-in constants
      
12764:    t = @newIdent( nConst, oId_True )
12777:    oNodeSet( t, qType, BooleanType )
12789:    oNodeSetInt( t, qValue, 1 )
12801:    oScopeDeclare( t )
      
12807:    t = @newIdent( nConst, oId_False )
12820:    oNodeSet( t, qType, BooleanType )
12832:    oNodeSetInt( t, qValue, 0 )
12844:    oScopeDeclare( t )
      
12850:    t = @newIdent( nConst, oId_Nil )
12863:    oNodeSet( t, qType, UniversalPointerType )
12875:    oNodeSetInt( t, qValue, 0 )
12887:    oScopeDeclare( t )
      
         % Built-in methods
         % These aren't declared like normal methods, because they may have
         % special rules for parameter types (e.g. any scalar type).
         % Calls to these methods will be handled specially by the compiler.
      
12893:    BuiltIn_Ord = @DeclareBuiltInFunc( oId_Ord )
12903:    BuiltIn_Chr = @DeclareBuiltInFunc( oId_Chr )
12913:    BuiltIn_Pred = @DeclareBuiltInFunc( oId_Pred )
12923:    BuiltIn_Succ = @DeclareBuiltInFunc( oId_Succ )
12934:    ;
      
12934: end
      
12934: 

Generated code:

   0: oGlobalSpace 22
   2: oLocalSpace 5
   4: oGetAddrGlobal 1
   6: oPushResult
   7: oWorkspaceNew
   8: oAssign
   9: oSetResult 0
  11: oPushResult
  12: oSetResult 0
  14: oPushResult
  15: oScopeBegin
  16: oPop 2
  18: oGetAddrLocal 2
  20: oPushResult
  21: oScopeCurrent
  22: oAssign
  23: oCall 12379
  25: oEmit 67
  27: oSetResult 0
  29: oPushResult
  30: oEmitInt
  31: oPop 1
  33: oGetAddrLocal 3
  35: oPushResult
  36: oLabelNew
  37: oAssign
  38: oEmit 61
  40: oSetResult 0
  42: oPushResult
  43: oEmitInt
  44: oPop 1
  46: oEmit 64
  48: oGetLocal 3
  50: oPushResult
  51: oEmitLabel
  52: oPop 1
  54: oEmit 63
  56: oSetResult 0
  58: oPushResult
  59: oEmitInt
  60: oPop 1
  62: oEmit 66
  64: oInput 28
  66: oInput 0
  68: oGetAddrLocal 4
  70: oPushResult
  71: oSetResult 4
  73: oPushResult
  74: oNodeNew
  75: oPop 1
  77: oAssign
  78: oGetLocal 4
  80: oPushResult
  81: oSetResult 4
  83: oPushResult
  84: LAST_ID
  85: oPushResult
  86: oNodeSetInt
  87: oPop 3
  89: oGetGlobal 1
  91: oPushResult
  92: oSetResult 2
  94: oPushResult
  95: oGetLocal 4
  97: oPushResult
  98: oNodeSet
  99: oPop 3
 101: oInputChoice 175
 103: oInput 0
 105: oGetAddrLocal 1
 107: oPushResult
 108: oSetResult 19
 110: oPushResult
 111: LAST_ID
 112: oPushResult
 113: oCall 12035
 115: oPop 2
 117: oAssign
 118: oGetLocal 1
 120: oPushResult
 121: oSetResult 21
 123: oPushResult
 124: oGetGlobal 5
 126: oPushResult
 127: oNodeSet
 128: oPop 3
 130: oGetLocal 1
 132: oPushResult
 133: oScopeDeclareAlloc
 134: oPop 1
 136: oInput 13
 138: oInput 0
 140: oGetAddrLocal 1
 142: oPushResult
 143: oSetResult 19
 145: oPushResult
 146: LAST_ID
 147: oPushResult
 148: oCall 12035
 150: oPop 2
 152: oAssign
 153: oGetLocal 1
 155: oPushResult
 156: oSetResult 21
 158: oPushResult
 159: oGetGlobal 5
 161: oPushResult
 162: oNodeSet
 163: oPop 3
 165: oGetLocal 1
 167: oPushResult
 168: oScopeDeclareAlloc
 169: oPop 1
 171: oInput 15
 173: oJumpForward 178
 175: Choice Lookup Table
          14    103
 178: oInput 5
 180: oGetLocal 4
 182: oPushResult
 183: oCall 333
 185: oPop 1
 187: oInputChoice 198
 189: oGetLocal 4
 191: oPushResult
 192: oCall 306
 194: oPop 1
 196: oJumpForward 201
 198: Choice Lookup Table
          59    189
 201: oGetLocal 4
 203: oPushResult
 204: oCall 586
 206: oPop 1
 208: oSetResult 0
 210: oPushResult
 211: oSetResult 0
 213: oPushResult
 214: oScopeBegin
 215: oPop 2
 217: oGetAddrGlobal 2
 219: oPushResult
 220: oScopeCurrent
 221: oAssign
 222: oSetResult 0
 224: oPushResult
 225: oSetResult 1
 227: oPushResult
 228: oScopeBegin
 229: oPop 2
 231: oScopeCurrent
 232: oPushResult
 233: oSetResult 16
 235: oPushResult
 236: oGetGlobal 2
 238: oPushResult
 239: oNodeSet
 240: oPop 3
 242: oGetAddrGlobal 3
 244: oPushResult
 245: oScopeCurrent
 246: oAssign
 247: oGetLocal 4
 249: oPushResult
 250: oSetResult 7
 252: oPushResult
 253: oGetGlobal 3
 255: oPushResult
 256: oNodeSet
 257: oPop 3
 259: oScopeEnd
 260: oSetResult 20
 262: oPushResult
 263: oCall 1543
 265: oPop 1
 267: oGetGlobal 3
 269: oPushResult
 270: oScopeEnter
 271: oPop 1
 273: oGetAddrLocal 5
 275: oPushResult
 276: oSetResult 1
 278: oAssign
 279: oGetLocal 3
 281: oPushResult
 282: oGetGlobal 2
 284: oPushResult
 285: oGetLocal 5
 287: oPushResult
 288: oCall 1864
 290: oPop 3
 292: oScopeEnd
 293: oInput 20
 295: oCall 1599
 297: oScopeEnd
 298: oGetLocal 4
 300: oPushResult
 301: oCall 648
 303: oPop 1
 305: oReturn
 306: oLocalSpace 0
 308: oInput 0
 310: LAST_ID
 311: oPushResult
 312: oGetParam 1
 314: oPushResult
 315: oCall 447
 317: oPop 2
 319: oInputChoice 323
 321: oJumpForward 328
 323: Choice Lookup Table
          13    321
 326: oJumpForward 330
 328: oJumpBack 308
 330: oInput 5
 332: oReturn
 333: oLocalSpace 0
 335: oGetParam 1
 337: oPushResult
 338: oSetResult 4
 340: oPushResult
 341: oNodeGetInt
 342: oPop 2
 344: oPushResult
 345: oGetGlobal 4
 347: oPushResult
 348: equal
 349: oPop 2
 351: oChoice 356
 353: oReturn
 354: oJumpForward 359
 356: Choice Lookup Table
           1    353
 359: oGetGlobal 4
 361: oPushResult
 362: oGetParam 1
 364: oPushResult
 365: oCall 447
 367: oPop 2
 369: oReturn
 370: oLocalSpace 0
 372: oGetParam 1
 374: oPushResult
 375: oSetResult 4
 377: oPushResult
 378: oNodeGetInt
 379: oPop 2
 381: oPushResult
 382: oGetGlobal 4
 384: oPushResult
 385: equal
 386: oPop 2
 388: oChoice 443
 390: oGetAddrGlobal 19
 392: oPushResult
 393: oScopeCurrent
 394: oPushResult
 395: oSetResult 15
 397: oPushResult
 398: oSetResult 4
 400: oPushResult
 401: oId_ShortStringAppendShortString
 402: oPushResult
 403: oNodeFind
 404: oPop 4
 406: oAssign
 407: oGetAddrGlobal 20
 409: oPushResult
 410: oScopeCurrent
 411: oPushResult
 412: oSetResult 15
 414: oPushResult
 415: oSetResult 4
 417: oPushResult
 418: oId_ShortStringAppendChar
 419: oPushResult
 420: oNodeFind
 421: oPop 4
 423: oAssign
 424: oGetAddrGlobal 21
 426: oPushResult
 427: oScopeCurrent
 428: oPushResult
 429: oSetResult 15
 431: oPushResult
 432: oSetResult 4
 434: oPushResult
 435: oId_ShortStringCmp
 436: oPushResult
 437: oNodeFind
 438: oPop 4
 440: oAssign
 441: oJumpForward 446
 443: Choice Lookup Table
           1    390
 446: oReturn
 447: oLocalSpace 2
 449: oGetAddrLocal 1
 451: oPushResult
 452: oGetParam 2
 454: oPushResult
 455: oCall 727
 457: oPop 1
 459: oAssign
 460: oGetLocal 1
 462: oPushResult
 463: oSetResult 0
 465: oPushResult
 466: equal_node
 467: oPop 2
 469: oChoice 539
 471: oGetParam 1
 473: oPushResult
 474: oSetResult 5
 476: oPushResult
 477: oGetLocal 1
 479: oPushResult
 480: oNodeAddLast
 481: oPop 3
 483: oGetAddrLocal 2
 485: oPushResult
 486: oSetResult 10
 488: oPushResult
 489: oNodeNew
 490: oPop 1
 492: oAssign
 493: oGetLocal 2
 495: oPushResult
 496: oSetResult 4
 498: oPushResult
 499: oGetLocal 1
 501: oPushResult
 502: oSetResult 4
 504: oPushResult
 505: oNodeGetInt
 506: oPop 2
 508: oPushResult
 509: oNodeSetInt
 510: oPop 3
 512: oGetLocal 2
 514: oPushResult
 515: oSetResult 9
 517: oPushResult
 518: oGetLocal 1
 520: oPushResult
 521: oSetResult 9
 523: oPushResult
 524: oNodeGet
 525: oPop 2
 527: oPushResult
 528: oNodeSet
 529: oPop 3
 531: oGetLocal 2
 533: oPushResult
 534: oScopeDeclare
 535: oPop 1
 537: oJumpForward 542
 539: Choice Lookup Table
           0    471
 542: oReturn
 543: oLocalSpace 1
 545: oGetFromParam 1
 547: oPushResult
 548: oNodeType
 549: oPop 1
 551: oChoice 582
 553: oGetAddrLocal 1
 555: oPushResult
 556: oGetFromParam 1
 558: oPushResult
 559: oSetResult 9
 561: oPushResult
 562: oNodeGet
 563: oPop 2
 565: oAssign
 566: oInput 20
 568: oInput 0
 570: oGetParam 1
 572: oPushResult
 573: oGetLocal 1
 575: oPushResult
 576: oScopeFindRequireInScope
 577: oPop 1
 579: oAssign
 580: oJumpForward 585
 582: Choice Lookup Table
          10    553
 585: oReturn
 586: oLocalSpace 2
 588: oGetAddrLocal 1
 590: oPushResult
 591: oGetParam 1
 593: oPushResult
 594: oSetResult 5
 596: oPushResult
 597: oNodeGetIter
 598: oPop 2
 600: oAssign
 601: oGetAddrLocal 2
 603: oPushResult
 604: oGetLocal 1
 606: oPushResult
 607: oNodeIterValue
 608: oPop 1
 610: oAssign
 611: oGetLocal 2
 613: oPushResult
 614: oNodeNull
 615: oPop 1
 617: oChoice 634
 619: oGetLocal 2
 621: oPushResult
 622: oSetResult 9
 624: oPushResult
 625: oNodeGet
 626: oPop 2
 628: oPushResult
 629: oScopeEnter
 630: oPop 1
 632: oJumpForward 639
 634: Choice Lookup Table
           0    619
 637: oJumpForward 647
 639: oGetAddrLocal 1
 641: oPushResult
 642: oNodeIterNext
 643: oPop 1
 645: oJumpBack 601
 647: oReturn
 648: oLocalSpace 2
 650: oGetAddrLocal 1
 652: oPushResult
 653: oGetParam 1
 655: oPushResult
 656: oSetResult 5
 658: oPushResult
 659: oNodeGetIterLast
 660: oPop 2
 662: oAssign
 663: oGetAddrLocal 2
 665: oPushResult
 666: oGetLocal 1
 668: oPushResult
 669: oNodeIterValue
 670: oPop 1
 672: oAssign
 673: oGetLocal 2
 675: oPushResult
 676: oNodeNull
 677: oPop 1
 679: oChoice 713
 681: oScopeCurrent
 682: oPushResult
 683: oGetLocal 2
 685: oPushResult
 686: oSetResult 9
 688: oPushResult
 689: oNodeGet
 690: oPop 2
 692: oPushResult
 693: oNodeEqual
 694: oPop 2
 696: oChoice 704
 698: oJumpForward 710
 700: oError 25
 702: oJumpForward 710
 704: Choice Lookup Table
           0    700
           1    698
 709: oEndChoice
 710: oScopeEnd
 711: oJumpForward 718
 713: Choice Lookup Table
           0    681
 716: oJumpForward 726
 718: oGetAddrLocal 1
 720: oPushResult
 721: oNodeIterPrev
 722: oPop 1
 724: oJumpBack 663
 726: oReturn
 727: oLocalSpace 2
 729: oGetAddrLocal 1
 731: oPushResult
 732: oGetGlobal 1
 734: oPushResult
 735: oSetResult 1
 737: oPushResult
 738: oSetResult 4
 740: oPushResult
 741: oGetParam 1
 743: oPushResult
 744: oNodeFind
 745: oPop 4
 747: oAssign
 748: oGetLocal 1
 750: oPushResult
 751: oSetResult 0
 753: oPushResult
 754: equal_node
 755: oPop 2
 757: oChoice 764
 759: oGetLocal 1
 761: oReturn
 762: oJumpForward 767
 764: Choice Lookup Table
           0    759
 767: oGetAddrLocal 2
 769: oPushResult
 770: oGetParam 1
 772: oPushResult
 773: oIncludeUnitFile
 774: oPop 1
 776: oAssign
 777: oGetLocal 2
 779: oChoice 788
 781: oError 24
 783: oSetResult 0
 785: oReturn
 786: oJumpForward 791
 788: Choice Lookup Table
           0    781
 791: oGetAddrLocal 1
 793: oPushResult
 794: oCall 802
 796: oAssign
 797: oIncludeEnd
 798: oGetLocal 1
 800: oReturn
 801: oReturn
 802: oLocalSpace 2
 804: oInput 60
 806: oInput 0
 808: oGetAddrLocal 1
 810: oPushResult
 811: oSetResult 5
 813: oPushResult
 814: oNodeNew
 815: oPop 1
 817: oAssign
 818: oGetLocal 1
 820: oPushResult
 821: oSetResult 4
 823: oPushResult
 824: LAST_ID
 825: oPushResult
 826: oNodeSetInt
 827: oPop 3
 829: oGetAddrLocal 2
 831: oPushResult
 832: oSetResult 6
 834: oPushResult
 835: oNodeNew
 836: oPop 1
 838: oAssign
 839: oGetLocal 2
 841: oPushResult
 842: oSetResult 4
 844: oPushResult
 845: LAST_ID
 846: oPushResult
 847: oNodeSetInt
 848: oPop 3
 850: oGetLocal 1
 852: oPushResult
 853: oSetResult 8
 855: oPushResult
 856: oGetLocal 2
 858: oPushResult
 859: oNodeSet
 860: oPop 3
 862: oInput 5
 864: oInput 61
 866: oGetLocal 1
 868: oPushResult
 869: oCall 333
 871: oPop 1
 873: oInputChoice 884
 875: oGetLocal 1
 877: oPushResult
 878: oCall 306
 880: oPop 1
 882: oJumpForward 887
 884: Choice Lookup Table
          59    875
 887: oGetLocal 1
 889: oPushResult
 890: oCall 586
 892: oPop 1
 894: oSetResult 0
 896: oPushResult
 897: oSetResult 0
 899: oPushResult
 900: oScopeBegin
 901: oPop 2
 903: oGetLocal 1
 905: oPushResult
 906: oSetResult 9
 908: oPushResult
 909: oScopeCurrent
 910: oPushResult
 911: oNodeSet
 912: oPop 3
 914: oGetAddrGlobal 2
 916: oPushResult
 917: oScopeCurrent
 918: oAssign
 919: oSetResult 0
 921: oPushResult
 922: oSetResult 1
 924: oPushResult
 925: oScopeBegin
 926: oPop 2
 928: oGetAddrGlobal 3
 930: oPushResult
 931: oScopeCurrent
 932: oAssign
 933: oGetLocal 1
 935: oPushResult
 936: oSetResult 13
 938: oPushResult
 939: oGetGlobal 3
 941: oPushResult
 942: oNodeSet
 943: oPop 3
 945: oScopeEnd
 946: oGetLocal 1
 948: oPushResult
 949: oCall 1137
 951: oPop 1
 953: oScopeEnd
 954: oInput 62
 956: oGetLocal 2
 958: oPushResult
 959: oCall 333
 961: oPop 1
 963: oInputChoice 974
 965: oGetLocal 2
 967: oPushResult
 968: oCall 306
 970: oPop 1
 972: oJumpForward 977
 974: Choice Lookup Table
          59    965
 977: oGetLocal 2
 979: oPushResult
 980: oCall 586
 982: oPop 1
 984: oGetLocal 1
 986: oPushResult
 987: oSetResult 9
 989: oPushResult
 990: oNodeGet
 991: oPop 2
 993: oPushResult
 994: oScopeEnter
 995: oPop 1
 997: oSetResult 0
 999: oPushResult
1000: oSetResult 0
1002: oPushResult
1003: oScopeBegin
1004: oPop 2
1006: oGetLocal 1
1008: oPushResult
1009: oSetResult 10
1011: oPushResult
1012: oScopeCurrent
1013: oPushResult
1014: oNodeSet
1015: oPop 3
1017: oScopeCurrent
1018: oPushResult
1019: oSetResult 16
1021: oPushResult
1022: oGetLocal 1
1024: oPushResult
1025: oSetResult 9
1027: oPushResult
1028: oNodeGet
1029: oPop 2
1031: oPushResult
1032: oNodeSet
1033: oPop 3
1035: oGetAddrGlobal 2
1037: oPushResult
1038: oScopeCurrent
1039: oAssign
1040: oGetLocal 1
1042: oPushResult
1043: oCall 1229
1045: oPop 1
1047: oInputChoice 1061
1049: oGetLocal 1
1051: oPushResult
1052: oSetResult 1
1054: oPushResult
1055: oCall 1239
1057: oPop 2
1059: oJumpForward 1074
1061: Choice Lookup Table
          63   1049
1064: oGetLocal 1
1066: oPushResult
1067: oSetResult 0
1069: oPushResult
1070: oCall 1239
1072: oPop 2
1074: oInputChoice 1088
1076: oGetLocal 1
1078: oPushResult
1079: oSetResult 1
1081: oPushResult
1082: oCall 1425
1084: oPop 2
1086: oJumpForward 1101
1088: Choice Lookup Table
          64   1076
1091: oGetLocal 1
1093: oPushResult
1094: oSetResult 0
1096: oPushResult
1097: oCall 1425
1099: oPop 2
1101: oInput 36
1103: oInput 20
1105: oScopeEnd
1106: oScopeEnd
1107: oGetLocal 2
1109: oPushResult
1110: oCall 648
1112: oPop 1
1114: oGetLocal 1
1116: oPushResult
1117: oCall 648
1119: oPop 1
1121: oGetGlobal 1
1123: oPushResult
1124: oSetResult 1
1126: oPushResult
1127: oGetLocal 1
1129: oPushResult
1130: oNodeAddLast
1131: oPop 3
1133: oGetLocal 1
1135: oReturn
1136: oReturn
1137: oLocalSpace 2
1139: oInputChoice 1206
1141: oCall 3137
1143: oJumpForward 1219
1145: oCall 3734
1147: oJumpForward 1219
1149: oSetResult 20
1151: oPushResult
1152: oCall 3790
1154: oPop 1
1156: oJumpForward 1219
1158: oGetAddrLocal 1
1160: oPushResult
1161: oCall 2104
1163: oAssign
1164: oInputChoice 1177
1166: oGetLocal 1
1168: oPushResult
1169: oCall 2042
1171: oPop 1
1173: oInput 5
1175: oJumpForward 1180
1177: Choice Lookup Table
          70   1166
1180: oJumpForward 1219
1182: oGetAddrLocal 2
1184: oPushResult
1185: oCall 2478
1187: oAssign
1188: oInputChoice 1201
1190: oGetLocal 2
1192: oPushResult
1193: oCall 2042
1195: oPop 1
1197: oInput 5
1199: oJumpForward 1204
1201: Choice Lookup Table
          70   1190
1204: oJumpForward 1219
1206: Choice Lookup Table
          30   1182
          29   1158
          33   1149
          32   1145
          31   1141
1217: oJumpForward 1221
1219: oJumpBack 1139
1221: oGetParam 1
1223: oPushResult
1224: oCall 370
1226: oPop 1
1228: oReturn
1229: oLocalSpace 0
1231: oSetResult 20
1233: oPushResult
1234: oCall 1543
1236: oPop 1
1238: oReturn
1239: oLocalSpace 5
1241: oGetAddrLocal 1
1243: oPushResult
1244: oLabelNew
1245: oAssign
1246: oEmit 77
1248: oGetLocal 1
1250: oPushResult
1251: oEmitLabel
1252: oPop 1
1254: oGetParam 2
1256: oPushResult
1257: oSetResult 11
1259: oPushResult
1260: oGetLocal 1
1262: oPushResult
1263: oNodeSetLabel
1264: oPop 3
1266: oEmit 67
1268: oGetAddrLocal 2
1270: oPushResult
1271: Here
1272: oAssign
1273: oEmit 90
1275: oGetAddrLocal 3
1277: oPushResult
1278: oGetParam 2
1280: oPushResult
1281: oSetResult 9
1283: oPushResult
1284: oNodeGet
1285: oPop 2
1287: oAssign
1288: oGetAddrLocal 4
1290: oPushResult
1291: oGetLocal 3
1293: oPushResult
1294: oSetResult 19
1296: oPushResult
1297: oNodeGetCode
1298: oPop 2
1300: oAssign
1301: oGetLocal 4
1303: oPushResult
1304: oEmitCode
1305: oPop 1
1307: oGetLocal 3
1309: oPushResult
1310: oSetResult 19
1312: oPushResult
1313: oSetResult 0
1315: oPushResult
1316: oNodeSetCode
1317: oPop 3
1319: oGetAddrLocal 3
1321: oPushResult
1322: oGetParam 2
1324: oPushResult
1325: oSetResult 10
1327: oPushResult
1328: oNodeGet
1329: oPop 2
1331: oAssign
1332: oGetAddrLocal 4
1334: oPushResult
1335: oGetLocal 3
1337: oPushResult
1338: oSetResult 19
1340: oPushResult
1341: oNodeGetCode
1342: oPop 2
1344: oAssign
1345: oGetLocal 4
1347: oPushResult
1348: oEmitCode
1349: oPop 1
1351: oGetLocal 3
1353: oPushResult
1354: oSetResult 19
1356: oPushResult
1357: oSetResult 0
1359: oPushResult
1360: oNodeSetCode
1361: oPop 3
1363: oGetParam 2
1365: oPushResult
1366: oSetResult 13
1368: oPushResult
1369: oNodeGet
1370: oPop 2
1372: oPushResult
1373: oScopeEnter
1374: oPop 1
1376: oGetParam 1
1378: oChoice 1397
1380: oCall 10173
1382: oInputChoice 1388
1384: oCall 10173
1386: oJumpForward 1393
1388: Choice Lookup Table
           5   1384
1391: oJumpForward 1395
1393: oJumpBack 1382
1395: oJumpForward 1400
1397: Choice Lookup Table
           1   1380
1400: oEmit 66
1402: oGetAddrLocal 5
1404: oPushResult
1405: oScopeCurrent
1406: oPushResult
1407: oSetResult 17
1409: oPushResult
1410: oNodeGetInt
1411: oPop 2
1413: oAssign
1414: oGetLocal 2
1416: oPushResult
1417: oGetLocal 5
1419: oPushResult
1420: oPatch
1421: oPop 2
1423: oScopeEnd
1424: oReturn
1425: oLocalSpace 3
1427: oGetAddrLocal 1
1429: oPushResult
1430: oLabelNew
1431: oAssign
1432: oEmit 77
1434: oGetLocal 1
1436: oPushResult
1437: oEmitLabel
1438: oPop 1
1440: oGetParam 2
1442: oPushResult
1443: oSetResult 12
1445: oPushResult
1446: oGetLocal 1
1448: oPushResult
1449: oNodeSetLabel
1450: oPop 3
1452: oEmit 67
1454: oGetAddrLocal 2
1456: oPushResult
1457: Here
1458: oAssign
1459: oEmit 90
1461: oSetResult 0
1463: oPushResult
1464: oSetResult 1
1466: oPushResult
1467: oScopeBegin
1468: oPop 2
1470: oGetParam 1
1472: oChoice 1491
1474: oCall 10173
1476: oInputChoice 1482
1478: oCall 10173
1480: oJumpForward 1487
1482: Choice Lookup Table
           5   1478
1485: oJumpForward 1489
1487: oJumpBack 1476
1489: oJumpForward 1494
1491: Choice Lookup Table
           1   1474
1494: oEmit 66
1496: oGetAddrLocal 3
1498: oPushResult
1499: oScopeCurrent
1500: oPushResult
1501: oSetResult 17
1503: oPushResult
1504: oNodeGetInt
1505: oPop 2
1507: oAssign
1508: oGetLocal 2
1510: oPushResult
1511: oGetLocal 3
1513: oPushResult
1514: oPatch
1515: oPop 2
1517: oScopeEnd
1518: oReturn
1519: oLocalSpace 0
1521: oGetParam 2
1523: oPushResult
1524: oCall 1543
1526: oPop 1
1528: oGetParam 1
1530: oPushResult
1531: oScopeCurrent
1532: oPushResult
1533: oSetResult 0
1535: oPushResult
1536: oCall 1864
1538: oPop 3
1540: oCall 1599
1542: oReturn
1543: oLocalSpace 0
1545: oInputChoice 1576
1547: oCall 3137
1549: oJumpForward 1591
1551: oCall 3734
1553: oJumpForward 1591
1555: oGetParam 1
1557: oPushResult
1558: oCall 3790
1560: oPop 1
1562: oJumpForward 1591
1564: oCall 4024
1566: oJumpForward 1591
1568: oCall 2360
1570: oJumpForward 1591
1572: oCall 2795
1574: oJumpForward 1591
1576: Choice Lookup Table
          30   1572
          29   1568
          34   1564
          33   1555
          32   1551
          31   1547
1589: oJumpForward 1593
1591: oJumpBack 1545
1593: oCall 1596
1595: oReturn
1596: oLocalSpace 0
1598: oReturn
1599: oLocalSpace 2
1601: oGetAddrLocal 1
1603: oPushResult
1604: oScopeCurrent
1605: oPushResult
1606: oSetResult 15
1608: oPushResult
1609: oNodeGetIter
1610: oPop 2
1612: oAssign
1613: oGetAddrLocal 2
1615: oPushResult
1616: oGetLocal 1
1618: oPushResult
1619: oNodeIterValue
1620: oPop 1
1622: oAssign
1623: oGetLocal 2
1625: oPushResult
1626: oNodeNull
1627: oPop 1
1629: oChoice 1633
1631: oJumpForward 1638
1633: Choice Lookup Table
           0   1631
1636: oJumpForward 1693
1638: oGetLocal 2
1640: oPushResult
1641: oNodeType
1642: oPop 1
1644: oChoice 1682
1646: oGetLocal 2
1648: oPushResult
1649: oSetResult 34
1651: oPushResult
1652: oNodeGetBoolean
1653: oPop 2
1655: oChoice 1677
1657: oGetLocal 2
1659: oPushResult
1660: oSetResult 28
1662: oPushResult
1663: oNodeGetBoolean
1664: oPop 2
1666: oChoice 1672
1668: oError 27
1670: oJumpForward 1675
1672: Choice Lookup Table
           1   1668
1675: oJumpForward 1680
1677: Choice Lookup Table
           0   1657
1680: oJumpForward 1685
1682: Choice Lookup Table
          25   1646
1685: oGetAddrLocal 1
1687: oPushResult
1688: oNodeIterNext
1689: oPop 1
1691: oJumpBack 1613
1693: oReturn
1694: oLocalSpace 2
1696: oGetAddrLocal 1
1698: oPushResult
1699: oGetGlobal 1
1701: oPushResult
1702: oSetResult 1
1704: oPushResult
1705: oNodeGetIter
1706: oPop 2
1708: oAssign
1709: oGetAddrLocal 2
1711: oPushResult
1712: oGetLocal 1
1714: oPushResult
1715: oNodeIterValue
1716: oPop 1
1718: oAssign
1719: oGetLocal 2
1721: oPushResult
1722: oNodeNull
1723: oPop 1
1725: oChoice 1770
1727: oJumpForward 1778
1729: oJumpForward 1776
1731: oEmit 61
1733: oSetResult 0
1735: oPushResult
1736: oEmitInt
1737: oPop 1
1739: oEmit 64
1741: oGetLocal 2
1743: oPushResult
1744: oSetResult 11
1746: oPushResult
1747: oNodeGetLabel
1748: oPop 2
1750: oPushResult
1751: oEmitLabel
1752: oPop 1
1754: oEmit 63
1756: oSetResult 0
1758: oPushResult
1759: oEmitInt
1760: oPop 1
1762: oGetAddrLocal 1
1764: oPushResult
1765: oNodeIterNext
1766: oPop 1
1768: oJumpForward 1776
1770: Choice Lookup Table
           0   1731
           1   1727
1775: oEndChoice
1776: oJumpBack 1709
1778: oReturn
1779: oLocalSpace 2
1781: oGetAddrLocal 1
1783: oPushResult
1784: oGetGlobal 1
1786: oPushResult
1787: oSetResult 1
1789: oPushResult
1790: oNodeGetIterLast
1791: oPop 2
1793: oAssign
1794: oGetAddrLocal 2
1796: oPushResult
1797: oGetLocal 1
1799: oPushResult
1800: oNodeIterValue
1801: oPop 1
1803: oAssign
1804: oGetLocal 2
1806: oPushResult
1807: oNodeNull
1808: oPop 1
1810: oChoice 1855
1812: oJumpForward 1863
1814: oJumpForward 1861
1816: oEmit 61
1818: oSetResult 0
1820: oPushResult
1821: oEmitInt
1822: oPop 1
1824: oEmit 64
1826: oGetLocal 2
1828: oPushResult
1829: oSetResult 12
1831: oPushResult
1832: oNodeGetLabel
1833: oPop 2
1835: oPushResult
1836: oEmitLabel
1837: oPop 1
1839: oEmit 63
1841: oSetResult 0
1843: oPushResult
1844: oEmitInt
1845: oPop 1
1847: oGetAddrLocal 1
1849: oPushResult
1850: oNodeIterPrev
1851: oPop 1
1853: oJumpForward 1861
1855: Choice Lookup Table
           0   1816
           1   1812
1860: oEndChoice
1861: oJumpBack 1794
1863: oReturn
1864: oLocalSpace 3
1866: oEmit 77
1868: oGetParam 3
1870: oPushResult
1871: oEmitLabel
1872: oPop 1
1874: oEmit 67
1876: oGetAddrLocal 1
1878: oPushResult
1879: Here
1880: oAssign
1881: oEmit 90
1883: oGetParam 1
1885: oChoice 1891
1887: oCall 1694
1889: oJumpForward 1894
1891: Choice Lookup Table
           1   1887
1894: oGetAddrLocal 2
1896: oPushResult
1897: oGetParam 2
1899: oPushResult
1900: oSetResult 19
1902: oPushResult
1903: oNodeGetCode
1904: oPop 2
1906: oAssign
1907: oGetLocal 2
1909: oPushResult
1910: oEmitCode
1911: oPop 1
1913: oGetParam 2
1915: oPushResult
1916: oSetResult 19
1918: oPushResult
1919: oSetResult 0
1921: oPushResult
1922: oNodeSetCode
1923: oPop 3
1925: oCall 10173
1927: oGetParam 1
1929: oChoice 1935
1931: oCall 1779
1933: oJumpForward 1938
1935: Choice Lookup Table
           1   1931
1938: oEmit 66
1940: oGetAddrLocal 3
1942: oPushResult
1943: oScopeCurrent
1944: oPushResult
1945: oSetResult 17
1947: oPushResult
1948: oNodeGetInt
1949: oPop 2
1951: oAssign
1952: oGetLocal 1
1954: oPushResult
1955: oGetLocal 3
1957: oPushResult
1958: oPatch
1959: oPop 2
1961: oReturn
1962: oLocalSpace 0
1964: oInputChoice 1982
1966: oGetParam 1
1968: oPushResult
1969: oSetResult 27
1971: oPushResult
1972: oSetResult 1
1974: oPushResult
1975: oNodeSetBoolean
1976: oPop 3
1978: oInput 5
1980: oJumpForward 1987
1982: Choice Lookup Table
          72   1966
1985: oJumpForward 1989
1987: oJumpBack 1964
1989: oReturn
1990: oLocalSpace 1
1992: oGetAddrLocal 1
1994: oPushResult
1995: oGetParam 1
1997: oPushResult
1998: oSetResult 19
2000: oPushResult
2001: oNodeGetCode
2002: oPop 2
2004: oAssign
2005: oGetLocal 1
2007: oPushResult
2008: oSetResult 0
2010: oPushResult
2011: equal_code
2012: oPop 2
2014: oChoice 2035
2016: oGetAddrLocal 1
2018: oPushResult
2019: oCodeNew
2020: oAssign
2021: oGetParam 1
2023: oPushResult
2024: oSetResult 19
2026: oPushResult
2027: oGetLocal 1
2029: oPushResult
2030: oNodeSetCode
2031: oPop 3
2033: oJumpForward 2038
2035: Choice Lookup Table
           1   2016
2038: oGetLocal 1
2040: oReturn
2041: oReturn
2042: oLocalSpace 0
2044: oGetParam 1
2046: oPushResult
2047: oCall 11785
2049: oPop 1
2051: oPushResult
2052: equal_zero
2053: oPop 1
2055: oChoice 2061
2057: oError 23
2059: oJumpForward 2064
2061: Choice Lookup Table
           0   2057
2064: oGetParam 1
2066: oPushResult
2067: oSetResult 25
2069: oPushResult
2070: oSetResult 1
2072: oPushResult
2073: oNodeSetBoolean
2074: oPop 3
2076: oInputChoice 2100
2078: oInputChoice 2095
2080: oInput 2
2082: oGetParam 1
2084: oPushResult
2085: oSetResult 26
2087: oPushResult
2088: CURRENT_STRLIT
2089: oPushResult
2090: oNodeSetString
2091: oPop 3
2093: oJumpForward 2098
2095: Choice Lookup Table
          71   2080
2098: oJumpForward 2103
2100: Choice Lookup Table
           2   2078
2103: oReturn
2104: oLocalSpace 6
2106: oInput 0
2108: oGetAddrLocal 1
2110: oPushResult
2111: oSetResult 0
2113: oAssign
2114: oGetAddrLocal 2
2116: oPushResult
2117: oScopeFindInCurrentScope
2118: oAssign
2119: oGetLocal 2
2121: oPushResult
2122: oNodeNull
2123: oPop 1
2125: oChoice 2243
2127: oGetAddrLocal 2
2129: oPushResult
2130: oSetResult 12
2132: oPushResult
2133: LAST_ID
2134: oPushResult
2135: oCall 12035
2137: oPop 2
2139: oAssign
2140: oGetLocal 2
2142: oPushResult
2143: oSetResult 22
2145: oPushResult
2146: oLabelNew
2147: oPushResult
2148: oNodeSetLabel
2149: oPop 3
2151: oJumpForward 2249
2153: oGetAddrLocal 1
2155: oPushResult
2156: oSetResult 1
2158: oAssign
2159: oGetLocal 2
2161: oPushResult
2162: oSetResult 24
2164: oPushResult
2165: oNodeGetBoolean
2166: oPop 2
2168: oChoice 2174
2170: oError 21
2172: oJumpForward 2177
2174: Choice Lookup Table
           1   2170
2177: oGetLocal 2
2179: oPushResult
2180: oSetResult 25
2182: oPushResult
2183: oNodeGetBoolean
2184: oPop 2
2186: oChoice 2192
2188: oError 21
2190: oJumpForward 2195
2192: Choice Lookup Table
           1   2188
2195: oGetLocal 2
2197: oPushResult
2198: oNodeType
2199: oPop 1
2201: oChoice 2205
2203: oJumpForward 2210
2205: Choice Lookup Table
          12   2203
2208: oError 21
2210: oGetLocal 2
2212: oPushResult
2213: oSetResult 29
2215: oPushResult
2216: oGetLocal 2
2218: oPushResult
2219: oSetResult 23
2221: oPushResult
2222: oNodeGet
2223: oPop 2
2225: oPushResult
2226: oNodeSet
2227: oPop 3
2229: oGetLocal 2
2231: oPushResult
2232: oSetResult 23
2234: oPushResult
2235: oSetResult 0
2237: oPushResult
2238: oNodeSet
2239: oPop 3
2241: oJumpForward 2249
2243: Choice Lookup Table
           0   2153
           1   2127
2248: oEndChoice
2249: oGetAddrLocal 3
2251: oPushResult
2252: oCall 11773
2254: oAssign
2255: oGetAddrLocal 4
2257: oPushResult
2258: oGetLocal 3
2260: oPushResult
2261: oSetResult 0
2263: oPushResult
2264: greater
2265: oPop 2
2267: oAssign
2268: oGetAddrLocal 3
2270: oPushResult
2271: inc
2272: oPop 1
2274: oGetLocal 3
2276: oPushResult
2277: oSetResult 2
2279: oPushResult
2280: oScopeBegin
2281: oPop 2
2283: oGetAddrLocal 5
2285: oPushResult
2286: oScopeCurrent
2287: oAssign
2288: oGetLocal 4
2290: oChoice 2309
2292: oGetAddrLocal 6
2294: oPushResult
2295: oGetGlobal 6
2297: oPushResult
2298: oCall 12063
2300: oPop 1
2302: oPushResult
2303: oScopeAllocType
2304: oPop 1
2306: oAssign
2307: oJumpForward 2312
2309: Choice Lookup Table
           1   2292
2312: oCall 2913
2314: oGetLocal 2
2316: oPushResult
2317: oSetResult 23
2319: oPushResult
2320: oGetLocal 5
2322: oPushResult
2323: oNodeSet
2324: oPop 3
2326: oScopeEnd
2327: oInput 5
2329: oGetLocal 1
2331: oChoice 2343
2333: oGetLocal 2
2335: oPushResult
2336: oScopeDeclare
2337: oPop 1
2339: oJumpForward 2349
2341: oJumpForward 2349
2343: Choice Lookup Table
           1   2341
           0   2333
2348: oEndChoice
2349: oGetLocal 2
2351: oPushResult
2352: oCall 1962
2354: oPop 1
2356: oGetLocal 2
2358: oReturn
2359: oReturn
2360: oLocalSpace 4
2362: oGetAddrLocal 1
2364: oPushResult
2365: oCall 2104
2367: oAssign
2368: oInputChoice 2381
2370: oJumpForward 2475
2372: oGetLocal 1
2374: oPushResult
2375: oCall 2042
2377: oPop 1
2379: oJumpForward 2475
2381: Choice Lookup Table
          70   2372
          69   2370
2386: oGetAddrLocal 2
2388: oPushResult
2389: oGetLocal 1
2391: oPushResult
2392: oSetResult 23
2394: oPushResult
2395: oNodeGet
2396: oPop 2
2398: oAssign
2399: oGetLocal 2
2401: oPushResult
2402: oScopeEnter
2403: oPop 1
2405: oGetAddrLocal 3
2407: oPushResult
2408: oGetLocal 2
2410: oPushResult
2411: oSetResult 14
2413: oPushResult
2414: oNodeGetInt
2415: oPop 2
2417: oAssign
2418: oGetLocal 3
2420: oPushResult
2421: oSetResult 1
2423: oPushResult
2424: oScopeBegin
2425: oPop 2
2427: oGetLocal 1
2429: oPushResult
2430: oSetResult 6
2432: oPushResult
2433: oScopeCurrent
2434: oPushResult
2435: oNodeSet
2436: oPop 3
2438: oGetAddrLocal 4
2440: oPushResult
2441: oGetLocal 1
2443: oPushResult
2444: oSetResult 22
2446: oPushResult
2447: oNodeGetLabel
2448: oPop 2
2450: oAssign
2451: oSetResult 21
2453: oPushResult
2454: oGetLocal 4
2456: oPushResult
2457: oCall 1519
2459: oPop 2
2461: oGetLocal 1
2463: oPushResult
2464: oSetResult 24
2466: oPushResult
2467: oSetResult 1
2469: oPushResult
2470: oNodeSetBoolean
2471: oPop 3
2473: oScopeEnd
2474: oScopeEnd
2475: oInput 5
2477: oReturn
2478: oLocalSpace 8
2480: oInput 0
2482: oGetAddrLocal 1
2484: oPushResult
2485: oSetResult 0
2487: oAssign
2488: oGetAddrLocal 2
2490: oPushResult
2491: oScopeFindInCurrentScope
2492: oAssign
2493: oGetLocal 2
2495: oPushResult
2496: oNodeNull
2497: oPop 1
2499: oChoice 2630
2501: oGetAddrLocal 2
2503: oPushResult
2504: oSetResult 13
2506: oPushResult
2507: LAST_ID
2508: oPushResult
2509: oCall 12035
2511: oPop 2
2513: oAssign
2514: oGetLocal 2
2516: oPushResult
2517: oSetResult 22
2519: oPushResult
2520: oLabelNew
2521: oPushResult
2522: oNodeSetLabel
2523: oPop 3
2525: oJumpForward 2636
2527: oGetAddrLocal 1
2529: oPushResult
2530: oSetResult 1
2532: oAssign
2533: oGetLocal 2
2535: oPushResult
2536: oSetResult 24
2538: oPushResult
2539: oNodeGetBoolean
2540: oPop 2
2542: oChoice 2548
2544: oError 21
2546: oJumpForward 2551
2548: Choice Lookup Table
           1   2544
2551: oGetLocal 2
2553: oPushResult
2554: oNodeType
2555: oPop 1
2557: oChoice 2561
2559: oJumpForward 2566
2561: Choice Lookup Table
          13   2559
2564: oError 21
2566: oGetLocal 2
2568: oPushResult
2569: oSetResult 29
2571: oPushResult
2572: oGetLocal 2
2574: oPushResult
2575: oSetResult 23
2577: oPushResult
2578: oNodeGet
2579: oPop 2
2581: oPushResult
2582: oNodeSet
2583: oPop 3
2585: oGetLocal 2
2587: oPushResult
2588: oSetResult 23
2590: oPushResult
2591: oSetResult 0
2593: oPushResult
2594: oNodeSet
2595: oPop 3
2597: oGetLocal 2
2599: oPushResult
2600: oSetResult 30
2602: oPushResult
2603: oGetLocal 2
2605: oPushResult
2606: oSetResult 21
2608: oPushResult
2609: oNodeGet
2610: oPop 2
2612: oPushResult
2613: oNodeSet
2614: oPop 3
2616: oGetLocal 2
2618: oPushResult
2619: oSetResult 21
2621: oPushResult
2622: oSetResult 0
2624: oPushResult
2625: oNodeSet
2626: oPop 3
2628: oJumpForward 2636
2630: Choice Lookup Table
           0   2527
           1   2501
2635: oEndChoice
2636: oGetAddrLocal 3
2638: oPushResult
2639: oCall 11773
2641: oAssign
2642: oGetAddrLocal 4
2644: oPushResult
2645: oGetLocal 3
2647: oPushResult
2648: oSetResult 0
2650: oPushResult
2651: greater
2652: oPop 2
2654: oAssign
2655: oGetAddrLocal 3
2657: oPushResult
2658: inc
2659: oPop 1
2661: oGetLocal 3
2663: oPushResult
2664: oSetResult 2
2666: oPushResult
2667: oScopeBegin
2668: oPop 2
2670: oGetAddrLocal 5
2672: oPushResult
2673: oScopeCurrent
2674: oAssign
2675: oGetLocal 4
2677: oChoice 2696
2679: oGetAddrLocal 6
2681: oPushResult
2682: oGetGlobal 6
2684: oPushResult
2685: oCall 12063
2687: oPop 1
2689: oPushResult
2690: oScopeAllocType
2691: oPop 1
2693: oAssign
2694: oJumpForward 2699
2696: Choice Lookup Table
           1   2679
2699: oCall 2913
2701: oGetLocal 2
2703: oPushResult
2704: oSetResult 23
2706: oPushResult
2707: oGetLocal 5
2709: oPushResult
2710: oNodeSet
2711: oPop 3
2713: oInput 12
2715: oGetAddrLocal 7
2717: oPushResult
2718: oCall 4089
2720: oPop 1
2722: oGetLocal 2
2724: oPushResult
2725: oSetResult 21
2727: oPushResult
2728: oGetLocal 7
2730: oPushResult
2731: oNodeSet
2732: oPop 3
2734: oGetAddrLocal 8
2736: oPushResult
2737: oGetLocal 7
2739: oPushResult
2740: oCall 12063
2742: oPop 1
2744: oAssign
2745: oGetLocal 2
2747: oPushResult
2748: oSetResult 31
2750: oPushResult
2751: oGetLocal 8
2753: oPushResult
2754: oScopeAllocType
2755: oPop 1
2757: oPushResult
2758: oNodeSetInt
2759: oPop 3
2761: oScopeEnd
2762: oInput 5
2764: oGetLocal 1
2766: oChoice 2778
2768: oGetLocal 2
2770: oPushResult
2771: oScopeDeclare
2772: oPop 1
2774: oJumpForward 2784
2776: oJumpForward 2784
2778: Choice Lookup Table
           1   2776
           0   2768
2783: oEndChoice
2784: oGetLocal 2
2786: oPushResult
2787: oCall 1962
2789: oPop 1
2791: oGetLocal 2
2793: oReturn
2794: oReturn
2795: oLocalSpace 4
2797: oGetAddrLocal 1
2799: oPushResult
2800: oCall 2478
2802: oAssign
2803: oInputChoice 2816
2805: oJumpForward 2910
2807: oGetLocal 1
2809: oPushResult
2810: oCall 2042
2812: oPop 1
2814: oJumpForward 2910
2816: Choice Lookup Table
          70   2807
          69   2805
2821: oGetAddrLocal 2
2823: oPushResult
2824: oGetLocal 1
2826: oPushResult
2827: oSetResult 23
2829: oPushResult
2830: oNodeGet
2831: oPop 2
2833: oAssign
2834: oGetLocal 2
2836: oPushResult
2837: oScopeEnter
2838: oPop 1
2840: oGetAddrLocal 3
2842: oPushResult
2843: oGetLocal 2
2845: oPushResult
2846: oSetResult 14
2848: oPushResult
2849: oNodeGetInt
2850: oPop 2
2852: oAssign
2853: oGetLocal 3
2855: oPushResult
2856: oSetResult 1
2858: oPushResult
2859: oScopeBegin
2860: oPop 2
2862: oGetLocal 1
2864: oPushResult
2865: oSetResult 6
2867: oPushResult
2868: oScopeCurrent
2869: oPushResult
2870: oNodeSet
2871: oPop 3
2873: oGetAddrLocal 4
2875: oPushResult
2876: oGetLocal 1
2878: oPushResult
2879: oSetResult 22
2881: oPushResult
2882: oNodeGetLabel
2883: oPop 2
2885: oAssign
2886: oSetResult 21
2888: oPushResult
2889: oGetLocal 4
2891: oPushResult
2892: oCall 1519
2894: oPop 2
2896: oGetLocal 1
2898: oPushResult
2899: oSetResult 24
2901: oPushResult
2902: oSetResult 1
2904: oPushResult
2905: oNodeSetBoolean
2906: oPop 3
2908: oScopeEnd
2909: oScopeEnd
2910: oInput 5
2912: oReturn
2913: oLocalSpace 6
2915: oInputChoice 3133
2917: oGetAddrLocal 1
2919: oPushResult
2920: oNodeVecNew
2921: oAssign
2922: oGetAddrLocal 3
2924: oPushResult
2925: oSetResult 0
2927: oAssign
2928: oInputChoice 2938
2930: oGetAddrLocal 3
2932: oPushResult
2933: oSetResult 1
2935: oAssign
2936: oJumpForward 2941
2938: Choice Lookup Table
          33   2930
2941: oInput 0
2943: oGetAddrLocal 2
2945: oPushResult
2946: oSetResult 23
2948: oPushResult
2949: LAST_ID
2950: oPushResult
2951: oCall 12035
2953: oPop 2
2955: oAssign
2956: oGetLocal 2
2958: oPushResult
2959: oSetResult 33
2961: oPushResult
2962: oGetLocal 3
2964: oPushResult
2965: oNodeSetBoolean
2966: oPop 3
2968: oGetLocal 1
2970: oPushResult
2971: oGetLocal 2
2973: oPushResult
2974: oNodeVecAppend
2975: oPop 2
2977: oInputChoice 2985
2979: oJumpForward 2993
2981: oJumpForward 2991
2983: oJumpForward 2991
2985: Choice Lookup Table
          13   2983
          12   2979
2990: oEndChoice
2991: oJumpBack 2941
2993: oGetAddrLocal 4
2995: oPushResult
2996: oCall 4089
2998: oPop 1
3000: oGetLocal 3
3002: oChoice 3017
3004: oGetAddrLocal 5
3006: oPushResult
3007: oGetLocal 4
3009: oPushResult
3010: oCall 12063
3012: oPop 1
3014: oAssign
3015: oJumpForward 3026
3017: Choice Lookup Table
           1   3004
3020: oGetAddrLocal 5
3022: oPushResult
3023: oGetLocal 4
3025: oAssign
3026: oGetAddrLocal 6
3028: oPushResult
3029: oSetResult 0
3031: oAssign
3032: oGetLocal 6
3034: oPushResult
3035: oGetLocal 1
3037: oPushResult
3038: oNodeVecSize
3039: oPop 1
3041: oPushResult
3042: equal
3043: oPop 2
3045: oChoice 3102
3047: oGetAddrLocal 2
3049: oPushResult
3050: oGetLocal 1
3052: oPushResult
3053: oGetLocal 6
3055: oPushResult
3056: oNodeVecElement
3057: oPop 2
3059: oAssign
3060: oGetLocal 2
3062: oPushResult
3063: oSetResult 21
3065: oPushResult
3066: oGetLocal 4
3068: oPushResult
3069: oNodeSet
3070: oPop 3
3072: oGetLocal 2
3074: oPushResult
3075: oScopeDeclare
3076: oPop 1
3078: oGetLocal 2
3080: oPushResult
3081: oSetResult 22
3083: oPushResult
3084: oGetLocal 5
3086: oPushResult
3087: oScopeAllocType
3088: oPop 1
3090: oPushResult
3091: oNodeSetInt
3092: oPop 3
3094: oGetAddrLocal 6
3096: oPushResult
3097: inc
3098: oPop 1
3100: oJumpForward 3107
3102: Choice Lookup Table
           0   3047
3105: oJumpForward 3109
3107: oJumpBack 3032
3109: oGetLocal 1
3111: oPushResult
3112: oNodeVecDelete
3113: oPop 1
3115: oInputChoice 3123
3117: oJumpForward 3131
3119: oJumpForward 3129
3121: oJumpForward 3129
3123: Choice Lookup Table
           5   3121
          15   3117
3128: oEndChoice
3129: oJumpBack 2917
3131: oJumpForward 3136
3133: Choice Lookup Table
          14   2917
3136: oReturn
3137: oLocalSpace 0
3139: oInputChoice 3154
3141: oInputChoice 3147
3143: oCall 3214
3145: oJumpForward 3152
3147: Choice Lookup Table
          12   3143
3150: oCall 3162
3152: oJumpForward 3159
3154: Choice Lookup Table
           0   3141
3157: oJumpForward 3161
3159: oJumpBack 3139
3161: oReturn
3162: oLocalSpace 1
3164: oGetAddrLocal 1
3166: oPushResult
3167: oSetResult 16
3169: oPushResult
3170: LAST_ID
3171: oPushResult
3172: oCall 12035
3174: oPop 2
3176: oAssign
3177: oInput 6
3179: oCall 5168
3181: oGetLocal 1
3183: oPushResult
3184: oSetResult 22
3186: oPushResult
3187: oValueTop
3188: oPushResult
3189: oNodeSetInt
3190: oPop 3
3192: oValuePop
3193: oGetLocal 1
3195: oPushResult
3196: oSetResult 21
3198: oPushResult
3199: oTypeSTop
3200: oPushResult
3201: oNodeSet
3202: oPop 3
3204: oTypeSPop
3205: oGetLocal 1
3207: oPushResult
3208: oScopeDeclare
3209: oPop 1
3211: oInput 5
3213: oReturn
3214: oLocalSpace 3
3216: oGetAddrLocal 1
3218: oPushResult
3219: oSetResult 24
3221: oPushResult
3222: LAST_ID
3223: oPushResult
3224: oCall 12035
3226: oPop 2
3228: oAssign
3229: oGetAddrLocal 2
3231: oPushResult
3232: oCall 4089
3234: oPop 1
3236: oGetLocal 1
3238: oPushResult
3239: oSetResult 21
3241: oPushResult
3242: oGetLocal 2
3244: oPushResult
3245: oNodeSet
3246: oPop 3
3248: oGetLocal 2
3250: oPushResult
3251: oNodeType
3252: oPop 1
3254: oChoice 3358
3256: oInput 6
3258: oGetLocal 2
3260: oPushResult
3261: oTypeSPush
3262: oPop 1
3264: oCall 5168
3266: oCall 5628
3268: oGetLocal 1
3270: oPushResult
3271: oSetResult 22
3273: oPushResult
3274: oValueTop
3275: oPushResult
3276: oNodeSetInt
3277: oPop 3
3279: oValuePop
3280: oTypeSPop
3281: oGetLocal 1
3283: oPushResult
3284: oScopeDeclare
3285: oPop 1
3287: oInput 5
3289: oJumpForward 3382
3291: oError 16
3293: oJumpForward 3382
3295: oGetGlobal 2
3297: oPushResult
3298: oScopeEnter
3299: oPop 1
3301: oGetAddrLocal 3
3303: oPushResult
3304: oGetLocal 2
3306: oPushResult
3307: oScopeAllocType
3308: oPop 1
3310: oAssign
3311: oScopeEnd
3312: oGetGlobal 2
3314: oPushResult
3315: oCall 1990
3317: oPop 1
3319: oPushResult
3320: oCodePush
3321: oPop 1
3323: oGetLocal 1
3325: oPushResult
3326: oSetResult 22
3328: oPushResult
3329: oGetLocal 3
3331: oPushResult
3332: oNodeSetInt
3333: oPop 3
3335: oInput 6
3337: oGetLocal 2
3339: oPushResult
3340: oGetLocal 3
3342: oPushResult
3343: oCall 3383
3345: oPop 2
3347: oCodePop
3348: oGetLocal 1
3350: oPushResult
3351: oScopeDeclare
3352: oPop 1
3354: oInput 5
3356: oJumpForward 3382
3358: Choice Lookup Table
          37   3295
          35   3295
          27   3291
          39   3291
          34   3256
          33   3256
          40   3256
          28   3256
          32   3256
          29   3256
          30   3256
3381: oEndChoice
3382: oReturn
3383: oLocalSpace 10
3385: oGetParam 2
3387: oPushResult
3388: oNodeType
3389: oPop 1
3391: oChoice 3709
3393: oGetAddrLocal 1
3395: oPushResult
3396: oGetParam 2
3398: oPushResult
3399: oSetResult 36
3401: oPushResult
3402: oNodeGet
3403: oPop 2
3405: oAssign
3406: oGetAddrLocal 2
3408: oPushResult
3409: oGetParam 2
3411: oPushResult
3412: oSetResult 37
3414: oPushResult
3415: oNodeGet
3416: oPop 2
3418: oAssign
3419: oGetAddrLocal 3
3421: oPushResult
3422: oGetLocal 2
3424: oPushResult
3425: oCall 12147
3427: oPop 1
3429: oAssign
3430: oGetAddrLocal 4
3432: oPushResult
3433: oGetLocal 2
3435: oPushResult
3436: oCall 12242
3438: oPop 1
3440: oAssign
3441: oGetAddrLocal 5
3443: oPushResult
3444: oGetLocal 1
3446: oPushResult
3447: oSetResult 17
3449: oPushResult
3450: oNodeGetInt
3451: oPop 2
3453: oAssign
3454: oInput 14
3456: oGetAddrLocal 6
3458: oPushResult
3459: oGetLocal 3
3461: oAssign
3462: oGetLocal 1
3464: oPushResult
3465: oGetParam 1
3467: oPushResult
3468: oCall 3383
3470: oPop 2
3472: oGetLocal 6
3474: oPushResult
3475: oGetLocal 4
3477: oPushResult
3478: equal
3479: oPop 2
3481: oChoice 3489
3483: oJumpForward 3518
3485: oJumpForward 3495
3487: oJumpForward 3495
3489: Choice Lookup Table
           0   3487
           1   3483
3494: oEndChoice
3495: oInput 13
3497: oGetAddrParam 1
3499: oPushResult
3500: oGetParam 1
3502: oPushResult
3503: oGetLocal 5
3505: oPushResult
3506: add
3507: oPop 2
3509: oAssign
3510: oGetAddrLocal 6
3512: oPushResult
3513: inc
3514: oPop 1
3516: oJumpBack 3462
3518: oInput 15
3520: oJumpForward 3733
3522: oInput 14
3524: oGetAddrLocal 7
3526: oPushResult
3527: oGetParam 2
3529: oPushResult
3530: oSetResult 40
3532: oPushResult
3533: oNodeGet
3534: oPop 2
3536: oAssign
3537: oInputChoice 3541
3539: oJumpForward 3546
3541: Choice Lookup Table
           0   3539
3544: oJumpForward 3612
3546: oGetAddrLocal 8
3548: oPushResult
3549: oGetLocal 7
3551: oPushResult
3552: oScopeFindRequireInScope
3553: oPop 1
3555: oAssign
3556: oInput 12
3558: oGetAddrLocal 9
3560: oPushResult
3561: oGetLocal 8
3563: oPushResult
3564: oSetResult 21
3566: oPushResult
3567: oNodeGet
3568: oPop 2
3570: oAssign
3571: oGetAddrLocal 10
3573: oPushResult
3574: oGetParam 1
3576: oPushResult
3577: oGetLocal 8
3579: oPushResult
3580: oSetResult 22
3582: oPushResult
3583: oNodeGetInt
3584: oPop 2
3586: oPushResult
3587: add
3588: oPop 2
3590: oAssign
3591: oGetLocal 9
3593: oPushResult
3594: oGetLocal 10
3596: oPushResult
3597: oCall 3383
3599: oPop 2
3601: oInputChoice 3605
3603: oJumpForward 3610
3605: Choice Lookup Table
           5   3603
3608: oJumpForward 3612
3610: oJumpBack 3537
3612: oInput 15
3614: oJumpForward 3733
3616: oEmit 16
3618: oGetParam 1
3620: oPushResult
3621: oEmitInt
3622: oPop 1
3624: oGetParam 2
3626: oPushResult
3627: oTypeSPush
3628: oPop 1
3630: oCall 5168
3632: oCall 5628
3634: oEmit 15
3636: oValueTop
3637: oPushResult
3638: oEmitInt
3639: oPop 1
3641: oValuePop
3642: oTypeSPop
3643: oEmit 27
3645: oJumpForward 3733
3647: oEmit 16
3649: oGetParam 1
3651: oPushResult
3652: oEmitInt
3653: oPop 1
3655: oGetParam 2
3657: oPushResult
3658: oTypeSPush
3659: oPop 1
3661: oCall 5168
3663: oEmit 15
3665: oValueTop
3666: oPushResult
3667: oEmitInt
3668: oPop 1
3670: oValuePop
3671: oTypeSPop
3672: oEmit 26
3674: oJumpForward 3733
3676: oEmit 16
3678: oGetParam 1
3680: oPushResult
3681: oEmitInt
3682: oPop 1
3684: oGetParam 2
3686: oPushResult
3687: oTypeSPush
3688: oPop 1
3690: oCall 5168
3692: oEmit 15
3694: oValueTop
3695: oPushResult
3696: oEmitInt
3697: oPop 1
3699: oValuePop
3700: oTypeSPop
3701: oEmit 28
3703: oJumpForward 3733
3705: oError 16
3707: oJumpForward 3733
3709: Choice Lookup Table
          27   3705
          39   3705
          34   3676
          33   3676
          40   3647
          28   3647
          32   3616
          29   3616
          30   3616
          37   3522
          35   3393
3732: oEndChoice
3733: oReturn
3734: oLocalSpace 2
3736: oInputChoice 3782
3738: oGetAddrLocal 1
3740: oPushResult
3741: oSetResult 18
3743: oPushResult
3744: LAST_ID
3745: oPushResult
3746: oCall 12035
3748: oPop 2
3750: oAssign
3751: oInput 6
3753: oGetAddrLocal 2
3755: oPushResult
3756: oCall 4089
3758: oPop 1
3760: oGetLocal 1
3762: oPushResult
3763: oSetResult 21
3765: oPushResult
3766: oGetLocal 2
3768: oPushResult
3769: oNodeSet
3770: oPop 3
3772: oGetLocal 1
3774: oPushResult
3775: oScopeDeclare
3776: oPop 1
3778: oInput 5
3780: oJumpForward 3787
3782: Choice Lookup Table
           0   3738
3785: oJumpForward 3789
3787: oJumpBack 3736
3789: oReturn
3790: oLocalSpace 6
3792: oInputChoice 4016
3794: oGetAddrLocal 1
3796: oPushResult
3797: oNodeVecNew
3798: oAssign
3799: oGetAddrLocal 2
3801: oPushResult
3802: oGetParam 1
3804: oPushResult
3805: LAST_ID
3806: oPushResult
3807: oCall 12035
3809: oPop 2
3811: oAssign
3812: oGetLocal 1
3814: oPushResult
3815: oGetLocal 2
3817: oPushResult
3818: oNodeVecAppend
3819: oPop 2
3821: oInputChoice 3827
3823: oInput 0
3825: oJumpForward 3832
3827: Choice Lookup Table
          13   3823
3830: oJumpForward 3834
3832: oJumpBack 3799
3834: oInput 12
3836: oGetAddrLocal 3
3838: oPushResult
3839: oCall 4089
3841: oPop 1
3843: oGetAddrLocal 4
3845: oPushResult
3846: oSetResult 0
3848: oAssign
3849: oGetLocal 4
3851: oPushResult
3852: oGetLocal 1
3854: oPushResult
3855: oNodeVecSize
3856: oPop 1
3858: oPushResult
3859: equal
3860: oPop 2
3862: oChoice 3903
3864: oGetAddrLocal 2
3866: oPushResult
3867: oGetLocal 1
3869: oPushResult
3870: oGetLocal 4
3872: oPushResult
3873: oNodeVecElement
3874: oPop 2
3876: oAssign
3877: oGetLocal 2
3879: oPushResult
3880: oSetResult 21
3882: oPushResult
3883: oGetLocal 3
3885: oPushResult
3886: oNodeSet
3887: oPop 3
3889: oGetLocal 2
3891: oPushResult
3892: oScopeDeclareAlloc
3893: oPop 1
3895: oGetAddrLocal 4
3897: oPushResult
3898: inc
3899: oPop 1
3901: oJumpForward 3908
3903: Choice Lookup Table
           0   3864
3906: oJumpForward 3910
3908: oJumpBack 3849
3910: oInputChoice 4003
3912: oGetLocal 1
3914: oPushResult
3915: oNodeVecSize
3916: oPop 1
3918: oChoice 3922
3920: oJumpForward 3927
3922: Choice Lookup Table
           1   3920
3925: oError 22
3927: oGetAddrLocal 5
3929: oPushResult
3930: oScopeCurrent
3931: oPushResult
3932: oCall 1990
3934: oPop 1
3936: oAssign
3937: oGetLocal 5
3939: oPushResult
3940: oCodePush
3941: oPop 1
3943: oGetAddrLocal 6
3945: oPushResult
3946: oSetResult 0
3948: oAssign
3949: oCall 11773
3951: oPushResult
3952: equal_zero
3953: oPop 1
3955: oChoice 3971
3957: oGetGlobal 3
3959: oPushResult
3960: oScopeEnter
3961: oPop 1
3963: oGetAddrLocal 6
3965: oPushResult
3966: oSetResult 1
3968: oAssign
3969: oJumpForward 3974
3971: Choice Lookup Table
           1   3957
3974: oGetLocal 2
3976: oPushResult
3977: oSetResult 1
3979: oPushResult
3980: oCall 10661
3982: oPop 2
3984: oCall 5686
3986: oCall 8799
3988: oCall 10417
3990: oGetLocal 6
3992: oChoice 3997
3994: oScopeEnd
3995: oJumpForward 4000
3997: Choice Lookup Table
           1   3994
4000: oCodePop
4001: oJumpForward 4006
4003: Choice Lookup Table
           6   3912
4006: oGetLocal 1
4008: oPushResult
4009: oNodeVecDelete
4010: oPop 1
4012: oInput 5
4014: oJumpForward 4021
4016: Choice Lookup Table
           0   3794
4019: oJumpForward 4023
4021: oJumpBack 3792
4023: oReturn
4024: oLocalSpace 2
4026: oInputChoice 4033
4028: oJumpForward 4039
4030: oChangeIntLitToLabelIdent
4031: oJumpForward 4039
4033: Choice Lookup Table
           1   4030
           0   4028
4038: oEndChoice
4039: oGetAddrLocal 1
4041: oPushResult
4042: oSetResult 25
4044: oPushResult
4045: LAST_ID
4046: oPushResult
4047: oCall 12035
4049: oPop 2
4051: oAssign
4052: oGetAddrLocal 2
4054: oPushResult
4055: oLabelNew
4056: oAssign
4057: oGetLocal 1
4059: oPushResult
4060: oSetResult 22
4062: oPushResult
4063: oGetLocal 2
4065: oPushResult
4066: oNodeSetLabel
4067: oPop 3
4069: oGetLocal 1
4071: oPushResult
4072: oScopeDeclare
4073: oPop 1
4075: oInputChoice 4079
4077: oJumpForward 4084
4079: Choice Lookup Table
          13   4077
4082: oJumpForward 4086
4084: oJumpBack 4026
4086: oInput 5
4088: oReturn
4089: oLocalSpace 12
4091: oInputChoice 4574
4093: oGetAddrLocal 1
4095: oPushResult
4096: oScopeFindRequire
4097: oAssign
4098: oGetAddrLocal 1
4100: oPushResult
4101: oCall 543
4103: oPop 1
4105: oGetLocal 1
4107: oPushResult
4108: oNodeType
4109: oPop 1
4111: oChoice 4128
4113: oGetParam 1
4115: oPushResult
4116: oGetLocal 1
4118: oPushResult
4119: oSetResult 21
4121: oPushResult
4122: oNodeGet
4123: oPop 2
4125: oAssign
4126: oJumpForward 4139
4128: Choice Lookup Table
          18   4113
4131: oError 2
4133: oGetParam 1
4135: oPushResult
4136: oGetGlobal 6
4138: oAssign
4139: oJumpForward 4597
4141: oInput 16
4143: oGetAddrLocal 2
4145: oPushResult
4146: oNodeVecNew
4147: oAssign
4148: oGetAddrLocal 3
4150: oPushResult
4151: oSetResult 36
4153: oPushResult
4154: oNodeNew
4155: oPop 1
4157: oAssign
4158: oCall 5168
4160: oGetLocal 3
4162: oPushResult
4163: oSetResult 38
4165: oPushResult
4166: oValueTop
4167: oPushResult
4168: oNodeSetInt
4169: oPop 3
4171: oValuePop
4172: oInput 21
4174: oCall 5168
4176: oGetLocal 3
4178: oPushResult
4179: oSetResult 39
4181: oPushResult
4182: oValueTop
4183: oPushResult
4184: oNodeSetInt
4185: oPop 3
4187: oValuePop
4188: oCall 5628
4190: oGetLocal 3
4192: oPushResult
4193: oSetResult 36
4195: oPushResult
4196: oTypeSTop
4197: oPushResult
4198: oNodeSet
4199: oPop 3
4201: oGetLocal 3
4203: oPushResult
4204: oSetResult 17
4206: oPushResult
4207: oTypeSTop
4208: oPushResult
4209: oSetResult 17
4211: oPushResult
4212: oNodeGetInt
4213: oPop 2
4215: oPushResult
4216: oNodeSetInt
4217: oPop 3
4219: oTypeSPop
4220: oGetLocal 3
4222: oPushResult
4223: oTypeAdd
4224: oPop 1
4226: oGetAddrLocal 4
4228: oPushResult
4229: oSetResult 35
4231: oPushResult
4232: oNodeNew
4233: oPop 1
4235: oAssign
4236: oGetLocal 4
4238: oPushResult
4239: oSetResult 37
4241: oPushResult
4242: oGetLocal 3
4244: oPushResult
4245: oNodeSet
4246: oPop 3
4248: oGetLocal 2
4250: oPushResult
4251: oGetLocal 4
4253: oPushResult
4254: oNodeVecAppend
4255: oPop 2
4257: oInputChoice 4265
4259: oJumpForward 4273
4261: oJumpForward 4271
4263: oJumpForward 4271
4265: Choice Lookup Table
          13   4263
          17   4259
4270: oEndChoice
4271: oJumpBack 4148
4273: oInput 40
4275: oGetAddrLocal 5
4277: oPushResult
4278: oCall 4089
4280: oPop 1
4282: oGetAddrLocal 6
4284: oPushResult
4285: oGetLocal 2
4287: oPushResult
4288: oNodeVecSize
4289: oPop 1
4291: oAssign
4292: oGetAddrLocal 6
4294: oPushResult
4295: dec
4296: oPop 1
4298: oGetAddrLocal 7
4300: oPushResult
4301: oGetLocal 2
4303: oPushResult
4304: oGetLocal 6
4306: oPushResult
4307: oNodeVecElement
4308: oPop 2
4310: oAssign
4311: oGetLocal 7
4313: oPushResult
4314: oSetResult 36
4316: oPushResult
4317: oGetLocal 5
4319: oPushResult
4320: oNodeSet
4321: oPop 3
4323: oGetAddrLocal 8
4325: oPushResult
4326: oGetLocal 7
4328: oPushResult
4329: oSetResult 37
4331: oPushResult
4332: oNodeGet
4333: oPop 2
4335: oAssign
4336: oGetAddrLocal 9
4338: oPushResult
4339: oGetLocal 8
4341: oPushResult
4342: oSetResult 39
4344: oPushResult
4345: oNodeGetInt
4346: oPop 2
4348: oPushResult
4349: oGetLocal 8
4351: oPushResult
4352: oSetResult 38
4354: oPushResult
4355: oNodeGetInt
4356: oPop 2
4358: oPushResult
4359: subtract
4360: oPop 2
4362: oAssign
4363: oGetAddrLocal 9
4365: oPushResult
4366: inc
4367: oPop 1
4369: oGetLocal 7
4371: oPushResult
4372: oSetResult 17
4374: oPushResult
4375: oGetLocal 9
4377: oPushResult
4378: oGetLocal 5
4380: oPushResult
4381: oSetResult 17
4383: oPushResult
4384: oNodeGetInt
4385: oPop 2
4387: oPushResult
4388: multiply
4389: oPop 2
4391: oPushResult
4392: oNodeSetInt
4393: oPop 3
4395: oGetLocal 7
4397: oPushResult
4398: oTypeAdd
4399: oPop 1
4401: oGetAddrLocal 5
4403: oPushResult
4404: oGetLocal 7
4406: oAssign
4407: oGetLocal 6
4409: oPushResult
4410: equal_zero
4411: oPop 1
4413: oChoice 4419
4415: oJumpForward 4424
4417: oJumpForward 4422
4419: Choice Lookup Table
           1   4415
4422: oJumpBack 4292
4424: oGetParam 1
4426: oPushResult
4427: oGetLocal 2
4429: oPushResult
4430: oSetResult 0
4432: oPushResult
4433: oNodeVecElement
4434: oPop 2
4436: oAssign
4437: oGetLocal 2
4439: oPushResult
4440: oNodeVecDelete
4441: oPop 1
4443: oJumpForward 4597
4445: oGetAddrLocal 10
4447: oPushResult
4448: oCall 4089
4450: oPop 1
4452: oGetParam 1
4454: oPushResult
4455: oGetLocal 10
4457: oPushResult
4458: oCall 12063
4460: oPop 1
4462: oAssign
4463: oJumpForward 4597
4465: oGetParam 1
4467: oPushResult
4468: oSetResult 37
4470: oPushResult
4471: oNodeNew
4472: oPop 1
4474: oAssign
4475: oSetResult -1
4477: oPushResult
4478: oSetResult 2
4480: oPushResult
4481: oScopeBegin
4482: oPop 2
4484: oSetResult 22
4486: oPushResult
4487: oCall 3790
4489: oPop 1
4491: oGetAddrLocal 11
4493: oPushResult
4494: oScopeCurrent
4495: oPushResult
4496: oSetResult 17
4498: oPushResult
4499: oNodeGetInt
4500: oPop 2
4502: oAssign
4503: oGetLocal 11
4505: oPushResult
4506: equal_zero
4507: oPop 1
4509: oChoice 4515
4511: oError 19
4513: oJumpForward 4518
4515: Choice Lookup Table
           1   4511
4518: oInput 36
4520: oGetFromParam 1
4522: oPushResult
4523: oSetResult 40
4525: oPushResult
4526: oScopeCurrent
4527: oPushResult
4528: oNodeSet
4529: oPop 3
4531: oGetFromParam 1
4533: oPushResult
4534: oSetResult 17
4536: oPushResult
4537: oGetLocal 11
4539: oPushResult
4540: oNodeSetInt
4541: oPop 3
4543: oScopeEnd
4544: oGetFromParam 1
4546: oPushResult
4547: oTypeAdd
4548: oPop 1
4550: oJumpForward 4597
4552: oGetParam 1
4554: oPushResult
4555: oCall 4598
4557: oPop 1
4559: oJumpForward 4597
4561: oInput 40
4563: oGetAddrLocal 12
4565: oPushResult
4566: oCall 4089
4568: oPop 1
4570: oError 16
4572: oJumpForward 4597
4574: Choice Lookup Table
          39   4561
          14   4552
          38   4465
          18   4445
          37   4141
           0   4093
4587: oCall 5168
4589: oInput 21
4591: oCall 5168
4593: oCall 5628
4595: oError 16
4597: oReturn
4598: oLocalSpace 11
4600: oGetParam 1
4602: oPushResult
4603: oSetResult 40
4605: oPushResult
4606: oNodeNew
4607: oPop 1
4609: oAssign
4610: oGetAddrLocal 1
4612: oPushResult
4613: oSetResult 0
4615: oAssign
4616: oGetAddrLocal 2
4618: oPushResult
4619: oSetResult 0
4621: oAssign
4622: oGetAddrLocal 3
4624: oPushResult
4625: oSetResult 1
4627: oAssign
4628: oGetAddrLocal 4
4630: oPushResult
4631: oScopeCurrent
4632: oAssign
4633: oSetResult -1
4635: oPushResult
4636: oSetResult 2
4638: oPushResult
4639: oScopeBegin
4640: oPop 2
4642: oInput 0
4644: oGetAddrLocal 5
4646: oPushResult
4647: oSetResult 17
4649: oPushResult
4650: LAST_ID
4651: oPushResult
4652: oCall 12035
4654: oPop 2
4656: oAssign
4657: oGetAddrLocal 6
4659: oPushResult
4660: oSetResult 17
4662: oPushResult
4663: LAST_ID
4664: oPushResult
4665: oCall 12035
4667: oPop 2
4669: oAssign
4670: oGetLocal 5
4672: oPushResult
4673: oSetResult 21
4675: oPushResult
4676: oGetFromParam 1
4678: oPushResult
4679: oNodeSet
4680: oPop 3
4682: oGetLocal 6
4684: oPushResult
4685: oSetResult 21
4687: oPushResult
4688: oGetFromParam 1
4690: oPushResult
4691: oNodeSet
4692: oPop 3
4694: oGetAddrLocal 7
4696: oPushResult
4697: LAST_ID
4698: oPushResult
4699: ID_STRING
4700: oPop 1
4702: oPushResult
4703: oStringAllocLit
4704: oPop 1
4706: oAssign
4707: oGetLocal 5
4709: oPushResult
4710: oSetResult 32
4712: oPushResult
4713: oGetLocal 7
4715: oPushResult
4716: oNodeSetInt
4717: oPop 3
4719: oGetLocal 6
4721: oPushResult
4722: oSetResult 32
4724: oPushResult
4725: oGetLocal 7
4727: oPushResult
4728: oNodeSetInt
4729: oPop 3
4731: oInputChoice 4809
4733: oGetGlobal 6
4735: oPushResult
4736: oTypeSPush
4737: oPop 1
4739: oCall 5168
4741: oCall 5628
4743: oTypeSPop
4744: oGetLocal 2
4746: oPushResult
4747: equal_zero
4748: oPop 1
4750: oChoice 4771
4752: oValueTop
4753: oPushResult
4754: oGetLocal 1
4756: oPushResult
4757: greater
4758: oPop 2
4760: oChoice 4766
4762: oError 26
4764: oJumpForward 4769
4766: Choice Lookup Table
           0   4762
4769: oJumpForward 4774
4771: Choice Lookup Table
           0   4752
4774: oGetLocal 1
4776: oPushResult
4777: oValueTop
4778: oPushResult
4779: equal
4780: oPop 2
4782: oChoice 4798
4784: oGetFromParam 1
4786: oPushResult
4787: oSetResult 43
4789: oPushResult
4790: oSetResult 1
4792: oPushResult
4793: oNodeSetBoolean
4794: oPop 3
4796: oJumpForward 4801
4798: Choice Lookup Table
           0   4784
4801: oGetAddrLocal 1
4803: oPushResult
4804: oValueTop
4805: oAssign
4806: oValuePop
4807: oJumpForward 4814
4809: Choice Lookup Table
           4   4733
           6   4733
4814: oGetLocal 5
4816: oPushResult
4817: oSetResult 22
4819: oPushResult
4820: oGetLocal 1
4822: oPushResult
4823: oNodeSetInt
4824: oPop 3
4826: oGetLocal 6
4828: oPushResult
4829: oSetResult 22
4831: oPushResult
4832: oGetLocal 1
4834: oPushResult
4835: oNodeSetInt
4836: oPop 3
4838: oGetLocal 5
4840: oPushResult
4841: oScopeDeclare
4842: oPop 1
4844: oGetLocal 4
4846: oPushResult
4847: oScopeEnter
4848: oPop 1
4850: oGetLocal 6
4852: oPushResult
4853: oScopeDeclare
4854: oPop 1
4856: oScopeEnd
4857: oGetAddrLocal 1
4859: oPushResult
4860: inc
4861: oPop 1
4863: oGetAddrLocal 2
4865: oPushResult
4866: inc
4867: oPop 1
4869: oInputChoice 4873
4871: oJumpForward 4878
4873: Choice Lookup Table
          13   4871
4876: oJumpForward 4880
4878: oJumpBack 4642
4880: oInput 15
4882: oGetFromParam 1
4884: oPushResult
4885: oSetResult 40
4887: oPushResult
4888: oScopeCurrent
4889: oPushResult
4890: oNodeSet
4891: oPop 3
4893: oGetFromParam 1
4895: oPushResult
4896: oSetResult 17
4898: oPushResult
4899: oSetResult 4
4901: oPushResult
4902: oNodeSetInt
4903: oPop 3
4905: oScopeEnd
4906: oGetGlobal 2
4908: oPushResult
4909: oCall 1990
4911: oPop 1
4913: oPushResult
4914: oCodePush
4915: oPop 1
4917: oGetGlobal 2
4919: oPushResult
4920: oScopeEnter
4921: oPop 1
4923: oGetAddrLocal 8
4925: oPushResult
4926: oGetLocal 2
4928: oPushResult
4929: oSetResult 1
4931: oPushResult
4932: add
4933: oPop 2
4935: oPushResult
4936: oSetResult 16
4938: oPushResult
4939: multiply
4940: oPop 2
4942: oAssign
4943: oGetAddrLocal 9
4945: oPushResult
4946: oGetLocal 8
4948: oPushResult
4949: oSetResult 8
4951: oPushResult
4952: oScopeAlloc
4953: oPop 2
4955: oAssign
4956: oScopeEnd
4957: oGetFromParam 1
4959: oPushResult
4960: oSetResult 42
4962: oPushResult
4963: oGetLocal 9
4965: oPushResult
4966: oNodeSetInt
4967: oPop 3
4969: oGetAddrLocal 10
4971: oPushResult
4972: oGetFromParam 1
4974: oPushResult
4975: oSetResult 40
4977: oPushResult
4978: oNodeGet
4979: oPop 2
4981: oPushResult
4982: oSetResult 15
4984: oPushResult
4985: oNodeGetIter
4986: oPop 2
4988: oAssign
4989: oGetAddrLocal 11
4991: oPushResult
4992: oGetLocal 10
4994: oPushResult
4995: oNodeIterValue
4996: oPop 1
4998: oAssign
4999: oGetLocal 11
5001: oPushResult
5002: oNodeNull
5003: oPop 1
5005: oChoice 5011
5007: oJumpForward 5098
5009: oJumpForward 5014
5011: Choice Lookup Table
           1   5007
5014: oEmit 16
5016: oGetLocal 9
5018: oPushResult
5019: oEmitInt
5020: oPop 1
5022: oEmit 15
5024: oGetLocal 11
5026: oPushResult
5027: oSetResult 22
5029: oPushResult
5030: oNodeGetInt
5031: oPop 2
5033: oPushResult
5034: oEmitInt
5035: oPop 1
5037: oEmit 26
5039: oGetAddrLocal 9
5041: oPushResult
5042: oGetLocal 9
5044: oPushResult
5045: oSetResult 8
5047: oPushResult
5048: add
5049: oPop 2
5051: oAssign
5052: oEmit 16
5054: oGetLocal 9
5056: oPushResult
5057: oEmitInt
5058: oPop 1
5060: oEmit 16
5062: oGetLocal 11
5064: oPushResult
5065: oSetResult 32
5067: oPushResult
5068: oNodeGetInt
5069: oPop 2
5071: oPushResult
5072: oEmitInt
5073: oPop 1
5075: oEmit 28
5077: oGetAddrLocal 9
5079: oPushResult
5080: oGetLocal 9
5082: oPushResult
5083: oSetResult 8
5085: oPushResult
5086: add
5087: oPop 2
5089: oAssign
5090: oGetAddrLocal 10
5092: oPushResult
5093: oNodeIterNext
5094: oPop 1
5096: oJumpBack 4989
5098: oEmit 16
5100: oGetLocal 9
5102: oPushResult
5103: oEmitInt
5104: oPop 1
5106: oEmit 15
5108: oSetResult 0
5110: oPushResult
5111: oEmitInt
5112: oPop 1
5114: oEmit 26
5116: oGetAddrLocal 9
5118: oPushResult
5119: oGetLocal 9
5121: oPushResult
5122: oSetResult 8
5124: oPushResult
5125: add
5126: oPop 2
5128: oAssign
5129: oEmit 16
5131: oGetLocal 9
5133: oPushResult
5134: oEmitInt
5135: oPop 1
5137: oEmit 15
5139: oSetResult 0
5141: oPushResult
5142: oEmitInt
5143: oPop 1
5145: oEmit 28
5147: oGetAddrLocal 9
5149: oPushResult
5150: oGetLocal 9
5152: oPushResult
5153: oSetResult 8
5155: oPushResult
5156: add
5157: oPop 2
5159: oAssign
5160: oCodePop
5161: oGetFromParam 1
5163: oPushResult
5164: oTypeAdd
5165: oPop 1
5167: oReturn
5168: oLocalSpace 0
5170: oCall 5276
5172: oInputChoice 5258
5174: oCall 5299
5176: oCall 5628
5178: oTypeSPop
5179: oGetGlobal 7
5181: oPushResult
5182: oTypeSPush
5183: oPop 1
5185: oValueEqual
5186: oJumpForward 5273
5188: oCall 5276
5190: oCall 5628
5192: oTypeSPop
5193: oGetGlobal 7
5195: oPushResult
5196: oTypeSPush
5197: oPop 1
5199: oValueNotEqual
5200: oJumpForward 5273
5202: oCall 5276
5204: oCall 5628
5206: oTypeSPop
5207: oGetGlobal 7
5209: oPushResult
5210: oTypeSPush
5211: oPop 1
5213: oValueLess
5214: oJumpForward 5273
5216: oCall 5276
5218: oCall 5628
5220: oTypeSPop
5221: oGetGlobal 7
5223: oPushResult
5224: oTypeSPush
5225: oPop 1
5227: oValueGreater
5228: oJumpForward 5273
5230: oCall 5276
5232: oCall 5628
5234: oTypeSPop
5235: oGetGlobal 7
5237: oPushResult
5238: oTypeSPush
5239: oPop 1
5241: oValueLessEqual
5242: oJumpForward 5273
5244: oCall 5276
5246: oCall 5628
5248: oTypeSPop
5249: oGetGlobal 7
5251: oPushResult
5252: oTypeSPush
5253: oPop 1
5255: oValueGreaterEqual
5256: oJumpForward 5273
5258: Choice Lookup Table
          11   5244
          10   5230
           9   5216
           8   5202
           7   5188
           6   5174
5271: oJumpForward 5275
5273: oJumpBack 5172
5275: oReturn
5276: oLocalSpace 0
5278: oCall 5299
5280: oInputChoice 5291
5282: oCall 5615
5284: oCall 5299
5286: oCall 5601
5288: oValueOr
5289: oJumpForward 5296
5291: Choice Lookup Table
          57   5282
5294: oJumpForward 5298
5296: oJumpBack 5280
5298: oReturn
5299: oLocalSpace 0
5301: oCall 5322
5303: oInputChoice 5314
5305: oCall 5615
5307: oCall 5322
5309: oCall 5601
5311: oValueAnd
5312: oJumpForward 5319
5314: Choice Lookup Table
          56   5305
5317: oJumpForward 5321
5319: oJumpBack 5303
5321: oReturn
5322: oLocalSpace 0
5324: oInputChoice 5333
5326: oCall 5322
5328: oCall 5615
5330: oValueNot
5331: oJumpForward 5338
5333: Choice Lookup Table
          58   5326
5336: oCall 5339
5338: oReturn
5339: oLocalSpace 0
5341: oCall 5369
5343: oInputChoice 5359
5345: oCall 5369
5347: oCall 5628
5349: oValueAdd
5350: oJumpForward 5366
5352: oCall 5369
5354: oCall 5628
5356: oValueSub
5357: oJumpForward 5366
5359: Choice Lookup Table
          25   5352
          24   5345
5364: oJumpForward 5368
5366: oJumpBack 5343
5368: oReturn
5369: oLocalSpace 0
5371: oCall 5399
5373: oInputChoice 5389
5375: oCall 5399
5377: oCall 5628
5379: oValueMult
5380: oJumpForward 5396
5382: oCall 5399
5384: oCall 5628
5386: oValueDiv
5387: oJumpForward 5396
5389: Choice Lookup Table
          23   5382
          22   5375
5394: oJumpForward 5398
5396: oJumpBack 5373
5398: oReturn
5399: oLocalSpace 0
5401: oInputChoice 5412
5403: oCall 5420
5405: oJumpForward 5419
5407: oCall 5420
5409: oValueNegate
5410: oJumpForward 5419
5412: Choice Lookup Table
          25   5407
          24   5403
5417: oCall 5420
5419: oReturn
5420: oLocalSpace 1
5422: oInputChoice 5568
5424: TOKEN_VALUE
5425: oPushResult
5426: oValuePush
5427: oPop 1
5429: oGetGlobal 6
5431: oPushResult
5432: oTypeSPush
5433: oPop 1
5435: oJumpForward 5595
5437: TOKEN_VALUE
5438: oPushResult
5439: oValuePush
5440: oPop 1
5442: oGetGlobal 9
5444: oPushResult
5445: oTypeSPush
5446: oPop 1
5448: oJumpForward 5595
5450: oError 16
5452: oSetResult 0
5454: oPushResult
5455: oValuePush
5456: oPop 1
5458: oGetGlobal 14
5460: oPushResult
5461: oTypeSPush
5462: oPop 1
5464: oJumpForward 5595
5466: oCall 5168
5468: oInput 15
5470: oJumpForward 5595
5472: oGetAddrLocal 1
5474: oPushResult
5475: oScopeFindRequire
5476: oAssign
5477: oGetAddrLocal 1
5479: oPushResult
5480: oCall 543
5482: oPop 1
5484: oGetLocal 1
5486: oPushResult
5487: oNodeType
5488: oPop 1
5490: oChoice 5529
5492: oGetLocal 1
5494: oPushResult
5495: oCall 5596
5497: oPop 1
5499: oJumpForward 5550
5501: oGetLocal 1
5503: oPushResult
5504: oSetResult 22
5506: oPushResult
5507: oNodeGetInt
5508: oPop 2
5510: oPushResult
5511: oValuePush
5512: oPop 1
5514: oGetLocal 1
5516: oPushResult
5517: oSetResult 21
5519: oPushResult
5520: oNodeGet
5521: oPop 2
5523: oPushResult
5524: oTypeSPush
5525: oPop 1
5527: oJumpForward 5550
5529: Choice Lookup Table
          17   5501
          16   5501
          14   5492
5536: oError 1
5538: oSetResult 0
5540: oPushResult
5541: oValuePush
5542: oPop 1
5544: oGetGlobal 6
5546: oPushResult
5547: oTypeSPush
5548: oPop 1
5550: oJumpForward 5595
5552: oError 16
5554: oSetResult 0
5556: oPushResult
5557: oValuePush
5558: oPop 1
5560: oGetGlobal 12
5562: oPushResult
5563: oTypeSPush
5564: oPop 1
5566: oJumpForward 5595
5568: Choice Lookup Table
          19   5552
           0   5472
          14   5466
           2   5450
           3   5437
           1   5424
5581: oError 1
5583: oSetResult 0
5585: oPushResult
5586: oValuePush
5587: oPop 1
5589: oGetGlobal 6
5591: oPushResult
5592: oTypeSPush
5593: oPop 1
5595: oReturn
5596: oLocalSpace 0
5598: oError 16
5600: oReturn
5601: oLocalSpace 0
5603: oTypeSNodeType
5604: oChoice 5608
5606: oJumpForward 5613
5608: Choice Lookup Table
          30   5606
5611: oError 8
5613: oTypeSPop
5614: oReturn
5615: oLocalSpace 0
5617: oTypeSNodeType
5618: oChoice 5622
5620: oJumpForward 5627
5622: Choice Lookup Table
          30   5620
5625: oError 8
5627: oReturn
5628: oLocalSpace 1
5630: oGetAddrLocal 1
5632: oPushResult
5633: oTypeSNodeType
5634: oAssign
5635: oTypeSPop
5636: oGetLocal 1
5638: oPushResult
5639: oTypeSNodeType
5640: oPushResult
5641: equal_node_type
5642: oPop 2
5644: oChoice 5682
5646: oTypeSNodeType
5647: oChoice 5673
5649: oGetLocal 1
5651: oChoice 5656
5653: oReturn
5654: oJumpForward 5659
5656: Choice Lookup Table
          34   5653
5659: oJumpForward 5678
5661: oGetLocal 1
5663: oChoice 5668
5665: oReturn
5666: oJumpForward 5671
5668: Choice Lookup Table
          33   5665
5671: oJumpForward 5678
5673: Choice Lookup Table
          34   5661
          33   5649
5678: oError 14
5680: oJumpForward 5685
5682: Choice Lookup Table
           0   5646
5685: oReturn
5686: oLocalSpace 1
5688: oGetAddrLocal 1
5690: oPushResult
5691: oSetResult 0
5693: oAssign
5694: oGetAddrLocal 1
5696: oPushResult
5697: oCall 5847
5699: oPop 1
5701: oGetAddrLocal 1
5703: oPushResult
5704: oCall 5747
5706: oPop 1
5708: oReturn
5709: oLocalSpace 0
5711: oGetParam 1
5713: oPushResult
5714: oCall 5847
5716: oPop 1
5718: oTypeSNodeType
5719: oChoice 5738
5721: oJumpForward 5745
5723: oGetParam 1
5725: oPushResult
5726: oLabelNew
5727: oAssign
5728: oEmit 70
5730: oGetFromParam 1
5732: oPushResult
5733: oEmitLabel
5734: oPop 1
5736: oJumpForward 5745
5738: Choice Lookup Table
          30   5723
          31   5721
5743: oError 8
5745: oTypeSPop
5746: oReturn
5747: oLocalSpace 1
5749: oTypeSNodeType
5750: oChoice 5812
5752: oGetAddrLocal 1
5754: oPushResult
5755: oLabelNew
5756: oAssign
5757: oEmit 15
5759: oSetResult 1
5761: oPushResult
5762: oEmitInt
5763: oPop 1
5765: oEmit 68
5767: oGetLocal 1
5769: oPushResult
5770: oEmitLabel
5771: oPop 1
5773: oEmit 77
5775: oGetFromParam 1
5777: oPushResult
5778: oEmitLabel
5779: oPop 1
5781: oEmit 15
5783: oSetResult 0
5785: oPushResult
5786: oEmitInt
5787: oPop 1
5789: oEmit 77
5791: oGetLocal 1
5793: oPushResult
5794: oEmitLabel
5795: oPop 1
5797: oTypeSPop
5798: oGetGlobal 7
5800: oPushResult
5801: oTypeSPush
5802: oPop 1
5804: oGetParam 1
5806: oPushResult
5807: oSetResult 0
5809: oAssign
5810: oJumpForward 5815
5812: Choice Lookup Table
          31   5752
5815: oReturn
5816: oLocalSpace 0
5818: oTypeSNodeType
5819: oChoice 5843
5821: oGetParam 1
5823: oPushResult
5824: oLabelNew
5825: oAssign
5826: oEmit 70
5828: oGetFromParam 1
5830: oPushResult
5831: oEmitLabel
5832: oPop 1
5834: oTypeSPop
5835: oGetGlobal 8
5837: oPushResult
5838: oTypeSPush
5839: oPop 1
5841: oJumpForward 5846
5843: Choice Lookup Table
          30   5821
5846: oReturn
5847: oLocalSpace 0
5849: oGetParam 1
5851: oPushResult
5852: oCall 6380
5854: oPop 1
5856: oInputChoice 6362
5858: oGetParam 1
5860: oPushResult
5861: oCall 5747
5863: oPop 1
5865: oCall 11954
5867: oGetParam 1
5869: oPushResult
5870: oCall 6380
5872: oPop 1
5874: oGetParam 1
5876: oPushResult
5877: oCall 5747
5879: oPop 1
5881: oCall 11954
5883: oCall 11823
5885: oTypeSNodeType
5886: oChoice 5914
5888: oEmit 43
5890: oJumpForward 5933
5892: oEmit 49
5894: oJumpForward 5933
5896: oEmit 55
5898: oJumpForward 5933
5900: oCall 9168
5902: oEmit 15
5904: oSetResult 0
5906: oPushResult
5907: oEmitInt
5908: oPop 1
5910: oEmit 49
5912: oJumpForward 5933
5914: Choice Lookup Table
          38   5900
          39   5900
          34   5896
          33   5896
          40   5892
          28   5892
          32   5888
          30   5888
5931: oError 17
5933: oTypeSPop
5934: oGetGlobal 7
5936: oPushResult
5937: oTypeSPush
5938: oPop 1
5940: oJumpForward 6377
5942: oGetParam 1
5944: oPushResult
5945: oCall 5747
5947: oPop 1
5949: oCall 11954
5951: oGetParam 1
5953: oPushResult
5954: oCall 6380
5956: oPop 1
5958: oGetParam 1
5960: oPushResult
5961: oCall 5747
5963: oPop 1
5965: oCall 11954
5967: oCall 11823
5969: oTypeSNodeType
5970: oChoice 5998
5972: oEmit 44
5974: oJumpForward 6017
5976: oEmit 50
5978: oJumpForward 6017
5980: oEmit 56
5982: oJumpForward 6017
5984: oCall 9168
5986: oEmit 15
5988: oSetResult 0
5990: oPushResult
5991: oEmitInt
5992: oPop 1
5994: oEmit 50
5996: oJumpForward 6017
5998: Choice Lookup Table
          38   5984
          39   5984
          34   5980
          33   5980
          40   5976
          28   5976
          32   5972
          30   5972
6015: oError 17
6017: oTypeSPop
6018: oGetGlobal 7
6020: oPushResult
6021: oTypeSPush
6022: oPop 1
6024: oJumpForward 6377
6026: oGetParam 1
6028: oPushResult
6029: oCall 5747
6031: oPop 1
6033: oCall 11954
6035: oGetParam 1
6037: oPushResult
6038: oCall 6380
6040: oPop 1
6042: oGetParam 1
6044: oPushResult
6045: oCall 5747
6047: oPop 1
6049: oCall 11954
6051: oCall 11823
6053: oTypeSNodeType
6054: oChoice 6082
6056: oEmit 46
6058: oJumpForward 6101
6060: oEmit 52
6062: oJumpForward 6101
6064: oEmit 58
6066: oJumpForward 6101
6068: oCall 9168
6070: oEmit 15
6072: oSetResult 0
6074: oPushResult
6075: oEmitInt
6076: oPop 1
6078: oEmit 52
6080: oJumpForward 6101
6082: Choice Lookup Table
          38   6068
          39   6068
          34   6064
          33   6064
          40   6060
          28   6060
          32   6056
          30   6056
6099: oError 17
6101: oTypeSPop
6102: oGetGlobal 7
6104: oPushResult
6105: oTypeSPush
6106: oPop 1
6108: oJumpForward 6377
6110: oGetParam 1
6112: oPushResult
6113: oCall 5747
6115: oPop 1
6117: oCall 11954
6119: oGetParam 1
6121: oPushResult
6122: oCall 6380
6124: oPop 1
6126: oGetParam 1
6128: oPushResult
6129: oCall 5747
6131: oPop 1
6133: oCall 11954
6135: oCall 11823
6137: oTypeSNodeType
6138: oChoice 6166
6140: oEmit 45
6142: oJumpForward 6185
6144: oEmit 51
6146: oJumpForward 6185
6148: oEmit 57
6150: oJumpForward 6185
6152: oCall 9168
6154: oEmit 15
6156: oSetResult 0
6158: oPushResult
6159: oEmitInt
6160: oPop 1
6162: oEmit 51
6164: oJumpForward 6185
6166: Choice Lookup Table
          38   6152
          39   6152
          34   6148
          33   6148
          40   6144
          28   6144
          32   6140
          30   6140
6183: oError 17
6185: oTypeSPop
6186: oGetGlobal 7
6188: oPushResult
6189: oTypeSPush
6190: oPop 1
6192: oJumpForward 6377
6194: oGetParam 1
6196: oPushResult
6197: oCall 5747
6199: oPop 1
6201: oCall 11954
6203: oGetParam 1
6205: oPushResult
6206: oCall 6380
6208: oPop 1
6210: oGetParam 1
6212: oPushResult
6213: oCall 5747
6215: oPop 1
6217: oCall 11954
6219: oCall 11823
6221: oTypeSNodeType
6222: oChoice 6250
6224: oEmit 48
6226: oJumpForward 6269
6228: oEmit 54
6230: oJumpForward 6269
6232: oEmit 60
6234: oJumpForward 6269
6236: oCall 9168
6238: oEmit 15
6240: oSetResult 0
6242: oPushResult
6243: oEmitInt
6244: oPop 1
6246: oEmit 54
6248: oJumpForward 6269
6250: Choice Lookup Table
          38   6236
          39   6236
          34   6232
          33   6232
          40   6228
          28   6228
          32   6224
          30   6224
6267: oError 17
6269: oTypeSPop
6270: oGetGlobal 7
6272: oPushResult
6273: oTypeSPush
6274: oPop 1
6276: oJumpForward 6377
6278: oGetParam 1
6280: oPushResult
6281: oCall 5747
6283: oPop 1
6285: oCall 11954
6287: oGetParam 1
6289: oPushResult
6290: oCall 6380
6292: oPop 1
6294: oGetParam 1
6296: oPushResult
6297: oCall 5747
6299: oPop 1
6301: oCall 11954
6303: oCall 11823
6305: oTypeSNodeType
6306: oChoice 6334
6308: oEmit 47
6310: oJumpForward 6353
6312: oEmit 53
6314: oJumpForward 6353
6316: oEmit 59
6318: oJumpForward 6353
6320: oCall 9168
6322: oEmit 15
6324: oSetResult 0
6326: oPushResult
6327: oEmitInt
6328: oPop 1
6330: oEmit 53
6332: oJumpForward 6353
6334: Choice Lookup Table
          38   6320
          39   6320
          34   6316
          33   6316
          40   6312
          28   6312
          32   6308
          30   6308
6351: oError 17
6353: oTypeSPop
6354: oGetGlobal 7
6356: oPushResult
6357: oTypeSPush
6358: oPop 1
6360: oJumpForward 6377
6362: Choice Lookup Table
          11   6278
          10   6194
           9   6110
           8   6026
           7   5942
           6   5858
6375: oJumpForward 6379
6377: oJumpBack 5856
6379: oReturn
6380: oLocalSpace 1
6382: oGetAddrLocal 1
6384: oPushResult
6385: oSetResult 0
6387: oAssign
6388: oGetParam 1
6390: oPushResult
6391: oCall 6560
6393: oPop 1
6395: oInputChoice 6528
6397: oTypeSNodeType
6398: oChoice 6469
6400: oGetLocal 1
6402: oPushResult
6403: oSetResult 0
6405: oPushResult
6406: equal_label
6407: oPop 2
6409: oChoice 6418
6411: oGetAddrLocal 1
6413: oPushResult
6414: oLabelNew
6415: oAssign
6416: oJumpForward 6421
6418: Choice Lookup Table
           1   6411
6421: oEmit 68
6423: oGetLocal 1
6425: oPushResult
6426: oEmitLabel
6427: oPop 1
6429: oJumpForward 6476
6431: oGetParam 1
6433: oPushResult
6434: oCall 5816
6436: oPop 1
6438: oGetLocal 1
6440: oPushResult
6441: oSetResult 0
6443: oPushResult
6444: equal_label
6445: oPop 2
6447: oChoice 6456
6449: oGetAddrLocal 1
6451: oPushResult
6452: oLabelNew
6453: oAssign
6454: oJumpForward 6459
6456: Choice Lookup Table
           1   6449
6459: oEmit 68
6461: oGetLocal 1
6463: oPushResult
6464: oEmitLabel
6465: oPop 1
6467: oJumpForward 6476
6469: Choice Lookup Table
          30   6431
          31   6400
6474: oError 8
6476: oTypeSPop
6477: oEmit 77
6479: oGetFromParam 1
6481: oPushResult
6482: oEmitLabel
6483: oPop 1
6485: oGetParam 1
6487: oPushResult
6488: oSetResult 0
6490: oAssign
6491: oGetParam 1
6493: oPushResult
6494: oCall 6560
6496: oPop 1
6498: oTypeSNodeType
6499: oChoice 6512
6501: oJumpForward 6519
6503: oGetParam 1
6505: oPushResult
6506: oCall 5816
6508: oPop 1
6510: oJumpForward 6519
6512: Choice Lookup Table
          30   6503
          31   6501
6517: oError 8
6519: oTypeSPop
6520: oGetGlobal 8
6522: oPushResult
6523: oTypeSPush
6524: oPop 1
6526: oJumpForward 6533
6528: Choice Lookup Table
          57   6397
6531: oJumpForward 6535
6533: oJumpBack 6395
6535: oGetLocal 1
6537: oPushResult
6538: oSetResult 0
6540: oPushResult
6541: equal_label
6542: oPop 2
6544: oChoice 6556
6546: oEmit 77
6548: oGetLocal 1
6550: oPushResult
6551: oEmitLabel
6552: oPop 1
6554: oJumpForward 6559
6556: Choice Lookup Table
           0   6546
6559: oReturn
6560: oLocalSpace 2
6562: oGetAddrLocal 1
6564: oPushResult
6565: oSetResult 0
6567: oAssign
6568: oGetParam 1
6570: oPushResult
6571: oCall 6698
6573: oPop 1
6575: oInputChoice 6690
6577: oTypeSNodeType
6578: oChoice 6591
6580: oJumpForward 6598
6582: oGetParam 1
6584: oPushResult
6585: oCall 5816
6587: oPop 1
6589: oJumpForward 6598
6591: Choice Lookup Table
          30   6582
          31   6580
6596: oError 8
6598: oTypeSPop
6599: oGetLocal 1
6601: oPushResult
6602: oSetResult 0
6604: oPushResult
6605: equal_label
6606: oPop 2
6608: oChoice 6637
6610: oGetAddrLocal 1
6612: oPushResult
6613: oLabelNew
6614: oAssign
6615: oEmit 78
6617: oGetFromParam 1
6619: oPushResult
6620: oEmitLabel
6621: oPop 1
6623: oGetLocal 1
6625: oPushResult
6626: oEmitLabel
6627: oPop 1
6629: oGetParam 1
6631: oPushResult
6632: oGetLocal 1
6634: oAssign
6635: oJumpForward 6640
6637: Choice Lookup Table
           1   6610
6640: oGetAddrLocal 2
6642: oPushResult
6643: oSetResult 0
6645: oAssign
6646: oGetAddrLocal 2
6648: oPushResult
6649: oCall 6698
6651: oPop 1
6653: oTypeSNodeType
6654: oChoice 6667
6656: oJumpForward 6674
6658: oGetAddrLocal 2
6660: oPushResult
6661: oCall 5816
6663: oPop 1
6665: oJumpForward 6674
6667: Choice Lookup Table
          30   6658
          31   6656
6672: oError 8
6674: oEmit 78
6676: oGetLocal 2
6678: oPushResult
6679: oEmitLabel
6680: oPop 1
6682: oGetLocal 1
6684: oPushResult
6685: oEmitLabel
6686: oPop 1
6688: oJumpForward 6695
6690: Choice Lookup Table
          56   6577
6693: oJumpForward 6697
6695: oJumpBack 6575
6697: oReturn
6698: oLocalSpace 1
6700: oInputChoice 6754
6702: oGetAddrLocal 1
6704: oPushResult
6705: oSetResult 0
6707: oAssign
6708: oGetAddrLocal 1
6710: oPushResult
6711: oCall 6698
6713: oPop 1
6715: oTypeSNodeType
6716: oChoice 6745
6718: oGetParam 1
6720: oPushResult
6721: oLabelNew
6722: oAssign
6723: oEmit 68
6725: oGetFromParam 1
6727: oPushResult
6728: oEmitLabel
6729: oPop 1
6731: oEmit 77
6733: oGetLocal 1
6735: oPushResult
6736: oEmitLabel
6737: oPop 1
6739: oJumpForward 6752
6741: oEmit 42
6743: oJumpForward 6752
6745: Choice Lookup Table
          30   6741
          31   6718
6750: oError 8
6752: oJumpForward 6764
6754: Choice Lookup Table
          58   6702
6757: oGetParam 1
6759: oPushResult
6760: oCall 6765
6762: oPop 1
6764: oReturn
6765: oLocalSpace 2
6767: oGetAddrLocal 1
6769: oPushResult
6770: oSetResult 1
6772: oAssign
6773: oGetParam 1
6775: oPushResult
6776: oCall 7001
6778: oPop 1
6780: oInputChoice 6991
6782: oTypeSNodeType
6783: oChoice 6906
6785: oCall 11908
6787: oGetParam 1
6789: oPushResult
6790: oCall 7001
6792: oPop 1
6794: oTypeSNodeType
6795: oChoice 6803
6797: oEmit 22
6799: oCall 8584
6801: oJumpForward 6812
6803: Choice Lookup Table
          34   6797
          33   6797
6808: oCall 11928
6810: oEmit 37
6812: oJumpForward 6923
6814: oGetLocal 1
6816: oChoice 6832
6818: oGetAddrLocal 2
6820: oPushResult
6821: oCall 8951
6823: oAssign
6824: oGetAddrLocal 1
6826: oPushResult
6827: oSetResult 0
6829: oAssign
6830: oJumpForward 6835
6832: Choice Lookup Table
           1   6818
6835: oGetParam 1
6837: oPushResult
6838: oCall 7001
6840: oPop 1
6842: oTypeSNodeType
6843: oChoice 6881
6845: oCall 9060
6847: oEmit 17
6849: oGetLocal 2
6851: oPushResult
6852: oEmitInt
6853: oPop 1
6855: oGetGlobal 14
6857: oPushResult
6858: oTypeSPush
6859: oPop 1
6861: oJumpForward 6891
6863: oCall 9114
6865: oEmit 17
6867: oGetLocal 2
6869: oPushResult
6870: oEmitInt
6871: oPop 1
6873: oGetGlobal 14
6875: oPushResult
6876: oTypeSPush
6877: oPop 1
6879: oJumpForward 6891
6881: Choice Lookup Table
          32   6863
          38   6845
          39   6845
6888: oError 14
6890: oTypeSPop
6891: oJumpForward 6923
6893: oGetParam 1
6895: oPushResult
6896: oCall 7001
6898: oPop 1
6900: oCall 11908
6902: oCall 8584
6904: oJumpForward 6923
6906: Choice Lookup Table
          34   6893
          33   6893
          32   6814
          38   6814
          39   6814
          29   6785
          28   6785
6921: oError 17
6923: oJumpForward 6998
6925: oTypeSNodeType
6926: oChoice 6978
6928: oCall 11908
6930: oGetParam 1
6932: oPushResult
6933: oCall 7001
6935: oPop 1
6937: oCall 11928
6939: oEmit 40
6941: oJumpForward 6989
6943: oGetParam 1
6945: oPushResult
6946: oCall 7001
6948: oPop 1
6950: oTypeSNodeType
6951: oChoice 6965
6953: oCall 11908
6955: oCall 8640
6957: oJumpForward 6976
6959: oCall 11823
6961: oCall 8696
6963: oJumpForward 6976
6965: Choice Lookup Table
          34   6959
          33   6959
          29   6953
          28   6953
6974: oError 17
6976: oJumpForward 6989
6978: Choice Lookup Table
          34   6943
          33   6943
          29   6928
          28   6928
6987: oError 17
6989: oJumpForward 6998
6991: Choice Lookup Table
          25   6925
          24   6782
6996: oJumpForward 7000
6998: oJumpBack 6780
7000: oReturn
7001: oLocalSpace 0
7003: oGetParam 1
7005: oPushResult
7006: oCall 7052
7008: oPop 1
7010: oInputChoice 7042
7012: oCall 11908
7014: oGetParam 1
7016: oPushResult
7017: oCall 7052
7019: oPop 1
7021: oCall 11928
7023: oEmit 34
7025: oJumpForward 7049
7027: oCall 11908
7029: oGetParam 1
7031: oPushResult
7032: oCall 7052
7034: oPop 1
7036: oCall 11928
7038: oEmit 35
7040: oJumpForward 7049
7042: Choice Lookup Table
          23   7027
          22   7012
7047: oJumpForward 7051
7049: oJumpBack 7010
7051: oReturn
7052: oLocalSpace 0
7054: oInputChoice 7080
7056: oGetParam 1
7058: oPushResult
7059: oCall 7093
7061: oPop 1
7063: oCall 11928
7065: oJumpForward 7092
7067: oGetParam 1
7069: oPushResult
7070: oCall 7093
7072: oPop 1
7074: oCall 11928
7076: oEmit 41
7078: oJumpForward 7092
7080: Choice Lookup Table
          25   7067
          24   7056
7085: oGetParam 1
7087: oPushResult
7088: oCall 7093
7090: oPop 1
7092: oReturn
7093: oLocalSpace 6
7095: oInputChoice 7349
7097: oEmit 15
7099: TOKEN_VALUE
7100: oPushResult
7101: oEmitInt
7102: oPop 1
7104: oGetGlobal 6
7106: oPushResult
7107: oTypeSPush
7108: oPop 1
7110: oJumpForward 7370
7112: oEmit 15
7114: TOKEN_VALUE
7115: oPushResult
7116: oEmitInt
7117: oPop 1
7119: oGetGlobal 9
7121: oPushResult
7122: oTypeSPush
7123: oPop 1
7125: oJumpForward 7370
7127: oGetParam 1
7129: oPushResult
7130: oCall 5847
7132: oPop 1
7134: oInput 15
7136: oJumpForward 7370
7138: oGetAddrLocal 1
7140: oPushResult
7141: CURRENT_STRLIT
7142: oPushResult
7143: oStringAllocShortStringLit
7144: oPop 1
7146: oAssign
7147: oEmit 16
7149: oGetLocal 1
7151: oPushResult
7152: oEmitInt
7153: oPop 1
7155: oGetGlobal 13
7157: oPushResult
7158: oTypeSPush
7159: oPop 1
7161: oCall 8182
7163: oCall 8128
7165: oJumpForward 7370
7167: oGetAddrLocal 2
7169: oPushResult
7170: oScopeFindRequire
7171: oAssign
7172: oGetAddrLocal 2
7174: oPushResult
7175: oCall 543
7177: oPop 1
7179: oGetLocal 2
7181: oPushResult
7182: oNodeType
7183: oPop 1
7185: oChoice 7273
7187: oGetLocal 2
7189: oPushResult
7190: oCall 9346
7192: oPop 1
7194: oJumpForward 7298
7196: oGetLocal 2
7198: oPushResult
7199: oCall 9966
7201: oPop 1
7203: oJumpForward 7298
7205: oGetAddrLocal 3
7207: oPushResult
7208: oGetLocal 2
7210: oPushResult
7211: oSetResult 21
7213: oPushResult
7214: oNodeGet
7215: oPop 2
7217: oAssign
7218: oGetLocal 3
7220: oPushResult
7221: oTypeSPush
7222: oPop 1
7224: oTypeSNodeType
7225: oChoice 7249
7227: oEmit 15
7229: oGetLocal 2
7231: oPushResult
7232: oCall 12337
7234: oPop 1
7236: oJumpForward 7262
7238: oEmit 15
7240: oGetLocal 2
7242: oPushResult
7243: oCall 12337
7245: oPop 1
7247: oJumpForward 7262
7249: Choice Lookup Table
          34   7238
          33   7238
          30   7227
          40   7227
          28   7227
7260: oError 16
7262: oJumpForward 7298
7264: oGetLocal 2
7266: oPushResult
7267: oCall 7371
7269: oPop 1
7271: oJumpForward 7298
7273: Choice Lookup Table
          24   7264
          23   7264
          21   7264
          20   7264
          17   7205
          16   7205
          14   7196
          13   7187
7290: oError 6
7292: oGetGlobal 6
7294: oPushResult
7295: oTypeSPush
7296: oPop 1
7298: oJumpForward 7370
7300: oInput 0
7302: oGetAddrLocal 4
7304: oPushResult
7305: oScopeFindRequire
7306: oAssign
7307: oGetAddrLocal 4
7309: oPushResult
7310: oCall 543
7312: oPop 1
7314: oGetLocal 4
7316: oPushResult
7317: oSetResult 0
7319: oPushResult
7320: oCall 10661
7322: oPop 2
7324: oGetAddrLocal 5
7326: oPushResult
7327: oTypeSTop
7328: oAssign
7329: oTypeSPop
7330: oGetAddrLocal 6
7332: oPushResult
7333: oGetLocal 5
7335: oPushResult
7336: oCall 12063
7338: oPop 1
7340: oAssign
7341: oGetLocal 6
7343: oPushResult
7344: oTypeSPush
7345: oPop 1
7347: oJumpForward 7370
7349: Choice Lookup Table
          19   7300
           0   7167
           2   7138
          14   7127
           3   7112
           1   7097
7362: oError 6
7364: oGetGlobal 6
7366: oPushResult
7367: oTypeSPush
7368: oPop 1
7370: oReturn
7371: oLocalSpace 2
7373: oGetAddrLocal 1
7375: oPushResult
7376: oGetParam 1
7378: oPushResult
7379: oSetResult 21
7381: oPushResult
7382: oNodeGet
7383: oPop 2
7385: oAssign
7386: oGetAddrLocal 2
7388: oPushResult
7389: oGetParam 1
7391: oPushResult
7392: oCall 11805
7394: oPop 1
7396: oAssign
7397: oGetLocal 1
7399: oPushResult
7400: oTypeSPush
7401: oPop 1
7403: oTypeSNodeType
7404: oChoice 8103
7406: oGetParam 1
7408: oPushResult
7409: oNodeType
7410: oPop 1
7412: oChoice 7558
7414: oEmit 0
7416: oGetParam 1
7418: oPushResult
7419: oCall 12337
7421: oPop 1
7423: oJumpForward 7568
7425: oGetLocal 2
7427: oPushResult
7428: equal_zero
7429: oPop 1
7431: oChoice 7444
7433: oEmit 3
7435: oGetParam 1
7437: oPushResult
7438: oCall 12337
7440: oPop 1
7442: oJumpForward 7462
7444: Choice Lookup Table
           1   7433
7447: oEmit 9
7449: oGetLocal 2
7451: oPushResult
7452: oEmitInt
7453: oPop 1
7455: oGetParam 1
7457: oPushResult
7458: oCall 12337
7460: oPop 1
7462: oJumpForward 7568
7464: oGetParam 1
7466: oPushResult
7467: oSetResult 33
7469: oPushResult
7470: oNodeGetBoolean
7471: oPop 2
7473: oChoice 7516
7475: oGetLocal 2
7477: oPushResult
7478: equal_zero
7479: oPop 1
7481: oChoice 7494
7483: oEmit 8
7485: oGetParam 1
7487: oPushResult
7488: oCall 12337
7490: oPop 1
7492: oJumpForward 7512
7494: Choice Lookup Table
           1   7483
7497: oEmit 14
7499: oGetLocal 2
7501: oPushResult
7502: oEmitInt
7503: oPop 1
7505: oGetParam 1
7507: oPushResult
7508: oCall 12337
7510: oPop 1
7512: oEmit 23
7514: oJumpForward 7556
7516: Choice Lookup Table
           1   7475
7519: oGetLocal 2
7521: oPushResult
7522: equal_zero
7523: oPop 1
7525: oChoice 7538
7527: oEmit 6
7529: oGetParam 1
7531: oPushResult
7532: oCall 12337
7534: oPop 1
7536: oJumpForward 7556
7538: Choice Lookup Table
           1   7527
7541: oEmit 12
7543: oGetLocal 2
7545: oPushResult
7546: oEmitInt
7547: oPop 1
7549: oGetParam 1
7551: oPushResult
7552: oCall 12337
7554: oPop 1
7556: oJumpForward 7568
7558: Choice Lookup Table
          23   7464
          21   7425
          24   7414
          20   7414
7567: oEndChoice
7568: oJumpForward 8127
7570: oGetParam 1
7572: oPushResult
7573: oNodeType
7574: oPop 1
7576: oChoice 7722
7578: oEmit 1
7580: oGetParam 1
7582: oPushResult
7583: oCall 12337
7585: oPop 1
7587: oJumpForward 7732
7589: oGetLocal 2
7591: oPushResult
7592: equal_zero
7593: oPop 1
7595: oChoice 7608
7597: oEmit 4
7599: oGetParam 1
7601: oPushResult
7602: oCall 12337
7604: oPop 1
7606: oJumpForward 7626
7608: Choice Lookup Table
           1   7597
7611: oEmit 10
7613: oGetLocal 2
7615: oPushResult
7616: oEmitInt
7617: oPop 1
7619: oGetParam 1
7621: oPushResult
7622: oCall 12337
7624: oPop 1
7626: oJumpForward 7732
7628: oGetParam 1
7630: oPushResult
7631: oSetResult 33
7633: oPushResult
7634: oNodeGetBoolean
7635: oPop 2
7637: oChoice 7680
7639: oGetLocal 2
7641: oPushResult
7642: equal_zero
7643: oPop 1
7645: oChoice 7658
7647: oEmit 8
7649: oGetParam 1
7651: oPushResult
7652: oCall 12337
7654: oPop 1
7656: oJumpForward 7676
7658: Choice Lookup Table
           1   7647
7661: oEmit 14
7663: oGetLocal 2
7665: oPushResult
7666: oEmitInt
7667: oPop 1
7669: oGetParam 1
7671: oPushResult
7672: oCall 12337
7674: oPop 1
7676: oEmit 24
7678: oJumpForward 7720
7680: Choice Lookup Table
           1   7639
7683: oGetLocal 2
7685: oPushResult
7686: equal_zero
7687: oPop 1
7689: oChoice 7702
7691: oEmit 7
7693: oGetParam 1
7695: oPushResult
7696: oCall 12337
7698: oPop 1
7700: oJumpForward 7720
7702: Choice Lookup Table
           1   7691
7705: oEmit 13
7707: oGetLocal 2
7709: oPushResult
7710: oEmitInt
7711: oPop 1
7713: oGetParam 1
7715: oPushResult
7716: oCall 12337
7718: oPop 1
7720: oJumpForward 7732
7722: Choice Lookup Table
          23   7628
          21   7589
          24   7578
          20   7578
7731: oEndChoice
7732: oJumpForward 8127
7734: oError 16
7736: oJumpForward 8127
7738: oGetParam 1
7740: oPushResult
7741: oNodeType
7742: oPop 1
7744: oChoice 7890
7746: oEmit 2
7748: oGetParam 1
7750: oPushResult
7751: oCall 12337
7753: oPop 1
7755: oJumpForward 7900
7757: oGetLocal 2
7759: oPushResult
7760: equal_zero
7761: oPop 1
7763: oChoice 7776
7765: oEmit 5
7767: oGetParam 1
7769: oPushResult
7770: oCall 12337
7772: oPop 1
7774: oJumpForward 7794
7776: Choice Lookup Table
           1   7765
7779: oEmit 11
7781: oGetLocal 2
7783: oPushResult
7784: oEmitInt
7785: oPop 1
7787: oGetParam 1
7789: oPushResult
7790: oCall 12337
7792: oPop 1
7794: oJumpForward 7900
7796: oGetParam 1
7798: oPushResult
7799: oSetResult 33
7801: oPushResult
7802: oNodeGetBoolean
7803: oPop 2
7805: oChoice 7848
7807: oGetLocal 2
7809: oPushResult
7810: equal_zero
7811: oPop 1
7813: oChoice 7826
7815: oEmit 8
7817: oGetParam 1
7819: oPushResult
7820: oCall 12337
7822: oPop 1
7824: oJumpForward 7844
7826: Choice Lookup Table
           1   7815
7829: oEmit 14
7831: oGetLocal 2
7833: oPushResult
7834: oEmitInt
7835: oPop 1
7837: oGetParam 1
7839: oPushResult
7840: oCall 12337
7842: oPop 1
7844: oEmit 25
7846: oJumpForward 7888
7848: Choice Lookup Table
           1   7807
7851: oGetLocal 2
7853: oPushResult
7854: equal_zero
7855: oPop 1
7857: oChoice 7870
7859: oEmit 8
7861: oGetParam 1
7863: oPushResult
7864: oCall 12337
7866: oPop 1
7868: oJumpForward 7888
7870: Choice Lookup Table
           1   7859
7873: oEmit 14
7875: oGetLocal 2
7877: oPushResult
7878: oEmitInt
7879: oPop 1
7881: oGetParam 1
7883: oPushResult
7884: oCall 12337
7886: oPop 1
7888: oJumpForward 7900
7890: Choice Lookup Table
          23   7796
          21   7757
          24   7746
          20   7746
7899: oEndChoice
7900: oInputChoice 7930
7902: oTypeSPop
7903: oGetLocal 1
7905: oPushResult
7906: oSetResult 36
7908: oPushResult
7909: oNodeGet
7910: oPop 2
7912: oPushResult
7913: oTypeSPush
7914: oPop 1
7916: oCall 8182
7918: oCall 8128
7920: oJumpForward 7935
7922: oCall 8377
7924: oCall 8182
7926: oCall 8128
7928: oJumpForward 7935
7930: Choice Lookup Table
          16   7922
          18   7902
7935: oJumpForward 8127
7937: oGetParam 1
7939: oPushResult
7940: oNodeType
7941: oPop 1
7943: oChoice 8087
7945: oEmit 16
7947: oGetParam 1
7949: oPushResult
7950: oCall 12337
7952: oPop 1
7954: oJumpForward 8097
7956: oGetLocal 2
7958: oPushResult
7959: equal_zero
7960: oPop 1
7962: oChoice 7975
7964: oEmit 17
7966: oGetParam 1
7968: oPushResult
7969: oCall 12337
7971: oPop 1
7973: oJumpForward 7993
7975: Choice Lookup Table
           1   7964
7978: oEmit 20
7980: oGetLocal 2
7982: oPushResult
7983: oEmitInt
7984: oPop 1
7986: oGetParam 1
7988: oPushResult
7989: oCall 12337
7991: oPop 1
7993: oJumpForward 8097
7995: oGetParam 1
7997: oPushResult
7998: oSetResult 33
8000: oPushResult
8001: oNodeGetBoolean
8002: oPop 2
8004: oChoice 8045
8006: oGetLocal 2
8008: oPushResult
8009: equal_zero
8010: oPop 1
8012: oChoice 8025
8014: oEmit 8
8016: oGetParam 1
8018: oPushResult
8019: oCall 12337
8021: oPop 1
8023: oJumpForward 8043
8025: Choice Lookup Table
           1   8014
8028: oEmit 14
8030: oGetLocal 2
8032: oPushResult
8033: oEmitInt
8034: oPop 1
8036: oGetParam 1
8038: oPushResult
8039: oCall 12337
8041: oPop 1
8043: oJumpForward 8085
8045: Choice Lookup Table
           1   8006
8048: oGetLocal 2
8050: oPushResult
8051: equal_zero
8052: oPop 1
8054: oChoice 8067
8056: oEmit 18
8058: oGetParam 1
8060: oPushResult
8061: oCall 12337
8063: oPop 1
8065: oJumpForward 8085
8067: Choice Lookup Table
           1   8056
8070: oEmit 21
8072: oGetLocal 2
8074: oPushResult
8075: oEmitInt
8076: oPop 1
8078: oGetParam 1
8080: oPushResult
8081: oCall 12337
8083: oPop 1
8085: oJumpForward 8097
8087: Choice Lookup Table
          23   7995
          21   7956
          24   7945
          20   7945
8096: oEndChoice
8097: oCall 8182
8099: oCall 8128
8101: oJumpForward 8127
8103: Choice Lookup Table
          39   7937
          37   7937
          35   7937
          34   7738
          33   7738
          27   7734
          32   7570
          29   7570
          30   7570
          40   7406
          28   7406
8126: oEndChoice
8127: oReturn
8128: oLocalSpace 0
8130: oTypeSNodeType
8131: oChoice 8155
8133: oEmit 23
8135: oJumpForward 8181
8137: oEmit 24
8139: oJumpForward 8181
8141: oError 16
8143: oJumpForward 8181
8145: oEmit 25
8147: oJumpForward 8181
8149: oError 29
8151: oJumpForward 8181
8153: oJumpForward 8181
8155: Choice Lookup Table
          39   8153
          38   8153
          37   8153
          35   8153
          34   8149
          33   8145
          27   8141
          32   8137
          29   8137
          30   8137
          40   8133
          28   8133
8180: oEndChoice
8181: oReturn
8182: oLocalSpace 0
8184: oInputChoice 8222
8186: oTypeSNodeType
8187: oChoice 8201
8189: oCall 8234
8191: oJumpForward 8212
8193: oCall 8377
8195: oJumpForward 8212
8197: oCall 8456
8199: oJumpForward 8212
8201: Choice Lookup Table
          39   8197
          38   8197
          33   8193
          35   8189
8210: oError 10
8212: oJumpForward 8231
8214: oCall 8486
8216: oJumpForward 8231
8218: oCall 8759
8220: oJumpForward 8231
8222: Choice Lookup Table
          18   8218
          20   8214
          16   8186
8229: oJumpForward 8233
8231: oJumpBack 8184
8233: oReturn
8234: oLocalSpace 3
8236: oTypeSNodeType
8237: oChoice 8241
8239: oJumpForward 8246
8241: Choice Lookup Table
          35   8239
8244: oError 10
8246: oTypeSNodeType
8247: oChoice 8251
8249: oJumpForward 8256
8251: Choice Lookup Table
          35   8249
8254: oError 13
8256: oGetAddrLocal 1
8258: oPushResult
8259: oTypeSTop
8260: oPushResult
8261: oSetResult 37
8263: oPushResult
8264: oNodeGet
8265: oPop 2
8267: oPushResult
8268: oCall 12147
8270: oPop 1
8272: oAssign
8273: oGetAddrLocal 2
8275: oPushResult
8276: oTypeSTop
8277: oPushResult
8278: oSetResult 36
8280: oPushResult
8281: oNodeGet
8282: oPop 2
8284: oAssign
8285: oTypeSPop
8286: oGetLocal 2
8288: oPushResult
8289: oTypeSPush
8290: oPop 1
8292: oCall 5686
8294: oCall 11881
8296: oGetLocal 1
8298: oPushResult
8299: equal_zero
8300: oPop 1
8302: oChoice 8316
8304: oEmit 15
8306: oGetLocal 1
8308: oPushResult
8309: oEmitInt
8310: oPop 1
8312: oEmit 40
8314: oJumpForward 8319
8316: Choice Lookup Table
           0   8304
8319: oGetAddrLocal 3
8321: oPushResult
8322: oGetLocal 2
8324: oPushResult
8325: oSetResult 17
8327: oPushResult
8328: oNodeGetInt
8329: oPop 2
8331: oAssign
8332: oGetLocal 3
8334: oPushResult
8335: oSetResult 1
8337: oPushResult
8338: equal
8339: oPop 2
8341: oChoice 8355
8343: oEmit 15
8345: oGetLocal 3
8347: oPushResult
8348: oEmitInt
8349: oPop 1
8351: oEmit 34
8353: oJumpForward 8358
8355: Choice Lookup Table
           0   8343
8358: oEmit 36
8360: oInputChoice 8368
8362: oJumpForward 8376
8364: oJumpForward 8374
8366: oJumpForward 8374
8368: Choice Lookup Table
          13   8366
          17   8362
8373: oEndChoice
8374: oJumpBack 8246
8376: oReturn
8377: oLocalSpace 2
8379: oTypeSNodeType
8380: oChoice 8384
8382: oJumpForward 8389
8384: Choice Lookup Table
          33   8382
8387: oError 29
8389: oGetAddrLocal 1
8391: oPushResult
8392: oTypeSTop
8393: oPushResult
8394: oSetResult 36
8396: oPushResult
8397: oNodeGet
8398: oPop 2
8400: oAssign
8401: oTypeSPop
8402: oGetLocal 1
8404: oPushResult
8405: oTypeSPush
8406: oPop 1
8408: oCall 5686
8410: oCall 11881
8412: oGetAddrLocal 2
8414: oPushResult
8415: oGetLocal 1
8417: oPushResult
8418: oSetResult 17
8420: oPushResult
8421: oNodeGetInt
8422: oPop 2
8424: oAssign
8425: oGetLocal 2
8427: oPushResult
8428: oSetResult 1
8430: oPushResult
8431: equal
8432: oPop 2
8434: oChoice 8448
8436: oEmit 15
8438: oGetLocal 2
8440: oPushResult
8441: oEmitInt
8442: oPop 1
8444: oEmit 34
8446: oJumpForward 8451
8448: Choice Lookup Table
           0   8436
8451: oEmit 36
8453: oInput 17
8455: oReturn
8456: oLocalSpace 0
8458: oTypeSNodeType
8459: oChoice 8463
8461: oJumpForward 8470
8463: Choice Lookup Table
          39   8461
          38   8461
8468: oError 29
8470: oTypeSPop
8471: oGetGlobal 9
8473: oPushResult
8474: oTypeSPush
8475: oPop 1
8477: oCall 5686
8479: oCall 11881
8481: oEmit 36
8483: oInput 17
8485: oReturn
8486: oLocalSpace 2
8488: oTypeSNodeType
8489: oChoice 8493
8491: oJumpForward 8498
8493: Choice Lookup Table
          37   8491
8496: oError 11
8498: oTypeSTop
8499: oPushResult
8500: oSetResult 40
8502: oPushResult
8503: oNodeGet
8504: oPop 2
8506: oPushResult
8507: oScopeEnter
8508: oPop 1
8510: oInput 0
8512: oGetAddrLocal 1
8514: oPushResult
8515: oScopeFindRequire
8516: oAssign
8517: oGetLocal 1
8519: oPushResult
8520: oNodeType
8521: oPop 1
8523: oChoice 8527
8525: oJumpForward 8532
8527: Choice Lookup Table
          22   8525
8530: oError 12
8532: oScopeEnd
8533: oGetAddrLocal 2
8535: oPushResult
8536: oGetLocal 1
8538: oPushResult
8539: oSetResult 22
8541: oPushResult
8542: oNodeGetInt
8543: oPop 2
8545: oAssign
8546: oGetLocal 2
8548: oPushResult
8549: equal_zero
8550: oPop 1
8552: oChoice 8566
8554: oEmit 15
8556: oGetLocal 2
8558: oPushResult
8559: oEmitInt
8560: oPop 1
8562: oEmit 36
8564: oJumpForward 8569
8566: Choice Lookup Table
           0   8554
8569: oTypeSPop
8570: oGetLocal 1
8572: oPushResult
8573: oSetResult 21
8575: oPushResult
8576: oNodeGet
8577: oPop 2
8579: oPushResult
8580: oTypeSPush
8581: oPop 1
8583: oReturn
8584: oLocalSpace 2
8586: oGetAddrLocal 1
8588: oPushResult
8589: oTypeSTop
8590: oPushResult
8591: oSetResult 36
8593: oPushResult
8594: oNodeGet
8595: oPop 2
8597: oAssign
8598: oGetAddrLocal 2
8600: oPushResult
8601: oGetLocal 1
8603: oPushResult
8604: oSetResult 17
8606: oPushResult
8607: oNodeGetInt
8608: oPop 2
8610: oAssign
8611: oGetLocal 2
8613: oPushResult
8614: oSetResult 1
8616: oPushResult
8617: equal
8618: oPop 2
8620: oChoice 8634
8622: oEmit 15
8624: oGetLocal 2
8626: oPushResult
8627: oEmitInt
8628: oPop 1
8630: oEmit 34
8632: oJumpForward 8637
8634: Choice Lookup Table
           0   8622
8637: oEmit 36
8639: oReturn
8640: oLocalSpace 2
8642: oGetAddrLocal 1
8644: oPushResult
8645: oTypeSTop
8646: oPushResult
8647: oSetResult 36
8649: oPushResult
8650: oNodeGet
8651: oPop 2
8653: oAssign
8654: oGetAddrLocal 2
8656: oPushResult
8657: oGetLocal 1
8659: oPushResult
8660: oSetResult 17
8662: oPushResult
8663: oNodeGetInt
8664: oPop 2
8666: oAssign
8667: oGetLocal 2
8669: oPushResult
8670: oSetResult 1
8672: oPushResult
8673: equal
8674: oPop 2
8676: oChoice 8690
8678: oEmit 15
8680: oGetLocal 2
8682: oPushResult
8683: oEmitInt
8684: oPop 1
8686: oEmit 34
8688: oJumpForward 8693
8690: Choice Lookup Table
           0   8678
8693: oEmit 39
8695: oReturn
8696: oLocalSpace 2
8698: oEmit 38
8700: oGetAddrLocal 1
8702: oPushResult
8703: oTypeSTop
8704: oPushResult
8705: oSetResult 36
8707: oPushResult
8708: oNodeGet
8709: oPop 2
8711: oAssign
8712: oGetAddrLocal 2
8714: oPushResult
8715: oGetLocal 1
8717: oPushResult
8718: oSetResult 17
8720: oPushResult
8721: oNodeGetInt
8722: oPop 2
8724: oAssign
8725: oGetLocal 2
8727: oPushResult
8728: oSetResult 1
8730: oPushResult
8731: equal
8732: oPop 2
8734: oChoice 8748
8736: oEmit 15
8738: oGetLocal 2
8740: oPushResult
8741: oEmitInt
8742: oPop 1
8744: oEmit 35
8746: oJumpForward 8751
8748: Choice Lookup Table
           0   8736
8751: oTypeSPop
8752: oGetGlobal 6
8754: oPushResult
8755: oTypeSPush
8756: oPop 1
8758: oReturn
8759: oLocalSpace 1
8761: oTypeSNodeType
8762: oChoice 8770
8764: oJumpForward 8777
8766: oError 29
8768: oJumpForward 8777
8770: Choice Lookup Table
          34   8766
          33   8764
8775: oError 9
8777: oEmit 25
8779: oGetAddrLocal 1
8781: oPushResult
8782: oTypeSTop
8783: oAssign
8784: oTypeSPop
8785: oGetLocal 1
8787: oPushResult
8788: oSetResult 36
8790: oPushResult
8791: oNodeGet
8792: oPop 2
8794: oPushResult
8795: oTypeSPush
8796: oPop 1
8798: oReturn
8799: oLocalSpace 2
8801: oGetAddrLocal 1
8803: oPushResult
8804: oTypeSNodeType
8805: oAssign
8806: oTypeSPop
8807: oGetLocal 1
8809: oPushResult
8810: oTypeSNodeType
8811: oPushResult
8812: equal_node_type
8813: oPop 2
8815: oChoice 8947
8817: oTypeSNodeType
8818: oChoice 8932
8820: oGetLocal 1
8822: oChoice 8829
8824: oEmit 30
8826: oReturn
8827: oJumpForward 8832
8829: Choice Lookup Table
          29   8824
8832: oJumpForward 8943
8834: oGetLocal 1
8836: oChoice 8843
8838: oEmit 31
8840: oReturn
8841: oJumpForward 8846
8843: Choice Lookup Table
          28   8838
8846: oJumpForward 8943
8848: oGetLocal 1
8850: oChoice 8883
8852: oReturn
8853: oJumpForward 8888
8855: oTypeSTop
8856: oPushResult
8857: oGetGlobal 10
8859: oPushResult
8860: equal_node
8861: oPop 2
8863: oChoice 8878
8865: oEmit 15
8867: oSetResult 1
8869: oPushResult
8870: oEmitInt
8871: oPop 1
8873: oEmit 36
8875: oReturn
8876: oJumpForward 8881
8878: Choice Lookup Table
           1   8865
8881: oJumpForward 8888
8883: Choice Lookup Table
          38   8855
          34   8852
8888: oJumpForward 8943
8890: oGetLocal 1
8892: oChoice 8897
8894: oReturn
8895: oJumpForward 8900
8897: Choice Lookup Table
          33   8894
8900: oJumpForward 8943
8902: oGetLocal 1
8904: oChoice 8925
8906: oReturn
8907: oJumpForward 8930
8909: oGetGlobal 9
8911: oPushResult
8912: oTypeSPush
8913: oPop 1
8915: oGetAddrLocal 2
8917: oPushResult
8918: oCall 8951
8920: oAssign
8921: oTypeSPop
8922: oReturn
8923: oJumpForward 8930
8925: Choice Lookup Table
          32   8909
          38   8906
8930: oJumpForward 8943
8932: Choice Lookup Table
          39   8902
          34   8890
          33   8848
          29   8834
          28   8820
8943: oError 14
8945: oJumpForward 8950
8947: Choice Lookup Table
           0   8817
8950: oReturn
8951: oLocalSpace 1
8953: oGetAddrLocal 1
8955: oPushResult
8956: oGetGlobal 14
8958: oPushResult
8959: oScopeAllocType
8960: oPop 1
8962: oAssign
8963: oTypeSNodeType
8964: oChoice 9032
8966: oEmit 17
8968: oGetLocal 1
8970: oPushResult
8971: oEmitInt
8972: oPop 1
8974: oEmit 22
8976: oEmit 29
8978: oGetGlobal 14
8980: oPushResult
8981: oSetResult 17
8983: oPushResult
8984: oNodeGetInt
8985: oPop 2
8987: oPushResult
8988: oEmitInt
8989: oPop 1
8991: oJumpForward 9041
8993: oEmit 17
8995: oGetLocal 1
8997: oPushResult
8998: oEmitInt
8999: oPop 1
9001: oEmit 15
9003: oSetResult 1
9005: oPushResult
9006: oEmitInt
9007: oPop 1
9009: oEmit 27
9011: oEmit 17
9013: oGetLocal 1
9015: oPushResult
9016: oSetResult 1
9018: oPushResult
9019: add
9020: oPop 2
9022: oPushResult
9023: oEmitInt
9024: oPop 1
9026: oEmit 22
9028: oEmit 27
9030: oJumpForward 9041
9032: Choice Lookup Table
          32   8993
          38   8966
          39   8966
9039: oError 14
9041: oTypeSPop
9042: oEmit 17
9044: oGetLocal 1
9046: oPushResult
9047: oEmitInt
9048: oPop 1
9050: oGetGlobal 14
9052: oPushResult
9053: oTypeSPush
9054: oPop 1
9056: oGetLocal 1
9058: oReturn
9059: oReturn
9060: oLocalSpace 0
9062: oEmit 61
9064: oSetResult 16
9066: oPushResult
9067: oEmitInt
9068: oPop 1
9070: oEmit 19
9072: oSetResult 8
9074: oPushResult
9075: oEmitInt
9076: oPop 1
9078: oEmit 22
9080: oEmit 28
9082: oEmit 19
9084: oSetResult 0
9086: oPushResult
9087: oEmitInt
9088: oPop 1
9090: oEmit 22
9092: oEmit 28
9094: oEmit 64
9096: oGetGlobal 19
9098: oPushResult
9099: oCall 12337
9101: oPop 1
9103: oEmit 63
9105: oSetResult 16
9107: oPushResult
9108: oEmitInt
9109: oPop 1
9111: oTypeSPop
9112: oTypeSPop
9113: oReturn
9114: oLocalSpace 0
9116: oEmit 61
9118: oSetResult 12
9120: oPushResult
9121: oEmitInt
9122: oPop 1
9124: oEmit 19
9126: oSetResult 8
9128: oPushResult
9129: oEmitInt
9130: oPop 1
9132: oEmit 22
9134: oEmit 26
9136: oEmit 19
9138: oSetResult 0
9140: oPushResult
9141: oEmitInt
9142: oPop 1
9144: oEmit 22
9146: oEmit 28
9148: oEmit 64
9150: oGetGlobal 20
9152: oPushResult
9153: oCall 12337
9155: oPop 1
9157: oEmit 63
9159: oSetResult 12
9161: oPushResult
9162: oEmitInt
9163: oPop 1
9165: oTypeSPop
9166: oTypeSPop
9167: oReturn
9168: oLocalSpace 1
9170: oEmit 61
9172: oSetResult 24
9174: oPushResult
9175: oEmitInt
9176: oPop 1
9178: oEmit 19
9180: oSetResult 8
9182: oPushResult
9183: oEmitInt
9184: oPop 1
9186: oEmit 22
9188: oEmit 28
9190: oEmit 19
9192: oSetResult 0
9194: oPushResult
9195: oEmitInt
9196: oPop 1
9198: oEmit 22
9200: oEmit 28
9202: oGetAddrLocal 1
9204: oPushResult
9205: oGetGlobal 6
9207: oPushResult
9208: oScopeAllocType
9209: oPop 1
9211: oAssign
9212: oEmit 19
9214: oSetResult 16
9216: oPushResult
9217: oEmitInt
9218: oPop 1
9220: oEmit 17
9222: oGetLocal 1
9224: oPushResult
9225: oEmitInt
9226: oPop 1
9228: oEmit 28
9230: oEmit 64
9232: oGetGlobal 21
9234: oPushResult
9235: oCall 12337
9237: oPop 1
9239: oEmit 3
9241: oGetLocal 1
9243: oPushResult
9244: oEmitInt
9245: oPop 1
9247: oEmit 63
9249: oSetResult 24
9251: oPushResult
9252: oEmitInt
9253: oPop 1
9255: oTypeSPop
9256: oGetGlobal 6
9258: oPushResult
9259: oTypeSPush
9260: oPop 1
9262: oReturn
9263: oLocalSpace 2
9265: oGetAddrLocal 2
9267: oPushResult
9268: oGetParam 1
9270: oPushResult
9271: oSetResult 26
9273: oPushResult
9274: oNodeGetString
9275: oPop 2
9277: oAssign
9278: oGetLocal 2
9280: oPushResult
9281: oSetResult 0
9283: oPushResult
9284: equal_string
9285: oPop 2
9287: oChoice 9324
9289: oGetAddrLocal 1
9291: oPushResult
9292: oGetParam 1
9294: oPushResult
9295: oSetResult 4
9297: oPushResult
9298: oNodeGetInt
9299: oPop 2
9301: oPushResult
9302: ID_STRING
9303: oPop 1
9305: oPushResult
9306: oStringAllocLit
9307: oPop 1
9309: oAssign
9310: oJumpForward 9330
9312: oGetAddrLocal 1
9314: oPushResult
9315: oGetLocal 2
9317: oPushResult
9318: oStringAllocLit
9319: oPop 1
9321: oAssign
9322: oJumpForward 9330
9324: Choice Lookup Table
           0   9312
           1   9289
9329: oEndChoice
9330: oEmit 79
9332: oGetParam 1
9334: oPushResult
9335: oCall 12337
9337: oPop 1
9339: oGetLocal 1
9341: oPushResult
9342: oEmitInt
9343: oPop 1
9345: oReturn
9346: oLocalSpace 10
9348: oGetParam 1
9350: oPushResult
9351: oSetResult 25
9353: oPushResult
9354: oNodeGetBoolean
9355: oPop 2
9357: oChoice 9384
9359: oGetParam 1
9361: oPushResult
9362: oSetResult 28
9364: oPushResult
9365: oNodeGetBoolean
9366: oPop 2
9368: oChoice 9379
9370: oGetParam 1
9372: oPushResult
9373: oCall 9263
9375: oPop 1
9377: oJumpForward 9382
9379: Choice Lookup Table
           0   9370
9382: oJumpForward 9387
9384: Choice Lookup Table
           1   9359
9387: oGetParam 1
9389: oPushResult
9390: oSetResult 28
9392: oPushResult
9393: oSetResult 1
9395: oPushResult
9396: oNodeSetBoolean
9397: oPop 3
9399: oGetAddrLocal 1
9401: oPushResult
9402: oGetParam 1
9404: oPushResult
9405: oSetResult 27
9407: oPushResult
9408: oNodeGetBoolean
9409: oPop 2
9411: oAssign
9412: oGetAddrLocal 4
9414: oPushResult
9415: oGetParam 1
9417: oPushResult
9418: oNodeType
9419: oPop 1
9421: oPushResult
9422: oSetResult 13
9424: oPushResult
9425: equal_node_type
9426: oPop 2
9428: oAssign
9429: oGetLocal 4
9431: oChoice 9458
9433: oGetAddrLocal 2
9435: oPushResult
9436: oGetParam 1
9438: oPushResult
9439: oSetResult 21
9441: oPushResult
9442: oNodeGet
9443: oPop 2
9445: oAssign
9446: oGetAddrLocal 3
9448: oPushResult
9449: oGetLocal 2
9451: oPushResult
9452: oScopeAllocType
9453: oPop 1
9455: oAssign
9456: oJumpForward 9461
9458: Choice Lookup Table
           1   9433
9461: oGetAddrLocal 5
9463: oPushResult
9464: oGetParam 1
9466: oPushResult
9467: oSetResult 23
9469: oPushResult
9470: oNodeGet
9471: oPop 2
9473: oAssign
9474: oGetAddrLocal 6
9476: oPushResult
9477: oGetLocal 5
9479: oPushResult
9480: oSetResult 17
9482: oPushResult
9483: oNodeGetInt
9484: oPop 2
9486: oAssign
9487: oGetLocal 1
9489: oChoice 9511
9491: oEmit 62
9493: oGetLocal 6
9495: oPushResult
9496: oEmitInt
9497: oPop 1
9499: oJumpForward 9517
9501: oEmit 61
9503: oGetLocal 6
9505: oPushResult
9506: oEmitInt
9507: oPop 1
9509: oJumpForward 9517
9511: Choice Lookup Table
           0   9501
           1   9491
9516: oEndChoice
9517: oGetParam 1
9519: oPushResult
9520: oCall 11785
9522: oPop 1
9524: oPushResult
9525: oSetResult 0
9527: oPushResult
9528: greater
9529: oPop 2
9531: oChoice 9564
9533: oEmit 19
9535: oSetResult 0
9537: oPushResult
9538: oEmitInt
9539: oPop 1
9541: oEmit 20
9543: oGetParam 1
9545: oPushResult
9546: oCall 11805
9548: oPop 1
9550: oPushResult
9551: oEmitInt
9552: oPop 1
9554: oSetResult 0
9556: oPushResult
9557: oEmitInt
9558: oPop 1
9560: oEmit 28
9562: oJumpForward 9567
9564: Choice Lookup Table
           1   9533
9567: oGetAddrLocal 7
9569: oPushResult
9570: oGetLocal 5
9572: oPushResult
9573: oSetResult 15
9575: oPushResult
9576: oNodeGetIter
9577: oPop 2
9579: oAssign
9580: oGetAddrLocal 8
9582: oPushResult
9583: oGetLocal 7
9585: oPushResult
9586: oNodeIterValue
9587: oPop 1
9589: oAssign
9590: oInputChoice 9787
9592: oGetLocal 8
9594: oPushResult
9595: oNodeNull
9596: oPop 1
9598: oChoice 9604
9600: oJumpForward 9783
9602: oJumpForward 9607
9604: Choice Lookup Table
           1   9600
9607: oGetAddrLocal 9
9609: oPushResult
9610: oGetLocal 8
9612: oPushResult
9613: oSetResult 22
9615: oPushResult
9616: oNodeGetInt
9617: oPop 2
9619: oAssign
9620: oEmit 19
9622: oGetLocal 9
9624: oPushResult
9625: oEmitInt
9626: oPop 1
9628: oGetLocal 8
9630: oPushResult
9631: oSetResult 21
9633: oPushResult
9634: oNodeGet
9635: oPop 2
9637: oPushResult
9638: oTypeSPush
9639: oPop 1
9641: oGetLocal 8
9643: oPushResult
9644: oSetResult 33
9646: oPushResult
9647: oNodeGetBoolean
9648: oPop 2
9650: oChoice 9736
9652: oSetResult 1
9654: oPushResult
9655: oCall 10613
9657: oPop 1
9659: oCall 11823
9661: oEmit 28
9663: oJumpForward 9742
9665: oCall 5686
9667: oCall 8799
9669: oTypeSNodeType
9670: oChoice 9710
9672: oEmit 26
9674: oJumpForward 9734
9676: oEmit 27
9678: oJumpForward 9734
9680: oError 16
9682: oJumpForward 9734
9684: oEmit 28
9686: oJumpForward 9734
9688: oGetAddrLocal 10
9690: oPushResult
9691: oTypeSTop
9692: oPushResult
9693: oSetResult 17
9695: oPushResult
9696: oNodeGetInt
9697: oPop 2
9699: oAssign
9700: oEmit 29
9702: oGetLocal 10
9704: oPushResult
9705: oEmitInt
9706: oPop 1
9708: oJumpForward 9734
9710: Choice Lookup Table
          39   9688
          37   9688
          35   9688
          34   9684
          33   9684
          27   9680
          32   9676
          29   9676
          30   9676
          40   9672
          28   9672
9733: oEndChoice
9734: oJumpForward 9742
9736: Choice Lookup Table
           0   9665
           1   9652
9741: oEndChoice
9742: oTypeSPop
9743: oGetAddrLocal 7
9745: oPushResult
9746: oNodeIterNext
9747: oPop 1
9749: oGetAddrLocal 8
9751: oPushResult
9752: oGetLocal 7
9754: oPushResult
9755: oNodeIterValue
9756: oPop 1
9758: oAssign
9759: oGetLocal 8
9761: oPushResult
9762: oNodeNull
9763: oPop 1
9765: oChoice 9773
9767: oJumpForward 9783
9769: oJumpForward 9779
9771: oJumpForward 9779
9773: Choice Lookup Table
           0   9771
           1   9767
9778: oEndChoice
9779: oInput 13
9781: oJumpBack 9592
9783: oInput 15
9785: oJumpForward 9790
9787: Choice Lookup Table
          14   9592
9790: oGetLocal 8
9792: oPushResult
9793: oNodeNull
9794: oPop 1
9796: oChoice 9802
9798: oError 15
9800: oJumpForward 9805
9802: Choice Lookup Table
           0   9798
9805: oGetLocal 4
9807: oChoice 9836
9809: oEmit 19
9811: oGetParam 1
9813: oPushResult
9814: oSetResult 31
9816: oPushResult
9817: oNodeGetInt
9818: oPop 2
9820: oPushResult
9821: oEmitInt
9822: oPop 1
9824: oEmit 17
9826: oGetLocal 3
9828: oPushResult
9829: oEmitInt
9830: oPop 1
9832: oEmit 28
9834: oJumpForward 9839
9836: Choice Lookup Table
           1   9809
9839: oGetLocal 1
9841: oChoice 9865
9843: oEmit 65
9845: oGetParam 1
9847: oPushResult
9848: oCall 12337
9850: oPop 1
9852: oJumpForward 9871
9854: oEmit 64
9856: oGetParam 1
9858: oPushResult
9859: oCall 12337
9861: oPop 1
9863: oJumpForward 9871
9865: Choice Lookup Table
           0   9854
           1   9843
9870: oEndChoice
9871: oGetLocal 4
9873: oChoice 9954
9875: oGetLocal 2
9877: oPushResult
9878: oTypeSPush
9879: oPop 1
9881: oTypeSNodeType
9882: oChoice 9928
9884: oEmit 3
9886: oGetLocal 3
9888: oPushResult
9889: oEmitInt
9890: oPop 1
9892: oJumpForward 9952
9894: oEmit 4
9896: oGetLocal 3
9898: oPushResult
9899: oEmitInt
9900: oPop 1
9902: oJumpForward 9952
9904: oError 16
9906: oJumpForward 9952
9908: oEmit 5
9910: oGetLocal 3
9912: oPushResult
9913: oEmitInt
9914: oPop 1
9916: oJumpForward 9952
9918: oEmit 17
9920: oGetLocal 3
9922: oPushResult
9923: oEmitInt
9924: oPop 1
9926: oJumpForward 9952
9928: Choice Lookup Table
          39   9918
          37   9918
          35   9918
          34   9908
          33   9908
          27   9904
          32   9894
          29   9894
          30   9894
          40   9884
          28   9884
9951: oEndChoice
9952: oJumpForward 9957
9954: Choice Lookup Table
           1   9875
9957: oEmit 63
9959: oGetLocal 6
9961: oPushResult
9962: oEmitInt
9963: oPop 1
9965: oReturn
9966: oLocalSpace 0
9968: oGetParam 1
9970: oPushResult
9971: oGetGlobal 15
9973: oPushResult
9974: oNodeEqual
9975: oPop 2
9977: oChoice 10017
9979: oInput 14
9981: oCall 5686
9983: oTypeSNodeType
9984: oChoice 9992
9986: oJumpForward 10005
9988: oEmit 30
9990: oJumpForward 10005
9992: Choice Lookup Table
          32   9988
          29   9988
          30   9988
          40   9986
          28   9986
10003: oError 14
10005: oTypeSPop
10006: oGetGlobal 6
10008: oPushResult
10009: oTypeSPush
10010: oPop 1
10012: oInput 15
10014: oReturn
10015: oJumpForward 10020
10017: Choice Lookup Table
           1   9979
10020: oGetParam 1
10022: oPushResult
10023: oGetGlobal 16
10025: oPushResult
10026: oNodeEqual
10027: oPop 2
10029: oChoice 10063
10031: oInput 14
10033: oCall 5686
10035: oTypeSNodeType
10036: oChoice 10044
10038: oEmit 31
10040: oJumpForward 10051
10042: oJumpForward 10051
10044: Choice Lookup Table
          29   10042
          28   10038
10049: oError 14
10051: oTypeSPop
10052: oGetGlobal 9
10054: oPushResult
10055: oTypeSPush
10056: oPop 1
10058: oInput 15
10060: oReturn
10061: oJumpForward 10066
10063: Choice Lookup Table
           1   10031
10066: oGetParam 1
10068: oPushResult
10069: oGetGlobal 17
10071: oPushResult
10072: oNodeEqual
10073: oPop 2
10075: oChoice 10115
10077: oInput 14
10079: oCall 5686
10081: oTypeSNodeType
10082: oChoice 10103
10084: oTypeSTop
10085: oPushResult
10086: oSetResult 43
10088: oPushResult
10089: oNodeGetBoolean
10090: oPop 2
10092: oChoice 10098
10094: oError 28
10096: oJumpForward 10101
10098: Choice Lookup Table
           1   10094
10101: oJumpForward 10108
10103: Choice Lookup Table
          40   10084
10106: oError 14
10108: oEmit 33
10110: oInput 15
10112: oReturn
10113: oJumpForward 10118
10115: Choice Lookup Table
           1   10077
10118: oGetParam 1
10120: oPushResult
10121: oGetGlobal 18
10123: oPushResult
10124: oNodeEqual
10125: oPop 2
10127: oChoice 10167
10129: oInput 14
10131: oCall 5686
10133: oTypeSNodeType
10134: oChoice 10155
10136: oTypeSTop
10137: oPushResult
10138: oSetResult 43
10140: oPushResult
10141: oNodeGetBoolean
10142: oPop 2
10144: oChoice 10150
10146: oError 28
10148: oJumpForward 10153
10150: Choice Lookup Table
           1   10146
10153: oJumpForward 10160
10155: Choice Lookup Table
          40   10136
10158: oError 14
10160: oEmit 32
10162: oInput 15
10164: oReturn
10165: oJumpForward 10170
10167: Choice Lookup Table
           1   10129
10170: oError 16
10172: oReturn
10173: oLocalSpace 0
10175: oInputChoice 10238
10177: oCall 11636
10179: oJumpForward 10269
10181: oCall 11643
10183: oJumpForward 10269
10185: oCall 11767
10187: oJumpForward 10269
10189: oCall 11770
10191: oJumpForward 10269
10193: oCall 10851
10195: oJumpForward 10269
10197: oCall 11174
10199: oJumpForward 10269
10201: oCall 10917
10203: oJumpForward 10269
10205: oCall 11094
10207: oJumpForward 10269
10209: oCall 11259
10211: oJumpForward 10269
10213: oCall 11227
10215: oJumpForward 10269
10217: oCall 11613
10219: oJumpForward 10269
10221: oCall 10270
10223: oJumpForward 10269
10225: oCall 11291
10227: oJumpForward 10269
10229: oCall 11561
10231: oJumpForward 10269
10233: oChangeIntLitToLabelIdent
10234: oCall 10270
10236: oJumpForward 10269
10238: Choice Lookup Table
           1   10233
          55   10229
          53   10225
           0   10221
          35   10217
          51   10213
          52   10209
          49   10205
          44   10201
          48   10197
          41   10193
          68   10189
          67   10185
          66   10181
          65   10177
10269: oReturn
10270: oLocalSpace 1
10272: oGetAddrLocal 1
10274: oPushResult
10275: oScopeFindRequire
10276: oAssign
10277: oGetAddrLocal 1
10279: oPushResult
10280: oCall 543
10282: oPop 1
10284: oGetLocal 1
10286: oPushResult
10287: oNodeType
10288: oPop 1
10290: oChoice 10330
10292: oGetLocal 1
10294: oPushResult
10295: oCall 10346
10297: oPop 1
10299: oCall 10173
10301: oJumpForward 10345
10303: oGetLocal 1
10305: oPushResult
10306: oCall 9346
10308: oPop 1
10310: oJumpForward 10345
10312: oGetLocal 1
10314: oPushResult
10315: oCall 10396
10317: oPop 1
10319: oJumpForward 10345
10321: oGetLocal 1
10323: oPushResult
10324: oCall 10486
10326: oPop 1
10328: oJumpForward 10345
10330: Choice Lookup Table
          13   10321
          23   10312
          21   10312
          20   10312
          12   10303
          25   10292
10343: oError 0
10345: oReturn
10346: oLocalSpace 0
10348: oGetParam 1
10350: oPushResult
10351: oSetResult 34
10353: oPushResult
10354: oNodeGetBoolean
10355: oPop 2
10357: oChoice 10363
10359: oError 21
10361: oJumpForward 10366
10363: Choice Lookup Table
           1   10359
10366: oEmit 77
10368: oGetParam 1
10370: oPushResult
10371: oSetResult 22
10373: oPushResult
10374: oNodeGetLabel
10375: oPop 2
10377: oPushResult
10378: oEmitLabel
10379: oPop 1
10381: oGetParam 1
10383: oPushResult
10384: oSetResult 34
10386: oPushResult
10387: oSetResult 1
10389: oPushResult
10390: oNodeSetBoolean
10391: oPop 3
10393: oInput 12
10395: oReturn
10396: oLocalSpace 0
10398: oGetParam 1
10400: oPushResult
10401: oSetResult 1
10403: oPushResult
10404: oCall 10661
10406: oPop 2
10408: oInput 4
10410: oCall 5686
10412: oCall 8799
10414: oCall 10417
10416: oReturn
10417: oLocalSpace 1
10419: oTypeSNodeType
10420: oChoice 10460
10422: oEmit 26
10424: oJumpForward 10484
10426: oEmit 27
10428: oJumpForward 10484
10430: oError 16
10432: oJumpForward 10484
10434: oEmit 28
10436: oJumpForward 10484
10438: oGetAddrLocal 1
10440: oPushResult
10441: oTypeSTop
10442: oPushResult
10443: oSetResult 17
10445: oPushResult
10446: oNodeGetInt
10447: oPop 2
10449: oAssign
10450: oEmit 29
10452: oGetLocal 1
10454: oPushResult
10455: oEmitInt
10456: oPop 1
10458: oJumpForward 10484
10460: Choice Lookup Table
          39   10438
          37   10438
          35   10438
          34   10434
          33   10434
          27   10430
          32   10426
          29   10426
          30   10426
          40   10422
          28   10422
10483: oEndChoice
10484: oTypeSPop
10485: oReturn
10486: oLocalSpace 1
10488: oGetParam 1
10490: oPushResult
10491: oSetResult 6
10493: oPushResult
10494: oNodeGet
10495: oPop 2
10497: oPushResult
10498: oScopeCurrent
10499: oPushResult
10500: oNodeEqual
10501: oPop 2
10503: oChoice 10509
10505: oError 20
10507: oJumpForward 10512
10509: Choice Lookup Table
           0   10505
10512: oEmit 8
10514: oGetParam 1
10516: oPushResult
10517: oSetResult 31
10519: oPushResult
10520: oNodeGetInt
10521: oPop 2
10523: oPushResult
10524: oEmitInt
10525: oPop 1
10527: oGetParam 1
10529: oPushResult
10530: oSetResult 21
10532: oPushResult
10533: oNodeGet
10534: oPop 2
10536: oPushResult
10537: oTypeSPush
10538: oPop 1
10540: oInput 4
10542: oCall 5686
10544: oCall 8799
10546: oTypeSNodeType
10547: oChoice 10587
10549: oEmit 26
10551: oJumpForward 10611
10553: oEmit 27
10555: oJumpForward 10611
10557: oError 16
10559: oJumpForward 10611
10561: oEmit 28
10563: oJumpForward 10611
10565: oGetAddrLocal 1
10567: oPushResult
10568: oTypeSTop
10569: oPushResult
10570: oSetResult 17
10572: oPushResult
10573: oNodeGetInt
10574: oPop 2
10576: oAssign
10577: oEmit 29
10579: oGetLocal 1
10581: oPushResult
10582: oEmitInt
10583: oPop 1
10585: oJumpForward 10611
10587: Choice Lookup Table
          39   10565
          37   10565
          35   10565
          34   10561
          33   10561
          27   10557
          32   10553
          29   10553
          30   10553
          40   10549
          28   10549
10610: oEndChoice
10611: oTypeSPop
10612: oReturn
10613: oLocalSpace 1
10615: oInput 0
10617: oGetAddrLocal 1
10619: oPushResult
10620: oScopeFindRequire
10621: oAssign
10622: oGetAddrLocal 1
10624: oPushResult
10625: oCall 543
10627: oPop 1
10629: oGetLocal 1
10631: oPushResult
10632: oNodeType
10633: oPop 1
10635: oChoice 10639
10637: oJumpForward 10650
10639: Choice Lookup Table
          24   10637
          23   10637
          21   10637
          20   10637
10648: oError 4
10650: oGetLocal 1
10652: oPushResult
10653: oGetParam 1
10655: oPushResult
10656: oCall 10661
10658: oPop 2
10660: oReturn
10661: oLocalSpace 0
10663: oGetParam 2
10665: oPushResult
10666: oNodeType
10667: oPop 1
10669: oChoice 10751
10671: oEmit 16
10673: oGetParam 2
10675: oPushResult
10676: oCall 12337
10678: oPop 1
10680: oJumpForward 10762
10682: oEmit 17
10684: oGetParam 2
10686: oPushResult
10687: oCall 12337
10689: oPop 1
10691: oJumpForward 10762
10693: oGetParam 2
10695: oPushResult
10696: oSetResult 33
10698: oPushResult
10699: oNodeGetBoolean
10700: oPop 2
10702: oChoice 10715
10704: oEmit 8
10706: oGetParam 2
10708: oPushResult
10709: oCall 12337
10711: oPop 1
10713: oJumpForward 10727
10715: Choice Lookup Table
           1   10704
10718: oEmit 18
10720: oGetParam 2
10722: oPushResult
10723: oCall 12337
10725: oPop 1
10727: oJumpForward 10762
10729: oGetParam 1
10731: oChoice 10744
10733: oEmit 16
10735: oGetParam 2
10737: oPushResult
10738: oCall 12337
10740: oPop 1
10742: oJumpForward 10749
10744: Choice Lookup Table
           0   10733
10747: oError 4
10749: oJumpForward 10762
10751: Choice Lookup Table
          24   10729
          23   10693
          21   10682
          20   10671
10760: oError 4
10762: oGetParam 2
10764: oPushResult
10765: oSetResult 21
10767: oPushResult
10768: oNodeGet
10769: oPop 2
10771: oPushResult
10772: oTypeSPush
10773: oPop 1
10775: oTypeSNodeType
10776: oChoice 10791
10778: oInputChoice 10786
10780: oEmit 25
10782: oCall 8377
10784: oJumpForward 10789
10786: Choice Lookup Table
          16   10780
10789: oJumpForward 10794
10791: Choice Lookup Table
          33   10778
10794: oCall 8182
10796: oReturn
10797: oLocalSpace 0
10799: oGetParam 1
10801: oPushResult
10802: oSetResult 1
10804: oPushResult
10805: oCall 10661
10807: oPop 2
10809: oCall 11881
10811: oGetParam 1
10813: oPushResult
10814: oCall 7371
10816: oPop 1
10818: oTypeSPop
10819: oEmit 32
10821: oEmit 26
10823: oReturn
10824: oLocalSpace 0
10826: oGetParam 1
10828: oPushResult
10829: oSetResult 1
10831: oPushResult
10832: oCall 10661
10834: oPop 2
10836: oCall 11881
10838: oGetParam 1
10840: oPushResult
10841: oCall 7371
10843: oPop 1
10845: oTypeSPop
10846: oEmit 33
10848: oEmit 26
10850: oReturn
10851: oLocalSpace 2
10853: oGetAddrLocal 1
10855: oPushResult
10856: oSetResult 0
10858: oAssign
10859: oGetAddrLocal 1
10861: oPushResult
10862: oCall 5709
10864: oPop 1
10866: oInput 42
10868: oCall 10173
10870: oInputChoice 10905
10872: oGetAddrLocal 2
10874: oPushResult
10875: oLabelNew
10876: oAssign
10877: oEmit 68
10879: oGetLocal 2
10881: oPushResult
10882: oEmitLabel
10883: oPop 1
10885: oEmit 77
10887: oGetLocal 1
10889: oPushResult
10890: oEmitLabel
10891: oPop 1
10893: oCall 10173
10895: oEmit 77
10897: oGetLocal 2
10899: oPushResult
10900: oEmitLabel
10901: oPop 1
10903: oJumpForward 10916
10905: Choice Lookup Table
          43   10872
10908: oEmit 77
10910: oGetLocal 1
10912: oPushResult
10913: oEmitLabel
10914: oPop 1
10916: oReturn
10917: oLocalSpace 4
10919: oInput 0
10921: oGetAddrLocal 1
10923: oPushResult
10924: oScopeFindRequire
10925: oAssign
10926: oGetLocal 1
10928: oPushResult
10929: oSetResult 1
10931: oPushResult
10932: oCall 10661
10934: oPop 2
10936: oCall 11881
10938: oInput 4
10940: oCall 5686
10942: oCall 11881
10944: oEmit 26
10946: oGetAddrLocal 2
10948: oPushResult
10949: oLabelNew
10950: oAssign
10951: oGetAddrLocal 3
10953: oPushResult
10954: oLabelNew
10955: oAssign
10956: oEmit 68
10958: oGetLocal 3
10960: oPushResult
10961: oEmitLabel
10962: oPop 1
10964: oGetAddrLocal 4
10966: oPushResult
10967: oLabelNew
10968: oAssign
10969: oEmit 77
10971: oGetLocal 4
10973: oPushResult
10974: oEmitLabel
10975: oPop 1
10977: oInputChoice 11057
10979: oGetLocal 1
10981: oPushResult
10982: oCall 10797
10984: oPop 1
10986: oEmit 77
10988: oGetLocal 3
10990: oPushResult
10991: oEmitLabel
10992: oPop 1
10994: oGetLocal 1
10996: oPushResult
10997: oCall 7371
10999: oPop 1
11001: oTypeSPop
11002: oCall 5686
11004: oCall 11881
11006: oEmit 51
11008: oEmit 69
11010: oGetLocal 2
11012: oPushResult
11013: oEmitLabel
11014: oPop 1
11016: oJumpForward 11063
11018: oGetLocal 1
11020: oPushResult
11021: oCall 10824
11023: oPop 1
11025: oEmit 77
11027: oGetLocal 3
11029: oPushResult
11030: oEmitLabel
11031: oPop 1
11033: oGetLocal 1
11035: oPushResult
11036: oCall 7371
11038: oPop 1
11040: oTypeSPop
11041: oCall 5686
11043: oCall 11881
11045: oEmit 52
11047: oEmit 69
11049: oGetLocal 2
11051: oPushResult
11052: oEmitLabel
11053: oPop 1
11055: oJumpForward 11063
11057: Choice Lookup Table
          46   11018
          45   10979
11062: oEndChoice
11063: oGetLocal 4
11065: oPushResult
11066: oGetLocal 2
11068: oPushResult
11069: oLoopPush
11070: oPop 2
11072: oInput 47
11074: oCall 10173
11076: oEmit 68
11078: oGetLocal 4
11080: oPushResult
11081: oEmitLabel
11082: oPop 1
11084: oEmit 77
11086: oGetLocal 2
11088: oPushResult
11089: oEmitLabel
11090: oPop 1
11092: oLoopPop
11093: oReturn
11094: oLocalSpace 3
11096: oGetAddrLocal 1
11098: oPushResult
11099: oLabelNew
11100: oAssign
11101: oEmit 77
11103: oGetLocal 1
11105: oPushResult
11106: oEmitLabel
11107: oPop 1
11109: oGetAddrLocal 2
11111: oPushResult
11112: oLabelNew
11113: oAssign
11114: oGetLocal 1
11116: oPushResult
11117: oGetLocal 2
11119: oPushResult
11120: oLoopPush
11121: oPop 2
11123: oCall 10173
11125: oInputChoice 11156
11127: oCall 10173
11129: oJumpForward 11162
11131: oGetAddrLocal 3
11133: oPushResult
11134: oCall 5709
11136: oPop 1
11138: oEmit 78
11140: oGetLocal 3
11142: oPushResult
11143: oEmitLabel
11144: oPop 1
11146: oGetLocal 1
11148: oPushResult
11149: oEmitLabel
11150: oPop 1
11152: oJumpForward 11164
11154: oJumpForward 11162
11156: Choice Lookup Table
          50   11131
           5   11127
11161: oEndChoice
11162: oJumpBack 11125
11164: oEmit 77
11166: oGetLocal 2
11168: oPushResult
11169: oEmitLabel
11170: oPop 1
11172: oLoopPop
11173: oReturn
11174: oLocalSpace 2
11176: oGetAddrLocal 1
11178: oPushResult
11179: oLabelNew
11180: oAssign
11181: oEmit 77
11183: oGetLocal 1
11185: oPushResult
11186: oEmitLabel
11187: oPop 1
11189: oGetAddrLocal 2
11191: oPushResult
11192: oCall 5709
11194: oPop 1
11196: oGetLocal 1
11198: oPushResult
11199: oGetLocal 2
11201: oPushResult
11202: oLoopPush
11203: oPop 2
11205: oInput 47
11207: oCall 10173
11209: oEmit 68
11211: oGetLocal 1
11213: oPushResult
11214: oEmitLabel
11215: oPop 1
11217: oEmit 77
11219: oGetLocal 2
11221: oPushResult
11222: oEmitLabel
11223: oPop 1
11225: oLoopPop
11226: oReturn
11227: oLocalSpace 0
11229: oLoopContinueLabel
11230: oPushResult
11231: oSetResult 0
11233: oPushResult
11234: equal_label
11235: oPop 2
11237: oChoice 11252
11239: oError 18
11241: oJumpForward 11258
11243: oEmit 68
11245: oLoopContinueLabel
11246: oPushResult
11247: oEmitLabel
11248: oPop 1
11250: oJumpForward 11258
11252: Choice Lookup Table
           0   11243
           1   11239
11257: oEndChoice
11258: oReturn
11259: oLocalSpace 0
11261: oLoopBreakLabel
11262: oPushResult
11263: oSetResult 0
11265: oPushResult
11266: equal_label
11267: oPop 2
11269: oChoice 11284
11271: oError 18
11273: oJumpForward 11290
11275: oEmit 68
11277: oLoopBreakLabel
11278: oPushResult
11279: oEmitLabel
11280: oPop 1
11282: oJumpForward 11290
11284: Choice Lookup Table
           0   11275
           1   11271
11289: oEndChoice
11290: oReturn
11291: oLocalSpace 7
11293: oGetAddrLocal 1
11295: oPushResult
11296: oCodeNew
11297: oAssign
11298: oGetAddrLocal 2
11300: oPushResult
11301: oLabelNew
11302: oAssign
11303: oGetAddrLocal 3
11305: oPushResult
11306: oLabelNew
11307: oAssign
11308: oGetAddrLocal 4
11310: oPushResult
11311: oGetLocal 3
11313: oAssign
11314: oCall 5686
11316: oTypeSNodeType
11317: oChoice 11343
11319: oEmit 71
11321: oGetLocal 2
11323: oPushResult
11324: oEmitLabel
11325: oPop 1
11327: oJumpForward 11360
11329: oEmit 72
11331: oGetLocal 2
11333: oPushResult
11334: oEmitLabel
11335: oPop 1
11337: oJumpForward 11360
11339: oError 16
11341: oJumpForward 11360
11343: Choice Lookup Table
          38   11339
          39   11339
          40   11329
          28   11329
          32   11319
          29   11319
          30   11319
11358: oError 17
11360: oInput 40
11362: oInputChoice 11409
11364: oGetAddrLocal 4
11366: oPushResult
11367: oLabelNew
11368: oAssign
11369: oEmit 77
11371: oGetLocal 4
11373: oPushResult
11374: oEmitLabel
11375: oPop 1
11377: oInputChoice 11383
11379: oJumpForward 11401
11381: oJumpForward 11399
11383: Choice Lookup Table
          36   11379
11386: oCall 10173
11388: oInputChoice 11392
11390: oJumpForward 11399
11392: Choice Lookup Table
           5   11390
11395: oInput 36
11397: oJumpForward 11401
11399: oJumpBack 11377
11401: oJumpForward 11529
11403: oJumpForward 11527
11405: oJumpForward 11529
11407: oJumpForward 11527
11409: Choice Lookup Table
          36   11405
          43   11364
          54   11364
11416: oGetAddrLocal 5
11418: oPushResult
11419: oLabelNew
11420: oAssign
11421: oGetLocal 1
11423: oPushResult
11424: oCodePush
11425: oPop 1
11427: oCall 5168
11429: oCall 5628
11431: oGetAddrLocal 6
11433: oPushResult
11434: oValueTop
11435: oAssign
11436: oValuePop
11437: oInputChoice 11471
11439: oCall 5168
11441: oCall 5628
11443: oGetAddrLocal 7
11445: oPushResult
11446: oValueTop
11447: oAssign
11448: oValuePop
11449: oEmit 75
11451: oGetLocal 6
11453: oPushResult
11454: oEmitInt
11455: oPop 1
11457: oGetLocal 7
11459: oPushResult
11460: oEmitInt
11461: oPop 1
11463: oGetLocal 5
11465: oPushResult
11466: oEmitLabel
11467: oPop 1
11469: oJumpForward 11488
11471: Choice Lookup Table
          21   11439
11474: oEmit 74
11476: oGetLocal 6
11478: oPushResult
11479: oEmitInt
11480: oPop 1
11482: oGetLocal 5
11484: oPushResult
11485: oEmitLabel
11486: oPop 1
11488: oInputChoice 11492
11490: oJumpForward 11497
11492: Choice Lookup Table
          13   11490
11495: oJumpForward 11499
11497: oJumpBack 11427
11499: oCodePop
11500: oInput 12
11502: oEmit 77
11504: oGetLocal 5
11506: oPushResult
11507: oEmitLabel
11508: oPop 1
11510: oCall 10173
11512: oEmit 68
11514: oGetLocal 3
11516: oPushResult
11517: oEmitLabel
11518: oPop 1
11520: oInputChoice 11524
11522: oJumpForward 11527
11524: Choice Lookup Table
           5   11522
11527: oJumpBack 11362
11529: oEmit 77
11531: oGetLocal 2
11533: oPushResult
11534: oEmitLabel
11535: oPop 1
11537: oGetLocal 1
11539: oPushResult
11540: oEmitCode
11541: oPop 1
11543: oEmit 76
11545: oGetLocal 4
11547: oPushResult
11548: oEmitLabel
11549: oPop 1
11551: oEmit 77
11553: oGetLocal 3
11555: oPushResult
11556: oEmitLabel
11557: oPop 1
11559: oTypeSPop
11560: oReturn
11561: oLocalSpace 1
11563: oInputChoice 11570
11565: oJumpForward 11576
11567: oChangeIntLitToLabelIdent
11568: oJumpForward 11576
11570: Choice Lookup Table
           1   11567
           0   11565
11575: oEndChoice
11576: oGetAddrLocal 1
11578: oPushResult
11579: oScopeCurrent
11580: oPushResult
11581: oScopeFindRequireInScope
11582: oPop 1
11584: oAssign
11585: oGetLocal 1
11587: oPushResult
11588: oSetResult 28
11590: oPushResult
11591: oSetResult 1
11593: oPushResult
11594: oNodeSetBoolean
11595: oPop 3
11597: oEmit 68
11599: oGetLocal 1
11601: oPushResult
11602: oSetResult 22
11604: oPushResult
11605: oNodeGetLabel
11606: oPop 2
11608: oPushResult
11609: oEmitLabel
11610: oPop 1
11612: oReturn
11613: oLocalSpace 0
11615: oCall 10173
11617: oInputChoice 11627
11619: oCall 10173
11621: oJumpForward 11633
11623: oJumpForward 11635
11625: oJumpForward 11633
11627: Choice Lookup Table
          36   11623
           5   11619
11632: oEndChoice
11633: oJumpBack 11617
11635: oReturn
11636: oLocalSpace 0
11638: oCall 11643
11640: oEmit 87
11642: oReturn
11643: oLocalSpace 0
11645: oInputChoice 11763
11647: oCall 5686
11649: oTypeSNodeType
11650: oChoice 11721
11652: oEmit 80
11654: oJumpForward 11744
11656: oEmit 81
11658: oJumpForward 11744
11660: oEmit 30
11662: oEmit 80
11664: oJumpForward 11744
11666: oEmit 82
11668: oJumpForward 11744
11670: oEmit 83
11672: oJumpForward 11744
11674: oError 16
11676: oJumpForward 11744
11678: oEmit 16
11680: oTypeSTop
11681: oPushResult
11682: oSetResult 42
11684: oPushResult
11685: oNodeGetInt
11686: oPop 2
11688: oPushResult
11689: oEmitInt
11690: oPop 1
11692: oEmit 86
11694: oJumpForward 11744
11696: oTypeSTop
11697: oPushResult
11698: oGetGlobal 10
11700: oPushResult
11701: equal_node
11702: oPop 2
11704: oChoice 11710
11706: oEmit 84
11708: oJumpForward 11715
11710: Choice Lookup Table
           1   11706
11713: oEmit 85
11715: oJumpForward 11744
11717: oEmit 85
11719: oJumpForward 11744
11721: Choice Lookup Table
          34   11717
          33   11696
          40   11678
          27   11674
          38   11670
          39   11670
          32   11666
          29   11660
          30   11656
          28   11652
11742: oError 17
11744: oTypeSPop
11745: oInputChoice 11753
11747: oJumpForward 11761
11749: oJumpForward 11759
11751: oJumpForward 11759
11753: Choice Lookup Table
          13   11751
          15   11747
11758: oEndChoice
11759: oJumpBack 11647
11761: oJumpForward 11766
11763: Choice Lookup Table
          14   11647
11766: oReturn
11767: oLocalSpace 0
11769: oReturn
11770: oLocalSpace 0
11772: oReturn
11773: oLocalSpace 0
11775: oScopeCurrent
11776: oPushResult
11777: oSetResult 14
11779: oPushResult
11780: oNodeGetInt
11781: oPop 2
11783: oReturn
11784: oReturn
11785: oLocalSpace 0
11787: oGetParam 1
11789: oPushResult
11790: oSetResult 20
11792: oPushResult
11793: oNodeGet
11794: oPop 2
11796: oPushResult
11797: oSetResult 14
11799: oPushResult
11800: oNodeGetInt
11801: oPop 2
11803: oReturn
11804: oReturn
11805: oLocalSpace 0
11807: oCall 11773
11809: oPushResult
11810: oGetParam 1
11812: oPushResult
11813: oCall 11785
11815: oPop 1
11817: oPushResult
11818: subtract
11819: oPop 2
11821: oReturn
11822: oReturn
11823: oLocalSpace 1
11825: oGetAddrLocal 1
11827: oPushResult
11828: oTypeSNodeType
11829: oAssign
11830: oTypeSPop
11831: oGetLocal 1
11833: oPushResult
11834: oTypeSNodeType
11835: oPushResult
11836: equal_node_type
11837: oPop 2
11839: oChoice 11877
11841: oTypeSNodeType
11842: oChoice 11868
11844: oGetLocal 1
11846: oChoice 11851
11848: oReturn
11849: oJumpForward 11854
11851: Choice Lookup Table
          34   11848
11854: oJumpForward 11873
11856: oGetLocal 1
11858: oChoice 11863
11860: oReturn
11861: oJumpForward 11866
11863: Choice Lookup Table
          33   11860
11866: oJumpForward 11873
11868: Choice Lookup Table
          34   11856
          33   11844
11873: oError 14
11875: oJumpForward 11880
11877: Choice Lookup Table
           0   11841
11880: oReturn
11881: oLocalSpace 0
11883: oTypeSNodeType
11884: oChoice 11888
11886: oJumpForward 11893
11888: Choice Lookup Table
          28   11886
11891: oError 7
11893: oTypeSPop
11894: oReturn
11895: oLocalSpace 0
11897: oTypeSNodeType
11898: oChoice 11902
11900: oJumpForward 11907
11902: Choice Lookup Table
          28   11900
11905: oError 7
11907: oReturn
11908: oLocalSpace 0
11910: oTypeSNodeType
11911: oChoice 11919
11913: oJumpForward 11926
11915: oEmit 30
11917: oJumpForward 11926
11919: Choice Lookup Table
          29   11915
          28   11913
11924: oError 7
11926: oTypeSPop
11927: oReturn
11928: oLocalSpace 0
11930: oTypeSNodeType
11931: oChoice 11946
11933: oJumpForward 11953
11935: oEmit 30
11937: oTypeSPop
11938: oGetGlobal 6
11940: oPushResult
11941: oTypeSPush
11942: oPop 1
11944: oJumpForward 11953
11946: Choice Lookup Table
          29   11935
          28   11933
11951: oError 7
11953: oReturn
11954: oLocalSpace 0
11956: oTypeSNodeType
11957: oChoice 11970
11959: oEmit 30
11961: oTypeSPop
11962: oGetGlobal 6
11964: oPushResult
11965: oTypeSPush
11966: oPop 1
11968: oJumpForward 11973
11970: Choice Lookup Table
          29   11959
11973: oReturn
11974: oLocalSpace 0
11976: oTypeSNodeType
11977: oChoice 11981
11979: oJumpForward 11986
11981: Choice Lookup Table
          30   11979
11984: oError 8
11986: oTypeSPop
11987: oReturn
11988: oLocalSpace 0
11990: oTypeSNodeType
11991: oChoice 11995
11993: oJumpForward 12000
11995: Choice Lookup Table
          30   11993
11998: oError 8
12000: oReturn
12001: oLocalSpace 1
12003: oGetAddrLocal 1
12005: oPushResult
12006: oGetParam 2
12008: oPushResult
12009: oNodeNew
12010: oPop 1
12012: oAssign
12013: oGetLocal 1
12015: oPushResult
12016: oSetResult 17
12018: oPushResult
12019: oGetParam 1
12021: oPushResult
12022: oNodeSetInt
12023: oPop 3
12025: oGetLocal 1
12027: oPushResult
12028: oTypeAdd
12029: oPop 1
12031: oGetLocal 1
12033: oReturn
12034: oReturn
12035: oLocalSpace 1
12037: oGetAddrLocal 1
12039: oPushResult
12040: oGetParam 2
12042: oPushResult
12043: oNodeNew
12044: oPop 1
12046: oAssign
12047: oGetLocal 1
12049: oPushResult
12050: oSetResult 4
12052: oPushResult
12053: oGetParam 1
12055: oPushResult
12056: oNodeSetInt
12057: oPop 3
12059: oGetLocal 1
12061: oReturn
12062: oReturn
12063: oLocalSpace 1
12065: oGetAddrLocal 1
12067: oPushResult
12068: oGetParam 1
12070: oPushResult
12071: oSetResult 35
12073: oPushResult
12074: oNodeGet
12075: oPop 2
12077: oAssign
12078: oGetLocal 1
12080: oPushResult
12081: oNodeNull
12082: oPop 1
12084: oChoice 12140
12086: oGetAddrLocal 1
12088: oPushResult
12089: oSetResult 33
12091: oPushResult
12092: oNodeNew
12093: oPop 1
12095: oAssign
12096: oGetLocal 1
12098: oPushResult
12099: oSetResult 36
12101: oPushResult
12102: oGetParam 1
12104: oPushResult
12105: oNodeSet
12106: oPop 3
12108: oGetLocal 1
12110: oPushResult
12111: oSetResult 17
12113: oPushResult
12114: oSetResult 8
12116: oPushResult
12117: oNodeSetInt
12118: oPop 3
12120: oGetLocal 1
12122: oPushResult
12123: oTypeAdd
12124: oPop 1
12126: oGetParam 1
12128: oPushResult
12129: oSetResult 35
12131: oPushResult
12132: oGetLocal 1
12134: oPushResult
12135: oNodeSet
12136: oPop 3
12138: oJumpForward 12143
12140: Choice Lookup Table
           1   12086
12143: oGetLocal 1
12145: oReturn
12146: oReturn
12147: oLocalSpace 2
12149: oGetParam 1
12151: oPushResult
12152: oNodeType
12153: oPop 1
12155: oChoice 12225
12157: oMININT
12158: oReturn
12159: oJumpForward 12241
12161: oSetResult 0
12163: oReturn
12164: oJumpForward 12241
12166: oSetResult 0
12168: oReturn
12169: oJumpForward 12241
12171: oGetAddrLocal 1
12173: oPushResult
12174: oGetParam 1
12176: oPushResult
12177: oSetResult 40
12179: oPushResult
12180: oNodeGet
12181: oPop 2
12183: oAssign
12184: oGetAddrLocal 2
12186: oPushResult
12187: oGetLocal 1
12189: oPushResult
12190: oSetResult 15
12192: oPushResult
12193: oNodeGetIter
12194: oPop 2
12196: oPushResult
12197: oNodeIterValue
12198: oPop 1
12200: oAssign
12201: oGetLocal 2
12203: oPushResult
12204: oSetResult 22
12206: oPushResult
12207: oNodeGetInt
12208: oPop 2
12210: oReturn
12211: oJumpForward 12241
12213: oGetParam 1
12215: oPushResult
12216: oSetResult 38
12218: oPushResult
12219: oNodeGetInt
12220: oPop 2
12222: oReturn
12223: oJumpForward 12241
12225: Choice Lookup Table
          36   12213
          40   12171
          32   12166
          30   12161
          28   12157
12236: oError 3
12238: oSetResult 0
12240: oReturn
12241: oReturn
12242: oLocalSpace 2
12244: oGetParam 1
12246: oPushResult
12247: oNodeType
12248: oPop 1
12250: oChoice 12320
12252: oMAXINT
12253: oReturn
12254: oJumpForward 12336
12256: oSetResult 1
12258: oReturn
12259: oJumpForward 12336
12261: oSetResult 255
12263: oReturn
12264: oJumpForward 12336
12266: oGetAddrLocal 1
12268: oPushResult
12269: oGetParam 1
12271: oPushResult
12272: oSetResult 40
12274: oPushResult
12275: oNodeGet
12276: oPop 2
12278: oAssign
12279: oGetAddrLocal 2
12281: oPushResult
12282: oGetLocal 1
12284: oPushResult
12285: oSetResult 15
12287: oPushResult
12288: oNodeGetIterLast
12289: oPop 2
12291: oPushResult
12292: oNodeIterValue
12293: oPop 1
12295: oAssign
12296: oGetLocal 2
12298: oPushResult
12299: oSetResult 22
12301: oPushResult
12302: oNodeGetInt
12303: oPop 2
12305: oReturn
12306: oJumpForward 12336
12308: oGetParam 1
12310: oPushResult
12311: oSetResult 39
12313: oPushResult
12314: oNodeGetInt
12315: oPop 2
12317: oReturn
12318: oJumpForward 12336
12320: Choice Lookup Table
          36   12308
          40   12266
          32   12261
          30   12256
          28   12252
12331: oError 3
12333: oSetResult 0
12335: oReturn
12336: oReturn
12337: oLocalSpace 0
12339: oGetParam 1
12341: oPushResult
12342: oSetResult 22
12344: oPushResult
12345: oNodeGetInt
12346: oPop 2
12348: oPushResult
12349: oEmitInt
12350: oPop 1
12352: oReturn
12353: oLocalSpace 1
12355: oGetAddrLocal 1
12357: oPushResult
12358: oSetResult 14
12360: oPushResult
12361: oGetParam 1
12363: oPushResult
12364: oCall 12035
12366: oPop 2
12368: oAssign
12369: oGetLocal 1
12371: oPushResult
12372: oScopeDeclare
12373: oPop 1
12375: oGetLocal 1
12377: oReturn
12378: oReturn
12379: oLocalSpace 1
12381: oGetAddrGlobal 4
12383: oPushResult
12384: oId_mysystem
12385: oAssign
12386: oGetAddrGlobal 5
12388: oPushResult
12389: oSetResult 27
12391: oPushResult
12392: oSetResult 4
12394: oPushResult
12395: oCall 12001
12397: oPop 2
12399: oAssign
12400: oGetAddrGlobal 6
12402: oPushResult
12403: oSetResult 28
12405: oPushResult
12406: oSetResult 4
12408: oPushResult
12409: oCall 12001
12411: oPop 2
12413: oAssign
12414: oGetAddrGlobal 7
12416: oPushResult
12417: oSetResult 30
12419: oPushResult
12420: oSetResult 1
12422: oPushResult
12423: oCall 12001
12425: oPop 2
12427: oAssign
12428: oGetAddrGlobal 8
12430: oPushResult
12431: oSetResult 31
12433: oPushResult
12434: oSetResult 1
12436: oPushResult
12437: oCall 12001
12439: oPop 2
12441: oAssign
12442: oGetAddrGlobal 9
12444: oPushResult
12445: oSetResult 32
12447: oPushResult
12448: oSetResult 1
12450: oPushResult
12451: oCall 12001
12453: oPop 2
12455: oAssign
12456: oGetAddrGlobal 10
12458: oPushResult
12459: oGetGlobal 9
12461: oPushResult
12462: oCall 12063
12464: oPop 1
12466: oAssign
12467: oGetAddrGlobal 11
12469: oPushResult
12470: oSetResult 29
12472: oPushResult
12473: oSetResult 1
12475: oPushResult
12476: oCall 12001
12478: oPop 2
12480: oAssign
12481: oGetAddrGlobal 12
12483: oPushResult
12484: oSetResult 34
12486: oPushResult
12487: oSetResult 8
12489: oPushResult
12490: oCall 12001
12492: oPop 2
12494: oAssign
12495: oGetGlobal 12
12497: oPushResult
12498: oSetResult 36
12500: oPushResult
12501: oGetGlobal 11
12503: oPushResult
12504: oNodeSet
12505: oPop 3
12507: oGetAddrGlobal 13
12509: oPushResult
12510: oSetResult 38
12512: oPushResult
12513: oSetResult 256
12515: oPushResult
12516: oCall 12001
12518: oPop 2
12520: oAssign
12521: oGetAddrGlobal 14
12523: oPushResult
12524: oSetResult 39
12526: oPushResult
12527: oSetResult 256
12529: oPushResult
12530: oCall 12001
12532: oPop 2
12534: oAssign
12535: oGetGlobal 14
12537: oPushResult
12538: oSetResult 41
12540: oPushResult
12541: oSetResult 255
12543: oPushResult
12544: oNodeSetInt
12545: oPop 3
12547: oGetAddrLocal 1
12549: oPushResult
12550: oSetResult 18
12552: oPushResult
12553: oId_File
12554: oPushResult
12555: oCall 12035
12557: oPop 2
12559: oAssign
12560: oGetLocal 1
12562: oPushResult
12563: oSetResult 21
12565: oPushResult
12566: oGetGlobal 5
12568: oPushResult
12569: oNodeSet
12570: oPop 3
12572: oGetLocal 1
12574: oPushResult
12575: oScopeDeclare
12576: oPop 1
12578: oGetAddrLocal 1
12580: oPushResult
12581: oSetResult 18
12583: oPushResult
12584: oId_Integer
12585: oPushResult
12586: oCall 12035
12588: oPop 2
12590: oAssign
12591: oGetLocal 1
12593: oPushResult
12594: oSetResult 21
12596: oPushResult
12597: oGetGlobal 6
12599: oPushResult
12600: oNodeSet
12601: oPop 3
12603: oGetLocal 1
12605: oPushResult
12606: oScopeDeclare
12607: oPop 1
12609: oGetAddrLocal 1
12611: oPushResult
12612: oSetResult 18
12614: oPushResult
12615: oId_Boolean
12616: oPushResult
12617: oCall 12035
12619: oPop 2
12621: oAssign
12622: oGetLocal 1
12624: oPushResult
12625: oSetResult 21
12627: oPushResult
12628: oGetGlobal 7
12630: oPushResult
12631: oNodeSet
12632: oPop 3
12634: oGetLocal 1
12636: oPushResult
12637: oScopeDeclare
12638: oPop 1
12640: oGetAddrLocal 1
12642: oPushResult
12643: oSetResult 18
12645: oPushResult
12646: oId_Char
12647: oPushResult
12648: oCall 12035
12650: oPop 2
12652: oAssign
12653: oGetLocal 1
12655: oPushResult
12656: oSetResult 21
12658: oPushResult
12659: oGetGlobal 9
12661: oPushResult
12662: oNodeSet
12663: oPop 3
12665: oGetLocal 1
12667: oPushResult
12668: oScopeDeclare
12669: oPop 1
12671: oGetAddrLocal 1
12673: oPushResult
12674: oSetResult 18
12676: oPushResult
12677: oId_Byte
12678: oPushResult
12679: oCall 12035
12681: oPop 2
12683: oAssign
12684: oGetLocal 1
12686: oPushResult
12687: oSetResult 21
12689: oPushResult
12690: oGetGlobal 11
12692: oPushResult
12693: oNodeSet
12694: oPop 3
12696: oGetLocal 1
12698: oPushResult
12699: oScopeDeclare
12700: oPop 1
12702: oGetAddrLocal 1
12704: oPushResult
12705: oSetResult 18
12707: oPushResult
12708: oId_Pointer
12709: oPushResult
12710: oCall 12035
12712: oPop 2
12714: oAssign
12715: oGetLocal 1
12717: oPushResult
12718: oSetResult 21
12720: oPushResult
12721: oGetGlobal 12
12723: oPushResult
12724: oNodeSet
12725: oPop 3
12727: oGetLocal 1
12729: oPushResult
12730: oScopeDeclare
12731: oPop 1
12733: oGetAddrLocal 1
12735: oPushResult
12736: oSetResult 18
12738: oPushResult
12739: oId_ShortString
12740: oPushResult
12741: oCall 12035
12743: oPop 2
12745: oAssign
12746: oGetLocal 1
12748: oPushResult
12749: oSetResult 21
12751: oPushResult
12752: oGetGlobal 14
12754: oPushResult
12755: oNodeSet
12756: oPop 3
12758: oGetLocal 1
12760: oPushResult
12761: oScopeDeclare
12762: oPop 1
12764: oGetAddrLocal 1
12766: oPushResult
12767: oSetResult 16
12769: oPushResult
12770: oId_True
12771: oPushResult
12772: oCall 12035
12774: oPop 2
12776: oAssign
12777: oGetLocal 1
12779: oPushResult
12780: oSetResult 21
12782: oPushResult
12783: oGetGlobal 7
12785: oPushResult
12786: oNodeSet
12787: oPop 3
12789: oGetLocal 1
12791: oPushResult
12792: oSetResult 22
12794: oPushResult
12795: oSetResult 1
12797: oPushResult
12798: oNodeSetInt
12799: oPop 3
12801: oGetLocal 1
12803: oPushResult
12804: oScopeDeclare
12805: oPop 1
12807: oGetAddrLocal 1
12809: oPushResult
12810: oSetResult 16
12812: oPushResult
12813: oId_False
12814: oPushResult
12815: oCall 12035
12817: oPop 2
12819: oAssign
12820: oGetLocal 1
12822: oPushResult
12823: oSetResult 21
12825: oPushResult
12826: oGetGlobal 7
12828: oPushResult
12829: oNodeSet
12830: oPop 3
12832: oGetLocal 1
12834: oPushResult
12835: oSetResult 22
12837: oPushResult
12838: oSetResult 0
12840: oPushResult
12841: oNodeSetInt
12842: oPop 3
12844: oGetLocal 1
12846: oPushResult
12847: oScopeDeclare
12848: oPop 1
12850: oGetAddrLocal 1
12852: oPushResult
12853: oSetResult 16
12855: oPushResult
12856: oId_Nil
12857: oPushResult
12858: oCall 12035
12860: oPop 2
12862: oAssign
12863: oGetLocal 1
12865: oPushResult
12866: oSetResult 21
12868: oPushResult
12869: oGetGlobal 12
12871: oPushResult
12872: oNodeSet
12873: oPop 3
12875: oGetLocal 1
12877: oPushResult
12878: oSetResult 22
12880: oPushResult
12881: oSetResult 0
12883: oPushResult
12884: oNodeSetInt
12885: oPop 3
12887: oGetLocal 1
12889: oPushResult
12890: oScopeDeclare
12891: oPop 1
12893: oGetAddrGlobal 15
12895: oPushResult
12896: oId_Ord
12897: oPushResult
12898: oCall 12353
12900: oPop 1
12902: oAssign
12903: oGetAddrGlobal 16
12905: oPushResult
12906: oId_Chr
12907: oPushResult
12908: oCall 12353
12910: oPop 1
12912: oAssign
12913: oGetAddrGlobal 17
12915: oPushResult
12916: oId_Pred
12917: oPushResult
12918: oCall 12353
12920: oPop 1
12922: oAssign
12923: oGetAddrGlobal 18
12925: oPushResult
12926: oId_Succ
12927: oPushResult
12928: oCall 12353
12930: oPop 1
12932: oAssign
12933: oReturn
