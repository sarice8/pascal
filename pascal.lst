   2: title: 'Pascal Compiler 1.1.5 -- Jan 01 ''90';
         
      %
      %  Pascal.ssl
      %
      %  Pascal Compiler for the Amiga, by Steve Rice.
      %
      %  HISTORY
      %    11Sep89   First version, framework of parser.
      %    18Sep89   Added some semantic mechanisms.
      %    21Sep89   Added simple type references; expressions generate code.
      %    22Sep89   Allocate variable addresses as they're declared.
      %    24Sep89   Added arrays, pointers.
      %    27Sep89   Added for statement.
      %    23Oct89   Fixed for statement, so CYCLE goes to next step.
      %    01Jan90   Added string literals
      %    09Sep22   I have returned.  Migrate symbol table to schema, to ease development.
      %    01Oct22   Language: Switch from cycle/exit (Mac Pascal extension) to continue/break (Borland).
      %
      %  NOTES
      %    -  The 'value' of a var symbol is its allocated address.
      %    -  References to vars of intrinsic types, and pointer types,
      %       pushes the value of the var on the expr stack.  Referenecs to
      %       vars of compound types (arrays, records...) pushes the address
      %       on the expr stack.
      %    -  Just as there is only one type table entry for a given (named) type,
      %       there is only one type table entry for a pointer to a named type.
      %       When a pointer type is declared, a field in the TT entry of the
      %       type pointed to will be set to indicate the TT entry of the pointer
      %       to that type (0 means none defined yet).  When evaluating the
      %       expression ^x, the type in that field in the entry for the type of x
      %       will be used (unless it's 0, in which case a new TT entry will be
      %       created).
      %
      %
      %  MISSING
      %
      %    - Forward declaration of proceudres and functions.
      %      Only one forward declaration should be allowed.
      %      I will overwrite the nMethod info with the final addr and param names when the true body is seen.
      %      If a call is made to a foward declared method, add the forward decl node & Here to patch table.
      % 
      %    - procedure and function declarations may be nested within other procs/funcs!
      %      They are allowed to see locals within those parent scopes.
      %      Pass a hidden parameter to nested methods, to follow up to parent scopes as needed.
      %      Need a level counter at each scope, and uplevels count on reference to local/param.
      %      
      %    - Consider non-ISO extensions.  e.g. see "Units" e.g. from Turbo Pascal wikipedia page.
      %      Dynamic arrays.  Objects.  But, perhaps stick to my old goal, standard Pascal.
      %
      %
      %  PASCAL DOCS
      %      Here's some handy language material:
      %      https://www.freepascal.org/docs-html/ref/ref.html
      %      https://www.freepascal.org/docs-html/prog/prog.html
      %      https://en.wikipedia.org/wiki/Turbo_Pascal
      %      https://en.wikipedia.org/wiki/Pascal_(programming_language)#Standards
      %      http://www.standardpascaline.org/
      %
      
   2: input:
   2:    pIdent
   2:    pIntLit
   2:    pStrLit
   2:    pAssign       ':='
   2:    pSemiColon    ';'
   2:    pEqual        '='
   2:    pNotEqual     '<>'
   2:    pLess         '<'
   2:    pGreater      '>'
   2:    pLessEqual    '<='
   2:    pGreaterEqual '>='
   2:    pColon        ':'
   2:    pComma        ','
   2:    pLParen       '('
   2:    pRParen       ')'
   2:    pLSquare      '['
   2:    pRSquare      ']'
   2:    pCarat        '^'
   2:    pAt           '@'
   2:    pDot          '.'
   2:    pDotDot       '..'
   2:    pTimes        '*'
   2:    pDivide       '/'
   2:    pPlus         '+'
   2:    pMinus        '-'
   2:    pEof
   2:    pInvalid
      
      %  keywords  (built-in types 'integer', 'char', etc, are not keywords,
      %             type constructors 'array', 'record', 'set' are keywords,
      %             pseudo-procedures 'writeln', 'readln' are keywords)
      %
      %             forward/external/name/cdecl appear in method modifiers, in fpc grammar.
      %             I'm making them keywords to simplify parsing, but could reconsider.
      
   2:    pProgram
   2:    pProcedure
   2:    pFunction
   2:    pConst
   2:    pType
   2:    pVar
   2:    pBegin
   2:    pEnd
   2:    pArray
   2:    pRecord
   2:    pSet
   2:    pOf
   2:    pIf
   2:    pThen
   2:    pElse
   2:    pFor
   2:    pTo
   2:    pDownto
   2:    pDo
   2:    pWhile
   2:    pRepeat
   2:    pUntil
   2:    pContinue
   2:    pBreak
   2:    pAnd
   2:    pOr
   2:    pNot
   2:    pWriteln
   2:    pWrite
   2:    pReadln
   2:    pRead
   2:    pForward
   2:    pExternal
   2:    pName
   2:    pCdecl
   2:    ;
      
      
   2: output:
      
      %  Instructions for a stack machine (all vars are 32-bit integers)
      
   2:    tPushGlobalI      % <ptr> - push int value read from ptr
   2:    tPushGlobalB      % <ptr> - push byte value read from ptr
   2:    tPushGlobalP      % <ptr> - push ptr value read from ptr
   2:    tPushLocalI       % <offset> - push int value read from local var
   2:    tPushLocalB       % <offset> - push byte value read from local var
   2:    tPushLocalP       % <offset> - push ptr value read from local var
   2:    tPushParamI       % <offset> - push int value read from local var
   2:    tPushParamB       % <offset> - push byte value read from local var
   2:    tPushParamP       % <offset> - push ptr value read from local var
      
   2:    tPushConstI       % <int> - push int value on stack (NOTE, used for BOOLEAN too)
   2:    tPushAddrGlobal   % <offset> - push ptr to global var (same as tPushConstP)
   2:    tPushAddrLocal    % <offset> - push ptr to local var
   2:    tPushAddrParam    % <offset> - push ptr to formal param (used by method to see its param)
   2:    tPushAddrActual   % <offset> - push ptr to actual param, in actuals space (used by caller)
   2:    tFetchI           % pop ptr from stack, and push int value it points to
   2:    tFetchB           %    "      "      "     "     byte  "   "    "
   2:    tFetchP           %    "      "      "     "     ptr   "   "    "   
   2:    tAssignI          % assign int value on top of stack to addr under it (pop both)
   2:    tAssignB          %   "    byte   "    "   "  "   "    "    "   "   "
   2:    tAssignP          %   "    ptr    "    "   "  "   "    "    "   "   "
   2:    tCopy             % <#bytes> - copy bytes.  tos=src, 2nd=dest (pop 2)
   2:    tIncI             % increment int value on top of expr stack
   2:    tDecI             % decrement int value on top of expr stack
   2:    tMultI            % multiply top two integers (replacing with result)
   2:    tDivI
   2:    tAddPI            % add ptr (2nd value) and int (top value), resulting in a ptr
   2:    tAddI
   2:    tSubI
   2:    tNegI             % top entry *= -1
   2:    tNot              % negate top boolean
   2:    tEqualI           % top two entries equal? (pop 2, push 1) (true=1)
   2:    tNotEqualI        %    NOTE, these all work for booleans too
   2:    tGreaterI         % 2nd entry greater than top entry? (pop 2, push answer)
   2:    tLessI  
   2:    tGreaterEqualI
   2:    tLessEqualI
   2:    tEqualP           % two two pointer values equal? (pop 2, push 1) (true=1)
   2:    tNotEqualP
   2:    tAllocActuals     % <#bytes> - make space on call stack for actual params (adjusting call stack sp)
   2:    tAllocActualsCdecl  % <#bytes> - starting a call to a cdecl method.  tcode still describes my own calling convention.
   2:    tFreeActuals      % <#bytes> - discard space on call stack allocated by tAllocActuals
   2:    tCall             % <label#>
   2:    tCallCdecl        % <label#> - call a method using native (C) calling convention. Only supported for extern labels.
   2:    tReturn
   2:    tEnter            % <#bytes> - start a stack frame on the call stack, reserving #bytes of local variable space
   2:    tJump             % <label#>
   2:    tJumpTrue         % <label#>  (pops top of stack, jumps if true)
   2:    tJumpFalse        % <label#>  (pops top of stack, jumps if false)
   2:    tLabel            % <label#> - define label# at the current address
   2:    tLabelAlias       % <label#> <aliasToLabel#> - defines label to be an alias of another label
   2:    tLabelExtern      % <label#> <offsetToStrLit> - defines label to mean an extern symbol, whose name is in global data
   2:    tWriteI           % for writeln : write integer on tos, pop
   2:    tWriteBool        %  "     "    : write TRUE/FALSE, pop
   2:    tWriteStr         %  "     "    : write string whose addr is on tos, pop
   2:    tWriteP           %  "     "    : write ptr var whose addr is on tos, pop
   2:    tWriteCR          %  "     "    : write cr
      
      %  Other:
      
   2:    tSpace            % emit a hole, to be patched later
   2:    ;
      
   2: error:
   2:    eBadStatement
   2:    eNotConst
   2:    eNotType
   2:    eNotOrdinalType
   2:    eNotVar
   2:    eNotIntVar
   2:    eNotValue
   2:    eNotInteger
   2:    eNotBoolean
   2:    eNotPointer
   2:    eNotArray
   2:    eNotRecord
   2:    eNotRecordField
   2:    eTooManySubscripts
   2:    eTypeMismatch
   2:    eMissingParameter
   2:    eNotImplemented
   2:    eNotAllowed
   2:    eNotInALoop
   2:    eRecordEmpty
   2:    eNotCurrentFunction
   2:    eAlreadyDefined
   2:    ;
      
   2: include 'pascal_schema.ssl'
      
      % Generated automatically by schema
      
   2: type node_type:
   2: 	nINVALID
   2: 	Object
   2: 	nScope
   2: 	nDeclaration
   2: 	nIdent
   2: 	nProgram
   2: 	nMethod
   2: 	nProc
   2: 	nFunc
   2: 	nConst
   2: 	nTypeDecl
   2: 	nVar
   2: 	nGlobalVar
   2: 	nLocalVar
   2: 	nRecordField
   2: 	nParam
   2: 	nType
   2: 	nFileType
   2: 	nIntegerType
   2: 	nBooleanType
   2: 	nBooleanCFType
   2: 	nCharType
   2: 	nStringType
   2: 	nPointerType
   2: 	nArrayType
   2: 	nSubrangeType
   2: 	nRecordType
   2: 	nEnumType
   2: 	nSetType
   2: 	;
      
   2: type node_attribute:
   2: 	qINVALID
   2: 	qDecls
   2: 	qSize
   2: 	qAllocDown
   2: 	qIdent
   2: 	qType
   2: 	qValue
   2: 	qMainRoutineScope
   2: 	qParams
   2: 	qChildScope
   2: 	qBodyDefined
   2: 	qExternal
   2: 	qCdecl
   2: 	qCalled
   2: 	qOldParams
   2: 	qOldType
   2: 	qResultOffset
   2: 	qInOut
   2: 	qPointerType
   2: 	qBaseType
   2: 	qIndexType
   2: 	qLow
   2: 	qHigh
   2: 	qScope
   2: 	;
      
      
   2: type Node:     % A pointer to a node in the schema database (symbol database)
   2:     Null = 0
   2:     ;
      
   2: type NodeVec:  % A pointer to a vector of Node.  See mechanism node_vec_mech
   2:     NullVec = 0
   2:     ;
      
   2: type boolean:
   2:    false    = 0
   2:    true     = 1;
      
   2: type kind:           % kind of identifier
   2:    kUndefined        % not yet added to symbol table
   2:    kProgram
   2:    kProc
   2:    kFunc
   2:    kConst
   2:    kType
   2:    kVar;
      
      % intrinsic types & type constructs
      
   2: type typ:
   2:    tyNone     = 0    % in ptrTyp field of TT, means no ptr to type defined
   2:    tyInteger
   2:    tyBoolean
   2:    tyChar
   2:    tyString
   2:    tyFile            % tyInteger..tyFile are scalars (types on their own)
   2:    tyPointer         % following are type constructor classes...
   2:    tyArray           %   (they are not type#'s)
   2:    tyRecord
   2:    tyParams          % like record; a collection of proc/func params
   2:    tySet;
      
   2: type Label:
   2:    labelNull;
      
      
      % Some general schema node operations.
      % node_type and node_attribute are defined in generated file pascal_schema.ssl included above.
      %
   2: mechanism node_mech:
   2:     oNodeNew (node_type) >> Node         % create new node
   2:     oNodeSet (Node, node_attribute, Node)   % set Node attribute of node
   2:     oNodeSetInt (Node, node_attribute, int) % set int attribute of node
   2:     oNodeSetBoolean (Node, node_attribute, boolean)
   2:     oNodeSetKind (Node, node_attribute, kind) % set attribute of node  *** MIGHT NOT NEED
   2:     oNodeSetLabel( Node, node_attribute, Label )  % set Label attribute of node
   2:     oNodeGet (Node, node_attribute) >> Node    % get Node attribute of node
   2:     oNodeGetInt (Node, node_attribute) >> int  % get int attribute of node
   2:     oNodeGetBoolean (Node, node_attribute) >> boolean  % get int attribute of node
   2:     oNodeGetLabel (Node, node_attribute) >> Label      % get Label attribute of node
   2:     oNodeNull (Node) >> boolean          % is node null?
   2:     oNodeNext (inout Node)               % advance Node to next in list
   2:     oNodeType (Node) >> node_type        % return node type of node
   2:     oNodeEqual (Node, Node) >> boolean   % compare two nodes for equality
                                               % (i.e. same node, not just same contents)
   2:     ;
      
      
      % Manipulate a temporary vector of Node
      %
   2: mechanism node_vec_mech:
   2:     oNodeVecNew >> NodeVec
   2:     oNodeVecDelete( NodeVec nv )
   2:     oNodeVecAppend( NodeVec nv, Node n )
   2:     oNodeVecSize( NodeVec nv ) >> int                % how many elements
   2:     oNodeVecElement( NodeVec nv, int idx ) >> Node   % element at index idx (0..size-1)
   2:     ;
      
      
      
   2: mechanism emit_mech:
   2:     oEmitInt( int )              % emit int into the generated code
   2:     oEmitLabel( Label )
   2:     Here >> int                  % current address in the generated code
   2:     oPatch( int addr, int val )  % patch an int into address in the generated code
   2:     ;
      
   2: mechanism math:
   2:     inc (inout int)
   2:     dec (inout int)
   2:     negate (int) >> int
   2:     subtract( int x, int y ) >> int     % x - y
   2:     multiply( int x, int y ) >> int     % x * y
   2:     equal( int x, int y ) >> boolean
   2:     equal_zero (int) >> boolean
   2:     equal_node_type (node_type, node_type) >> boolean     % Want equal_<type> for every type
   2:     equal_label( Label, Label ) >> boolean
   2:     oMININT >> int    % the minimum 32-bit integer.  necessary because ssl literal ints are currently (silently) short (!)
   2:     ;
      
   2: mechanism more_builtins:      % These should be built-in SSL operations
   2:     TOKEN_VALUE >> int        % value of just accepted token, e.g. IntLit token
   2:     LAST_ID >> int            % id number of last accepted identifier
   2:     ;
      
   2: mechanism scope_mech:
   2:     oScopeBegin                          % create a new scope. Subsequent declarations will go here.
   2:     oScopeEnter( Node scope )            % enter an existing scope.
   2:     oScopeEnd                            % end current scope. Subsequent declarations will go to previous scope.
   2:     oScopeCurrent >> Node                % returns current scope
   2:     oScopeDeclare( Node decl )           % add declaration to current scope.
   2:     oScopeDeclareAlloc( Node decl )      % add declaration to current scope, and allocate space according to its type
   2:     oScopeAllocType( Node theType ) >> int   % allocate space for type in current scope, and return its address
   2:     oScopeFind >> Node                   % find declaration of last accepted identifier.  Returns Null if not found.
   2:     oScopeFindRequire >> Node            % find declaration of last accepted identifier.  Error if not found.
   2:     oScopeFindInCurrentScope >> Node     % find declaration of last accepted identifier, only within the current scope.  Null if not found.
   2:     ;
      
      
   2: mechanism type_mech:
   2:     oTypeAdd( Node node )     % add the given nType to the type table
   2:     ;
      
   2: mechanism type_stack_mech:
   2:     oTypeSPush( Node node )
   2:     oTypeSPop
   2:     oTypeSTop >> Node
   2:     oTypeSNodeType >> node_type          % node_type of the node on top of type stack, skipping subranges
   2:     ;
      
      
   2: mechanism id_mech:
          % adds a predefined id to the scanner's id table, and returns the id code
   2:     oIdAdd_File >> int
   2:     oIdAdd_Integer >> int
   2:     oIdAdd_Boolean >> int
   2:     oIdAdd_Char >> int
   2:     oIdAdd_String >> int
   2:     oIdAdd_True >> int
   2:     oIdAdd_False >> int
   2:     ;
      
      
      
   2: mechanism label_mech:
   2:    oLabelNew >> Label
   2:    ;
      
   2: mechanism count :
   2:    oCountPush(int)          % start a new counter, with initial value
   2:    oCountInc
   2:    oCountDec
   2:    oCountIsZero >> boolean
   2:    oCountPop;
      
      
   2: mechanism value :              % value stack, to calc. const expr's
   2:    oValuePush(int)             % push an explicit int lit
   2:    oValueNegate                % negate top value
   2:    oValueTop >> int            % get top value on value stack
   2:    oValuePop;
      
   2: mechanism string :
   2:    oStringAllocLit >> int      % alloc global space for strlit, return address
   2:    oStringAllocLitFromIdent( int id ) >> int  % alloc global space for strlit taken from name of ident;
                                                    %  return address
   2:    ;
      
      % track labels for the loop we're in, if any
   2: mechanism loop_mech:
   2:    oLoopPush( Label continueLabel, Label breakLabel )
   2:    oLoopContinueLabel >> Label
   2:    oLoopBreakLabel >> Label
   2:    oLoopPop
   2:    ;
      
      % for hacky debugging
   2: mechanism msg_mech:
   2:    oMsg( int num )             % print message "oMsg <num>"
   2:    oMsgTrace( int num )        % print message "oMsg <num>" followed by ssl traceback
   2:    oMsgNode( Node node )       % print node
   2:    oMsgNodeVec( NodeVec vec )  % print node vec
   2:    ;
      
      
   2: rules
      
      % ----------------------------- Global Variables ----------------------------
      
   2: Node    globalScope            % global nScope
      
      % built-in nTypes
   2: Node    FileType
   2: Node    IntegerType
   2: Node    BooleanType
   2: Node    BooleanCFType
   2: Node    CharType
   2: Node    StringType
      
      % -------------------------- Forward Declarations -------------------------
      
   2: Block( node_type varNodeType, Label labelForBody );
   2: BlockDecls( node_type varNodeType );
   2: BlockStmt( Label labelForBody );
   2: VarDecl( node_type varNodeType );
   2: newType( node_type nt, int size ) >> Node;
   2: newIdent( node_type nt, kind k, int id ) >> Node;
   2: EmitValue( Node decl );
   2: TypeRef( out Node theType );
   2: PointerTypeTo( Node theType ) >> Node;
   2: OrdinalLow( Node theType ) >> int;
   2: AssignStmt( Node decl );
   2: BooleanExprControlFlow( out Label falseLabel );
   2: ExprAllowCF( out Label falseLabel );
   2: BoolExprAllowCF( out Label falseLabel );
   2: BoolTermAllowCF( out Label falseLabel );
   2: BoolFactorAllowCF( out Label falseLabel );
   2: ArithExprAllowCF( out Label falseLabel );
   2: TermAllowCF( out Label falseLabel );
   2: FactorAllowCF( out Label falseLabel );
   2: PrimaryAllowCF( out Label falseLabel );
      
      
      
   2: VarExpr( Node decl );
   2: LValueVar( Node decl );
   2: IncVar( Node decl );
   2: DecVar( Node decl );
      
   2: CFToVal( inout Label falseLabel );
   2: ValToCF( out Label falseLabel );
      
      % ----------------------------- Declarations ----------------------------
      
   2: Program:
   4:    Node t
      
   4:    oScopeBegin
   5:    globalScope = oScopeCurrent
      
  10:    @installBuiltIns
      
         % Start by calling the main program routine.
      
         % This dummy call to main needs to look like a normal method itself,
         % so jit can align the stack properly.  So we need .tEnter,
         % and .tAllocActuals / .tFreeActuals.
  12:    .tEnter  oEmitInt( 0 )
  20:    Label mainLabel = oLabelNew
      
  25:    .tAllocActuals  oEmitInt( 0 )
  33:    .tCall  oEmitLabel( mainLabel )
  41:    .tFreeActuals  oEmitInt( 0 )
  49:    .tReturn
      
  51:    pProgram
  53:    pIdent
      
  55:    Node progDecl = @newIdent( nProgram, kProgram, LAST_ID )
  71:    oScopeDeclare( progDecl )
      
  77:    [
  77:       | '(' :
  79:          pIdent      % input, output files
      
  81:          t = @newIdent( nVar, kVar, LAST_ID )
  97:          oNodeSet( t, qType, FileType )
 109:          oScopeDeclareAlloc( t )
      
 115:          ','
 117:          pIdent
      
 119:          t = @newIdent( nVar, kVar, LAST_ID )
 135:          oNodeSet( t, qType, FileType )
 147:          oScopeDeclareAlloc( t )
      
 153:          ')'
 155:       | * :
 160:    ]
 160:    ';'
      
 162:    @BlockDecls( nGlobalVar )
      
         % a new scope just for temporaries in the main routine
 169:    oScopeBegin
 170:    oNodeSetBoolean( oScopeCurrent, qAllocDown, true )
 181:    oNodeSet( progDecl, qMainRoutineScope, oScopeCurrent )
      
         % The block statement includes a stack frame, and enter/return,
         % even for the main routine.
         % That will be necessary for temporaries allocated in the main routine.
 192:    @BlockStmt( mainLabel )
      
 199:    oScopeEnd   % main routine scope
      
 200:    '.'
 202:    oScopeEnd   % global scope
 204:    ;
      
      
 204: Block( node_type varNodeType, Label labelForBody ):
 206:    @BlockDecls( varNodeType )
 213:    @BlockStmt( labelForBody )
 221:    ;
      
      
 221: BlockDecls( node_type varNodeType ):
 223:    {[
 223:       | pConst :     @ConstDecl
 227:       | pType :      @TypeDecl
 231:       | pVar :       @VarDecl( varNodeType )
 240:       | pProcedure : @ProcDecl
 244:       | pFunction :  @FuncDecl
 248:       | * :          >
 263:    ]}
 265:    @CheckForUndefinedMethods
 268:    ;
      
      
      % were there any procedures or functions declared in this scope
      % that were never defined?
 268: CheckForUndefinedMethods:
         % TO DO
         % Note: disregard methods marked external
 271:    ;
      
      
      
 271: BlockStmt( Label labelForBody ):
 273:    .tLabel  oEmitLabel( labelForBody )
      
         % Proc, func, and main routine all start with tEnter
         % to create a stack frame.  This will be used for temporaries
         % (and local vars in the case of proc, func).
      
 281:    int patchLS
 281:    .tEnter  patchLS = Here  .tSpace
      
 290:    @Statement
 292:    .tReturn
      
 294:    int localSpace = oNodeGetInt( oScopeCurrent, qSize )
 306:    oPatch( patchLS, localSpace )
 316:    ;
      
      
      % modifers that may appear on a proc/function declaration.
      %
 316: MethodModifiers( Node decl ):
 318:    {[
 318:       | pCdecl :
 320:          oNodeSetBoolean( decl, qCdecl, true )
 332:          ';'
      
 334:       | * : >
 341:    ]}
 344:    ;
      
      
      % external method resides in an external object file
      % (or in my system, the built-in runtime library).
      % The method has a label, as usual, which callers will use.
      % But we define that label with .tLabelExtern rather than .tLabel.
      %
      % Note, I'll hold off on issuing the .tLabelExtern until we see that
      % the external method is actually called.  Otherwise we'd fill each output file
      % with all the external method names in my included libraries, which seems dumb.
      %
      % Note this is fpc syntax.  I'm not sure about other Pascals.
      %
 344: ExternalDecl( Node decl ):
 346:    oNodeSetBoolean( decl, qExternal, true )
 358:    [
 358:       | pStrLit :
               % that was the optional library name containing the method.
               % TO DO: I'm currently ignoring this.
 360:          [
 360:             | pName :
 362:                pStrLit
                     % that was the optional method name defined in that library,
                     % which might differ from the Pascal name.
                     % TO DO: I'm currently ignoring this.
                     %        Unfortunately my schema system doesn't support string fields yet!
 364:             | * :
 369:          ]
 369:       | * :
 374:    ]
 375:    ;
      
      
 375: ProcDecl:
 377:    pIdent
      
         % If we already have a forward declaration, we'll modify that decl
         % instead of creating a second symbol table entry.
         % (Alternatively could delete or hide the old entry.)
 379:    boolean redeclaring = false
 385:    Node decl = oScopeFindInCurrentScope
      
 390:    [ oNodeNull( decl )
 397:       | true :
               % first declaration
 398:          decl = @newIdent( nProc, kProc, LAST_ID )
 414:          oNodeSetLabel( decl, qValue, oLabelNew )
      
 425:       | false :
               % we already have a declaration.
               % Keep it, and its label.
 427:          redeclaring = true
 433:          [ oNodeGetBoolean( decl, qBodyDefined )
 443:             | true : #eAlreadyDefined
 446:             | * :
 451:          ]
 451:          [ oNodeGetBoolean( decl, qExternal )
 461:             | true : #eAlreadyDefined
 464:             | * :
 469:          ]
 469:          [ oNodeType( decl )
 476:             | nProc :
 477:             | * : #eAlreadyDefined   % wrong kind
 484:          ]
               % Move the existing param scope aside, so we can check that the
               % new one is consistent.  And, the body will want to see the new one
               % since the names might differ.
               % TO DO: If qOldParams already set, we have multiple forward decls,
               % which I believe is supposed to be an error.
 484:          oNodeSet( decl, qOldParams, oNodeGet( decl, qParams ) )
 503:          oNodeSet( decl, qParams, Null )
 515:    ]
      
 523:    oScopeBegin
 524:    Node paramScope = oScopeCurrent
      
 529:    @FormalArgDecl
 531:    oNodeSet( decl, qParams, paramScope )
 543:    oScopeEnd
 544:    ';'
      
 546:    [ redeclaring
 549:       | false : oScopeDeclare( decl )
 556:       | true :  % TO DO: check that qParams is consistent with qOldParams
 558:    ]
      
 566:    @MethodModifiers( decl )
      
         % Body may be a statement, "forward", "external".
         % Note, this syntax is based on FPC, and I'm not sure if other Pascals are similar.
         % FPC says that forward, external, cdecl, name, etc are not reserved words -
         % I think this means the user may declare other things with those names, but if so the
         % original meaning is lost.  I'll make them keywords for simplicity, for now
         % (just not too happy about "name").
      
 573:    [
 573:       | pForward :
               % Nothing to do.  We simply won't set qBodyDefined.
      
 575:       | pExternal : @ExternalDecl( decl )
      
 584:       | * :
               % Body statement
      
               % Enter the params scope again, so params are visible in body.
               % TO DO: Perhaps I could mark the scope read-only at this point.
 591:          oScopeEnter( paramScope )
      
               % Start scope for declarations within the proc
 597:          oScopeBegin
 598:          oNodeSetBoolean( oScopeCurrent, qAllocDown, true )
 609:          oNodeSet( decl, qChildScope, oScopeCurrent )
      
 620:          Label label = oNodeGetLabel( decl, qValue )
 633:          @Block( nLocalVar, label )
 643:          oNodeSetBoolean( decl, qBodyDefined, true )
 655:          oScopeEnd
      
 656:          oScopeEnd  % paramScope
 657:    ]
 657:    ';';
      
      
 660: FuncDecl:
 662:    pIdent
      
         % If we already have a forward declaration, we'll modify that decl
         % instead of creating a second symbol table entry.
         % (Alternatively could delete or hide the old entry.)
 664:    boolean redeclaring = false
 670:    Node decl = oScopeFindInCurrentScope
      
 675:    [ oNodeNull( decl )
 682:       | true :
               % first declaration
 683:          decl = @newIdent( nFunc, kFunc, LAST_ID )
 699:          oNodeSetLabel( decl, qValue, oLabelNew )
      
 710:       | false :
               % we already have a declaration.
               % Keep it, and its label.
 712:          redeclaring = true
 718:          [ oNodeGetBoolean( decl, qBodyDefined )
 728:             | true : #eAlreadyDefined
 731:             | * :
 736:          ]
 736:          [ oNodeType( decl )
 743:             | nFunc :
 744:             | * : #eAlreadyDefined   % wrong kind
 751:          ]
               % Move the existing param scope and return value aside,
               % so we can check that the new one is consistent.
               % And, the body will want to see the new one since the names might differ.
               % TO DO: If qOldParams already set, we have multiple forward decls,
               % which I believe is supposed to be an error.
 751:          oNodeSet( decl, qOldParams, oNodeGet( decl, qParams ) )
 770:          oNodeSet( decl, qParams, Null )
 782:          oNodeSet( decl, qOldType, oNodeGet( decl, qType ) )
 801:          oNodeSet( decl, qType, Null )
 813:    ]
      
 821:    oScopeBegin
 822:    Node paramScope = oScopeCurrent
      
 827:    @FormalArgDecl
 829:    oNodeSet( decl, qParams, paramScope )
      
 841:    ':'
      
 843:    Node theType
 843:    @TypeRef( theType )
 850:    oNodeSet( decl, qType, theType )
      
         % The function's param space gets an additional pointer,
         % which will point to a temporary in the caller's scope.
         % This pointer is essentially a VAR param, but I won't create an nParam for it.
      
 862:    Node ptrType = @PointerTypeTo( theType )
 873:    oNodeSetInt( decl, qResultOffset, oScopeAllocType( ptrType ) )
 889:    oScopeEnd
 890:    ';'
      
 892:    [ redeclaring
 895:       | false : oScopeDeclare( decl )
 902:       | true :  % TO DO: check that qParams is consistent with qOldParams
                      % and qType is consistent with qOldType
 904:    ]
      
 912:    @MethodModifiers( decl )
      
         % Body may be a statement, "forward", "external".
 919:    [
 919:       | pForward :
               % Nothing to do.  We simply won't set qBodyDefined.
      
 921:       | pExternal : @ExternalDecl( decl )
      
 930:       | * :
               % Body statement
      
               % Enter the params scope again, so params are visible in body.
               % TO DO: Perhaps I could mark the scope read-only at this point.
 937:          oScopeEnter( paramScope )
      
 943:          oScopeBegin
 944:          oNodeSetBoolean( oScopeCurrent, qAllocDown, true )
 955:          oNodeSet( decl, qChildScope, oScopeCurrent )
      
 966:          Label label = oNodeGetLabel( decl, qValue )
 979:          @Block( nLocalVar, label )
 989:          oNodeSetBoolean( decl, qBodyDefined, true )
1001:          oScopeEnd
      
1002:          oScopeEnd  % paramScope
1003:    ]
1003:    ';';
      
      
1006: FormalArgDecl:
1008:    [
1008:       | '(' :
1010:          {
1010:             NodeVec decls = oNodeVecNew
1015:             Node decl
1015:             boolean isInOut = false
      
1021:             [
1021:                | pVar : isInOut = true
1029:                | * :
1034:             ]
      
1034:             {  pIdent
      
1036:                decl = @newIdent( nParam, kVar, LAST_ID )
1052:                oNodeSetBoolean( decl, qInOut, isInOut )
1064:                oNodeVecAppend( decls, decl )
      
1073:                [
1073:                   | ':' : >
1077:                   | ',' :
1079:                ]
1087:             }
      
1089:             Node theType
1089:             @TypeRef( theType )
      
                  % VAR param is declared with its given type, but allocated as a pointer.
1096:             Node allocType
1096:             [ isInOut
1099:                | true :   allocType = @PointerTypeTo( theType )
1111:                | * :      allocType = theType
1122:             ]
      
1122:             int i = 0
1128:             {[ equal( i, oNodeVecSize( decls ) )
1142:                | false :
1143:                   decl = oNodeVecElement( decls, i )
      
1156:                   oNodeSet( decl, qType, theType )
1168:                   oScopeDeclare( decl )
1174:                   oNodeSetInt( decl, qValue, oScopeAllocType( allocType ) )
1190:                   inc( i )
1196:                | * :
1201:                   >
1203:             ]}
      
1205:             oNodeVecDelete( decls )
      
1211:             [
1211:                | ')' : >
1215:                | ';' :
1217:             ]
1225:          }
1227:       | * :
1232:    ];
      
1233: ConstDecl:
1235:    {[
1235:       | pIdent :
1237:          Node decl = @newIdent( nConst, kConst, LAST_ID )
1253:          '='
      
1255:          @ConstExpr
               % TO DO: currently ConstExpr leaves int result on oValue stack
1257:          int val = oValueTop
1262:          oValuePop
1263:          oNodeSetInt( decl, qValue, val )
      
               % TO DO: different types.  Currently assumes int!
1275:          oNodeSet( decl, qType, IntegerType )
      
1287:          oScopeDeclare( decl )
1293:          ';'
1295:       | * :
1300:          >
1302:    ]};
      
1305: TypeDecl:
1307:    {[
1307:       | pIdent :
1309:          Node decl = @newIdent( nTypeDecl, kType, LAST_ID )
1325:          '='
1327:          Node theType
1327:          @TypeRef( theType )
1334:          oNodeSet( decl, qType, theType )
1346:          oScopeDeclare( decl )
1352:          ';'
1354:       | * :
1359:          >
1361:    ]};
      
1364: VarDecl( node_type varNodeType ):
1366:    {[
1366:       | pIdent :
1368:          NodeVec decls = oNodeVecNew
1373:          Node decl
1373:          {
1373:             decl = @newIdent( varNodeType, kVar, LAST_ID )
1389:             oNodeVecAppend( decls, decl )
1398:             [
1398:                | ',' :
1400:                   pIdent
1402:                | * :
1407:                   >
1409:             ]
1409:          }
1411:          ':'
1413:          Node theType
1413:          @TypeRef( theType )
      
1420:          int i = 0
1426:          {[ equal( i, oNodeVecSize( decls ) )
1440:            | false :
1441:              decl = oNodeVecElement( decls, i )
1454:              oNodeSet( decl, qType, theType )
1466:              oScopeDeclareAlloc( decl )
1472:              inc( i )
1478:             | * :
1483:               >
1485:          ]}
      
1487:          oNodeVecDelete( decls )
1493:          ';'
1495:       | * :
1500:          >
1502:    ]};
      
      
      % Parse a type reference, returning the nType.
      % This will add types to the type table, as needed.
      %
      % Style question - at the moment I think callers look clearer if we use
      % an out param here, rather than a return value.
      %
1505: TypeRef( out Node resultType ):
1507:    [
1507:       | pIdent :           % previously named type (including intrinsics)
1509:          Node decl = oScopeFindRequire
1514:          [ oNodeType( decl )
1521:            | nTypeDecl :
1522:                resultType = oNodeGet( decl, qType )
1535:            | * :
1540:                #eNotType
1542:                resultType = IntegerType
1548:          ]
         
1548:       | pArray :
1550:          '['
      
               % A multi-dimensional array is represented as a chain
               %    array [subrange1] of array [subrange2] of elementType
      
               % First, we build a vector of nArray's, each with one subrange as its index type,
               % but without setting the "of" type or size.
      
1552:          NodeVec dimensions = oNodeVecNew
      
1557:          {
                  % to do: probably should use general subrange parsing, incl minimal size value
                  %   In fact, supposed to parse ordinal_type here.  all ordinal types have a static low, high.
                  %   Not necessary to be a subrange.
      
1557:             Node subrange = oNodeNew( nSubrangeType )
                  % TO DO: currently assuming subrange of integer
1567:             oNodeSet( subrange, qBaseType, IntegerType )
      
                  % TO DO: currently ConstExpr leaves int result on oValue stack
1579:             @ConstExpr
1581:             oNodeSetInt( subrange, qLow, oValueTop )
1592:             oValuePop
1593:             '..'
1595:             @ConstExpr
1597:             oNodeSetInt( subrange, qHigh, oValueTop )
1608:             oValuePop
1609:             oNodeSetInt( subrange, qSize, 4 )   % maybe don't need
      
1621:             oTypeAdd( subrange )
      
1627:             Node a = oNodeNew( nArrayType )
1637:             oNodeSet( a, qIndexType, subrange )
      
1649:             oNodeVecAppend( dimensions, a )
                  % I'll hold off on adding 'a' to the type table since not fully formed yet
      
1658:             [
1658:                | ']' : >
1662:                | ',' :
1664:             ]
1672:          }
      
1674:          pOf
1676:          Node baseType
1676:          @TypeRef( baseType )
      
               % Work backwards through the dimensions,
               % hooking up the 'of' type and calculating the size.
               % At each iteration, baseType is the 'of' type.
      
1683:          int dim = oNodeVecSize( dimensions )
      
1693:          {
1693:              dec(dim)
      
1699:              Node a = oNodeVecElement( dimensions, dim )
      
1712:              oNodeSet( a, qBaseType, baseType )
1724:              Node subrange = oNodeGet( a, qIndexType )
1737:              int width = subtract( oNodeGetInt( subrange, qHigh ), oNodeGetInt( subrange, qLow ) )
1764:              inc( width )
1770:              oNodeSetInt( a, qSize, multiply( width, oNodeGetInt( baseType, qSize ) ) )
      
1796:              oTypeAdd( a )
1802:              baseType = a
      
1808:              [ equal_zero(dim)
1815:                  | true:  >
1818:                  | *:
1823:              ]
1823:          }
      
1825:          resultType = oNodeVecElement( dimensions, 0 )
1838:          oNodeVecDelete( dimensions )
      
1844:       | '^' :
1846:          Node theType
1846:          @TypeRef( theType )
1853:          resultType = @PointerTypeTo( theType )
      
1864:       | pRecord :
1866:          resultType = oNodeNew( nRecordType )
1876:          oScopeBegin
      
1877:          @VarDecl( nRecordField )
      
1884:          int size = oNodeGetInt( oScopeCurrent, qSize )
               % to do: padding
1896:          [ equal_zero( size )
1903:             | true : #eRecordEmpty
1906:             | * :
1911:          ]
      
1911:          pEnd
      
1913:          oNodeSet( resultType, qScope, oScopeCurrent )
1924:          oNodeSetInt( resultType, qSize, size )
1936:          oScopeEnd
1937:          oTypeAdd( resultType )
      
      
            % *** TO DO: following type constructors are not implemented *** 
            % *** TO DO: also missing declaration of enum type
1943:       | pSet :
1945:          pOf
1947:          Node theType
1947:          @TypeRef( theType )
1954:       | * :       % this works for cases except where expr starts with an id
1967:          @ConstExpr '..' @ConstExpr
1973:    ];
      
      
      % --------------------------- Const Expressions --------------------------
      
      % Constant expressions: currently, only literal integers or previously
      % named constant integers are supported, possibly with a negation.
      % Constant expressions are evaluated at compile time.
      
1974: ConstExpr:
1976:    [
1976:       | pIntLit :
1978:          oValuePush( TOKEN_VALUE )
1983:       | pIdent :
1985:          Node decl = oScopeFindRequire
1990:          [ oNodeType( decl )
1997:             | nConst :
1998:                oValuePush( oNodeGetInt( decl, qValue ) )
2011:             | * :
2016:                #eNotConst
2018:                oValuePush( 0 )
2024:          ]
2024:       | pMinus :
2026:          @ConstExpr
2028:          oValueNegate
2029:    ];
      
      
      
      % ------------------------------ Expressions -----------------------------
      
      % There are two wrappers leading into expression parsing:
      %   Expr()
      %   BooleanExprControlFlow( out Label falseLabel )
      %
      % Expr always produces a value on the runtime expr stack,
      % and pushes its type on the type stack.
      %
      % BooleanExprControlFlow always generates control-flow code.
      % It does not push a value on the runtime expr stack.
      % It does not push a type on the type stack.
      % The control flow code ends up at Here if the expr is true,
      % and jumps to falseLabel if the expr is false.
      % This rule allocates falseLabel, and passes it back.
      % The caller will need to define its location.
      %
      % The internal methods of expr parsing may produce a mix of
      % values and control flow, depending on the operators seen.
      % We don't always do one or the other, hoping to be efficient for
      % cases like   "func_call( bool_var1, bool_var2 )"
      % as well as  "if bool_expr1 or bool_expr2 then ...".
      % If a subexpression rule produces control flow, it will allocate a
      % falseLabel and pass it back up.  And it will push the
      % result type as BooleanCFType, to distinguish from BooleanType
      % which corresponds with a boolean value on the expr stack.
      % 
      % Note that my expression parsing is broken into more levels than
      % grammars describe for Pascal precedence levels.  This follows my
      % original parser implementation.  I think my rationale was that
      % operators from the levels that I split up couldn't have been
      % mixed anyway, since they require different data types
      % (e.g. boolean vs int/real).  And splitting them up simplified
      % my code.  But, I should revisit this.
      %
      
      
      % Public entry point:
      %
      % Parse an expression, leaving a value on the runtime expr stack
      % and its type on the type stack.
      %
      % This rule does not export control flow (though it may generate
      % control flow internally for subexpressions).
      %
2040: Expr:
2042:    Label falseLabel = labelNull
      
2048:    @ExprAllowCF( falseLabel )
2055:    @CFToVal( falseLabel );
      
      
      % Public entry point:
      %
      % Parse a Boolean expression, producing control flow code rather than a value.
      % Does not leave a value on the runtime expr stack.
      % Does not leave a type on the type stack.
      %
      % If the expression is true, the code will fall through to the end (Here).
      % If the expression is false, the code will jump to the given falseLabel,
      % which this rule will allocate but not define the location for.
      % The caller must do so.
      %
2063: BooleanExprControlFlow( out Label falseLabel ):
2065:    @ExprAllowCF( falseLabel )
2072:    [ oTypeSNodeType
2074:       | nBooleanCFType :
2075:       | nBooleanType :
               % convert value to control flow
2077:          falseLabel = oLabelNew
2082:          .tJumpFalse  oEmitLabel( falseLabel )
2090:       | * :
2097:          #eNotBoolean
2099:    ]
2099:    oTypeSPop;
      
      
      % If the current expr result is control flow, convert it to a value.
      % falseLabel is the label that had been used by the control flow.
      % On return it will be set to labelNull.
      %
2101: CFToVal( inout Label falseLabel ):
2103:    [ oTypeSNodeType
2105:       | nBooleanCFType :
2106:          Label doneLabel = oLabelNew
2111:          .tPushConstI  oEmitInt( 1 )
2119:          .tJump  oEmitLabel( doneLabel )
2127:          .tLabel  oEmitLabel( falseLabel )
2135:          .tPushConstI  oEmitInt( 0 )
2143:          .tLabel  oEmitLabel( doneLabel )
2151:          oTypeSPop
2152:          oTypeSPush( BooleanType )
2158:          falseLabel = labelNull
2164:       | * :
2169:    ];
      
      
      % If the current expr result is boolean value, convert it to control flow.
      % falseLabel will be allocated by this rule and passed back.
      % The caller must define its location.
      %
2170: ValToCF( out Label falseLabel ):
2172:    [ oTypeSNodeType
2174:       | nBooleanType :
2175:          falseLabel = oLabelNew
2180:          .tJumpFalse  oEmitLabel( falseLabel )
2188:          oTypeSPop
2189:          oTypeSPush( BooleanCFType )
2195:       | * :
2200:    ];
      
      
      % Parse an expression.  It may produce a value on the expr stack,
      % or control flow, depending on what's seen in the expression.
      % Leaves the expression type on the type stack.
      %
      % If the expression produces control flow, the expression type will be
      % nBooleanCFType.  In this case, a true value falls through to Here,
      % and a false value jumps to falseLabel.  This rule will allocate falseLabel
      % and return it, but will not define its location; the caller must do so.
      %
      % If the expression produces a value, the value will be left on the
      % expression stack, and the type will be some type other than nBooleanCFType.
      % In this case, falseLabel is ignored.
      %
2201: ExprAllowCF( out Label falseLabel ):
2203:    @BoolExprAllowCF( falseLabel )
2210:    {[
2210:       | '=' :
2212:          @CFToVal( falseLabel )
2219:          @BoolExprAllowCF( falseLabel )
2226:          @CFToVal( falseLabel )
2233:          @MatchTypes
2235:          [ oTypeSNodeType
2237:             | nIntegerType, nBooleanType :  .tEqualI
2240:             | nPointerType :                .tEqualP
2244:             | nCharType, nStringType :      #eNotImplemented
2248:             | * :                           #eNotAllowed
2263:          ]
2263:          oTypeSPop
2264:          oTypeSPush( BooleanType )
      
2270:       | '<>' :
2272:          @CFToVal( falseLabel )
2279:          @BoolExprAllowCF( falseLabel )
2286:          @CFToVal( falseLabel )
2293:          @MatchTypes
2295:          [ oTypeSNodeType
2297:             | nIntegerType, nBooleanType :  .tNotEqualI
2300:             | nPointerType :                .tNotEqualP
2304:             | nCharType, nStringType :      #eNotImplemented
2308:             | * :                           #eNotAllowed
2323:          ]
2323:          oTypeSPop
2324:          oTypeSPush( BooleanType )
      
2330:       | '<' :
2332:          @CFToVal( falseLabel )
2339:          @BoolExprAllowCF( falseLabel )
2346:          @CFToVal( falseLabel )
2353:          @MatchTypes
2355:          [ oTypeSNodeType
2357:             | nIntegerType, nBooleanType :  .tLessI
2360:             | nCharType, nStringType :      #eNotImplemented
2364:             | * :                           #eNotAllowed
2377:          ]
2377:          oTypeSPop
2378:          oTypeSPush( BooleanType )
      
2384:       | '>' :
2386:          @CFToVal( falseLabel )
2393:          @BoolExprAllowCF( falseLabel )
2400:          @CFToVal( falseLabel )
2407:          @MatchTypes
2409:          [ oTypeSNodeType
2411:             | nIntegerType, nBooleanType :  .tGreaterI
2414:             | nCharType, nStringType :      #eNotImplemented
2418:             | * :                           #eNotAllowed
2431:          ]
2431:          oTypeSPop
2432:          oTypeSPush( BooleanType )
      
2438:       | '<=' :
2440:          @CFToVal( falseLabel )
2447:          @BoolExprAllowCF( falseLabel )
2454:          @CFToVal( falseLabel )
2461:          @MatchTypes
2463:          [ oTypeSNodeType
2465:             | nIntegerType, nBooleanType :  .tLessEqualI
2468:             | nCharType, nStringType :      #eNotImplemented
2472:             | * :                           #eNotAllowed
2485:          ]
2485:          oTypeSPop
2486:          oTypeSPush( BooleanType )
      
2492:       | '>=' :
2494:          @CFToVal( falseLabel )
2501:          @BoolExprAllowCF( falseLabel )
2508:          @CFToVal( falseLabel )
2515:          @MatchTypes
2517:          [ oTypeSNodeType
2519:             | nIntegerType, nBooleanType :  .tGreaterEqualI
2522:             | nCharType, nStringType :      #eNotImplemented
2526:             | * :                           #eNotAllowed
2539:          ]
2539:          oTypeSPop
2540:          oTypeSPush( BooleanType )
      
2546:       | * :
2561:          >
2563:    ]};
      
      
2566: BoolExprAllowCF( out Label falseLabel ):
2568:    Label trueLabel = labelNull
      
2574:    @BoolTermAllowCF( falseLabel )
2581:    {[
2581:       | pOr :
2583:          [ oTypeSNodeType
2585:             | nBooleanCFType :
                     % We are true here. Jump ahead to done
2586:                [ equal_label( trueLabel, labelNull )
2596:                   | true :  trueLabel = oLabelNew
2602:                   | * :
2607:                ]
2607:                .tJump  oEmitLabel( trueLabel )
2615:             | nBooleanType :
2617:                @ValToCF( falseLabel )
                     % We might be true here. If so, jump ahead to done
2624:                [ equal_label( trueLabel, labelNull )
2634:                   | true :  trueLabel = oLabelNew
2640:                   | * :
2645:                ]
2645:                .tJumpTrue  oEmitLabel( trueLabel )
2653:             | * : #eNotBoolean
2662:          ]
2662:          oTypeSPop
      
               % false in previous term will jump here, to try this alternative term
2663:          .tLabel  oEmitLabel( falseLabel )
      
               % we'll get a new falseLabel for this term
2671:          falseLabel = labelNull
2677:          @BoolTermAllowCF( falseLabel )
      
2684:          [ oTypeSNodeType
2686:             | nBooleanCFType :
2687:             | nBooleanType :
2689:                @ValToCF( falseLabel )
2696:             | * : #eNotBoolean
2705:          ]
      
2705:          oTypeSPop
2706:          oTypeSPush( BooleanCFType )
      
2712:       | * :
2717:          >
2719:    ]}
      
         % any short-circuit trues jump here to the end
2721:    [ equal_label( trueLabel, labelNull )
2731:       | false :
2732:          .tLabel  oEmitLabel( trueLabel )
2740:       | * :
2745:    ]
2746:    ;
      
      
2746: BoolTermAllowCF( out Label falseLabel ):
2748:    Label overallFalseLabel = labelNull
      
2754:    @BoolFactorAllowCF( falseLabel )
2761:    {[
2761:       | pAnd :
2763:          [ oTypeSNodeType
2765:             | nBooleanCFType :
2766:             | nBooleanType :
2768:                @ValToCF( falseLabel )
2775:             | * :
2782:                #eNotBoolean
2784:          ]
2784:          oTypeSPop
      
               % We're going to have a different falseLabel for each term,
               % because we let each rule allocate its own (rather than accepting labels passed in).
               % And in this case we want them all to go to the same place,
               % to be determined by the caller.
               %
               % I'll allow for label aliases.  This will be more optimal than generating
               % multiple private false-handling code segments, that the true path would have to
               % jump around.  That would be hard to eliminate afterwards.
      
2785:          [ equal_label( overallFalseLabel, labelNull )
2795:             | true :
2796:                overallFalseLabel = oLabelNew
2801:                .tLabelAlias  oEmitLabel( falseLabel )  oEmitLabel( overallFalseLabel )
2815:                falseLabel = overallFalseLabel
2821:             | * :
2826:          ]
      
2826:          Label factorFalseLabel = labelNull
2832:          @BoolFactorAllowCF( factorFalseLabel )
      
2839:          [ oTypeSNodeType
2841:             | nBooleanCFType :
2842:             | nBooleanType :
2844:                @ValToCF( factorFalseLabel )
2851:             | * : #eNotBoolean
2860:          ]
2860:         .tLabelAlias  oEmitLabel( factorFalseLabel )  oEmitLabel( overallFalseLabel )
      
2874:       | * :
2879:          >
2881:    ]};
      
2884: BoolFactorAllowCF( out Label falseLabel ):
2886:    [
2886:       | pNot :
2888:          Label factorFalseLabel = labelNull
      
2894:          @BoolFactorAllowCF( factorFalseLabel )
2901:          [ oTypeSNodeType
2903:             | nBooleanCFType :
                     % We have control flow, and are sitting at the point that has value false.
2904:                falseLabel = oLabelNew
2909:                .tJump  oEmitLabel( falseLabel )
                     % The true path jumps here
2917:                .tLabel  oEmitLabel( factorFalseLabel )
      
2925:             | nBooleanType :
                     % I have a value.  I'll leave it as a value, rather than create control flow.
                     % See how this goes.
2927:                .tNot
      
2929:             | * : #eNotBoolean
2938:          ]
      
2938:       | * :
2943:          @ArithExprAllowCF( falseLabel )
2950:    ];
      
2951: ArithExprAllowCF( out Label falseLabel ):
2953:    @TermAllowCF( falseLabel )
2960:    {[
2960:       | pPlus :
2962:          @RequireIntPop
2964:          @TermAllowCF( falseLabel )  % actually not allowing CF, will be caught by type check
2971:          @RequireInt
2973:          .tAddI
2975:       | pMinus :
2977:          @RequireIntPop
2979:          @TermAllowCF( falseLabel )
2986:          @RequireInt
2988:          .tSubI
2990:       | * :
2997:          >
2999:    ]};
      
3002: TermAllowCF( out Label falseLabel ):
3004:    @FactorAllowCF( falseLabel )
3011:    {[
3011:       | pTimes :
3013:          @RequireIntPop
3015:          @FactorAllowCF( falseLabel )  % actually not allowing CF, will be caught by type check
3022:          @RequireInt
3024:          .tMultI
3026:       | pDivide :
3028:          @RequireIntPop
3030:          @FactorAllowCF( falseLabel )
3037:          @RequireInt
3039:          .tDivI
3041:       | * :
3048:          >
3050:    ]};
      
3053: FactorAllowCF( out Label falseLabel ):
3055:    [
3055:       | pPlus :
3057:          @PrimaryAllowCF( falseLabel )  % actually not allowing CF, will be caught by type check
3064:          @RequireInt
3066:       | pMinus :
3068:          @PrimaryAllowCF( falseLabel )
3075:          @RequireInt
3077:          .tNegI
3079:       | * :
3086:          @PrimaryAllowCF( falseLabel )
3093:    ];
      
3094: PrimaryAllowCF( out Label falseLabel ):
3096:    [
3096:       | pIntLit :
3098:          .tPushConstI  oEmitInt( TOKEN_VALUE )
3105:          oTypeSPush( IntegerType )
      
3111:       | '(' :
3113:          @ExprAllowCF( falseLabel )
3120:          ')'
      
3122:       | pStrLit :
3124:          int addr = oStringAllocLit     % store in global data
3129:          .tPushAddrGlobal oEmitInt( addr )
               % TO DO: do we need to create a type with the literal's length?
3137:          oTypeSPush( StringType )
      
3143:       | pIdent :
3145:          Node decl = oScopeFindRequire
3150:          Node theType
      
3150:          [ oNodeType( decl )
3157:             | nFunc :
      
3158:                @Call( decl )
      
3165:             | nConst :
3167:                theType = oNodeGet( decl, qType )
3180:                oTypeSPush( theType )
3186:                [ oTypeSNodeType
3188:                   | nIntegerType, nBooleanType :
3189:                      .tPushConstI @EmitValue( decl )
3198:                   | * :
3205:                      #eNotImplemented
3207:                ]
      
3207:             | nGlobalVar, nLocalVar, nParam :
3209:                @VarExpr( decl )
      
3216:             | * :
3229:                #eNotValue
3231:                oTypeSPush( IntegerType )
3237:          ]
      
3237:       | '@' :        % @var -- pointer to var
3239:          pIdent
      
3241:          Node decl = oScopeFindRequire
3246:          Node theType
      
3246:          @LValueVar( decl )
      
               % The above leaves the pointed-to type on type stack.
               % Replace with ptr-to-<type>.
3253:          theType = oTypeSTop
3258:          oTypeSPop
3259:          Node ptrType = @PointerTypeTo( theType )
3270:          oTypeSPush( ptrType )
      
3276:       | * :
3289:          #eNotValue
3291:          oTypeSPush( IntegerType )
3297:    ];
      
      
      % Parse a variable expression, given the declaration of the
      % just-accepted identifier.
      % Leaves the value on the expression stack, and type on the type stack.
      %
3298: VarExpr( Node decl ):
3300:    Node theType = oNodeGet( decl, qType )
3313:    oTypeSPush( theType )
3319:    [ oTypeSNodeType
3321:       | nIntegerType :
3322:          [ oNodeType( decl )
3329:             | nGlobalVar :   .tPushGlobalI @EmitValue( decl )
3339:             | nLocalVar :    .tPushLocalI @EmitValue( decl )
3350:             | nParam :
3352:                [ oNodeGetBoolean( decl, qInOut )
3362:                   | true :    % VAR param points to the var.  Auto dereference.
3363:                               .tPushParamP @EmitValue( decl )
3372:                               .tFetchI
3374:                   | * :       .tPushParamI @EmitValue( decl )
3388:                ]
3388:          ]
      
3398:       | nBooleanType :
3400:          [ oNodeType( decl )
3407:             | nGlobalVar :   .tPushGlobalB @EmitValue( decl )
3417:             | nLocalVar :    .tPushLocalB @EmitValue( decl )
3428:             | nParam :
3430:                [ oNodeGetBoolean( decl, qInOut )
3440:                   | true :    % VAR param points to the var.  Auto derefernce.
3441:                               .tPushParamP @EmitValue( decl )
3450:                               .tFetchB
3452:                   | * :       .tPushParamB @EmitValue( decl )
3466:                ]
3466:          ]
      
3476:       | nCharType, nStringType, nFileType :
3478:          #eNotImplemented
      
3480:       | nPointerType :
3482:          [ oNodeType( decl )
3489:             | nGlobalVar :   .tPushGlobalP @EmitValue( decl )
3499:             | nLocalVar :    .tPushLocalP @EmitValue( decl )
3510:             | nParam :
3512:                [ oNodeGetBoolean( decl, qInOut )
3522:                   | true :    % VAR param points to the var.  Auto derefernce.
3523:                               .tPushParamP @EmitValue( decl )
3532:                               .tFetchP
3534:                   | * :       .tPushParamP @EmitValue( decl )
3548:                ]
3548:          ]
3558:          [
3558:             | '^' :             % dereferenced
3560:                oTypeSPop
3561:                oTypeSPush( oNodeGet( theType, qBaseType ) )
3574:                @LValueIndexes
3576:                @FetchVar
3578:             | * :               % just ptr value alone
3583:          ]
      
3583:       | * :
               % compound type
               % first, push addr of start of var
3598:          [ oNodeType( decl )
3605:             | nGlobalVar :   .tPushAddrGlobal @EmitValue( decl )
3615:             | nLocalVar :    .tPushAddrLocal @EmitValue( decl )
3626:             | nParam :
3628:                [ oNodeGetBoolean( decl, qInOut )
3638:                   | true :    % VAR param points to the var.  Auto derefernce.
3639:                               .tPushParamP @EmitValue( decl )
3648:                   | * :       .tPushAddrParam @EmitValue( decl )
3662:                ]
3662:          ]
               % modify addr for subscripts, field references, etc
3672:          @LValueIndexes
               % get final value
3674:          @FetchVar
3676:    ];
      
      
      % Addr of start of var is on expr stack; type is on type stack.
      % Replace expr stack with value of var.
      % (In the case of compound vars, this remains as the addr of the var).
      
3677: FetchVar:
3679:    [ oTypeSNodeType
3681:       | nIntegerType :   .tFetchI
3684:       | nBooleanType :   .tFetchB
3688:       | nCharType, nStringType, nFileType : #eNotImplemented
3692:       | nPointerType :   .tFetchP
3696:       | * :              % compound type; leave as addr
3711:    ];
      
      
      % Addr of start of var is already on run stack, and type is on type stack.
      % Read subscripts, record fields, etc, to get final addr on run stack, and final type
      % on type stack.
      
3712: LValueIndexes:
3714:    {[
3714:       | '[' :       @ArraySubscripts
3718:       | '.' :       @RecordFieldRef
3722:       | '^' :       @PointerDeref
3726:       | * :         >
3737:    ]};
      
3740: ArraySubscripts:
3742:    [ oTypeSNodeType
3744:       | nArrayType :
3745:       | * :       #eNotArray
3752:    ]
3752:    {
3752:       [ oTypeSNodeType
3754:          | nArrayType :
3755:          | * :    #eTooManySubscripts
3762:       ]
      
            % low subscript of this dimension
3762:       int low = @OrdinalLow( oNodeGet( oTypeSTop, qIndexType ) )
      
            % replace type stack with next dimension, or OF type
3779:       Node baseType
3779:       baseType = oNodeGet( oTypeSTop, qBaseType )
3791:       oTypeSPop
3792:       oTypeSPush( baseType )
      
3798:       @Expr
3800:       @RequireIntPop
            % adjust for low subscript
3802:       [ equal_zero( low )
3809:          | false :
3810:             .tPushConstI oEmitInt( low ) .tSubI
3820:          | * :
3825:       ]
      
            % multiply by element size
3825:       int size = oNodeGetInt( baseType, qSize )
3838:       [ equal( size, 1 )
3848:          | false :
3849:             .tPushConstI oEmitInt( size ) .tMultI
3859:          | * :
3864:       ]
      
            % update start address
3864:       .tAddPI
3866:       [
3866:          | ']' :  >
3870:          | ',' :
3872:       ]
3880:    };
      
      
3883: RecordFieldRef:
3885:    [ oTypeSNodeType
3887:       | nRecordType :
3888:       | * :    #eNotRecord
3895:    ]
3895:    oScopeEnter( oNodeGet( oTypeSTop, qScope ) )
3907:    pIdent
3909:    Node field = oScopeFindRequire
         % oScopeFind searches all open scopes, so make sure we found nRecordField
         % which could only be seen in the local scope we entered above.
3914:    [ oNodeType( field )
3921:       | nRecordField :
3922:       | * :   #eNotRecordField
3929:    ]
3929:    oScopeEnd
3930:    int offset = oNodeGetInt( field, qValue )
3943:    [ equal_zero( offset )
3950:       | false :
3951:          .tPushConstI oEmitInt( offset ) .tAddPI
3961:       | * :
3966:    ]
      
         % replace the type on the type stack, with the field type
3966:    oTypeSPop
3967:    oTypeSPush( oNodeGet( field, qType ) )
3981:    ;
      
      
      % ptr deref on left side, i.e. BEFORE addr of ptr var is on stack,
      %                              AFTER addr of thing pointed to is on stack
3981: PointerDeref:
3983:    [ oTypeSNodeType
3985:       | nPointerType :
3986:       | * :       #eNotPointer
3993:    ]
3993:    .tFetchP           % now addr on stack is addr of what we're pointing to
      
3995:    Node theType = oTypeSTop
4000:    oTypeSPop
4001:    oTypeSPush( oNodeGet( theType, qBaseType ) )
4015:    ;
      
      
      % The expr stack contains a value whose type is on top of the type stack.
      % Generate code to coerce the value to the type under it in the type stack
      % (pop the type stack, leaving only the desired type).
      % This is used for assignment.
      %
4015: CoerceType:
         % TO DO: not implemented yet.  For now I require exact type match.
4017:    @MatchTypes
4020:    ;
      
      
      % Parse a call, given an nProc or nFunc for the just-accepted identifier.
      % If a func, this will also generate the code to push the return value on the expr stack,
      % and push the return type on the type stack.
      %
4020: Call( Node method ):
      
         % Prior to first call, issue extern label for a called method.
         % I don't want to issue .tLabelExtern for unused methods, that seems inefficient.
4022:    [ oNodeGetBoolean( method, qExternal )
4032:       | true :
4033:          [ oNodeGetBoolean( method, qCalled )
4043:             | false :
                     % define the label as extern
4044:                int strAddr = oStringAllocLitFromIdent( oNodeGetInt( method, qIdent ) )
4061:                .tLabelExtern  @EmitValue( method )  oEmitInt( strAddr )
4076:             | * :
4081:          ]
4081:      | * :
4086:    ]
4086:    oNodeSetBoolean( method, qCalled, true )
      
         % If the method has a cdecl modifier, the back end will need to use the native
         % calling convention, instead of my own.  But, the convention varies by platform,
         % so the front end won't assume what it needs.  I'll still generate the normal tcode
         % that copies values into actuals space on the stack.
         % However, to help the back end, I will at least use a different instruction for the
         % allocation of the actuals space, and for the actual call.
         %
         % p.s. I only support cdecl on external methods, because I don't have a way
         % to let my own Pascal methods read params passed in with the cdecl calling convention.
         %
4098:    boolean cdecl = oNodeGetBoolean( method, qCdecl )
      
         % If this is a function, we will allocate a temporary
         % in the current scope, to hold the result value.
         % And pass a pointer to that temporary as an extra parameter.
4111:    Node resultType
4111:    int tempOffset
      
4111:    boolean isFunc = equal_node_type( oNodeType( method ), nFunc )
      
4128:    [ isFunc
4131:       | true :
4132:          resultType = oNodeGet( method, qType )
4145:          tempOffset = oScopeAllocType( resultType )
               % TO DO: we could manage temp allocation, so temp space can be reused
               %        by different code branches.
4155:       | * :
4160:    ]
         
      
4160:    Node paramScope = oNodeGet( method, qParams )
4173:    int actualsSize = oNodeGetInt( paramScope, qSize )
4186:    [ cdecl
4189:       | true : .tAllocActualsCdecl  oEmitInt( actualsSize )
4198:       | false :  .tAllocActuals  oEmitInt( actualsSize )
4208:    ]
      
4216:    Node param = oNodeGet( paramScope, qDecls )
4229:    [
4229:       | '(' :
            
4231:          {
4231:             [ oNodeNull( param )
4238:                | true : >
4241:                | * :
4246:             ]
      
4246:             int offset = oNodeGetInt( param, qValue )
      
                  % Assign actual value to spot in actuals space
4259:             .tPushAddrActual oEmitInt( offset )
4267:             oTypeSPush( oNodeGet( param, qType ) )
      
4280:             [ oNodeGetBoolean( param, qInOut )
4290:                | true :   % A VAR param.
                                % The actual is a pointer to the value.
                                % The type on the type stack (pushed above) is for the pointed-to value.
      
4291:                           @LValueExpr
                                % Addr of the referenced variable is on the expr stack,
                                % type of the variable is on the type stack.
      
                                % Match types more exactly. It's not sufficient to be assign compatible
                                % since the method will be assigning to the actual using the param type.
                                % Maybe something like type contents must match, incl subrange bounds.
4293:                           @MatchTypes
      
4295:                           .tAssignP
      
4297:                | false :  @Expr
4301:                           @CoerceType
                                
                                % Assign to offset in actuals space
      
4303:                           [ oTypeSNodeType
4305:                              | nIntegerType :            .tAssignI
4308:                              | nBooleanType :            .tAssignB
4312:                              | nCharType, nStringType, nFileType :   #eNotImplemented
4316:                              | nPointerType :            .tAssignP
4320:                              | * :
                                       % compound types: copy value into actuals space
4335:                                  int size = oNodeGetInt( oTypeSTop, qSize )
4347:                                  .tCopy  oEmitInt( size )    % multi-word copy
4355:                           ]
4355:             ]
4363:             oTypeSPop
      
4364:             oNodeNext( param )
4370:             [ oNodeNull( param )
4377:                | true :  >
4380:                | false :
4382:             ]
      
4390:             ','
4392:          }
      
4394:          ')'
      
4396:       | * :
4401:    ]
      
4401:    [ oNodeNull( param )
4408:       | false :    #eMissingParameter
4411:       | * :
4416:    ]
      
4416:    [ isFunc
4419:       | true :
               % Pass result temp as an additional VAR parameter.
4420:          .tPushAddrActual oEmitInt( oNodeGetInt( method, qResultOffset ) )
4435:          .tPushAddrLocal  oEmitInt( tempOffset )
4443:          .tAssignP
4445:       | * :
4450:    ]
      
4450:    [ cdecl
4453:       | true :
4454:          .tCallCdecl  @EmitValue( method )
4463:       | false :
4465:          .tCall   @EmitValue( method )
4474:    ]
      
4482:    [ isFunc
4485:       | true :
               % push return value from temp
4486:          oTypeSPush( resultType )
      
4492:          [ oTypeSNodeType
4494:             | nIntegerType :   .tPushLocalI  oEmitInt( tempOffset )
4503:             | nBooleanType :   .tPushLocalB  oEmitInt( tempOffset )
4513:             | nCharType, nStringType, nFileType : #eNotImplemented
4517:             | nPointerType :   .tPushLocalP  oEmitInt( tempOffset )
4527:             | * :              % compound type: push address
4542:                                .tPushAddrLocal  oEmitInt( tempOffset )
4550:          ]
4550:       | * :
4555:    ]
         
4555:    .tFreeActuals  oEmitInt( actualsSize )
4564:    ;
      
      
      % ------------------------------ Statements -----------------------------
      
4564: Statement:
4566:    [
4566:       | pWriteln :     @WritelnStmt
4570:       | pWrite :       @WriteStmt
4574:       | pReadln :      @ReadlnStmt
4578:       | pRead :        @ReadStmt
4582:       | pIf :          @IfStmt
4586:       | pWhile :       @WhileStmt
4590:       | pFor :         @ForStmt
4594:       | pRepeat :      @RepeatStmt
4598:       | pBreak :       @BreakStmt
4602:       | pContinue :    @ContinueStmt
4606:       | pBegin :       @BeginStmt
4610:       | pIdent :       @AssignOrCallStmt
4614:       | * :            % null statement : don't accept any tokens
4641:    ];
      
      
4642: AssignOrCallStmt:
4644:    Node decl = oScopeFindRequire
4649:    [ oNodeType( decl )
4656:       | nProc :                           @Call( decl )
4664:       | nGlobalVar, nLocalVar, nParam :   @AssignStmt( decl )
4673:       | nFunc :                           @AssignResultStmt( decl )
4682:       | * :                               #eBadStatement
4697:    ];
      
      
      % Given decl, the just-accepted first identifier on the left hand side.
      %
4698: AssignStmt( Node decl ):
      
4700:    @LValueVar( decl )
      
4707:    ':=' 
4709:    @Expr
4711:    @MatchTypes
4713:    [ oTypeSNodeType
4715:       | nIntegerType :            .tAssignI
4718:       | nBooleanType :            .tAssignB
4722:       | nCharType, nStringType, nFileType :   #eNotImplemented
      
            % compound var assigns; addrs of src, dest on stack
4726:       | nPointerType :            .tAssignP
4730:       | * :
4745:           int size = oNodeGetInt( oTypeSTop, qSize )
4757:           .tCopy  oEmitInt( size )    % multi-word copy
4765:    ]
4765:    oTypeSPop
4767:    ;
      
      
      % Given nFunc for the just-accepted identifier on the left hand side.
      % Parse an assignment that represents assignment of the function result.
      %
4767: AssignResultStmt( Node funcDecl ):
         % Only allowed to assign the result of the immediately enclosing function, I think.
4769:    [ oNodeEqual( oNodeGet( funcDecl, qChildScope ), oScopeCurrent )
4785:       | false :   #eNotCurrentFunction
4788:       | * :
4793:    ]
      
         % Result value is stored in the caller's space, via a hidden VAR parameter.
4793:    .tPushParamP  oEmitInt( oNodeGetInt( funcDecl, qResultOffset ) )
4808:    oTypeSPush( oNodeGet( funcDecl, qType ) )
      
4821:    ':='
4823:    @Expr
4825:    @MatchTypes
4827:    [ oTypeSNodeType
4829:       | nIntegerType :            .tAssignI
4832:       | nBooleanType :            .tAssignB
4836:       | nCharType, nStringType, nFileType :   #eNotImplemented
      
            % compound var assigns; addrs of src, dest on stack
4840:       | nPointerType :            .tAssignP
4844:       | * :
4859:           int size = oNodeGetInt( oTypeSTop, qSize )
4871:           .tCopy  oEmitInt( size )    % multi-word copy
4879:    ]
4879:    oTypeSPop
4881:    ;
      
      
      
      % Parse an lvalue expression, from scratch.
      % This is an expression that may appear on the left side of an assignment.
      % Leaves the address of the value on the expr stack,
      % and the type of the value at that address on the type stack.
      %
4881: LValueExpr:
         % At the moment, all lvalue expressions start with a variable name.
         % I think there can also be typecasts, not supported yet.  Check standard syntax.
4883:    pIdent
4885:    Node decl = oScopeFindRequire
4890:    [ oNodeType( decl )
4897:       | nGlobalVar, nLocalVar, nParam :
4898:       | * :  #eNotVar
4909:    ]
4909:    @LValueVar( decl )
4917:    ;
      
      
      % Parse an lvalue expression (e.g. left side of an assign statement)
      % that starts with the just-accepted identifier indicated by the given decl.
      % Leaves the lvalue address on the expression stack,
      % and the type of the value at that address on the type stack.
      %
4917: LValueVar( Node decl ):
4919:    [ oNodeType( decl )
4926:       | nGlobalVar :   .tPushAddrGlobal @EmitValue( decl )
4936:       | nLocalVar :    .tPushAddrLocal @EmitValue( decl )
4947:       | nParam :
4949:          [ oNodeGetBoolean( decl, qInOut )
4959:             | true :   % VAR param points to variable.  No dereference.
4960:                        .tPushParamP @EmitValue( decl )
4969:             | * :      .tPushAddrParam @EmitValue( decl )
4983:          ]
4983:       | * :            #eNotVar
4994:    ]
      
4994:    oTypeSPush( oNodeGet( decl, qType ) )
5007:    @LValueIndexes        % handle subscripts, if any
5010:    ;
      
      
5010: IncVar( Node decl ):
5012:    @LValueVar( decl )
5019:    @RequireIntPop
5021:    @VarExpr( decl )
5028:    oTypeSPop
5029:    .tIncI
5031:    .tAssignI;
      
5034: DecVar( Node decl ):
5036:    @LValueVar( decl )
5043:    @RequireIntPop
5045:    @VarExpr( decl )
5052:    oTypeSPop
5053:    .tDecI
5055:    .tAssignI;
      
      
5058: IfStmt:
5060:    Label falseLabel = labelNull
      
5066:    @BooleanExprControlFlow( falseLabel )
5073:    pThen
5075:    @Statement
5077:    [
5077:       | pElse :
5079:          Label doneLabel = oLabelNew
      
5084:          .tJump  oEmitLabel( doneLabel )
5092:          .tLabel oEmitLabel( falseLabel )
5100:          @Statement
5102:          .tLabel oEmitLabel( doneLabel )
      
5110:       | * :
5115:          .tLabel oEmitLabel( falseLabel )
5123:    ];
      
      
5124: ForStmt:
5126:    pIdent
      
5128:    Node decl = oScopeFindRequire
         % TO DO: disallow use of a compound variable field.
         %        Could do that by disallowing use of LValueIndexes,
         %        or by double-checking the decl's qType here.
5133:    @LValueVar( decl )
5140:    @RequireIntPop
      
5142:    ':='
      
5144:    @Expr
5146:    @RequireIntPop
5148:    .tAssignI
      
5150:    Label breakLabel = oLabelNew
      
5155:    Label checkLabel = oLabelNew
5160:    .tJump  oEmitLabel( checkLabel )
      
5168:    Label continueLabel = oLabelNew
5173:    .tLabel  oEmitLabel( continueLabel )
5181:    [
5181:       | pTo :
5183:          @IncVar( decl )
5190:          .tLabel  oEmitLabel( checkLabel )
5198:          @VarExpr( decl )  oTypeSPop
5206:          @Expr
5208:          @RequireIntPop
5210:          .tGreaterI
5212:          .tJumpTrue  oEmitLabel( breakLabel )
5220:       | pDownto :
5222:          @DecVar( decl )
5229:          .tLabel  oEmitLabel( checkLabel )
5237:          @VarExpr( decl )  oTypeSPop
5245:          @Expr
5247:          @RequireIntPop
5249:          .tLessI
5251:          .tJumpTrue  oEmitLabel( breakLabel )
5259:    ]
5267:    oLoopPush( continueLabel, breakLabel )
5276:    pDo
5278:    @Statement
5280:    .tJump  oEmitLabel( continueLabel )
5288:    .tLabel  oEmitLabel( breakLabel )
5296:    oLoopPop;
      
      
5298: RepeatStmt:
5300:    Label continueLabel = oLabelNew
5305:    .tLabel  oEmitLabel( continueLabel )
      
5313:    Label breakLabel = oLabelNew
      
5318:    oLoopPush( continueLabel, breakLabel )
5327:    @Statement
5329:    {[
5329:       | ';' :
5331:          @Statement
5333:       | pUntil :
5335:          Label falseLabel
5335:          @BooleanExprControlFlow( falseLabel )
5342:          .tLabelAlias  oEmitLabel( falseLabel )  oEmitLabel( continueLabel )
5356:          >
5358:    ]}
5368:    .tLabel  oEmitLabel( breakLabel )
5376:    oLoopPop;
      
      
5378: WhileStmt:
5380:    Label continueLabel = oLabelNew
5385:    .tLabel  oEmitLabel( continueLabel )
      
5393:    Label breakLabel
5393:    @BooleanExprControlFlow( breakLabel )
      
5400:    oLoopPush( continueLabel, breakLabel )
5409:    pDo
5411:    @Statement
5413:    .tJump  oEmitLabel( continueLabel )
5421:    .tLabel  oEmitLabel( breakLabel )
5429:    oLoopPop;
      
      
5431: ContinueStmt:                     % NOTE, for repeat..until, skips test (??)
5433:    [ equal_label( oLoopContinueLabel, labelNull )
5442:       | true :
5443:          #eNotInALoop
5445:       | false :
5447:          .tJump  oEmitLabel( oLoopContinueLabel )
5454:    ];
      
      
5463: BreakStmt:
5465:    [ equal_label( oLoopBreakLabel, labelNull )
5474:       | true :
5475:          #eNotInALoop
5477:       | false :
5479:          .tJump  oEmitLabel( oLoopBreakLabel )
5486:    ];
      
      
5495: BeginStmt:
5497:    @Statement
5499:    {[
5499:       | ';' :   @Statement
5503:       | pEnd :  >
5507:    ]};
      
      
5518: WritelnStmt:
5520:    @WriteStmt
5522:    .tWriteCR;
      
      
5525: WriteStmt:
5527:    [
5527:       | '(' :
5529:          {
5529:             @Expr
5531:             [ oTypeSNodeType
5533:                | nIntegerType :             .tWriteI
5536:                | nBooleanType :             .tWriteBool
5540:                | nStringType :              .tWriteStr
5544:                | nCharType, nFileType :     #eNotImplemented
5548:                | nPointerType :             .tWriteP
5552:                | * :                        #eNotAllowed
5569:             ]
5569:             oTypeSPop
5570:             [
5570:                | ')' : >
5574:                | ',' :
5576:             ]
5584:          }
5586:       | * :
5591:    ];
      
      
5592: ReadlnStmt:      % ***
         % TO DO
5595:    ;
      
5595: ReadStmt:
         % TO DO
5598:    ;
      
      % -------------------------------- Utilities -------------------------------
      
      
      % Require that the top two types on the type stack are matching (ignoring subranges).
      % Pop one of them, leaving only one.
      %
5598: MatchTypes:
5600:    node_type nt = oTypeSNodeType
5605:    oTypeSPop
5606:    [ equal_node_type( nt, oTypeSNodeType )
5615:       | false :
5616:          #eTypeMismatch
5618:       | * :
5623:    ];
      
      
      % Require that the top type on the type stack is integer (ignoring subranges).
      % Pop it.
      %
5624: RequireIntPop:
5626:    [ oTypeSNodeType
5628:       | nIntegerType :
5629:       | * :          #eNotInteger
5636:    ]
5636:    oTypeSPop;
      
5638: RequireInt:
5640:    [ oTypeSNodeType
5642:       | nIntegerType :
5643:       | * :          #eNotInteger
5650:    ];
      
5651: RequireBoolPop:
5653:    [ oTypeSNodeType
5655:       | nBooleanType :
5656:       | * :          #eNotBoolean
5663:    ]
5663:    oTypeSPop;
      
5665: RequireBool:
5667:    [ oTypeSNodeType
5669:       | nBooleanType :
5670:       | * :          #eNotBoolean
5677:    ];
      
      
      % Create and return a new nType of the given node_type, adding it to the type table.
      %
5678: newType( node_type nt, int size ) >> Node:
5680:   Node node = oNodeNew( nt )
5690:   oNodeSetInt( node, qSize, size )
5702:   oTypeAdd( node )
5708:   >> node
5712:   ;
      
      
      % Create and return a new nIdent of the given node_type, with the given ident id.
      % Does not add it to any scope.
      %
5712: newIdent( node_type nt, kind k, int id ) >> Node:
5714:   Node t = oNodeNew( nt )
5724:   oNodeSetInt( t, qIdent, id )
5736:   >> t
5740:   ;
      
      
      % Return an nType representing a pointer to the given type.
      % (Creates a new type if necessary.)
      %
5740: PointerTypeTo( Node theType ) >> Node:
5742:    Node ptrType = oNodeGet( theType, qPointerType )
5755:    [ oNodeNull( ptrType )
5762:       | true :
5763:          ptrType = oNodeNew( nPointerType )
5773:          oNodeSet( ptrType, qBaseType, theType )
5785:          oNodeSetInt( ptrType, qSize, 8 )
5797:          oTypeAdd( ptrType )
5803:          oNodeSet( theType, qPointerType, ptrType )
5815:       | * :
5820:    ]
5820:    >> ptrType;
      
      
      % Return the low value of an ordinal type
      %
5824: OrdinalLow( Node theType ) >> int:
5826:    [ oNodeType( theType )
5833:       | nIntegerType :  >> oMININT    % NOTE ssl literals are limited to 16 bit at the moment, though values are 32 bit ok. So need a mechanism.
5836:       | nBooleanType :  >> 0
5841:       | nCharType :     >> 0
5846:       | nSubrangeType : >> oNodeGetInt( theType, qLow )
5858:       | * :             #eNotOrdinalType
5871:                         >> 0
5874:    ];
      
      
      
      % Emit the value in a declaration.
      % For a constant integer, this is the constant value.
      % For a global variable, this is the global address.
      % For a local variable, this is the local address relative to the call stack frame.
      %
5875: EmitValue( Node decl ):
5877:     oEmitInt( oNodeGetInt( decl, qValue ));
      
      
5891: installBuiltIns:
      
         % install built-in types
5893:    FileType = @newType( nFileType, 4 )
5907:    IntegerType = @newType( nIntegerType, 4 )
5921:    BooleanType = @newType( nBooleanType, 1 )
5935:    BooleanCFType = @newType( nBooleanCFType, 1 )
5949:    CharType = @newType( nCharType, 1 )
5963:    StringType = @newType( nStringType, 256 )    % string with default length 256
      
         % Declare those type identifiers.
         % SSL doesn't support strings, so need help from operations e.g. oIdAdd_File
      
5977:    Node t
      
5977:    t = @newIdent( nTypeDecl, kType, oIdAdd_File )
5993:    oNodeSet( t, qType, FileType )
6005:    oScopeDeclare( t )
      
6011:    t = @newIdent( nTypeDecl, kType, oIdAdd_Integer )
6027:    oNodeSet( t, qType, IntegerType )
6039:    oScopeDeclare( t )
      
6045:    t = @newIdent( nTypeDecl, kType, oIdAdd_Boolean )
6061:    oNodeSet( t, qType, BooleanType )
6073:    oScopeDeclare( t )
      
6079:    t = @newIdent( nTypeDecl, kType, oIdAdd_Char )
6095:    oNodeSet( t, qType, CharType )
6107:    oScopeDeclare( t )
      
6113:    t = @newIdent( nTypeDecl, kType, oIdAdd_String )
6129:    oNodeSet( t, qType, StringType )
6141:    oScopeDeclare( t )
      
         % Built-in constants
      
6147:    t = @newIdent( nConst, kConst, oIdAdd_True )
6163:    oNodeSet( t, qType, BooleanType )
6175:    oNodeSetInt( t, qValue, 1 )
6187:    oScopeDeclare( t )
      
6193:    t = @newIdent( nConst, kConst, oIdAdd_False )
6209:    oNodeSet( t, qType, BooleanType )
6221:    oNodeSetInt( t, qValue, 0 )
6233:    oScopeDeclare( t )
      
6240:    ;
      
6240: end
      
6240: 

Generated code:

   0: oGlobalSpace 8
   2: oLocalSpace 3
   4: oScopeBegin
   5: oGetAddrGlobal 1
   7: oPushResult
   8: oScopeCurrent
   9: oAssign
  10: oCall 5891
  12: oEmit 44
  14: oSetResult 0
  16: oPushResult
  17: oEmitInt
  18: oPop 1
  20: oGetAddrLocal 2
  22: oPushResult
  23: oLabelNew
  24: oAssign
  25: oEmit 38
  27: oSetResult 0
  29: oPushResult
  30: oEmitInt
  31: oPop 1
  33: oEmit 41
  35: oGetLocal 2
  37: oPushResult
  38: oEmitLabel
  39: oPop 1
  41: oEmit 40
  43: oSetResult 0
  45: oPushResult
  46: oEmitInt
  47: oPop 1
  49: oEmit 43
  51: oInput 27
  53: oInput 0
  55: oGetAddrLocal 3
  57: oPushResult
  58: oSetResult 5
  60: oPushResult
  61: oSetResult 1
  63: oPushResult
  64: LAST_ID
  65: oPushResult
  66: oCall 5712
  68: oPop 3
  70: oAssign
  71: oGetLocal 3
  73: oPushResult
  74: oScopeDeclare
  75: oPop 1
  77: oInputChoice 157
  79: oInput 0
  81: oGetAddrLocal 1
  83: oPushResult
  84: oSetResult 11
  86: oPushResult
  87: oSetResult 6
  89: oPushResult
  90: LAST_ID
  91: oPushResult
  92: oCall 5712
  94: oPop 3
  96: oAssign
  97: oGetLocal 1
  99: oPushResult
 100: oSetResult 5
 102: oPushResult
 103: oGetGlobal 2
 105: oPushResult
 106: oNodeSet
 107: oPop 3
 109: oGetLocal 1
 111: oPushResult
 112: oScopeDeclareAlloc
 113: oPop 1
 115: oInput 12
 117: oInput 0
 119: oGetAddrLocal 1
 121: oPushResult
 122: oSetResult 11
 124: oPushResult
 125: oSetResult 6
 127: oPushResult
 128: LAST_ID
 129: oPushResult
 130: oCall 5712
 132: oPop 3
 134: oAssign
 135: oGetLocal 1
 137: oPushResult
 138: oSetResult 5
 140: oPushResult
 141: oGetGlobal 2
 143: oPushResult
 144: oNodeSet
 145: oPop 3
 147: oGetLocal 1
 149: oPushResult
 150: oScopeDeclareAlloc
 151: oPop 1
 153: oInput 14
 155: oJumpForward 160
 157: Choice Lookup Table
          13     79
 160: oInput 4
 162: oSetResult 12
 164: oPushResult
 165: oCall 221
 167: oPop 1
 169: oScopeBegin
 170: oScopeCurrent
 171: oPushResult
 172: oSetResult 3
 174: oPushResult
 175: oSetResult 1
 177: oPushResult
 178: oNodeSetBoolean
 179: oPop 3
 181: oGetLocal 3
 183: oPushResult
 184: oSetResult 7
 186: oPushResult
 187: oScopeCurrent
 188: oPushResult
 189: oNodeSet
 190: oPop 3
 192: oGetLocal 2
 194: oPushResult
 195: oCall 271
 197: oPop 1
 199: oScopeEnd
 200: oInput 19
 202: oScopeEnd
 203: oReturn
 204: oLocalSpace 0
 206: oGetParam 2
 208: oPushResult
 209: oCall 221
 211: oPop 1
 213: oGetParam 1
 215: oPushResult
 216: oCall 271
 218: oPop 1
 220: oReturn
 221: oLocalSpace 0
 223: oInputChoice 250
 225: oCall 1233
 227: oJumpForward 263
 229: oCall 1305
 231: oJumpForward 263
 233: oGetParam 1
 235: oPushResult
 236: oCall 1364
 238: oPop 1
 240: oJumpForward 263
 242: oCall 375
 244: oJumpForward 263
 246: oCall 660
 248: oJumpForward 263
 250: Choice Lookup Table
          29    246
          28    242
          32    233
          31    229
          30    225
 261: oJumpForward 265
 263: oJumpBack 223
 265: oCall 268
 267: oReturn
 268: oLocalSpace 0
 270: oReturn
 271: oLocalSpace 2
 273: oEmit 48
 275: oGetParam 1
 277: oPushResult
 278: oEmitLabel
 279: oPop 1
 281: oEmit 44
 283: oGetAddrLocal 1
 285: oPushResult
 286: Here
 287: oAssign
 288: oEmit 56
 290: oCall 4564
 292: oEmit 43
 294: oGetAddrLocal 2
 296: oPushResult
 297: oScopeCurrent
 298: oPushResult
 299: oSetResult 2
 301: oPushResult
 302: oNodeGetInt
 303: oPop 2
 305: oAssign
 306: oGetLocal 1
 308: oPushResult
 309: oGetLocal 2
 311: oPushResult
 312: oPatch
 313: oPop 2
 315: oReturn
 316: oLocalSpace 0
 318: oInputChoice 336
 320: oGetParam 1
 322: oPushResult
 323: oSetResult 12
 325: oPushResult
 326: oSetResult 1
 328: oPushResult
 329: oNodeSetBoolean
 330: oPop 3
 332: oInput 4
 334: oJumpForward 341
 336: Choice Lookup Table
          61    320
 339: oJumpForward 343
 341: oJumpBack 318
 343: oReturn
 344: oLocalSpace 0
 346: oGetParam 1
 348: oPushResult
 349: oSetResult 11
 351: oPushResult
 352: oSetResult 1
 354: oPushResult
 355: oNodeSetBoolean
 356: oPop 3
 358: oInputChoice 371
 360: oInputChoice 366
 362: oInput 2
 364: oJumpForward 369
 366: Choice Lookup Table
          60    362
 369: oJumpForward 374
 371: Choice Lookup Table
           2    360
 374: oReturn
 375: oLocalSpace 4
 377: oInput 0
 379: oGetAddrLocal 1
 381: oPushResult
 382: oSetResult 0
 384: oAssign
 385: oGetAddrLocal 2
 387: oPushResult
 388: oScopeFindInCurrentScope
 389: oAssign
 390: oGetLocal 2
 392: oPushResult
 393: oNodeNull
 394: oPop 1
 396: oChoice 517
 398: oGetAddrLocal 2
 400: oPushResult
 401: oSetResult 7
 403: oPushResult
 404: oSetResult 2
 406: oPushResult
 407: LAST_ID
 408: oPushResult
 409: oCall 5712
 411: oPop 3
 413: oAssign
 414: oGetLocal 2
 416: oPushResult
 417: oSetResult 6
 419: oPushResult
 420: oLabelNew
 421: oPushResult
 422: oNodeSetLabel
 423: oPop 3
 425: oJumpForward 523
 427: oGetAddrLocal 1
 429: oPushResult
 430: oSetResult 1
 432: oAssign
 433: oGetLocal 2
 435: oPushResult
 436: oSetResult 10
 438: oPushResult
 439: oNodeGetBoolean
 440: oPop 2
 442: oChoice 448
 444: oError 21
 446: oJumpForward 451
 448: Choice Lookup Table
           1    444
 451: oGetLocal 2
 453: oPushResult
 454: oSetResult 11
 456: oPushResult
 457: oNodeGetBoolean
 458: oPop 2
 460: oChoice 466
 462: oError 21
 464: oJumpForward 469
 466: Choice Lookup Table
           1    462
 469: oGetLocal 2
 471: oPushResult
 472: oNodeType
 473: oPop 1
 475: oChoice 479
 477: oJumpForward 484
 479: Choice Lookup Table
           7    477
 482: oError 21
 484: oGetLocal 2
 486: oPushResult
 487: oSetResult 14
 489: oPushResult
 490: oGetLocal 2
 492: oPushResult
 493: oSetResult 8
 495: oPushResult
 496: oNodeGet
 497: oPop 2
 499: oPushResult
 500: oNodeSet
 501: oPop 3
 503: oGetLocal 2
 505: oPushResult
 506: oSetResult 8
 508: oPushResult
 509: oSetResult 0
 511: oPushResult
 512: oNodeSet
 513: oPop 3
 515: oJumpForward 523
 517: Choice Lookup Table
           0    427
           1    398
 522: oEndChoice
 523: oScopeBegin
 524: oGetAddrLocal 3
 526: oPushResult
 527: oScopeCurrent
 528: oAssign
 529: oCall 1006
 531: oGetLocal 2
 533: oPushResult
 534: oSetResult 8
 536: oPushResult
 537: oGetLocal 3
 539: oPushResult
 540: oNodeSet
 541: oPop 3
 543: oScopeEnd
 544: oInput 4
 546: oGetLocal 1
 548: oChoice 560
 550: oGetLocal 2
 552: oPushResult
 553: oScopeDeclare
 554: oPop 1
 556: oJumpForward 566
 558: oJumpForward 566
 560: Choice Lookup Table
           1    558
           0    550
 565: oEndChoice
 566: oGetLocal 2
 568: oPushResult
 569: oCall 316
 571: oPop 1
 573: oInputChoice 586
 575: oJumpForward 657
 577: oGetLocal 2
 579: oPushResult
 580: oCall 344
 582: oPop 1
 584: oJumpForward 657
 586: Choice Lookup Table
          59    577
          58    575
 591: oGetLocal 3
 593: oPushResult
 594: oScopeEnter
 595: oPop 1
 597: oScopeBegin
 598: oScopeCurrent
 599: oPushResult
 600: oSetResult 3
 602: oPushResult
 603: oSetResult 1
 605: oPushResult
 606: oNodeSetBoolean
 607: oPop 3
 609: oGetLocal 2
 611: oPushResult
 612: oSetResult 9
 614: oPushResult
 615: oScopeCurrent
 616: oPushResult
 617: oNodeSet
 618: oPop 3
 620: oGetAddrLocal 4
 622: oPushResult
 623: oGetLocal 2
 625: oPushResult
 626: oSetResult 6
 628: oPushResult
 629: oNodeGetLabel
 630: oPop 2
 632: oAssign
 633: oSetResult 13
 635: oPushResult
 636: oGetLocal 4
 638: oPushResult
 639: oCall 204
 641: oPop 2
 643: oGetLocal 2
 645: oPushResult
 646: oSetResult 10
 648: oPushResult
 649: oSetResult 1
 651: oPushResult
 652: oNodeSetBoolean
 653: oPop 3
 655: oScopeEnd
 656: oScopeEnd
 657: oInput 4
 659: oReturn
 660: oLocalSpace 6
 662: oInput 0
 664: oGetAddrLocal 1
 666: oPushResult
 667: oSetResult 0
 669: oAssign
 670: oGetAddrLocal 2
 672: oPushResult
 673: oScopeFindInCurrentScope
 674: oAssign
 675: oGetLocal 2
 677: oPushResult
 678: oNodeNull
 679: oPop 1
 681: oChoice 815
 683: oGetAddrLocal 2
 685: oPushResult
 686: oSetResult 8
 688: oPushResult
 689: oSetResult 3
 691: oPushResult
 692: LAST_ID
 693: oPushResult
 694: oCall 5712
 696: oPop 3
 698: oAssign
 699: oGetLocal 2
 701: oPushResult
 702: oSetResult 6
 704: oPushResult
 705: oLabelNew
 706: oPushResult
 707: oNodeSetLabel
 708: oPop 3
 710: oJumpForward 821
 712: oGetAddrLocal 1
 714: oPushResult
 715: oSetResult 1
 717: oAssign
 718: oGetLocal 2
 720: oPushResult
 721: oSetResult 10
 723: oPushResult
 724: oNodeGetBoolean
 725: oPop 2
 727: oChoice 733
 729: oError 21
 731: oJumpForward 736
 733: Choice Lookup Table
           1    729
 736: oGetLocal 2
 738: oPushResult
 739: oNodeType
 740: oPop 1
 742: oChoice 746
 744: oJumpForward 751
 746: Choice Lookup Table
           8    744
 749: oError 21
 751: oGetLocal 2
 753: oPushResult
 754: oSetResult 14
 756: oPushResult
 757: oGetLocal 2
 759: oPushResult
 760: oSetResult 8
 762: oPushResult
 763: oNodeGet
 764: oPop 2
 766: oPushResult
 767: oNodeSet
 768: oPop 3
 770: oGetLocal 2
 772: oPushResult
 773: oSetResult 8
 775: oPushResult
 776: oSetResult 0
 778: oPushResult
 779: oNodeSet
 780: oPop 3
 782: oGetLocal 2
 784: oPushResult
 785: oSetResult 15
 787: oPushResult
 788: oGetLocal 2
 790: oPushResult
 791: oSetResult 5
 793: oPushResult
 794: oNodeGet
 795: oPop 2
 797: oPushResult
 798: oNodeSet
 799: oPop 3
 801: oGetLocal 2
 803: oPushResult
 804: oSetResult 5
 806: oPushResult
 807: oSetResult 0
 809: oPushResult
 810: oNodeSet
 811: oPop 3
 813: oJumpForward 821
 815: Choice Lookup Table
           0    712
           1    683
 820: oEndChoice
 821: oScopeBegin
 822: oGetAddrLocal 3
 824: oPushResult
 825: oScopeCurrent
 826: oAssign
 827: oCall 1006
 829: oGetLocal 2
 831: oPushResult
 832: oSetResult 8
 834: oPushResult
 835: oGetLocal 3
 837: oPushResult
 838: oNodeSet
 839: oPop 3
 841: oInput 11
 843: oGetAddrLocal 4
 845: oPushResult
 846: oCall 1505
 848: oPop 1
 850: oGetLocal 2
 852: oPushResult
 853: oSetResult 5
 855: oPushResult
 856: oGetLocal 4
 858: oPushResult
 859: oNodeSet
 860: oPop 3
 862: oGetAddrLocal 5
 864: oPushResult
 865: oGetLocal 4
 867: oPushResult
 868: oCall 5740
 870: oPop 1
 872: oAssign
 873: oGetLocal 2
 875: oPushResult
 876: oSetResult 16
 878: oPushResult
 879: oGetLocal 5
 881: oPushResult
 882: oScopeAllocType
 883: oPop 1
 885: oPushResult
 886: oNodeSetInt
 887: oPop 3
 889: oScopeEnd
 890: oInput 4
 892: oGetLocal 1
 894: oChoice 906
 896: oGetLocal 2
 898: oPushResult
 899: oScopeDeclare
 900: oPop 1
 902: oJumpForward 912
 904: oJumpForward 912
 906: Choice Lookup Table
           1    904
           0    896
 911: oEndChoice
 912: oGetLocal 2
 914: oPushResult
 915: oCall 316
 917: oPop 1
 919: oInputChoice 932
 921: oJumpForward 1003
 923: oGetLocal 2
 925: oPushResult
 926: oCall 344
 928: oPop 1
 930: oJumpForward 1003
 932: Choice Lookup Table
          59    923
          58    921
 937: oGetLocal 3
 939: oPushResult
 940: oScopeEnter
 941: oPop 1
 943: oScopeBegin
 944: oScopeCurrent
 945: oPushResult
 946: oSetResult 3
 948: oPushResult
 949: oSetResult 1
 951: oPushResult
 952: oNodeSetBoolean
 953: oPop 3
 955: oGetLocal 2
 957: oPushResult
 958: oSetResult 9
 960: oPushResult
 961: oScopeCurrent
 962: oPushResult
 963: oNodeSet
 964: oPop 3
 966: oGetAddrLocal 6
 968: oPushResult
 969: oGetLocal 2
 971: oPushResult
 972: oSetResult 6
 974: oPushResult
 975: oNodeGetLabel
 976: oPop 2
 978: oAssign
 979: oSetResult 13
 981: oPushResult
 982: oGetLocal 6
 984: oPushResult
 985: oCall 204
 987: oPop 2
 989: oGetLocal 2
 991: oPushResult
 992: oSetResult 10
 994: oPushResult
 995: oSetResult 1
 997: oPushResult
 998: oNodeSetBoolean
 999: oPop 3
1001: oScopeEnd
1002: oScopeEnd
1003: oInput 4
1005: oReturn
1006: oLocalSpace 6
1008: oInputChoice 1229
1010: oGetAddrLocal 1
1012: oPushResult
1013: oNodeVecNew
1014: oAssign
1015: oGetAddrLocal 3
1017: oPushResult
1018: oSetResult 0
1020: oAssign
1021: oInputChoice 1031
1023: oGetAddrLocal 3
1025: oPushResult
1026: oSetResult 1
1028: oAssign
1029: oJumpForward 1034
1031: Choice Lookup Table
          32   1023
1034: oInput 0
1036: oGetAddrLocal 2
1038: oPushResult
1039: oSetResult 15
1041: oPushResult
1042: oSetResult 6
1044: oPushResult
1045: LAST_ID
1046: oPushResult
1047: oCall 5712
1049: oPop 3
1051: oAssign
1052: oGetLocal 2
1054: oPushResult
1055: oSetResult 17
1057: oPushResult
1058: oGetLocal 3
1060: oPushResult
1061: oNodeSetBoolean
1062: oPop 3
1064: oGetLocal 1
1066: oPushResult
1067: oGetLocal 2
1069: oPushResult
1070: oNodeVecAppend
1071: oPop 2
1073: oInputChoice 1081
1075: oJumpForward 1089
1077: oJumpForward 1087
1079: oJumpForward 1087
1081: Choice Lookup Table
          12   1079
          11   1075
1086: oEndChoice
1087: oJumpBack 1034
1089: oGetAddrLocal 4
1091: oPushResult
1092: oCall 1505
1094: oPop 1
1096: oGetLocal 3
1098: oChoice 1113
1100: oGetAddrLocal 5
1102: oPushResult
1103: oGetLocal 4
1105: oPushResult
1106: oCall 5740
1108: oPop 1
1110: oAssign
1111: oJumpForward 1122
1113: Choice Lookup Table
           1   1100
1116: oGetAddrLocal 5
1118: oPushResult
1119: oGetLocal 4
1121: oAssign
1122: oGetAddrLocal 6
1124: oPushResult
1125: oSetResult 0
1127: oAssign
1128: oGetLocal 6
1130: oPushResult
1131: oGetLocal 1
1133: oPushResult
1134: oNodeVecSize
1135: oPop 1
1137: oPushResult
1138: equal
1139: oPop 2
1141: oChoice 1198
1143: oGetAddrLocal 2
1145: oPushResult
1146: oGetLocal 1
1148: oPushResult
1149: oGetLocal 6
1151: oPushResult
1152: oNodeVecElement
1153: oPop 2
1155: oAssign
1156: oGetLocal 2
1158: oPushResult
1159: oSetResult 5
1161: oPushResult
1162: oGetLocal 4
1164: oPushResult
1165: oNodeSet
1166: oPop 3
1168: oGetLocal 2
1170: oPushResult
1171: oScopeDeclare
1172: oPop 1
1174: oGetLocal 2
1176: oPushResult
1177: oSetResult 6
1179: oPushResult
1180: oGetLocal 5
1182: oPushResult
1183: oScopeAllocType
1184: oPop 1
1186: oPushResult
1187: oNodeSetInt
1188: oPop 3
1190: oGetAddrLocal 6
1192: oPushResult
1193: inc
1194: oPop 1
1196: oJumpForward 1203
1198: Choice Lookup Table
           0   1143
1201: oJumpForward 1205
1203: oJumpBack 1128
1205: oGetLocal 1
1207: oPushResult
1208: oNodeVecDelete
1209: oPop 1
1211: oInputChoice 1219
1213: oJumpForward 1227
1215: oJumpForward 1225
1217: oJumpForward 1225
1219: Choice Lookup Table
           4   1217
          14   1213
1224: oEndChoice
1225: oJumpBack 1010
1227: oJumpForward 1232
1229: Choice Lookup Table
          13   1010
1232: oReturn
1233: oLocalSpace 2
1235: oInputChoice 1297
1237: oGetAddrLocal 1
1239: oPushResult
1240: oSetResult 9
1242: oPushResult
1243: oSetResult 4
1245: oPushResult
1246: LAST_ID
1247: oPushResult
1248: oCall 5712
1250: oPop 3
1252: oAssign
1253: oInput 5
1255: oCall 1974
1257: oGetAddrLocal 2
1259: oPushResult
1260: oValueTop
1261: oAssign
1262: oValuePop
1263: oGetLocal 1
1265: oPushResult
1266: oSetResult 6
1268: oPushResult
1269: oGetLocal 2
1271: oPushResult
1272: oNodeSetInt
1273: oPop 3
1275: oGetLocal 1
1277: oPushResult
1278: oSetResult 5
1280: oPushResult
1281: oGetGlobal 3
1283: oPushResult
1284: oNodeSet
1285: oPop 3
1287: oGetLocal 1
1289: oPushResult
1290: oScopeDeclare
1291: oPop 1
1293: oInput 4
1295: oJumpForward 1302
1297: Choice Lookup Table
           0   1237
1300: oJumpForward 1304
1302: oJumpBack 1235
1304: oReturn
1305: oLocalSpace 2
1307: oInputChoice 1356
1309: oGetAddrLocal 1
1311: oPushResult
1312: oSetResult 10
1314: oPushResult
1315: oSetResult 5
1317: oPushResult
1318: LAST_ID
1319: oPushResult
1320: oCall 5712
1322: oPop 3
1324: oAssign
1325: oInput 5
1327: oGetAddrLocal 2
1329: oPushResult
1330: oCall 1505
1332: oPop 1
1334: oGetLocal 1
1336: oPushResult
1337: oSetResult 5
1339: oPushResult
1340: oGetLocal 2
1342: oPushResult
1343: oNodeSet
1344: oPop 3
1346: oGetLocal 1
1348: oPushResult
1349: oScopeDeclare
1350: oPop 1
1352: oInput 4
1354: oJumpForward 1361
1356: Choice Lookup Table
           0   1309
1359: oJumpForward 1363
1361: oJumpBack 1307
1363: oReturn
1364: oLocalSpace 4
1366: oInputChoice 1497
1368: oGetAddrLocal 1
1370: oPushResult
1371: oNodeVecNew
1372: oAssign
1373: oGetAddrLocal 2
1375: oPushResult
1376: oGetParam 1
1378: oPushResult
1379: oSetResult 6
1381: oPushResult
1382: LAST_ID
1383: oPushResult
1384: oCall 5712
1386: oPop 3
1388: oAssign
1389: oGetLocal 1
1391: oPushResult
1392: oGetLocal 2
1394: oPushResult
1395: oNodeVecAppend
1396: oPop 2
1398: oInputChoice 1404
1400: oInput 0
1402: oJumpForward 1409
1404: Choice Lookup Table
          12   1400
1407: oJumpForward 1411
1409: oJumpBack 1373
1411: oInput 11
1413: oGetAddrLocal 3
1415: oPushResult
1416: oCall 1505
1418: oPop 1
1420: oGetAddrLocal 4
1422: oPushResult
1423: oSetResult 0
1425: oAssign
1426: oGetLocal 4
1428: oPushResult
1429: oGetLocal 1
1431: oPushResult
1432: oNodeVecSize
1433: oPop 1
1435: oPushResult
1436: equal
1437: oPop 2
1439: oChoice 1480
1441: oGetAddrLocal 2
1443: oPushResult
1444: oGetLocal 1
1446: oPushResult
1447: oGetLocal 4
1449: oPushResult
1450: oNodeVecElement
1451: oPop 2
1453: oAssign
1454: oGetLocal 2
1456: oPushResult
1457: oSetResult 5
1459: oPushResult
1460: oGetLocal 3
1462: oPushResult
1463: oNodeSet
1464: oPop 3
1466: oGetLocal 2
1468: oPushResult
1469: oScopeDeclareAlloc
1470: oPop 1
1472: oGetAddrLocal 4
1474: oPushResult
1475: inc
1476: oPop 1
1478: oJumpForward 1485
1480: Choice Lookup Table
           0   1441
1483: oJumpForward 1487
1485: oJumpBack 1426
1487: oGetLocal 1
1489: oPushResult
1490: oNodeVecDelete
1491: oPop 1
1493: oInput 4
1495: oJumpForward 1502
1497: Choice Lookup Table
           0   1368
1500: oJumpForward 1504
1502: oJumpBack 1366
1504: oReturn
1505: oLocalSpace 12
1507: oInputChoice 1956
1509: oGetAddrLocal 1
1511: oPushResult
1512: oScopeFindRequire
1513: oAssign
1514: oGetLocal 1
1516: oPushResult
1517: oNodeType
1518: oPop 1
1520: oChoice 1537
1522: oGetParam 1
1524: oPushResult
1525: oGetLocal 1
1527: oPushResult
1528: oSetResult 5
1530: oPushResult
1531: oNodeGet
1532: oPop 2
1534: oAssign
1535: oJumpForward 1548
1537: Choice Lookup Table
          10   1522
1540: oError 2
1542: oGetParam 1
1544: oPushResult
1545: oGetGlobal 3
1547: oAssign
1548: oJumpForward 1973
1550: oInput 15
1552: oGetAddrLocal 2
1554: oPushResult
1555: oNodeVecNew
1556: oAssign
1557: oGetAddrLocal 3
1559: oPushResult
1560: oSetResult 25
1562: oPushResult
1563: oNodeNew
1564: oPop 1
1566: oAssign
1567: oGetLocal 3
1569: oPushResult
1570: oSetResult 19
1572: oPushResult
1573: oGetGlobal 3
1575: oPushResult
1576: oNodeSet
1577: oPop 3
1579: oCall 1974
1581: oGetLocal 3
1583: oPushResult
1584: oSetResult 21
1586: oPushResult
1587: oValueTop
1588: oPushResult
1589: oNodeSetInt
1590: oPop 3
1592: oValuePop
1593: oInput 20
1595: oCall 1974
1597: oGetLocal 3
1599: oPushResult
1600: oSetResult 22
1602: oPushResult
1603: oValueTop
1604: oPushResult
1605: oNodeSetInt
1606: oPop 3
1608: oValuePop
1609: oGetLocal 3
1611: oPushResult
1612: oSetResult 2
1614: oPushResult
1615: oSetResult 4
1617: oPushResult
1618: oNodeSetInt
1619: oPop 3
1621: oGetLocal 3
1623: oPushResult
1624: oTypeAdd
1625: oPop 1
1627: oGetAddrLocal 4
1629: oPushResult
1630: oSetResult 24
1632: oPushResult
1633: oNodeNew
1634: oPop 1
1636: oAssign
1637: oGetLocal 4
1639: oPushResult
1640: oSetResult 20
1642: oPushResult
1643: oGetLocal 3
1645: oPushResult
1646: oNodeSet
1647: oPop 3
1649: oGetLocal 2
1651: oPushResult
1652: oGetLocal 4
1654: oPushResult
1655: oNodeVecAppend
1656: oPop 2
1658: oInputChoice 1666
1660: oJumpForward 1674
1662: oJumpForward 1672
1664: oJumpForward 1672
1666: Choice Lookup Table
          12   1664
          16   1660
1671: oEndChoice
1672: oJumpBack 1557
1674: oInput 38
1676: oGetAddrLocal 5
1678: oPushResult
1679: oCall 1505
1681: oPop 1
1683: oGetAddrLocal 6
1685: oPushResult
1686: oGetLocal 2
1688: oPushResult
1689: oNodeVecSize
1690: oPop 1
1692: oAssign
1693: oGetAddrLocal 6
1695: oPushResult
1696: dec
1697: oPop 1
1699: oGetAddrLocal 7
1701: oPushResult
1702: oGetLocal 2
1704: oPushResult
1705: oGetLocal 6
1707: oPushResult
1708: oNodeVecElement
1709: oPop 2
1711: oAssign
1712: oGetLocal 7
1714: oPushResult
1715: oSetResult 19
1717: oPushResult
1718: oGetLocal 5
1720: oPushResult
1721: oNodeSet
1722: oPop 3
1724: oGetAddrLocal 8
1726: oPushResult
1727: oGetLocal 7
1729: oPushResult
1730: oSetResult 20
1732: oPushResult
1733: oNodeGet
1734: oPop 2
1736: oAssign
1737: oGetAddrLocal 9
1739: oPushResult
1740: oGetLocal 8
1742: oPushResult
1743: oSetResult 22
1745: oPushResult
1746: oNodeGetInt
1747: oPop 2
1749: oPushResult
1750: oGetLocal 8
1752: oPushResult
1753: oSetResult 21
1755: oPushResult
1756: oNodeGetInt
1757: oPop 2
1759: oPushResult
1760: subtract
1761: oPop 2
1763: oAssign
1764: oGetAddrLocal 9
1766: oPushResult
1767: inc
1768: oPop 1
1770: oGetLocal 7
1772: oPushResult
1773: oSetResult 2
1775: oPushResult
1776: oGetLocal 9
1778: oPushResult
1779: oGetLocal 5
1781: oPushResult
1782: oSetResult 2
1784: oPushResult
1785: oNodeGetInt
1786: oPop 2
1788: oPushResult
1789: multiply
1790: oPop 2
1792: oPushResult
1793: oNodeSetInt
1794: oPop 3
1796: oGetLocal 7
1798: oPushResult
1799: oTypeAdd
1800: oPop 1
1802: oGetAddrLocal 5
1804: oPushResult
1805: oGetLocal 7
1807: oAssign
1808: oGetLocal 6
1810: oPushResult
1811: equal_zero
1812: oPop 1
1814: oChoice 1820
1816: oJumpForward 1825
1818: oJumpForward 1823
1820: Choice Lookup Table
           1   1816
1823: oJumpBack 1693
1825: oGetParam 1
1827: oPushResult
1828: oGetLocal 2
1830: oPushResult
1831: oSetResult 0
1833: oPushResult
1834: oNodeVecElement
1835: oPop 2
1837: oAssign
1838: oGetLocal 2
1840: oPushResult
1841: oNodeVecDelete
1842: oPop 1
1844: oJumpForward 1973
1846: oGetAddrLocal 10
1848: oPushResult
1849: oCall 1505
1851: oPop 1
1853: oGetParam 1
1855: oPushResult
1856: oGetLocal 10
1858: oPushResult
1859: oCall 5740
1861: oPop 1
1863: oAssign
1864: oJumpForward 1973
1866: oGetParam 1
1868: oPushResult
1869: oSetResult 26
1871: oPushResult
1872: oNodeNew
1873: oPop 1
1875: oAssign
1876: oScopeBegin
1877: oSetResult 14
1879: oPushResult
1880: oCall 1364
1882: oPop 1
1884: oGetAddrLocal 11
1886: oPushResult
1887: oScopeCurrent
1888: oPushResult
1889: oSetResult 2
1891: oPushResult
1892: oNodeGetInt
1893: oPop 2
1895: oAssign
1896: oGetLocal 11
1898: oPushResult
1899: equal_zero
1900: oPop 1
1902: oChoice 1908
1904: oError 19
1906: oJumpForward 1911
1908: Choice Lookup Table
           1   1904
1911: oInput 34
1913: oGetFromParam 1
1915: oPushResult
1916: oSetResult 23
1918: oPushResult
1919: oScopeCurrent
1920: oPushResult
1921: oNodeSet
1922: oPop 3
1924: oGetFromParam 1
1926: oPushResult
1927: oSetResult 2
1929: oPushResult
1930: oGetLocal 11
1932: oPushResult
1933: oNodeSetInt
1934: oPop 3
1936: oScopeEnd
1937: oGetFromParam 1
1939: oPushResult
1940: oTypeAdd
1941: oPop 1
1943: oJumpForward 1973
1945: oInput 38
1947: oGetAddrLocal 12
1949: oPushResult
1950: oCall 1505
1952: oPop 1
1954: oJumpForward 1973
1956: Choice Lookup Table
          37   1945
          36   1866
          17   1846
          35   1550
           0   1509
1967: oCall 1974
1969: oInput 20
1971: oCall 1974
1973: oReturn
1974: oLocalSpace 1
1976: oInputChoice 2031
1978: TOKEN_VALUE
1979: oPushResult
1980: oValuePush
1981: oPop 1
1983: oJumpForward 2039
1985: oGetAddrLocal 1
1987: oPushResult
1988: oScopeFindRequire
1989: oAssign
1990: oGetLocal 1
1992: oPushResult
1993: oNodeType
1994: oPop 1
1996: oChoice 2013
1998: oGetLocal 1
2000: oPushResult
2001: oSetResult 6
2003: oPushResult
2004: oNodeGetInt
2005: oPop 2
2007: oPushResult
2008: oValuePush
2009: oPop 1
2011: oJumpForward 2024
2013: Choice Lookup Table
           9   1998
2016: oError 1
2018: oSetResult 0
2020: oPushResult
2021: oValuePush
2022: oPop 1
2024: oJumpForward 2039
2026: oCall 1974
2028: oValueNegate
2029: oJumpForward 2039
2031: Choice Lookup Table
          24   2026
           0   1985
           1   1978
2038: oEndChoice
2039: oReturn
2040: oLocalSpace 1
2042: oGetAddrLocal 1
2044: oPushResult
2045: oSetResult 0
2047: oAssign
2048: oGetAddrLocal 1
2050: oPushResult
2051: oCall 2201
2053: oPop 1
2055: oGetAddrLocal 1
2057: oPushResult
2058: oCall 2101
2060: oPop 1
2062: oReturn
2063: oLocalSpace 0
2065: oGetParam 1
2067: oPushResult
2068: oCall 2201
2070: oPop 1
2072: oTypeSNodeType
2073: oChoice 2092
2075: oJumpForward 2099
2077: oGetParam 1
2079: oPushResult
2080: oLabelNew
2081: oAssign
2082: oEmit 47
2084: oGetFromParam 1
2086: oPushResult
2087: oEmitLabel
2088: oPop 1
2090: oJumpForward 2099
2092: Choice Lookup Table
          19   2077
          20   2075
2097: oError 8
2099: oTypeSPop
2100: oReturn
2101: oLocalSpace 1
2103: oTypeSNodeType
2104: oChoice 2166
2106: oGetAddrLocal 1
2108: oPushResult
2109: oLabelNew
2110: oAssign
2111: oEmit 9
2113: oSetResult 1
2115: oPushResult
2116: oEmitInt
2117: oPop 1
2119: oEmit 45
2121: oGetLocal 1
2123: oPushResult
2124: oEmitLabel
2125: oPop 1
2127: oEmit 48
2129: oGetFromParam 1
2131: oPushResult
2132: oEmitLabel
2133: oPop 1
2135: oEmit 9
2137: oSetResult 0
2139: oPushResult
2140: oEmitInt
2141: oPop 1
2143: oEmit 48
2145: oGetLocal 1
2147: oPushResult
2148: oEmitLabel
2149: oPop 1
2151: oTypeSPop
2152: oGetGlobal 4
2154: oPushResult
2155: oTypeSPush
2156: oPop 1
2158: oGetParam 1
2160: oPushResult
2161: oSetResult 0
2163: oAssign
2164: oJumpForward 2169
2166: Choice Lookup Table
          20   2106
2169: oReturn
2170: oLocalSpace 0
2172: oTypeSNodeType
2173: oChoice 2197
2175: oGetParam 1
2177: oPushResult
2178: oLabelNew
2179: oAssign
2180: oEmit 47
2182: oGetFromParam 1
2184: oPushResult
2185: oEmitLabel
2186: oPop 1
2188: oTypeSPop
2189: oGetGlobal 5
2191: oPushResult
2192: oTypeSPush
2193: oPop 1
2195: oJumpForward 2200
2197: Choice Lookup Table
          19   2175
2200: oReturn
2201: oLocalSpace 0
2203: oGetParam 1
2205: oPushResult
2206: oCall 2566
2208: oPop 1
2210: oInputChoice 2548
2212: oGetParam 1
2214: oPushResult
2215: oCall 2101
2217: oPop 1
2219: oGetParam 1
2221: oPushResult
2222: oCall 2566
2224: oPop 1
2226: oGetParam 1
2228: oPushResult
2229: oCall 2101
2231: oPop 1
2233: oCall 5598
2235: oTypeSNodeType
2236: oChoice 2250
2238: oEmit 30
2240: oJumpForward 2263
2242: oEmit 36
2244: oJumpForward 2263
2246: oError 16
2248: oJumpForward 2263
2250: Choice Lookup Table
          22   2246
          21   2246
          23   2242
          19   2238
          18   2238
2261: oError 17
2263: oTypeSPop
2264: oGetGlobal 4
2266: oPushResult
2267: oTypeSPush
2268: oPop 1
2270: oJumpForward 2563
2272: oGetParam 1
2274: oPushResult
2275: oCall 2101
2277: oPop 1
2279: oGetParam 1
2281: oPushResult
2282: oCall 2566
2284: oPop 1
2286: oGetParam 1
2288: oPushResult
2289: oCall 2101
2291: oPop 1
2293: oCall 5598
2295: oTypeSNodeType
2296: oChoice 2310
2298: oEmit 31
2300: oJumpForward 2323
2302: oEmit 37
2304: oJumpForward 2323
2306: oError 16
2308: oJumpForward 2323
2310: Choice Lookup Table
          22   2306
          21   2306
          23   2302
          19   2298
          18   2298
2321: oError 17
2323: oTypeSPop
2324: oGetGlobal 4
2326: oPushResult
2327: oTypeSPush
2328: oPop 1
2330: oJumpForward 2563
2332: oGetParam 1
2334: oPushResult
2335: oCall 2101
2337: oPop 1
2339: oGetParam 1
2341: oPushResult
2342: oCall 2566
2344: oPop 1
2346: oGetParam 1
2348: oPushResult
2349: oCall 2101
2351: oPop 1
2353: oCall 5598
2355: oTypeSNodeType
2356: oChoice 2366
2358: oEmit 33
2360: oJumpForward 2377
2362: oError 16
2364: oJumpForward 2377
2366: Choice Lookup Table
          22   2362
          21   2362
          19   2358
          18   2358
2375: oError 17
2377: oTypeSPop
2378: oGetGlobal 4
2380: oPushResult
2381: oTypeSPush
2382: oPop 1
2384: oJumpForward 2563
2386: oGetParam 1
2388: oPushResult
2389: oCall 2101
2391: oPop 1
2393: oGetParam 1
2395: oPushResult
2396: oCall 2566
2398: oPop 1
2400: oGetParam 1
2402: oPushResult
2403: oCall 2101
2405: oPop 1
2407: oCall 5598
2409: oTypeSNodeType
2410: oChoice 2420
2412: oEmit 32
2414: oJumpForward 2431
2416: oError 16
2418: oJumpForward 2431
2420: Choice Lookup Table
          22   2416
          21   2416
          19   2412
          18   2412
2429: oError 17
2431: oTypeSPop
2432: oGetGlobal 4
2434: oPushResult
2435: oTypeSPush
2436: oPop 1
2438: oJumpForward 2563
2440: oGetParam 1
2442: oPushResult
2443: oCall 2101
2445: oPop 1
2447: oGetParam 1
2449: oPushResult
2450: oCall 2566
2452: oPop 1
2454: oGetParam 1
2456: oPushResult
2457: oCall 2101
2459: oPop 1
2461: oCall 5598
2463: oTypeSNodeType
2464: oChoice 2474
2466: oEmit 35
2468: oJumpForward 2485
2470: oError 16
2472: oJumpForward 2485
2474: Choice Lookup Table
          22   2470
          21   2470
          19   2466
          18   2466
2483: oError 17
2485: oTypeSPop
2486: oGetGlobal 4
2488: oPushResult
2489: oTypeSPush
2490: oPop 1
2492: oJumpForward 2563
2494: oGetParam 1
2496: oPushResult
2497: oCall 2101
2499: oPop 1
2501: oGetParam 1
2503: oPushResult
2504: oCall 2566
2506: oPop 1
2508: oGetParam 1
2510: oPushResult
2511: oCall 2101
2513: oPop 1
2515: oCall 5598
2517: oTypeSNodeType
2518: oChoice 2528
2520: oEmit 34
2522: oJumpForward 2539
2524: oError 16
2526: oJumpForward 2539
2528: Choice Lookup Table
          22   2524
          21   2524
          19   2520
          18   2520
2537: oError 17
2539: oTypeSPop
2540: oGetGlobal 4
2542: oPushResult
2543: oTypeSPush
2544: oPop 1
2546: oJumpForward 2563
2548: Choice Lookup Table
          10   2494
           9   2440
           8   2386
           7   2332
           6   2272
           5   2212
2561: oJumpForward 2565
2563: oJumpBack 2210
2565: oReturn
2566: oLocalSpace 1
2568: oGetAddrLocal 1
2570: oPushResult
2571: oSetResult 0
2573: oAssign
2574: oGetParam 1
2576: oPushResult
2577: oCall 2746
2579: oPop 1
2581: oInputChoice 2714
2583: oTypeSNodeType
2584: oChoice 2655
2586: oGetLocal 1
2588: oPushResult
2589: oSetResult 0
2591: oPushResult
2592: equal_label
2593: oPop 2
2595: oChoice 2604
2597: oGetAddrLocal 1
2599: oPushResult
2600: oLabelNew
2601: oAssign
2602: oJumpForward 2607
2604: Choice Lookup Table
           1   2597
2607: oEmit 45
2609: oGetLocal 1
2611: oPushResult
2612: oEmitLabel
2613: oPop 1
2615: oJumpForward 2662
2617: oGetParam 1
2619: oPushResult
2620: oCall 2170
2622: oPop 1
2624: oGetLocal 1
2626: oPushResult
2627: oSetResult 0
2629: oPushResult
2630: equal_label
2631: oPop 2
2633: oChoice 2642
2635: oGetAddrLocal 1
2637: oPushResult
2638: oLabelNew
2639: oAssign
2640: oJumpForward 2645
2642: Choice Lookup Table
           1   2635
2645: oEmit 46
2647: oGetLocal 1
2649: oPushResult
2650: oEmitLabel
2651: oPop 1
2653: oJumpForward 2662
2655: Choice Lookup Table
          19   2617
          20   2586
2660: oError 8
2662: oTypeSPop
2663: oEmit 48
2665: oGetFromParam 1
2667: oPushResult
2668: oEmitLabel
2669: oPop 1
2671: oGetParam 1
2673: oPushResult
2674: oSetResult 0
2676: oAssign
2677: oGetParam 1
2679: oPushResult
2680: oCall 2746
2682: oPop 1
2684: oTypeSNodeType
2685: oChoice 2698
2687: oJumpForward 2705
2689: oGetParam 1
2691: oPushResult
2692: oCall 2170
2694: oPop 1
2696: oJumpForward 2705
2698: Choice Lookup Table
          19   2689
          20   2687
2703: oError 8
2705: oTypeSPop
2706: oGetGlobal 5
2708: oPushResult
2709: oTypeSPush
2710: oPop 1
2712: oJumpForward 2719
2714: Choice Lookup Table
          52   2583
2717: oJumpForward 2721
2719: oJumpBack 2581
2721: oGetLocal 1
2723: oPushResult
2724: oSetResult 0
2726: oPushResult
2727: equal_label
2728: oPop 2
2730: oChoice 2742
2732: oEmit 48
2734: oGetLocal 1
2736: oPushResult
2737: oEmitLabel
2738: oPop 1
2740: oJumpForward 2745
2742: Choice Lookup Table
           0   2732
2745: oReturn
2746: oLocalSpace 2
2748: oGetAddrLocal 1
2750: oPushResult
2751: oSetResult 0
2753: oAssign
2754: oGetParam 1
2756: oPushResult
2757: oCall 2884
2759: oPop 1
2761: oInputChoice 2876
2763: oTypeSNodeType
2764: oChoice 2777
2766: oJumpForward 2784
2768: oGetParam 1
2770: oPushResult
2771: oCall 2170
2773: oPop 1
2775: oJumpForward 2784
2777: Choice Lookup Table
          19   2768
          20   2766
2782: oError 8
2784: oTypeSPop
2785: oGetLocal 1
2787: oPushResult
2788: oSetResult 0
2790: oPushResult
2791: equal_label
2792: oPop 2
2794: oChoice 2823
2796: oGetAddrLocal 1
2798: oPushResult
2799: oLabelNew
2800: oAssign
2801: oEmit 49
2803: oGetFromParam 1
2805: oPushResult
2806: oEmitLabel
2807: oPop 1
2809: oGetLocal 1
2811: oPushResult
2812: oEmitLabel
2813: oPop 1
2815: oGetParam 1
2817: oPushResult
2818: oGetLocal 1
2820: oAssign
2821: oJumpForward 2826
2823: Choice Lookup Table
           1   2796
2826: oGetAddrLocal 2
2828: oPushResult
2829: oSetResult 0
2831: oAssign
2832: oGetAddrLocal 2
2834: oPushResult
2835: oCall 2884
2837: oPop 1
2839: oTypeSNodeType
2840: oChoice 2853
2842: oJumpForward 2860
2844: oGetAddrLocal 2
2846: oPushResult
2847: oCall 2170
2849: oPop 1
2851: oJumpForward 2860
2853: Choice Lookup Table
          19   2844
          20   2842
2858: oError 8
2860: oEmit 49
2862: oGetLocal 2
2864: oPushResult
2865: oEmitLabel
2866: oPop 1
2868: oGetLocal 1
2870: oPushResult
2871: oEmitLabel
2872: oPop 1
2874: oJumpForward 2881
2876: Choice Lookup Table
          51   2763
2879: oJumpForward 2883
2881: oJumpBack 2761
2883: oReturn
2884: oLocalSpace 1
2886: oInputChoice 2940
2888: oGetAddrLocal 1
2890: oPushResult
2891: oSetResult 0
2893: oAssign
2894: oGetAddrLocal 1
2896: oPushResult
2897: oCall 2884
2899: oPop 1
2901: oTypeSNodeType
2902: oChoice 2931
2904: oGetParam 1
2906: oPushResult
2907: oLabelNew
2908: oAssign
2909: oEmit 45
2911: oGetFromParam 1
2913: oPushResult
2914: oEmitLabel
2915: oPop 1
2917: oEmit 48
2919: oGetLocal 1
2921: oPushResult
2922: oEmitLabel
2923: oPop 1
2925: oJumpForward 2938
2927: oEmit 29
2929: oJumpForward 2938
2931: Choice Lookup Table
          19   2927
          20   2904
2936: oError 8
2938: oJumpForward 2950
2940: Choice Lookup Table
          53   2888
2943: oGetParam 1
2945: oPushResult
2946: oCall 2951
2948: oPop 1
2950: oReturn
2951: oLocalSpace 0
2953: oGetParam 1
2955: oPushResult
2956: oCall 3002
2958: oPop 1
2960: oInputChoice 2992
2962: oCall 5624
2964: oGetParam 1
2966: oPushResult
2967: oCall 3002
2969: oPop 1
2971: oCall 5638
2973: oEmit 26
2975: oJumpForward 2999
2977: oCall 5624
2979: oGetParam 1
2981: oPushResult
2982: oCall 3002
2984: oPop 1
2986: oCall 5638
2988: oEmit 27
2990: oJumpForward 2999
2992: Choice Lookup Table
          24   2977
          23   2962
2997: oJumpForward 3001
2999: oJumpBack 2960
3001: oReturn
3002: oLocalSpace 0
3004: oGetParam 1
3006: oPushResult
3007: oCall 3053
3009: oPop 1
3011: oInputChoice 3043
3013: oCall 5624
3015: oGetParam 1
3017: oPushResult
3018: oCall 3053
3020: oPop 1
3022: oCall 5638
3024: oEmit 23
3026: oJumpForward 3050
3028: oCall 5624
3030: oGetParam 1
3032: oPushResult
3033: oCall 3053
3035: oPop 1
3037: oCall 5638
3039: oEmit 24
3041: oJumpForward 3050
3043: Choice Lookup Table
          22   3028
          21   3013
3048: oJumpForward 3052
3050: oJumpBack 3011
3052: oReturn
3053: oLocalSpace 0
3055: oInputChoice 3081
3057: oGetParam 1
3059: oPushResult
3060: oCall 3094
3062: oPop 1
3064: oCall 5638
3066: oJumpForward 3093
3068: oGetParam 1
3070: oPushResult
3071: oCall 3094
3073: oPop 1
3075: oCall 5638
3077: oEmit 28
3079: oJumpForward 3093
3081: Choice Lookup Table
          24   3068
          23   3057
3086: oGetParam 1
3088: oPushResult
3089: oCall 3094
3091: oPop 1
3093: oReturn
3094: oLocalSpace 6
3096: oInputChoice 3278
3098: oEmit 9
3100: TOKEN_VALUE
3101: oPushResult
3102: oEmitInt
3103: oPop 1
3105: oGetGlobal 3
3107: oPushResult
3108: oTypeSPush
3109: oPop 1
3111: oJumpForward 3297
3113: oGetParam 1
3115: oPushResult
3116: oCall 2201
3118: oPop 1
3120: oInput 14
3122: oJumpForward 3297
3124: oGetAddrLocal 1
3126: oPushResult
3127: oStringAllocLit
3128: oAssign
3129: oEmit 10
3131: oGetLocal 1
3133: oPushResult
3134: oEmitInt
3135: oPop 1
3137: oGetGlobal 7
3139: oPushResult
3140: oTypeSPush
3141: oPop 1
3143: oJumpForward 3297
3145: oGetAddrLocal 2
3147: oPushResult
3148: oScopeFindRequire
3149: oAssign
3150: oGetLocal 2
3152: oPushResult
3153: oNodeType
3154: oPop 1
3156: oChoice 3218
3158: oGetLocal 2
3160: oPushResult
3161: oCall 4020
3163: oPop 1
3165: oJumpForward 3237
3167: oGetAddrLocal 3
3169: oPushResult
3170: oGetLocal 2
3172: oPushResult
3173: oSetResult 5
3175: oPushResult
3176: oNodeGet
3177: oPop 2
3179: oAssign
3180: oGetLocal 3
3182: oPushResult
3183: oTypeSPush
3184: oPop 1
3186: oTypeSNodeType
3187: oChoice 3200
3189: oEmit 9
3191: oGetLocal 2
3193: oPushResult
3194: oCall 5875
3196: oPop 1
3198: oJumpForward 3207
3200: Choice Lookup Table
          19   3189
          18   3189
3205: oError 16
3207: oJumpForward 3237
3209: oGetLocal 2
3211: oPushResult
3212: oCall 3298
3214: oPop 1
3216: oJumpForward 3237
3218: Choice Lookup Table
          15   3209
          13   3209
          12   3209
           9   3167
           8   3158
3229: oError 6
3231: oGetGlobal 3
3233: oPushResult
3234: oTypeSPush
3235: oPop 1
3237: oJumpForward 3297
3239: oInput 0
3241: oGetAddrLocal 4
3243: oPushResult
3244: oScopeFindRequire
3245: oAssign
3246: oGetLocal 4
3248: oPushResult
3249: oCall 4917
3251: oPop 1
3253: oGetAddrLocal 5
3255: oPushResult
3256: oTypeSTop
3257: oAssign
3258: oTypeSPop
3259: oGetAddrLocal 6
3261: oPushResult
3262: oGetLocal 5
3264: oPushResult
3265: oCall 5740
3267: oPop 1
3269: oAssign
3270: oGetLocal 6
3272: oPushResult
3273: oTypeSPush
3274: oPop 1
3276: oJumpForward 3297
3278: Choice Lookup Table
          18   3239
           0   3145
           2   3124
          13   3113
           1   3098
3289: oError 6
3291: oGetGlobal 3
3293: oPushResult
3294: oTypeSPush
3295: oPop 1
3297: oReturn
3298: oLocalSpace 1
3300: oGetAddrLocal 1
3302: oPushResult
3303: oGetParam 1
3305: oPushResult
3306: oSetResult 5
3308: oPushResult
3309: oNodeGet
3310: oPop 2
3312: oAssign
3313: oGetLocal 1
3315: oPushResult
3316: oTypeSPush
3317: oPop 1
3319: oTypeSNodeType
3320: oChoice 3585
3322: oGetParam 1
3324: oPushResult
3325: oNodeType
3326: oPop 1
3328: oChoice 3390
3330: oEmit 0
3332: oGetParam 1
3334: oPushResult
3335: oCall 5875
3337: oPop 1
3339: oJumpForward 3398
3341: oEmit 3
3343: oGetParam 1
3345: oPushResult
3346: oCall 5875
3348: oPop 1
3350: oJumpForward 3398
3352: oGetParam 1
3354: oPushResult
3355: oSetResult 17
3357: oPushResult
3358: oNodeGetBoolean
3359: oPop 2
3361: oChoice 3376
3363: oEmit 8
3365: oGetParam 1
3367: oPushResult
3368: oCall 5875
3370: oPop 1
3372: oEmit 14
3374: oJumpForward 3388
3376: Choice Lookup Table
           1   3363
3379: oEmit 6
3381: oGetParam 1
3383: oPushResult
3384: oCall 5875
3386: oPop 1
3388: oJumpForward 3398
3390: Choice Lookup Table
          15   3352
          13   3341
          12   3330
3397: oEndChoice
3398: oJumpForward 3676
3400: oGetParam 1
3402: oPushResult
3403: oNodeType
3404: oPop 1
3406: oChoice 3468
3408: oEmit 1
3410: oGetParam 1
3412: oPushResult
3413: oCall 5875
3415: oPop 1
3417: oJumpForward 3476
3419: oEmit 4
3421: oGetParam 1
3423: oPushResult
3424: oCall 5875
3426: oPop 1
3428: oJumpForward 3476
3430: oGetParam 1
3432: oPushResult
3433: oSetResult 17
3435: oPushResult
3436: oNodeGetBoolean
3437: oPop 2
3439: oChoice 3454
3441: oEmit 8
3443: oGetParam 1
3445: oPushResult
3446: oCall 5875
3448: oPop 1
3450: oEmit 15
3452: oJumpForward 3466
3454: Choice Lookup Table
           1   3441
3457: oEmit 7
3459: oGetParam 1
3461: oPushResult
3462: oCall 5875
3464: oPop 1
3466: oJumpForward 3476
3468: Choice Lookup Table
          15   3430
          13   3419
          12   3408
3475: oEndChoice
3476: oJumpForward 3676
3478: oError 16
3480: oJumpForward 3676
3482: oGetParam 1
3484: oPushResult
3485: oNodeType
3486: oPop 1
3488: oChoice 3550
3490: oEmit 2
3492: oGetParam 1
3494: oPushResult
3495: oCall 5875
3497: oPop 1
3499: oJumpForward 3558
3501: oEmit 5
3503: oGetParam 1
3505: oPushResult
3506: oCall 5875
3508: oPop 1
3510: oJumpForward 3558
3512: oGetParam 1
3514: oPushResult
3515: oSetResult 17
3517: oPushResult
3518: oNodeGetBoolean
3519: oPop 2
3521: oChoice 3536
3523: oEmit 8
3525: oGetParam 1
3527: oPushResult
3528: oCall 5875
3530: oPop 1
3532: oEmit 16
3534: oJumpForward 3548
3536: Choice Lookup Table
           1   3523
3539: oEmit 8
3541: oGetParam 1
3543: oPushResult
3544: oCall 5875
3546: oPop 1
3548: oJumpForward 3558
3550: Choice Lookup Table
          15   3512
          13   3501
          12   3490
3557: oEndChoice
3558: oInputChoice 3580
3560: oTypeSPop
3561: oGetLocal 1
3563: oPushResult
3564: oSetResult 19
3566: oPushResult
3567: oNodeGet
3568: oPop 2
3570: oPushResult
3571: oTypeSPush
3572: oPop 1
3574: oCall 3712
3576: oCall 3677
3578: oJumpForward 3583
3580: Choice Lookup Table
          17   3560
3583: oJumpForward 3676
3585: Choice Lookup Table
          23   3482
          17   3478
          22   3478
          21   3478
          19   3400
          18   3322
3598: oGetParam 1
3600: oPushResult
3601: oNodeType
3602: oPop 1
3604: oChoice 3664
3606: oEmit 10
3608: oGetParam 1
3610: oPushResult
3611: oCall 5875
3613: oPop 1
3615: oJumpForward 3672
3617: oEmit 11
3619: oGetParam 1
3621: oPushResult
3622: oCall 5875
3624: oPop 1
3626: oJumpForward 3672
3628: oGetParam 1
3630: oPushResult
3631: oSetResult 17
3633: oPushResult
3634: oNodeGetBoolean
3635: oPop 2
3637: oChoice 3650
3639: oEmit 8
3641: oGetParam 1
3643: oPushResult
3644: oCall 5875
3646: oPop 1
3648: oJumpForward 3662
3650: Choice Lookup Table
           1   3639
3653: oEmit 12
3655: oGetParam 1
3657: oPushResult
3658: oCall 5875
3660: oPop 1
3662: oJumpForward 3672
3664: Choice Lookup Table
          15   3628
          13   3617
          12   3606
3671: oEndChoice
3672: oCall 3712
3674: oCall 3677
3676: oReturn
3677: oLocalSpace 0
3679: oTypeSNodeType
3680: oChoice 3698
3682: oEmit 14
3684: oJumpForward 3711
3686: oEmit 15
3688: oJumpForward 3711
3690: oError 16
3692: oJumpForward 3711
3694: oEmit 16
3696: oJumpForward 3711
3698: Choice Lookup Table
          23   3694
          17   3690
          22   3690
          21   3690
          19   3686
          18   3682
3711: oReturn
3712: oLocalSpace 0
3714: oInputChoice 3728
3716: oCall 3740
3718: oJumpForward 3737
3720: oCall 3883
3722: oJumpForward 3737
3724: oCall 3981
3726: oJumpForward 3737
3728: Choice Lookup Table
          17   3724
          19   3720
          15   3716
3735: oJumpForward 3739
3737: oJumpBack 3714
3739: oReturn
3740: oLocalSpace 3
3742: oTypeSNodeType
3743: oChoice 3747
3745: oJumpForward 3752
3747: Choice Lookup Table
          24   3745
3750: oError 10
3752: oTypeSNodeType
3753: oChoice 3757
3755: oJumpForward 3762
3757: Choice Lookup Table
          24   3755
3760: oError 13
3762: oGetAddrLocal 1
3764: oPushResult
3765: oTypeSTop
3766: oPushResult
3767: oSetResult 20
3769: oPushResult
3770: oNodeGet
3771: oPop 2
3773: oPushResult
3774: oCall 5824
3776: oPop 1
3778: oAssign
3779: oGetAddrLocal 2
3781: oPushResult
3782: oTypeSTop
3783: oPushResult
3784: oSetResult 19
3786: oPushResult
3787: oNodeGet
3788: oPop 2
3790: oAssign
3791: oTypeSPop
3792: oGetLocal 2
3794: oPushResult
3795: oTypeSPush
3796: oPop 1
3798: oCall 2040
3800: oCall 5624
3802: oGetLocal 1
3804: oPushResult
3805: equal_zero
3806: oPop 1
3808: oChoice 3822
3810: oEmit 9
3812: oGetLocal 1
3814: oPushResult
3815: oEmitInt
3816: oPop 1
3818: oEmit 27
3820: oJumpForward 3825
3822: Choice Lookup Table
           0   3810
3825: oGetAddrLocal 3
3827: oPushResult
3828: oGetLocal 2
3830: oPushResult
3831: oSetResult 2
3833: oPushResult
3834: oNodeGetInt
3835: oPop 2
3837: oAssign
3838: oGetLocal 3
3840: oPushResult
3841: oSetResult 1
3843: oPushResult
3844: equal
3845: oPop 2
3847: oChoice 3861
3849: oEmit 9
3851: oGetLocal 3
3853: oPushResult
3854: oEmitInt
3855: oPop 1
3857: oEmit 23
3859: oJumpForward 3864
3861: Choice Lookup Table
           0   3849
3864: oEmit 25
3866: oInputChoice 3874
3868: oJumpForward 3882
3870: oJumpForward 3880
3872: oJumpForward 3880
3874: Choice Lookup Table
          12   3872
          16   3868
3879: oEndChoice
3880: oJumpBack 3752
3882: oReturn
3883: oLocalSpace 2
3885: oTypeSNodeType
3886: oChoice 3890
3888: oJumpForward 3895
3890: Choice Lookup Table
          26   3888
3893: oError 11
3895: oTypeSTop
3896: oPushResult
3897: oSetResult 23
3899: oPushResult
3900: oNodeGet
3901: oPop 2
3903: oPushResult
3904: oScopeEnter
3905: oPop 1
3907: oInput 0
3909: oGetAddrLocal 1
3911: oPushResult
3912: oScopeFindRequire
3913: oAssign
3914: oGetLocal 1
3916: oPushResult
3917: oNodeType
3918: oPop 1
3920: oChoice 3924
3922: oJumpForward 3929
3924: Choice Lookup Table
          14   3922
3927: oError 12
3929: oScopeEnd
3930: oGetAddrLocal 2
3932: oPushResult
3933: oGetLocal 1
3935: oPushResult
3936: oSetResult 6
3938: oPushResult
3939: oNodeGetInt
3940: oPop 2
3942: oAssign
3943: oGetLocal 2
3945: oPushResult
3946: equal_zero
3947: oPop 1
3949: oChoice 3963
3951: oEmit 9
3953: oGetLocal 2
3955: oPushResult
3956: oEmitInt
3957: oPop 1
3959: oEmit 25
3961: oJumpForward 3966
3963: Choice Lookup Table
           0   3951
3966: oTypeSPop
3967: oGetLocal 1
3969: oPushResult
3970: oSetResult 5
3972: oPushResult
3973: oNodeGet
3974: oPop 2
3976: oPushResult
3977: oTypeSPush
3978: oPop 1
3980: oReturn
3981: oLocalSpace 1
3983: oTypeSNodeType
3984: oChoice 3988
3986: oJumpForward 3993
3988: Choice Lookup Table
          23   3986
3991: oError 9
3993: oEmit 16
3995: oGetAddrLocal 1
3997: oPushResult
3998: oTypeSTop
3999: oAssign
4000: oTypeSPop
4001: oGetLocal 1
4003: oPushResult
4004: oSetResult 19
4006: oPushResult
4007: oNodeGet
4008: oPop 2
4010: oPushResult
4011: oTypeSPush
4012: oPop 1
4014: oReturn
4015: oLocalSpace 0
4017: oCall 5598
4019: oReturn
4020: oLocalSpace 10
4022: oGetParam 1
4024: oPushResult
4025: oSetResult 11
4027: oPushResult
4028: oNodeGetBoolean
4029: oPop 2
4031: oChoice 4083
4033: oGetParam 1
4035: oPushResult
4036: oSetResult 13
4038: oPushResult
4039: oNodeGetBoolean
4040: oPop 2
4042: oChoice 4078
4044: oGetAddrLocal 1
4046: oPushResult
4047: oGetParam 1
4049: oPushResult
4050: oSetResult 4
4052: oPushResult
4053: oNodeGetInt
4054: oPop 2
4056: oPushResult
4057: oStringAllocLitFromIdent
4058: oPop 1
4060: oAssign
4061: oEmit 50
4063: oGetParam 1
4065: oPushResult
4066: oCall 5875
4068: oPop 1
4070: oGetLocal 1
4072: oPushResult
4073: oEmitInt
4074: oPop 1
4076: oJumpForward 4081
4078: Choice Lookup Table
           0   4044
4081: oJumpForward 4086
4083: Choice Lookup Table
           1   4033
4086: oGetParam 1
4088: oPushResult
4089: oSetResult 13
4091: oPushResult
4092: oSetResult 1
4094: oPushResult
4095: oNodeSetBoolean
4096: oPop 3
4098: oGetAddrLocal 2
4100: oPushResult
4101: oGetParam 1
4103: oPushResult
4104: oSetResult 12
4106: oPushResult
4107: oNodeGetBoolean
4108: oPop 2
4110: oAssign
4111: oGetAddrLocal 5
4113: oPushResult
4114: oGetParam 1
4116: oPushResult
4117: oNodeType
4118: oPop 1
4120: oPushResult
4121: oSetResult 8
4123: oPushResult
4124: equal_node_type
4125: oPop 2
4127: oAssign
4128: oGetLocal 5
4130: oChoice 4157
4132: oGetAddrLocal 3
4134: oPushResult
4135: oGetParam 1
4137: oPushResult
4138: oSetResult 5
4140: oPushResult
4141: oNodeGet
4142: oPop 2
4144: oAssign
4145: oGetAddrLocal 4
4147: oPushResult
4148: oGetLocal 3
4150: oPushResult
4151: oScopeAllocType
4152: oPop 1
4154: oAssign
4155: oJumpForward 4160
4157: Choice Lookup Table
           1   4132
4160: oGetAddrLocal 6
4162: oPushResult
4163: oGetParam 1
4165: oPushResult
4166: oSetResult 8
4168: oPushResult
4169: oNodeGet
4170: oPop 2
4172: oAssign
4173: oGetAddrLocal 7
4175: oPushResult
4176: oGetLocal 6
4178: oPushResult
4179: oSetResult 2
4181: oPushResult
4182: oNodeGetInt
4183: oPop 2
4185: oAssign
4186: oGetLocal 2
4188: oChoice 4210
4190: oEmit 39
4192: oGetLocal 7
4194: oPushResult
4195: oEmitInt
4196: oPop 1
4198: oJumpForward 4216
4200: oEmit 38
4202: oGetLocal 7
4204: oPushResult
4205: oEmitInt
4206: oPop 1
4208: oJumpForward 4216
4210: Choice Lookup Table
           0   4200
           1   4190
4215: oEndChoice
4216: oGetAddrLocal 8
4218: oPushResult
4219: oGetLocal 6
4221: oPushResult
4222: oSetResult 1
4224: oPushResult
4225: oNodeGet
4226: oPop 2
4228: oAssign
4229: oInputChoice 4398
4231: oGetLocal 8
4233: oPushResult
4234: oNodeNull
4235: oPop 1
4237: oChoice 4243
4239: oJumpForward 4394
4241: oJumpForward 4246
4243: Choice Lookup Table
           1   4239
4246: oGetAddrLocal 9
4248: oPushResult
4249: oGetLocal 8
4251: oPushResult
4252: oSetResult 6
4254: oPushResult
4255: oNodeGetInt
4256: oPop 2
4258: oAssign
4259: oEmit 13
4261: oGetLocal 9
4263: oPushResult
4264: oEmitInt
4265: oPop 1
4267: oGetLocal 8
4269: oPushResult
4270: oSetResult 5
4272: oPushResult
4273: oNodeGet
4274: oPop 2
4276: oPushResult
4277: oTypeSPush
4278: oPop 1
4280: oGetLocal 8
4282: oPushResult
4283: oSetResult 17
4285: oPushResult
4286: oNodeGetBoolean
4287: oPop 2
4289: oChoice 4357
4291: oCall 4881
4293: oCall 5598
4295: oEmit 19
4297: oJumpForward 4363
4299: oCall 2040
4301: oCall 4015
4303: oTypeSNodeType
4304: oChoice 4322
4306: oEmit 17
4308: oJumpForward 4355
4310: oEmit 18
4312: oJumpForward 4355
4314: oError 16
4316: oJumpForward 4355
4318: oEmit 19
4320: oJumpForward 4355
4322: Choice Lookup Table
          23   4318
          17   4314
          22   4314
          21   4314
          19   4310
          18   4306
4335: oGetAddrLocal 10
4337: oPushResult
4338: oTypeSTop
4339: oPushResult
4340: oSetResult 2
4342: oPushResult
4343: oNodeGetInt
4344: oPop 2
4346: oAssign
4347: oEmit 20
4349: oGetLocal 10
4351: oPushResult
4352: oEmitInt
4353: oPop 1
4355: oJumpForward 4363
4357: Choice Lookup Table
           0   4299
           1   4291
4362: oEndChoice
4363: oTypeSPop
4364: oGetAddrLocal 8
4366: oPushResult
4367: oNodeNext
4368: oPop 1
4370: oGetLocal 8
4372: oPushResult
4373: oNodeNull
4374: oPop 1
4376: oChoice 4384
4378: oJumpForward 4394
4380: oJumpForward 4390
4382: oJumpForward 4390
4384: Choice Lookup Table
           0   4382
           1   4378
4389: oEndChoice
4390: oInput 12
4392: oJumpBack 4231
4394: oInput 14
4396: oJumpForward 4401
4398: Choice Lookup Table
          13   4231
4401: oGetLocal 8
4403: oPushResult
4404: oNodeNull
4405: oPop 1
4407: oChoice 4413
4409: oError 15
4411: oJumpForward 4416
4413: Choice Lookup Table
           0   4409
4416: oGetLocal 5
4418: oChoice 4447
4420: oEmit 13
4422: oGetParam 1
4424: oPushResult
4425: oSetResult 16
4427: oPushResult
4428: oNodeGetInt
4429: oPop 2
4431: oPushResult
4432: oEmitInt
4433: oPop 1
4435: oEmit 11
4437: oGetLocal 4
4439: oPushResult
4440: oEmitInt
4441: oPop 1
4443: oEmit 19
4445: oJumpForward 4450
4447: Choice Lookup Table
           1   4420
4450: oGetLocal 2
4452: oChoice 4476
4454: oEmit 42
4456: oGetParam 1
4458: oPushResult
4459: oCall 5875
4461: oPop 1
4463: oJumpForward 4482
4465: oEmit 41
4467: oGetParam 1
4469: oPushResult
4470: oCall 5875
4472: oPop 1
4474: oJumpForward 4482
4476: Choice Lookup Table
           0   4465
           1   4454
4481: oEndChoice
4482: oGetLocal 5
4484: oChoice 4552
4486: oGetLocal 3
4488: oPushResult
4489: oTypeSPush
4490: oPop 1
4492: oTypeSNodeType
4493: oChoice 4529
4495: oEmit 3
4497: oGetLocal 4
4499: oPushResult
4500: oEmitInt
4501: oPop 1
4503: oJumpForward 4550
4505: oEmit 4
4507: oGetLocal 4
4509: oPushResult
4510: oEmitInt
4511: oPop 1
4513: oJumpForward 4550
4515: oError 16
4517: oJumpForward 4550
4519: oEmit 5
4521: oGetLocal 4
4523: oPushResult
4524: oEmitInt
4525: oPop 1
4527: oJumpForward 4550
4529: Choice Lookup Table
          23   4519
          17   4515
          22   4515
          21   4515
          19   4505
          18   4495
4542: oEmit 11
4544: oGetLocal 4
4546: oPushResult
4547: oEmitInt
4548: oPop 1
4550: oJumpForward 4555
4552: Choice Lookup Table
           1   4486
4555: oEmit 40
4557: oGetLocal 7
4559: oPushResult
4560: oEmitInt
4561: oPop 1
4563: oReturn
4564: oLocalSpace 0
4566: oInputChoice 4616
4568: oCall 5518
4570: oJumpForward 4641
4572: oCall 5525
4574: oJumpForward 4641
4576: oCall 5592
4578: oJumpForward 4641
4580: oCall 5595
4582: oJumpForward 4641
4584: oCall 5058
4586: oJumpForward 4641
4588: oCall 5378
4590: oJumpForward 4641
4592: oCall 5124
4594: oJumpForward 4641
4596: oCall 5298
4598: oJumpForward 4641
4600: oCall 5463
4602: oJumpForward 4641
4604: oCall 5431
4606: oJumpForward 4641
4608: oCall 5495
4610: oJumpForward 4641
4612: oCall 4642
4614: oJumpForward 4641
4616: Choice Lookup Table
           0   4612
          33   4608
          49   4604
          50   4600
          47   4596
          42   4592
          46   4588
          39   4584
          57   4580
          56   4576
          55   4572
          54   4568
4641: oReturn
4642: oLocalSpace 1
4644: oGetAddrLocal 1
4646: oPushResult
4647: oScopeFindRequire
4648: oAssign
4649: oGetLocal 1
4651: oPushResult
4652: oNodeType
4653: oPop 1
4655: oChoice 4684
4657: oGetLocal 1
4659: oPushResult
4660: oCall 4020
4662: oPop 1
4664: oJumpForward 4697
4666: oGetLocal 1
4668: oPushResult
4669: oCall 4698
4671: oPop 1
4673: oJumpForward 4697
4675: oGetLocal 1
4677: oPushResult
4678: oCall 4767
4680: oPop 1
4682: oJumpForward 4697
4684: Choice Lookup Table
           8   4675
          15   4666
          13   4666
          12   4666
           7   4657
4695: oError 0
4697: oReturn
4698: oLocalSpace 1
4700: oGetParam 1
4702: oPushResult
4703: oCall 4917
4705: oPop 1
4707: oInput 3
4709: oCall 2040
4711: oCall 5598
4713: oTypeSNodeType
4714: oChoice 4732
4716: oEmit 17
4718: oJumpForward 4765
4720: oEmit 18
4722: oJumpForward 4765
4724: oError 16
4726: oJumpForward 4765
4728: oEmit 19
4730: oJumpForward 4765
4732: Choice Lookup Table
          23   4728
          17   4724
          22   4724
          21   4724
          19   4720
          18   4716
4745: oGetAddrLocal 1
4747: oPushResult
4748: oTypeSTop
4749: oPushResult
4750: oSetResult 2
4752: oPushResult
4753: oNodeGetInt
4754: oPop 2
4756: oAssign
4757: oEmit 20
4759: oGetLocal 1
4761: oPushResult
4762: oEmitInt
4763: oPop 1
4765: oTypeSPop
4766: oReturn
4767: oLocalSpace 1
4769: oGetParam 1
4771: oPushResult
4772: oSetResult 9
4774: oPushResult
4775: oNodeGet
4776: oPop 2
4778: oPushResult
4779: oScopeCurrent
4780: oPushResult
4781: oNodeEqual
4782: oPop 2
4784: oChoice 4790
4786: oError 20
4788: oJumpForward 4793
4790: Choice Lookup Table
           0   4786
4793: oEmit 8
4795: oGetParam 1
4797: oPushResult
4798: oSetResult 16
4800: oPushResult
4801: oNodeGetInt
4802: oPop 2
4804: oPushResult
4805: oEmitInt
4806: oPop 1
4808: oGetParam 1
4810: oPushResult
4811: oSetResult 5
4813: oPushResult
4814: oNodeGet
4815: oPop 2
4817: oPushResult
4818: oTypeSPush
4819: oPop 1
4821: oInput 3
4823: oCall 2040
4825: oCall 5598
4827: oTypeSNodeType
4828: oChoice 4846
4830: oEmit 17
4832: oJumpForward 4879
4834: oEmit 18
4836: oJumpForward 4879
4838: oError 16
4840: oJumpForward 4879
4842: oEmit 19
4844: oJumpForward 4879
4846: Choice Lookup Table
          23   4842
          17   4838
          22   4838
          21   4838
          19   4834
          18   4830
4859: oGetAddrLocal 1
4861: oPushResult
4862: oTypeSTop
4863: oPushResult
4864: oSetResult 2
4866: oPushResult
4867: oNodeGetInt
4868: oPop 2
4870: oAssign
4871: oEmit 20
4873: oGetLocal 1
4875: oPushResult
4876: oEmitInt
4877: oPop 1
4879: oTypeSPop
4880: oReturn
4881: oLocalSpace 1
4883: oInput 0
4885: oGetAddrLocal 1
4887: oPushResult
4888: oScopeFindRequire
4889: oAssign
4890: oGetLocal 1
4892: oPushResult
4893: oNodeType
4894: oPop 1
4896: oChoice 4900
4898: oJumpForward 4909
4900: Choice Lookup Table
          15   4898
          13   4898
          12   4898
4907: oError 4
4909: oGetLocal 1
4911: oPushResult
4912: oCall 4917
4914: oPop 1
4916: oReturn
4917: oLocalSpace 0
4919: oGetParam 1
4921: oPushResult
4922: oNodeType
4923: oPop 1
4925: oChoice 4985
4927: oEmit 10
4929: oGetParam 1
4931: oPushResult
4932: oCall 5875
4934: oPop 1
4936: oJumpForward 4994
4938: oEmit 11
4940: oGetParam 1
4942: oPushResult
4943: oCall 5875
4945: oPop 1
4947: oJumpForward 4994
4949: oGetParam 1
4951: oPushResult
4952: oSetResult 17
4954: oPushResult
4955: oNodeGetBoolean
4956: oPop 2
4958: oChoice 4971
4960: oEmit 8
4962: oGetParam 1
4964: oPushResult
4965: oCall 5875
4967: oPop 1
4969: oJumpForward 4983
4971: Choice Lookup Table
           1   4960
4974: oEmit 12
4976: oGetParam 1
4978: oPushResult
4979: oCall 5875
4981: oPop 1
4983: oJumpForward 4994
4985: Choice Lookup Table
          15   4949
          13   4938
          12   4927
4992: oError 4
4994: oGetParam 1
4996: oPushResult
4997: oSetResult 5
4999: oPushResult
5000: oNodeGet
5001: oPop 2
5003: oPushResult
5004: oTypeSPush
5005: oPop 1
5007: oCall 3712
5009: oReturn
5010: oLocalSpace 0
5012: oGetParam 1
5014: oPushResult
5015: oCall 4917
5017: oPop 1
5019: oCall 5624
5021: oGetParam 1
5023: oPushResult
5024: oCall 3298
5026: oPop 1
5028: oTypeSPop
5029: oEmit 21
5031: oEmit 17
5033: oReturn
5034: oLocalSpace 0
5036: oGetParam 1
5038: oPushResult
5039: oCall 4917
5041: oPop 1
5043: oCall 5624
5045: oGetParam 1
5047: oPushResult
5048: oCall 3298
5050: oPop 1
5052: oTypeSPop
5053: oEmit 22
5055: oEmit 17
5057: oReturn
5058: oLocalSpace 2
5060: oGetAddrLocal 1
5062: oPushResult
5063: oSetResult 0
5065: oAssign
5066: oGetAddrLocal 1
5068: oPushResult
5069: oCall 2063
5071: oPop 1
5073: oInput 40
5075: oCall 4564
5077: oInputChoice 5112
5079: oGetAddrLocal 2
5081: oPushResult
5082: oLabelNew
5083: oAssign
5084: oEmit 45
5086: oGetLocal 2
5088: oPushResult
5089: oEmitLabel
5090: oPop 1
5092: oEmit 48
5094: oGetLocal 1
5096: oPushResult
5097: oEmitLabel
5098: oPop 1
5100: oCall 4564
5102: oEmit 48
5104: oGetLocal 2
5106: oPushResult
5107: oEmitLabel
5108: oPop 1
5110: oJumpForward 5123
5112: Choice Lookup Table
          41   5079
5115: oEmit 48
5117: oGetLocal 1
5119: oPushResult
5120: oEmitLabel
5121: oPop 1
5123: oReturn
5124: oLocalSpace 4
5126: oInput 0
5128: oGetAddrLocal 1
5130: oPushResult
5131: oScopeFindRequire
5132: oAssign
5133: oGetLocal 1
5135: oPushResult
5136: oCall 4917
5138: oPop 1
5140: oCall 5624
5142: oInput 3
5144: oCall 2040
5146: oCall 5624
5148: oEmit 17
5150: oGetAddrLocal 2
5152: oPushResult
5153: oLabelNew
5154: oAssign
5155: oGetAddrLocal 3
5157: oPushResult
5158: oLabelNew
5159: oAssign
5160: oEmit 45
5162: oGetLocal 3
5164: oPushResult
5165: oEmitLabel
5166: oPop 1
5168: oGetAddrLocal 4
5170: oPushResult
5171: oLabelNew
5172: oAssign
5173: oEmit 48
5175: oGetLocal 4
5177: oPushResult
5178: oEmitLabel
5179: oPop 1
5181: oInputChoice 5261
5183: oGetLocal 1
5185: oPushResult
5186: oCall 5010
5188: oPop 1
5190: oEmit 48
5192: oGetLocal 3
5194: oPushResult
5195: oEmitLabel
5196: oPop 1
5198: oGetLocal 1
5200: oPushResult
5201: oCall 3298
5203: oPop 1
5205: oTypeSPop
5206: oCall 2040
5208: oCall 5624
5210: oEmit 32
5212: oEmit 46
5214: oGetLocal 2
5216: oPushResult
5217: oEmitLabel
5218: oPop 1
5220: oJumpForward 5267
5222: oGetLocal 1
5224: oPushResult
5225: oCall 5034
5227: oPop 1
5229: oEmit 48
5231: oGetLocal 3
5233: oPushResult
5234: oEmitLabel
5235: oPop 1
5237: oGetLocal 1
5239: oPushResult
5240: oCall 3298
5242: oPop 1
5244: oTypeSPop
5245: oCall 2040
5247: oCall 5624
5249: oEmit 33
5251: oEmit 46
5253: oGetLocal 2
5255: oPushResult
5256: oEmitLabel
5257: oPop 1
5259: oJumpForward 5267
5261: Choice Lookup Table
          44   5222
          43   5183
5266: oEndChoice
5267: oGetLocal 4
5269: oPushResult
5270: oGetLocal 2
5272: oPushResult
5273: oLoopPush
5274: oPop 2
5276: oInput 45
5278: oCall 4564
5280: oEmit 45
5282: oGetLocal 4
5284: oPushResult
5285: oEmitLabel
5286: oPop 1
5288: oEmit 48
5290: oGetLocal 2
5292: oPushResult
5293: oEmitLabel
5294: oPop 1
5296: oLoopPop
5297: oReturn
5298: oLocalSpace 3
5300: oGetAddrLocal 1
5302: oPushResult
5303: oLabelNew
5304: oAssign
5305: oEmit 48
5307: oGetLocal 1
5309: oPushResult
5310: oEmitLabel
5311: oPop 1
5313: oGetAddrLocal 2
5315: oPushResult
5316: oLabelNew
5317: oAssign
5318: oGetLocal 1
5320: oPushResult
5321: oGetLocal 2
5323: oPushResult
5324: oLoopPush
5325: oPop 2
5327: oCall 4564
5329: oInputChoice 5360
5331: oCall 4564
5333: oJumpForward 5366
5335: oGetAddrLocal 3
5337: oPushResult
5338: oCall 2063
5340: oPop 1
5342: oEmit 49
5344: oGetLocal 3
5346: oPushResult
5347: oEmitLabel
5348: oPop 1
5350: oGetLocal 1
5352: oPushResult
5353: oEmitLabel
5354: oPop 1
5356: oJumpForward 5368
5358: oJumpForward 5366
5360: Choice Lookup Table
          48   5335
           4   5331
5365: oEndChoice
5366: oJumpBack 5329
5368: oEmit 48
5370: oGetLocal 2
5372: oPushResult
5373: oEmitLabel
5374: oPop 1
5376: oLoopPop
5377: oReturn
5378: oLocalSpace 2
5380: oGetAddrLocal 1
5382: oPushResult
5383: oLabelNew
5384: oAssign
5385: oEmit 48
5387: oGetLocal 1
5389: oPushResult
5390: oEmitLabel
5391: oPop 1
5393: oGetAddrLocal 2
5395: oPushResult
5396: oCall 2063
5398: oPop 1
5400: oGetLocal 1
5402: oPushResult
5403: oGetLocal 2
5405: oPushResult
5406: oLoopPush
5407: oPop 2
5409: oInput 45
5411: oCall 4564
5413: oEmit 45
5415: oGetLocal 1
5417: oPushResult
5418: oEmitLabel
5419: oPop 1
5421: oEmit 48
5423: oGetLocal 2
5425: oPushResult
5426: oEmitLabel
5427: oPop 1
5429: oLoopPop
5430: oReturn
5431: oLocalSpace 0
5433: oLoopContinueLabel
5434: oPushResult
5435: oSetResult 0
5437: oPushResult
5438: equal_label
5439: oPop 2
5441: oChoice 5456
5443: oError 18
5445: oJumpForward 5462
5447: oEmit 45
5449: oLoopContinueLabel
5450: oPushResult
5451: oEmitLabel
5452: oPop 1
5454: oJumpForward 5462
5456: Choice Lookup Table
           0   5447
           1   5443
5461: oEndChoice
5462: oReturn
5463: oLocalSpace 0
5465: oLoopBreakLabel
5466: oPushResult
5467: oSetResult 0
5469: oPushResult
5470: equal_label
5471: oPop 2
5473: oChoice 5488
5475: oError 18
5477: oJumpForward 5494
5479: oEmit 45
5481: oLoopBreakLabel
5482: oPushResult
5483: oEmitLabel
5484: oPop 1
5486: oJumpForward 5494
5488: Choice Lookup Table
           0   5479
           1   5475
5493: oEndChoice
5494: oReturn
5495: oLocalSpace 0
5497: oCall 4564
5499: oInputChoice 5509
5501: oCall 4564
5503: oJumpForward 5515
5505: oJumpForward 5517
5507: oJumpForward 5515
5509: Choice Lookup Table
          34   5505
           4   5501
5514: oEndChoice
5515: oJumpBack 5499
5517: oReturn
5518: oLocalSpace 0
5520: oCall 5525
5522: oEmit 55
5524: oReturn
5525: oLocalSpace 0
5527: oInputChoice 5588
5529: oCall 2040
5531: oTypeSNodeType
5532: oChoice 5554
5534: oEmit 51
5536: oJumpForward 5569
5538: oEmit 52
5540: oJumpForward 5569
5542: oEmit 53
5544: oJumpForward 5569
5546: oError 16
5548: oJumpForward 5569
5550: oEmit 54
5552: oJumpForward 5569
5554: Choice Lookup Table
          23   5550
          17   5546
          21   5546
          22   5542
          19   5538
          18   5534
5567: oError 17
5569: oTypeSPop
5570: oInputChoice 5578
5572: oJumpForward 5586
5574: oJumpForward 5584
5576: oJumpForward 5584
5578: Choice Lookup Table
          12   5576
          14   5572
5583: oEndChoice
5584: oJumpBack 5529
5586: oJumpForward 5591
5588: Choice Lookup Table
          13   5529
5591: oReturn
5592: oLocalSpace 0
5594: oReturn
5595: oLocalSpace 0
5597: oReturn
5598: oLocalSpace 1
5600: oGetAddrLocal 1
5602: oPushResult
5603: oTypeSNodeType
5604: oAssign
5605: oTypeSPop
5606: oGetLocal 1
5608: oPushResult
5609: oTypeSNodeType
5610: oPushResult
5611: equal_node_type
5612: oPop 2
5614: oChoice 5620
5616: oError 14
5618: oJumpForward 5623
5620: Choice Lookup Table
           0   5616
5623: oReturn
5624: oLocalSpace 0
5626: oTypeSNodeType
5627: oChoice 5631
5629: oJumpForward 5636
5631: Choice Lookup Table
          18   5629
5634: oError 7
5636: oTypeSPop
5637: oReturn
5638: oLocalSpace 0
5640: oTypeSNodeType
5641: oChoice 5645
5643: oJumpForward 5650
5645: Choice Lookup Table
          18   5643
5648: oError 7
5650: oReturn
5651: oLocalSpace 0
5653: oTypeSNodeType
5654: oChoice 5658
5656: oJumpForward 5663
5658: Choice Lookup Table
          19   5656
5661: oError 8
5663: oTypeSPop
5664: oReturn
5665: oLocalSpace 0
5667: oTypeSNodeType
5668: oChoice 5672
5670: oJumpForward 5677
5672: Choice Lookup Table
          19   5670
5675: oError 8
5677: oReturn
5678: oLocalSpace 1
5680: oGetAddrLocal 1
5682: oPushResult
5683: oGetParam 2
5685: oPushResult
5686: oNodeNew
5687: oPop 1
5689: oAssign
5690: oGetLocal 1
5692: oPushResult
5693: oSetResult 2
5695: oPushResult
5696: oGetParam 1
5698: oPushResult
5699: oNodeSetInt
5700: oPop 3
5702: oGetLocal 1
5704: oPushResult
5705: oTypeAdd
5706: oPop 1
5708: oGetLocal 1
5710: oReturn
5711: oReturn
5712: oLocalSpace 1
5714: oGetAddrLocal 1
5716: oPushResult
5717: oGetParam 3
5719: oPushResult
5720: oNodeNew
5721: oPop 1
5723: oAssign
5724: oGetLocal 1
5726: oPushResult
5727: oSetResult 4
5729: oPushResult
5730: oGetParam 1
5732: oPushResult
5733: oNodeSetInt
5734: oPop 3
5736: oGetLocal 1
5738: oReturn
5739: oReturn
5740: oLocalSpace 1
5742: oGetAddrLocal 1
5744: oPushResult
5745: oGetParam 1
5747: oPushResult
5748: oSetResult 18
5750: oPushResult
5751: oNodeGet
5752: oPop 2
5754: oAssign
5755: oGetLocal 1
5757: oPushResult
5758: oNodeNull
5759: oPop 1
5761: oChoice 5817
5763: oGetAddrLocal 1
5765: oPushResult
5766: oSetResult 23
5768: oPushResult
5769: oNodeNew
5770: oPop 1
5772: oAssign
5773: oGetLocal 1
5775: oPushResult
5776: oSetResult 19
5778: oPushResult
5779: oGetParam 1
5781: oPushResult
5782: oNodeSet
5783: oPop 3
5785: oGetLocal 1
5787: oPushResult
5788: oSetResult 2
5790: oPushResult
5791: oSetResult 8
5793: oPushResult
5794: oNodeSetInt
5795: oPop 3
5797: oGetLocal 1
5799: oPushResult
5800: oTypeAdd
5801: oPop 1
5803: oGetParam 1
5805: oPushResult
5806: oSetResult 18
5808: oPushResult
5809: oGetLocal 1
5811: oPushResult
5812: oNodeSet
5813: oPop 3
5815: oJumpForward 5820
5817: Choice Lookup Table
           1   5763
5820: oGetLocal 1
5822: oReturn
5823: oReturn
5824: oLocalSpace 0
5826: oGetParam 1
5828: oPushResult
5829: oNodeType
5830: oPop 1
5832: oChoice 5860
5834: oMININT
5835: oReturn
5836: oJumpForward 5874
5838: oSetResult 0
5840: oReturn
5841: oJumpForward 5874
5843: oSetResult 0
5845: oReturn
5846: oJumpForward 5874
5848: oGetParam 1
5850: oPushResult
5851: oSetResult 21
5853: oPushResult
5854: oNodeGetInt
5855: oPop 2
5857: oReturn
5858: oJumpForward 5874
5860: Choice Lookup Table
          25   5848
          21   5843
          19   5838
          18   5834
5869: oError 3
5871: oSetResult 0
5873: oReturn
5874: oReturn
5875: oLocalSpace 0
5877: oGetParam 1
5879: oPushResult
5880: oSetResult 6
5882: oPushResult
5883: oNodeGetInt
5884: oPop 2
5886: oPushResult
5887: oEmitInt
5888: oPop 1
5890: oReturn
5891: oLocalSpace 1
5893: oGetAddrGlobal 2
5895: oPushResult
5896: oSetResult 17
5898: oPushResult
5899: oSetResult 4
5901: oPushResult
5902: oCall 5678
5904: oPop 2
5906: oAssign
5907: oGetAddrGlobal 3
5909: oPushResult
5910: oSetResult 18
5912: oPushResult
5913: oSetResult 4
5915: oPushResult
5916: oCall 5678
5918: oPop 2
5920: oAssign
5921: oGetAddrGlobal 4
5923: oPushResult
5924: oSetResult 19
5926: oPushResult
5927: oSetResult 1
5929: oPushResult
5930: oCall 5678
5932: oPop 2
5934: oAssign
5935: oGetAddrGlobal 5
5937: oPushResult
5938: oSetResult 20
5940: oPushResult
5941: oSetResult 1
5943: oPushResult
5944: oCall 5678
5946: oPop 2
5948: oAssign
5949: oGetAddrGlobal 6
5951: oPushResult
5952: oSetResult 21
5954: oPushResult
5955: oSetResult 1
5957: oPushResult
5958: oCall 5678
5960: oPop 2
5962: oAssign
5963: oGetAddrGlobal 7
5965: oPushResult
5966: oSetResult 22
5968: oPushResult
5969: oSetResult 256
5971: oPushResult
5972: oCall 5678
5974: oPop 2
5976: oAssign
5977: oGetAddrLocal 1
5979: oPushResult
5980: oSetResult 10
5982: oPushResult
5983: oSetResult 5
5985: oPushResult
5986: oIdAdd_File
5987: oPushResult
5988: oCall 5712
5990: oPop 3
5992: oAssign
5993: oGetLocal 1
5995: oPushResult
5996: oSetResult 5
5998: oPushResult
5999: oGetGlobal 2
6001: oPushResult
6002: oNodeSet
6003: oPop 3
6005: oGetLocal 1
6007: oPushResult
6008: oScopeDeclare
6009: oPop 1
6011: oGetAddrLocal 1
6013: oPushResult
6014: oSetResult 10
6016: oPushResult
6017: oSetResult 5
6019: oPushResult
6020: oIdAdd_Integer
6021: oPushResult
6022: oCall 5712
6024: oPop 3
6026: oAssign
6027: oGetLocal 1
6029: oPushResult
6030: oSetResult 5
6032: oPushResult
6033: oGetGlobal 3
6035: oPushResult
6036: oNodeSet
6037: oPop 3
6039: oGetLocal 1
6041: oPushResult
6042: oScopeDeclare
6043: oPop 1
6045: oGetAddrLocal 1
6047: oPushResult
6048: oSetResult 10
6050: oPushResult
6051: oSetResult 5
6053: oPushResult
6054: oIdAdd_Boolean
6055: oPushResult
6056: oCall 5712
6058: oPop 3
6060: oAssign
6061: oGetLocal 1
6063: oPushResult
6064: oSetResult 5
6066: oPushResult
6067: oGetGlobal 4
6069: oPushResult
6070: oNodeSet
6071: oPop 3
6073: oGetLocal 1
6075: oPushResult
6076: oScopeDeclare
6077: oPop 1
6079: oGetAddrLocal 1
6081: oPushResult
6082: oSetResult 10
6084: oPushResult
6085: oSetResult 5
6087: oPushResult
6088: oIdAdd_Char
6089: oPushResult
6090: oCall 5712
6092: oPop 3
6094: oAssign
6095: oGetLocal 1
6097: oPushResult
6098: oSetResult 5
6100: oPushResult
6101: oGetGlobal 6
6103: oPushResult
6104: oNodeSet
6105: oPop 3
6107: oGetLocal 1
6109: oPushResult
6110: oScopeDeclare
6111: oPop 1
6113: oGetAddrLocal 1
6115: oPushResult
6116: oSetResult 10
6118: oPushResult
6119: oSetResult 5
6121: oPushResult
6122: oIdAdd_String
6123: oPushResult
6124: oCall 5712
6126: oPop 3
6128: oAssign
6129: oGetLocal 1
6131: oPushResult
6132: oSetResult 5
6134: oPushResult
6135: oGetGlobal 7
6137: oPushResult
6138: oNodeSet
6139: oPop 3
6141: oGetLocal 1
6143: oPushResult
6144: oScopeDeclare
6145: oPop 1
6147: oGetAddrLocal 1
6149: oPushResult
6150: oSetResult 9
6152: oPushResult
6153: oSetResult 4
6155: oPushResult
6156: oIdAdd_True
6157: oPushResult
6158: oCall 5712
6160: oPop 3
6162: oAssign
6163: oGetLocal 1
6165: oPushResult
6166: oSetResult 5
6168: oPushResult
6169: oGetGlobal 4
6171: oPushResult
6172: oNodeSet
6173: oPop 3
6175: oGetLocal 1
6177: oPushResult
6178: oSetResult 6
6180: oPushResult
6181: oSetResult 1
6183: oPushResult
6184: oNodeSetInt
6185: oPop 3
6187: oGetLocal 1
6189: oPushResult
6190: oScopeDeclare
6191: oPop 1
6193: oGetAddrLocal 1
6195: oPushResult
6196: oSetResult 9
6198: oPushResult
6199: oSetResult 4
6201: oPushResult
6202: oIdAdd_False
6203: oPushResult
6204: oCall 5712
6206: oPop 3
6208: oAssign
6209: oGetLocal 1
6211: oPushResult
6212: oSetResult 5
6214: oPushResult
6215: oGetGlobal 4
6217: oPushResult
6218: oNodeSet
6219: oPop 3
6221: oGetLocal 1
6223: oPushResult
6224: oSetResult 6
6226: oPushResult
6227: oSetResult 0
6229: oPushResult
6230: oNodeSetInt
6231: oPop 3
6233: oGetLocal 1
6235: oPushResult
6236: oScopeDeclare
6237: oPop 1
6239: oReturn
