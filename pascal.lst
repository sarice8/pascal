   2: title: 'Pascal Compiler 1.1.5 -- Jan 01 ''90';
         
      %
      %  Pascal.ssl
      %
      %  Pascal Compiler for the Amiga, by Steve Rice.
      %
      %  HISTORY
      %    11Sep89   First version, framework of parser.
      %    18Sep89   Added some semantic mechanisms.
      %    21Sep89   Added simple type references; expressions generate code.
      %    22Sep89   Allocate variable addresses as they're declared.
      %    24Sep89   Added arrays, pointers.
      %    27Sep89   Added for statement.
      %    23Oct89   Fixed for statement, so CYCLE goes to next step.
      %    01Jan90   Added string literals
      %    09Sep22   I have returned.  Migrate symbol table to schema, to ease development.
      %    01Oct22   Language: Switch from cycle/exit (Mac Pascal extension) to continue/break (Borland).
      %
      %  NOTES
      %    -  The 'value' of a var symbol is its allocated address.
      %    -  References to vars of intrinsic types, and pointer types,
      %       pushes the value of the var on the expr stack.  Referenecs to
      %       vars of compound types (arrays, records...) pushes the address
      %       on the expr stack.
      %    -  Just as there is only one type table entry for a given (named) type,
      %       there is only one type table entry for a pointer to a named type.
      %       When a pointer type is declared, a field in the TT entry of the
      %       type pointed to will be set to indicate the TT entry of the pointer
      %       to that type (0 means none defined yet).  When evaluating the
      %       expression @x, the type in that field in the entry for the type of x
      %       will be used (unless it's 0, in which case a new TT entry will be
      %       created).
      %
      %
      %  MISSING
      %
      %    - Consider non-ISO extensions.  e.g. 
      %      Dynamic arrays.  Objects.  But, perhaps stick to my old goal, standard Pascal.
      %
      %  PASCAL DOCS
      %      Here's some handy language material:
      %      https://www.freepascal.org/docs-html/ref/ref.html
      %      https://www.freepascal.org/docs-html/prog/prog.html
      %      https://en.wikipedia.org/wiki/Turbo_Pascal
      %      https://en.wikipedia.org/wiki/Pascal_(programming_language)#Standards
      %      http://www.standardpascaline.org/
      %
      
   2: input:
   2:    pIdent
   2:    pIntLit
   2:    pStrLit
   2:    pCharLit
   2:    pAssign       ':='
   2:    pSemiColon    ';'
   2:    pEqual        '='
   2:    pNotEqual     '<>'
   2:    pLess         '<'
   2:    pGreater      '>'
   2:    pLessEqual    '<='
   2:    pGreaterEqual '>='
   2:    pColon        ':'
   2:    pComma        ','
   2:    pLParen       '('
   2:    pRParen       ')'
   2:    pLSquare      '['
   2:    pRSquare      ']'
   2:    pCarat        '^'
   2:    pAt           '@'
   2:    pDot          '.'
   2:    pDotDot       '..'
   2:    pTimes        '*'
   2:    pDivide       '/'
   2:    pPlus         '+'
   2:    pMinus        '-'
   2:    pEof
   2:    pInvalid
      
      %  keywords  (built-in types 'integer', 'byte', 'char', etc, are not keywords,
      %             type constructors 'array', 'record', 'set' are keywords,
      %             pseudo-procedures 'writeln', 'readln' are keywords)
      %
      %             forward/external/name/cdecl appear in method modifiers, in fpc grammar.
      %             I'm making them keywords to simplify parsing, but could reconsider.
      
   2:    pProgram
   2:    pProcedure
   2:    pFunction
   2:    pConst
   2:    pType
   2:    pVar
   2:    pLabel
   2:    pBegin
   2:    pEnd
   2:    pArray
   2:    pRecord
   2:    pSet
   2:    pOf
   2:    pIf
   2:    pThen
   2:    pElse
   2:    pFor
   2:    pTo
   2:    pDownto
   2:    pDo
   2:    pWhile
   2:    pRepeat
   2:    pUntil
   2:    pContinue
   2:    pBreak
   2:    pCase
   2:    pOtherwise
   2:    pGoto
   2:    pAnd
   2:    pOr
   2:    pNot
   2:    pUses
   2:    pUnit
   2:    pInterface
   2:    pImplementation
   2:    pInitialization
   2:    pFinalization
   2:    pWriteln
   2:    pWrite
   2:    pReadln
   2:    pRead
      
   2:    pForward
   2:    pExternal
   2:    pName
   2:    pCdecl
   2:    ;
      
      
   2: output:
      
      %  Instructions for a stack machine (all vars are 32-bit integers)
      
   2:    tPushGlobalI      % <ptr> - push int value read from ptr
   2:    tPushGlobalB      % <ptr> - push byte value read from ptr
   2:    tPushGlobalP      % <ptr> - push ptr value read from ptr
   2:    tPushLocalI       % <offset> - push int value read from local var in current scope
   2:    tPushLocalB       % <offset> - push byte value read from local var in current scope
   2:    tPushLocalP       % <offset> - push ptr value read from local var in current scope
   2:    tPushParamI       % <offset> - push int value read from param in current scope
   2:    tPushParamB       % <offset> - push byte value read from param in current scope
   2:    tPushParamP       % <offset> - push ptr value read from param in current scope
   2:    tPushUpLocalI     % <uplevels> <offset> - push int value read from local var in a parent static scope
   2:    tPushUpLocalB     % <uplevels> <offset> - push byte value read from local var in a parent static scope
   2:    tPushUpLocalP     % <uplevels> <offset> - push ptr value read from local var in a parent static scope
   2:    tPushUpParamI     % <uplevels> <offset> - push int value read from param in a parent static scope
   2:    tPushUpParamB     % <uplevels> <offset> - push byte value read from param in a parent static scope
   2:    tPushUpParamP     % <uplevels> <offset> - push ptr value read from param in a parent static scope
   2:    tPushConstI       % <int> - push int value on stack (NOTE, used for BOOLEAN too)
   2:    tPushAddrGlobal   % <offset> - push ptr to global var (same as tPushConstP)
   2:    tPushAddrLocal    % <offset> - push ptr to local var
   2:    tPushAddrParam    % <offset> - push ptr to formal param (used by method to see its param)
   2:    tPushAddrActual   % <offset> - push ptr to actual param, in actuals space (used by caller)
   2:    tPushAddrUpLocal  % <uplevels> <offset> - push ptr to local var in a parent static scope
   2:    tPushAddrUpParam  % <uplevels> <offset> - push ptr to formal param in a parent static scope
   2:    tSwap             % swap the top two entries on the stack
   2:    tFetchI           % pop ptr from stack, and push int value it points to
   2:    tFetchB           %    "      "      "     "     byte  "   "    "
   2:    tFetchP           %    "      "      "     "     ptr   "   "    "   
   2:    tAssignI          % assign int value on top of stack to addr under it (pop both)
   2:    tAssignB          %   "    byte   "    "   "  "   "    "    "   "   "
   2:    tAssignP          %   "    ptr    "    "   "  "   "    "    "   "   "
   2:    tCopy             % <#bytes> - copy bytes.  tos=src, 2nd=dest (pop 2)
   2:    tCastBtoI         % zero-extend uint8_t to int32_t
   2:    tCastItoB         % truncate int32_t to uint8_t
   2:    tIncI             % increment int value on top of expr stack
   2:    tDecI             % decrement int value on top of expr stack
   2:    tMultI            % multiply top two integers (replacing with result)
   2:    tDivI
   2:    tAddPI            % add ptr (2nd value) and int (top value), resulting in a ptr
   2:    tAddI
   2:    tSubP
   2:    tSubPI
   2:    tSubI
   2:    tNegI             % top entry *= -1
   2:    tNot              % negate top boolean
   2:    tEqualB
   2:    tNotEqualB
   2:    tGreaterB         % B is uint8_t, so these are unsigned comparisons
   2:    tLessB
   2:    tGreaterEqualB
   2:    tLessEqualB
   2:    tEqualI           % top two entries equal? (pop 2, push 1) (true=1)
   2:    tNotEqualI        %    NOTE, these all work for booleans too, but I'm moving to tEqualB etc for those
   2:    tGreaterI         % 2nd entry greater than top entry? (pop 2, push answer)
   2:    tLessI  
   2:    tGreaterEqualI
   2:    tLessEqualI
   2:    tEqualP           % two two pointer values equal? (pop 2, push 1) (true=1)
   2:    tNotEqualP
   2:    tGreaterP
   2:    tLessP
   2:    tGreaterEqualP
   2:    tLessEqualP
   2:    tAllocActuals     % <#bytes> - make space on call stack for actual params (adjusting call stack sp)
   2:    tAllocActualsCdecl  % <#bytes> - starting a call to a cdecl method.  tcode still describes my own calling convention.
   2:    tFreeActuals      % <#bytes> - discard space on call stack allocated by tAllocActuals
   2:    tCall             % <label#>
   2:    tCallCdecl        % <label#> - call a method using native (C) calling convention. Only supported for extern labels.
   2:    tReturn
   2:    tEnter            % <#bytes> - start a stack frame on the call stack, reserving #bytes of local variable space
   2:    tJump             % <label#>
   2:    tJumpTrue         % <label#>  (pops top of stack, jumps if true)
   2:    tJumpFalse        % <label#>  (pops top of stack, jumps if false)
   2:    tJumpCaseB        % <label#>  pops uint8_t, jumps to case indicated by table at label (consisting of tCase, tCaseRange, tCaseEnd)
   2:    tJumpCaseI        % <label#>  pops integer, jumps to case indicated by table at label
   2:    tJumpCaseS        % <label#>  pops pointer to ShortString, jumps to case indicated by table at label
   2:    tCase             % <int> <label#>  - case table entry: if match int, goto label.  For tJumpCaseS, int is offset into global data.
   2:    tCaseRange        % <lowint> <highint> <label#>  - case table entry: if lowint <= value <= highint, goto label.  For tJumpCaseS, offsets into global.
   2:    tCaseEnd          % <label#> - end of case table.  Label points to no-match code (otherwise clause or end of statement).
   2:    tLabel            % <label#> - define label# at the current address
   2:    tLabelAlias       % <label#> <aliasToLabel#> - defines label to be an alias of another label
   2:    tLabelExtern      % <label#> <offsetToStrLit> - defines label to mean an extern symbol, whose name is in global data
   2:    tWriteI           % for writeln : write integer on tos, pop
   2:    tWriteBool        %  "     "    : write TRUE/FALSE, pop
   2:    tWriteChar        %  "     "    : write char, pop
   2:    tWriteShortStr    %  "     "    : write ShortString whose addr is on tos, pop
   2:    tWritePChar       %  "     "    : write a null-terminated string whose addr is on tos, pop
   2:    tWriteP           %  "     "    : write ptr var whose addr is on tos, pop
   2:    tWriteEnum        %  "     "    : write enum name.  Name table on tos, value under it, pop both
   2:    tWriteCR          %  "     "    : write cr
   2:    tFile             % <file#> - pascal source file id, for debugging.  I haven't decided yet how I will communicate the corresponding filename.
   2:    tLine             % <line#> - pascal source line number, for debugging
      
      %  Other:
      
   2:    tSpace            % emit a hole, to be patched later
   2:    ;
      
   2: error:
   2:    eBadStatement
   2:    eNotConst
   2:    eNotType
   2:    eNotOrdinalType
   2:    eNotVar
   2:    eNotIntVar
   2:    eNotValue
   2:    eNotInteger
   2:    eNotBoolean
   2:    eNotPointer
   2:    eNotArray
   2:    eNotRecord
   2:    eNotRecordField
   2:    eTooManySubscripts
   2:    eTypeMismatch
   2:    eMissingParameter
   2:    eNotImplemented
   2:    eNotAllowed
   2:    eNotInALoop
   2:    eRecordEmpty
   2:    eNotCurrentFunction
   2:    eAlreadyDefined
   2:    eOnlyOneVarCanBeInitialized
   2:    eExternalMethodCannotBeNested
   2:    eCantFindUnitFile
   2:    eInternalScopeMismatch
   2:    eEnumValueNotAscending
   2:    eUsedButNotDefined
   2:    eCantUsePredSuccOnEnumWithValueGaps
   2:    eCantDereference
   2:    ;
      
   2: include 'pascal_schema.ssl'
      
      % Generated automatically by schema
      
   2: type node_type:
   2: 	nINVALID
   2: 	Object
   2: 	nWorkspace
   2: 	nModule
   2: 	nProgram
   2: 	nUnit
   2: 	nUnitImpl
   2: 	nScope
   2: 	nDeclaration
   2: 	nIdent
   2: 	nUnitRef
   2: 	nMethod
   2: 	nProc
   2: 	nFunc
   2: 	nBuiltInFunc
   2: 	nBuiltInProc
   2: 	nConst
   2: 	nEnumValue
   2: 	nConstStr
   2: 	nTypeDecl
   2: 	nVar
   2: 	nGlobalVar
   2: 	nLocalVar
   2: 	nRecordField
   2: 	nParam
   2: 	nTypedConst
   2: 	nLabel
   2: 	nType
   2: 	nFileType
   2: 	nIntegerType
   2: 	nByteType
   2: 	nBooleanType
   2: 	nBooleanFlowType
   2: 	nCharType
   2: 	nPointerType
   2: 	nUniversalPointerType
   2: 	nArrayType
   2: 	nSubrangeType
   2: 	nRecordType
   2: 	nStrLitType
   2: 	nShortStringType
   2: 	nEnumType
   2: 	nSetType
   2: 	;
      
   2: type node_attribute:
   2: 	qINVALID
   2: 	qUnits
   2: 	qProgram
   2: 	qGlobalSize
   2: 	qIdent
   2: 	qUsedUnits
   2: 	qChildScope
   2: 	qMainRoutineScope
   2: 	qImpl
   2: 	qPublicScope
   2: 	qPrivateScope
   2: 	qInitLabel
   2: 	qFinalLabel
   2: 	qInitRoutineScope
   2: 	qLevel
   2: 	qDecls
   2: 	qExtends
   2: 	qSize
   2: 	qAllocMode
   2: 	qInitCode
   2: 	qParentScope
   2: 	qType
   2: 	qValue
   2: 	qParams
   2: 	qBodyDefined
   2: 	qExternal
   2: 	qExternalName
   2: 	qCdecl
   2: 	qUsed
   2: 	qOldParams
   2: 	qOldType
   2: 	qResultOffset
   2: 	qNameOffset
   2: 	qValueStr
   2: 	qInOut
   2: 	qDefined
   2: 	qPointerType
   2: 	qBaseType
   2: 	qIndexType
   2: 	qLow
   2: 	qHigh
   2: 	qScope
   2: 	qCapacity
   2: 	qNameTable
   2: 	qHasGap
   2: 	;
      
      
   2: type Node:     % A pointer to a node in the schema database (symbol database)
   2:    Null = 0
   2:    ;
      
   2: type NodeIter:   % An iterator over nodes in a list, in the schema database
   2:    NullIter = 0
   2:    ;
      
   2: type NodeVec:  % A pointer to a vector of Node.  See mechanism node_vec_mech
   2:    NullVec = 0
   2:    ;
      
   2: type boolean:
   2:    false    = 0
   2:    true     = 1;
      
      % intrinsic types & type constructs
      
   2: type typ:
   2:    tyNone     = 0    % in ptrTyp field of TT, means no ptr to type defined
   2:    tyInteger
   2:    tyBoolean
   2:    tyChar
   2:    tyString
   2:    tyFile            % tyInteger..tyFile are scalars (types on their own)
   2:    tyPointer         % following are type constructor classes...
   2:    tyArray           %   (they are not type#'s)
   2:    tyRecord
   2:    tyParams          % like record; a collection of proc/func params
   2:    tySet;
      
   2: type Label:
   2:    labelNull = 0;
      
      % An output code stream.
   2: type Code:
   2:    codeNull = 0
   2:    codeDefault = 1
   2:    ;
      
      % A string
   2: type String:
   2:    stringNull = 0
   2:    ;
      
      % allocation modes for oScopeBegin
   2: type AllocMode:
   2:    allocGlobal = 0  % allocate from global data
   2:    allocDown        % allocate down the stack
   2:    allocUp          % allocate up the stack
   2:    ;
      
      % Some general schema node operations.
      % node_type and node_attribute are defined in generated file pascal_schema.ssl included above.
      %
   2: mechanism node_mech:
   2:     oNodeNew (node_type) >> Node         % create new node
   2:     oNodeSet (Node, node_attribute, Node)   % set Node attribute of node
   2:     oNodeSetString (Node, node_attribute, String)
   2:     oNodeSetInt (Node, node_attribute, int) % set int attribute of node
   2:     oNodeSetBoolean (Node, node_attribute, boolean)
   2:     oNodeSetLabel( Node, node_attribute, Label )  % set Label attribute of node
   2:     oNodeSetCode( Node, node_attribute, Code )    % set Code attribute of node
   2:     oNodeAddLast( Node, node_attribute, Node value )  % append to a List attribute of node
   2:     oNodeGet (Node, node_attribute) >> Node    % get Node attribute of node
   2:     oNodeGetString (Node, node_attribute) >> String
   2:     oNodeGetInt (Node, node_attribute) >> int  % get int attribute of node
   2:     oNodeGetBoolean (Node, node_attribute) >> boolean  % get int attribute of node
   2:     oNodeGetLabel (Node, node_attribute) >> Label      % get Label attribute of node
   2:     oNodeGetCode (Node, node_attribute) >> Code        % get code stream attribute of node
   2:     oNodeNull (Node) >> boolean          % is node null?
   2:     oNodeFind (Node, node_attribute listAttr, node_attribute valueAttr, int value) >> Node  % find node with value in list
   2:     oNodeGetIter (Node, node_attribute) >> NodeIter   % get an iterator over nodes in a List attribute
   2:     oNodeGetIterLast (Node, node_attribute) >> NodeIter  % get an iterator over nodes in a List, starting at last
   2:     oNodeIterValue (NodeIter) >> Node             % the node that iter is referring to (NodeNull if no more nodes)
   2:     oNodeIterNext (inout NodeIter)                % advance iterator through list
   2:     oNodeIterPrev (inout NodeIter)                % advance iterator backwards through list
   2:     oNodeType (Node) >> node_type        % return node type of node
   2:     oNodeEqual (Node, Node) >> boolean   % compare two nodes for equality
                                               % (i.e. same node, not just same contents)
   2:     ;
      
      
      % Manipulate a temporary vector of Node
      %
   2: mechanism node_vec_mech:
   2:     oNodeVecNew >> NodeVec
   2:     oNodeVecDelete( NodeVec nv )
   2:     oNodeVecAppend( NodeVec nv, Node n )
   2:     oNodeVecSize( NodeVec nv ) >> int                % how many elements
   2:     oNodeVecElement( NodeVec nv, int idx ) >> Node   % element at index idx (0..size-1)
   2:     ;
      
      
      
   2: mechanism emit_mech:
   2:     oEmitInt( int )              % emit int into the generated code
   2:     oEmitLabel( Label )
   2:     oEmitCode( Code )            % append a code stream to the current code stream
   2:     Here >> int                  % current address in the generated code
                                       %   (only usable in the default code stream)
   2:     oPatch( int addr, int val )  % patch an int into address in the generated code
                                       %   (only usable in the default code stream)
   2:     ;
      
   2: mechanism math:
   2:     inc (inout int)
   2:     dec (inout int)
   2:     negate (int) >> int
   2:     add( int x, int y ) >> int
   2:     subtract( int x, int y ) >> int     % x - y
   2:     multiply( int x, int y ) >> int     % x * y
   2:     equal( int x, int y ) >> boolean
   2:     equal_zero (int) >> boolean
   2:     equal_node( Node, Node ) >> boolean
   2:     equal_string( String, String ) >> boolean
   2:     equal_node_type (node_type, node_type) >> boolean     % Want equal_<type> for every type
   2:     equal_label( Label, Label ) >> boolean
   2:     equal_code( Code, Code ) >> boolean
   2:     greater( int x, int y ) >> boolean
   2:     oMININT >> int    % the minimum 32-bit integer.
   2:     oMAXINT >> int    % the maximum 32-bit integer.
   2:     ;
      
   2: mechanism more_builtins:      % These should be built-in SSL operations
   2:     TOKEN_VALUE >> int        % value of just accepted token, e.g. IntLit token
   2:     LAST_ID >> int            % id number of last accepted identifier
   2:     ID_STRING( int id ) >> String       % text name of identifier with given id
   2:     CURRENT_STRLIT >> String            % text value of just-accepted string literal
   2:     ;
      
   2: mechanism workspace_mech:
   2:     oWorkspaceNew >> Node
   2:     ;
      
   2: mechanism scope_mech:
   2:     oScopeBegin( int level, AllocMode )  % create a new scope. Subsequent declarations will go here.
                                               %  level = static scope depth (0 = globals)
   2:     oScopeEnter( Node scope )            % enter an existing scope.
   2:     oScopeEnd                            % end current scope. Subsequent declarations will go to previous scope.
   2:     oScopeCurrent >> Node                % returns current scope
   2:     oScopeDeclare( Node decl )           % add declaration to current scope.
   2:     oScopeDeclareAlloc( Node decl )      % add declaration to current scope, and allocate space according to its type
   2:     oScopeAllocType( Node theType ) >> int   % allocate space for type in current scope, and return its address
   2:     oScopeAlloc( int size, int align ) >> int % allocate bytes, with given alignment in bytes 
   2:     oScopeFind >> Node                   % find declaration of last accepted identifier.  Returns Null if not found.
   2:     oScopeFindRequire >> Node            % find declaration of last accepted identifier.  Error if not found.
   2:     oScopeFindInCurrentScope >> Node     % find declaration of last accepted identifier, only within the current scope.  Null if not found.
   2:     oScopeFindRequireInScope( Node scope ) >> Node  % find decl of last accepted identifier, only within the given scope.  Error it not found.
   2:     ;
      
   2: mechanism type_mech:
   2:     oTypeAdd( Node node )     % add the given nType to the type table
   2:     ;
      
   2: mechanism type_stack_mech:
   2:     oTypeSPush( Node node )
   2:     oTypeSPop
   2:     oTypeSTop >> Node
   2:     oTypeSNodeType >> node_type          % node_type of the node on top of type stack, skipping subranges
   2:     ;
      
      
   2: mechanism id_mech:
          % gets/adds a predefined id to the scanner's id table, and returns the id code
   2:     oId_mysystem >> int
   2:     oId_ShortStringAppendShortString >> int
   2:     oId_ShortStringAppendChar >> int
   2:     oId_ShortStringCmp >> int
   2:     oId_File >> int
   2:     oId_Integer >> int
   2:     oId_Boolean >> int
   2:     oId_Char >> int
   2:     oId_Byte >> int
   2:     oId_Pointer >> int
   2:     oId_ShortString >> int
   2:     oId_True >> int
   2:     oId_False >> int
   2:     oId_Nil >> int
   2:     oId_Ord >> int
   2:     oId_Chr >> int
   2:     oId_Pred >> int
   2:     oId_Succ >> int
   2:     oChangeIntLitToLabelIdent    % change current token from pIntLit to pIdent "_label_<intlit>"
   2:     ;
      
      
      
   2: mechanism label_mech:
   2:    oLabelNew >> Label
   2:    ;
      
   2: mechanism code_mech:
   2:    oCodeNew >> Code         % create a new empty code stream
   2:    oCodePush( Code )        % change the current output code stream to the given one
   2:    oCodePop                 % restore the current code stream to the previous one
   2:    ;
      
   2: mechanism include_mech:
   2:    oIncludeUnitFile( int id ) >> boolean  % search for <unit>.pas and include it.
                                                % returns false if can't find.
   2:    oIncludeEnd              % stop including the current file
   2:    ;
      
      
   2: mechanism count :
   2:    oCountPush(int)          % start a new counter, with initial value
   2:    oCountInc
   2:    oCountDec
   2:    oCountIsZero >> boolean
   2:    oCountPop;
      
      
   2: mechanism value :              % value stack, to calc. const expr's
   2:    oValuePush(int)             % push an explicit int lit
   2:    oValuePushString(String)    % push string onto value stack
   2:    oValueTop >> int            % get top value on value stack
   2:    oValueTopString >> String
   2:    oValueSwap                  % swap top two
   2:    oValuePop
   2:    oValueCharToString          % convert top value from char to string
   2:    oValueNegate                % negate top numeric value
   2:    oValueEqual
   2:    oValueNotEqual
   2:    oValueLess
   2:    oValueGreater
   2:    oValueLessEqual
   2:    oValueGreaterEqual
   2:    oValueOr                    % boolean or
   2:    oValueAnd
   2:    oValueNot                   % boolean not
   2:    oValueAdd
   2:    oValueSub
   2:    oValueMult
   2:    oValueDiv
   2:    oValueStringCmp             % compare top two strings. replace with negative, 0, or positive
   2:    oValueStringConcat
   2:    ;
      
   2: mechanism string :
   2:    oStringAllocLit( String ) >> int      % alloc global space for strlit, return address
   2:    oStringAllocShortStringLit( String ) >> int  % alloc global space for ShortString, return address
   2:    ;
      
      % track labels for the loop we're in, if any
   2: mechanism loop_mech:
   2:    oLoopPush( Label continueLabel, Label breakLabel )
   2:    oLoopContinueLabel >> Label
   2:    oLoopBreakLabel >> Label
   2:    oLoopPop
   2:    ;
      
      % for hacky debugging
   2: mechanism msg_mech:
   2:    oMsg( int num )             % print message "oMsg <num>"
   2:    oMsgTrace( int num )        % print message "oMsg <num>" followed by ssl traceback
   2:    oMsgNode( Node node )       % print node
   2:    oMsgNodeLong( Node node )   % print node with more detail
   2:    oMsgNodeVec( NodeVec vec )  % print node vec
   2:    ;
      
      
   2: rules
      
      % ----------------------------- Global Variables ----------------------------
      
   2: Node    workspace              % root of database
   2: Node    globalScope            % scope for globals in the current module
   2: Node    initScope              % scope for temporaries global var init,
                                     % and program main stmt / unit initialization stmts
      
   2: int     mysystemId               % id of identifier "mysystem"
      
      % built-in nTypes
   2: Node    FileType
   2: Node    IntegerType
   2: Node    BooleanType
   2: Node    BooleanFlowType
   2: Node    CharType
   2: Node    PCharType
   2: Node    ByteType
   2: Node    UniversalPointerType
   2: Node    StrLitType
   2: Node    ShortStringType
      
      % nBuiltInFunc
   2: Node    BuiltIn_Ord
   2: Node    BuiltIn_Chr
   2: Node    BuiltIn_Pred
   2: Node    BuiltIn_Succ
      
      % Declarations in unit mysystem that the compiler may refer to directly.
      
   2: Node    System_ShortStringAppendShortString
   2: Node    System_ShortStringAppendChar
   2: Node    System_ShortStringCmp
      
      
      % -------------------------- Forward Declarations -------------------------
      
   2: Block( node_type varNodeType, Label labelForBody );
   2: BlockDecls( node_type varNodeType );
   2: BlockStmt( Label labelForBody, Node varScope, boolean isMain );
   2: VarDecl( node_type varNodeType );
   2: newType( node_type nt, int size ) >> Node;
   2: newIdent( node_type nt, int id ) >> Node;
   2: EmitValue( Node decl );
   2: TypeRef( out Node theType );
   2: EnumTypeRef( out Node resultType );
   2: PointerTypeTo( Node theType ) >> Node;
   2: OrdinalLow( Node theType ) >> int;
   2: OrdinalHigh( Node theType ) >> int;
   2: AssignStmt( Node decl );
   2: BooleanExprControlFlow( out Label falseLabel );
   2: ExprAllowFlow( out Label falseLabel );
   2: BoolExprAllowFlow( out Label falseLabel );
   2: BoolTermAllowFlow( out Label falseLabel );
   2: BoolFactorAllowFlow( out Label falseLabel );
   2: ArithExprAllowFlow( out Label falseLabel );
   2: TermAllowFlow( out Label falseLabel );
   2: FactorAllowFlow( out Label falseLabel );
   2: PrimaryAllowFlow( out Label falseLabel );
      
   2: VarExpr( Node decl );
   2: LValueVar( Node decl, boolean writeable );
   2: IncVar( Node decl );
   2: DecVar( Node decl );
      
   2: FlowToVal( inout Label falseLabel );
   2: ValToFlow( out Label falseLabel );
   2: MoveIntoTempShortString >> int;
      
   2: DeclLevel( Node decl ) >> int;
   2: DeclUpLevels( Node decl ) >> int;
      
      % ----------------------------- Start ----------------------------
      
   2: MainRule:
   4:    @Program
   7:    ;
      
   7: include 'pascal_unit.ssl'
      
      %
      %  Pascal Compiler
      %
      
      % ------------------------------ Units -----------------------------
      
      
      % The uses clause is a list of units required by the user program or unit.
      % We will find and compile the named units (unless already loaded).
      % We do not make the unit interface visible to the user, the caller will do so later.
   7: UsesClause( Node user ):
   9:    {
   9:       pIdent
  11:       @Uses( LAST_ID, user )
  20:       [
  20:          | ',' :
  22:          | * :  >
  29:       ]
  29:    }   
  31:    ';'
  34:    ;
      
      
      % Process an implicit "uses mysystem" in every module, except in the mysystem unit itself.
      % (I'm calling the unit mysystem rather than system, so fpc doesn't use it to replace its own system unit.)
      %
  34: UsesMySystem( Node user ):
  36:    [ equal( oNodeGetInt( user, qIdent ), mysystemId )
  53:       | true :  >>
  55:       | * :
  60:    ]
  60:    @Uses( mysystemId, user )
  71:    ;
      
      
      % After processing the mysystem unit interface, grab certain declarations from it
      % that the compiler may want to refer to later.
      %
  71: FindSelectSystemDecls( Node unit ):
  73:    [ equal( oNodeGetInt( unit, qIdent ), mysystemId )
  90:       | true :
  91:          System_ShortStringAppendShortString = oNodeFind( oScopeCurrent, qDecls, qIdent, oId_ShortStringAppendShortString )
 108:          System_ShortStringAppendChar = oNodeFind( oScopeCurrent, qDecls, qIdent, oId_ShortStringAppendChar )
 125:          System_ShortStringCmp = oNodeFind( oScopeCurrent, qDecls, qIdent, oId_ShortStringCmp )
 142:       | * :
 147:    ]
 148:    ;
      
      
      % The given user module uses a unit with the given id,
      % which may or may not have been loaded already.
      %
 148: Uses( int id, Node user ):
 150:    Node unit = @FindOrCompileUnit( id )
 161:    [ equal_node( unit, Null )
 171:       | false :
 172:          oNodeAddLast( user, qUsedUnits, unit )
      
               % Put a declaration in the current scope, naming the unit and pointing to it.
               % This is to allow references to  <unit>.<identifier_in_unit>
 184:          Node unitRef = oNodeNew( nUnitRef )
 194:          oNodeSetInt( unitRef, qIdent, oNodeGetInt( unit, qIdent ) )
 213:          oNodeSet( unitRef, qPublicScope, oNodeGet( unit, qPublicScope ) )
 232:          oScopeDeclare( unitRef )
 238:       | * :
 243:    ];
      
      
      % If the given decl is for an nUnitRef, the program is using syntax <unit>.<identifier>
      % Parse the rest of that to find the intended decl.
      %
 244: ResolveUnitRef( inout Node decl ):
 246:    [ oNodeType( decl )
 253:       | nUnitRef :
 254:          Node scope = oNodeGet( decl, qPublicScope )
 267:          '.'
 269:          pIdent
 271:          decl = oScopeFindRequireInScope( scope )
 281:       | * :
 286:    ];
      
      
 287: EnterUsedUnits( Node user ):
         % Make the used units' public scopes directly visible.
         % This is done after the units are all compiled, so they don't interfere with each other incorrectly.
         % Units later in the list have priority.
 289:    NodeIter unitIt = oNodeGetIter( user, qUsedUnits )
 302:    {
 302:       Node unit = oNodeIterValue( unitIt )
 312:       [ oNodeNull( unit )
 319:          | false :
 320:             oScopeEnter( oNodeGet( unit, qPublicScope ) )
 333:          | * :
 338:             >
 340:       ]
 340:       oNodeIterNext( unitIt )
 346:    }
 349:    ;
      
 349: EndUsedUnits( Node user ):
         % Leave the units' public scopes, so no longer visible.
 351:    NodeIter unitIt = oNodeGetIterLast( user, qUsedUnits )
 364:    {
 364:       Node unit = oNodeIterValue( unitIt )
 374:       [ oNodeNull( unit )
 381:          | false :
                  % Consistency check.  Make sure our scope enter / end have lined up correctly.
 382:             [ oNodeEqual( oScopeCurrent, oNodeGet( unit, qPublicScope ) )
 398:                | true :
 399:                | false :  #eInternalScopeMismatch
 403:             ]
 411:             oScopeEnd
 412:          | * :
 417:             >
 419:       ]
 419:       oNodeIterPrev( unitIt )
 425:    }
 428:    ;
      
      
 428: FindOrCompileUnit( int id ) >> Node:
         % We might have this unit loaded already
 430:    Node unit = oNodeFind( workspace, qUnits, qIdent, id )
 449:    [ equal_node( unit, Null )
 459:       | false :  >> unit
 463:       | * :
 468:    ]
      
         % If not, search for the source file on disk
 468:    boolean ok = oIncludeUnitFile( id )
 478:    [ ok
 481:       | false :  #eCantFindUnitFile  >> Null
 487:       | * :
 492:    ]
      
         % compile it, adding it into the workspace
         % then return it.
 492:    unit = @Unit
      
         % TO DO: ensure we are at pEof
         % end the include
 498:    oIncludeEnd
 499:    >> unit;
      
      
      
 503: Unit >> Node:
 505:    pUnit
 507:    pIdent
 509:    Node unit = oNodeNew( nUnit )
 519:    oNodeSetInt( unit, qIdent, LAST_ID )
 530:    Node unitImpl = oNodeNew( nUnitImpl )
 540:    oNodeSetInt( unitImpl, qIdent, LAST_ID )
 551:    oNodeSet( unit, qImpl, unitImpl )
 563:    ';'
      
         % mandatory sections
      
 565:    pInterface
 567:    @UsesMySystem( unit )
 574:    [
 574:       | pUses :   @UsesClause( unit )
 583:       | * :
 588:    ]
 588:    @EnterUsedUnits( unit )
      
 595:    oScopeBegin( 0, allocGlobal )
 604:    oNodeSet( unit, qPublicScope, oScopeCurrent )
 615:    globalScope = oScopeCurrent
      
         % A scope for temporaries needed by variable initialization
 620:    oScopeBegin( 0, allocDown )
 629:    initScope = oScopeCurrent
 634:    oNodeSet( unit, qInitRoutineScope, initScope )
 646:    oScopeEnd
      
 647:    @UnitInterface( unit )
 654:    oScopeEnd  % interface scope
      
 655:    pImplementation
 657:    @UsesMySystem( unitImpl )
 664:    [
 664:       | pUses :   @UsesClause( unitImpl )
 673:       | * :
 678:    ]
 678:    @EnterUsedUnits( unitImpl )
         % re-enter interface scope after impl's uses.  interface still has priority.
 685:    oScopeEnter( oNodeGet( unit, qPublicScope ) )
         
 698:    oScopeBegin( 0, allocGlobal )
 707:    oNodeSet( unit, qPrivateScope, oScopeCurrent )
 718:    oNodeSet( oScopeCurrent, qExtends, oNodeGet( unit, qPublicScope ) )
 736:    globalScope = oScopeCurrent
 741:    @UnitImplementation( unit )
      
 748:    [
 748:       | pInitialization :  @UnitInitialization( unit, true )   % init routine with statements from init section
 760:       | * :                @UnitInitialization( unit, false )  % implicit init routine
 775:    ]
 775:    [
 775:       | pFinalization :  @UnitFinalization( unit, true )
 787:       | * :              @UnitFinalization( unit, false )   % implicit final routine, may be handy later
 802:    ]
 802:    pEnd  '.'
      
 806:    oScopeEnd  % impl scope
 807:    oScopeEnd  % interface scope
 808:    @EndUsedUnits( unitImpl )  % used units scopes
 815:    @EndUsedUnits( unit )
 822:    oNodeAddLast( workspace, qUnits, unit )
 834:    >> unit;
      
      
 838: UnitInterface( Node unit ):
 840:    {[
 840:       | pConst :     @ConstDecl
 844:       | pType :      @TypeDecl
 848:       | pVar :       @VarDecl( nGlobalVar )
            % label declaration not allowed in interface
      
 857:       | pProcedure :
 859:          Node decl = @ProcHeaderDecl
               % despite syntax diagrams, fpc does allow external clause on methods in unit interface,
               % even though this clause is an alternative for the body statement.
 865:          [
 865:             | pExternal :
 867:                @ExternalDecl( decl )
 874:                ';'
 876:             | * :
 881:          ]
      
 881:       | pFunction :
 883:          Node decl = @FuncHeaderDecl
 889:          [
 889:             | pExternal :
 891:                @ExternalDecl( decl )
 898:                ';'
 900:             | * :
 905:          ]
      
 905:       | * :          >
 920:    ]}
 922:    @FindSelectSystemDecls( unit )
 930:    ;
      
 930: UnitImplementation( Node unit ):
 932:    @BlockDecls( nGlobalVar )
 940:    ;
      
      
 940: UnitInitialization( Node unit, boolean hasStmts ):
 942:    Label label = oLabelNew
 947:    .tLabel  oEmitLabel( label )
 955:    oNodeSetLabel( unit, qInitLabel, label )
      
 967:    int patchLS
 967:    .tEnter  patchLS = Here  .tSpace
      
         % insert any code for initialization of this unit's variables.
         
 976:    Node scope
 976:    Code initCode
      
 976:    scope = oNodeGet( unit, qPublicScope )
 989:    initCode = oNodeGetCode( scope, qInitCode )
1002:    oEmitCode( initCode )
1008:    oNodeSetCode( scope, qInitCode, codeNull )
      
1020:    scope = oNodeGet( unit, qPrivateScope )
1033:    initCode = oNodeGetCode( scope, qInitCode )
1046:    oEmitCode( initCode )
1052:    oNodeSetCode( scope, qInitCode, codeNull )
      
1064:    oScopeEnter( oNodeGet( unit, qInitRoutineScope ) )
      
1077:    [ hasStmts
1080:       | true :     
1081:          @Statement
1083:          {[
1083:             | ';' :  @Statement
1087:             | * :    >
1094:          ]}
1096:       | * :
1101:    ]
      
1101:    .tReturn
      
1103:    int localSpace = oNodeGetInt( oScopeCurrent, qSize )
1115:    oPatch( patchLS, localSpace )
1124:    oScopeEnd   % init routine scope, for temporaries
1126:    ;
      
      
1126: UnitFinalization( Node unit, boolean hasStmts ):
1128:    Label label = oLabelNew
1133:    .tLabel  oEmitLabel( label )
1141:    oNodeSetLabel( unit, qFinalLabel, label )
      
1153:    int patchLS
1153:    .tEnter  patchLS = Here  .tSpace
      
         % final routine scope, for temporaries
1162:    oScopeBegin( 0, allocDown )
      
1171:    [ hasStmts
1174:       | true :     
1175:          @Statement
1177:          {[
1177:             | ';' :  @Statement
1181:             | * :    >
1188:          ]}
1190:       | * :
1195:    ]
      
1195:    .tReturn
      
1197:    int localSpace = oNodeGetInt( oScopeCurrent, qSize )
1209:    oPatch( patchLS, localSpace )
1218:    oScopeEnd   % final routine scope, for temporaries
1220:    ;
      
      
1220: InitializeUnits:
         % call init routine of each loaded unit, in the order they were loaded
         % (used directly or indirectly by the main program).
1222:    NodeIter it = oNodeGetIter( workspace, qUnits )
1235:    {
1235:       Node unit = oNodeIterValue( it )
1245:       [ oNodeNull( unit )
1252:          | true :  >
1255:          | false :
1257:             .tAllocActuals  oEmitInt( 0 )  % not sure I need this. maybe for stack alignment.
1265:             .tCall  oEmitLabel( oNodeGetLabel( unit, qInitLabel ) )
1280:             .tFreeActuals  oEmitInt( 0 )
1288:             oNodeIterNext( it )
1294:       ]
1302:    };
      
      
1305: FinalizeUnits:
1307:    NodeIter it = oNodeGetIterLast( workspace, qUnits )
1320:    {
1320:       Node unit = oNodeIterValue( it )
1330:       [ oNodeNull( unit )
1337:          | true :  >
1340:          | false :
1342:             .tAllocActuals  oEmitInt( 0 )  % not sure I need this. maybe for stack alignment.
1350:             .tCall  oEmitLabel( oNodeGetLabel( unit, qFinalLabel ) )
1365:             .tFreeActuals  oEmitInt( 0 )
1373:             oNodeIterPrev( it )
1379:       ]
1387:    };
      
1390: include 'pascal_decl.ssl'
      %
      % Pascal Compiler
      %
      
      % ----------------------------- Declarations ----------------------------
      
      
      
      % modifers that may appear on a proc/function declaration.
      %
1390: MethodModifiers( Node decl ):
1392:    {[
1392:       | pCdecl :
1394:          oNodeSetBoolean( decl, qCdecl, true )
1406:          ';'
      
1408:       | * : >
1415:    ]}
1418:    ;
      
      
      % external method resides in an external object file
      % (or in my system, the built-in runtime library).
      % The method has a label, as usual, which callers will use.
      % But we define that label with .tLabelExtern rather than .tLabel.
      %
      % Note, I'll hold off on issuing the .tLabelExtern until we see that
      % the external method is actually called.  Otherwise we'd fill each output file
      % with all the external method names in my included libraries, which seems dumb.
      %
      % Note this is fpc syntax.  I'm not sure about other Pascals.
      %
1418: ExternalDecl( Node decl ):
1420:    [ equal_zero( @DeclLevel( decl ) )
1432:       | false :  #eExternalMethodCannotBeNested
1435:       | * :
1440:    ]
1440:    oNodeSetBoolean( decl, qExternal, true )
1452:    [
1452:       | pStrLit :
               % that was the optional library name containing the method.
               % TO DO: I'm currently ignoring this.
1454:          [
1454:             | pName :
1456:                pStrLit
                     % that was the optional method name defined in that library,
                     % which might differ from the Pascal name.
1458:                oNodeSetString( decl, qExternalName, CURRENT_STRLIT )
1469:             | * :
1474:          ]
1474:       | * :
1479:    ]
1480:    ;
      
      
1480: ProcHeaderDecl >> Node:
1482:    pIdent
      
         % If we already have a forward declaration, we'll modify that decl
         % instead of creating a second symbol table entry.
         % (Alternatively could delete or hide the old entry.)
1484:    boolean redeclaring = false
1490:    Node decl = oScopeFindInCurrentScope
      
1495:    [ oNodeNull( decl )
1502:       | true :
               % first declaration
1503:          decl = @newIdent( nProc, LAST_ID )
1516:          oNodeSetLabel( decl, qValue, oLabelNew )
      
1527:       | false :
               % we already have a declaration.
               % Keep it, and its label.
1529:          redeclaring = true
1535:          [ oNodeGetBoolean( decl, qBodyDefined )
1545:             | true : #eAlreadyDefined
1548:             | * :
1553:          ]
1553:          [ oNodeGetBoolean( decl, qExternal )
1563:             | true : #eAlreadyDefined
1566:             | * :
1571:          ]
1571:          [ oNodeType( decl )
1578:             | nProc :
1579:             | * : #eAlreadyDefined   % wrong kind
1586:          ]
               % Move the existing param scope aside, so we can check that the
               % new one is consistent.  And, the body will want to see the new one
               % since the names might differ.
               % TO DO: If qOldParams already set, we have multiple forward decls,
               % which I believe is supposed to be an error.
1586:          oNodeSet( decl, qOldParams, oNodeGet( decl, qParams ) )
1605:          oNodeSet( decl, qParams, Null )
1617:    ]
      
1625:    int level = @ScopeLevel
1631:    boolean nested = greater( level, 0 )
1644:    inc( level )
1650:    oScopeBegin( level, allocUp )
1659:    Node paramScope = oScopeCurrent
      
         % A nested method has a hidden first param for the parent static scope.
         % This won't appear in the param decls list, just reserve space for it.
         % It's first so the static chain is always at a fixed offset from the frame pointer.
1664:    [ nested
1667:       | true :
1668:          int offset = oScopeAllocType( @PointerTypeTo( IntegerType ) )   % arbitrary ptr type
1683:       | * :
1688:    ]
      
1688:    @FormalArgDecl
1690:    oNodeSet( decl, qParams, paramScope )
1702:    oScopeEnd
1703:    ';'
      
1705:    [ redeclaring
1708:       | false : oScopeDeclare( decl )
1715:       | true :  % TO DO: check that qParams is consistent with qOldParams
1717:    ]
      
1725:    @MethodModifiers( decl )
1732:    >> decl;
      
      
1736: ProcDecl:
1738:    Node decl = @ProcHeaderDecl
      
         % Body may be a statement, "forward", "external".
         % Note, this syntax is based on FPC, and I'm not sure if other Pascals are similar.
         % FPC says that forward, external, cdecl, name, etc are not reserved words -
         % I think this means the user may declare other things with those names, but if so the
         % original meaning is lost.  I'll make them keywords for simplicity, for now
         % (just not too happy about "name").
      
1744:    [
1744:       | pForward :
               % Nothing to do.  We simply won't set qBodyDefined.
      
1746:       | pExternal : @ExternalDecl( decl )
      
1755:       | * :
               % Body statement
      
               % Enter the params scope again, so params are visible in body.
               % TO DO: Perhaps I could mark the scope read-only at this point.
1762:          Node paramScope = oNodeGet( decl, qParams )
1775:          oScopeEnter( paramScope )
      
               % Start scope for declarations within the proc
1781:          int level = oNodeGetInt( paramScope, qLevel )
1794:          oScopeBegin( level, allocDown )
1803:          oNodeSet( decl, qChildScope, oScopeCurrent )
      
1814:          Label label = oNodeGetLabel( decl, qValue )
1827:          @Block( nLocalVar, label )
1837:          oNodeSetBoolean( decl, qBodyDefined, true )
1849:          oScopeEnd
      
1850:          oScopeEnd  % paramScope
1851:    ]
1851:    ';';
      
      
      
1854: FuncHeaderDecl >> Node:
1856:    pIdent
      
         % If we already have a forward declaration, we'll modify that decl
         % instead of creating a second symbol table entry.
         % (Alternatively could delete or hide the old entry.)
1858:    boolean redeclaring = false
1864:    Node decl = oScopeFindInCurrentScope
      
1869:    [ oNodeNull( decl )
1876:       | true :
               % first declaration
1877:          decl = @newIdent( nFunc, LAST_ID )
1890:          oNodeSetLabel( decl, qValue, oLabelNew )
      
1901:       | false :
               % we already have a declaration.
               % Keep it, and its label.
1903:          redeclaring = true
1909:          [ oNodeGetBoolean( decl, qBodyDefined )
1919:             | true : #eAlreadyDefined
1922:             | * :
1927:          ]
1927:          [ oNodeType( decl )
1934:             | nFunc :
1935:             | * : #eAlreadyDefined   % wrong kind
1942:          ]
               % Move the existing param scope and return value aside,
               % so we can check that the new one is consistent.
               % And, the body will want to see the new one since the names might differ.
               % TO DO: If qOldParams already set, we have multiple forward decls,
               % which I believe is supposed to be an error.
1942:          oNodeSet( decl, qOldParams, oNodeGet( decl, qParams ) )
1961:          oNodeSet( decl, qParams, Null )
1973:          oNodeSet( decl, qOldType, oNodeGet( decl, qType ) )
1992:          oNodeSet( decl, qType, Null )
2004:    ]
      
2012:    int level = @ScopeLevel
2018:    boolean nested = greater( level, 0 )
2031:    inc( level )
2037:    oScopeBegin( level, allocUp )
2046:    Node paramScope = oScopeCurrent
      
         % A nested method has a hidden first param for the parent static scope.
         % This won't appear in the param decls list, just reserve space for it.
         % It's first so the static chain is always at a fixed offset from the frame pointer.
2051:    [ nested
2054:       | true :
2055:          int offset = oScopeAllocType( @PointerTypeTo( IntegerType ) )   % arbitrary ptr type
2070:       | * :
2075:    ]
      
2075:    @FormalArgDecl
2077:    oNodeSet( decl, qParams, paramScope )
      
2089:    ':'
      
2091:    Node theType
2091:    @TypeRef( theType )
2098:    oNodeSet( decl, qType, theType )
      
         % The function's param space gets an additional pointer,
         % which will point to a temporary in the caller's scope.
         % This pointer is essentially a VAR param, but I won't create an nParam for it.
      
2110:    Node ptrType = @PointerTypeTo( theType )
2121:    oNodeSetInt( decl, qResultOffset, oScopeAllocType( ptrType ) )
2137:    oScopeEnd
2138:    ';'
      
2140:    [ redeclaring
2143:       | false : oScopeDeclare( decl )
2150:       | true :  % TO DO: check that qParams is consistent with qOldParams
                      % and qType is consistent with qOldType
2152:    ]
      
2160:    @MethodModifiers( decl )
      
2167:    >> decl;
      
      
2171: FuncDecl:
2173:    Node decl = @FuncHeaderDecl
      
         % Body may be a statement, "forward", "external".
2179:    [
2179:       | pForward :
               % Nothing to do.  We simply won't set qBodyDefined.
      
2181:       | pExternal : @ExternalDecl( decl )
      
2190:       | * :
               % Body statement
      
               % Enter the params scope again, so params are visible in body.
               % TO DO: Perhaps I could mark the scope read-only at this point.
2197:          Node paramScope = oNodeGet( decl, qParams )
2210:          oScopeEnter( paramScope )
      
               % Start scope for declarations within the func
2216:          int level = oNodeGetInt( paramScope, qLevel )
2229:          oScopeBegin( level, allocDown )
2238:          oNodeSet( decl, qChildScope, oScopeCurrent )
      
2249:          Label label = oNodeGetLabel( decl, qValue )
2262:          @Block( nLocalVar, label )
2272:          oNodeSetBoolean( decl, qBodyDefined, true )
2284:          oScopeEnd
      
2285:          oScopeEnd  % paramScope
2286:    ]
2286:    ';';
      
      
2289: FormalArgDecl:
2291:    [
2291:       | '(' :
2293:          {
2293:             NodeVec decls = oNodeVecNew
2298:             Node decl
2298:             boolean isInOut = false
      
2304:             [
2304:                | pVar : isInOut = true
2312:                | * :
2317:             ]
      
2317:             {  pIdent
      
2319:                decl = @newIdent( nParam, LAST_ID )
2332:                oNodeSetBoolean( decl, qInOut, isInOut )
2344:                oNodeVecAppend( decls, decl )
      
2353:                [
2353:                   | ':' : >
2357:                   | ',' :
2359:                ]
2367:             }
      
2369:             Node theType
2369:             @TypeRef( theType )
      
                  % VAR param is declared with its given type, but allocated as a pointer.
2376:             Node allocType
2376:             [ isInOut
2379:                | true :   allocType = @PointerTypeTo( theType )
2391:                | * :      allocType = theType
2402:             ]
      
2402:             int i = 0
2408:             {[ equal( i, oNodeVecSize( decls ) )
2422:                | false :
2423:                   decl = oNodeVecElement( decls, i )
      
2436:                   oNodeSet( decl, qType, theType )
2448:                   oScopeDeclare( decl )
2454:                   oNodeSetInt( decl, qValue, oScopeAllocType( allocType ) )
2470:                   inc( i )
2476:                | * :
2481:                   >
2483:             ]}
      
2485:             oNodeVecDelete( decls )
      
2491:             [
2491:                | ')' : >
2495:                | ';' :
2497:             ]
2505:          }
2507:       | * :
2512:    ];
      
      
2513: ConstDecl:
2515:    {[
2515:       | pIdent :
2517:          [
2517:             | ':' :
2519:                @TypedConstDecl
2521:             | * :
2526:                @TrueConstDecl
2528:          ]
2528:       | * :
2533:          >
2535:    ]};
      
      
      % Parse a true constant declaration (as opposed to a typed const declaration).
      % The "true constant" terminology comes from Delphi docs.  It refers to a const that is
      % evaluated at compile time, rather than at program startup time.
      %
      % We've just accepted the identifier.
      %
2538: TrueConstDecl:
2540:    int id = LAST_ID
2545:    '='
      
2547:    @ConstExpr
      
2549:    Node decl
2549:    [ oTypeSNodeType
2551:       | nBooleanType, nByteType, nCharType, nIntegerType, nEnumType,
2552:         nPointerType, nUniversalPointerType :
2552:          decl = @newIdent( nConst, id )
2566:          oNodeSetInt( decl, qValue, oValueTop )
2577:       | nStrLitType :
2579:          decl = @newIdent( nConstStr, id )
2593:          oNodeSetString( decl, qValueStr, oValueTopString )
2604:       | * :  #eNotAllowed
2625:    ]
2625:    oValuePop
2626:    oNodeSet( decl, qType, oTypeSTop )
2637:    oTypeSPop
2638:    oScopeDeclare( decl )
2644:    ';'
2647:    ;
      
      
      % Parse a typed const declaration.
      % We've just accepted the identifier and ':'
      %
2647: TypedConstDecl:
2649:    Node decl = @newIdent( nTypedConst, LAST_ID )
      
2662:    Node theType
2662:    @TypeRef( theType )
2669:    oNodeSet( decl, qType, theType )
      
         % Array and record consts are allocated in global memory,
         % with global offset stored as decl value.
         % Scalar consts are not allocated in memory, and their value is
         % stored directly as the decl value, as I do with "true constants".
         %
         % TO DO: I probably should store scalar consts in memory too, in case somebody
         % wants to get a pointer to them.  And anyway, typed constants can't be used in
         % constant expressions, so less need to store value in decl node.
      
         % TO DO: skip subranges, similar to oTypeSNodeType.
2681:    [ oNodeType( theType )
2688:       | nBooleanType, nByteType, nCharType, nIntegerType, nEnumType,
2689:         nPointerType, nUniversalPointerType :
               % Parse expression and store value in decl
2689:          '='
      
2691:          oTypeSPush( theType )
2697:          @ConstExpr
2699:          @ConstCoerceType
      
2701:          oNodeSetInt( decl, qValue, oValueTop )
2712:          oValuePop
2713:          oTypeSPop
2714:          oScopeDeclare( decl )
2720:          ';'
      
2722:       | nShortStringType, nFileType :
2724:          #eNotImplemented
      
2726:       | nArrayType, nRecordType :
               % Allocate global space, store address in decl.
               % Push into global scope init code stream (since we'll be issuing code
               % rather than creating static data, at the moment).
               % Parse expression and store in global memory.
2728:          oScopeEnter( globalScope )
2734:          int addr = oScopeAllocType( theType )
2744:          oScopeEnd
2745:          oCodePush( @GetOrCreateInitCode( globalScope ) )
2756:          oNodeSetInt( decl, qValue, addr )
2768:          '='
2770:          @TypedConstInit( theType, addr )
2780:          oCodePop
2781:          oScopeDeclare( decl )
2787:          ';'
2789:    ]
2816:    ;
      
      
      % Parse the initial value of a constant that's being stored in global memory.
      % (An array or record constant, and recursively all its elements.)
      % Given the type, and the address in global memory for the const value.
      % The caller has already pushed into the global init code stream.
      %
2816: TypedConstInit( Node theType, int addr ):
      
         % TO DO: skip subranges, similar to oTypeSNodeTYpe
2818:    [ oNodeType( theType )
2825:       | nArrayType :
2826:          Node baseType = oNodeGet( theType, qBaseType )
2839:          Node indexType = oNodeGet( theType, qIndexType )
2852:          int low = @OrdinalLow( indexType )
2863:          int high = @OrdinalHigh( indexType )
2874:          int elementSize = oNodeGetInt( baseType, qSize )
      
2887:          '('
               % Loop over elements
2889:          int i = low
2895:          {
2895:             @TypedConstInit( baseType, addr )
2905:             [ equal( i, high )
2915:                | true : >
2918:                | false :
2920:             ]
2928:             ','
2930:             addr = add( addr, elementSize )
2943:             inc( i )
2949:          }
2951:          ')'
      
2953:       | nRecordType :
2955:          '('
2957:          Node fieldScope = oNodeGet( theType, qScope )
               % Loop over zero or more named fields.  It's not necessary to name them all.
               % fpc says the names that are given should be in order, but I'm not requiring that.
               % Since this is global memory, uninitialized fields will be left as 0.
2970:          {
2970:             [
2970:                | pIdent :
2972:                | * :  >
2979:             ]
2979:             Node field = oScopeFindRequireInScope( fieldScope )
2989:             ':'
2991:             Node fieldType = oNodeGet( field, qType )
3004:             int fieldAddr = add( addr, oNodeGetInt( field, qValue ) )
3024:             @TypedConstInit( fieldType, fieldAddr )
3034:             [
3034:                | ';' :
3036:                | * :  >
3043:             ]
3043:          }
3045:          ')'
      
3047:       | nBooleanType, nByteType, nCharType:
3049:          .tPushAddrGlobal  oEmitInt( addr )
3057:          oTypeSPush( theType )
3063:          @ConstExpr
3065:          @ConstCoerceType
3067:          .tPushConstI  oEmitInt( oValueTop )
3074:          oValuePop
3075:          oTypeSPop
3076:          .tAssignB
      
3078:       | nIntegerType, nEnumType:
3080:          .tPushAddrGlobal  oEmitInt( addr )
3088:          oTypeSPush( theType )
3094:          @ConstExpr
3096:          @ConstCoerceType
3098:          .tPushConstI  oEmitInt( oValueTop )
3105:          oValuePop
3106:          oTypeSPop
3107:          .tAssignI
      
3109:       | nPointerType, nUniversalPointerType :
3111:          .tPushAddrGlobal  oEmitInt( addr )
3119:          oTypeSPush( theType )
3125:          @ConstExpr
3127:          @ConstCoerceType
3129:          .tPushConstI  oEmitInt( oValueTop )   % only allowing ptr constant Nil so don't need tPushConstP or link redirection
3136:          oValuePop
3137:          oTypeSPop
3138:          .tAssignP
      
3140:       | nShortStringType, nFileType :
3142:          #eNotImplemented
3144:    ]
3171:    ;
      
      
3171: TypeDecl:
3173:    {[
3173:       | pIdent :
3175:          Node decl = @newIdent( nTypeDecl, LAST_ID )
3188:          '='
3190:          Node theType
3190:          @TypeRef( theType )
3197:          oNodeSet( decl, qType, theType )
3209:          oScopeDeclare( decl )
3215:          ';'
3217:       | * :
3222:          >
3224:    ]};
      
3227: VarDecl( node_type varNodeType ):
3229:    {[
3229:       | pIdent :
3231:          NodeVec decls = oNodeVecNew
3236:          Node decl
3236:          {
3236:             decl = @newIdent( varNodeType, LAST_ID )
3249:             oNodeVecAppend( decls, decl )
3258:             [
3258:                | ',' :
3260:                   pIdent
3262:                | * :
3267:                   >
3269:             ]
3269:          }
3271:          ':'
3273:          Node theType
3273:          @TypeRef( theType )
      
3280:          int i = 0
3286:          {[ equal( i, oNodeVecSize( decls ) )
3300:             | false :
3301:                decl = oNodeVecElement( decls, i )
3314:                oNodeSet( decl, qType, theType )
3326:                oScopeDeclareAlloc( decl )
3332:                inc( i )
3338:             | * :
3343:               >
3345:          ]}
      
               % optional initialization
3347:          [
3347:             | '=' :
3349:                [ oNodeVecSize( decls )
3356:                   | 1 :
3357:                   | * :  #eOnlyOneVarCanBeInitialized
3364:                ]
      
                     % we need an initCode stream for this scope
3364:                Code initCode = @GetOrCreateInitCode( oScopeCurrent )
3374:                oCodePush( initCode )
      
                     % currently the global level has two scopes:
                     % the one for declarations e.g. vars and methods,
                     % and a second one for temporaries needed by the main block stmt.
                     % During evaluation of the init expr, we need to be in the 2nd scope
                     % in case the expression requires temporaries
                     % (so the temporaries get allocated in the right scope).
                     % TO DO: Maybe I should make the global scope the special case, instead.
3380:                boolean changedScope = false
3386:                [ equal_zero( @ScopeLevel )
3393:                   | true : oScopeEnter( initScope )
3400:                            changedScope = true
3406:                   | * :
3411:                ]
                     % generate assignment in initCode stream
3411:                @LValueVar( decl, true )
3421:                @Expr
3423:                @CoerceType
3425:                @Assign
3427:                [ changedScope
3430:                   | true : oScopeEnd
3432:                   | * :
3437:                ]
3437:                oCodePop
                   
3438:             | * :
3443:          ]
      
3443:          oNodeVecDelete( decls )
3449:          ';'
3451:       | * :
3456:          >
3458:    ]};
      
      
      % Parse a list of label declarations.
      % We'll create a tcode label at declaration time, for each user label.
      % If the user label is an integer, we'll record it as _label_<int> in the decl.
      %
3461: LabelDecl:
3463:    {
3463:       Node decl
3463:       [
3463:          | pIdent :
3465:          | pIntLit :
                  % Replace token with identifier "_label_<intlit>"
3467:             oChangeIntLitToLabelIdent
3468:       ]
3476:       decl = @newIdent( nLabel, LAST_ID )
            % TO DO: ensure not already declared in this scope.
            %        Or maybe that can be part of oScopeDeclare.
3489:       Label label = oLabelNew
3494:       oNodeSetLabel( decl, qValue, label )
3506:       oScopeDeclare( decl )
3512:       [
3512:          | ',' :
3514:          | * :
3519:             >
3521:       ]
3521:    }
3523:    ';'
3526:    ;
3526: include 'pascal_constexpr.ssl'
      %
      % Pascal Compiler
      %
      
      % --------------------------- Const Expressions --------------------------
      
      
      % Constant expressions are evaluated at compile time.
      % They are limited to constant literals, declared constants (not including TypedConstants!)
      % and a small selection of built-in functions. 
      %
      % The value of a constant expression is left on the Value Stack.
      % The type is left on the Type Stack.
      
3526: ConstExpr:
3528:    @ConstBoolExpr
3530:    {[
3530:       | '=' :
3532:          @ConstBoolTerm
3534:          @ConstMatchTypes
3536:          [ oTypeSNodeType
3538:             | nStrLitType :   oValueStringCmp  oValuePush( 0 )  oValueEqual
3547:             | * :             oValueEqual
3553:          ]
3553:          oTypeSPop  oTypeSPush( BooleanType )
3560:       | '<>' :
3562:          @ConstBoolExpr
3564:          @ConstMatchTypes
3566:          [ oTypeSNodeType
3568:             | nStrLitType :   oValueStringCmp  oValuePush( 0 )  oValueNotEqual
3577:             | * :             oValueNotEqual
3583:          ]
3583:          oTypeSPop  oTypeSPush( BooleanType )
3590:       | '<' :
3592:          @ConstBoolExpr
3594:          @ConstMatchTypes
3596:          [ oTypeSNodeType
3598:             | nStrLitType :   oValueStringCmp  oValuePush( 0 )  oValueLess
3607:             | * :             oValueLess
3613:          ]
3613:          oTypeSPop  oTypeSPush( BooleanType )
3620:       | '>' :
3622:          @ConstBoolExpr
3624:          @ConstMatchTypes
3626:          [ oTypeSNodeType
3628:             | nStrLitType :   oValueStringCmp  oValuePush( 0 )  oValueGreater
3637:             | * :             oValueGreater
3643:          ]
3643:          oTypeSPop  oTypeSPush( BooleanType )
3650:       | '<=' :
3652:          @ConstBoolExpr
3654:          @ConstMatchTypes
3656:          [ oTypeSNodeType
3658:             | nStrLitType :   oValueStringCmp  oValuePush( 0 )  oValueLessEqual
3667:             | * :             oValueLessEqual
3673:          ]
3673:          oTypeSPop  oTypeSPush( BooleanType )
3680:       | '>=' :
3682:          @ConstBoolExpr
3684:          @ConstMatchTypes
3686:          [ oTypeSNodeType
3688:             | nStrLitType :   oValueStringCmp  oValuePush( 0 )  oValueGreaterEqual
3697:             | * :             oValueGreaterEqual
3703:          ]
3703:          oTypeSPop  oTypeSPush( BooleanType )
3710:       | * :  >
3727:    ]};
      
      
3730: ConstBoolExpr:
3732:    @ConstBoolTerm
3734:    {[
3734:       | pOr :
3736:          @ConstRequireBool
3738:          @ConstBoolTerm
3740:          @ConstRequireBoolPop
3742:          oValueOr
3743:       | * :  >
3750:    ]};
      
      
3753: ConstBoolTerm:
3755:    @ConstBoolFactor
3757:    {[
3757:       | pAnd :
3759:          @ConstRequireBool
3761:          @ConstBoolFactor
3763:          @ConstRequireBoolPop
3765:          oValueAnd
3766:       | * :  >
3773:    ]};
      
      
3776: ConstBoolFactor:
3778:    [
3778:       | pNot :
3780:          @ConstBoolFactor
3782:          @ConstRequireBool
3784:          oValueNot
3785:       | * :
3790:          @ConstArithExpr
3792:    ];
      
      
3793: ConstArithExpr:
3795:    @ConstTerm
3797:    {[
3797:       | '+' :
3799:          @ConstTerm
3801:          @ConstMatchTypes
3803:          [ oTypeSNodeType
3805:             | nStrLitType :   oValueStringConcat
3807:             | * :             oValueAdd
3813:          ]
3813:       | '-' :
3815:          @ConstTerm
3817:          @ConstMatchTypes
3819:          [ oTypeSNodeType
3821:             | nStrLitType :   #eNotAllowed
3824:             | * :             oValueSub
3830:          ]
3830:       | * :  >
3839:    ]};
      
      
3842: ConstTerm:
3844:    @ConstFactor
3846:    {[
3846:       | pTimes :
3848:          @ConstFactor
3850:          @ConstMatchTypes
3852:          [ oTypeSNodeType
3854:             | nStrLitType :   #eNotAllowed
3857:             | * :             oValueMult
3863:          ]
3863:       | pDivide :
3865:          @ConstFactor
3867:          @ConstMatchTypes
3869:          [ oTypeSNodeType
3871:             | nStrLitType :   #eNotAllowed
3874:             | * :             oValueDiv
3880:          ]
3880:       | * :  >
3889:    ]};
      
      
3892: ConstFactor:
3894:    [
3894:       | pPlus :
3896:          @ConstPrimary
3898:       | pMinus :
3900:          @ConstPrimary
3902:          oValueNegate
3903:       | * :
3910:          @ConstPrimary
3912:    ];
      
      
3913: ConstPrimary:
3915:    [
3915:       | pIntLit :
3917:          oValuePush( TOKEN_VALUE )
3922:          oTypeSPush( IntegerType )
3928:       | pCharLit :
3930:          oValuePush( TOKEN_VALUE )
3935:          oTypeSPush( CharType )
3941:       | pStrLit :
3943:          oValuePushString( CURRENT_STRLIT )
3948:          oTypeSPush( StrLitType )
3954:       | '(' :
3956:          @ConstExpr
3958:          ')'
3960:       | pIdent :
3962:          Node decl = oScopeFindRequire
3967:          @ResolveUnitRef( decl )
3974:          [ oNodeType( decl )
3981:             | nBuiltInFunc :
3982:                @ConstBuiltInFunc( decl )
3989:             | nConst :
3991:                oValuePush( oNodeGetInt( decl, qValue ) )
4004:                oTypeSPush( oNodeGet( decl, qType ) )
4017:             | nConstStr :
4019:                oValuePushString( oNodeGetString( decl, qValueStr ) )
4032:                oTypeSPush( oNodeGet( decl, qType ) )
4045:             | nEnumValue :
4047:                oValuePush( oNodeGetInt( decl, qValue ) )
4060:                oTypeSPush( oNodeGet( decl, qType ) )
4073:             | * :
4084:                #eNotConst
4086:                oValuePush( 0 )
4092:                oTypeSPush( IntegerType )
4098:          ]
4098:       | '@' :
4100:          #eNotImplemented
4102:          oValuePush( 0 )
4108:          oTypeSPush( UniversalPointerType )
4114:       | * :
4129:          #eNotConst
4131:          oValuePush( 0 )
4137:          oTypeSPush( IntegerType )
4143:    ];
      
4144: ConstRequireBoolPop:
4146:    [ oTypeSNodeType
4148:       | nBooleanType :
4149:       | * :          #eNotBoolean
4156:    ]
4156:    oTypeSPop;
      
      
4158: ConstRequireBool:
4160:    [ oTypeSNodeType
4162:       | nBooleanType :
4163:       | * :          #eNotBoolean
4170:    ];
      
      
      % Require that the top two types on the type stack are matching (ignoring subranges).
      % Pop one of them, leaving only one.
      % The types refer to constant values on the Value Stack,
      % so any implicit conversion would occur there, not in code.
      %
      % Some implicit conversion is allowed for either of the types.
      % See also ConstCoerceType where only the top type may change.
      %
4171: ConstMatchTypes:
4173:    node_type nt = oTypeSNodeType
4178:    oTypeSPop
4179:    [ equal_node_type( nt, oTypeSNodeType )
4188:       | false :
               % Some implicit conversion is allowed even here
4189:          [ oTypeSNodeType
4191:             | nPointerType :
4192:                [ nt
4195:                   | nUniversalPointerType :  >>
4197:                   | * :
4202:                ]
4202:             | nUniversalPointerType :
4204:                [ nt
4207:                   | nPointerType :  >>
4209:                   | * :
4214:                ]
4214:             | nStrLitType :
4216:                [ nt
4219:                   | nCharType :
4220:                      oValueCharToString
4221:                      >>
4222:                   | * :
4227:                ]
4227:             | nCharType :
4229:                [ nt
4232:                   | nStrLitType :
4233:                      oValueSwap
4234:                      oValueCharToString
4235:                      oValueSwap
4236:                      oTypeSPop
4237:                      oTypeSPush( StrLitType )
4243:                      >>
4244:                   | * :
4249:                ]
4249:             | * :
4260:          ]
4260:          #eTypeMismatch
4262:       | * :
4267:    ];
      
      
      % Given a constant value on the value stack, its type on the type stack,
      % and the desired type under it on the type stack.
      % Perform any necessary implicit conversions so the value is the desired type.
      % Pop the top type, leaving only the desired type.
      %
4268: ConstCoerceType:
4270:    node_type nt = oTypeSNodeType
4275:    oTypeSPop
4276:    [ equal_node_type( nt, oTypeSNodeType )
4285:       | false :
               % Some implicit conversion is allowed even here
4286:          [ oTypeSNodeType
4288:             | nPointerType :
4289:                [ nt
4292:                   | nUniversalPointerType :  >>
4294:                   | * :
4299:                ]
4299:             | nUniversalPointerType :
4301:                [ nt
4304:                   | nPointerType :  >>
4306:                   | * :
4311:                ]
4311:             | nStrLitType :
4313:                [ nt
4316:                   | nCharType :
4317:                      oValueCharToString
4318:                      >>
4319:                   | * :
4324:                ]
4324:             | nShortStringType :
4326:                [ nt
4329:                   | nStrLitType :  >>
4331:                   | nCharType :
4333:                      oValueCharToString
4334:                      >>
4335:                   | * :
4342:                ]
4342:             | * :
4353:          ]
4353:          #eTypeMismatch
4355:       | * :
4360:    ];
      
      
      % These are the methods that Pascal allows in a constant expression:
      %   Abs( x: integer_or_real ) : integer_or_real
      %   Round( x: real ) : integer
      %   Trunc( x: real ) : integer
      %   Chr( x: integer ) : char
      %   Ord( x: ordinal ) : integer
      %   Length( s: string ) : integer
      %   Pred( x: ordinal ) : ordinal
      %   Succ( x: ordinal ) : ordinal
      %   SizeOf( var, expr, or typename ) : integer
      %   Odd( x: integer ) : boolean  - true if the argument is odd
      %
4361: ConstBuiltInFunc( Node method ):
      
         % Ord(x)
4363:    [ oNodeEqual( method, BuiltIn_Ord )
4373:       | true :
4374:          '('
4376:          @ConstExpr
4378:          ')'
4380:          [ oTypeSNodeType
4382:             | nIntegerType, nEnumType :
4383:             | nBooleanType, nByteType, nCharType :
4385:             | * :  #eTypeMismatch
4400:          ]
4400:          oTypeSPop
4401:          oTypeSPush( IntegerType )
4407:          ')'
4409:          >>
4410:       | * :
4415:    ]
      
         % Chr(x)
4415:    [ oNodeEqual( method, BuiltIn_Chr )
4425:       | true :
4426:          '('
4428:          @ConstExpr
4430:          ')'
4432:          [ oTypeSNodeType
4434:             | nIntegerType :
4435:             | nByteType :
4437:             | * :  #eTypeMismatch
4446:          ]
4446:          oTypeSPop
4447:          oTypeSPush( CharType )
4453:          ')'
4455:          >>
4456:       | * :
4461:    ]
      
         % Pred(x)
4461:    [ oNodeEqual( method, BuiltIn_Pred )
4471:       | true :
4472:          '('
4474:          @ConstExpr
4476:          [ oTypeSNodeType
4478:             | nEnumType :
4479:                [ oNodeGetBoolean( oTypeSTop, qHasGap )
4488:                   | true :   #eCantUsePredSuccOnEnumWithValueGaps
4491:                   | * :
4496:                ]
4496:             | * :  #eTypeMismatch
4503:          ]
4503:          oValuePush( 1 )  oValueSub
4510:          ')'
4512:          >>
4513:       | * :
4518:    ]
      
         % Succ(x)
4518:    [ oNodeEqual( method, BuiltIn_Succ )
4528:       | true :
4529:          '('
4531:          @ConstExpr
4533:          [ oTypeSNodeType
4535:             | nEnumType :
4536:                [ oNodeGetBoolean( oTypeSTop, qHasGap )
4545:                   | true :   #eCantUsePredSuccOnEnumWithValueGaps
4548:                   | * :
4553:                ]
4553:             | * :  #eTypeMismatch
4560:          ]
4560:          oValuePush( 1 )  oValueAdd
4567:          ')'
4569:          >>
4570:       | * :
4575:    ]
      
4575:    #eNotImplemented
4578:    ;
      
      
4578: include 'pascal_expr.ssl'
      %
      % Pascal Compiler
      %
      
      
      % ------------------------------ Expressions -----------------------------
      
      
      % There are two wrappers leading into expression parsing:
      %   Expr()
      %   BooleanExprControlFlow( out Label falseLabel )
      %
      % Expr always produces a value on the runtime expr stack,
      % and pushes its type on the type stack.
      %
      % BooleanExprControlFlow always generates control-flow code.
      % It does not push a value on the runtime expr stack.
      % It does not push a type on the type stack.
      % The control flow code ends up at Here if the expr is true,
      % and jumps to falseLabel if the expr is false.
      % This rule allocates falseLabel, and passes it back.
      % The caller will need to define its location.
      %
      % The internal methods of expr parsing may produce a mix of
      % values and control flow, depending on the operators seen.
      % We don't always do one or the other, hoping to be efficient for
      % cases like   "func_call( bool_var1, bool_var2 )"
      % as well as  "if bool_expr1 or bool_expr2 then ...".
      % If a subexpression rule produces control flow, it will allocate a
      % falseLabel and pass it back up.  And it will push the
      % result type as BooleanFlowType, to distinguish from BooleanType
      % which corresponds with a boolean value on the expr stack.
      % 
      % Note that my expression parsing is broken into more levels than
      % grammars describe for Pascal precedence levels.  This follows my
      % original parser implementation.  I think my rationale was that
      % operators from the levels that I split up couldn't have been
      % mixed anyway, since they require different data types
      % (e.g. boolean vs int/real).  And splitting them up simplified
      % my code.  But, I should revisit this.
      %
      
      
      % Public entry point:
      %
      % Parse an expression, leaving a value on the runtime expr stack
      % and its type on the type stack.
      %
      % This rule does not export control flow (though it may generate
      % control flow internally for subexpressions).
      %
4578: Expr:
4580:    Label falseLabel = labelNull
      
4586:    @ExprAllowFlow( falseLabel )
4593:    @FlowToVal( falseLabel );
      
      
      % Public entry point:
      %
      % Parse a Boolean expression, producing control flow code rather than a value.
      % Does not leave a value on the runtime expr stack.
      % Does not leave a type on the type stack.
      %
      % If the expression is true, the code will fall through to the end (Here).
      % If the expression is false, the code will jump to the given falseLabel,
      % which this rule will allocate but not define the location for.
      % The caller must do so.
      %
4601: BooleanExprControlFlow( out Label falseLabel ):
4603:    @ExprAllowFlow( falseLabel )
4610:    [ oTypeSNodeType
4612:       | nBooleanFlowType :
4613:       | nBooleanType :
               % convert value to control flow
4615:          falseLabel = oLabelNew
4620:          .tJumpFalse  oEmitLabel( falseLabel )
4628:       | * :
4635:          #eNotBoolean
4637:    ]
4637:    oTypeSPop;
      
      
      % If the current expr result is control flow, convert it to a value.
      % falseLabel is the label that had been used by the control flow.
      % On return it will be set to labelNull.
      %
4639: FlowToVal( inout Label falseLabel ):
4641:    [ oTypeSNodeType
4643:       | nBooleanFlowType :
4644:          Label doneLabel = oLabelNew
4649:          .tPushConstI  oEmitInt( 1 )
4657:          .tJump  oEmitLabel( doneLabel )
4665:          .tLabel  oEmitLabel( falseLabel )
4673:          .tPushConstI  oEmitInt( 0 )
4681:          .tLabel  oEmitLabel( doneLabel )
4689:          oTypeSPop
4690:          oTypeSPush( BooleanType )
4696:          falseLabel = labelNull
4702:       | * :
4707:    ];
      
      
      % If the current expr result is boolean value, convert it to control flow.
      % falseLabel will be allocated by this rule and passed back.
      % The caller must define its location.
      %
4708: ValToFlow( out Label falseLabel ):
4710:    [ oTypeSNodeType
4712:       | nBooleanType :
4713:          falseLabel = oLabelNew
4718:          .tJumpFalse  oEmitLabel( falseLabel )
4726:          oTypeSPop
4727:          oTypeSPush( BooleanFlowType )
4733:       | * :
4738:    ];
      
      
      % Parse an expression.  It may produce a value on the expr stack,
      % or control flow, depending on what's seen in the expression.
      % Leaves the expression type on the type stack.
      %
      % If the expression produces control flow, the expression type will be
      % nBooleanFlowType.  In this case, a true value falls through to Here,
      % and a false value jumps to falseLabel.  This rule will allocate falseLabel
      % and return it, but will not define its location; the caller must do so.
      %
      % If the expression produces a value, the value will be left on the
      % expression stack, and the type will be some type other than nBooleanFlowType.
      % In this case, falseLabel is ignored.
      %
4739: ExprAllowFlow( out Label falseLabel ):
4741:    @BoolExprAllowFlow( falseLabel )
4748:    {[
4748:       | '=' :
4750:          @FlowToVal( falseLabel )
4757:          @PromoteToIntOptional
4759:          @BoolExprAllowFlow( falseLabel )
4766:          @FlowToVal( falseLabel )
4773:          @PromoteToIntOptional
4775:          @MatchTypes
4777:          [ oTypeSNodeType
4779:             | nBooleanType, nCharType :     .tEqualB
4782:             | nIntegerType, nEnumType :     .tEqualI
4786:             | nPointerType, nUniversalPointerType :    .tEqualP
4790:             | nShortStringType, nStrLitType :
4792:                @ShortStringCmp  .tPushConstI  oEmitInt( 0 )  .tEqualI
4804:             | * :                           #eNotAllowed
4825:          ]
4825:          oTypeSPop
4826:          oTypeSPush( BooleanType )
      
4832:       | '<>' :
4834:          @FlowToVal( falseLabel )
4841:          @PromoteToIntOptional
4843:          @BoolExprAllowFlow( falseLabel )
4850:          @FlowToVal( falseLabel )
4857:          @PromoteToIntOptional
4859:          @MatchTypes
4861:          [ oTypeSNodeType
4863:             | nBooleanType, nCharType :     .tNotEqualB
4866:             | nIntegerType, nEnumType :     .tNotEqualI
4870:             | nPointerType, nUniversalPointerType :    .tNotEqualP
4874:             | nShortStringType, nStrLitType :
4876:                @ShortStringCmp  .tPushConstI  oEmitInt( 0 )  .tNotEqualI
4888:             | * :                           #eNotAllowed
4909:          ]
4909:          oTypeSPop
4910:          oTypeSPush( BooleanType )
      
4916:       | '<' :
4918:          @FlowToVal( falseLabel )
4925:          @PromoteToIntOptional
4927:          @BoolExprAllowFlow( falseLabel )
4934:          @FlowToVal( falseLabel )
4941:          @PromoteToIntOptional
4943:          @MatchTypes
4945:          [ oTypeSNodeType
4947:             | nBooleanType, nCharType :     .tLessB
4950:             | nIntegerType, nEnumType :     .tLessI
4954:             | nPointerType, nUniversalPointerType :   .tLessP
4958:             | nShortStringType, nStrLitType :
4960:                @ShortStringCmp  .tPushConstI  oEmitInt( 0 )  .tLessI
4972:             | * :                           #eNotAllowed
4993:          ]
4993:          oTypeSPop
4994:          oTypeSPush( BooleanType )
      
5000:       | '>' :
5002:          @FlowToVal( falseLabel )
5009:          @PromoteToIntOptional
5011:          @BoolExprAllowFlow( falseLabel )
5018:          @FlowToVal( falseLabel )
5025:          @PromoteToIntOptional
5027:          @MatchTypes
5029:          [ oTypeSNodeType
5031:             | nBooleanType, nCharType :     .tGreaterB
5034:             | nIntegerType, nEnumType :     .tGreaterI
5038:             | nPointerType, nUniversalPointerType :   .tGreaterP
5042:             | nShortStringType, nStrLitType :
5044:                @ShortStringCmp  .tPushConstI  oEmitInt( 0 )  .tGreaterI
5056:             | * :                           #eNotAllowed
5077:          ]
5077:          oTypeSPop
5078:          oTypeSPush( BooleanType )
      
5084:       | '<=' :
5086:          @FlowToVal( falseLabel )
5093:          @PromoteToIntOptional
5095:          @BoolExprAllowFlow( falseLabel )
5102:          @FlowToVal( falseLabel )
5109:          @PromoteToIntOptional
5111:          @MatchTypes
5113:          [ oTypeSNodeType
5115:             | nBooleanType, nCharType :     .tLessEqualB
5118:             | nIntegerType, nEnumType :     .tLessEqualI
5122:             | nPointerType, nUniversalPointerType :   .tLessEqualP
5126:             | nShortStringType, nStrLitType :
5128:                @ShortStringCmp  .tPushConstI  oEmitInt( 0 )  .tLessEqualI
5140:             | * :                           #eNotAllowed
5161:          ]
5161:          oTypeSPop
5162:          oTypeSPush( BooleanType )
      
5168:       | '>=' :
5170:          @FlowToVal( falseLabel )
5177:          @PromoteToIntOptional
5179:          @BoolExprAllowFlow( falseLabel )
5186:          @FlowToVal( falseLabel )
5193:          @PromoteToIntOptional
5195:          @MatchTypes
5197:          [ oTypeSNodeType
5199:             | nBooleanType, nCharType :     .tGreaterEqualB
5202:             | nIntegerType, nEnumType :     .tGreaterEqualI
5206:             | nPointerType, nUniversalPointerType :   .tGreaterEqualP
5210:             | nShortStringType, nStrLitType :
5212:                @ShortStringCmp  .tPushConstI  oEmitInt( 0 )  .tGreaterEqualI
5224:             | * :                           #eNotAllowed
5245:          ]
5245:          oTypeSPop
5246:          oTypeSPush( BooleanType )
      
5252:       | * :
5267:          >
5269:    ]};
      
      
5272: BoolExprAllowFlow( out Label falseLabel ):
5274:    Label trueLabel = labelNull
      
5280:    @BoolTermAllowFlow( falseLabel )
5287:    {[
5287:       | pOr :
5289:          [ oTypeSNodeType
5291:             | nBooleanFlowType :
                     % We are true here. Jump ahead to done
5292:                [ equal_label( trueLabel, labelNull )
5302:                   | true :  trueLabel = oLabelNew
5308:                   | * :
5313:                ]
5313:                .tJump  oEmitLabel( trueLabel )
5321:             | nBooleanType :
5323:                @ValToFlow( falseLabel )
                     % We are true here. Jump ahead to done
5330:                [ equal_label( trueLabel, labelNull )
5340:                   | true :  trueLabel = oLabelNew
5346:                   | * :
5351:                ]
5351:                .tJump  oEmitLabel( trueLabel )
5359:             | * : #eNotBoolean
5368:          ]
5368:          oTypeSPop
      
               % false in previous term will jump here, to try this alternative term
5369:          .tLabel  oEmitLabel( falseLabel )
      
               % we'll get a new falseLabel for this term
5377:          falseLabel = labelNull
5383:          @BoolTermAllowFlow( falseLabel )
      
5390:          [ oTypeSNodeType
5392:             | nBooleanFlowType :
5393:             | nBooleanType :
5395:                @ValToFlow( falseLabel )
5402:             | * : #eNotBoolean
5411:          ]
      
5411:          oTypeSPop
5412:          oTypeSPush( BooleanFlowType )
      
5418:       | * :
5423:          >
5425:    ]}
      
         % any short-circuit trues jump here to the end
5427:    [ equal_label( trueLabel, labelNull )
5437:       | false :
5438:          .tLabel  oEmitLabel( trueLabel )
5446:       | * :
5451:    ]
5452:    ;
      
      
5452: BoolTermAllowFlow( out Label falseLabel ):
5454:    Label overallFalseLabel = labelNull
      
5460:    @BoolFactorAllowFlow( falseLabel )
5467:    {[
5467:       | pAnd :
5469:          [ oTypeSNodeType
5471:             | nBooleanFlowType :
5472:             | nBooleanType :
5474:                @ValToFlow( falseLabel )
5481:             | * :
5488:                #eNotBoolean
5490:          ]
5490:          oTypeSPop
      
               % We're going to have a different falseLabel for each term,
               % because we let each rule allocate its own (rather than accepting labels passed in).
               % And in this case we want them all to go to the same place,
               % to be determined by the caller.
               %
               % I'll allow for label aliases.  This will be more optimal than generating
               % multiple private false-handling code segments, that the true path would have to
               % jump around.  That would be hard to eliminate afterwards.
      
5491:          [ equal_label( overallFalseLabel, labelNull )
5501:             | true :
5502:                overallFalseLabel = oLabelNew
5507:                .tLabelAlias  oEmitLabel( falseLabel )  oEmitLabel( overallFalseLabel )
5521:                falseLabel = overallFalseLabel
5527:             | * :
5532:          ]
      
5532:          Label factorFalseLabel = labelNull
5538:          @BoolFactorAllowFlow( factorFalseLabel )
      
5545:          [ oTypeSNodeType
5547:             | nBooleanFlowType :
5548:             | nBooleanType :
5550:                @ValToFlow( factorFalseLabel )
5557:             | * : #eNotBoolean
5566:          ]
5566:         .tLabelAlias  oEmitLabel( factorFalseLabel )  oEmitLabel( overallFalseLabel )
      
5580:       | * :
5585:          >
5587:    ]};
      
      
5590: BoolFactorAllowFlow( out Label falseLabel ):
5592:    [
5592:       | pNot :
5594:          Label factorFalseLabel = labelNull
      
5600:          @BoolFactorAllowFlow( factorFalseLabel )
5607:          [ oTypeSNodeType
5609:             | nBooleanFlowType :
                     % We have control flow, and are sitting at the point that has value false.
5610:                falseLabel = oLabelNew
5615:                .tJump  oEmitLabel( falseLabel )
                     % The true path jumps here
5623:                .tLabel  oEmitLabel( factorFalseLabel )
      
5631:             | nBooleanType :
                     % I have a value.  I'll leave it as a value, rather than create control flow.
                     % See how this goes.
5633:                .tNot
      
5635:             | * : #eNotBoolean
5644:          ]
      
5644:       | * :
5649:          @ArithExprAllowFlow( falseLabel )
5656:    ];
      
      
5657: ArithExprAllowFlow( out Label falseLabel ):
5659:    boolean first = true
5665:    int tempStrOffset
      
5665:    @TermAllowFlow( falseLabel )
5672:    {[
5672:       | '+' :
5674:          [ oTypeSNodeType
5676:             | nIntegerType, nByteType :
5677:                @PromoteToIntPop
5679:                @TermAllowFlow( falseLabel )  % actually not allowing CF, will be caught by type check
      
5686:                [ oTypeSNodeType
5688:                   | nPointerType, nUniversalPointerType :
                           % int + ptr
5689:                      .tSwap
                           % leave only the ptr type on the type stack (int was already popped above)
5691:                      @PointerAddition
5693:                   | * :
5700:                      @PromoteToInt
5702:                      .tAddI
5704:                ]
      
5704:             | nShortStringType, nStrLitType, nCharType :
                     % String concatenation
5706:                [ first
5709:                   | true :  % move into a temp string, so subsequent term(s) can further modify it.
5710:                             tempStrOffset = @MoveIntoTempShortString
5716:                             first = false
5722:                   | * :
5727:                ]
5727:                @TermAllowFlow( falseLabel )  % actually not allowing CF, will be caught by type check
5734:                [ oTypeSNodeType
5736:                   | nShortStringType, nStrLitType :
5737:                      @ShortStringAppendShortString
                           % Have to re-push the temp string.
                           % If we ever have .tDup then the append method could do it and we wouldn't need this
5739:                      .tPushAddrLocal  oEmitInt( tempStrOffset )
5747:                      oTypeSPush( ShortStringType )
5753:                   | nCharType :
5755:                      @ShortStringAppendChar
                           % Have to re-push the temp string.
                           % If we ever have .tDup then the append method could do it and we wouldn't need this
5757:                      .tPushAddrLocal  oEmitInt( tempStrOffset )
5765:                      oTypeSPush( ShortStringType )
5771:                   | * :
5780:                      #eTypeMismatch
5782:                      oTypeSPop
5783:                ]
      
5783:             | nPointerType, nUniversalPointerType :
5785:                @TermAllowFlow( falseLabel )   % actually not allowing CF
5792:                @PromoteToIntPop
5794:                @PointerAddition
      
5796:             | * :
5813:                #eNotAllowed
5815:          ]
      
5815:       | '-' :
5817:          [ oTypeSNodeType
5819:             | nIntegerType, nByteType :
5820:                @PromoteToIntPop
5822:                @TermAllowFlow( falseLabel )
5829:                @PromoteToInt
5831:                .tSubI
      
5833:             | nPointerType, nUniversalPointerType :
5835:                @TermAllowFlow( falseLabel )
5842:                [ oTypeSNodeType
5844:                   | nIntegerType, nByteType :
5845:                      @PromoteToIntPop
5847:                      @PointerSubInt
5849:                   | nPointerType, nUniversalPointerType :
5851:                      @MatchTypes
5853:                      @PointerSubPointer
5855:                   | * :
5866:                      #eNotAllowed
5868:                ]
      
5868:             | * :  #eNotAllowed
      
5881:          ]
5881:       | * :
5888:          >
5890:    ]};
      
      
5893: TermAllowFlow( out Label falseLabel ):
5895:    @FactorAllowFlow( falseLabel )
5902:    {[
5902:       | pTimes :
5904:          @PromoteToIntPop
5906:          @FactorAllowFlow( falseLabel )  % actually not allowing CF, will be caught by type check
5913:          @PromoteToInt
5915:          .tMultI
5917:       | pDivide :
5919:          @PromoteToIntPop
5921:          @FactorAllowFlow( falseLabel )
5928:          @PromoteToInt
5930:          .tDivI
5932:       | * :
5939:          >
5941:    ]};
      
      
5944: FactorAllowFlow( out Label falseLabel ):
5946:    [
5946:       | pPlus :
5948:          @PrimaryAllowFlow( falseLabel )  % actually not allowing CF, will be caught by type check
               % TO DO: unary +/- is supposed to leave expression type as-is.
5955:          @PromoteToInt
5957:       | pMinus :
5959:          @PrimaryAllowFlow( falseLabel )
               % TO DO: unary +/- is supposed to leave expression type as-is.
5966:          @PromoteToInt
5968:          .tNegI
5970:       | * :
5977:          @PrimaryAllowFlow( falseLabel )
5984:    ];
      
      
5985: PrimaryAllowFlow( out Label falseLabel ):
5987:    [
5987:       | pIntLit :
5989:          .tPushConstI  oEmitInt( TOKEN_VALUE )
5996:          oTypeSPush( IntegerType )
      
6002:       | pCharLit :
6004:          .tPushConstI  oEmitInt( TOKEN_VALUE )
6011:          oTypeSPush( CharType )
      
6017:       | '(' :
6019:          @ExprAllowFlow( falseLabel )
6026:          ')'
      
6028:       | pStrLit :
6030:          int addr = oStringAllocShortStringLit( CURRENT_STRLIT )     % store in global data
6039:          .tPushAddrGlobal oEmitInt( addr )
               % TO DO: consider defining a ShortString type with the exact capacity used.
               % But, I don't think it should matter here, since nobody should be assigning to this string.
6047:          oTypeSPush( StrLitType )
               % This seems unlikely, but the strlit may be followed by
               % array indexing.  Handle this the same way we would with a variable expression (see VarExpr)
               % First, advance the pointer by index if any
6053:          @LValueIndexes
               % get final value of dereferencing, if any
6055:          @FetchVar
      
6057:       | pIdent :
6059:          Node decl = oScopeFindRequire
6064:          @ResolveUnitRef( decl )
6071:          Node theType
      
6071:          [ oNodeType( decl )
6078:             | nFunc :
6079:                @Call( decl )
      
6086:             | nBuiltInFunc :
6088:                @CallBuiltInFunc( decl )
      
6095:             | nConst, nEnumValue :
6097:                theType = oNodeGet( decl, qType )
6110:                oTypeSPush( theType )
6116:                [ oTypeSNodeType
6118:                   | nIntegerType, nEnumType, nBooleanType :
6119:                      .tPushConstI @EmitValue( decl )
6128:                   | nPointerType, nUniversalPointerType :
                           % We have one pointer const, Nil.  It's pushed as I.
                           % Sign-extending I to P won't hurt since it's 0.
6130:                      .tPushConstI @EmitValue( decl )
6139:                   | * :
6152:                      #eNotImplemented
6154:                ]
      
6154:             | nConstStr :
                     % This is a non-typed const defined as a strlit.
                     % So far, the value is held in the compiler's symbol table.
                     % Referencing the constant in the code will work the same as directly giving a strlit.
                     % (See pStrLit above).  We store the strlit in global memory, and set expr type to StrLitType.
      
                     % Storage in global memory only happens the first time the const is referenced.
                     % The global offset is stored in qValue.
6156:                int addr = oNodeGetInt( decl, qValue )
6169:                [ equal_zero( addr )
6176:                   | true :
6177:                      addr = oStringAllocShortStringLit( oNodeGetString( decl, qValueStr ) )
6194:                      oNodeSetInt( decl, qValue, addr )
6206:                   | * :
6211:                ]
6211:                .tPushAddrGlobal oEmitInt( addr )
6219:                oTypeSPush( StrLitType )
                     % This seems unlikely, but the strlit may be followed by
                     % array indexing.  Handle this the same way we would with a variable expression (see VarExpr)
                     % First, advance the pointer by index if any
6225:                @LValueIndexes
                     % get final value of dereferencing, if any
6227:                @FetchVar
      
6229:             | nGlobalVar, nLocalVar, nParam, nTypedConst :
6231:                @VarExpr( decl )
      
6238:             | * :
6259:                #eNotValue
6261:                oTypeSPush( IntegerType )
6267:          ]
      
6267:       | '@' :        % @var -- pointer to var
6269:          pIdent
      
6271:          Node decl = oScopeFindRequire
6276:          @ResolveUnitRef( decl )
6283:          Node theType
      
               % writeable is false because we're not on the left hand side of an assignment,
               % or passign into a var parameter.  So it's ok to take the address of a typed const.
6283:          @LValueVar( decl, false )
      
               % The above leaves the pointed-to type on type stack.
               % Replace with ptr-to-<type>.
6293:          theType = oTypeSTop
6298:          oTypeSPop
6299:          Node ptrType = @PointerTypeTo( theType )
6310:          oTypeSPush( ptrType )
      
6316:       | * :
6331:          #eNotValue
6333:          oTypeSPush( IntegerType )
6339:    ];
      
      
      % Parse a variable expression, given the declaration of the
      % just-accepted identifier.
      % Leaves the value on the expression stack, and type on the type stack.
      %
6340: VarExpr( Node decl ):
6342:    Node theType = oNodeGet( decl, qType )
         % how many levels up the static scope? Will ignore for globals.
6355:    int uplevels = @DeclUpLevels( decl )
      
6366:    oTypeSPush( theType )
6372:    [ oTypeSNodeType
6374:       | nIntegerType, nEnumType :
6375:          [ oNodeType( decl )
6382:             | nGlobalVar, nTypedConst :   .tPushGlobalI  @EmitValue( decl )
6392:             | nLocalVar :
6394:                [ equal_zero( uplevels )
6401:                   | true :  .tPushLocalI  @EmitValue( decl )
6411:                   | * :     .tPushUpLocalI  oEmitInt( uplevels )  @EmitValue( decl )
6431:                ]
6431:             | nParam :
6433:                [ oNodeGetBoolean( decl, qInOut )
6443:                   | true :    % VAR param points to the var.  Auto dereference.
6444:                      [ equal_zero( uplevels )
6451:                         | true :  .tPushParamP  @EmitValue( decl )
6461:                         | * :     .tPushUpParamP  oEmitInt( uplevels )  @EmitValue( decl )
6481:                      ]
6481:                      .tFetchI
6483:                   | * :
6488:                      [ equal_zero( uplevels )
6495:                         | true :  .tPushParamI  @EmitValue( decl )
6505:                         | * :     .tPushUpParamI  oEmitInt( uplevels )  @EmitValue( decl )
6525:                      ]
6525:                ]
6525:          ]
      
6537:       | nBooleanType, nByteType, nCharType :
6539:          [ oNodeType( decl )
6546:             | nGlobalVar, nTypedConst :   .tPushGlobalB  @EmitValue( decl )
6556:             | nLocalVar :
6558:                [ equal_zero( uplevels )
6565:                   | true :  .tPushLocalB  @EmitValue( decl )
6575:                   | * :     .tPushUpLocalB  oEmitInt( uplevels )  @EmitValue( decl )
6595:                ]
6595:             | nParam :
6597:                [ oNodeGetBoolean( decl, qInOut )
6607:                   | true :    % VAR param points to the var.  Auto dereference.
6608:                      [ equal_zero( uplevels )
6615:                         | true :  .tPushParamP  @EmitValue( decl )
6625:                         | * :     .tPushUpParamP  oEmitInt( uplevels )  @EmitValue( decl )
6645:                      ]
6645:                      .tFetchB
6647:                   | * :
6652:                      [ equal_zero( uplevels )
6659:                         | true :  .tPushParamB  @EmitValue( decl )
6669:                         | * :     .tPushUpParamB  oEmitInt( uplevels )  @EmitValue( decl )
6689:                      ]
6689:                ]
6689:          ]
      
6701:       | nFileType :
6703:          #eNotImplemented
      
6705:       | nPointerType, nUniversalPointerType :
6707:          [ oNodeType( decl )
6714:             | nGlobalVar, nTypedConst :   .tPushGlobalP @EmitValue( decl )
6724:             | nLocalVar :
6726:                [ equal_zero( uplevels )
6733:                   | true :  .tPushLocalP  @EmitValue( decl )
6743:                   | * :     .tPushUpLocalP  oEmitInt( uplevels )  @EmitValue( decl )
6763:                ]
6763:             | nParam :
6765:                [ oNodeGetBoolean( decl, qInOut )
6775:                   | true :    % VAR param points to the var.  Auto dereference.
6776:                      [ equal_zero( uplevels )
6783:                         | true :  .tPushParamP  @EmitValue( decl )
6793:                         | * :     .tPushUpParamP  oEmitInt( uplevels )  @EmitValue( decl )
6813:                      ]
6813:                      .tFetchP
6815:                   | * :
6820:                      [ equal_zero( uplevels )
6827:                         | true :  .tPushParamP  @EmitValue( decl )
6837:                         | * :     .tPushUpParamP  oEmitInt( uplevels )  @EmitValue( decl )
6857:                      ]
6857:                ]               
6857:          ]
6869:          [
6869:             | '^' :             % dereferenced
6871:                oTypeSPop
6872:                oTypeSPush( oNodeGet( theType, qBaseType ) )
6885:                @LValueIndexes
6887:                @FetchVar
6889:             | '[' :             % dereferencing pointer like an array [0..] of baseType
6891:                @PointerArraySubscript
                     % modify addr for any subsequent subscripts, field references, etc
6893:                @LValueIndexes
6895:                @FetchVar
6897:             | * :               % just ptr value alone
6904:          ]
      
6904:       | nArrayType, nRecordType, nShortStringType :
               % compound type
               % first, push addr of start of var
6906:          [ oNodeType( decl )
6913:             | nGlobalVar, nTypedConst :   .tPushAddrGlobal @EmitValue( decl )
6923:             | nLocalVar :
6925:                [ equal_zero( uplevels )
6932:                   | true :  .tPushAddrLocal  @EmitValue( decl )
6942:                   | * :     .tPushAddrUpLocal  oEmitInt( uplevels )  @EmitValue( decl )
6962:                ]
6962:             | nParam :
6964:                [ oNodeGetBoolean( decl, qInOut )
6974:                   | true :    % VAR param points to the var.  Auto dereference.
6975:                      [ equal_zero( uplevels )
6982:                         | true :  .tPushParamP  @EmitValue( decl )
6992:                         | * :     .tPushUpParamP  oEmitInt( uplevels )  @EmitValue( decl )
7012:                      ]
7012:                   | * :
7017:                      [ equal_zero( uplevels )
7024:                         | true :  .tPushAddrParam  @EmitValue( decl )
7034:                         | * :     .tPushAddrUpParam  oEmitInt( uplevels )  @EmitValue( decl )
7054:                      ]
7054:                ]
7054:          ]
               % modify addr for subscripts, field references, etc
7066:          @LValueIndexes
               % get final value
7068:          @FetchVar
7070:    ];
      
      
      % Addr of start of var is on expr stack; type is on type stack.
      % Replace expr stack with value of var.
      % (In the case of compound vars, this remains as the addr of the var).
      
7097: FetchVar:
7099:    [ oTypeSNodeType
7101:       | nIntegerType, nEnumType :  .tFetchI
7104:       | nBooleanType, nByteType, nCharType :  .tFetchB
7108:       | nFileType :   #eNotImplemented
7112:       | nPointerType :             .tFetchP
7116:       | nUniversalPointerType :    #eCantDereference
7120:       | nArrayType, nRecordType, nStrLitType, nShortStringType :  % compound type; leave as addr
7122:    ];
      
      
      % Addr of start of var is already on run stack, and type is on type stack.
      % Read subscripts, record fields, etc, to get final addr on run stack, and final type
      % on type stack.
      
7151: LValueIndexes:
7153:    {[
7153:       | '[' :
7155:          [ oTypeSNodeType
7157:             | nArrayType :    @ArraySubscripts
7160:             | nPointerType :  @PointerArraySubscript
7164:             | nStrLitType, nShortStringType :  @ShortStringArraySubscript
7168:             | * :             #eNotArray
7181:          ]
7181:       | '.' :       @RecordFieldRef
7185:       | '^' :       @PointerDeref   % TO DO: I suspect I don't have logic right here
                                          % about precondition and using .tFetchP
                                          % Ideally this should take over for the ^ in VarExpr too.
7189:       | * :         >
7200:    ]};
      
      
7203: ArraySubscripts:
7205:    [ oTypeSNodeType
7207:       | nArrayType :
7208:       | * :       #eNotArray
7215:    ]
7215:    {
7215:       [ oTypeSNodeType
7217:          | nArrayType :
7218:          | * :    #eTooManySubscripts
7225:       ]
      
            % low subscript of this dimension
7225:       int low = @OrdinalLow( oNodeGet( oTypeSTop, qIndexType ) )
      
            % replace type stack with next dimension, or OF type
7242:       Node baseType
7242:       baseType = oNodeGet( oTypeSTop, qBaseType )
7254:       oTypeSPop
7255:       oTypeSPush( baseType )
      
7261:       @Expr
7263:       @RequireIntPop
            % adjust for low subscript
7265:       [ equal_zero( low )
7272:          | false :
7273:             .tPushConstI oEmitInt( low ) .tSubI
7283:          | * :
7288:       ]
      
            % multiply by element size
7288:       int size = oNodeGetInt( baseType, qSize )
7301:       [ equal( size, 1 )
7311:          | false :
7312:             .tPushConstI oEmitInt( size ) .tMultI
7322:          | * :
7327:       ]
      
            % update start address
7327:       .tAddPI
7329:       [
7329:          | ']' :  >
7333:          | ',' :
7335:       ]
7343:    };
      
      
      % pointer[index] - similar to array[index] where index counts from 0.
      % On entry, the pointer value is on the stack, and pointer type is on the type stack.
      % We've already accepted the '['.
      % On exit, the address of the pointed-to element is on the stack,
      % and the element type is on the type stack.
      %
7346: PointerArraySubscript:
7348:    [ oTypeSNodeType
7350:       | nPointerType :
7351:       | * :    #eCantDereference
7358:    ]
         % replace type stack with base type
7358:    Node baseType = oNodeGet( oTypeSTop, qBaseType )
7370:    oTypeSPop
7371:    oTypeSPush( baseType )
         
7377:    @Expr
7379:    @RequireIntPop
         % multiply by element size
7381:    int size = oNodeGetInt( baseType, qSize )
7394:    [ equal( size, 1 )
7404:       | false :
7405:          .tPushConstI  oEmitInt( size )  .tMultI
7415:       | * :
7420:    ]
         % update start address
7420:    .tAddPI
7422:    ']';
      
      
      % Specialization of array indexing for ShortString.
      % We treat the starting index as 0 so that str[1] sees the first string char,
      % past the length byte.
      %
7425: ShortStringArraySubscript:
7427:    [ oTypeSNodeType
7429:       | nStrLitType, nShortStringType :
7430:       | * :    #eCantDereference
7439:    ]
7439:    oTypeSPop
7440:    oTypeSPush( CharType )
7446:    @Expr
7448:    @RequireIntPop
7450:    .tAddPI
7452:    ']';
      
      
7455: RecordFieldRef:
7457:    [ oTypeSNodeType
7459:       | nRecordType :
7460:       | * :    #eNotRecord
7467:    ]
7467:    oScopeEnter( oNodeGet( oTypeSTop, qScope ) )
7479:    pIdent
7481:    Node field = oScopeFindRequire
         % oScopeFind searches all open scopes, so make sure we found nRecordField
         % which could only be seen in the local scope we entered above.
7486:    [ oNodeType( field )
7493:       | nRecordField :
7494:       | * :   #eNotRecordField
7501:    ]
7501:    oScopeEnd
7502:    int offset = oNodeGetInt( field, qValue )
7515:    [ equal_zero( offset )
7522:       | false :
7523:          .tPushConstI oEmitInt( offset ) .tAddPI
7533:       | * :
7538:    ]
      
         % replace the type on the type stack, with the field type
7538:    oTypeSPop
7539:    oTypeSPush( oNodeGet( field, qType ) )
7553:    ;
      
      
      % On entry, expr stack has ptr, and integer index above it.
      % The type stack has just the pointer type.
      % Pop those, and push the ptr advanced to that index
      % (scaled by the pointed-to element size).
      % Leaves the pointer type on the type stack.
      %
7553: PointerAddition:
7555:    Node elementType = oNodeGet( oTypeSTop, qBaseType )
7567:    int elementSize = oNodeGetInt( elementType, qSize )
7580:    [ equal( elementSize, 1 )
7590:       | false :
7591:          .tPushConstI  oEmitInt( elementSize )
7599:          .tMultI
7601:       | * :
7606:    ]
7606:    .tAddPI
7609:    ;
      
      
      % On entry, expr stack has ptr, and integer above it.
      % The type stack has just the pointer type.
      % Pop those, and push the ptr decremented by that integer
      % (scaled by the pointed-to element size).
      % Leaves the pointer type on the type stack.
      %
7609: PointerSubInt:
7611:    Node elementType = oNodeGet( oTypeSTop, qBaseType )
7623:    int elementSize = oNodeGetInt( elementType, qSize )
7636:    [ equal( elementSize, 1 )
7646:       | false :
7647:          .tPushConstI  oEmitInt( elementSize )
7655:          .tMultI
7657:       | * :
7662:    ]
7662:    .tSubPI
7665:    ;
      
      
      % On entry, expr stack has two pointers, P1 and P2 above it.
      % The type stack has the type of P1.  (The type of P2 was already matched to P1.)
      % Replace the pointers on the expression stack with P1 - P2, scaled by the
      % pointed-to element size.  Type stack switched to integer.
      % 
7665: PointerSubPointer:
7667:    .tSubP
7669:    Node elementType = oNodeGet( oTypeSTop, qBaseType )
7681:    int elementSize = oNodeGetInt( elementType, qSize )
7694:    [ equal( elementSize, 1 )
7704:       | false :
7705:          .tPushConstI  oEmitInt( elementSize )
7713:          .tDivI
7715:       | * :
7720:    ]
7720:    oTypeSPop
7721:    oTypeSPush( IntegerType )
7728:    ;
      
      % ptr deref on left side, i.e. BEFORE addr of ptr var is on stack,
      %                              AFTER addr of thing pointed to is on stack
7728: PointerDeref:
7730:    [ oTypeSNodeType
7732:       | nPointerType :
7733:       | nUniversalPointerType :   #eCantDereference
7737:       | * :       #eNotPointer
7746:    ]
7746:    .tFetchP           % now addr on stack is addr of what we're pointing to
      
7748:    Node theType = oTypeSTop
7753:    oTypeSPop
7754:    oTypeSPush( oNodeGet( theType, qBaseType ) )
7768:    ;
      
      
      % The expr stack contains a value whose type is on top of the type stack.
      % Generate code to coerce the value to the type under it in the type stack
      % (pop the type stack, leaving only the desired type).
      % This is used for assignment.
      %
7768: CoerceType:
7770:    node_type nt = oTypeSNodeType
7775:    oTypeSPop
7776:    [ equal_node_type( nt, oTypeSNodeType )
7785:       | false :
               % Can we implicitly convert the value to the desired type?
7786:          [ oTypeSNodeType
7788:             | nIntegerType :
7789:                [ nt
7792:                   | nByteType :   .tCastBtoI  >>
7796:                   | * :
7801:                ]
7801:             | nByteType :
7803:                [ nt
7806:                   | nIntegerType :   .tCastItoB  >>
7810:                   | * :
7815:                ]
7815:             | nPointerType :
7817:                [ nt
7820:                   | nUniversalPointerType :  >>
7822:                   | nStrLitType :
7824:                      [ equal_node( oTypeSTop, PCharType )
7833:                         | true :
                                 % PChar := 'strlit' i.e. point at strlit[1]
7834:                            .tPushConstI  oEmitInt(1)  .tAddPI  >>
7845:                         | * :
7850:                      ]
7850:                   | * :
7857:                ]
7857:             | nUniversalPointerType :
7859:                [ nt
7862:                   | nPointerType :  >>
7864:                   | * :
7869:                ]
7869:             | nShortStringType :
7871:                [ nt
7874:                   | nStrLitType :  >>
7876:                   | nCharType :
                           % Store char as a temp ShortString.
7878:                      oTypeSPush( CharType )
7884:                      int tempOffset = @MoveIntoTempShortString
7890:                      oTypeSPop
7891:                      >>
7892:                   | * :
7899:                ]
7899:             | * :
7912:          ]
7912:          #eTypeMismatch
7914:       | * :
7919:    ];
      
      
      % Require that the top two types on the type stack are matching (ignoring subranges).
      % Pop one of them, leaving only one.
      %
7920: MatchTypes:
7922:    node_type nt = oTypeSNodeType
7927:    oTypeSPop
7928:    [ equal_node_type( nt, oTypeSNodeType )
7937:       | false :
               % Some implicit conversion is allowed even here
7938:          [ oTypeSNodeType
7940:             | nPointerType :
7941:                [ nt
7944:                   | nUniversalPointerType :  >>
7946:                   | * :
7951:                ]
7951:             | nUniversalPointerType :
7953:                [ nt
7956:                   | nPointerType :  >>
7958:                   | * :
7963:                ]
7963:             | * :
7970:          ]
7970:          #eTypeMismatch
7972:       | * :
7977:    ];
      
      
      % Require that the top type on the type stack is integer (ignoring subranges).
      % Pop it.
      %
7978: RequireIntPop:
7980:    [ oTypeSNodeType
7982:       | nIntegerType :
7983:       | * :          #eNotInteger
7990:    ]
7990:    oTypeSPop;
      
7992: RequireInt:
7994:    [ oTypeSNodeType
7996:       | nIntegerType :
7997:       | * :          #eNotInteger
8004:    ];
      
      
      % Convert the top value to integer (if it isn't already).
      % It must be implicitly convertable to integer.
      % Pop the type stack.
      %
8005: PromoteToIntPop:
8007:    [ oTypeSNodeType
8009:       | nIntegerType :
8010:       | nByteType :        .tCastBtoI
8014:       | * :                #eNotInteger
8023:    ]
8023:    oTypeSPop;
      
      % Convert the top value to integer (if it isn't already).
      % It must be implicitly convertable to integer.
      % Leave integer on the type stack.
      %
8025: PromoteToInt:
8027:    [ oTypeSNodeType
8029:       | nIntegerType :
8030:       | nByteType :        .tCastBtoI
8034:                            oTypeSPop
8035:                            oTypeSPush( IntegerType )
8041:       | * :                #eNotInteger
8050:    ];
      
      
      % If the top value is implicitly convertable to integer, do so.
      % Otherwise leave it as-is.
      %
8051: PromoteToIntOptional:
8053:    [ oTypeSNodeType
8055:       | nByteType :        .tCastBtoI
8058:                            oTypeSPop
8059:                            oTypeSPush( IntegerType )
8065:       | * :
8070:    ];
      
      
8071: RequireBoolPop:
8073:    [ oTypeSNodeType
8075:       | nBooleanType :
8076:       | * :          #eNotBoolean
8083:    ]
8083:    oTypeSPop;
      
8085: RequireBool:
8087:    [ oTypeSNodeType
8089:       | nBooleanType :
8090:       | * :          #eNotBoolean
8097:    ];
      
      
8098: include 'pascal_stmt.ssl'
      %
      % Pascal Compiler
      %
      
      
      % ------------------------------ Statements -----------------------------
      
8098: Statement:
8100:    [
8100:       | pWriteln :     @WritelnStmt
8104:       | pWrite :       @WriteStmt
8108:       | pReadln :      @ReadlnStmt
8112:       | pRead :        @ReadStmt
8116:       | pIf :          @IfStmt
8120:       | pWhile :       @WhileStmt
8124:       | pFor :         @ForStmt
8128:       | pRepeat :      @RepeatStmt
8132:       | pBreak :       @BreakStmt
8136:       | pContinue :    @ContinueStmt
8140:       | pBegin :       @BeginStmt
8144:       | pIdent :       @LabelOrAssignOrCallStmt
8148:       | pCase :        @CaseStmt
8152:       | pGoto :        @GotoStmt
8156:       | pIntLit :      % should be an integer label
8158:                        oChangeIntLitToLabelIdent
8159:                        @LabelOrAssignOrCallStmt
8161:       | * :            % null statement : don't accept any tokens
8194:    ];
      
      
8195: LabelOrAssignOrCallStmt:
8197:    Node decl = oScopeFindRequire
8202:    @ResolveUnitRef( decl )
8209:    [ oNodeType( decl )
8216:       | nLabel :                          @LabelDefinition( decl )
8224:                                           @Statement
8226:       | nProc :                           @Call( decl )
8235:       | nGlobalVar, nLocalVar, nParam :   @AssignStmt( decl )
8244:       | nFunc :                           @AssignResultStmt( decl )
8253:       | * :                               #eBadStatement
8270:    ];
      
      
      % Parse a "label:" prefix in front of a statement.
      %
8271: LabelDefinition( Node decl ):
8273:    [ oNodeGetBoolean( decl, qDefined )
8283:       | true :  #eAlreadyDefined
8286:       | * :
8291:    ]
8291:    .tLabel  oEmitLabel( oNodeGetLabel( decl, qValue ) )
8306:    oNodeSetBoolean( decl, qDefined, true )
8318:    ':'
8321:    ;
      
      
      % Given decl, the just-accepted first identifier on the left hand side.
      %
8321: AssignStmt( Node decl ):
      
8323:    @LValueVar( decl, true )
8333:    ':=' 
8335:    @Expr
8337:    @CoerceType
8339:    @Assign
8342:    ;
      
      
      % Performs a raw assignment.
      % Given lvalue 2nd on stack, and expr value top of stack (already coerced to the lvalue type),
      % and type of both of these on the type stack,
      % perform the assignment and pop the type off the type stack.
      %
8342: Assign:
8344:    [ oTypeSNodeType
8346:       | nIntegerType, nEnumType :  .tAssignI
8349:       | nBooleanType, nByteType, nCharType :  .tAssignB
8353:       | nFileType :   #eNotImplemented
8357:       | nPointerType, nUniversalPointerType :  .tAssignP
            % compound var assigns; addrs of src, dest on stack
8361:       | nArrayType, nRecordType, nShortStringType :
                % TO DO: for ShortString, allow destination to be smaller capacity,
                % and truncate the copied value/length.
8363:           int size = oNodeGetInt( oTypeSTop, qSize )
8375:           .tCopy  oEmitInt( size )    % multi-word copy
8383:    ]
8409:    oTypeSPop
8411:    ;
      
      % Given nFunc for the just-accepted identifier on the left hand side.
      % Parse an assignment that represents assignment of the function result.
      %
8411: AssignResultStmt( Node funcDecl ):
         % Only allowed to assign the result of the immediately enclosing function, I think.
8413:    [ oNodeEqual( oNodeGet( funcDecl, qChildScope ), oScopeCurrent )
8429:       | false :   #eNotCurrentFunction
8432:       | * :
8437:    ]
      
         % Result value is stored in the caller's space, via a hidden VAR parameter.
8437:    .tPushParamP  oEmitInt( oNodeGetInt( funcDecl, qResultOffset ) )
8452:    oTypeSPush( oNodeGet( funcDecl, qType ) )
      
8465:    ':='
8467:    @Expr
8469:    @CoerceType
8471:    [ oTypeSNodeType
8473:       | nIntegerType, nEnumType : .tAssignI
8476:       | nBooleanType, nByteType, nCharType :  .tAssignB
8480:       | nFileType :   #eNotImplemented
8484:       | nPointerType, nUniversalPointerType :  .tAssignP
            % compound var assigns; addrs of src, dest on stack
8488:       | nArrayType, nRecordType, nShortStringType :
8490:           int size = oNodeGetInt( oTypeSTop, qSize )
8502:           .tCopy  oEmitInt( size )    % multi-word copy
8510:    ]
8536:    oTypeSPop
8538:    ;
      
      
      
      % Parse an lvalue expression, from scratch.
      % This is an expression that may appear on the left side of an assignment.
      % Leaves the address of the value on the expr stack,
      % and the type of the value at that address on the type stack.
      % If writeable is false, the expression won't be written to, so may access a
      % typed const.
      %
8538: LValueExpr( boolean writeable ):
         % At the moment, all lvalue expressions start with a variable name.
         % I think there can also be typecasts, not supported yet.  Check standard syntax.
8540:    pIdent
8542:    Node decl = oScopeFindRequire
8547:    @ResolveUnitRef( decl )
8554:    [ oNodeType( decl )
8561:       | nGlobalVar, nLocalVar, nParam, nTypedConst :
8562:       | * :  #eNotVar
8575:    ]
8575:    @LValueVar( decl, writeable )
8586:    ;
      
      
      % Parse an lvalue expression (e.g. left side of an assign statement)
      % that starts with the just-accepted identifier indicated by the given decl.
      % Leaves the lvalue address on the expression stack,
      % and the type of the value at that address on the type stack.
      %
8586: LValueVar( Node decl, boolean writeable ):
8588:    [ oNodeType( decl )
8595:       | nGlobalVar :   .tPushAddrGlobal @EmitValue( decl )
8605:       | nLocalVar :    .tPushAddrLocal @EmitValue( decl )
8616:       | nParam :
8618:          [ oNodeGetBoolean( decl, qInOut )
8628:             | true :   % VAR param points to variable.  No dereference.
8629:                        .tPushParamP @EmitValue( decl )
8638:             | * :      .tPushAddrParam @EmitValue( decl )
8652:          ]
8652:       | nTypedConst :
8654:          [ writeable
8657:             | false :  .tPushAddrGlobal @EmitValue( decl )                       
8667:             | * :      #eNotVar
8674:          ]
8674:       | * :            #eNotVar
8687:    ]
      
8687:    oTypeSPush( oNodeGet( decl, qType ) )
      
         % handle subscripts, if any.
         % There is one case that I'm not fitting into the pattern nicely, so need to
         % check for specially here:  if lvalue var is a pointer variable, and is
         % followed by [index], we need to dereference the pointer variable before applying
         % the index.  This is different from handling of [index] on an rvalue expression.
         % Right now I have LValueIndexes working for both lvalue and rvalue (composite types)
         % so can't easily add this behavior in there.
         % TO DO: probably I need separate rules LValueIndexes and RValueIndexes.
         %    This might also explain my confusion about handling of deref operator in LValueIndexes vs rvalue expr,
         %    and having separate rules might clear that up better.
      
8700:    [ oTypeSNodeType
8702:       | nPointerType :
8703:          [
8703:             | '[' :
                     % dereference the pointer var first
8705:                .tFetchP
8707:                @PointerArraySubscript
8709:             | * :
8714:          ]
8714:       | * :
8719:    ]
         % additional subscripts, if any
8719:    @LValueIndexes
8722:    ;
      
      
8722: IncVar( Node decl ):
8724:    @LValueVar( decl, true )
8734:    @RequireIntPop
8736:    @VarExpr( decl )
8743:    oTypeSPop
8744:    .tIncI
8746:    .tAssignI;
      
8749: DecVar( Node decl ):
8751:    @LValueVar( decl, true )
8761:    @RequireIntPop
8763:    @VarExpr( decl )
8770:    oTypeSPop
8771:    .tDecI
8773:    .tAssignI;
      
      
8776: IfStmt:
8778:    Label falseLabel = labelNull
      
8784:    @BooleanExprControlFlow( falseLabel )
8791:    pThen
8793:    @Statement
8795:    [
8795:       | pElse :
8797:          Label doneLabel = oLabelNew
      
8802:          .tJump  oEmitLabel( doneLabel )
8810:          .tLabel oEmitLabel( falseLabel )
8818:          @Statement
8820:          .tLabel oEmitLabel( doneLabel )
      
8828:       | * :
8833:          .tLabel oEmitLabel( falseLabel )
8841:    ];
      
      
8842: ForStmt:
8844:    pIdent
      
8846:    Node decl = oScopeFindRequire
         % TO DO: disallow use of a compound variable field.
         %        Could do that by disallowing use of LValueIndexes,
         %        or by double-checking the decl's qType here.
         % TO DO: I think I read somewhere that the variable must be in current scope.
8851:    @LValueVar( decl, true )
8861:    @RequireIntPop
      
8863:    ':='
      
8865:    @Expr
8867:    @RequireIntPop
8869:    .tAssignI
      
8871:    Label breakLabel = oLabelNew
      
8876:    Label checkLabel = oLabelNew
8881:    .tJump  oEmitLabel( checkLabel )
      
8889:    Label continueLabel = oLabelNew
8894:    .tLabel  oEmitLabel( continueLabel )
8902:    [
8902:       | pTo :
8904:          @IncVar( decl )
8911:          .tLabel  oEmitLabel( checkLabel )
8919:          @VarExpr( decl )  oTypeSPop
8927:          @Expr
8929:          @RequireIntPop
8931:          .tGreaterI
8933:          .tJumpTrue  oEmitLabel( breakLabel )
8941:       | pDownto :
8943:          @DecVar( decl )
8950:          .tLabel  oEmitLabel( checkLabel )
8958:          @VarExpr( decl )  oTypeSPop
8966:          @Expr
8968:          @RequireIntPop
8970:          .tLessI
8972:          .tJumpTrue  oEmitLabel( breakLabel )
8980:    ]
8988:    oLoopPush( continueLabel, breakLabel )
8997:    pDo
8999:    @Statement
9001:    .tJump  oEmitLabel( continueLabel )
9009:    .tLabel  oEmitLabel( breakLabel )
9017:    oLoopPop;
      
      
9019: RepeatStmt:
9021:    Label continueLabel = oLabelNew
9026:    .tLabel  oEmitLabel( continueLabel )
      
9034:    Label breakLabel = oLabelNew
      
9039:    oLoopPush( continueLabel, breakLabel )
9048:    @Statement
9050:    {[
9050:       | ';' :
9052:          @Statement
9054:       | pUntil :
9056:          Label falseLabel
9056:          @BooleanExprControlFlow( falseLabel )
9063:          .tLabelAlias  oEmitLabel( falseLabel )  oEmitLabel( continueLabel )
9077:          >
9079:    ]}
9089:    .tLabel  oEmitLabel( breakLabel )
9097:    oLoopPop;
      
      
9099: WhileStmt:
9101:    Label continueLabel = oLabelNew
9106:    .tLabel  oEmitLabel( continueLabel )
      
9114:    Label breakLabel
9114:    @BooleanExprControlFlow( breakLabel )
      
9121:    oLoopPush( continueLabel, breakLabel )
9130:    pDo
9132:    @Statement
9134:    .tJump  oEmitLabel( continueLabel )
9142:    .tLabel  oEmitLabel( breakLabel )
9150:    oLoopPop;
      
      
9152: ContinueStmt:                     % NOTE, for repeat..until, skips test (??)
9154:    [ equal_label( oLoopContinueLabel, labelNull )
9163:       | true :
9164:          #eNotInALoop
9166:       | false :
9168:          .tJump  oEmitLabel( oLoopContinueLabel )
9175:    ];
      
      
9184: BreakStmt:
9186:    [ equal_label( oLoopBreakLabel, labelNull )
9195:       | true :
9196:          #eNotInALoop
9198:       | false :
9200:          .tJump  oEmitLabel( oLoopBreakLabel )
9207:    ];
      
      
9216: CaseStmt:
9218:    Code tableCode = oCodeNew
9223:    Label tableLabel = oLabelNew
9228:    Label doneLabel = oLabelNew
9233:    Label otherwiseLabel = doneLabel
9239:    boolean isString = false
      
9245:    @Expr
         % Leave the expr type on the type stack throughout case statement
9247:    [ oTypeSNodeType
9249:       | nBooleanType, nByteType, nCharType :   .tJumpCaseB  oEmitLabel( tableLabel )
9258:       | nIntegerType, nEnumType :              .tJumpCaseI  oEmitLabel( tableLabel )
9268:       | nShortStringType, nStrLitType :        isString = true
9276:                                                .tJumpCaseS  oEmitLabel( tableLabel )
9284:       | * :     #eNotAllowed
9303:    ]
9303:    pOf
      
9305:    {
9305:       [
9305:          | pOtherwise, pElse :
9307:             otherwiseLabel = oLabelNew
9312:             .tLabel  oEmitLabel( otherwiseLabel )
      
                  % A bit tricky:
                  % The otherwise clause allows multiple statements (unlike other cases).
                  % ';' might be separating statements in the otherwise clause,
                  % or might be an optional trailing ; after the last statement.
                  % I have to watch for End to know when the statements stop.
                  % (Note, the otherwise clause is the last part of the case statement.)
9320:             {[
9320:                | pEnd :  >
9324:                | * :
9329:                   @Statement
9331:                   [
9331:                      | ';' :
9333:                      | * :   pEnd  >
9342:                   ]
9342:             ]}
9344:             >
      
9346:          | pEnd :
                  % Reached end with no otherwise clause
9348:             >
      
9350:          | * :
9359:             Label caseLabel = oLabelNew
9364:             oCodePush( tableCode )
9370:             {
9370:                @ConstExpr
9372:                @ConstCoerceType
9374:                int val
9374:                [ isString
9377:                   | true :    val = oStringAllocShortStringLit( oValueTopString )
9387:                   | false :   val = oValueTop
9394:                ]
9402:                oValuePop
9403:                [
9403:                   | '..' :  @ConstExpr
9407:                             @ConstCoerceType
9409:                             int highval
9409:                             [ isString
9412:                                | true :   highval = oStringAllocShortStringLit( oValueTopString )
9422:                                | false :  highval = oValueTop
9429:                             ]
9437:                             oValuePop
9438:                             .tCaseRange  oEmitInt( val )  oEmitInt( highval )  oEmitLabel( caseLabel )
9458:                   | * :     .tCase  oEmitInt( val )  oEmitLabel( caseLabel )
9477:                ]
9477:                [
9477:                   | ',' :
9479:                   | * :  >
9486:                ]
9486:             }
9488:             oCodePop
9489:             ':'
9491:             .tLabel  oEmitLabel( caseLabel )
9499:             @Statement
9501:             .tJump  oEmitLabel( doneLabel )
                  % Swallow optional trailing ';'
9509:             [
9509:                | ';' :
9511:                | * :
9516:             ]
                  
9516:       ]
         
9516:    }
      
9518:    .tLabel  oEmitLabel( tableLabel )
9526:    oEmitCode( tableCode )
9532:    .tCaseEnd  oEmitLabel( otherwiseLabel )
9540:    .tLabel  oEmitLabel( doneLabel )
9548:    oTypeSPop
9550:    ;
      
      
9550: GotoStmt:
9552:    [
9552:       | pIdent :
9554:       | pIntLit :
               % Replace token with identifier "_label_<intlit>"
9556:          oChangeIntLitToLabelIdent
9557:    ]
      
         % Some pascals have rules about where you can jump (to a sibling statement or
         % higher level statement in the block, but not into a lower lower level statement.)
         % fpc just says "jumping into a nested statement can have strange effects."
         % I'm going to follow that and not prohibit any goto, as long as it's in the same block.
      
         % Label must be declared in the same block (same scope) it is used.
         % Some pascals allow non-local goto, but we do not.
         % That would require more tracking of dynamic scope, to unwind stack.
         % Note: in main program statement, this relies on the temporaries scope extending
         %  the main scope (where a label declaration would occur).
9565:    Node decl = oScopeFindRequireInScope( oScopeCurrent )
9574:    oNodeSetBoolean( decl, qUsed, true )
9586:    .tJump  oEmitLabel( oNodeGetLabel( decl, qValue ) )
9602:    ;
      
      
9602: BeginStmt:
9604:    @Statement
9606:    {[
9606:       | ';' :   @Statement
9610:       | pEnd :  >
9614:    ]};
      
      
9625: WritelnStmt:
9627:    @WriteStmt
9629:    .tWriteCR;
      
      
9632: WriteStmt:
9634:    [
9634:       | '(' :
9636:          {
9636:             @Expr
9638:             [ oTypeSNodeType
9640:                | nIntegerType :             .tWriteI
9643:                | nBooleanType :             .tWriteBool
9647:                | nByteType :                .tCastBtoI  .tWriteI
9653:                | nCharType :                .tWriteChar
9657:                | nShortStringType, nStrLitType :   .tWriteShortStr
9661:                | nFileType :                #eNotImplemented
9665:                | nEnumType :
                        % write name via table lookup
9667:                   .tPushAddrGlobal  oEmitInt( oNodeGetInt( oTypeSTop, qNameTable ) )
9681:                   .tWriteEnum
9683:                | nPointerType :
9685:                   [ equal_node( oTypeSTop, PCharType )
9694:                      | true :               .tWritePChar
9697:                      | * :                  .tWriteP
9704:                   ]
9704:                | nUniversalPointerType :    .tWriteP
9708:                | * :                        #eNotAllowed
9733:             ]
9733:             oTypeSPop
9734:             [
9734:                | ')' : >
9738:                | ',' :
9740:             ]
9748:          }
9750:       | * :
9755:    ];
      
      
9756: ReadlnStmt:      % ***
         % TO DO
9759:    ;
      
9759: ReadStmt:
         % TO DO
9762:    ;
9762: include 'pascal_str.ssl'
      %
      % Pascal Compiler
      %
      
      % ------------------------------ String Operations -----------------------------
      
      
      % Given a ShortString, StrLit, or Char on the expression stack
      % (and type on the type stack).  Move the value into a new temporary ShortString.
      % Leave that temp string and type on the stacks.
      % Also returns the offset of the temp string.
      %
9762: MoveIntoTempShortString >> int:
9764:    int tempOffset = oScopeAllocType( ShortStringType )
         % copy the value
9774:    [ oTypeSNodeType
9776:       | nShortStringType, nStrLitType :
9777:          .tPushAddrLocal  oEmitInt( tempOffset )
               % put temp addr under value addr
9785:          .tSwap
               % TO DO: we could just copy length + 1, but tCopy takes a fixed #bytes
9787:          .tCopy  oEmitInt( oNodeGetInt( ShortStringType, qSize ) )
9802:       | nCharType :
               % temp[0] = 1
9804:          .tPushAddrLocal  oEmitInt( tempOffset )
9812:          .tPushConstI  oEmitInt( 1 )
9820:          .tAssignB
               % temp[1] = value
9822:          .tPushAddrLocal  oEmitInt( add( tempOffset, 1 ) )
9837:          .tSwap
9839:          .tAssignB
9841:       | * :   #eTypeMismatch
9852:    ]
9852:    oTypeSPop
         % Leave the temp ShortString on the expr stack and type stack
9853:    .tPushAddrLocal  oEmitInt( tempOffset )
9861:    oTypeSPush( ShortStringType )
9867:    >> tempOffset;
      
      
      % Top of expr stack / type stack is ShortString B.
      % Under it is ShortString A.
      % Change A to append the contents of B to it (truncating if necessary).
      % Removes both A and B from the expr stack / type stack.
      %
9871: ShortStringAppendShortString:
         % TO DO: ideally I would do this directly with tcode.  But I think I need some more
         % enhancements for that to work well.   Meanwhile, generate a call to a method.
         % For the moment, I'll implement the method in Pascal, in the mysystem unit.
9873:    .tAllocActuals  oEmitInt( 16 )
9881:    .tPushAddrActual  oEmitInt( 8 )  .tSwap  .tAssignP
9893:    .tPushAddrActual  oEmitInt( 0 )  .tSwap  .tAssignP
9905:    .tCall   @EmitValue( System_ShortStringAppendShortString )
         % TO DO: Ideally I would leave A on the expr stack / type stack.
         %  But I can't really do that without dup, which I hesitate to add.
         %  I'll have the caller push A again themselves.
9914:    .tFreeActuals  oEmitInt( 16 )
9922:    oTypeSPop
9923:    oTypeSPop
9925:    ;
      
      % Top of expr stack / type stack is Char B.
      % Under it is ShortString A.
      % Change A to append char B to it (truncating if necessary).
      % Removes both A and B from the expr stack / type stack.
      %
9925: ShortStringAppendChar:
         % Note at the moment I don't align params
9927:    .tAllocActuals  oEmitInt( 12 )
9935:    .tPushAddrActual  oEmitInt( 8 )  .tSwap  .tAssignI
9947:    .tPushAddrActual  oEmitInt( 0 )  .tSwap  .tAssignP
9959:    .tCall  @EmitValue( System_ShortStringAppendChar )
9968:    .tFreeActuals  oEmitInt( 12 )
9976:    oTypeSPop
9977:    oTypeSPop
9979:    ;
      
      % Expr stack has ShortString A, and ShortString B above it.
      % Type stack has just the type of ShortString A.
      % Replaces the expr stack with the integer value of string comparison:
      % -1 if A < B,  0 if A = B,  1 if A > B
      % Leaves Integer on the type stack.
      %
9979: ShortStringCmp:
9981:    .tAllocActuals  oEmitInt( 24 )
9989:    .tPushAddrActual  oEmitInt( 8 )  .tSwap  .tAssignP
10001:    .tPushAddrActual  oEmitInt( 0 )  .tSwap  .tAssignP
10013:    int tempOffset = oScopeAllocType( IntegerType )
10023:    .tPushAddrActual  oEmitInt( 16 )  .tPushAddrLocal  oEmitInt( tempOffset )  .tAssignP
10041:    .tCall  @EmitValue( System_ShortStringCmp )
10050:    .tPushLocalI  oEmitInt( tempOffset )
10058:    .tFreeActuals  oEmitInt( 24 )
10066:    oTypeSPop
10067:    oTypeSPush( IntegerType )
10074:    ;
10074: include 'pascal_call.ssl'
      %
      % Pascal Compiler
      %
      
      % ------------------------------ Method Calls -----------------------------
      
      
      % Parse a call, given an nProc or nFunc for the just-accepted identifier.
      % If a func, this will also generate the code to push the return value on the expr stack,
      % and push the return type on the type stack.
      %
10074: Call( Node method ):
      
         % Prior to first call, issue extern label for a called method.
         % I don't want to issue .tLabelExtern for unused methods, that seems inefficient.
10076:    [ oNodeGetBoolean( method, qExternal )
10086:       | true :
10087:          [ oNodeGetBoolean( method, qUsed )
10097:             | false :
                     % define the extern label on first use
10098:                @DefineExternLabel( method )
10105:             | * :
10110:          ]
10110:      | * :
10115:    ]
10115:    oNodeSetBoolean( method, qUsed, true )
      
         % If the method has a cdecl modifier, the back end will need to use the native
         % calling convention, instead of my own.  But, the convention varies by platform,
         % so the front end won't assume what it needs.  I'll still generate the normal tcode
         % that copies values into actuals space on the stack.
         % However, to help the back end, I will at least use a different instruction for the
         % allocation of the actuals space, and for the actual call.
         %
         % p.s. I only support cdecl on external methods, because I don't have a way
         % to let my own Pascal methods read params passed in with the cdecl calling convention.
         %
10127:    boolean cdecl = oNodeGetBoolean( method, qCdecl )
      
         % If this is a function, we will allocate a temporary
         % in the current scope, to hold the result value.
         % And pass a pointer to that temporary as an extra parameter.
10140:    Node resultType
10140:    int tempOffset
      
10140:    boolean isFunc = equal_node_type( oNodeType( method ), nFunc )
      
10157:    [ isFunc
10160:       | true :
10161:          resultType = oNodeGet( method, qType )
10174:          tempOffset = oScopeAllocType( resultType )
               % TO DO: we could manage temp allocation, so temp space can be reused
               %        by different code branches.
10184:       | * :
10189:    ]
         
      
10189:    Node paramScope = oNodeGet( method, qParams )
10202:    int actualsSize = oNodeGetInt( paramScope, qSize )
10215:    [ cdecl
10218:       | true : .tAllocActualsCdecl  oEmitInt( actualsSize )
10227:       | false :  .tAllocActuals  oEmitInt( actualsSize )
10237:    ]
      
         % If method is nested, it takes a hidden first parameter:
         % a pointer to the frame of the static scope in which the method is declared.
         % The location of a scope's frame is equivalent to offset 0 in the scope's locals space
         % (since local offsets are relative to the scope's frame pointer).
         %
         % The nested method may be in a higher scope (upLevels > 1),
         % or a sibling of the method we're in (upLevels = 1),
         % or an immediate child of the current method (upLevels = 0).
         %
         % To understand the upLevels computation, remember that a method's declaration
         % and its contents (variables, nested functions, and body statement)
         % are in two different scopes.
      
10245:    [ greater( @DeclLevel( method ), 0 )
10260:       | true :
10261:          .tPushAddrActual  oEmitInt( 0 )    % hidden param is at param offset 0
10269:          .tPushAddrUpLocal  oEmitInt( @DeclUpLevels( method ) )  oEmitInt( 0 )
10288:          .tAssignP
10290:       | * :
10295:    ]
      
      
10295:    NodeIter paramIter = oNodeGetIter( paramScope, qDecls )
10308:    Node param = oNodeIterValue( paramIter )
10318:    [
10318:       | '(' :
            
10320:          {
10320:             [ oNodeNull( param )
10327:                | true : >
10330:                | * :
10335:             ]
      
10335:             int offset = oNodeGetInt( param, qValue )
      
                  % Assign actual value to spot in actuals space
10348:             .tPushAddrActual oEmitInt( offset )
10356:             oTypeSPush( oNodeGet( param, qType ) )
      
10369:             [ oNodeGetBoolean( param, qInOut )
10379:                | true :   % A VAR param.
                                % The actual is a pointer to the value.
                                % The type on the type stack (pushed above) is for the pointed-to value.
      
10380:                           @LValueExpr( true )
                                % Addr of the referenced variable is on the expr stack,
                                % type of the variable is on the type stack.
      
                                % Match types more exactly. It's not sufficient to be assign compatible
                                % since the method will be assigning to the actual using the param type.
                                % Maybe something like type contents must match, incl subrange bounds.
10387:                           @MatchTypes
      
10389:                           .tAssignP
      
10391:                | false :  @Expr
10395:                           @CoerceType
                                
                                % Assign to offset in actuals space
      
10397:                           [ oTypeSNodeType
10399:                              | nIntegerType, nEnumType : .tAssignI
10402:                              | nBooleanType, nByteType, nCharType :  .tAssignB
10406:                              | nFileType :   #eNotImplemented
10410:                              | nPointerType, nUniversalPointerType :  .tAssignP
10414:                              | nArrayType, nRecordType, nShortStringType :
                                       % compound types: copy value into actuals space
10416:                                  int size = oNodeGetInt( oTypeSTop, qSize )
10428:                                  .tCopy  oEmitInt( size )    % multi-word copy
10436:                           ]
10462:             ]
10470:             oTypeSPop
      
10471:             oNodeIterNext( paramIter )
10477:             param = oNodeIterValue( paramIter )
10487:             [ oNodeNull( param )
10494:                | true :  >
10497:                | false :
10499:             ]
      
10507:             ','
10509:          }
      
10511:          ')'
      
10513:       | * :
10518:    ]
      
10518:    [ oNodeNull( param )
10525:       | false :    #eMissingParameter
10528:       | * :
10533:    ]
      
10533:    [ isFunc
10536:       | true :
               % Pass result temp as an additional VAR parameter.
10537:          .tPushAddrActual oEmitInt( oNodeGetInt( method, qResultOffset ) )
10552:          .tPushAddrLocal  oEmitInt( tempOffset )
10560:          .tAssignP
10562:       | * :
10567:    ]
      
10567:    [ cdecl
10570:       | true :
10571:          .tCallCdecl  @EmitValue( method )
10580:       | false :
10582:          .tCall   @EmitValue( method )
10591:    ]
      
10599:    [ isFunc
10602:       | true :
               % push return value from temp
10603:          oTypeSPush( resultType )
      
10609:          [ oTypeSNodeType
10611:             | nIntegerType, nEnumType :   .tPushLocalI  oEmitInt( tempOffset )
10620:             | nBooleanType, nByteType, nCharType :   .tPushLocalB  oEmitInt( tempOffset )
10630:             | nFileType :  #eNotImplemented
10634:             | nPointerType, nUniversalPointerType :   .tPushLocalP  oEmitInt( tempOffset )
10644:             | nArrayType, nRecordType, nShortStringType :   % compound type: push address
10646:                                .tPushAddrLocal  oEmitInt( tempOffset )
10654:          ]
10680:       | * :
10685:    ]
         
10685:    .tFreeActuals  oEmitInt( actualsSize )
10694:    ;
      
      
      
      % Called on first use of an extern method
      %
10694: DefineExternLabel( Node method ):
         % The extern name might be given explicitly, otherwise the pascal method name.
10696:    int strAddr
10696:    String externalName = oNodeGetString( method, qExternalName )
10709:    [ equal_string( externalName, stringNull )
10719:       | true :
10720:          strAddr = oStringAllocLit( ID_STRING( oNodeGetInt( method, qIdent ) ) )
10741:       | false :
10743:          strAddr = oStringAllocLit( externalName )
10753:    ]
10761:    .tLabelExtern  @EmitValue( method )  oEmitInt( strAddr )
10777:    ;
      
      
      
      % Parse a call to a built-in function, identified by the just-accepted identifier.
      % This will also generate the code to push the return value on the expr stack,
      % and push the return type on the type stack.
      %
10777: CallBuiltInFunc( Node method ):
      
         % Ord(x)
10779:    [ oNodeEqual( method, BuiltIn_Ord )
10789:       | true :
               % parameter is any scalar type (including boolean, enum, char)
               % result is integer
10790:          '('
10792:          @Expr
10794:          [ oTypeSNodeType
10796:             | nIntegerType, nEnumType :
10797:             | nBooleanType, nByteType, nCharType :  .tCastBtoI
10801:             | * :  #eTypeMismatch
10816:          ]
10816:          oTypeSPop
10817:          oTypeSPush( IntegerType )
10823:          ')'
10825:          >>
10826:       | * :
10831:    ]
      
         % Chr(x)
10831:    [ oNodeEqual( method, BuiltIn_Chr )
10841:       | true :
               % parameter is integer
               % result is char
10842:          '('
10844:          @Expr
10846:          [ oTypeSNodeType
10848:             | nIntegerType :    .tCastItoB
10851:             | nByteType :
10853:             | * :  #eTypeMismatch
10862:          ]
10862:          oTypeSPop
10863:          oTypeSPush( CharType )
10869:          ')'
10871:          >>
10872:       | * :
10877:    ]
      
         % Pred(x)
10877:    [ oNodeEqual( method, BuiltIn_Pred )
10887:       | true :
               % parameter is any enum type, as long as it has values 0..N-1
               % result is the same enum type
10888:          '('
10890:          @Expr
10892:          [ oTypeSNodeType
10894:             | nEnumType :
                     % TO DO: does this skip past type aliases?
                     % TO DO: what if using pred/succ on a subrange type?
10895:                [ oNodeGetBoolean( oTypeSTop, qHasGap )
10904:                   | true :   #eCantUsePredSuccOnEnumWithValueGaps
10907:                   | * :
10912:                ]
10912:             | * :  #eTypeMismatch
10919:          ]
10919:          .tDecI
10921:          ')'
10923:          >>
10924:       | * :
10929:    ]
      
         % Succ(x)
10929:    [ oNodeEqual( method, BuiltIn_Succ )
10939:       | true :
               % parameter is any enum type, as long as it has values 0..N-1
               % result is the same enum type
10940:          '('
10942:          @Expr
10944:          [ oTypeSNodeType
10946:             | nEnumType :
                     % TO DO: does this skip past type aliases?
                     % TO DO: what if using pred/succ on a subrange type?
10947:                [ oNodeGetBoolean( oTypeSTop, qHasGap )
10956:                   | true :   #eCantUsePredSuccOnEnumWithValueGaps
10959:                   | * :
10964:                ]
10964:             | * :  #eTypeMismatch
10971:          ]
10971:          .tIncI
10973:          ')'
10975:          >>
10976:       | * :
10981:    ]
      
10981:    #eNotImplemented
10984:    ;
      
10984: include 'pascal_type.ssl'
      %
      % Pascal Compiler
      %
      
      % ------------------------------ Types -----------------------------
      
      
      % Create and return a new nType of the given node_type, adding it to the type table.
      %
10984: newType( node_type nt, int size ) >> Node:
10986:   Node node = oNodeNew( nt )
10996:   oNodeSetInt( node, qSize, size )
11008:   oTypeAdd( node )
11014:   >> node
11018:   ;
      
      
      % Parse a type reference, returning the nType.
      % This will add types to the type table, as needed.
      %
      % Style question - at the moment I think callers look clearer if we use
      % an out param here, rather than a return value.
      %
11018: TypeRef( out Node resultType ):
11020:    [
11020:       | pIdent :           % previously named type (including intrinsics)
11022:          Node decl = oScopeFindRequire
11027:          @ResolveUnitRef( decl )
11034:          [ oNodeType( decl )
11041:             | nTypeDecl :
11042:                resultType = oNodeGet( decl, qType )
11055:             | * :
11060:                #eNotType
11062:                resultType = IntegerType
11068:          ]
         
11068:       | pArray :
11070:          '['
      
               % A multi-dimensional array is represented as a chain
               %    array [subrange1] of array [subrange2] of elementType
      
               % First, we build a vector of nArray's, each with one subrange as its index type,
               % but without setting the "of" type or size.
      
11072:          NodeVec dimensions = oNodeVecNew
      
11077:          {
                  % to do: probably should use general subrange parsing, incl minimal size value
                  %   In fact, supposed to parse ordinal_type here.  all ordinal types have a static low, high.
                  %   Not necessary to be a subrange.
      
11077:             Node subrange = oNodeNew( nSubrangeType )
      
11087:             @ConstExpr
11089:             oNodeSetInt( subrange, qLow, oValueTop )
11100:             oValuePop
11101:             '..'
11103:             @ConstExpr
11105:             oNodeSetInt( subrange, qHigh, oValueTop )
11116:             oValuePop
      
11117:             @ConstMatchTypes
11119:             oNodeSet( subrange, qBaseType, oTypeSTop )
11130:             oNodeSetInt( subrange, qSize, oNodeGetInt( oTypeSTop, qSize ) )
11148:             oTypeSPop
11149:             oTypeAdd( subrange )
      
11155:             Node a = oNodeNew( nArrayType )
11165:             oNodeSet( a, qIndexType, subrange )
      
11177:             oNodeVecAppend( dimensions, a )
                  % I'll hold off on adding 'a' to the type table since not fully formed yet
      
11186:             [
11186:                | ']' : >
11190:                | ',' :
11192:             ]
11200:          }
      
11202:          pOf
11204:          Node baseType
11204:          @TypeRef( baseType )
      
               % Work backwards through the dimensions,
               % hooking up the 'of' type and calculating the size.
               % At each iteration, baseType is the 'of' type.
      
11211:          int dim = oNodeVecSize( dimensions )
      
11221:          {
11221:              dec(dim)
      
11227:              Node a = oNodeVecElement( dimensions, dim )
      
11240:              oNodeSet( a, qBaseType, baseType )
11252:              Node subrange = oNodeGet( a, qIndexType )
11265:              int width = subtract( oNodeGetInt( subrange, qHigh ), oNodeGetInt( subrange, qLow ) )
11292:              inc( width )
11298:              oNodeSetInt( a, qSize, multiply( width, oNodeGetInt( baseType, qSize ) ) )
      
11324:              oTypeAdd( a )
11330:              baseType = a
      
11336:              [ equal_zero(dim)
11343:                  | true:  >
11346:                  | *:
11351:              ]
11351:          }
      
11353:          resultType = oNodeVecElement( dimensions, 0 )
11366:          oNodeVecDelete( dimensions )
      
11372:       | '^' :
11374:          Node theType
11374:          @TypeRef( theType )
11381:          resultType = @PointerTypeTo( theType )
      
11392:       | pRecord :
11394:          resultType = oNodeNew( nRecordType )
11404:          oScopeBegin( -1, allocUp )    % level is meaningless here
      
11413:          @VarDecl( nRecordField )
      
11420:          int size = oNodeGetInt( oScopeCurrent, qSize )
               % to do: padding
11432:          [ equal_zero( size )
11439:             | true : #eRecordEmpty
11442:             | * :
11447:          ]
      
11447:          pEnd
      
11449:          oNodeSet( resultType, qScope, oScopeCurrent )
11460:          oNodeSetInt( resultType, qSize, size )
11472:          oScopeEnd
11473:          oTypeAdd( resultType )
      
      
11479:       | '(' :
               % An enum type declaration.
11481:          @EnumTypeRef( resultType )
      
      
            % *** TO DO: following type constructors are not implemented *** 
11488:       | pSet :
11490:          pOf
11492:          Node theType
11492:          @TypeRef( theType )
11499:          #eNotImplemented
11501:       | * :       % this works for cases except where expr starts with an id
11516:          @ConstExpr '..' @ConstExpr
11522:          @ConstMatchTypes
11524:          #eNotImplemented
11526:    ];
      
      
      % Parse an enum type.
      % We've already accepted the '('
      % Returns the new type.
      %
11527: EnumTypeRef( out Node resultType ):
      
11529:    resultType = oNodeNew( nEnumType )
11539:    int value = 0
11545:    int numValues = 0
11551:    boolean first = true
      
         % We'll declare the enum values in two scopes: the current scope, and a scope nested in the enum type.
         % That will let programs use either <val> or <enumType>.<val>
11557:    Node outerScope = oScopeCurrent
11562:    oScopeBegin( -1, allocUp )   % level is meaningless, and we won't use allocate
      
11571:    {
            % TO DO: assert that name not already seen in this scope, i.e. this enum.
            %  And possibly not in the outerScope either, since that probably wouldn't count as shadowing.
            %  It might be in some other higher/used scope.
11571:       pIdent
11573:       Node decl = @newIdent( nEnumValue, LAST_ID )
11586:       Node decl2 = @newIdent( nEnumValue, LAST_ID )
11599:       oNodeSet( decl, qType, resultType )
11611:       oNodeSet( decl2, qType, resultType )
      
            % build up name table, for i/o
11623:       int nameOffset = oStringAllocLit( ID_STRING( LAST_ID ) )
11636:       oNodeSetInt( decl, qNameOffset, nameOffset )
11648:       oNodeSetInt( decl2, qNameOffset, nameOffset )
11660:       [
11660:          | '=', ':=' :
11662:             oTypeSPush( IntegerType )
11668:             @ConstExpr
11670:             @ConstCoerceType
11672:             oTypeSPop
                  % value must be ascending
                  % this obviously doesn't apply to the first value
11673:             [ equal_zero( numValues )
11680:                | false :
11681:                   [ greater( oValueTop, value )
11690:                      | false :   #eEnumValueNotAscending
11693:                      | * :
11698:                   ]
11698:                | * :
11703:             ]
11703:             [ equal( value, oValueTop )
11712:                | false :
                        % The values differ from 0..N-1.  pred/succ may not be used with this type.
11713:                   oNodeSetBoolean( resultType, qHasGap, true )
11725:                | * :
11730:             ]
11730:             value = oValueTop
11735:             oValuePop
11736:          | * :
11743:       ]
11743:       oNodeSetInt( decl, qValue, value )
11755:       oNodeSetInt( decl2, qValue, value )
11767:       oScopeDeclare( decl )
      
11773:       oScopeEnter( outerScope )
11779:       oScopeDeclare( decl2 )
11785:       oScopeEnd
      
11786:       inc( value )
11792:       inc( numValues )
11798:       [
11798:          | ',' :
11800:          | * :    >
11807:       ]
11807:    }
11809:    ')'
      
11811:    oNodeSet( resultType, qScope, oScopeCurrent )
11822:    oNodeSetInt( resultType, qSize, 4 )   % always integer sized
11834:    oScopeEnd
      
         % Finish creation of the name table
         %    struct {
         %      int    value;
         %      int    padding;
         %      char*  name;
         %    } table[ numValues + 1 ];
         %  final entry will have name == nullptr
         %
         % I'll need to generate init code, to store pointers in global data,
         % since I don't have a relocation mechanism for static data at the moment.
11835:    oCodePush( @GetOrCreateInitCode( globalScope ) )
11846:    oScopeEnter( globalScope )
11852:    int size = multiply( add( numValues, 1 ), 16 )
11872:    int addr = oScopeAlloc( size, 8 )
11885:    oScopeEnd
11886:    oNodeSetInt( resultType, qNameTable, addr )
         % loop over enum values
11898:    NodeIter it = oNodeGetIter( oNodeGet( resultType, qScope ), qDecls )
11918:    {
11918:       Node enumValue = oNodeIterValue( it )
11928:       [ oNodeNull( enumValue )
11935:          | true :  >
11938:          | * :
11943:       ]
11943:       .tPushAddrGlobal  oEmitInt( addr )
11951:       .tPushConstI  oEmitInt( oNodeGetInt( enumValue, qValue ) )
11966:       .tAssignI
11968:       addr = add( addr, 8 )
11981:       .tPushAddrGlobal  oEmitInt( addr )
11989:       .tPushAddrGlobal  oEmitInt( oNodeGetInt( enumValue, qNameOffset ) )
12004:       .tAssignP
12006:       addr = add( addr, 8 )
12019:       oNodeIterNext( it )
12025:    }
         % final table entry
12027:    .tPushAddrGlobal  oEmitInt( addr )
12035:    .tPushConstI  oEmitInt( 0 )
12043:    .tAssignI
12045:    addr = add( addr, 8 )
12058:    .tPushAddrGlobal  oEmitInt( addr )
12066:    .tPushConstI  oEmitInt( 0 )
12074:    .tAssignP
12076:    addr = add( addr, 8 )
12089:    oCodePop
      
12090:    oTypeAdd( resultType )
12097:    ;
      
      
      
      % Return an nType representing a pointer to the given type.
      % (Creates a new type if necessary.)
      %
12097: PointerTypeTo( Node theType ) >> Node:
12099:    Node ptrType = oNodeGet( theType, qPointerType )
12112:    [ oNodeNull( ptrType )
12119:       | true :
12120:          ptrType = oNodeNew( nPointerType )
12130:          oNodeSet( ptrType, qBaseType, theType )
12142:          oNodeSetInt( ptrType, qSize, 8 )
12154:          oTypeAdd( ptrType )
12160:          oNodeSet( theType, qPointerType, ptrType )
12172:       | * :
12177:    ]
12177:    >> ptrType;
      
      
      
      % Return the low value of an ordinal type
      %
12181: OrdinalLow( Node theType ) >> int:
12183:    [ oNodeType( theType )
12190:       | nIntegerType :  >> oMININT
12193:       | nBooleanType :  >> 0
12198:       | nCharType :     >> 0
12203:       | nEnumType :
12205:          Node enumScope = oNodeGet( theType, qScope )
12218:          Node first = oNodeIterValue( oNodeGetIter( enumScope, qDecls ) )
12235:          >> oNodeGetInt( first, qValue )
12245:       | nSubrangeType : >> oNodeGetInt( theType, qLow )
12257:       | * :             #eNotOrdinalType
12272:                         >> 0
12275:    ];
      
      
      % Return the high value of an ordinal type
      %
12276: OrdinalHigh( Node theType ) >> int:
12278:    [ oNodeType( theType )
12285:       | nIntegerType :  >> oMAXINT
12288:       | nBooleanType :  >> 1
12293:       | nCharType :     >> 255
12298:       | nEnumType :
12300:          Node enumScope = oNodeGet( theType, qScope )
12313:          Node last = oNodeIterValue( oNodeGetIterLast( enumScope, qDecls ) )
12330:          >> oNodeGetInt( last, qValue )
12340:       | nSubrangeType : >> oNodeGetInt( theType, qHigh )
12352:       | * :             #eNotOrdinalType
12367:                         >> 0
12370:    ];
      
      
      
12371: Program:
12373:    Node t
      
12373:    workspace = oWorkspaceNew
      
         % root scope is used for builtins e.g. Integer,
         % and is a parent to any used units, and the program's own global scope.
12378:    oScopeBegin( 0, allocGlobal )
12387:    Node rootScope = oScopeCurrent
      
12392:    @installBuiltIns
      
         % Start by calling the main program routine.
      
         % This dummy call to main needs to look like a normal method itself,
         % so jit can align the stack properly.  So we need .tEnter,
         % and .tAllocActuals / .tFreeActuals.
12394:    .tEnter  oEmitInt( 0 )
12402:    Label mainLabel = oLabelNew
      
12407:    .tAllocActuals  oEmitInt( 0 )
12415:    .tCall  oEmitLabel( mainLabel )
12423:    .tFreeActuals  oEmitInt( 0 )
12431:    .tReturn
      
12433:    pProgram
12435:    pIdent
      
12437:    Node program = oNodeNew( nProgram )
12447:    oNodeSetInt( program, qIdent, LAST_ID )
12458:    oNodeSet( workspace, qProgram, program )
      
      
12470:    [
12470:       | '(' :
12472:          pIdent      % input, output files
      
12474:          t = @newIdent( nVar, LAST_ID )
12487:          oNodeSet( t, qType, FileType )
12499:          oScopeDeclareAlloc( t )
               % TO DO: I shouldn't declare the files in root scope.
               %        Should save them for program's global scope.
      
12505:          ','
12507:          pIdent
      
12509:          t = @newIdent( nVar, LAST_ID )
12522:          oNodeSet( t, qType, FileType )
12534:          oScopeDeclareAlloc( t )
      
12540:          ')'
12542:       | * :
12547:    ]
12547:    ';'
      
12549:    @UsesMySystem( program )
         % The uses clause may only appear once, immediately after the program declaration.
12556:    [
12556:       | pUses :  @UsesClause( program )
12565:       | * :
12570:    ]
12570:    @EnterUsedUnits( program )
      
         % Global scope for the program, below any used units.
12577:    oScopeBegin( 0, allocGlobal )
12586:    globalScope = oScopeCurrent
      
         % A new scope just for temporaries in the main routine
         % Create it up front, in case it's needed by variable initialization exprs.
         % But we won't stay in it here.
         % Note we say it extends the global scope, so that during main statement evaluation
         % any user labels declared in the global scope are considered to be part of the current scope.
12591:    oScopeBegin( 0, allocDown )
12600:    oNodeSet( oScopeCurrent, qExtends, globalScope )
12611:    initScope = oScopeCurrent
12616:    oNodeSet( program, qMainRoutineScope, initScope )
12628:    oScopeEnd
      
12629:    @BlockDecls( nGlobalVar )
      
      
12636:    oScopeEnter( initScope )
      
         % The block statement includes a stack frame, and enter/return,
         % even for the main routine.
         % That will be necessary for temporaries allocated in the main routine.
      
         % isMain means we'll generate calls to the unit init/final methods in here too.
         % Alternatively we could do that in a higher level method that calls main.
12642:    boolean isMain = true
12648:    @BlockStmt( mainLabel, globalScope, isMain )
      
12661:    oScopeEnd   % main routine scope
      
12662:    '.'
12664:    @CheckForUndefinedLabels
12666:    oScopeEnd   % global scope
12667:    @EndUsedUnits( program )   % used units scopes
12675:    ;
      
      
      
      
12675: Block( node_type varNodeType, Label labelForBody ):
12677:    @BlockDecls( varNodeType )
12684:    @BlockStmt( labelForBody, oScopeCurrent, false )
12696:    @CheckForUndefinedLabels
12699:    ;
      
      
12699: BlockDecls( node_type varNodeType ):
12701:    {[
12701:       | pConst :     @ConstDecl
12705:       | pType :      @TypeDecl
12709:       | pVar :       @VarDecl( varNodeType )
12718:       | pLabel :     @LabelDecl
12722:       | pProcedure : @ProcDecl
12726:       | pFunction :  @FuncDecl
12730:       | * :          >
12747:    ]}
12749:    @CheckForUndefinedMethods
12752:    ;
      
      
      % were there any procedures or functions declared in this scope
      % that were never defined?
12752: CheckForUndefinedMethods:
         % TO DO
         % Note: disregard methods marked external
12755:    ;
      
      % were there any labels declared in the current scope, and used,
      % but never defined (as the prefix of a stement)?
      %
12755: CheckForUndefinedLabels:
12757:    NodeIter it = oNodeGetIter( oScopeCurrent, qDecls )
12769:    {
12769:       Node decl = oNodeIterValue( it )
12779:       [ oNodeNull( decl )
12786:          | false :
12787:          | * :  >
12794:       ]
12794:       [ oNodeType( decl )
12801:          | nLabel :
12802:             [ oNodeGetBoolean( decl, qDefined )
12812:                | false :
12813:                   [ oNodeGetBoolean( decl, qUsed )
12823:                      | true :    #eUsedButNotDefined  % TO DO: give the decl in the message
12826:                      | * :
12831:                   ]
12831:                | * :
12836:             ]
12836:          | * :
12841:       ]
12841:       oNodeIterNext( it )
12847:    }
12850:    ;
      
      
      % Given the scope of vars in this block.
      % Usually it's the current scope, but it's a bit different for the main statement.
      %
12850: BlockStmt( Label labelForBody, Node varScope, boolean isMain ):
12852:    .tLabel  oEmitLabel( labelForBody )
      
         % Proc, func, and main routine all start with tEnter
         % to create a stack frame.  This will be used for temporaries
         % (and local vars in the case of proc, func).
      
12860:    int patchLS
12860:    .tEnter  patchLS = Here  .tSpace
      
         % If we're generating the program main method,
         % add in calls to the loaded units' initialization and finalization.
12869:    [ isMain
12872:       | true :  @InitializeUnits
12875:       | * :
12880:    ]
      
         % insert any code for initialization of this scope's variables
12880:    Code initCode = oNodeGetCode( varScope, qInitCode )
12893:    oEmitCode( initCode )
12899:    oNodeSetCode( varScope, qInitCode, codeNull )
      
12911:    @Statement
      
12913:    [ isMain
12916:       | true :  @FinalizeUnits
12919:       | * :
12924:    ]
      
12924:    .tReturn
      
12926:    int localSpace = oNodeGetInt( oScopeCurrent, qSize )
12938:    oPatch( patchLS, localSpace )
12948:    ;
      
      
      % We need an initCode code stream for the given scope.
      % Create it if not present yet.  Return it.
      % (This will be used for variable initialization.)
      %
12948: GetOrCreateInitCode( Node scope ) >> Code:
12950:    Code initCode = oNodeGetCode( scope, qInitCode )
12963:    [ equal_code( initCode, codeNull )
12973:       | true :
12974:          initCode = oCodeNew
12979:          oNodeSetCode( scope, qInitCode, initCode )
12991:       | * :
12996:    ]
12996:    >> initCode;
      
      
      
      
      
      % -------------------------------- Utilities -------------------------------
      
      % Return the static scope level of the current scope
      %
13000: ScopeLevel >> int:
13002:    >> oNodeGetInt( oScopeCurrent, qLevel );
      
      % Return the static scope level of the given declaration
      %
13012: DeclLevel( Node decl ) >> int:
13014:    >> oNodeGetInt( oNodeGet( decl, qParentScope ), qLevel );
         
      
      % How many levels higher is the given declaration from the current scope?
      %
13032: DeclUpLevels( Node decl ) >> int:
13034:    >> subtract( @ScopeLevel, @DeclLevel( decl ) );
      
      
      
      
      % Create and return a new nIdent of the given node_type, with the given ident id.
      % Does not add it to any scope.
      %
13050: newIdent( node_type nt, int id ) >> Node:
13052:   Node t = oNodeNew( nt )
13062:   oNodeSetInt( t, qIdent, id )
13074:   >> t
13078:   ;
      
      
      % Emit the value in a declaration.
      % For a constant integer, this is the constant value.
      % For a global variable, this is the global address.
      % For a local variable, this is the local address relative to the call stack frame.
      %
13078: EmitValue( Node decl ):
13080:     oEmitInt( oNodeGetInt( decl, qValue ));
      
      
13094: DeclareBuiltInFunc( int id ) >> Node:
13096:    Node decl = @newIdent( nBuiltInFunc, id )
13110:    oScopeDeclare( decl )
13116:    >> decl;
      
      
13120: installBuiltIns:
      
         % "mysystem" is the name of a unit that will be available everywhere.
         % Add its name to the id table so we can easily spot the name later.
13122:    mysystemId = oId_mysystem
      
         % install built-in types
13127:    FileType = @newType( nFileType, 4 )
13141:    IntegerType = @newType( nIntegerType, 4 )
13155:    BooleanType = @newType( nBooleanType, 1 )
13169:    BooleanFlowType = @newType( nBooleanFlowType, 1 )
13183:    CharType = @newType( nCharType, 1 )
13197:    PCharType = @PointerTypeTo( CharType )
13208:    ByteType = @newType( nByteType, 1 )
         % Universal pointer says base type Byte, but this is only for the sake of
         % pointer arithmetic.  It doesn't matter otherwise, because this type cannot be dereferened.
13222:    UniversalPointerType = @newType( nUniversalPointerType, 8 )
13236:    oNodeSet( UniversalPointerType, qBaseType, ByteType )
         % StrLitType is stored with both a length byte and null termination, so it can be assigned to
         % both a ShortString and a PChar.  StrLits longer than 255 characters appear truncated when
         % referenced as a ShortString, but not when referenced as a PChar.
13248:    StrLitType = @newType( nStrLitType, 256 )
         % ShortString is the original Pascal string type: an array of characters, not null-terminated,
         % with the first byte recording the current length.
         % The default ShortString type has capacity for 255 characters.  The user may define
         % additional ShortString types with smaller capacities.
         % The first character can be accessed as myString[1].
13262:    ShortStringType = @newType( nShortStringType, 256 )
13276:    oNodeSetInt( ShortStringType, qCapacity, 255 )
      
         % Declare those type identifiers.
         % SSL doesn't support strings, so need help from operations e.g. oId_File
      
13288:    Node t
      
13288:    t = @newIdent( nTypeDecl, oId_File )
13301:    oNodeSet( t, qType, FileType )
13313:    oScopeDeclare( t )
      
13319:    t = @newIdent( nTypeDecl, oId_Integer )
13332:    oNodeSet( t, qType, IntegerType )
13344:    oScopeDeclare( t )
      
13350:    t = @newIdent( nTypeDecl, oId_Boolean )
13363:    oNodeSet( t, qType, BooleanType )
13375:    oScopeDeclare( t )
      
13381:    t = @newIdent( nTypeDecl, oId_Char )
13394:    oNodeSet( t, qType, CharType )
13406:    oScopeDeclare( t )
      
13412:    t = @newIdent( nTypeDecl, oId_Byte )
13425:    oNodeSet( t, qType, ByteType )
13437:    oScopeDeclare( t )
      
13443:    t = @newIdent( nTypeDecl, oId_Pointer )
13456:    oNodeSet( t, qType, UniversalPointerType )
13468:    oScopeDeclare( t )
      
13474:    t = @newIdent( nTypeDecl, oId_ShortString )
13487:    oNodeSet( t, qType, ShortStringType )
13499:    oScopeDeclare( t )
      
         % Built-in constants
      
13505:    t = @newIdent( nConst, oId_True )
13518:    oNodeSet( t, qType, BooleanType )
13530:    oNodeSetInt( t, qValue, 1 )
13542:    oScopeDeclare( t )
      
13548:    t = @newIdent( nConst, oId_False )
13561:    oNodeSet( t, qType, BooleanType )
13573:    oNodeSetInt( t, qValue, 0 )
13585:    oScopeDeclare( t )
      
13591:    t = @newIdent( nConst, oId_Nil )
13604:    oNodeSet( t, qType, UniversalPointerType )
13616:    oNodeSetInt( t, qValue, 0 )
13628:    oScopeDeclare( t )
      
         % Built-in methods
         % These aren't declared like normal methods, because they may have
         % special rules for parameter types (e.g. any scalar type).
         % Calls to these methods will be handled specially by the compiler.
      
13634:    BuiltIn_Ord = @DeclareBuiltInFunc( oId_Ord )
13644:    BuiltIn_Chr = @DeclareBuiltInFunc( oId_Chr )
13654:    BuiltIn_Pred = @DeclareBuiltInFunc( oId_Pred )
13664:    BuiltIn_Succ = @DeclareBuiltInFunc( oId_Succ )
13675:    ;
      
13675: end
      
13675: 

Generated code:

   0: oGlobalSpace 22
   2: oLocalSpace 0
   4: oCall 12371
   6: oReturn
   7: oLocalSpace 0
   9: oInput 0
  11: LAST_ID
  12: oPushResult
  13: oGetParam 1
  15: oPushResult
  16: oCall 148
  18: oPop 2
  20: oInputChoice 24
  22: oJumpForward 29
  24: Choice Lookup Table
          13     22
  27: oJumpForward 31
  29: oJumpBack 9
  31: oInput 5
  33: oReturn
  34: oLocalSpace 0
  36: oGetParam 1
  38: oPushResult
  39: oSetResult 4
  41: oPushResult
  42: oNodeGetInt
  43: oPop 2
  45: oPushResult
  46: oGetGlobal 4
  48: oPushResult
  49: equal
  50: oPop 2
  52: oChoice 57
  54: oReturn
  55: oJumpForward 60
  57: Choice Lookup Table
           1     54
  60: oGetGlobal 4
  62: oPushResult
  63: oGetParam 1
  65: oPushResult
  66: oCall 148
  68: oPop 2
  70: oReturn
  71: oLocalSpace 0
  73: oGetParam 1
  75: oPushResult
  76: oSetResult 4
  78: oPushResult
  79: oNodeGetInt
  80: oPop 2
  82: oPushResult
  83: oGetGlobal 4
  85: oPushResult
  86: equal
  87: oPop 2
  89: oChoice 144
  91: oGetAddrGlobal 19
  93: oPushResult
  94: oScopeCurrent
  95: oPushResult
  96: oSetResult 15
  98: oPushResult
  99: oSetResult 4
 101: oPushResult
 102: oId_ShortStringAppendShortString
 103: oPushResult
 104: oNodeFind
 105: oPop 4
 107: oAssign
 108: oGetAddrGlobal 20
 110: oPushResult
 111: oScopeCurrent
 112: oPushResult
 113: oSetResult 15
 115: oPushResult
 116: oSetResult 4
 118: oPushResult
 119: oId_ShortStringAppendChar
 120: oPushResult
 121: oNodeFind
 122: oPop 4
 124: oAssign
 125: oGetAddrGlobal 21
 127: oPushResult
 128: oScopeCurrent
 129: oPushResult
 130: oSetResult 15
 132: oPushResult
 133: oSetResult 4
 135: oPushResult
 136: oId_ShortStringCmp
 137: oPushResult
 138: oNodeFind
 139: oPop 4
 141: oAssign
 142: oJumpForward 147
 144: Choice Lookup Table
           1     91
 147: oReturn
 148: oLocalSpace 2
 150: oGetAddrLocal 1
 152: oPushResult
 153: oGetParam 2
 155: oPushResult
 156: oCall 428
 158: oPop 1
 160: oAssign
 161: oGetLocal 1
 163: oPushResult
 164: oSetResult 0
 166: oPushResult
 167: equal_node
 168: oPop 2
 170: oChoice 240
 172: oGetParam 1
 174: oPushResult
 175: oSetResult 5
 177: oPushResult
 178: oGetLocal 1
 180: oPushResult
 181: oNodeAddLast
 182: oPop 3
 184: oGetAddrLocal 2
 186: oPushResult
 187: oSetResult 10
 189: oPushResult
 190: oNodeNew
 191: oPop 1
 193: oAssign
 194: oGetLocal 2
 196: oPushResult
 197: oSetResult 4
 199: oPushResult
 200: oGetLocal 1
 202: oPushResult
 203: oSetResult 4
 205: oPushResult
 206: oNodeGetInt
 207: oPop 2
 209: oPushResult
 210: oNodeSetInt
 211: oPop 3
 213: oGetLocal 2
 215: oPushResult
 216: oSetResult 9
 218: oPushResult
 219: oGetLocal 1
 221: oPushResult
 222: oSetResult 9
 224: oPushResult
 225: oNodeGet
 226: oPop 2
 228: oPushResult
 229: oNodeSet
 230: oPop 3
 232: oGetLocal 2
 234: oPushResult
 235: oScopeDeclare
 236: oPop 1
 238: oJumpForward 243
 240: Choice Lookup Table
           0    172
 243: oReturn
 244: oLocalSpace 1
 246: oGetFromParam 1
 248: oPushResult
 249: oNodeType
 250: oPop 1
 252: oChoice 283
 254: oGetAddrLocal 1
 256: oPushResult
 257: oGetFromParam 1
 259: oPushResult
 260: oSetResult 9
 262: oPushResult
 263: oNodeGet
 264: oPop 2
 266: oAssign
 267: oInput 20
 269: oInput 0
 271: oGetParam 1
 273: oPushResult
 274: oGetLocal 1
 276: oPushResult
 277: oScopeFindRequireInScope
 278: oPop 1
 280: oAssign
 281: oJumpForward 286
 283: Choice Lookup Table
          10    254
 286: oReturn
 287: oLocalSpace 2
 289: oGetAddrLocal 1
 291: oPushResult
 292: oGetParam 1
 294: oPushResult
 295: oSetResult 5
 297: oPushResult
 298: oNodeGetIter
 299: oPop 2
 301: oAssign
 302: oGetAddrLocal 2
 304: oPushResult
 305: oGetLocal 1
 307: oPushResult
 308: oNodeIterValue
 309: oPop 1
 311: oAssign
 312: oGetLocal 2
 314: oPushResult
 315: oNodeNull
 316: oPop 1
 318: oChoice 335
 320: oGetLocal 2
 322: oPushResult
 323: oSetResult 9
 325: oPushResult
 326: oNodeGet
 327: oPop 2
 329: oPushResult
 330: oScopeEnter
 331: oPop 1
 333: oJumpForward 340
 335: Choice Lookup Table
           0    320
 338: oJumpForward 348
 340: oGetAddrLocal 1
 342: oPushResult
 343: oNodeIterNext
 344: oPop 1
 346: oJumpBack 302
 348: oReturn
 349: oLocalSpace 2
 351: oGetAddrLocal 1
 353: oPushResult
 354: oGetParam 1
 356: oPushResult
 357: oSetResult 5
 359: oPushResult
 360: oNodeGetIterLast
 361: oPop 2
 363: oAssign
 364: oGetAddrLocal 2
 366: oPushResult
 367: oGetLocal 1
 369: oPushResult
 370: oNodeIterValue
 371: oPop 1
 373: oAssign
 374: oGetLocal 2
 376: oPushResult
 377: oNodeNull
 378: oPop 1
 380: oChoice 414
 382: oScopeCurrent
 383: oPushResult
 384: oGetLocal 2
 386: oPushResult
 387: oSetResult 9
 389: oPushResult
 390: oNodeGet
 391: oPop 2
 393: oPushResult
 394: oNodeEqual
 395: oPop 2
 397: oChoice 405
 399: oJumpForward 411
 401: oError 25
 403: oJumpForward 411
 405: Choice Lookup Table
           0    401
           1    399
 410: oEndChoice
 411: oScopeEnd
 412: oJumpForward 419
 414: Choice Lookup Table
           0    382
 417: oJumpForward 427
 419: oGetAddrLocal 1
 421: oPushResult
 422: oNodeIterPrev
 423: oPop 1
 425: oJumpBack 364
 427: oReturn
 428: oLocalSpace 2
 430: oGetAddrLocal 1
 432: oPushResult
 433: oGetGlobal 1
 435: oPushResult
 436: oSetResult 1
 438: oPushResult
 439: oSetResult 4
 441: oPushResult
 442: oGetParam 1
 444: oPushResult
 445: oNodeFind
 446: oPop 4
 448: oAssign
 449: oGetLocal 1
 451: oPushResult
 452: oSetResult 0
 454: oPushResult
 455: equal_node
 456: oPop 2
 458: oChoice 465
 460: oGetLocal 1
 462: oReturn
 463: oJumpForward 468
 465: Choice Lookup Table
           0    460
 468: oGetAddrLocal 2
 470: oPushResult
 471: oGetParam 1
 473: oPushResult
 474: oIncludeUnitFile
 475: oPop 1
 477: oAssign
 478: oGetLocal 2
 480: oChoice 489
 482: oError 24
 484: oSetResult 0
 486: oReturn
 487: oJumpForward 492
 489: Choice Lookup Table
           0    482
 492: oGetAddrLocal 1
 494: oPushResult
 495: oCall 503
 497: oAssign
 498: oIncludeEnd
 499: oGetLocal 1
 501: oReturn
 502: oReturn
 503: oLocalSpace 2
 505: oInput 60
 507: oInput 0
 509: oGetAddrLocal 1
 511: oPushResult
 512: oSetResult 5
 514: oPushResult
 515: oNodeNew
 516: oPop 1
 518: oAssign
 519: oGetLocal 1
 521: oPushResult
 522: oSetResult 4
 524: oPushResult
 525: LAST_ID
 526: oPushResult
 527: oNodeSetInt
 528: oPop 3
 530: oGetAddrLocal 2
 532: oPushResult
 533: oSetResult 6
 535: oPushResult
 536: oNodeNew
 537: oPop 1
 539: oAssign
 540: oGetLocal 2
 542: oPushResult
 543: oSetResult 4
 545: oPushResult
 546: LAST_ID
 547: oPushResult
 548: oNodeSetInt
 549: oPop 3
 551: oGetLocal 1
 553: oPushResult
 554: oSetResult 8
 556: oPushResult
 557: oGetLocal 2
 559: oPushResult
 560: oNodeSet
 561: oPop 3
 563: oInput 5
 565: oInput 61
 567: oGetLocal 1
 569: oPushResult
 570: oCall 34
 572: oPop 1
 574: oInputChoice 585
 576: oGetLocal 1
 578: oPushResult
 579: oCall 7
 581: oPop 1
 583: oJumpForward 588
 585: Choice Lookup Table
          59    576
 588: oGetLocal 1
 590: oPushResult
 591: oCall 287
 593: oPop 1
 595: oSetResult 0
 597: oPushResult
 598: oSetResult 0
 600: oPushResult
 601: oScopeBegin
 602: oPop 2
 604: oGetLocal 1
 606: oPushResult
 607: oSetResult 9
 609: oPushResult
 610: oScopeCurrent
 611: oPushResult
 612: oNodeSet
 613: oPop 3
 615: oGetAddrGlobal 2
 617: oPushResult
 618: oScopeCurrent
 619: oAssign
 620: oSetResult 0
 622: oPushResult
 623: oSetResult 1
 625: oPushResult
 626: oScopeBegin
 627: oPop 2
 629: oGetAddrGlobal 3
 631: oPushResult
 632: oScopeCurrent
 633: oAssign
 634: oGetLocal 1
 636: oPushResult
 637: oSetResult 13
 639: oPushResult
 640: oGetGlobal 3
 642: oPushResult
 643: oNodeSet
 644: oPop 3
 646: oScopeEnd
 647: oGetLocal 1
 649: oPushResult
 650: oCall 838
 652: oPop 1
 654: oScopeEnd
 655: oInput 62
 657: oGetLocal 2
 659: oPushResult
 660: oCall 34
 662: oPop 1
 664: oInputChoice 675
 666: oGetLocal 2
 668: oPushResult
 669: oCall 7
 671: oPop 1
 673: oJumpForward 678
 675: Choice Lookup Table
          59    666
 678: oGetLocal 2
 680: oPushResult
 681: oCall 287
 683: oPop 1
 685: oGetLocal 1
 687: oPushResult
 688: oSetResult 9
 690: oPushResult
 691: oNodeGet
 692: oPop 2
 694: oPushResult
 695: oScopeEnter
 696: oPop 1
 698: oSetResult 0
 700: oPushResult
 701: oSetResult 0
 703: oPushResult
 704: oScopeBegin
 705: oPop 2
 707: oGetLocal 1
 709: oPushResult
 710: oSetResult 10
 712: oPushResult
 713: oScopeCurrent
 714: oPushResult
 715: oNodeSet
 716: oPop 3
 718: oScopeCurrent
 719: oPushResult
 720: oSetResult 16
 722: oPushResult
 723: oGetLocal 1
 725: oPushResult
 726: oSetResult 9
 728: oPushResult
 729: oNodeGet
 730: oPop 2
 732: oPushResult
 733: oNodeSet
 734: oPop 3
 736: oGetAddrGlobal 2
 738: oPushResult
 739: oScopeCurrent
 740: oAssign
 741: oGetLocal 1
 743: oPushResult
 744: oCall 930
 746: oPop 1
 748: oInputChoice 762
 750: oGetLocal 1
 752: oPushResult
 753: oSetResult 1
 755: oPushResult
 756: oCall 940
 758: oPop 2
 760: oJumpForward 775
 762: Choice Lookup Table
          63    750
 765: oGetLocal 1
 767: oPushResult
 768: oSetResult 0
 770: oPushResult
 771: oCall 940
 773: oPop 2
 775: oInputChoice 789
 777: oGetLocal 1
 779: oPushResult
 780: oSetResult 1
 782: oPushResult
 783: oCall 1126
 785: oPop 2
 787: oJumpForward 802
 789: Choice Lookup Table
          64    777
 792: oGetLocal 1
 794: oPushResult
 795: oSetResult 0
 797: oPushResult
 798: oCall 1126
 800: oPop 2
 802: oInput 36
 804: oInput 20
 806: oScopeEnd
 807: oScopeEnd
 808: oGetLocal 2
 810: oPushResult
 811: oCall 349
 813: oPop 1
 815: oGetLocal 1
 817: oPushResult
 818: oCall 349
 820: oPop 1
 822: oGetGlobal 1
 824: oPushResult
 825: oSetResult 1
 827: oPushResult
 828: oGetLocal 1
 830: oPushResult
 831: oNodeAddLast
 832: oPop 3
 834: oGetLocal 1
 836: oReturn
 837: oReturn
 838: oLocalSpace 2
 840: oInputChoice 907
 842: oCall 2513
 844: oJumpForward 920
 846: oCall 3171
 848: oJumpForward 920
 850: oSetResult 21
 852: oPushResult
 853: oCall 3227
 855: oPop 1
 857: oJumpForward 920
 859: oGetAddrLocal 1
 861: oPushResult
 862: oCall 1480
 864: oAssign
 865: oInputChoice 878
 867: oGetLocal 1
 869: oPushResult
 870: oCall 1418
 872: oPop 1
 874: oInput 5
 876: oJumpForward 881
 878: Choice Lookup Table
          70    867
 881: oJumpForward 920
 883: oGetAddrLocal 2
 885: oPushResult
 886: oCall 1854
 888: oAssign
 889: oInputChoice 902
 891: oGetLocal 2
 893: oPushResult
 894: oCall 1418
 896: oPop 1
 898: oInput 5
 900: oJumpForward 905
 902: Choice Lookup Table
          70    891
 905: oJumpForward 920
 907: Choice Lookup Table
          30    883
          29    859
          33    850
          32    846
          31    842
 918: oJumpForward 922
 920: oJumpBack 840
 922: oGetParam 1
 924: oPushResult
 925: oCall 71
 927: oPop 1
 929: oReturn
 930: oLocalSpace 0
 932: oSetResult 21
 934: oPushResult
 935: oCall 12699
 937: oPop 1
 939: oReturn
 940: oLocalSpace 5
 942: oGetAddrLocal 1
 944: oPushResult
 945: oLabelNew
 946: oAssign
 947: oEmit 77
 949: oGetLocal 1
 951: oPushResult
 952: oEmitLabel
 953: oPop 1
 955: oGetParam 2
 957: oPushResult
 958: oSetResult 11
 960: oPushResult
 961: oGetLocal 1
 963: oPushResult
 964: oNodeSetLabel
 965: oPop 3
 967: oEmit 67
 969: oGetAddrLocal 2
 971: oPushResult
 972: Here
 973: oAssign
 974: oEmit 90
 976: oGetAddrLocal 3
 978: oPushResult
 979: oGetParam 2
 981: oPushResult
 982: oSetResult 9
 984: oPushResult
 985: oNodeGet
 986: oPop 2
 988: oAssign
 989: oGetAddrLocal 4
 991: oPushResult
 992: oGetLocal 3
 994: oPushResult
 995: oSetResult 19
 997: oPushResult
 998: oNodeGetCode
 999: oPop 2
1001: oAssign
1002: oGetLocal 4
1004: oPushResult
1005: oEmitCode
1006: oPop 1
1008: oGetLocal 3
1010: oPushResult
1011: oSetResult 19
1013: oPushResult
1014: oSetResult 0
1016: oPushResult
1017: oNodeSetCode
1018: oPop 3
1020: oGetAddrLocal 3
1022: oPushResult
1023: oGetParam 2
1025: oPushResult
1026: oSetResult 10
1028: oPushResult
1029: oNodeGet
1030: oPop 2
1032: oAssign
1033: oGetAddrLocal 4
1035: oPushResult
1036: oGetLocal 3
1038: oPushResult
1039: oSetResult 19
1041: oPushResult
1042: oNodeGetCode
1043: oPop 2
1045: oAssign
1046: oGetLocal 4
1048: oPushResult
1049: oEmitCode
1050: oPop 1
1052: oGetLocal 3
1054: oPushResult
1055: oSetResult 19
1057: oPushResult
1058: oSetResult 0
1060: oPushResult
1061: oNodeSetCode
1062: oPop 3
1064: oGetParam 2
1066: oPushResult
1067: oSetResult 13
1069: oPushResult
1070: oNodeGet
1071: oPop 2
1073: oPushResult
1074: oScopeEnter
1075: oPop 1
1077: oGetParam 1
1079: oChoice 1098
1081: oCall 8098
1083: oInputChoice 1089
1085: oCall 8098
1087: oJumpForward 1094
1089: Choice Lookup Table
           5   1085
1092: oJumpForward 1096
1094: oJumpBack 1083
1096: oJumpForward 1101
1098: Choice Lookup Table
           1   1081
1101: oEmit 66
1103: oGetAddrLocal 5
1105: oPushResult
1106: oScopeCurrent
1107: oPushResult
1108: oSetResult 17
1110: oPushResult
1111: oNodeGetInt
1112: oPop 2
1114: oAssign
1115: oGetLocal 2
1117: oPushResult
1118: oGetLocal 5
1120: oPushResult
1121: oPatch
1122: oPop 2
1124: oScopeEnd
1125: oReturn
1126: oLocalSpace 3
1128: oGetAddrLocal 1
1130: oPushResult
1131: oLabelNew
1132: oAssign
1133: oEmit 77
1135: oGetLocal 1
1137: oPushResult
1138: oEmitLabel
1139: oPop 1
1141: oGetParam 2
1143: oPushResult
1144: oSetResult 12
1146: oPushResult
1147: oGetLocal 1
1149: oPushResult
1150: oNodeSetLabel
1151: oPop 3
1153: oEmit 67
1155: oGetAddrLocal 2
1157: oPushResult
1158: Here
1159: oAssign
1160: oEmit 90
1162: oSetResult 0
1164: oPushResult
1165: oSetResult 1
1167: oPushResult
1168: oScopeBegin
1169: oPop 2
1171: oGetParam 1
1173: oChoice 1192
1175: oCall 8098
1177: oInputChoice 1183
1179: oCall 8098
1181: oJumpForward 1188
1183: Choice Lookup Table
           5   1179
1186: oJumpForward 1190
1188: oJumpBack 1177
1190: oJumpForward 1195
1192: Choice Lookup Table
           1   1175
1195: oEmit 66
1197: oGetAddrLocal 3
1199: oPushResult
1200: oScopeCurrent
1201: oPushResult
1202: oSetResult 17
1204: oPushResult
1205: oNodeGetInt
1206: oPop 2
1208: oAssign
1209: oGetLocal 2
1211: oPushResult
1212: oGetLocal 3
1214: oPushResult
1215: oPatch
1216: oPop 2
1218: oScopeEnd
1219: oReturn
1220: oLocalSpace 2
1222: oGetAddrLocal 1
1224: oPushResult
1225: oGetGlobal 1
1227: oPushResult
1228: oSetResult 1
1230: oPushResult
1231: oNodeGetIter
1232: oPop 2
1234: oAssign
1235: oGetAddrLocal 2
1237: oPushResult
1238: oGetLocal 1
1240: oPushResult
1241: oNodeIterValue
1242: oPop 1
1244: oAssign
1245: oGetLocal 2
1247: oPushResult
1248: oNodeNull
1249: oPop 1
1251: oChoice 1296
1253: oJumpForward 1304
1255: oJumpForward 1302
1257: oEmit 61
1259: oSetResult 0
1261: oPushResult
1262: oEmitInt
1263: oPop 1
1265: oEmit 64
1267: oGetLocal 2
1269: oPushResult
1270: oSetResult 11
1272: oPushResult
1273: oNodeGetLabel
1274: oPop 2
1276: oPushResult
1277: oEmitLabel
1278: oPop 1
1280: oEmit 63
1282: oSetResult 0
1284: oPushResult
1285: oEmitInt
1286: oPop 1
1288: oGetAddrLocal 1
1290: oPushResult
1291: oNodeIterNext
1292: oPop 1
1294: oJumpForward 1302
1296: Choice Lookup Table
           0   1257
           1   1253
1301: oEndChoice
1302: oJumpBack 1235
1304: oReturn
1305: oLocalSpace 2
1307: oGetAddrLocal 1
1309: oPushResult
1310: oGetGlobal 1
1312: oPushResult
1313: oSetResult 1
1315: oPushResult
1316: oNodeGetIterLast
1317: oPop 2
1319: oAssign
1320: oGetAddrLocal 2
1322: oPushResult
1323: oGetLocal 1
1325: oPushResult
1326: oNodeIterValue
1327: oPop 1
1329: oAssign
1330: oGetLocal 2
1332: oPushResult
1333: oNodeNull
1334: oPop 1
1336: oChoice 1381
1338: oJumpForward 1389
1340: oJumpForward 1387
1342: oEmit 61
1344: oSetResult 0
1346: oPushResult
1347: oEmitInt
1348: oPop 1
1350: oEmit 64
1352: oGetLocal 2
1354: oPushResult
1355: oSetResult 12
1357: oPushResult
1358: oNodeGetLabel
1359: oPop 2
1361: oPushResult
1362: oEmitLabel
1363: oPop 1
1365: oEmit 63
1367: oSetResult 0
1369: oPushResult
1370: oEmitInt
1371: oPop 1
1373: oGetAddrLocal 1
1375: oPushResult
1376: oNodeIterPrev
1377: oPop 1
1379: oJumpForward 1387
1381: Choice Lookup Table
           0   1342
           1   1338
1386: oEndChoice
1387: oJumpBack 1320
1389: oReturn
1390: oLocalSpace 0
1392: oInputChoice 1410
1394: oGetParam 1
1396: oPushResult
1397: oSetResult 27
1399: oPushResult
1400: oSetResult 1
1402: oPushResult
1403: oNodeSetBoolean
1404: oPop 3
1406: oInput 5
1408: oJumpForward 1415
1410: Choice Lookup Table
          72   1394
1413: oJumpForward 1417
1415: oJumpBack 1392
1417: oReturn
1418: oLocalSpace 0
1420: oGetParam 1
1422: oPushResult
1423: oCall 13012
1425: oPop 1
1427: oPushResult
1428: equal_zero
1429: oPop 1
1431: oChoice 1437
1433: oError 23
1435: oJumpForward 1440
1437: Choice Lookup Table
           0   1433
1440: oGetParam 1
1442: oPushResult
1443: oSetResult 25
1445: oPushResult
1446: oSetResult 1
1448: oPushResult
1449: oNodeSetBoolean
1450: oPop 3
1452: oInputChoice 1476
1454: oInputChoice 1471
1456: oInput 2
1458: oGetParam 1
1460: oPushResult
1461: oSetResult 26
1463: oPushResult
1464: CURRENT_STRLIT
1465: oPushResult
1466: oNodeSetString
1467: oPop 3
1469: oJumpForward 1474
1471: Choice Lookup Table
          71   1456
1474: oJumpForward 1479
1476: Choice Lookup Table
           2   1454
1479: oReturn
1480: oLocalSpace 6
1482: oInput 0
1484: oGetAddrLocal 1
1486: oPushResult
1487: oSetResult 0
1489: oAssign
1490: oGetAddrLocal 2
1492: oPushResult
1493: oScopeFindInCurrentScope
1494: oAssign
1495: oGetLocal 2
1497: oPushResult
1498: oNodeNull
1499: oPop 1
1501: oChoice 1619
1503: oGetAddrLocal 2
1505: oPushResult
1506: oSetResult 12
1508: oPushResult
1509: LAST_ID
1510: oPushResult
1511: oCall 13050
1513: oPop 2
1515: oAssign
1516: oGetLocal 2
1518: oPushResult
1519: oSetResult 22
1521: oPushResult
1522: oLabelNew
1523: oPushResult
1524: oNodeSetLabel
1525: oPop 3
1527: oJumpForward 1625
1529: oGetAddrLocal 1
1531: oPushResult
1532: oSetResult 1
1534: oAssign
1535: oGetLocal 2
1537: oPushResult
1538: oSetResult 24
1540: oPushResult
1541: oNodeGetBoolean
1542: oPop 2
1544: oChoice 1550
1546: oError 21
1548: oJumpForward 1553
1550: Choice Lookup Table
           1   1546
1553: oGetLocal 2
1555: oPushResult
1556: oSetResult 25
1558: oPushResult
1559: oNodeGetBoolean
1560: oPop 2
1562: oChoice 1568
1564: oError 21
1566: oJumpForward 1571
1568: Choice Lookup Table
           1   1564
1571: oGetLocal 2
1573: oPushResult
1574: oNodeType
1575: oPop 1
1577: oChoice 1581
1579: oJumpForward 1586
1581: Choice Lookup Table
          12   1579
1584: oError 21
1586: oGetLocal 2
1588: oPushResult
1589: oSetResult 29
1591: oPushResult
1592: oGetLocal 2
1594: oPushResult
1595: oSetResult 23
1597: oPushResult
1598: oNodeGet
1599: oPop 2
1601: oPushResult
1602: oNodeSet
1603: oPop 3
1605: oGetLocal 2
1607: oPushResult
1608: oSetResult 23
1610: oPushResult
1611: oSetResult 0
1613: oPushResult
1614: oNodeSet
1615: oPop 3
1617: oJumpForward 1625
1619: Choice Lookup Table
           0   1529
           1   1503
1624: oEndChoice
1625: oGetAddrLocal 3
1627: oPushResult
1628: oCall 13000
1630: oAssign
1631: oGetAddrLocal 4
1633: oPushResult
1634: oGetLocal 3
1636: oPushResult
1637: oSetResult 0
1639: oPushResult
1640: greater
1641: oPop 2
1643: oAssign
1644: oGetAddrLocal 3
1646: oPushResult
1647: inc
1648: oPop 1
1650: oGetLocal 3
1652: oPushResult
1653: oSetResult 2
1655: oPushResult
1656: oScopeBegin
1657: oPop 2
1659: oGetAddrLocal 5
1661: oPushResult
1662: oScopeCurrent
1663: oAssign
1664: oGetLocal 4
1666: oChoice 1685
1668: oGetAddrLocal 6
1670: oPushResult
1671: oGetGlobal 6
1673: oPushResult
1674: oCall 12097
1676: oPop 1
1678: oPushResult
1679: oScopeAllocType
1680: oPop 1
1682: oAssign
1683: oJumpForward 1688
1685: Choice Lookup Table
           1   1668
1688: oCall 2289
1690: oGetLocal 2
1692: oPushResult
1693: oSetResult 23
1695: oPushResult
1696: oGetLocal 5
1698: oPushResult
1699: oNodeSet
1700: oPop 3
1702: oScopeEnd
1703: oInput 5
1705: oGetLocal 1
1707: oChoice 1719
1709: oGetLocal 2
1711: oPushResult
1712: oScopeDeclare
1713: oPop 1
1715: oJumpForward 1725
1717: oJumpForward 1725
1719: Choice Lookup Table
           1   1717
           0   1709
1724: oEndChoice
1725: oGetLocal 2
1727: oPushResult
1728: oCall 1390
1730: oPop 1
1732: oGetLocal 2
1734: oReturn
1735: oReturn
1736: oLocalSpace 4
1738: oGetAddrLocal 1
1740: oPushResult
1741: oCall 1480
1743: oAssign
1744: oInputChoice 1757
1746: oJumpForward 1851
1748: oGetLocal 1
1750: oPushResult
1751: oCall 1418
1753: oPop 1
1755: oJumpForward 1851
1757: Choice Lookup Table
          70   1748
          69   1746
1762: oGetAddrLocal 2
1764: oPushResult
1765: oGetLocal 1
1767: oPushResult
1768: oSetResult 23
1770: oPushResult
1771: oNodeGet
1772: oPop 2
1774: oAssign
1775: oGetLocal 2
1777: oPushResult
1778: oScopeEnter
1779: oPop 1
1781: oGetAddrLocal 3
1783: oPushResult
1784: oGetLocal 2
1786: oPushResult
1787: oSetResult 14
1789: oPushResult
1790: oNodeGetInt
1791: oPop 2
1793: oAssign
1794: oGetLocal 3
1796: oPushResult
1797: oSetResult 1
1799: oPushResult
1800: oScopeBegin
1801: oPop 2
1803: oGetLocal 1
1805: oPushResult
1806: oSetResult 6
1808: oPushResult
1809: oScopeCurrent
1810: oPushResult
1811: oNodeSet
1812: oPop 3
1814: oGetAddrLocal 4
1816: oPushResult
1817: oGetLocal 1
1819: oPushResult
1820: oSetResult 22
1822: oPushResult
1823: oNodeGetLabel
1824: oPop 2
1826: oAssign
1827: oSetResult 22
1829: oPushResult
1830: oGetLocal 4
1832: oPushResult
1833: oCall 12675
1835: oPop 2
1837: oGetLocal 1
1839: oPushResult
1840: oSetResult 24
1842: oPushResult
1843: oSetResult 1
1845: oPushResult
1846: oNodeSetBoolean
1847: oPop 3
1849: oScopeEnd
1850: oScopeEnd
1851: oInput 5
1853: oReturn
1854: oLocalSpace 8
1856: oInput 0
1858: oGetAddrLocal 1
1860: oPushResult
1861: oSetResult 0
1863: oAssign
1864: oGetAddrLocal 2
1866: oPushResult
1867: oScopeFindInCurrentScope
1868: oAssign
1869: oGetLocal 2
1871: oPushResult
1872: oNodeNull
1873: oPop 1
1875: oChoice 2006
1877: oGetAddrLocal 2
1879: oPushResult
1880: oSetResult 13
1882: oPushResult
1883: LAST_ID
1884: oPushResult
1885: oCall 13050
1887: oPop 2
1889: oAssign
1890: oGetLocal 2
1892: oPushResult
1893: oSetResult 22
1895: oPushResult
1896: oLabelNew
1897: oPushResult
1898: oNodeSetLabel
1899: oPop 3
1901: oJumpForward 2012
1903: oGetAddrLocal 1
1905: oPushResult
1906: oSetResult 1
1908: oAssign
1909: oGetLocal 2
1911: oPushResult
1912: oSetResult 24
1914: oPushResult
1915: oNodeGetBoolean
1916: oPop 2
1918: oChoice 1924
1920: oError 21
1922: oJumpForward 1927
1924: Choice Lookup Table
           1   1920
1927: oGetLocal 2
1929: oPushResult
1930: oNodeType
1931: oPop 1
1933: oChoice 1937
1935: oJumpForward 1942
1937: Choice Lookup Table
          13   1935
1940: oError 21
1942: oGetLocal 2
1944: oPushResult
1945: oSetResult 29
1947: oPushResult
1948: oGetLocal 2
1950: oPushResult
1951: oSetResult 23
1953: oPushResult
1954: oNodeGet
1955: oPop 2
1957: oPushResult
1958: oNodeSet
1959: oPop 3
1961: oGetLocal 2
1963: oPushResult
1964: oSetResult 23
1966: oPushResult
1967: oSetResult 0
1969: oPushResult
1970: oNodeSet
1971: oPop 3
1973: oGetLocal 2
1975: oPushResult
1976: oSetResult 30
1978: oPushResult
1979: oGetLocal 2
1981: oPushResult
1982: oSetResult 21
1984: oPushResult
1985: oNodeGet
1986: oPop 2
1988: oPushResult
1989: oNodeSet
1990: oPop 3
1992: oGetLocal 2
1994: oPushResult
1995: oSetResult 21
1997: oPushResult
1998: oSetResult 0
2000: oPushResult
2001: oNodeSet
2002: oPop 3
2004: oJumpForward 2012
2006: Choice Lookup Table
           0   1903
           1   1877
2011: oEndChoice
2012: oGetAddrLocal 3
2014: oPushResult
2015: oCall 13000
2017: oAssign
2018: oGetAddrLocal 4
2020: oPushResult
2021: oGetLocal 3
2023: oPushResult
2024: oSetResult 0
2026: oPushResult
2027: greater
2028: oPop 2
2030: oAssign
2031: oGetAddrLocal 3
2033: oPushResult
2034: inc
2035: oPop 1
2037: oGetLocal 3
2039: oPushResult
2040: oSetResult 2
2042: oPushResult
2043: oScopeBegin
2044: oPop 2
2046: oGetAddrLocal 5
2048: oPushResult
2049: oScopeCurrent
2050: oAssign
2051: oGetLocal 4
2053: oChoice 2072
2055: oGetAddrLocal 6
2057: oPushResult
2058: oGetGlobal 6
2060: oPushResult
2061: oCall 12097
2063: oPop 1
2065: oPushResult
2066: oScopeAllocType
2067: oPop 1
2069: oAssign
2070: oJumpForward 2075
2072: Choice Lookup Table
           1   2055
2075: oCall 2289
2077: oGetLocal 2
2079: oPushResult
2080: oSetResult 23
2082: oPushResult
2083: oGetLocal 5
2085: oPushResult
2086: oNodeSet
2087: oPop 3
2089: oInput 12
2091: oGetAddrLocal 7
2093: oPushResult
2094: oCall 11018
2096: oPop 1
2098: oGetLocal 2
2100: oPushResult
2101: oSetResult 21
2103: oPushResult
2104: oGetLocal 7
2106: oPushResult
2107: oNodeSet
2108: oPop 3
2110: oGetAddrLocal 8
2112: oPushResult
2113: oGetLocal 7
2115: oPushResult
2116: oCall 12097
2118: oPop 1
2120: oAssign
2121: oGetLocal 2
2123: oPushResult
2124: oSetResult 31
2126: oPushResult
2127: oGetLocal 8
2129: oPushResult
2130: oScopeAllocType
2131: oPop 1
2133: oPushResult
2134: oNodeSetInt
2135: oPop 3
2137: oScopeEnd
2138: oInput 5
2140: oGetLocal 1
2142: oChoice 2154
2144: oGetLocal 2
2146: oPushResult
2147: oScopeDeclare
2148: oPop 1
2150: oJumpForward 2160
2152: oJumpForward 2160
2154: Choice Lookup Table
           1   2152
           0   2144
2159: oEndChoice
2160: oGetLocal 2
2162: oPushResult
2163: oCall 1390
2165: oPop 1
2167: oGetLocal 2
2169: oReturn
2170: oReturn
2171: oLocalSpace 4
2173: oGetAddrLocal 1
2175: oPushResult
2176: oCall 1854
2178: oAssign
2179: oInputChoice 2192
2181: oJumpForward 2286
2183: oGetLocal 1
2185: oPushResult
2186: oCall 1418
2188: oPop 1
2190: oJumpForward 2286
2192: Choice Lookup Table
          70   2183
          69   2181
2197: oGetAddrLocal 2
2199: oPushResult
2200: oGetLocal 1
2202: oPushResult
2203: oSetResult 23
2205: oPushResult
2206: oNodeGet
2207: oPop 2
2209: oAssign
2210: oGetLocal 2
2212: oPushResult
2213: oScopeEnter
2214: oPop 1
2216: oGetAddrLocal 3
2218: oPushResult
2219: oGetLocal 2
2221: oPushResult
2222: oSetResult 14
2224: oPushResult
2225: oNodeGetInt
2226: oPop 2
2228: oAssign
2229: oGetLocal 3
2231: oPushResult
2232: oSetResult 1
2234: oPushResult
2235: oScopeBegin
2236: oPop 2
2238: oGetLocal 1
2240: oPushResult
2241: oSetResult 6
2243: oPushResult
2244: oScopeCurrent
2245: oPushResult
2246: oNodeSet
2247: oPop 3
2249: oGetAddrLocal 4
2251: oPushResult
2252: oGetLocal 1
2254: oPushResult
2255: oSetResult 22
2257: oPushResult
2258: oNodeGetLabel
2259: oPop 2
2261: oAssign
2262: oSetResult 22
2264: oPushResult
2265: oGetLocal 4
2267: oPushResult
2268: oCall 12675
2270: oPop 2
2272: oGetLocal 1
2274: oPushResult
2275: oSetResult 24
2277: oPushResult
2278: oSetResult 1
2280: oPushResult
2281: oNodeSetBoolean
2282: oPop 3
2284: oScopeEnd
2285: oScopeEnd
2286: oInput 5
2288: oReturn
2289: oLocalSpace 6
2291: oInputChoice 2509
2293: oGetAddrLocal 1
2295: oPushResult
2296: oNodeVecNew
2297: oAssign
2298: oGetAddrLocal 3
2300: oPushResult
2301: oSetResult 0
2303: oAssign
2304: oInputChoice 2314
2306: oGetAddrLocal 3
2308: oPushResult
2309: oSetResult 1
2311: oAssign
2312: oJumpForward 2317
2314: Choice Lookup Table
          33   2306
2317: oInput 0
2319: oGetAddrLocal 2
2321: oPushResult
2322: oSetResult 24
2324: oPushResult
2325: LAST_ID
2326: oPushResult
2327: oCall 13050
2329: oPop 2
2331: oAssign
2332: oGetLocal 2
2334: oPushResult
2335: oSetResult 34
2337: oPushResult
2338: oGetLocal 3
2340: oPushResult
2341: oNodeSetBoolean
2342: oPop 3
2344: oGetLocal 1
2346: oPushResult
2347: oGetLocal 2
2349: oPushResult
2350: oNodeVecAppend
2351: oPop 2
2353: oInputChoice 2361
2355: oJumpForward 2369
2357: oJumpForward 2367
2359: oJumpForward 2367
2361: Choice Lookup Table
          13   2359
          12   2355
2366: oEndChoice
2367: oJumpBack 2317
2369: oGetAddrLocal 4
2371: oPushResult
2372: oCall 11018
2374: oPop 1
2376: oGetLocal 3
2378: oChoice 2393
2380: oGetAddrLocal 5
2382: oPushResult
2383: oGetLocal 4
2385: oPushResult
2386: oCall 12097
2388: oPop 1
2390: oAssign
2391: oJumpForward 2402
2393: Choice Lookup Table
           1   2380
2396: oGetAddrLocal 5
2398: oPushResult
2399: oGetLocal 4
2401: oAssign
2402: oGetAddrLocal 6
2404: oPushResult
2405: oSetResult 0
2407: oAssign
2408: oGetLocal 6
2410: oPushResult
2411: oGetLocal 1
2413: oPushResult
2414: oNodeVecSize
2415: oPop 1
2417: oPushResult
2418: equal
2419: oPop 2
2421: oChoice 2478
2423: oGetAddrLocal 2
2425: oPushResult
2426: oGetLocal 1
2428: oPushResult
2429: oGetLocal 6
2431: oPushResult
2432: oNodeVecElement
2433: oPop 2
2435: oAssign
2436: oGetLocal 2
2438: oPushResult
2439: oSetResult 21
2441: oPushResult
2442: oGetLocal 4
2444: oPushResult
2445: oNodeSet
2446: oPop 3
2448: oGetLocal 2
2450: oPushResult
2451: oScopeDeclare
2452: oPop 1
2454: oGetLocal 2
2456: oPushResult
2457: oSetResult 22
2459: oPushResult
2460: oGetLocal 5
2462: oPushResult
2463: oScopeAllocType
2464: oPop 1
2466: oPushResult
2467: oNodeSetInt
2468: oPop 3
2470: oGetAddrLocal 6
2472: oPushResult
2473: inc
2474: oPop 1
2476: oJumpForward 2483
2478: Choice Lookup Table
           0   2423
2481: oJumpForward 2485
2483: oJumpBack 2408
2485: oGetLocal 1
2487: oPushResult
2488: oNodeVecDelete
2489: oPop 1
2491: oInputChoice 2499
2493: oJumpForward 2507
2495: oJumpForward 2505
2497: oJumpForward 2505
2499: Choice Lookup Table
           5   2497
          15   2493
2504: oEndChoice
2505: oJumpBack 2293
2507: oJumpForward 2512
2509: Choice Lookup Table
          14   2293
2512: oReturn
2513: oLocalSpace 0
2515: oInputChoice 2530
2517: oInputChoice 2523
2519: oCall 2647
2521: oJumpForward 2528
2523: Choice Lookup Table
          12   2519
2526: oCall 2538
2528: oJumpForward 2535
2530: Choice Lookup Table
           0   2517
2533: oJumpForward 2537
2535: oJumpBack 2515
2537: oReturn
2538: oLocalSpace 2
2540: oGetAddrLocal 1
2542: oPushResult
2543: LAST_ID
2544: oAssign
2545: oInput 6
2547: oCall 3526
2549: oTypeSNodeType
2550: oChoice 2606
2552: oGetAddrLocal 2
2554: oPushResult
2555: oSetResult 16
2557: oPushResult
2558: oGetLocal 1
2560: oPushResult
2561: oCall 13050
2563: oPop 2
2565: oAssign
2566: oGetLocal 2
2568: oPushResult
2569: oSetResult 22
2571: oPushResult
2572: oValueTop
2573: oPushResult
2574: oNodeSetInt
2575: oPop 3
2577: oJumpForward 2625
2579: oGetAddrLocal 2
2581: oPushResult
2582: oSetResult 18
2584: oPushResult
2585: oGetLocal 1
2587: oPushResult
2588: oCall 13050
2590: oPop 2
2592: oAssign
2593: oGetLocal 2
2595: oPushResult
2596: oSetResult 33
2598: oPushResult
2599: oValueTopString
2600: oPushResult
2601: oNodeSetString
2602: oPop 3
2604: oJumpForward 2625
2606: Choice Lookup Table
          39   2579
          35   2552
          34   2552
          41   2552
          29   2552
          33   2552
          30   2552
          31   2552
2623: oError 17
2625: oValuePop
2626: oGetLocal 2
2628: oPushResult
2629: oSetResult 21
2631: oPushResult
2632: oTypeSTop
2633: oPushResult
2634: oNodeSet
2635: oPop 3
2637: oTypeSPop
2638: oGetLocal 2
2640: oPushResult
2641: oScopeDeclare
2642: oPop 1
2644: oInput 5
2646: oReturn
2647: oLocalSpace 3
2649: oGetAddrLocal 1
2651: oPushResult
2652: oSetResult 25
2654: oPushResult
2655: LAST_ID
2656: oPushResult
2657: oCall 13050
2659: oPop 2
2661: oAssign
2662: oGetAddrLocal 2
2664: oPushResult
2665: oCall 11018
2667: oPop 1
2669: oGetLocal 1
2671: oPushResult
2672: oSetResult 21
2674: oPushResult
2675: oGetLocal 2
2677: oPushResult
2678: oNodeSet
2679: oPop 3
2681: oGetLocal 2
2683: oPushResult
2684: oNodeType
2685: oPop 1
2687: oChoice 2791
2689: oInput 6
2691: oGetLocal 2
2693: oPushResult
2694: oTypeSPush
2695: oPop 1
2697: oCall 3526
2699: oCall 4268
2701: oGetLocal 1
2703: oPushResult
2704: oSetResult 22
2706: oPushResult
2707: oValueTop
2708: oPushResult
2709: oNodeSetInt
2710: oPop 3
2712: oValuePop
2713: oTypeSPop
2714: oGetLocal 1
2716: oPushResult
2717: oScopeDeclare
2718: oPop 1
2720: oInput 5
2722: oJumpForward 2815
2724: oError 16
2726: oJumpForward 2815
2728: oGetGlobal 2
2730: oPushResult
2731: oScopeEnter
2732: oPop 1
2734: oGetAddrLocal 3
2736: oPushResult
2737: oGetLocal 2
2739: oPushResult
2740: oScopeAllocType
2741: oPop 1
2743: oAssign
2744: oScopeEnd
2745: oGetGlobal 2
2747: oPushResult
2748: oCall 12948
2750: oPop 1
2752: oPushResult
2753: oCodePush
2754: oPop 1
2756: oGetLocal 1
2758: oPushResult
2759: oSetResult 22
2761: oPushResult
2762: oGetLocal 3
2764: oPushResult
2765: oNodeSetInt
2766: oPop 3
2768: oInput 6
2770: oGetLocal 2
2772: oPushResult
2773: oGetLocal 3
2775: oPushResult
2776: oCall 2816
2778: oPop 2
2780: oCodePop
2781: oGetLocal 1
2783: oPushResult
2784: oScopeDeclare
2785: oPop 1
2787: oInput 5
2789: oJumpForward 2815
2791: Choice Lookup Table
          38   2728
          36   2728
          28   2724
          40   2724
          35   2689
          34   2689
          41   2689
          29   2689
          33   2689
          30   2689
          31   2689
2814: oEndChoice
2815: oReturn
2816: oLocalSpace 10
2818: oGetParam 2
2820: oPushResult
2821: oNodeType
2822: oPop 1
2824: oChoice 3146
2826: oGetAddrLocal 1
2828: oPushResult
2829: oGetParam 2
2831: oPushResult
2832: oSetResult 37
2834: oPushResult
2835: oNodeGet
2836: oPop 2
2838: oAssign
2839: oGetAddrLocal 2
2841: oPushResult
2842: oGetParam 2
2844: oPushResult
2845: oSetResult 38
2847: oPushResult
2848: oNodeGet
2849: oPop 2
2851: oAssign
2852: oGetAddrLocal 3
2854: oPushResult
2855: oGetLocal 2
2857: oPushResult
2858: oCall 12181
2860: oPop 1
2862: oAssign
2863: oGetAddrLocal 4
2865: oPushResult
2866: oGetLocal 2
2868: oPushResult
2869: oCall 12276
2871: oPop 1
2873: oAssign
2874: oGetAddrLocal 5
2876: oPushResult
2877: oGetLocal 1
2879: oPushResult
2880: oSetResult 17
2882: oPushResult
2883: oNodeGetInt
2884: oPop 2
2886: oAssign
2887: oInput 14
2889: oGetAddrLocal 6
2891: oPushResult
2892: oGetLocal 3
2894: oAssign
2895: oGetLocal 1
2897: oPushResult
2898: oGetParam 1
2900: oPushResult
2901: oCall 2816
2903: oPop 2
2905: oGetLocal 6
2907: oPushResult
2908: oGetLocal 4
2910: oPushResult
2911: equal
2912: oPop 2
2914: oChoice 2922
2916: oJumpForward 2951
2918: oJumpForward 2928
2920: oJumpForward 2928
2922: Choice Lookup Table
           0   2920
           1   2916
2927: oEndChoice
2928: oInput 13
2930: oGetAddrParam 1
2932: oPushResult
2933: oGetParam 1
2935: oPushResult
2936: oGetLocal 5
2938: oPushResult
2939: add
2940: oPop 2
2942: oAssign
2943: oGetAddrLocal 6
2945: oPushResult
2946: inc
2947: oPop 1
2949: oJumpBack 2895
2951: oInput 15
2953: oJumpForward 3170
2955: oInput 14
2957: oGetAddrLocal 7
2959: oPushResult
2960: oGetParam 2
2962: oPushResult
2963: oSetResult 41
2965: oPushResult
2966: oNodeGet
2967: oPop 2
2969: oAssign
2970: oInputChoice 2974
2972: oJumpForward 2979
2974: Choice Lookup Table
           0   2972
2977: oJumpForward 3045
2979: oGetAddrLocal 8
2981: oPushResult
2982: oGetLocal 7
2984: oPushResult
2985: oScopeFindRequireInScope
2986: oPop 1
2988: oAssign
2989: oInput 12
2991: oGetAddrLocal 9
2993: oPushResult
2994: oGetLocal 8
2996: oPushResult
2997: oSetResult 21
2999: oPushResult
3000: oNodeGet
3001: oPop 2
3003: oAssign
3004: oGetAddrLocal 10
3006: oPushResult
3007: oGetParam 1
3009: oPushResult
3010: oGetLocal 8
3012: oPushResult
3013: oSetResult 22
3015: oPushResult
3016: oNodeGetInt
3017: oPop 2
3019: oPushResult
3020: add
3021: oPop 2
3023: oAssign
3024: oGetLocal 9
3026: oPushResult
3027: oGetLocal 10
3029: oPushResult
3030: oCall 2816
3032: oPop 2
3034: oInputChoice 3038
3036: oJumpForward 3043
3038: Choice Lookup Table
           5   3036
3041: oJumpForward 3045
3043: oJumpBack 2970
3045: oInput 15
3047: oJumpForward 3170
3049: oEmit 16
3051: oGetParam 1
3053: oPushResult
3054: oEmitInt
3055: oPop 1
3057: oGetParam 2
3059: oPushResult
3060: oTypeSPush
3061: oPop 1
3063: oCall 3526
3065: oCall 4268
3067: oEmit 15
3069: oValueTop
3070: oPushResult
3071: oEmitInt
3072: oPop 1
3074: oValuePop
3075: oTypeSPop
3076: oEmit 27
3078: oJumpForward 3170
3080: oEmit 16
3082: oGetParam 1
3084: oPushResult
3085: oEmitInt
3086: oPop 1
3088: oGetParam 2
3090: oPushResult
3091: oTypeSPush
3092: oPop 1
3094: oCall 3526
3096: oCall 4268
3098: oEmit 15
3100: oValueTop
3101: oPushResult
3102: oEmitInt
3103: oPop 1
3105: oValuePop
3106: oTypeSPop
3107: oEmit 26
3109: oJumpForward 3170
3111: oEmit 16
3113: oGetParam 1
3115: oPushResult
3116: oEmitInt
3117: oPop 1
3119: oGetParam 2
3121: oPushResult
3122: oTypeSPush
3123: oPop 1
3125: oCall 3526
3127: oCall 4268
3129: oEmit 15
3131: oValueTop
3132: oPushResult
3133: oEmitInt
3134: oPop 1
3136: oValuePop
3137: oTypeSPop
3138: oEmit 28
3140: oJumpForward 3170
3142: oError 16
3144: oJumpForward 3170
3146: Choice Lookup Table
          28   3142
          40   3142
          35   3111
          34   3111
          41   3080
          29   3080
          33   3049
          30   3049
          31   3049
          38   2955
          36   2826
3169: oEndChoice
3170: oReturn
3171: oLocalSpace 2
3173: oInputChoice 3219
3175: oGetAddrLocal 1
3177: oPushResult
3178: oSetResult 19
3180: oPushResult
3181: LAST_ID
3182: oPushResult
3183: oCall 13050
3185: oPop 2
3187: oAssign
3188: oInput 6
3190: oGetAddrLocal 2
3192: oPushResult
3193: oCall 11018
3195: oPop 1
3197: oGetLocal 1
3199: oPushResult
3200: oSetResult 21
3202: oPushResult
3203: oGetLocal 2
3205: oPushResult
3206: oNodeSet
3207: oPop 3
3209: oGetLocal 1
3211: oPushResult
3212: oScopeDeclare
3213: oPop 1
3215: oInput 5
3217: oJumpForward 3224
3219: Choice Lookup Table
           0   3175
3222: oJumpForward 3226
3224: oJumpBack 3173
3226: oReturn
3227: oLocalSpace 6
3229: oInputChoice 3453
3231: oGetAddrLocal 1
3233: oPushResult
3234: oNodeVecNew
3235: oAssign
3236: oGetAddrLocal 2
3238: oPushResult
3239: oGetParam 1
3241: oPushResult
3242: LAST_ID
3243: oPushResult
3244: oCall 13050
3246: oPop 2
3248: oAssign
3249: oGetLocal 1
3251: oPushResult
3252: oGetLocal 2
3254: oPushResult
3255: oNodeVecAppend
3256: oPop 2
3258: oInputChoice 3264
3260: oInput 0
3262: oJumpForward 3269
3264: Choice Lookup Table
          13   3260
3267: oJumpForward 3271
3269: oJumpBack 3236
3271: oInput 12
3273: oGetAddrLocal 3
3275: oPushResult
3276: oCall 11018
3278: oPop 1
3280: oGetAddrLocal 4
3282: oPushResult
3283: oSetResult 0
3285: oAssign
3286: oGetLocal 4
3288: oPushResult
3289: oGetLocal 1
3291: oPushResult
3292: oNodeVecSize
3293: oPop 1
3295: oPushResult
3296: equal
3297: oPop 2
3299: oChoice 3340
3301: oGetAddrLocal 2
3303: oPushResult
3304: oGetLocal 1
3306: oPushResult
3307: oGetLocal 4
3309: oPushResult
3310: oNodeVecElement
3311: oPop 2
3313: oAssign
3314: oGetLocal 2
3316: oPushResult
3317: oSetResult 21
3319: oPushResult
3320: oGetLocal 3
3322: oPushResult
3323: oNodeSet
3324: oPop 3
3326: oGetLocal 2
3328: oPushResult
3329: oScopeDeclareAlloc
3330: oPop 1
3332: oGetAddrLocal 4
3334: oPushResult
3335: inc
3336: oPop 1
3338: oJumpForward 3345
3340: Choice Lookup Table
           0   3301
3343: oJumpForward 3347
3345: oJumpBack 3286
3347: oInputChoice 3440
3349: oGetLocal 1
3351: oPushResult
3352: oNodeVecSize
3353: oPop 1
3355: oChoice 3359
3357: oJumpForward 3364
3359: Choice Lookup Table
           1   3357
3362: oError 22
3364: oGetAddrLocal 5
3366: oPushResult
3367: oScopeCurrent
3368: oPushResult
3369: oCall 12948
3371: oPop 1
3373: oAssign
3374: oGetLocal 5
3376: oPushResult
3377: oCodePush
3378: oPop 1
3380: oGetAddrLocal 6
3382: oPushResult
3383: oSetResult 0
3385: oAssign
3386: oCall 13000
3388: oPushResult
3389: equal_zero
3390: oPop 1
3392: oChoice 3408
3394: oGetGlobal 3
3396: oPushResult
3397: oScopeEnter
3398: oPop 1
3400: oGetAddrLocal 6
3402: oPushResult
3403: oSetResult 1
3405: oAssign
3406: oJumpForward 3411
3408: Choice Lookup Table
           1   3394
3411: oGetLocal 2
3413: oPushResult
3414: oSetResult 1
3416: oPushResult
3417: oCall 8586
3419: oPop 2
3421: oCall 4578
3423: oCall 7768
3425: oCall 8342
3427: oGetLocal 6
3429: oChoice 3434
3431: oScopeEnd
3432: oJumpForward 3437
3434: Choice Lookup Table
           1   3431
3437: oCodePop
3438: oJumpForward 3443
3440: Choice Lookup Table
           6   3349
3443: oGetLocal 1
3445: oPushResult
3446: oNodeVecDelete
3447: oPop 1
3449: oInput 5
3451: oJumpForward 3458
3453: Choice Lookup Table
           0   3231
3456: oJumpForward 3460
3458: oJumpBack 3229
3460: oReturn
3461: oLocalSpace 2
3463: oInputChoice 3470
3465: oJumpForward 3476
3467: oChangeIntLitToLabelIdent
3468: oJumpForward 3476
3470: Choice Lookup Table
           1   3467
           0   3465
3475: oEndChoice
3476: oGetAddrLocal 1
3478: oPushResult
3479: oSetResult 26
3481: oPushResult
3482: LAST_ID
3483: oPushResult
3484: oCall 13050
3486: oPop 2
3488: oAssign
3489: oGetAddrLocal 2
3491: oPushResult
3492: oLabelNew
3493: oAssign
3494: oGetLocal 1
3496: oPushResult
3497: oSetResult 22
3499: oPushResult
3500: oGetLocal 2
3502: oPushResult
3503: oNodeSetLabel
3504: oPop 3
3506: oGetLocal 1
3508: oPushResult
3509: oScopeDeclare
3510: oPop 1
3512: oInputChoice 3516
3514: oJumpForward 3521
3516: Choice Lookup Table
          13   3514
3519: oJumpForward 3523
3521: oJumpBack 3463
3523: oInput 5
3525: oReturn
3526: oLocalSpace 0
3528: oCall 3730
3530: oInputChoice 3712
3532: oCall 3753
3534: oCall 4171
3536: oTypeSNodeType
3537: oChoice 3549
3539: oValueStringCmp
3540: oSetResult 0
3542: oPushResult
3543: oValuePush
3544: oPop 1
3546: oValueEqual
3547: oJumpForward 3553
3549: Choice Lookup Table
          39   3539
3552: oValueEqual
3553: oTypeSPop
3554: oGetGlobal 7
3556: oPushResult
3557: oTypeSPush
3558: oPop 1
3560: oJumpForward 3727
3562: oCall 3730
3564: oCall 4171
3566: oTypeSNodeType
3567: oChoice 3579
3569: oValueStringCmp
3570: oSetResult 0
3572: oPushResult
3573: oValuePush
3574: oPop 1
3576: oValueNotEqual
3577: oJumpForward 3583
3579: Choice Lookup Table
          39   3569
3582: oValueNotEqual
3583: oTypeSPop
3584: oGetGlobal 7
3586: oPushResult
3587: oTypeSPush
3588: oPop 1
3590: oJumpForward 3727
3592: oCall 3730
3594: oCall 4171
3596: oTypeSNodeType
3597: oChoice 3609
3599: oValueStringCmp
3600: oSetResult 0
3602: oPushResult
3603: oValuePush
3604: oPop 1
3606: oValueLess
3607: oJumpForward 3613
3609: Choice Lookup Table
          39   3599
3612: oValueLess
3613: oTypeSPop
3614: oGetGlobal 7
3616: oPushResult
3617: oTypeSPush
3618: oPop 1
3620: oJumpForward 3727
3622: oCall 3730
3624: oCall 4171
3626: oTypeSNodeType
3627: oChoice 3639
3629: oValueStringCmp
3630: oSetResult 0
3632: oPushResult
3633: oValuePush
3634: oPop 1
3636: oValueGreater
3637: oJumpForward 3643
3639: Choice Lookup Table
          39   3629
3642: oValueGreater
3643: oTypeSPop
3644: oGetGlobal 7
3646: oPushResult
3647: oTypeSPush
3648: oPop 1
3650: oJumpForward 3727
3652: oCall 3730
3654: oCall 4171
3656: oTypeSNodeType
3657: oChoice 3669
3659: oValueStringCmp
3660: oSetResult 0
3662: oPushResult
3663: oValuePush
3664: oPop 1
3666: oValueLessEqual
3667: oJumpForward 3673
3669: Choice Lookup Table
          39   3659
3672: oValueLessEqual
3673: oTypeSPop
3674: oGetGlobal 7
3676: oPushResult
3677: oTypeSPush
3678: oPop 1
3680: oJumpForward 3727
3682: oCall 3730
3684: oCall 4171
3686: oTypeSNodeType
3687: oChoice 3699
3689: oValueStringCmp
3690: oSetResult 0
3692: oPushResult
3693: oValuePush
3694: oPop 1
3696: oValueGreaterEqual
3697: oJumpForward 3703
3699: Choice Lookup Table
          39   3689
3702: oValueGreaterEqual
3703: oTypeSPop
3704: oGetGlobal 7
3706: oPushResult
3707: oTypeSPush
3708: oPop 1
3710: oJumpForward 3727
3712: Choice Lookup Table
          11   3682
          10   3652
           9   3622
           8   3592
           7   3562
           6   3532
3725: oJumpForward 3729
3727: oJumpBack 3530
3729: oReturn
3730: oLocalSpace 0
3732: oCall 3753
3734: oInputChoice 3745
3736: oCall 4158
3738: oCall 3753
3740: oCall 4144
3742: oValueOr
3743: oJumpForward 3750
3745: Choice Lookup Table
          57   3736
3748: oJumpForward 3752
3750: oJumpBack 3734
3752: oReturn
3753: oLocalSpace 0
3755: oCall 3776
3757: oInputChoice 3768
3759: oCall 4158
3761: oCall 3776
3763: oCall 4144
3765: oValueAnd
3766: oJumpForward 3773
3768: Choice Lookup Table
          56   3759
3771: oJumpForward 3775
3773: oJumpBack 3757
3775: oReturn
3776: oLocalSpace 0
3778: oInputChoice 3787
3780: oCall 3776
3782: oCall 4158
3784: oValueNot
3785: oJumpForward 3792
3787: Choice Lookup Table
          58   3780
3790: oCall 3793
3792: oReturn
3793: oLocalSpace 0
3795: oCall 3842
3797: oInputChoice 3832
3799: oCall 3842
3801: oCall 4171
3803: oTypeSNodeType
3804: oChoice 3809
3806: oValueStringConcat
3807: oJumpForward 3813
3809: Choice Lookup Table
          39   3806
3812: oValueAdd
3813: oJumpForward 3839
3815: oCall 3842
3817: oCall 4171
3819: oTypeSNodeType
3820: oChoice 3826
3822: oError 17
3824: oJumpForward 3830
3826: Choice Lookup Table
          39   3822
3829: oValueSub
3830: oJumpForward 3839
3832: Choice Lookup Table
          25   3815
          24   3799
3837: oJumpForward 3841
3839: oJumpBack 3797
3841: oReturn
3842: oLocalSpace 0
3844: oCall 3892
3846: oInputChoice 3882
3848: oCall 3892
3850: oCall 4171
3852: oTypeSNodeType
3853: oChoice 3859
3855: oError 17
3857: oJumpForward 3863
3859: Choice Lookup Table
          39   3855
3862: oValueMult
3863: oJumpForward 3889
3865: oCall 3892
3867: oCall 4171
3869: oTypeSNodeType
3870: oChoice 3876
3872: oError 17
3874: oJumpForward 3880
3876: Choice Lookup Table
          39   3872
3879: oValueDiv
3880: oJumpForward 3889
3882: Choice Lookup Table
          23   3865
          22   3848
3887: oJumpForward 3891
3889: oJumpBack 3846
3891: oReturn
3892: oLocalSpace 0
3894: oInputChoice 3905
3896: oCall 3913
3898: oJumpForward 3912
3900: oCall 3913
3902: oValueNegate
3903: oJumpForward 3912
3905: Choice Lookup Table
          25   3900
          24   3896
3910: oCall 3913
3912: oReturn
3913: oLocalSpace 1
3915: oInputChoice 4116
3917: TOKEN_VALUE
3918: oPushResult
3919: oValuePush
3920: oPop 1
3922: oGetGlobal 6
3924: oPushResult
3925: oTypeSPush
3926: oPop 1
3928: oJumpForward 4143
3930: TOKEN_VALUE
3931: oPushResult
3932: oValuePush
3933: oPop 1
3935: oGetGlobal 9
3937: oPushResult
3938: oTypeSPush
3939: oPop 1
3941: oJumpForward 4143
3943: CURRENT_STRLIT
3944: oPushResult
3945: oValuePushString
3946: oPop 1
3948: oGetGlobal 13
3950: oPushResult
3951: oTypeSPush
3952: oPop 1
3954: oJumpForward 4143
3956: oCall 3526
3958: oInput 15
3960: oJumpForward 4143
3962: oGetAddrLocal 1
3964: oPushResult
3965: oScopeFindRequire
3966: oAssign
3967: oGetAddrLocal 1
3969: oPushResult
3970: oCall 244
3972: oPop 1
3974: oGetLocal 1
3976: oPushResult
3977: oNodeType
3978: oPop 1
3980: oChoice 4075
3982: oGetLocal 1
3984: oPushResult
3985: oCall 4361
3987: oPop 1
3989: oJumpForward 4098
3991: oGetLocal 1
3993: oPushResult
3994: oSetResult 22
3996: oPushResult
3997: oNodeGetInt
3998: oPop 2
4000: oPushResult
4001: oValuePush
4002: oPop 1
4004: oGetLocal 1
4006: oPushResult
4007: oSetResult 21
4009: oPushResult
4010: oNodeGet
4011: oPop 2
4013: oPushResult
4014: oTypeSPush
4015: oPop 1
4017: oJumpForward 4098
4019: oGetLocal 1
4021: oPushResult
4022: oSetResult 33
4024: oPushResult
4025: oNodeGetString
4026: oPop 2
4028: oPushResult
4029: oValuePushString
4030: oPop 1
4032: oGetLocal 1
4034: oPushResult
4035: oSetResult 21
4037: oPushResult
4038: oNodeGet
4039: oPop 2
4041: oPushResult
4042: oTypeSPush
4043: oPop 1
4045: oJumpForward 4098
4047: oGetLocal 1
4049: oPushResult
4050: oSetResult 22
4052: oPushResult
4053: oNodeGetInt
4054: oPop 2
4056: oPushResult
4057: oValuePush
4058: oPop 1
4060: oGetLocal 1
4062: oPushResult
4063: oSetResult 21
4065: oPushResult
4066: oNodeGet
4067: oPop 2
4069: oPushResult
4070: oTypeSPush
4071: oPop 1
4073: oJumpForward 4098
4075: Choice Lookup Table
          17   4047
          18   4019
          16   3991
          14   3982
4084: oError 1
4086: oSetResult 0
4088: oPushResult
4089: oValuePush
4090: oPop 1
4092: oGetGlobal 6
4094: oPushResult
4095: oTypeSPush
4096: oPop 1
4098: oJumpForward 4143
4100: oError 16
4102: oSetResult 0
4104: oPushResult
4105: oValuePush
4106: oPop 1
4108: oGetGlobal 12
4110: oPushResult
4111: oTypeSPush
4112: oPop 1
4114: oJumpForward 4143
4116: Choice Lookup Table
          19   4100
           0   3962
          14   3956
           2   3943
           3   3930
           1   3917
4129: oError 1
4131: oSetResult 0
4133: oPushResult
4134: oValuePush
4135: oPop 1
4137: oGetGlobal 6
4139: oPushResult
4140: oTypeSPush
4141: oPop 1
4143: oReturn
4144: oLocalSpace 0
4146: oTypeSNodeType
4147: oChoice 4151
4149: oJumpForward 4156
4151: Choice Lookup Table
          31   4149
4154: oError 8
4156: oTypeSPop
4157: oReturn
4158: oLocalSpace 0
4160: oTypeSNodeType
4161: oChoice 4165
4163: oJumpForward 4170
4165: Choice Lookup Table
          31   4163
4168: oError 8
4170: oReturn
4171: oLocalSpace 1
4173: oGetAddrLocal 1
4175: oPushResult
4176: oTypeSNodeType
4177: oAssign
4178: oTypeSPop
4179: oGetLocal 1
4181: oPushResult
4182: oTypeSNodeType
4183: oPushResult
4184: equal_node_type
4185: oPop 2
4187: oChoice 4264
4189: oTypeSNodeType
4190: oChoice 4251
4192: oGetLocal 1
4194: oChoice 4199
4196: oReturn
4197: oJumpForward 4202
4199: Choice Lookup Table
          35   4196
4202: oJumpForward 4260
4204: oGetLocal 1
4206: oChoice 4211
4208: oReturn
4209: oJumpForward 4214
4211: Choice Lookup Table
          34   4208
4214: oJumpForward 4260
4216: oGetLocal 1
4218: oChoice 4224
4220: oValueCharToString
4221: oReturn
4222: oJumpForward 4227
4224: Choice Lookup Table
          33   4220
4227: oJumpForward 4260
4229: oGetLocal 1
4231: oChoice 4246
4233: oValueSwap
4234: oValueCharToString
4235: oValueSwap
4236: oTypeSPop
4237: oGetGlobal 13
4239: oPushResult
4240: oTypeSPush
4241: oPop 1
4243: oReturn
4244: oJumpForward 4249
4246: Choice Lookup Table
          39   4233
4249: oJumpForward 4260
4251: Choice Lookup Table
          33   4229
          39   4216
          35   4204
          34   4192
4260: oError 14
4262: oJumpForward 4267
4264: Choice Lookup Table
           0   4189
4267: oReturn
4268: oLocalSpace 1
4270: oGetAddrLocal 1
4272: oPushResult
4273: oTypeSNodeType
4274: oAssign
4275: oTypeSPop
4276: oGetLocal 1
4278: oPushResult
4279: oTypeSNodeType
4280: oPushResult
4281: equal_node_type
4282: oPop 2
4284: oChoice 4357
4286: oTypeSNodeType
4287: oChoice 4344
4289: oGetLocal 1
4291: oChoice 4296
4293: oReturn
4294: oJumpForward 4299
4296: Choice Lookup Table
          35   4293
4299: oJumpForward 4353
4301: oGetLocal 1
4303: oChoice 4308
4305: oReturn
4306: oJumpForward 4311
4308: Choice Lookup Table
          34   4305
4311: oJumpForward 4353
4313: oGetLocal 1
4315: oChoice 4321
4317: oValueCharToString
4318: oReturn
4319: oJumpForward 4324
4321: Choice Lookup Table
          33   4317
4324: oJumpForward 4353
4326: oGetLocal 1
4328: oChoice 4337
4330: oReturn
4331: oJumpForward 4342
4333: oValueCharToString
4334: oReturn
4335: oJumpForward 4342
4337: Choice Lookup Table
          33   4333
          39   4330
4342: oJumpForward 4353
4344: Choice Lookup Table
          40   4326
          39   4313
          35   4301
          34   4289
4353: oError 14
4355: oJumpForward 4360
4357: Choice Lookup Table
           0   4286
4360: oReturn
4361: oLocalSpace 0
4363: oGetParam 1
4365: oPushResult
4366: oGetGlobal 15
4368: oPushResult
4369: oNodeEqual
4370: oPop 2
4372: oChoice 4412
4374: oInput 14
4376: oCall 3526
4378: oInput 15
4380: oTypeSNodeType
4381: oChoice 4387
4383: oJumpForward 4400
4385: oJumpForward 4400
4387: Choice Lookup Table
          33   4385
          30   4385
          31   4385
          41   4383
          29   4383
4398: oError 14
4400: oTypeSPop
4401: oGetGlobal 6
4403: oPushResult
4404: oTypeSPush
4405: oPop 1
4407: oInput 15
4409: oReturn
4410: oJumpForward 4415
4412: Choice Lookup Table
           1   4374
4415: oGetParam 1
4417: oPushResult
4418: oGetGlobal 16
4420: oPushResult
4421: oNodeEqual
4422: oPop 2
4424: oChoice 4458
4426: oInput 14
4428: oCall 3526
4430: oInput 15
4432: oTypeSNodeType
4433: oChoice 4439
4435: oJumpForward 4446
4437: oJumpForward 4446
4439: Choice Lookup Table
          30   4437
          29   4435
4444: oError 14
4446: oTypeSPop
4447: oGetGlobal 9
4449: oPushResult
4450: oTypeSPush
4451: oPop 1
4453: oInput 15
4455: oReturn
4456: oJumpForward 4461
4458: Choice Lookup Table
           1   4426
4461: oGetParam 1
4463: oPushResult
4464: oGetGlobal 17
4466: oPushResult
4467: oNodeEqual
4468: oPop 2
4470: oChoice 4515
4472: oInput 14
4474: oCall 3526
4476: oTypeSNodeType
4477: oChoice 4498
4479: oTypeSTop
4480: oPushResult
4481: oSetResult 44
4483: oPushResult
4484: oNodeGetBoolean
4485: oPop 2
4487: oChoice 4493
4489: oError 28
4491: oJumpForward 4496
4493: Choice Lookup Table
           1   4489
4496: oJumpForward 4503
4498: Choice Lookup Table
          41   4479
4501: oError 14
4503: oSetResult 1
4505: oPushResult
4506: oValuePush
4507: oPop 1
4509: oValueSub
4510: oInput 15
4512: oReturn
4513: oJumpForward 4518
4515: Choice Lookup Table
           1   4472
4518: oGetParam 1
4520: oPushResult
4521: oGetGlobal 18
4523: oPushResult
4524: oNodeEqual
4525: oPop 2
4527: oChoice 4572
4529: oInput 14
4531: oCall 3526
4533: oTypeSNodeType
4534: oChoice 4555
4536: oTypeSTop
4537: oPushResult
4538: oSetResult 44
4540: oPushResult
4541: oNodeGetBoolean
4542: oPop 2
4544: oChoice 4550
4546: oError 28
4548: oJumpForward 4553
4550: Choice Lookup Table
           1   4546
4553: oJumpForward 4560
4555: Choice Lookup Table
          41   4536
4558: oError 14
4560: oSetResult 1
4562: oPushResult
4563: oValuePush
4564: oPop 1
4566: oValueAdd
4567: oInput 15
4569: oReturn
4570: oJumpForward 4575
4572: Choice Lookup Table
           1   4529
4575: oError 16
4577: oReturn
4578: oLocalSpace 1
4580: oGetAddrLocal 1
4582: oPushResult
4583: oSetResult 0
4585: oAssign
4586: oGetAddrLocal 1
4588: oPushResult
4589: oCall 4739
4591: oPop 1
4593: oGetAddrLocal 1
4595: oPushResult
4596: oCall 4639
4598: oPop 1
4600: oReturn
4601: oLocalSpace 0
4603: oGetParam 1
4605: oPushResult
4606: oCall 4739
4608: oPop 1
4610: oTypeSNodeType
4611: oChoice 4630
4613: oJumpForward 4637
4615: oGetParam 1
4617: oPushResult
4618: oLabelNew
4619: oAssign
4620: oEmit 70
4622: oGetFromParam 1
4624: oPushResult
4625: oEmitLabel
4626: oPop 1
4628: oJumpForward 4637
4630: Choice Lookup Table
          31   4615
          32   4613
4635: oError 8
4637: oTypeSPop
4638: oReturn
4639: oLocalSpace 1
4641: oTypeSNodeType
4642: oChoice 4704
4644: oGetAddrLocal 1
4646: oPushResult
4647: oLabelNew
4648: oAssign
4649: oEmit 15
4651: oSetResult 1
4653: oPushResult
4654: oEmitInt
4655: oPop 1
4657: oEmit 68
4659: oGetLocal 1
4661: oPushResult
4662: oEmitLabel
4663: oPop 1
4665: oEmit 77
4667: oGetFromParam 1
4669: oPushResult
4670: oEmitLabel
4671: oPop 1
4673: oEmit 15
4675: oSetResult 0
4677: oPushResult
4678: oEmitInt
4679: oPop 1
4681: oEmit 77
4683: oGetLocal 1
4685: oPushResult
4686: oEmitLabel
4687: oPop 1
4689: oTypeSPop
4690: oGetGlobal 7
4692: oPushResult
4693: oTypeSPush
4694: oPop 1
4696: oGetParam 1
4698: oPushResult
4699: oSetResult 0
4701: oAssign
4702: oJumpForward 4707
4704: Choice Lookup Table
          32   4644
4707: oReturn
4708: oLocalSpace 0
4710: oTypeSNodeType
4711: oChoice 4735
4713: oGetParam 1
4715: oPushResult
4716: oLabelNew
4717: oAssign
4718: oEmit 70
4720: oGetFromParam 1
4722: oPushResult
4723: oEmitLabel
4724: oPop 1
4726: oTypeSPop
4727: oGetGlobal 8
4729: oPushResult
4730: oTypeSPush
4731: oPop 1
4733: oJumpForward 4738
4735: Choice Lookup Table
          31   4713
4738: oReturn
4739: oLocalSpace 0
4741: oGetParam 1
4743: oPushResult
4744: oCall 5272
4746: oPop 1
4748: oInputChoice 5254
4750: oGetParam 1
4752: oPushResult
4753: oCall 4639
4755: oPop 1
4757: oCall 8051
4759: oGetParam 1
4761: oPushResult
4762: oCall 5272
4764: oPop 1
4766: oGetParam 1
4768: oPushResult
4769: oCall 4639
4771: oPop 1
4773: oCall 8051
4775: oCall 7920
4777: oTypeSNodeType
4778: oChoice 4806
4780: oEmit 43
4782: oJumpForward 4825
4784: oEmit 49
4786: oJumpForward 4825
4788: oEmit 55
4790: oJumpForward 4825
4792: oCall 9979
4794: oEmit 15
4796: oSetResult 0
4798: oPushResult
4799: oEmitInt
4800: oPop 1
4802: oEmit 49
4804: oJumpForward 4825
4806: Choice Lookup Table
          39   4792
          40   4792
          35   4788
          34   4788
          41   4784
          29   4784
          33   4780
          31   4780
4823: oError 17
4825: oTypeSPop
4826: oGetGlobal 7
4828: oPushResult
4829: oTypeSPush
4830: oPop 1
4832: oJumpForward 5269
4834: oGetParam 1
4836: oPushResult
4837: oCall 4639
4839: oPop 1
4841: oCall 8051
4843: oGetParam 1
4845: oPushResult
4846: oCall 5272
4848: oPop 1
4850: oGetParam 1
4852: oPushResult
4853: oCall 4639
4855: oPop 1
4857: oCall 8051
4859: oCall 7920
4861: oTypeSNodeType
4862: oChoice 4890
4864: oEmit 44
4866: oJumpForward 4909
4868: oEmit 50
4870: oJumpForward 4909
4872: oEmit 56
4874: oJumpForward 4909
4876: oCall 9979
4878: oEmit 15
4880: oSetResult 0
4882: oPushResult
4883: oEmitInt
4884: oPop 1
4886: oEmit 50
4888: oJumpForward 4909
4890: Choice Lookup Table
          39   4876
          40   4876
          35   4872
          34   4872
          41   4868
          29   4868
          33   4864
          31   4864
4907: oError 17
4909: oTypeSPop
4910: oGetGlobal 7
4912: oPushResult
4913: oTypeSPush
4914: oPop 1
4916: oJumpForward 5269
4918: oGetParam 1
4920: oPushResult
4921: oCall 4639
4923: oPop 1
4925: oCall 8051
4927: oGetParam 1
4929: oPushResult
4930: oCall 5272
4932: oPop 1
4934: oGetParam 1
4936: oPushResult
4937: oCall 4639
4939: oPop 1
4941: oCall 8051
4943: oCall 7920
4945: oTypeSNodeType
4946: oChoice 4974
4948: oEmit 46
4950: oJumpForward 4993
4952: oEmit 52
4954: oJumpForward 4993
4956: oEmit 58
4958: oJumpForward 4993
4960: oCall 9979
4962: oEmit 15
4964: oSetResult 0
4966: oPushResult
4967: oEmitInt
4968: oPop 1
4970: oEmit 52
4972: oJumpForward 4993
4974: Choice Lookup Table
          39   4960
          40   4960
          35   4956
          34   4956
          41   4952
          29   4952
          33   4948
          31   4948
4991: oError 17
4993: oTypeSPop
4994: oGetGlobal 7
4996: oPushResult
4997: oTypeSPush
4998: oPop 1
5000: oJumpForward 5269
5002: oGetParam 1
5004: oPushResult
5005: oCall 4639
5007: oPop 1
5009: oCall 8051
5011: oGetParam 1
5013: oPushResult
5014: oCall 5272
5016: oPop 1
5018: oGetParam 1
5020: oPushResult
5021: oCall 4639
5023: oPop 1
5025: oCall 8051
5027: oCall 7920
5029: oTypeSNodeType
5030: oChoice 5058
5032: oEmit 45
5034: oJumpForward 5077
5036: oEmit 51
5038: oJumpForward 5077
5040: oEmit 57
5042: oJumpForward 5077
5044: oCall 9979
5046: oEmit 15
5048: oSetResult 0
5050: oPushResult
5051: oEmitInt
5052: oPop 1
5054: oEmit 51
5056: oJumpForward 5077
5058: Choice Lookup Table
          39   5044
          40   5044
          35   5040
          34   5040
          41   5036
          29   5036
          33   5032
          31   5032
5075: oError 17
5077: oTypeSPop
5078: oGetGlobal 7
5080: oPushResult
5081: oTypeSPush
5082: oPop 1
5084: oJumpForward 5269
5086: oGetParam 1
5088: oPushResult
5089: oCall 4639
5091: oPop 1
5093: oCall 8051
5095: oGetParam 1
5097: oPushResult
5098: oCall 5272
5100: oPop 1
5102: oGetParam 1
5104: oPushResult
5105: oCall 4639
5107: oPop 1
5109: oCall 8051
5111: oCall 7920
5113: oTypeSNodeType
5114: oChoice 5142
5116: oEmit 48
5118: oJumpForward 5161
5120: oEmit 54
5122: oJumpForward 5161
5124: oEmit 60
5126: oJumpForward 5161
5128: oCall 9979
5130: oEmit 15
5132: oSetResult 0
5134: oPushResult
5135: oEmitInt
5136: oPop 1
5138: oEmit 54
5140: oJumpForward 5161
5142: Choice Lookup Table
          39   5128
          40   5128
          35   5124
          34   5124
          41   5120
          29   5120
          33   5116
          31   5116
5159: oError 17
5161: oTypeSPop
5162: oGetGlobal 7
5164: oPushResult
5165: oTypeSPush
5166: oPop 1
5168: oJumpForward 5269
5170: oGetParam 1
5172: oPushResult
5173: oCall 4639
5175: oPop 1
5177: oCall 8051
5179: oGetParam 1
5181: oPushResult
5182: oCall 5272
5184: oPop 1
5186: oGetParam 1
5188: oPushResult
5189: oCall 4639
5191: oPop 1
5193: oCall 8051
5195: oCall 7920
5197: oTypeSNodeType
5198: oChoice 5226
5200: oEmit 47
5202: oJumpForward 5245
5204: oEmit 53
5206: oJumpForward 5245
5208: oEmit 59
5210: oJumpForward 5245
5212: oCall 9979
5214: oEmit 15
5216: oSetResult 0
5218: oPushResult
5219: oEmitInt
5220: oPop 1
5222: oEmit 53
5224: oJumpForward 5245
5226: Choice Lookup Table
          39   5212
          40   5212
          35   5208
          34   5208
          41   5204
          29   5204
          33   5200
          31   5200
5243: oError 17
5245: oTypeSPop
5246: oGetGlobal 7
5248: oPushResult
5249: oTypeSPush
5250: oPop 1
5252: oJumpForward 5269
5254: Choice Lookup Table
          11   5170
          10   5086
           9   5002
           8   4918
           7   4834
           6   4750
5267: oJumpForward 5271
5269: oJumpBack 4748
5271: oReturn
5272: oLocalSpace 1
5274: oGetAddrLocal 1
5276: oPushResult
5277: oSetResult 0
5279: oAssign
5280: oGetParam 1
5282: oPushResult
5283: oCall 5452
5285: oPop 1
5287: oInputChoice 5420
5289: oTypeSNodeType
5290: oChoice 5361
5292: oGetLocal 1
5294: oPushResult
5295: oSetResult 0
5297: oPushResult
5298: equal_label
5299: oPop 2
5301: oChoice 5310
5303: oGetAddrLocal 1
5305: oPushResult
5306: oLabelNew
5307: oAssign
5308: oJumpForward 5313
5310: Choice Lookup Table
           1   5303
5313: oEmit 68
5315: oGetLocal 1
5317: oPushResult
5318: oEmitLabel
5319: oPop 1
5321: oJumpForward 5368
5323: oGetParam 1
5325: oPushResult
5326: oCall 4708
5328: oPop 1
5330: oGetLocal 1
5332: oPushResult
5333: oSetResult 0
5335: oPushResult
5336: equal_label
5337: oPop 2
5339: oChoice 5348
5341: oGetAddrLocal 1
5343: oPushResult
5344: oLabelNew
5345: oAssign
5346: oJumpForward 5351
5348: Choice Lookup Table
           1   5341
5351: oEmit 68
5353: oGetLocal 1
5355: oPushResult
5356: oEmitLabel
5357: oPop 1
5359: oJumpForward 5368
5361: Choice Lookup Table
          31   5323
          32   5292
5366: oError 8
5368: oTypeSPop
5369: oEmit 77
5371: oGetFromParam 1
5373: oPushResult
5374: oEmitLabel
5375: oPop 1
5377: oGetParam 1
5379: oPushResult
5380: oSetResult 0
5382: oAssign
5383: oGetParam 1
5385: oPushResult
5386: oCall 5452
5388: oPop 1
5390: oTypeSNodeType
5391: oChoice 5404
5393: oJumpForward 5411
5395: oGetParam 1
5397: oPushResult
5398: oCall 4708
5400: oPop 1
5402: oJumpForward 5411
5404: Choice Lookup Table
          31   5395
          32   5393
5409: oError 8
5411: oTypeSPop
5412: oGetGlobal 8
5414: oPushResult
5415: oTypeSPush
5416: oPop 1
5418: oJumpForward 5425
5420: Choice Lookup Table
          57   5289
5423: oJumpForward 5427
5425: oJumpBack 5287
5427: oGetLocal 1
5429: oPushResult
5430: oSetResult 0
5432: oPushResult
5433: equal_label
5434: oPop 2
5436: oChoice 5448
5438: oEmit 77
5440: oGetLocal 1
5442: oPushResult
5443: oEmitLabel
5444: oPop 1
5446: oJumpForward 5451
5448: Choice Lookup Table
           0   5438
5451: oReturn
5452: oLocalSpace 2
5454: oGetAddrLocal 1
5456: oPushResult
5457: oSetResult 0
5459: oAssign
5460: oGetParam 1
5462: oPushResult
5463: oCall 5590
5465: oPop 1
5467: oInputChoice 5582
5469: oTypeSNodeType
5470: oChoice 5483
5472: oJumpForward 5490
5474: oGetParam 1
5476: oPushResult
5477: oCall 4708
5479: oPop 1
5481: oJumpForward 5490
5483: Choice Lookup Table
          31   5474
          32   5472
5488: oError 8
5490: oTypeSPop
5491: oGetLocal 1
5493: oPushResult
5494: oSetResult 0
5496: oPushResult
5497: equal_label
5498: oPop 2
5500: oChoice 5529
5502: oGetAddrLocal 1
5504: oPushResult
5505: oLabelNew
5506: oAssign
5507: oEmit 78
5509: oGetFromParam 1
5511: oPushResult
5512: oEmitLabel
5513: oPop 1
5515: oGetLocal 1
5517: oPushResult
5518: oEmitLabel
5519: oPop 1
5521: oGetParam 1
5523: oPushResult
5524: oGetLocal 1
5526: oAssign
5527: oJumpForward 5532
5529: Choice Lookup Table
           1   5502
5532: oGetAddrLocal 2
5534: oPushResult
5535: oSetResult 0
5537: oAssign
5538: oGetAddrLocal 2
5540: oPushResult
5541: oCall 5590
5543: oPop 1
5545: oTypeSNodeType
5546: oChoice 5559
5548: oJumpForward 5566
5550: oGetAddrLocal 2
5552: oPushResult
5553: oCall 4708
5555: oPop 1
5557: oJumpForward 5566
5559: Choice Lookup Table
          31   5550
          32   5548
5564: oError 8
5566: oEmit 78
5568: oGetLocal 2
5570: oPushResult
5571: oEmitLabel
5572: oPop 1
5574: oGetLocal 1
5576: oPushResult
5577: oEmitLabel
5578: oPop 1
5580: oJumpForward 5587
5582: Choice Lookup Table
          56   5469
5585: oJumpForward 5589
5587: oJumpBack 5467
5589: oReturn
5590: oLocalSpace 1
5592: oInputChoice 5646
5594: oGetAddrLocal 1
5596: oPushResult
5597: oSetResult 0
5599: oAssign
5600: oGetAddrLocal 1
5602: oPushResult
5603: oCall 5590
5605: oPop 1
5607: oTypeSNodeType
5608: oChoice 5637
5610: oGetParam 1
5612: oPushResult
5613: oLabelNew
5614: oAssign
5615: oEmit 68
5617: oGetFromParam 1
5619: oPushResult
5620: oEmitLabel
5621: oPop 1
5623: oEmit 77
5625: oGetLocal 1
5627: oPushResult
5628: oEmitLabel
5629: oPop 1
5631: oJumpForward 5644
5633: oEmit 42
5635: oJumpForward 5644
5637: Choice Lookup Table
          31   5633
          32   5610
5642: oError 8
5644: oJumpForward 5656
5646: Choice Lookup Table
          58   5594
5649: oGetParam 1
5651: oPushResult
5652: oCall 5657
5654: oPop 1
5656: oReturn
5657: oLocalSpace 2
5659: oGetAddrLocal 1
5661: oPushResult
5662: oSetResult 1
5664: oAssign
5665: oGetParam 1
5667: oPushResult
5668: oCall 5893
5670: oPop 1
5672: oInputChoice 5883
5674: oTypeSNodeType
5675: oChoice 5798
5677: oCall 8005
5679: oGetParam 1
5681: oPushResult
5682: oCall 5893
5684: oPop 1
5686: oTypeSNodeType
5687: oChoice 5695
5689: oEmit 22
5691: oCall 7553
5693: oJumpForward 5704
5695: Choice Lookup Table
          35   5689
          34   5689
5700: oCall 8025
5702: oEmit 37
5704: oJumpForward 5815
5706: oGetLocal 1
5708: oChoice 5724
5710: oGetAddrLocal 2
5712: oPushResult
5713: oCall 9762
5715: oAssign
5716: oGetAddrLocal 1
5718: oPushResult
5719: oSetResult 0
5721: oAssign
5722: oJumpForward 5727
5724: Choice Lookup Table
           1   5710
5727: oGetParam 1
5729: oPushResult
5730: oCall 5893
5732: oPop 1
5734: oTypeSNodeType
5735: oChoice 5773
5737: oCall 9871
5739: oEmit 17
5741: oGetLocal 2
5743: oPushResult
5744: oEmitInt
5745: oPop 1
5747: oGetGlobal 14
5749: oPushResult
5750: oTypeSPush
5751: oPop 1
5753: oJumpForward 5783
5755: oCall 9925
5757: oEmit 17
5759: oGetLocal 2
5761: oPushResult
5762: oEmitInt
5763: oPop 1
5765: oGetGlobal 14
5767: oPushResult
5768: oTypeSPush
5769: oPop 1
5771: oJumpForward 5783
5773: Choice Lookup Table
          33   5755
          39   5737
          40   5737
5780: oError 14
5782: oTypeSPop
5783: oJumpForward 5815
5785: oGetParam 1
5787: oPushResult
5788: oCall 5893
5790: oPop 1
5792: oCall 8005
5794: oCall 7553
5796: oJumpForward 5815
5798: Choice Lookup Table
          35   5785
          34   5785
          33   5706
          39   5706
          40   5706
          30   5677
          29   5677
5813: oError 17
5815: oJumpForward 5890
5817: oTypeSNodeType
5818: oChoice 5870
5820: oCall 8005
5822: oGetParam 1
5824: oPushResult
5825: oCall 5893
5827: oPop 1
5829: oCall 8025
5831: oEmit 40
5833: oJumpForward 5881
5835: oGetParam 1
5837: oPushResult
5838: oCall 5893
5840: oPop 1
5842: oTypeSNodeType
5843: oChoice 5857
5845: oCall 8005
5847: oCall 7609
5849: oJumpForward 5868
5851: oCall 7920
5853: oCall 7665
5855: oJumpForward 5868
5857: Choice Lookup Table
          35   5851
          34   5851
          30   5845
          29   5845
5866: oError 17
5868: oJumpForward 5881
5870: Choice Lookup Table
          35   5835
          34   5835
          30   5820
          29   5820
5879: oError 17
5881: oJumpForward 5890
5883: Choice Lookup Table
          25   5817
          24   5674
5888: oJumpForward 5892
5890: oJumpBack 5672
5892: oReturn
5893: oLocalSpace 0
5895: oGetParam 1
5897: oPushResult
5898: oCall 5944
5900: oPop 1
5902: oInputChoice 5934
5904: oCall 8005
5906: oGetParam 1
5908: oPushResult
5909: oCall 5944
5911: oPop 1
5913: oCall 8025
5915: oEmit 34
5917: oJumpForward 5941
5919: oCall 8005
5921: oGetParam 1
5923: oPushResult
5924: oCall 5944
5926: oPop 1
5928: oCall 8025
5930: oEmit 35
5932: oJumpForward 5941
5934: Choice Lookup Table
          23   5919
          22   5904
5939: oJumpForward 5943
5941: oJumpBack 5902
5943: oReturn
5944: oLocalSpace 0
5946: oInputChoice 5972
5948: oGetParam 1
5950: oPushResult
5951: oCall 5985
5953: oPop 1
5955: oCall 8025
5957: oJumpForward 5984
5959: oGetParam 1
5961: oPushResult
5962: oCall 5985
5964: oPop 1
5966: oCall 8025
5968: oEmit 41
5970: oJumpForward 5984
5972: Choice Lookup Table
          25   5959
          24   5948
5977: oGetParam 1
5979: oPushResult
5980: oCall 5985
5982: oPop 1
5984: oReturn
5985: oLocalSpace 7
5987: oInputChoice 6318
5989: oEmit 15
5991: TOKEN_VALUE
5992: oPushResult
5993: oEmitInt
5994: oPop 1
5996: oGetGlobal 6
5998: oPushResult
5999: oTypeSPush
6000: oPop 1
6002: oJumpForward 6339
6004: oEmit 15
6006: TOKEN_VALUE
6007: oPushResult
6008: oEmitInt
6009: oPop 1
6011: oGetGlobal 9
6013: oPushResult
6014: oTypeSPush
6015: oPop 1
6017: oJumpForward 6339
6019: oGetParam 1
6021: oPushResult
6022: oCall 4739
6024: oPop 1
6026: oInput 15
6028: oJumpForward 6339
6030: oGetAddrLocal 1
6032: oPushResult
6033: CURRENT_STRLIT
6034: oPushResult
6035: oStringAllocShortStringLit
6036: oPop 1
6038: oAssign
6039: oEmit 16
6041: oGetLocal 1
6043: oPushResult
6044: oEmitInt
6045: oPop 1
6047: oGetGlobal 13
6049: oPushResult
6050: oTypeSPush
6051: oPop 1
6053: oCall 7151
6055: oCall 7097
6057: oJumpForward 6339
6059: oGetAddrLocal 2
6061: oPushResult
6062: oScopeFindRequire
6063: oAssign
6064: oGetAddrLocal 2
6066: oPushResult
6067: oCall 244
6069: oPop 1
6071: oGetLocal 2
6073: oPushResult
6074: oNodeType
6075: oPop 1
6077: oChoice 6240
6079: oGetLocal 2
6081: oPushResult
6082: oCall 10074
6084: oPop 1
6086: oJumpForward 6267
6088: oGetLocal 2
6090: oPushResult
6091: oCall 10777
6093: oPop 1
6095: oJumpForward 6267
6097: oGetAddrLocal 3
6099: oPushResult
6100: oGetLocal 2
6102: oPushResult
6103: oSetResult 21
6105: oPushResult
6106: oNodeGet
6107: oPop 2
6109: oAssign
6110: oGetLocal 3
6112: oPushResult
6113: oTypeSPush
6114: oPop 1
6116: oTypeSNodeType
6117: oChoice 6141
6119: oEmit 15
6121: oGetLocal 2
6123: oPushResult
6124: oCall 13078
6126: oPop 1
6128: oJumpForward 6154
6130: oEmit 15
6132: oGetLocal 2
6134: oPushResult
6135: oCall 13078
6137: oPop 1
6139: oJumpForward 6154
6141: Choice Lookup Table
          35   6130
          34   6130
          31   6119
          41   6119
          29   6119
6152: oError 16
6154: oJumpForward 6267
6156: oGetAddrLocal 4
6158: oPushResult
6159: oGetLocal 2
6161: oPushResult
6162: oSetResult 22
6164: oPushResult
6165: oNodeGetInt
6166: oPop 2
6168: oAssign
6169: oGetLocal 4
6171: oPushResult
6172: equal_zero
6173: oPop 1
6175: oChoice 6208
6177: oGetAddrLocal 4
6179: oPushResult
6180: oGetLocal 2
6182: oPushResult
6183: oSetResult 33
6185: oPushResult
6186: oNodeGetString
6187: oPop 2
6189: oPushResult
6190: oStringAllocShortStringLit
6191: oPop 1
6193: oAssign
6194: oGetLocal 2
6196: oPushResult
6197: oSetResult 22
6199: oPushResult
6200: oGetLocal 4
6202: oPushResult
6203: oNodeSetInt
6204: oPop 3
6206: oJumpForward 6211
6208: Choice Lookup Table
           1   6177
6211: oEmit 16
6213: oGetLocal 4
6215: oPushResult
6216: oEmitInt
6217: oPop 1
6219: oGetGlobal 13
6221: oPushResult
6222: oTypeSPush
6223: oPop 1
6225: oCall 7151
6227: oCall 7097
6229: oJumpForward 6267
6231: oGetLocal 2
6233: oPushResult
6234: oCall 6340
6236: oPop 1
6238: oJumpForward 6267
6240: Choice Lookup Table
          25   6231
          24   6231
          22   6231
          21   6231
          18   6156
          17   6097
          16   6097
          14   6088
          13   6079
6259: oError 6
6261: oGetGlobal 6
6263: oPushResult
6264: oTypeSPush
6265: oPop 1
6267: oJumpForward 6339
6269: oInput 0
6271: oGetAddrLocal 5
6273: oPushResult
6274: oScopeFindRequire
6275: oAssign
6276: oGetAddrLocal 5
6278: oPushResult
6279: oCall 244
6281: oPop 1
6283: oGetLocal 5
6285: oPushResult
6286: oSetResult 0
6288: oPushResult
6289: oCall 8586
6291: oPop 2
6293: oGetAddrLocal 6
6295: oPushResult
6296: oTypeSTop
6297: oAssign
6298: oTypeSPop
6299: oGetAddrLocal 7
6301: oPushResult
6302: oGetLocal 6
6304: oPushResult
6305: oCall 12097
6307: oPop 1
6309: oAssign
6310: oGetLocal 7
6312: oPushResult
6313: oTypeSPush
6314: oPop 1
6316: oJumpForward 6339
6318: Choice Lookup Table
          19   6269
           0   6059
           2   6030
          14   6019
           3   6004
           1   5989
6331: oError 6
6333: oGetGlobal 6
6335: oPushResult
6336: oTypeSPush
6337: oPop 1
6339: oReturn
6340: oLocalSpace 2
6342: oGetAddrLocal 1
6344: oPushResult
6345: oGetParam 1
6347: oPushResult
6348: oSetResult 21
6350: oPushResult
6351: oNodeGet
6352: oPop 2
6354: oAssign
6355: oGetAddrLocal 2
6357: oPushResult
6358: oGetParam 1
6360: oPushResult
6361: oCall 13032
6363: oPop 1
6365: oAssign
6366: oGetLocal 1
6368: oPushResult
6369: oTypeSPush
6370: oPop 1
6372: oTypeSNodeType
6373: oChoice 7072
6375: oGetParam 1
6377: oPushResult
6378: oNodeType
6379: oPop 1
6381: oChoice 6527
6383: oEmit 0
6385: oGetParam 1
6387: oPushResult
6388: oCall 13078
6390: oPop 1
6392: oJumpForward 6537
6394: oGetLocal 2
6396: oPushResult
6397: equal_zero
6398: oPop 1
6400: oChoice 6413
6402: oEmit 3
6404: oGetParam 1
6406: oPushResult
6407: oCall 13078
6409: oPop 1
6411: oJumpForward 6431
6413: Choice Lookup Table
           1   6402
6416: oEmit 9
6418: oGetLocal 2
6420: oPushResult
6421: oEmitInt
6422: oPop 1
6424: oGetParam 1
6426: oPushResult
6427: oCall 13078
6429: oPop 1
6431: oJumpForward 6537
6433: oGetParam 1
6435: oPushResult
6436: oSetResult 34
6438: oPushResult
6439: oNodeGetBoolean
6440: oPop 2
6442: oChoice 6485
6444: oGetLocal 2
6446: oPushResult
6447: equal_zero
6448: oPop 1
6450: oChoice 6463
6452: oEmit 8
6454: oGetParam 1
6456: oPushResult
6457: oCall 13078
6459: oPop 1
6461: oJumpForward 6481
6463: Choice Lookup Table
           1   6452
6466: oEmit 14
6468: oGetLocal 2
6470: oPushResult
6471: oEmitInt
6472: oPop 1
6474: oGetParam 1
6476: oPushResult
6477: oCall 13078
6479: oPop 1
6481: oEmit 23
6483: oJumpForward 6525
6485: Choice Lookup Table
           1   6444
6488: oGetLocal 2
6490: oPushResult
6491: equal_zero
6492: oPop 1
6494: oChoice 6507
6496: oEmit 6
6498: oGetParam 1
6500: oPushResult
6501: oCall 13078
6503: oPop 1
6505: oJumpForward 6525
6507: Choice Lookup Table
           1   6496
6510: oEmit 12
6512: oGetLocal 2
6514: oPushResult
6515: oEmitInt
6516: oPop 1
6518: oGetParam 1
6520: oPushResult
6521: oCall 13078
6523: oPop 1
6525: oJumpForward 6537
6527: Choice Lookup Table
          24   6433
          22   6394
          25   6383
          21   6383
6536: oEndChoice
6537: oJumpForward 7096
6539: oGetParam 1
6541: oPushResult
6542: oNodeType
6543: oPop 1
6545: oChoice 6691
6547: oEmit 1
6549: oGetParam 1
6551: oPushResult
6552: oCall 13078
6554: oPop 1
6556: oJumpForward 6701
6558: oGetLocal 2
6560: oPushResult
6561: equal_zero
6562: oPop 1
6564: oChoice 6577
6566: oEmit 4
6568: oGetParam 1
6570: oPushResult
6571: oCall 13078
6573: oPop 1
6575: oJumpForward 6595
6577: Choice Lookup Table
           1   6566
6580: oEmit 10
6582: oGetLocal 2
6584: oPushResult
6585: oEmitInt
6586: oPop 1
6588: oGetParam 1
6590: oPushResult
6591: oCall 13078
6593: oPop 1
6595: oJumpForward 6701
6597: oGetParam 1
6599: oPushResult
6600: oSetResult 34
6602: oPushResult
6603: oNodeGetBoolean
6604: oPop 2
6606: oChoice 6649
6608: oGetLocal 2
6610: oPushResult
6611: equal_zero
6612: oPop 1
6614: oChoice 6627
6616: oEmit 8
6618: oGetParam 1
6620: oPushResult
6621: oCall 13078
6623: oPop 1
6625: oJumpForward 6645
6627: Choice Lookup Table
           1   6616
6630: oEmit 14
6632: oGetLocal 2
6634: oPushResult
6635: oEmitInt
6636: oPop 1
6638: oGetParam 1
6640: oPushResult
6641: oCall 13078
6643: oPop 1
6645: oEmit 24
6647: oJumpForward 6689
6649: Choice Lookup Table
           1   6608
6652: oGetLocal 2
6654: oPushResult
6655: equal_zero
6656: oPop 1
6658: oChoice 6671
6660: oEmit 7
6662: oGetParam 1
6664: oPushResult
6665: oCall 13078
6667: oPop 1
6669: oJumpForward 6689
6671: Choice Lookup Table
           1   6660
6674: oEmit 13
6676: oGetLocal 2
6678: oPushResult
6679: oEmitInt
6680: oPop 1
6682: oGetParam 1
6684: oPushResult
6685: oCall 13078
6687: oPop 1
6689: oJumpForward 6701
6691: Choice Lookup Table
          24   6597
          22   6558
          25   6547
          21   6547
6700: oEndChoice
6701: oJumpForward 7096
6703: oError 16
6705: oJumpForward 7096
6707: oGetParam 1
6709: oPushResult
6710: oNodeType
6711: oPop 1
6713: oChoice 6859
6715: oEmit 2
6717: oGetParam 1
6719: oPushResult
6720: oCall 13078
6722: oPop 1
6724: oJumpForward 6869
6726: oGetLocal 2
6728: oPushResult
6729: equal_zero
6730: oPop 1
6732: oChoice 6745
6734: oEmit 5
6736: oGetParam 1
6738: oPushResult
6739: oCall 13078
6741: oPop 1
6743: oJumpForward 6763
6745: Choice Lookup Table
           1   6734
6748: oEmit 11
6750: oGetLocal 2
6752: oPushResult
6753: oEmitInt
6754: oPop 1
6756: oGetParam 1
6758: oPushResult
6759: oCall 13078
6761: oPop 1
6763: oJumpForward 6869
6765: oGetParam 1
6767: oPushResult
6768: oSetResult 34
6770: oPushResult
6771: oNodeGetBoolean
6772: oPop 2
6774: oChoice 6817
6776: oGetLocal 2
6778: oPushResult
6779: equal_zero
6780: oPop 1
6782: oChoice 6795
6784: oEmit 8
6786: oGetParam 1
6788: oPushResult
6789: oCall 13078
6791: oPop 1
6793: oJumpForward 6813
6795: Choice Lookup Table
           1   6784
6798: oEmit 14
6800: oGetLocal 2
6802: oPushResult
6803: oEmitInt
6804: oPop 1
6806: oGetParam 1
6808: oPushResult
6809: oCall 13078
6811: oPop 1
6813: oEmit 25
6815: oJumpForward 6857
6817: Choice Lookup Table
           1   6776
6820: oGetLocal 2
6822: oPushResult
6823: equal_zero
6824: oPop 1
6826: oChoice 6839
6828: oEmit 8
6830: oGetParam 1
6832: oPushResult
6833: oCall 13078
6835: oPop 1
6837: oJumpForward 6857
6839: Choice Lookup Table
           1   6828
6842: oEmit 14
6844: oGetLocal 2
6846: oPushResult
6847: oEmitInt
6848: oPop 1
6850: oGetParam 1
6852: oPushResult
6853: oCall 13078
6855: oPop 1
6857: oJumpForward 6869
6859: Choice Lookup Table
          24   6765
          22   6726
          25   6715
          21   6715
6868: oEndChoice
6869: oInputChoice 6899
6871: oTypeSPop
6872: oGetLocal 1
6874: oPushResult
6875: oSetResult 37
6877: oPushResult
6878: oNodeGet
6879: oPop 2
6881: oPushResult
6882: oTypeSPush
6883: oPop 1
6885: oCall 7151
6887: oCall 7097
6889: oJumpForward 6904
6891: oCall 7346
6893: oCall 7151
6895: oCall 7097
6897: oJumpForward 6904
6899: Choice Lookup Table
          16   6891
          18   6871
6904: oJumpForward 7096
6906: oGetParam 1
6908: oPushResult
6909: oNodeType
6910: oPop 1
6912: oChoice 7056
6914: oEmit 16
6916: oGetParam 1
6918: oPushResult
6919: oCall 13078
6921: oPop 1
6923: oJumpForward 7066
6925: oGetLocal 2
6927: oPushResult
6928: equal_zero
6929: oPop 1
6931: oChoice 6944
6933: oEmit 17
6935: oGetParam 1
6937: oPushResult
6938: oCall 13078
6940: oPop 1
6942: oJumpForward 6962
6944: Choice Lookup Table
           1   6933
6947: oEmit 20
6949: oGetLocal 2
6951: oPushResult
6952: oEmitInt
6953: oPop 1
6955: oGetParam 1
6957: oPushResult
6958: oCall 13078
6960: oPop 1
6962: oJumpForward 7066
6964: oGetParam 1
6966: oPushResult
6967: oSetResult 34
6969: oPushResult
6970: oNodeGetBoolean
6971: oPop 2
6973: oChoice 7014
6975: oGetLocal 2
6977: oPushResult
6978: equal_zero
6979: oPop 1
6981: oChoice 6994
6983: oEmit 8
6985: oGetParam 1
6987: oPushResult
6988: oCall 13078
6990: oPop 1
6992: oJumpForward 7012
6994: Choice Lookup Table
           1   6983
6997: oEmit 14
6999: oGetLocal 2
7001: oPushResult
7002: oEmitInt
7003: oPop 1
7005: oGetParam 1
7007: oPushResult
7008: oCall 13078
7010: oPop 1
7012: oJumpForward 7054
7014: Choice Lookup Table
           1   6975
7017: oGetLocal 2
7019: oPushResult
7020: equal_zero
7021: oPop 1
7023: oChoice 7036
7025: oEmit 18
7027: oGetParam 1
7029: oPushResult
7030: oCall 13078
7032: oPop 1
7034: oJumpForward 7054
7036: Choice Lookup Table
           1   7025
7039: oEmit 21
7041: oGetLocal 2
7043: oPushResult
7044: oEmitInt
7045: oPop 1
7047: oGetParam 1
7049: oPushResult
7050: oCall 13078
7052: oPop 1
7054: oJumpForward 7066
7056: Choice Lookup Table
          24   6964
          22   6925
          25   6914
          21   6914
7065: oEndChoice
7066: oCall 7151
7068: oCall 7097
7070: oJumpForward 7096
7072: Choice Lookup Table
          40   6906
          38   6906
          36   6906
          35   6707
          34   6707
          28   6703
          33   6539
          30   6539
          31   6539
          41   6375
          29   6375
7095: oEndChoice
7096: oReturn
7097: oLocalSpace 0
7099: oTypeSNodeType
7100: oChoice 7124
7102: oEmit 23
7104: oJumpForward 7150
7106: oEmit 24
7108: oJumpForward 7150
7110: oError 16
7112: oJumpForward 7150
7114: oEmit 25
7116: oJumpForward 7150
7118: oError 29
7120: oJumpForward 7150
7122: oJumpForward 7150
7124: Choice Lookup Table
          40   7122
          39   7122
          38   7122
          36   7122
          35   7118
          34   7114
          28   7110
          33   7106
          30   7106
          31   7106
          41   7102
          29   7102
7149: oEndChoice
7150: oReturn
7151: oLocalSpace 0
7153: oInputChoice 7191
7155: oTypeSNodeType
7156: oChoice 7170
7158: oCall 7203
7160: oJumpForward 7181
7162: oCall 7346
7164: oJumpForward 7181
7166: oCall 7425
7168: oJumpForward 7181
7170: Choice Lookup Table
          40   7166
          39   7166
          34   7162
          36   7158
7179: oError 10
7181: oJumpForward 7200
7183: oCall 7455
7185: oJumpForward 7200
7187: oCall 7728
7189: oJumpForward 7200
7191: Choice Lookup Table
          18   7187
          20   7183
          16   7155
7198: oJumpForward 7202
7200: oJumpBack 7153
7202: oReturn
7203: oLocalSpace 3
7205: oTypeSNodeType
7206: oChoice 7210
7208: oJumpForward 7215
7210: Choice Lookup Table
          36   7208
7213: oError 10
7215: oTypeSNodeType
7216: oChoice 7220
7218: oJumpForward 7225
7220: Choice Lookup Table
          36   7218
7223: oError 13
7225: oGetAddrLocal 1
7227: oPushResult
7228: oTypeSTop
7229: oPushResult
7230: oSetResult 38
7232: oPushResult
7233: oNodeGet
7234: oPop 2
7236: oPushResult
7237: oCall 12181
7239: oPop 1
7241: oAssign
7242: oGetAddrLocal 2
7244: oPushResult
7245: oTypeSTop
7246: oPushResult
7247: oSetResult 37
7249: oPushResult
7250: oNodeGet
7251: oPop 2
7253: oAssign
7254: oTypeSPop
7255: oGetLocal 2
7257: oPushResult
7258: oTypeSPush
7259: oPop 1
7261: oCall 4578
7263: oCall 7978
7265: oGetLocal 1
7267: oPushResult
7268: equal_zero
7269: oPop 1
7271: oChoice 7285
7273: oEmit 15
7275: oGetLocal 1
7277: oPushResult
7278: oEmitInt
7279: oPop 1
7281: oEmit 40
7283: oJumpForward 7288
7285: Choice Lookup Table
           0   7273
7288: oGetAddrLocal 3
7290: oPushResult
7291: oGetLocal 2
7293: oPushResult
7294: oSetResult 17
7296: oPushResult
7297: oNodeGetInt
7298: oPop 2
7300: oAssign
7301: oGetLocal 3
7303: oPushResult
7304: oSetResult 1
7306: oPushResult
7307: equal
7308: oPop 2
7310: oChoice 7324
7312: oEmit 15
7314: oGetLocal 3
7316: oPushResult
7317: oEmitInt
7318: oPop 1
7320: oEmit 34
7322: oJumpForward 7327
7324: Choice Lookup Table
           0   7312
7327: oEmit 36
7329: oInputChoice 7337
7331: oJumpForward 7345
7333: oJumpForward 7343
7335: oJumpForward 7343
7337: Choice Lookup Table
          13   7335
          17   7331
7342: oEndChoice
7343: oJumpBack 7215
7345: oReturn
7346: oLocalSpace 2
7348: oTypeSNodeType
7349: oChoice 7353
7351: oJumpForward 7358
7353: Choice Lookup Table
          34   7351
7356: oError 29
7358: oGetAddrLocal 1
7360: oPushResult
7361: oTypeSTop
7362: oPushResult
7363: oSetResult 37
7365: oPushResult
7366: oNodeGet
7367: oPop 2
7369: oAssign
7370: oTypeSPop
7371: oGetLocal 1
7373: oPushResult
7374: oTypeSPush
7375: oPop 1
7377: oCall 4578
7379: oCall 7978
7381: oGetAddrLocal 2
7383: oPushResult
7384: oGetLocal 1
7386: oPushResult
7387: oSetResult 17
7389: oPushResult
7390: oNodeGetInt
7391: oPop 2
7393: oAssign
7394: oGetLocal 2
7396: oPushResult
7397: oSetResult 1
7399: oPushResult
7400: equal
7401: oPop 2
7403: oChoice 7417
7405: oEmit 15
7407: oGetLocal 2
7409: oPushResult
7410: oEmitInt
7411: oPop 1
7413: oEmit 34
7415: oJumpForward 7420
7417: Choice Lookup Table
           0   7405
7420: oEmit 36
7422: oInput 17
7424: oReturn
7425: oLocalSpace 0
7427: oTypeSNodeType
7428: oChoice 7432
7430: oJumpForward 7439
7432: Choice Lookup Table
          40   7430
          39   7430
7437: oError 29
7439: oTypeSPop
7440: oGetGlobal 9
7442: oPushResult
7443: oTypeSPush
7444: oPop 1
7446: oCall 4578
7448: oCall 7978
7450: oEmit 36
7452: oInput 17
7454: oReturn
7455: oLocalSpace 2
7457: oTypeSNodeType
7458: oChoice 7462
7460: oJumpForward 7467
7462: Choice Lookup Table
          38   7460
7465: oError 11
7467: oTypeSTop
7468: oPushResult
7469: oSetResult 41
7471: oPushResult
7472: oNodeGet
7473: oPop 2
7475: oPushResult
7476: oScopeEnter
7477: oPop 1
7479: oInput 0
7481: oGetAddrLocal 1
7483: oPushResult
7484: oScopeFindRequire
7485: oAssign
7486: oGetLocal 1
7488: oPushResult
7489: oNodeType
7490: oPop 1
7492: oChoice 7496
7494: oJumpForward 7501
7496: Choice Lookup Table
          23   7494
7499: oError 12
7501: oScopeEnd
7502: oGetAddrLocal 2
7504: oPushResult
7505: oGetLocal 1
7507: oPushResult
7508: oSetResult 22
7510: oPushResult
7511: oNodeGetInt
7512: oPop 2
7514: oAssign
7515: oGetLocal 2
7517: oPushResult
7518: equal_zero
7519: oPop 1
7521: oChoice 7535
7523: oEmit 15
7525: oGetLocal 2
7527: oPushResult
7528: oEmitInt
7529: oPop 1
7531: oEmit 36
7533: oJumpForward 7538
7535: Choice Lookup Table
           0   7523
7538: oTypeSPop
7539: oGetLocal 1
7541: oPushResult
7542: oSetResult 21
7544: oPushResult
7545: oNodeGet
7546: oPop 2
7548: oPushResult
7549: oTypeSPush
7550: oPop 1
7552: oReturn
7553: oLocalSpace 2
7555: oGetAddrLocal 1
7557: oPushResult
7558: oTypeSTop
7559: oPushResult
7560: oSetResult 37
7562: oPushResult
7563: oNodeGet
7564: oPop 2
7566: oAssign
7567: oGetAddrLocal 2
7569: oPushResult
7570: oGetLocal 1
7572: oPushResult
7573: oSetResult 17
7575: oPushResult
7576: oNodeGetInt
7577: oPop 2
7579: oAssign
7580: oGetLocal 2
7582: oPushResult
7583: oSetResult 1
7585: oPushResult
7586: equal
7587: oPop 2
7589: oChoice 7603
7591: oEmit 15
7593: oGetLocal 2
7595: oPushResult
7596: oEmitInt
7597: oPop 1
7599: oEmit 34
7601: oJumpForward 7606
7603: Choice Lookup Table
           0   7591
7606: oEmit 36
7608: oReturn
7609: oLocalSpace 2
7611: oGetAddrLocal 1
7613: oPushResult
7614: oTypeSTop
7615: oPushResult
7616: oSetResult 37
7618: oPushResult
7619: oNodeGet
7620: oPop 2
7622: oAssign
7623: oGetAddrLocal 2
7625: oPushResult
7626: oGetLocal 1
7628: oPushResult
7629: oSetResult 17
7631: oPushResult
7632: oNodeGetInt
7633: oPop 2
7635: oAssign
7636: oGetLocal 2
7638: oPushResult
7639: oSetResult 1
7641: oPushResult
7642: equal
7643: oPop 2
7645: oChoice 7659
7647: oEmit 15
7649: oGetLocal 2
7651: oPushResult
7652: oEmitInt
7653: oPop 1
7655: oEmit 34
7657: oJumpForward 7662
7659: Choice Lookup Table
           0   7647
7662: oEmit 39
7664: oReturn
7665: oLocalSpace 2
7667: oEmit 38
7669: oGetAddrLocal 1
7671: oPushResult
7672: oTypeSTop
7673: oPushResult
7674: oSetResult 37
7676: oPushResult
7677: oNodeGet
7678: oPop 2
7680: oAssign
7681: oGetAddrLocal 2
7683: oPushResult
7684: oGetLocal 1
7686: oPushResult
7687: oSetResult 17
7689: oPushResult
7690: oNodeGetInt
7691: oPop 2
7693: oAssign
7694: oGetLocal 2
7696: oPushResult
7697: oSetResult 1
7699: oPushResult
7700: equal
7701: oPop 2
7703: oChoice 7717
7705: oEmit 15
7707: oGetLocal 2
7709: oPushResult
7710: oEmitInt
7711: oPop 1
7713: oEmit 35
7715: oJumpForward 7720
7717: Choice Lookup Table
           0   7705
7720: oTypeSPop
7721: oGetGlobal 6
7723: oPushResult
7724: oTypeSPush
7725: oPop 1
7727: oReturn
7728: oLocalSpace 1
7730: oTypeSNodeType
7731: oChoice 7739
7733: oJumpForward 7746
7735: oError 29
7737: oJumpForward 7746
7739: Choice Lookup Table
          35   7735
          34   7733
7744: oError 9
7746: oEmit 25
7748: oGetAddrLocal 1
7750: oPushResult
7751: oTypeSTop
7752: oAssign
7753: oTypeSPop
7754: oGetLocal 1
7756: oPushResult
7757: oSetResult 37
7759: oPushResult
7760: oNodeGet
7761: oPop 2
7763: oPushResult
7764: oTypeSPush
7765: oPop 1
7767: oReturn
7768: oLocalSpace 2
7770: oGetAddrLocal 1
7772: oPushResult
7773: oTypeSNodeType
7774: oAssign
7775: oTypeSPop
7776: oGetLocal 1
7778: oPushResult
7779: oTypeSNodeType
7780: oPushResult
7781: equal_node_type
7782: oPop 2
7784: oChoice 7916
7786: oTypeSNodeType
7787: oChoice 7901
7789: oGetLocal 1
7791: oChoice 7798
7793: oEmit 30
7795: oReturn
7796: oJumpForward 7801
7798: Choice Lookup Table
          30   7793
7801: oJumpForward 7912
7803: oGetLocal 1
7805: oChoice 7812
7807: oEmit 31
7809: oReturn
7810: oJumpForward 7815
7812: Choice Lookup Table
          29   7807
7815: oJumpForward 7912
7817: oGetLocal 1
7819: oChoice 7852
7821: oReturn
7822: oJumpForward 7857
7824: oTypeSTop
7825: oPushResult
7826: oGetGlobal 10
7828: oPushResult
7829: equal_node
7830: oPop 2
7832: oChoice 7847
7834: oEmit 15
7836: oSetResult 1
7838: oPushResult
7839: oEmitInt
7840: oPop 1
7842: oEmit 36
7844: oReturn
7845: oJumpForward 7850
7847: Choice Lookup Table
           1   7834
7850: oJumpForward 7857
7852: Choice Lookup Table
          39   7824
          35   7821
7857: oJumpForward 7912
7859: oGetLocal 1
7861: oChoice 7866
7863: oReturn
7864: oJumpForward 7869
7866: Choice Lookup Table
          34   7863
7869: oJumpForward 7912
7871: oGetLocal 1
7873: oChoice 7894
7875: oReturn
7876: oJumpForward 7899
7878: oGetGlobal 9
7880: oPushResult
7881: oTypeSPush
7882: oPop 1
7884: oGetAddrLocal 2
7886: oPushResult
7887: oCall 9762
7889: oAssign
7890: oTypeSPop
7891: oReturn
7892: oJumpForward 7899
7894: Choice Lookup Table
          33   7878
          39   7875
7899: oJumpForward 7912
7901: Choice Lookup Table
          40   7871
          35   7859
          34   7817
          30   7803
          29   7789
7912: oError 14
7914: oJumpForward 7919
7916: Choice Lookup Table
           0   7786
7919: oReturn
7920: oLocalSpace 1
7922: oGetAddrLocal 1
7924: oPushResult
7925: oTypeSNodeType
7926: oAssign
7927: oTypeSPop
7928: oGetLocal 1
7930: oPushResult
7931: oTypeSNodeType
7932: oPushResult
7933: equal_node_type
7934: oPop 2
7936: oChoice 7974
7938: oTypeSNodeType
7939: oChoice 7965
7941: oGetLocal 1
7943: oChoice 7948
7945: oReturn
7946: oJumpForward 7951
7948: Choice Lookup Table
          35   7945
7951: oJumpForward 7970
7953: oGetLocal 1
7955: oChoice 7960
7957: oReturn
7958: oJumpForward 7963
7960: Choice Lookup Table
          34   7957
7963: oJumpForward 7970
7965: Choice Lookup Table
          35   7953
          34   7941
7970: oError 14
7972: oJumpForward 7977
7974: Choice Lookup Table
           0   7938
7977: oReturn
7978: oLocalSpace 0
7980: oTypeSNodeType
7981: oChoice 7985
7983: oJumpForward 7990
7985: Choice Lookup Table
          29   7983
7988: oError 7
7990: oTypeSPop
7991: oReturn
7992: oLocalSpace 0
7994: oTypeSNodeType
7995: oChoice 7999
7997: oJumpForward 8004
7999: Choice Lookup Table
          29   7997
8002: oError 7
8004: oReturn
8005: oLocalSpace 0
8007: oTypeSNodeType
8008: oChoice 8016
8010: oJumpForward 8023
8012: oEmit 30
8014: oJumpForward 8023
8016: Choice Lookup Table
          30   8012
          29   8010
8021: oError 7
8023: oTypeSPop
8024: oReturn
8025: oLocalSpace 0
8027: oTypeSNodeType
8028: oChoice 8043
8030: oJumpForward 8050
8032: oEmit 30
8034: oTypeSPop
8035: oGetGlobal 6
8037: oPushResult
8038: oTypeSPush
8039: oPop 1
8041: oJumpForward 8050
8043: Choice Lookup Table
          30   8032
          29   8030
8048: oError 7
8050: oReturn
8051: oLocalSpace 0
8053: oTypeSNodeType
8054: oChoice 8067
8056: oEmit 30
8058: oTypeSPop
8059: oGetGlobal 6
8061: oPushResult
8062: oTypeSPush
8063: oPop 1
8065: oJumpForward 8070
8067: Choice Lookup Table
          30   8056
8070: oReturn
8071: oLocalSpace 0
8073: oTypeSNodeType
8074: oChoice 8078
8076: oJumpForward 8083
8078: Choice Lookup Table
          31   8076
8081: oError 8
8083: oTypeSPop
8084: oReturn
8085: oLocalSpace 0
8087: oTypeSNodeType
8088: oChoice 8092
8090: oJumpForward 8097
8092: Choice Lookup Table
          31   8090
8095: oError 8
8097: oReturn
8098: oLocalSpace 0
8100: oInputChoice 8163
8102: oCall 9625
8104: oJumpForward 8194
8106: oCall 9632
8108: oJumpForward 8194
8110: oCall 9756
8112: oJumpForward 8194
8114: oCall 9759
8116: oJumpForward 8194
8118: oCall 8776
8120: oJumpForward 8194
8122: oCall 9099
8124: oJumpForward 8194
8126: oCall 8842
8128: oJumpForward 8194
8130: oCall 9019
8132: oJumpForward 8194
8134: oCall 9184
8136: oJumpForward 8194
8138: oCall 9152
8140: oJumpForward 8194
8142: oCall 9602
8144: oJumpForward 8194
8146: oCall 8195
8148: oJumpForward 8194
8150: oCall 9216
8152: oJumpForward 8194
8154: oCall 9550
8156: oJumpForward 8194
8158: oChangeIntLitToLabelIdent
8159: oCall 8195
8161: oJumpForward 8194
8163: Choice Lookup Table
           1   8158
          55   8154
          53   8150
           0   8146
          35   8142
          51   8138
          52   8134
          49   8130
          44   8126
          48   8122
          41   8118
          68   8114
          67   8110
          66   8106
          65   8102
8194: oReturn
8195: oLocalSpace 1
8197: oGetAddrLocal 1
8199: oPushResult
8200: oScopeFindRequire
8201: oAssign
8202: oGetAddrLocal 1
8204: oPushResult
8205: oCall 244
8207: oPop 1
8209: oGetLocal 1
8211: oPushResult
8212: oNodeType
8213: oPop 1
8215: oChoice 8255
8217: oGetLocal 1
8219: oPushResult
8220: oCall 8271
8222: oPop 1
8224: oCall 8098
8226: oJumpForward 8270
8228: oGetLocal 1
8230: oPushResult
8231: oCall 10074
8233: oPop 1
8235: oJumpForward 8270
8237: oGetLocal 1
8239: oPushResult
8240: oCall 8321
8242: oPop 1
8244: oJumpForward 8270
8246: oGetLocal 1
8248: oPushResult
8249: oCall 8411
8251: oPop 1
8253: oJumpForward 8270
8255: Choice Lookup Table
          13   8246
          24   8237
          22   8237
          21   8237
          12   8228
          26   8217
8268: oError 0
8270: oReturn
8271: oLocalSpace 0
8273: oGetParam 1
8275: oPushResult
8276: oSetResult 35
8278: oPushResult
8279: oNodeGetBoolean
8280: oPop 2
8282: oChoice 8288
8284: oError 21
8286: oJumpForward 8291
8288: Choice Lookup Table
           1   8284
8291: oEmit 77
8293: oGetParam 1
8295: oPushResult
8296: oSetResult 22
8298: oPushResult
8299: oNodeGetLabel
8300: oPop 2
8302: oPushResult
8303: oEmitLabel
8304: oPop 1
8306: oGetParam 1
8308: oPushResult
8309: oSetResult 35
8311: oPushResult
8312: oSetResult 1
8314: oPushResult
8315: oNodeSetBoolean
8316: oPop 3
8318: oInput 12
8320: oReturn
8321: oLocalSpace 0
8323: oGetParam 1
8325: oPushResult
8326: oSetResult 1
8328: oPushResult
8329: oCall 8586
8331: oPop 2
8333: oInput 4
8335: oCall 4578
8337: oCall 7768
8339: oCall 8342
8341: oReturn
8342: oLocalSpace 1
8344: oTypeSNodeType
8345: oChoice 8385
8347: oEmit 26
8349: oJumpForward 8409
8351: oEmit 27
8353: oJumpForward 8409
8355: oError 16
8357: oJumpForward 8409
8359: oEmit 28
8361: oJumpForward 8409
8363: oGetAddrLocal 1
8365: oPushResult
8366: oTypeSTop
8367: oPushResult
8368: oSetResult 17
8370: oPushResult
8371: oNodeGetInt
8372: oPop 2
8374: oAssign
8375: oEmit 29
8377: oGetLocal 1
8379: oPushResult
8380: oEmitInt
8381: oPop 1
8383: oJumpForward 8409
8385: Choice Lookup Table
          40   8363
          38   8363
          36   8363
          35   8359
          34   8359
          28   8355
          33   8351
          30   8351
          31   8351
          41   8347
          29   8347
8408: oEndChoice
8409: oTypeSPop
8410: oReturn
8411: oLocalSpace 1
8413: oGetParam 1
8415: oPushResult
8416: oSetResult 6
8418: oPushResult
8419: oNodeGet
8420: oPop 2
8422: oPushResult
8423: oScopeCurrent
8424: oPushResult
8425: oNodeEqual
8426: oPop 2
8428: oChoice 8434
8430: oError 20
8432: oJumpForward 8437
8434: Choice Lookup Table
           0   8430
8437: oEmit 8
8439: oGetParam 1
8441: oPushResult
8442: oSetResult 31
8444: oPushResult
8445: oNodeGetInt
8446: oPop 2
8448: oPushResult
8449: oEmitInt
8450: oPop 1
8452: oGetParam 1
8454: oPushResult
8455: oSetResult 21
8457: oPushResult
8458: oNodeGet
8459: oPop 2
8461: oPushResult
8462: oTypeSPush
8463: oPop 1
8465: oInput 4
8467: oCall 4578
8469: oCall 7768
8471: oTypeSNodeType
8472: oChoice 8512
8474: oEmit 26
8476: oJumpForward 8536
8478: oEmit 27
8480: oJumpForward 8536
8482: oError 16
8484: oJumpForward 8536
8486: oEmit 28
8488: oJumpForward 8536
8490: oGetAddrLocal 1
8492: oPushResult
8493: oTypeSTop
8494: oPushResult
8495: oSetResult 17
8497: oPushResult
8498: oNodeGetInt
8499: oPop 2
8501: oAssign
8502: oEmit 29
8504: oGetLocal 1
8506: oPushResult
8507: oEmitInt
8508: oPop 1
8510: oJumpForward 8536
8512: Choice Lookup Table
          40   8490
          38   8490
          36   8490
          35   8486
          34   8486
          28   8482
          33   8478
          30   8478
          31   8478
          41   8474
          29   8474
8535: oEndChoice
8536: oTypeSPop
8537: oReturn
8538: oLocalSpace 1
8540: oInput 0
8542: oGetAddrLocal 1
8544: oPushResult
8545: oScopeFindRequire
8546: oAssign
8547: oGetAddrLocal 1
8549: oPushResult
8550: oCall 244
8552: oPop 1
8554: oGetLocal 1
8556: oPushResult
8557: oNodeType
8558: oPop 1
8560: oChoice 8564
8562: oJumpForward 8575
8564: Choice Lookup Table
          25   8562
          24   8562
          22   8562
          21   8562
8573: oError 4
8575: oGetLocal 1
8577: oPushResult
8578: oGetParam 1
8580: oPushResult
8581: oCall 8586
8583: oPop 2
8585: oReturn
8586: oLocalSpace 0
8588: oGetParam 2
8590: oPushResult
8591: oNodeType
8592: oPop 1
8594: oChoice 8676
8596: oEmit 16
8598: oGetParam 2
8600: oPushResult
8601: oCall 13078
8603: oPop 1
8605: oJumpForward 8687
8607: oEmit 17
8609: oGetParam 2
8611: oPushResult
8612: oCall 13078
8614: oPop 1
8616: oJumpForward 8687
8618: oGetParam 2
8620: oPushResult
8621: oSetResult 34
8623: oPushResult
8624: oNodeGetBoolean
8625: oPop 2
8627: oChoice 8640
8629: oEmit 8
8631: oGetParam 2
8633: oPushResult
8634: oCall 13078
8636: oPop 1
8638: oJumpForward 8652
8640: Choice Lookup Table
           1   8629
8643: oEmit 18
8645: oGetParam 2
8647: oPushResult
8648: oCall 13078
8650: oPop 1
8652: oJumpForward 8687
8654: oGetParam 1
8656: oChoice 8669
8658: oEmit 16
8660: oGetParam 2
8662: oPushResult
8663: oCall 13078
8665: oPop 1
8667: oJumpForward 8674
8669: Choice Lookup Table
           0   8658
8672: oError 4
8674: oJumpForward 8687
8676: Choice Lookup Table
          25   8654
          24   8618
          22   8607
          21   8596
8685: oError 4
8687: oGetParam 2
8689: oPushResult
8690: oSetResult 21
8692: oPushResult
8693: oNodeGet
8694: oPop 2
8696: oPushResult
8697: oTypeSPush
8698: oPop 1
8700: oTypeSNodeType
8701: oChoice 8716
8703: oInputChoice 8711
8705: oEmit 25
8707: oCall 7346
8709: oJumpForward 8714
8711: Choice Lookup Table
          16   8705
8714: oJumpForward 8719
8716: Choice Lookup Table
          34   8703
8719: oCall 7151
8721: oReturn
8722: oLocalSpace 0
8724: oGetParam 1
8726: oPushResult
8727: oSetResult 1
8729: oPushResult
8730: oCall 8586
8732: oPop 2
8734: oCall 7978
8736: oGetParam 1
8738: oPushResult
8739: oCall 6340
8741: oPop 1
8743: oTypeSPop
8744: oEmit 32
8746: oEmit 26
8748: oReturn
8749: oLocalSpace 0
8751: oGetParam 1
8753: oPushResult
8754: oSetResult 1
8756: oPushResult
8757: oCall 8586
8759: oPop 2
8761: oCall 7978
8763: oGetParam 1
8765: oPushResult
8766: oCall 6340
8768: oPop 1
8770: oTypeSPop
8771: oEmit 33
8773: oEmit 26
8775: oReturn
8776: oLocalSpace 2
8778: oGetAddrLocal 1
8780: oPushResult
8781: oSetResult 0
8783: oAssign
8784: oGetAddrLocal 1
8786: oPushResult
8787: oCall 4601
8789: oPop 1
8791: oInput 42
8793: oCall 8098
8795: oInputChoice 8830
8797: oGetAddrLocal 2
8799: oPushResult
8800: oLabelNew
8801: oAssign
8802: oEmit 68
8804: oGetLocal 2
8806: oPushResult
8807: oEmitLabel
8808: oPop 1
8810: oEmit 77
8812: oGetLocal 1
8814: oPushResult
8815: oEmitLabel
8816: oPop 1
8818: oCall 8098
8820: oEmit 77
8822: oGetLocal 2
8824: oPushResult
8825: oEmitLabel
8826: oPop 1
8828: oJumpForward 8841
8830: Choice Lookup Table
          43   8797
8833: oEmit 77
8835: oGetLocal 1
8837: oPushResult
8838: oEmitLabel
8839: oPop 1
8841: oReturn
8842: oLocalSpace 4
8844: oInput 0
8846: oGetAddrLocal 1
8848: oPushResult
8849: oScopeFindRequire
8850: oAssign
8851: oGetLocal 1
8853: oPushResult
8854: oSetResult 1
8856: oPushResult
8857: oCall 8586
8859: oPop 2
8861: oCall 7978
8863: oInput 4
8865: oCall 4578
8867: oCall 7978
8869: oEmit 26
8871: oGetAddrLocal 2
8873: oPushResult
8874: oLabelNew
8875: oAssign
8876: oGetAddrLocal 3
8878: oPushResult
8879: oLabelNew
8880: oAssign
8881: oEmit 68
8883: oGetLocal 3
8885: oPushResult
8886: oEmitLabel
8887: oPop 1
8889: oGetAddrLocal 4
8891: oPushResult
8892: oLabelNew
8893: oAssign
8894: oEmit 77
8896: oGetLocal 4
8898: oPushResult
8899: oEmitLabel
8900: oPop 1
8902: oInputChoice 8982
8904: oGetLocal 1
8906: oPushResult
8907: oCall 8722
8909: oPop 1
8911: oEmit 77
8913: oGetLocal 3
8915: oPushResult
8916: oEmitLabel
8917: oPop 1
8919: oGetLocal 1
8921: oPushResult
8922: oCall 6340
8924: oPop 1
8926: oTypeSPop
8927: oCall 4578
8929: oCall 7978
8931: oEmit 51
8933: oEmit 69
8935: oGetLocal 2
8937: oPushResult
8938: oEmitLabel
8939: oPop 1
8941: oJumpForward 8988
8943: oGetLocal 1
8945: oPushResult
8946: oCall 8749
8948: oPop 1
8950: oEmit 77
8952: oGetLocal 3
8954: oPushResult
8955: oEmitLabel
8956: oPop 1
8958: oGetLocal 1
8960: oPushResult
8961: oCall 6340
8963: oPop 1
8965: oTypeSPop
8966: oCall 4578
8968: oCall 7978
8970: oEmit 52
8972: oEmit 69
8974: oGetLocal 2
8976: oPushResult
8977: oEmitLabel
8978: oPop 1
8980: oJumpForward 8988
8982: Choice Lookup Table
          46   8943
          45   8904
8987: oEndChoice
8988: oGetLocal 4
8990: oPushResult
8991: oGetLocal 2
8993: oPushResult
8994: oLoopPush
8995: oPop 2
8997: oInput 47
8999: oCall 8098
9001: oEmit 68
9003: oGetLocal 4
9005: oPushResult
9006: oEmitLabel
9007: oPop 1
9009: oEmit 77
9011: oGetLocal 2
9013: oPushResult
9014: oEmitLabel
9015: oPop 1
9017: oLoopPop
9018: oReturn
9019: oLocalSpace 3
9021: oGetAddrLocal 1
9023: oPushResult
9024: oLabelNew
9025: oAssign
9026: oEmit 77
9028: oGetLocal 1
9030: oPushResult
9031: oEmitLabel
9032: oPop 1
9034: oGetAddrLocal 2
9036: oPushResult
9037: oLabelNew
9038: oAssign
9039: oGetLocal 1
9041: oPushResult
9042: oGetLocal 2
9044: oPushResult
9045: oLoopPush
9046: oPop 2
9048: oCall 8098
9050: oInputChoice 9081
9052: oCall 8098
9054: oJumpForward 9087
9056: oGetAddrLocal 3
9058: oPushResult
9059: oCall 4601
9061: oPop 1
9063: oEmit 78
9065: oGetLocal 3
9067: oPushResult
9068: oEmitLabel
9069: oPop 1
9071: oGetLocal 1
9073: oPushResult
9074: oEmitLabel
9075: oPop 1
9077: oJumpForward 9089
9079: oJumpForward 9087
9081: Choice Lookup Table
          50   9056
           5   9052
9086: oEndChoice
9087: oJumpBack 9050
9089: oEmit 77
9091: oGetLocal 2
9093: oPushResult
9094: oEmitLabel
9095: oPop 1
9097: oLoopPop
9098: oReturn
9099: oLocalSpace 2
9101: oGetAddrLocal 1
9103: oPushResult
9104: oLabelNew
9105: oAssign
9106: oEmit 77
9108: oGetLocal 1
9110: oPushResult
9111: oEmitLabel
9112: oPop 1
9114: oGetAddrLocal 2
9116: oPushResult
9117: oCall 4601
9119: oPop 1
9121: oGetLocal 1
9123: oPushResult
9124: oGetLocal 2
9126: oPushResult
9127: oLoopPush
9128: oPop 2
9130: oInput 47
9132: oCall 8098
9134: oEmit 68
9136: oGetLocal 1
9138: oPushResult
9139: oEmitLabel
9140: oPop 1
9142: oEmit 77
9144: oGetLocal 2
9146: oPushResult
9147: oEmitLabel
9148: oPop 1
9150: oLoopPop
9151: oReturn
9152: oLocalSpace 0
9154: oLoopContinueLabel
9155: oPushResult
9156: oSetResult 0
9158: oPushResult
9159: equal_label
9160: oPop 2
9162: oChoice 9177
9164: oError 18
9166: oJumpForward 9183
9168: oEmit 68
9170: oLoopContinueLabel
9171: oPushResult
9172: oEmitLabel
9173: oPop 1
9175: oJumpForward 9183
9177: Choice Lookup Table
           0   9168
           1   9164
9182: oEndChoice
9183: oReturn
9184: oLocalSpace 0
9186: oLoopBreakLabel
9187: oPushResult
9188: oSetResult 0
9190: oPushResult
9191: equal_label
9192: oPop 2
9194: oChoice 9209
9196: oError 18
9198: oJumpForward 9215
9200: oEmit 68
9202: oLoopBreakLabel
9203: oPushResult
9204: oEmitLabel
9205: oPop 1
9207: oJumpForward 9215
9209: Choice Lookup Table
           0   9200
           1   9196
9214: oEndChoice
9215: oReturn
9216: oLocalSpace 8
9218: oGetAddrLocal 1
9220: oPushResult
9221: oCodeNew
9222: oAssign
9223: oGetAddrLocal 2
9225: oPushResult
9226: oLabelNew
9227: oAssign
9228: oGetAddrLocal 3
9230: oPushResult
9231: oLabelNew
9232: oAssign
9233: oGetAddrLocal 4
9235: oPushResult
9236: oGetLocal 3
9238: oAssign
9239: oGetAddrLocal 5
9241: oPushResult
9242: oSetResult 0
9244: oAssign
9245: oCall 4578
9247: oTypeSNodeType
9248: oChoice 9286
9250: oEmit 71
9252: oGetLocal 2
9254: oPushResult
9255: oEmitLabel
9256: oPop 1
9258: oJumpForward 9303
9260: oEmit 72
9262: oGetLocal 2
9264: oPushResult
9265: oEmitLabel
9266: oPop 1
9268: oJumpForward 9303
9270: oGetAddrLocal 5
9272: oPushResult
9273: oSetResult 1
9275: oAssign
9276: oEmit 73
9278: oGetLocal 2
9280: oPushResult
9281: oEmitLabel
9282: oPop 1
9284: oJumpForward 9303
9286: Choice Lookup Table
          39   9270
          40   9270
          41   9260
          29   9260
          33   9250
          30   9250
          31   9250
9301: oError 17
9303: oInput 40
9305: oInputChoice 9352
9307: oGetAddrLocal 4
9309: oPushResult
9310: oLabelNew
9311: oAssign
9312: oEmit 77
9314: oGetLocal 4
9316: oPushResult
9317: oEmitLabel
9318: oPop 1
9320: oInputChoice 9326
9322: oJumpForward 9344
9324: oJumpForward 9342
9326: Choice Lookup Table
          36   9322
9329: oCall 8098
9331: oInputChoice 9335
9333: oJumpForward 9342
9335: Choice Lookup Table
           5   9333
9338: oInput 36
9340: oJumpForward 9344
9342: oJumpBack 9320
9344: oJumpForward 9518
9346: oJumpForward 9516
9348: oJumpForward 9518
9350: oJumpForward 9516
9352: Choice Lookup Table
          36   9348
          43   9307
          54   9307
9359: oGetAddrLocal 6
9361: oPushResult
9362: oLabelNew
9363: oAssign
9364: oGetLocal 1
9366: oPushResult
9367: oCodePush
9368: oPop 1
9370: oCall 3526
9372: oCall 4268
9374: oGetLocal 5
9376: oChoice 9396
9378: oGetAddrLocal 7
9380: oPushResult
9381: oValueTopString
9382: oPushResult
9383: oStringAllocShortStringLit
9384: oPop 1
9386: oAssign
9387: oJumpForward 9402
9389: oGetAddrLocal 7
9391: oPushResult
9392: oValueTop
9393: oAssign
9394: oJumpForward 9402
9396: Choice Lookup Table
           0   9389
           1   9378
9401: oEndChoice
9402: oValuePop
9403: oInputChoice 9460
9405: oCall 3526
9407: oCall 4268
9409: oGetLocal 5
9411: oChoice 9431
9413: oGetAddrLocal 8
9415: oPushResult
9416: oValueTopString
9417: oPushResult
9418: oStringAllocShortStringLit
9419: oPop 1
9421: oAssign
9422: oJumpForward 9437
9424: oGetAddrLocal 8
9426: oPushResult
9427: oValueTop
9428: oAssign
9429: oJumpForward 9437
9431: Choice Lookup Table
           0   9424
           1   9413
9436: oEndChoice
9437: oValuePop
9438: oEmit 75
9440: oGetLocal 7
9442: oPushResult
9443: oEmitInt
9444: oPop 1
9446: oGetLocal 8
9448: oPushResult
9449: oEmitInt
9450: oPop 1
9452: oGetLocal 6
9454: oPushResult
9455: oEmitLabel
9456: oPop 1
9458: oJumpForward 9477
9460: Choice Lookup Table
          21   9405
9463: oEmit 74
9465: oGetLocal 7
9467: oPushResult
9468: oEmitInt
9469: oPop 1
9471: oGetLocal 6
9473: oPushResult
9474: oEmitLabel
9475: oPop 1
9477: oInputChoice 9481
9479: oJumpForward 9486
9481: Choice Lookup Table
          13   9479
9484: oJumpForward 9488
9486: oJumpBack 9370
9488: oCodePop
9489: oInput 12
9491: oEmit 77
9493: oGetLocal 6
9495: oPushResult
9496: oEmitLabel
9497: oPop 1
9499: oCall 8098
9501: oEmit 68
9503: oGetLocal 3
9505: oPushResult
9506: oEmitLabel
9507: oPop 1
9509: oInputChoice 9513
9511: oJumpForward 9516
9513: Choice Lookup Table
           5   9511
9516: oJumpBack 9305
9518: oEmit 77
9520: oGetLocal 2
9522: oPushResult
9523: oEmitLabel
9524: oPop 1
9526: oGetLocal 1
9528: oPushResult
9529: oEmitCode
9530: oPop 1
9532: oEmit 76
9534: oGetLocal 4
9536: oPushResult
9537: oEmitLabel
9538: oPop 1
9540: oEmit 77
9542: oGetLocal 3
9544: oPushResult
9545: oEmitLabel
9546: oPop 1
9548: oTypeSPop
9549: oReturn
9550: oLocalSpace 1
9552: oInputChoice 9559
9554: oJumpForward 9565
9556: oChangeIntLitToLabelIdent
9557: oJumpForward 9565
9559: Choice Lookup Table
           1   9556
           0   9554
9564: oEndChoice
9565: oGetAddrLocal 1
9567: oPushResult
9568: oScopeCurrent
9569: oPushResult
9570: oScopeFindRequireInScope
9571: oPop 1
9573: oAssign
9574: oGetLocal 1
9576: oPushResult
9577: oSetResult 28
9579: oPushResult
9580: oSetResult 1
9582: oPushResult
9583: oNodeSetBoolean
9584: oPop 3
9586: oEmit 68
9588: oGetLocal 1
9590: oPushResult
9591: oSetResult 22
9593: oPushResult
9594: oNodeGetLabel
9595: oPop 2
9597: oPushResult
9598: oEmitLabel
9599: oPop 1
9601: oReturn
9602: oLocalSpace 0
9604: oCall 8098
9606: oInputChoice 9616
9608: oCall 8098
9610: oJumpForward 9622
9612: oJumpForward 9624
9614: oJumpForward 9622
9616: Choice Lookup Table
          36   9612
           5   9608
9621: oEndChoice
9622: oJumpBack 9606
9624: oReturn
9625: oLocalSpace 0
9627: oCall 9632
9629: oEmit 87
9631: oReturn
9632: oLocalSpace 0
9634: oInputChoice 9752
9636: oCall 4578
9638: oTypeSNodeType
9639: oChoice 9710
9641: oEmit 80
9643: oJumpForward 9733
9645: oEmit 81
9647: oJumpForward 9733
9649: oEmit 30
9651: oEmit 80
9653: oJumpForward 9733
9655: oEmit 82
9657: oJumpForward 9733
9659: oEmit 83
9661: oJumpForward 9733
9663: oError 16
9665: oJumpForward 9733
9667: oEmit 16
9669: oTypeSTop
9670: oPushResult
9671: oSetResult 43
9673: oPushResult
9674: oNodeGetInt
9675: oPop 2
9677: oPushResult
9678: oEmitInt
9679: oPop 1
9681: oEmit 86
9683: oJumpForward 9733
9685: oTypeSTop
9686: oPushResult
9687: oGetGlobal 10
9689: oPushResult
9690: equal_node
9691: oPop 2
9693: oChoice 9699
9695: oEmit 84
9697: oJumpForward 9704
9699: Choice Lookup Table
           1   9695
9702: oEmit 85
9704: oJumpForward 9733
9706: oEmit 85
9708: oJumpForward 9733
9710: Choice Lookup Table
          35   9706
          34   9685
          41   9667
          28   9663
          39   9659
          40   9659
          33   9655
          30   9649
          31   9645
          29   9641
9731: oError 17
9733: oTypeSPop
9734: oInputChoice 9742
9736: oJumpForward 9750
9738: oJumpForward 9748
9740: oJumpForward 9748
9742: Choice Lookup Table
          13   9740
          15   9736
9747: oEndChoice
9748: oJumpBack 9636
9750: oJumpForward 9755
9752: Choice Lookup Table
          14   9636
9755: oReturn
9756: oLocalSpace 0
9758: oReturn
9759: oLocalSpace 0
9761: oReturn
9762: oLocalSpace 1
9764: oGetAddrLocal 1
9766: oPushResult
9767: oGetGlobal 14
9769: oPushResult
9770: oScopeAllocType
9771: oPop 1
9773: oAssign
9774: oTypeSNodeType
9775: oChoice 9843
9777: oEmit 17
9779: oGetLocal 1
9781: oPushResult
9782: oEmitInt
9783: oPop 1
9785: oEmit 22
9787: oEmit 29
9789: oGetGlobal 14
9791: oPushResult
9792: oSetResult 17
9794: oPushResult
9795: oNodeGetInt
9796: oPop 2
9798: oPushResult
9799: oEmitInt
9800: oPop 1
9802: oJumpForward 9852
9804: oEmit 17
9806: oGetLocal 1
9808: oPushResult
9809: oEmitInt
9810: oPop 1
9812: oEmit 15
9814: oSetResult 1
9816: oPushResult
9817: oEmitInt
9818: oPop 1
9820: oEmit 27
9822: oEmit 17
9824: oGetLocal 1
9826: oPushResult
9827: oSetResult 1
9829: oPushResult
9830: add
9831: oPop 2
9833: oPushResult
9834: oEmitInt
9835: oPop 1
9837: oEmit 22
9839: oEmit 27
9841: oJumpForward 9852
9843: Choice Lookup Table
          33   9804
          39   9777
          40   9777
9850: oError 14
9852: oTypeSPop
9853: oEmit 17
9855: oGetLocal 1
9857: oPushResult
9858: oEmitInt
9859: oPop 1
9861: oGetGlobal 14
9863: oPushResult
9864: oTypeSPush
9865: oPop 1
9867: oGetLocal 1
9869: oReturn
9870: oReturn
9871: oLocalSpace 0
9873: oEmit 61
9875: oSetResult 16
9877: oPushResult
9878: oEmitInt
9879: oPop 1
9881: oEmit 19
9883: oSetResult 8
9885: oPushResult
9886: oEmitInt
9887: oPop 1
9889: oEmit 22
9891: oEmit 28
9893: oEmit 19
9895: oSetResult 0
9897: oPushResult
9898: oEmitInt
9899: oPop 1
9901: oEmit 22
9903: oEmit 28
9905: oEmit 64
9907: oGetGlobal 19
9909: oPushResult
9910: oCall 13078
9912: oPop 1
9914: oEmit 63
9916: oSetResult 16
9918: oPushResult
9919: oEmitInt
9920: oPop 1
9922: oTypeSPop
9923: oTypeSPop
9924: oReturn
9925: oLocalSpace 0
9927: oEmit 61
9929: oSetResult 12
9931: oPushResult
9932: oEmitInt
9933: oPop 1
9935: oEmit 19
9937: oSetResult 8
9939: oPushResult
9940: oEmitInt
9941: oPop 1
9943: oEmit 22
9945: oEmit 26
9947: oEmit 19
9949: oSetResult 0
9951: oPushResult
9952: oEmitInt
9953: oPop 1
9955: oEmit 22
9957: oEmit 28
9959: oEmit 64
9961: oGetGlobal 20
9963: oPushResult
9964: oCall 13078
9966: oPop 1
9968: oEmit 63
9970: oSetResult 12
9972: oPushResult
9973: oEmitInt
9974: oPop 1
9976: oTypeSPop
9977: oTypeSPop
9978: oReturn
9979: oLocalSpace 1
9981: oEmit 61
9983: oSetResult 24
9985: oPushResult
9986: oEmitInt
9987: oPop 1
9989: oEmit 19
9991: oSetResult 8
9993: oPushResult
9994: oEmitInt
9995: oPop 1
9997: oEmit 22
9999: oEmit 28
10001: oEmit 19
10003: oSetResult 0
10005: oPushResult
10006: oEmitInt
10007: oPop 1
10009: oEmit 22
10011: oEmit 28
10013: oGetAddrLocal 1
10015: oPushResult
10016: oGetGlobal 6
10018: oPushResult
10019: oScopeAllocType
10020: oPop 1
10022: oAssign
10023: oEmit 19
10025: oSetResult 16
10027: oPushResult
10028: oEmitInt
10029: oPop 1
10031: oEmit 17
10033: oGetLocal 1
10035: oPushResult
10036: oEmitInt
10037: oPop 1
10039: oEmit 28
10041: oEmit 64
10043: oGetGlobal 21
10045: oPushResult
10046: oCall 13078
10048: oPop 1
10050: oEmit 3
10052: oGetLocal 1
10054: oPushResult
10055: oEmitInt
10056: oPop 1
10058: oEmit 63
10060: oSetResult 24
10062: oPushResult
10063: oEmitInt
10064: oPop 1
10066: oTypeSPop
10067: oGetGlobal 6
10069: oPushResult
10070: oTypeSPush
10071: oPop 1
10073: oReturn
10074: oLocalSpace 10
10076: oGetParam 1
10078: oPushResult
10079: oSetResult 25
10081: oPushResult
10082: oNodeGetBoolean
10083: oPop 2
10085: oChoice 10112
10087: oGetParam 1
10089: oPushResult
10090: oSetResult 28
10092: oPushResult
10093: oNodeGetBoolean
10094: oPop 2
10096: oChoice 10107
10098: oGetParam 1
10100: oPushResult
10101: oCall 10694
10103: oPop 1
10105: oJumpForward 10110
10107: Choice Lookup Table
           0   10098
10110: oJumpForward 10115
10112: Choice Lookup Table
           1   10087
10115: oGetParam 1
10117: oPushResult
10118: oSetResult 28
10120: oPushResult
10121: oSetResult 1
10123: oPushResult
10124: oNodeSetBoolean
10125: oPop 3
10127: oGetAddrLocal 1
10129: oPushResult
10130: oGetParam 1
10132: oPushResult
10133: oSetResult 27
10135: oPushResult
10136: oNodeGetBoolean
10137: oPop 2
10139: oAssign
10140: oGetAddrLocal 4
10142: oPushResult
10143: oGetParam 1
10145: oPushResult
10146: oNodeType
10147: oPop 1
10149: oPushResult
10150: oSetResult 13
10152: oPushResult
10153: equal_node_type
10154: oPop 2
10156: oAssign
10157: oGetLocal 4
10159: oChoice 10186
10161: oGetAddrLocal 2
10163: oPushResult
10164: oGetParam 1
10166: oPushResult
10167: oSetResult 21
10169: oPushResult
10170: oNodeGet
10171: oPop 2
10173: oAssign
10174: oGetAddrLocal 3
10176: oPushResult
10177: oGetLocal 2
10179: oPushResult
10180: oScopeAllocType
10181: oPop 1
10183: oAssign
10184: oJumpForward 10189
10186: Choice Lookup Table
           1   10161
10189: oGetAddrLocal 5
10191: oPushResult
10192: oGetParam 1
10194: oPushResult
10195: oSetResult 23
10197: oPushResult
10198: oNodeGet
10199: oPop 2
10201: oAssign
10202: oGetAddrLocal 6
10204: oPushResult
10205: oGetLocal 5
10207: oPushResult
10208: oSetResult 17
10210: oPushResult
10211: oNodeGetInt
10212: oPop 2
10214: oAssign
10215: oGetLocal 1
10217: oChoice 10239
10219: oEmit 62
10221: oGetLocal 6
10223: oPushResult
10224: oEmitInt
10225: oPop 1
10227: oJumpForward 10245
10229: oEmit 61
10231: oGetLocal 6
10233: oPushResult
10234: oEmitInt
10235: oPop 1
10237: oJumpForward 10245
10239: Choice Lookup Table
           0   10229
           1   10219
10244: oEndChoice
10245: oGetParam 1
10247: oPushResult
10248: oCall 13012
10250: oPop 1
10252: oPushResult
10253: oSetResult 0
10255: oPushResult
10256: greater
10257: oPop 2
10259: oChoice 10292
10261: oEmit 19
10263: oSetResult 0
10265: oPushResult
10266: oEmitInt
10267: oPop 1
10269: oEmit 20
10271: oGetParam 1
10273: oPushResult
10274: oCall 13032
10276: oPop 1
10278: oPushResult
10279: oEmitInt
10280: oPop 1
10282: oSetResult 0
10284: oPushResult
10285: oEmitInt
10286: oPop 1
10288: oEmit 28
10290: oJumpForward 10295
10292: Choice Lookup Table
           1   10261
10295: oGetAddrLocal 7
10297: oPushResult
10298: oGetLocal 5
10300: oPushResult
10301: oSetResult 15
10303: oPushResult
10304: oNodeGetIter
10305: oPop 2
10307: oAssign
10308: oGetAddrLocal 8
10310: oPushResult
10311: oGetLocal 7
10313: oPushResult
10314: oNodeIterValue
10315: oPop 1
10317: oAssign
10318: oInputChoice 10515
10320: oGetLocal 8
10322: oPushResult
10323: oNodeNull
10324: oPop 1
10326: oChoice 10332
10328: oJumpForward 10511
10330: oJumpForward 10335
10332: Choice Lookup Table
           1   10328
10335: oGetAddrLocal 9
10337: oPushResult
10338: oGetLocal 8
10340: oPushResult
10341: oSetResult 22
10343: oPushResult
10344: oNodeGetInt
10345: oPop 2
10347: oAssign
10348: oEmit 19
10350: oGetLocal 9
10352: oPushResult
10353: oEmitInt
10354: oPop 1
10356: oGetLocal 8
10358: oPushResult
10359: oSetResult 21
10361: oPushResult
10362: oNodeGet
10363: oPop 2
10365: oPushResult
10366: oTypeSPush
10367: oPop 1
10369: oGetLocal 8
10371: oPushResult
10372: oSetResult 34
10374: oPushResult
10375: oNodeGetBoolean
10376: oPop 2
10378: oChoice 10464
10380: oSetResult 1
10382: oPushResult
10383: oCall 8538
10385: oPop 1
10387: oCall 7920
10389: oEmit 28
10391: oJumpForward 10470
10393: oCall 4578
10395: oCall 7768
10397: oTypeSNodeType
10398: oChoice 10438
10400: oEmit 26
10402: oJumpForward 10462
10404: oEmit 27
10406: oJumpForward 10462
10408: oError 16
10410: oJumpForward 10462
10412: oEmit 28
10414: oJumpForward 10462
10416: oGetAddrLocal 10
10418: oPushResult
10419: oTypeSTop
10420: oPushResult
10421: oSetResult 17
10423: oPushResult
10424: oNodeGetInt
10425: oPop 2
10427: oAssign
10428: oEmit 29
10430: oGetLocal 10
10432: oPushResult
10433: oEmitInt
10434: oPop 1
10436: oJumpForward 10462
10438: Choice Lookup Table
          40   10416
          38   10416
          36   10416
          35   10412
          34   10412
          28   10408
          33   10404
          30   10404
          31   10404
          41   10400
          29   10400
10461: oEndChoice
10462: oJumpForward 10470
10464: Choice Lookup Table
           0   10393
           1   10380
10469: oEndChoice
10470: oTypeSPop
10471: oGetAddrLocal 7
10473: oPushResult
10474: oNodeIterNext
10475: oPop 1
10477: oGetAddrLocal 8
10479: oPushResult
10480: oGetLocal 7
10482: oPushResult
10483: oNodeIterValue
10484: oPop 1
10486: oAssign
10487: oGetLocal 8
10489: oPushResult
10490: oNodeNull
10491: oPop 1
10493: oChoice 10501
10495: oJumpForward 10511
10497: oJumpForward 10507
10499: oJumpForward 10507
10501: Choice Lookup Table
           0   10499
           1   10495
10506: oEndChoice
10507: oInput 13
10509: oJumpBack 10320
10511: oInput 15
10513: oJumpForward 10518
10515: Choice Lookup Table
          14   10320
10518: oGetLocal 8
10520: oPushResult
10521: oNodeNull
10522: oPop 1
10524: oChoice 10530
10526: oError 15
10528: oJumpForward 10533
10530: Choice Lookup Table
           0   10526
10533: oGetLocal 4
10535: oChoice 10564
10537: oEmit 19
10539: oGetParam 1
10541: oPushResult
10542: oSetResult 31
10544: oPushResult
10545: oNodeGetInt
10546: oPop 2
10548: oPushResult
10549: oEmitInt
10550: oPop 1
10552: oEmit 17
10554: oGetLocal 3
10556: oPushResult
10557: oEmitInt
10558: oPop 1
10560: oEmit 28
10562: oJumpForward 10567
10564: Choice Lookup Table
           1   10537
10567: oGetLocal 1
10569: oChoice 10593
10571: oEmit 65
10573: oGetParam 1
10575: oPushResult
10576: oCall 13078
10578: oPop 1
10580: oJumpForward 10599
10582: oEmit 64
10584: oGetParam 1
10586: oPushResult
10587: oCall 13078
10589: oPop 1
10591: oJumpForward 10599
10593: Choice Lookup Table
           0   10582
           1   10571
10598: oEndChoice
10599: oGetLocal 4
10601: oChoice 10682
10603: oGetLocal 2
10605: oPushResult
10606: oTypeSPush
10607: oPop 1
10609: oTypeSNodeType
10610: oChoice 10656
10612: oEmit 3
10614: oGetLocal 3
10616: oPushResult
10617: oEmitInt
10618: oPop 1
10620: oJumpForward 10680
10622: oEmit 4
10624: oGetLocal 3
10626: oPushResult
10627: oEmitInt
10628: oPop 1
10630: oJumpForward 10680
10632: oError 16
10634: oJumpForward 10680
10636: oEmit 5
10638: oGetLocal 3
10640: oPushResult
10641: oEmitInt
10642: oPop 1
10644: oJumpForward 10680
10646: oEmit 17
10648: oGetLocal 3
10650: oPushResult
10651: oEmitInt
10652: oPop 1
10654: oJumpForward 10680
10656: Choice Lookup Table
          40   10646
          38   10646
          36   10646
          35   10636
          34   10636
          28   10632
          33   10622
          30   10622
          31   10622
          41   10612
          29   10612
10679: oEndChoice
10680: oJumpForward 10685
10682: Choice Lookup Table
           1   10603
10685: oEmit 63
10687: oGetLocal 6
10689: oPushResult
10690: oEmitInt
10691: oPop 1
10693: oReturn
10694: oLocalSpace 2
10696: oGetAddrLocal 2
10698: oPushResult
10699: oGetParam 1
10701: oPushResult
10702: oSetResult 26
10704: oPushResult
10705: oNodeGetString
10706: oPop 2
10708: oAssign
10709: oGetLocal 2
10711: oPushResult
10712: oSetResult 0
10714: oPushResult
10715: equal_string
10716: oPop 2
10718: oChoice 10755
10720: oGetAddrLocal 1
10722: oPushResult
10723: oGetParam 1
10725: oPushResult
10726: oSetResult 4
10728: oPushResult
10729: oNodeGetInt
10730: oPop 2
10732: oPushResult
10733: ID_STRING
10734: oPop 1
10736: oPushResult
10737: oStringAllocLit
10738: oPop 1
10740: oAssign
10741: oJumpForward 10761
10743: oGetAddrLocal 1
10745: oPushResult
10746: oGetLocal 2
10748: oPushResult
10749: oStringAllocLit
10750: oPop 1
10752: oAssign
10753: oJumpForward 10761
10755: Choice Lookup Table
           0   10743
           1   10720
10760: oEndChoice
10761: oEmit 79
10763: oGetParam 1
10765: oPushResult
10766: oCall 13078
10768: oPop 1
10770: oGetLocal 1
10772: oPushResult
10773: oEmitInt
10774: oPop 1
10776: oReturn
10777: oLocalSpace 0
10779: oGetParam 1
10781: oPushResult
10782: oGetGlobal 15
10784: oPushResult
10785: oNodeEqual
10786: oPop 2
10788: oChoice 10828
10790: oInput 14
10792: oCall 4578
10794: oTypeSNodeType
10795: oChoice 10803
10797: oJumpForward 10816
10799: oEmit 30
10801: oJumpForward 10816
10803: Choice Lookup Table
          33   10799
          30   10799
          31   10799
          41   10797
          29   10797
10814: oError 14
10816: oTypeSPop
10817: oGetGlobal 6
10819: oPushResult
10820: oTypeSPush
10821: oPop 1
10823: oInput 15
10825: oReturn
10826: oJumpForward 10831
10828: Choice Lookup Table
           1   10790
10831: oGetParam 1
10833: oPushResult
10834: oGetGlobal 16
10836: oPushResult
10837: oNodeEqual
10838: oPop 2
10840: oChoice 10874
10842: oInput 14
10844: oCall 4578
10846: oTypeSNodeType
10847: oChoice 10855
10849: oEmit 31
10851: oJumpForward 10862
10853: oJumpForward 10862
10855: Choice Lookup Table
          30   10853
          29   10849
10860: oError 14
10862: oTypeSPop
10863: oGetGlobal 9
10865: oPushResult
10866: oTypeSPush
10867: oPop 1
10869: oInput 15
10871: oReturn
10872: oJumpForward 10877
10874: Choice Lookup Table
           1   10842
10877: oGetParam 1
10879: oPushResult
10880: oGetGlobal 17
10882: oPushResult
10883: oNodeEqual
10884: oPop 2
10886: oChoice 10926
10888: oInput 14
10890: oCall 4578
10892: oTypeSNodeType
10893: oChoice 10914
10895: oTypeSTop
10896: oPushResult
10897: oSetResult 44
10899: oPushResult
10900: oNodeGetBoolean
10901: oPop 2
10903: oChoice 10909
10905: oError 28
10907: oJumpForward 10912
10909: Choice Lookup Table
           1   10905
10912: oJumpForward 10919
10914: Choice Lookup Table
          41   10895
10917: oError 14
10919: oEmit 33
10921: oInput 15
10923: oReturn
10924: oJumpForward 10929
10926: Choice Lookup Table
           1   10888
10929: oGetParam 1
10931: oPushResult
10932: oGetGlobal 18
10934: oPushResult
10935: oNodeEqual
10936: oPop 2
10938: oChoice 10978
10940: oInput 14
10942: oCall 4578
10944: oTypeSNodeType
10945: oChoice 10966
10947: oTypeSTop
10948: oPushResult
10949: oSetResult 44
10951: oPushResult
10952: oNodeGetBoolean
10953: oPop 2
10955: oChoice 10961
10957: oError 28
10959: oJumpForward 10964
10961: Choice Lookup Table
           1   10957
10964: oJumpForward 10971
10966: Choice Lookup Table
          41   10947
10969: oError 14
10971: oEmit 32
10973: oInput 15
10975: oReturn
10976: oJumpForward 10981
10978: Choice Lookup Table
           1   10940
10981: oError 16
10983: oReturn
10984: oLocalSpace 1
10986: oGetAddrLocal 1
10988: oPushResult
10989: oGetParam 2
10991: oPushResult
10992: oNodeNew
10993: oPop 1
10995: oAssign
10996: oGetLocal 1
10998: oPushResult
10999: oSetResult 17
11001: oPushResult
11002: oGetParam 1
11004: oPushResult
11005: oNodeSetInt
11006: oPop 3
11008: oGetLocal 1
11010: oPushResult
11011: oTypeAdd
11012: oPop 1
11014: oGetLocal 1
11016: oReturn
11017: oReturn
11018: oLocalSpace 12
11020: oInputChoice 11503
11022: oGetAddrLocal 1
11024: oPushResult
11025: oScopeFindRequire
11026: oAssign
11027: oGetAddrLocal 1
11029: oPushResult
11030: oCall 244
11032: oPop 1
11034: oGetLocal 1
11036: oPushResult
11037: oNodeType
11038: oPop 1
11040: oChoice 11057
11042: oGetParam 1
11044: oPushResult
11045: oGetLocal 1
11047: oPushResult
11048: oSetResult 21
11050: oPushResult
11051: oNodeGet
11052: oPop 2
11054: oAssign
11055: oJumpForward 11068
11057: Choice Lookup Table
          19   11042
11060: oError 2
11062: oGetParam 1
11064: oPushResult
11065: oGetGlobal 6
11067: oAssign
11068: oJumpForward 11526
11070: oInput 16
11072: oGetAddrLocal 2
11074: oPushResult
11075: oNodeVecNew
11076: oAssign
11077: oGetAddrLocal 3
11079: oPushResult
11080: oSetResult 37
11082: oPushResult
11083: oNodeNew
11084: oPop 1
11086: oAssign
11087: oCall 3526
11089: oGetLocal 3
11091: oPushResult
11092: oSetResult 39
11094: oPushResult
11095: oValueTop
11096: oPushResult
11097: oNodeSetInt
11098: oPop 3
11100: oValuePop
11101: oInput 21
11103: oCall 3526
11105: oGetLocal 3
11107: oPushResult
11108: oSetResult 40
11110: oPushResult
11111: oValueTop
11112: oPushResult
11113: oNodeSetInt
11114: oPop 3
11116: oValuePop
11117: oCall 4171
11119: oGetLocal 3
11121: oPushResult
11122: oSetResult 37
11124: oPushResult
11125: oTypeSTop
11126: oPushResult
11127: oNodeSet
11128: oPop 3
11130: oGetLocal 3
11132: oPushResult
11133: oSetResult 17
11135: oPushResult
11136: oTypeSTop
11137: oPushResult
11138: oSetResult 17
11140: oPushResult
11141: oNodeGetInt
11142: oPop 2
11144: oPushResult
11145: oNodeSetInt
11146: oPop 3
11148: oTypeSPop
11149: oGetLocal 3
11151: oPushResult
11152: oTypeAdd
11153: oPop 1
11155: oGetAddrLocal 4
11157: oPushResult
11158: oSetResult 36
11160: oPushResult
11161: oNodeNew
11162: oPop 1
11164: oAssign
11165: oGetLocal 4
11167: oPushResult
11168: oSetResult 38
11170: oPushResult
11171: oGetLocal 3
11173: oPushResult
11174: oNodeSet
11175: oPop 3
11177: oGetLocal 2
11179: oPushResult
11180: oGetLocal 4
11182: oPushResult
11183: oNodeVecAppend
11184: oPop 2
11186: oInputChoice 11194
11188: oJumpForward 11202
11190: oJumpForward 11200
11192: oJumpForward 11200
11194: Choice Lookup Table
          13   11192
          17   11188
11199: oEndChoice
11200: oJumpBack 11077
11202: oInput 40
11204: oGetAddrLocal 5
11206: oPushResult
11207: oCall 11018
11209: oPop 1
11211: oGetAddrLocal 6
11213: oPushResult
11214: oGetLocal 2
11216: oPushResult
11217: oNodeVecSize
11218: oPop 1
11220: oAssign
11221: oGetAddrLocal 6
11223: oPushResult
11224: dec
11225: oPop 1
11227: oGetAddrLocal 7
11229: oPushResult
11230: oGetLocal 2
11232: oPushResult
11233: oGetLocal 6
11235: oPushResult
11236: oNodeVecElement
11237: oPop 2
11239: oAssign
11240: oGetLocal 7
11242: oPushResult
11243: oSetResult 37
11245: oPushResult
11246: oGetLocal 5
11248: oPushResult
11249: oNodeSet
11250: oPop 3
11252: oGetAddrLocal 8
11254: oPushResult
11255: oGetLocal 7
11257: oPushResult
11258: oSetResult 38
11260: oPushResult
11261: oNodeGet
11262: oPop 2
11264: oAssign
11265: oGetAddrLocal 9
11267: oPushResult
11268: oGetLocal 8
11270: oPushResult
11271: oSetResult 40
11273: oPushResult
11274: oNodeGetInt
11275: oPop 2
11277: oPushResult
11278: oGetLocal 8
11280: oPushResult
11281: oSetResult 39
11283: oPushResult
11284: oNodeGetInt
11285: oPop 2
11287: oPushResult
11288: subtract
11289: oPop 2
11291: oAssign
11292: oGetAddrLocal 9
11294: oPushResult
11295: inc
11296: oPop 1
11298: oGetLocal 7
11300: oPushResult
11301: oSetResult 17
11303: oPushResult
11304: oGetLocal 9
11306: oPushResult
11307: oGetLocal 5
11309: oPushResult
11310: oSetResult 17
11312: oPushResult
11313: oNodeGetInt
11314: oPop 2
11316: oPushResult
11317: multiply
11318: oPop 2
11320: oPushResult
11321: oNodeSetInt
11322: oPop 3
11324: oGetLocal 7
11326: oPushResult
11327: oTypeAdd
11328: oPop 1
11330: oGetAddrLocal 5
11332: oPushResult
11333: oGetLocal 7
11335: oAssign
11336: oGetLocal 6
11338: oPushResult
11339: equal_zero
11340: oPop 1
11342: oChoice 11348
11344: oJumpForward 11353
11346: oJumpForward 11351
11348: Choice Lookup Table
           1   11344
11351: oJumpBack 11221
11353: oGetParam 1
11355: oPushResult
11356: oGetLocal 2
11358: oPushResult
11359: oSetResult 0
11361: oPushResult
11362: oNodeVecElement
11363: oPop 2
11365: oAssign
11366: oGetLocal 2
11368: oPushResult
11369: oNodeVecDelete
11370: oPop 1
11372: oJumpForward 11526
11374: oGetAddrLocal 10
11376: oPushResult
11377: oCall 11018
11379: oPop 1
11381: oGetParam 1
11383: oPushResult
11384: oGetLocal 10
11386: oPushResult
11387: oCall 12097
11389: oPop 1
11391: oAssign
11392: oJumpForward 11526
11394: oGetParam 1
11396: oPushResult
11397: oSetResult 38
11399: oPushResult
11400: oNodeNew
11401: oPop 1
11403: oAssign
11404: oSetResult -1
11406: oPushResult
11407: oSetResult 2
11409: oPushResult
11410: oScopeBegin
11411: oPop 2
11413: oSetResult 23
11415: oPushResult
11416: oCall 3227
11418: oPop 1
11420: oGetAddrLocal 11
11422: oPushResult
11423: oScopeCurrent
11424: oPushResult
11425: oSetResult 17
11427: oPushResult
11428: oNodeGetInt
11429: oPop 2
11431: oAssign
11432: oGetLocal 11
11434: oPushResult
11435: equal_zero
11436: oPop 1
11438: oChoice 11444
11440: oError 19
11442: oJumpForward 11447
11444: Choice Lookup Table
           1   11440
11447: oInput 36
11449: oGetFromParam 1
11451: oPushResult
11452: oSetResult 41
11454: oPushResult
11455: oScopeCurrent
11456: oPushResult
11457: oNodeSet
11458: oPop 3
11460: oGetFromParam 1
11462: oPushResult
11463: oSetResult 17
11465: oPushResult
11466: oGetLocal 11
11468: oPushResult
11469: oNodeSetInt
11470: oPop 3
11472: oScopeEnd
11473: oGetFromParam 1
11475: oPushResult
11476: oTypeAdd
11477: oPop 1
11479: oJumpForward 11526
11481: oGetParam 1
11483: oPushResult
11484: oCall 11527
11486: oPop 1
11488: oJumpForward 11526
11490: oInput 40
11492: oGetAddrLocal 12
11494: oPushResult
11495: oCall 11018
11497: oPop 1
11499: oError 16
11501: oJumpForward 11526
11503: Choice Lookup Table
          39   11490
          14   11481
          38   11394
          18   11374
          37   11070
           0   11022
11516: oCall 3526
11518: oInput 21
11520: oCall 3526
11522: oCall 4171
11524: oError 16
11526: oReturn
11527: oLocalSpace 11
11529: oGetParam 1
11531: oPushResult
11532: oSetResult 41
11534: oPushResult
11535: oNodeNew
11536: oPop 1
11538: oAssign
11539: oGetAddrLocal 1
11541: oPushResult
11542: oSetResult 0
11544: oAssign
11545: oGetAddrLocal 2
11547: oPushResult
11548: oSetResult 0
11550: oAssign
11551: oGetAddrLocal 3
11553: oPushResult
11554: oSetResult 1
11556: oAssign
11557: oGetAddrLocal 4
11559: oPushResult
11560: oScopeCurrent
11561: oAssign
11562: oSetResult -1
11564: oPushResult
11565: oSetResult 2
11567: oPushResult
11568: oScopeBegin
11569: oPop 2
11571: oInput 0
11573: oGetAddrLocal 5
11575: oPushResult
11576: oSetResult 17
11578: oPushResult
11579: LAST_ID
11580: oPushResult
11581: oCall 13050
11583: oPop 2
11585: oAssign
11586: oGetAddrLocal 6
11588: oPushResult
11589: oSetResult 17
11591: oPushResult
11592: LAST_ID
11593: oPushResult
11594: oCall 13050
11596: oPop 2
11598: oAssign
11599: oGetLocal 5
11601: oPushResult
11602: oSetResult 21
11604: oPushResult
11605: oGetFromParam 1
11607: oPushResult
11608: oNodeSet
11609: oPop 3
11611: oGetLocal 6
11613: oPushResult
11614: oSetResult 21
11616: oPushResult
11617: oGetFromParam 1
11619: oPushResult
11620: oNodeSet
11621: oPop 3
11623: oGetAddrLocal 7
11625: oPushResult
11626: LAST_ID
11627: oPushResult
11628: ID_STRING
11629: oPop 1
11631: oPushResult
11632: oStringAllocLit
11633: oPop 1
11635: oAssign
11636: oGetLocal 5
11638: oPushResult
11639: oSetResult 32
11641: oPushResult
11642: oGetLocal 7
11644: oPushResult
11645: oNodeSetInt
11646: oPop 3
11648: oGetLocal 6
11650: oPushResult
11651: oSetResult 32
11653: oPushResult
11654: oGetLocal 7
11656: oPushResult
11657: oNodeSetInt
11658: oPop 3
11660: oInputChoice 11738
11662: oGetGlobal 6
11664: oPushResult
11665: oTypeSPush
11666: oPop 1
11668: oCall 3526
11670: oCall 4268
11672: oTypeSPop
11673: oGetLocal 2
11675: oPushResult
11676: equal_zero
11677: oPop 1
11679: oChoice 11700
11681: oValueTop
11682: oPushResult
11683: oGetLocal 1
11685: oPushResult
11686: greater
11687: oPop 2
11689: oChoice 11695
11691: oError 26
11693: oJumpForward 11698
11695: Choice Lookup Table
           0   11691
11698: oJumpForward 11703
11700: Choice Lookup Table
           0   11681
11703: oGetLocal 1
11705: oPushResult
11706: oValueTop
11707: oPushResult
11708: equal
11709: oPop 2
11711: oChoice 11727
11713: oGetFromParam 1
11715: oPushResult
11716: oSetResult 44
11718: oPushResult
11719: oSetResult 1
11721: oPushResult
11722: oNodeSetBoolean
11723: oPop 3
11725: oJumpForward 11730
11727: Choice Lookup Table
           0   11713
11730: oGetAddrLocal 1
11732: oPushResult
11733: oValueTop
11734: oAssign
11735: oValuePop
11736: oJumpForward 11743
11738: Choice Lookup Table
           4   11662
           6   11662
11743: oGetLocal 5
11745: oPushResult
11746: oSetResult 22
11748: oPushResult
11749: oGetLocal 1
11751: oPushResult
11752: oNodeSetInt
11753: oPop 3
11755: oGetLocal 6
11757: oPushResult
11758: oSetResult 22
11760: oPushResult
11761: oGetLocal 1
11763: oPushResult
11764: oNodeSetInt
11765: oPop 3
11767: oGetLocal 5
11769: oPushResult
11770: oScopeDeclare
11771: oPop 1
11773: oGetLocal 4
11775: oPushResult
11776: oScopeEnter
11777: oPop 1
11779: oGetLocal 6
11781: oPushResult
11782: oScopeDeclare
11783: oPop 1
11785: oScopeEnd
11786: oGetAddrLocal 1
11788: oPushResult
11789: inc
11790: oPop 1
11792: oGetAddrLocal 2
11794: oPushResult
11795: inc
11796: oPop 1
11798: oInputChoice 11802
11800: oJumpForward 11807
11802: Choice Lookup Table
          13   11800
11805: oJumpForward 11809
11807: oJumpBack 11571
11809: oInput 15
11811: oGetFromParam 1
11813: oPushResult
11814: oSetResult 41
11816: oPushResult
11817: oScopeCurrent
11818: oPushResult
11819: oNodeSet
11820: oPop 3
11822: oGetFromParam 1
11824: oPushResult
11825: oSetResult 17
11827: oPushResult
11828: oSetResult 4
11830: oPushResult
11831: oNodeSetInt
11832: oPop 3
11834: oScopeEnd
11835: oGetGlobal 2
11837: oPushResult
11838: oCall 12948
11840: oPop 1
11842: oPushResult
11843: oCodePush
11844: oPop 1
11846: oGetGlobal 2
11848: oPushResult
11849: oScopeEnter
11850: oPop 1
11852: oGetAddrLocal 8
11854: oPushResult
11855: oGetLocal 2
11857: oPushResult
11858: oSetResult 1
11860: oPushResult
11861: add
11862: oPop 2
11864: oPushResult
11865: oSetResult 16
11867: oPushResult
11868: multiply
11869: oPop 2
11871: oAssign
11872: oGetAddrLocal 9
11874: oPushResult
11875: oGetLocal 8
11877: oPushResult
11878: oSetResult 8
11880: oPushResult
11881: oScopeAlloc
11882: oPop 2
11884: oAssign
11885: oScopeEnd
11886: oGetFromParam 1
11888: oPushResult
11889: oSetResult 43
11891: oPushResult
11892: oGetLocal 9
11894: oPushResult
11895: oNodeSetInt
11896: oPop 3
11898: oGetAddrLocal 10
11900: oPushResult
11901: oGetFromParam 1
11903: oPushResult
11904: oSetResult 41
11906: oPushResult
11907: oNodeGet
11908: oPop 2
11910: oPushResult
11911: oSetResult 15
11913: oPushResult
11914: oNodeGetIter
11915: oPop 2
11917: oAssign
11918: oGetAddrLocal 11
11920: oPushResult
11921: oGetLocal 10
11923: oPushResult
11924: oNodeIterValue
11925: oPop 1
11927: oAssign
11928: oGetLocal 11
11930: oPushResult
11931: oNodeNull
11932: oPop 1
11934: oChoice 11940
11936: oJumpForward 12027
11938: oJumpForward 11943
11940: Choice Lookup Table
           1   11936
11943: oEmit 16
11945: oGetLocal 9
11947: oPushResult
11948: oEmitInt
11949: oPop 1
11951: oEmit 15
11953: oGetLocal 11
11955: oPushResult
11956: oSetResult 22
11958: oPushResult
11959: oNodeGetInt
11960: oPop 2
11962: oPushResult
11963: oEmitInt
11964: oPop 1
11966: oEmit 26
11968: oGetAddrLocal 9
11970: oPushResult
11971: oGetLocal 9
11973: oPushResult
11974: oSetResult 8
11976: oPushResult
11977: add
11978: oPop 2
11980: oAssign
11981: oEmit 16
11983: oGetLocal 9
11985: oPushResult
11986: oEmitInt
11987: oPop 1
11989: oEmit 16
11991: oGetLocal 11
11993: oPushResult
11994: oSetResult 32
11996: oPushResult
11997: oNodeGetInt
11998: oPop 2
12000: oPushResult
12001: oEmitInt
12002: oPop 1
12004: oEmit 28
12006: oGetAddrLocal 9
12008: oPushResult
12009: oGetLocal 9
12011: oPushResult
12012: oSetResult 8
12014: oPushResult
12015: add
12016: oPop 2
12018: oAssign
12019: oGetAddrLocal 10
12021: oPushResult
12022: oNodeIterNext
12023: oPop 1
12025: oJumpBack 11918
12027: oEmit 16
12029: oGetLocal 9
12031: oPushResult
12032: oEmitInt
12033: oPop 1
12035: oEmit 15
12037: oSetResult 0
12039: oPushResult
12040: oEmitInt
12041: oPop 1
12043: oEmit 26
12045: oGetAddrLocal 9
12047: oPushResult
12048: oGetLocal 9
12050: oPushResult
12051: oSetResult 8
12053: oPushResult
12054: add
12055: oPop 2
12057: oAssign
12058: oEmit 16
12060: oGetLocal 9
12062: oPushResult
12063: oEmitInt
12064: oPop 1
12066: oEmit 15
12068: oSetResult 0
12070: oPushResult
12071: oEmitInt
12072: oPop 1
12074: oEmit 28
12076: oGetAddrLocal 9
12078: oPushResult
12079: oGetLocal 9
12081: oPushResult
12082: oSetResult 8
12084: oPushResult
12085: add
12086: oPop 2
12088: oAssign
12089: oCodePop
12090: oGetFromParam 1
12092: oPushResult
12093: oTypeAdd
12094: oPop 1
12096: oReturn
12097: oLocalSpace 1
12099: oGetAddrLocal 1
12101: oPushResult
12102: oGetParam 1
12104: oPushResult
12105: oSetResult 36
12107: oPushResult
12108: oNodeGet
12109: oPop 2
12111: oAssign
12112: oGetLocal 1
12114: oPushResult
12115: oNodeNull
12116: oPop 1
12118: oChoice 12174
12120: oGetAddrLocal 1
12122: oPushResult
12123: oSetResult 34
12125: oPushResult
12126: oNodeNew
12127: oPop 1
12129: oAssign
12130: oGetLocal 1
12132: oPushResult
12133: oSetResult 37
12135: oPushResult
12136: oGetParam 1
12138: oPushResult
12139: oNodeSet
12140: oPop 3
12142: oGetLocal 1
12144: oPushResult
12145: oSetResult 17
12147: oPushResult
12148: oSetResult 8
12150: oPushResult
12151: oNodeSetInt
12152: oPop 3
12154: oGetLocal 1
12156: oPushResult
12157: oTypeAdd
12158: oPop 1
12160: oGetParam 1
12162: oPushResult
12163: oSetResult 36
12165: oPushResult
12166: oGetLocal 1
12168: oPushResult
12169: oNodeSet
12170: oPop 3
12172: oJumpForward 12177
12174: Choice Lookup Table
           1   12120
12177: oGetLocal 1
12179: oReturn
12180: oReturn
12181: oLocalSpace 2
12183: oGetParam 1
12185: oPushResult
12186: oNodeType
12187: oPop 1
12189: oChoice 12259
12191: oMININT
12192: oReturn
12193: oJumpForward 12275
12195: oSetResult 0
12197: oReturn
12198: oJumpForward 12275
12200: oSetResult 0
12202: oReturn
12203: oJumpForward 12275
12205: oGetAddrLocal 1
12207: oPushResult
12208: oGetParam 1
12210: oPushResult
12211: oSetResult 41
12213: oPushResult
12214: oNodeGet
12215: oPop 2
12217: oAssign
12218: oGetAddrLocal 2
12220: oPushResult
12221: oGetLocal 1
12223: oPushResult
12224: oSetResult 15
12226: oPushResult
12227: oNodeGetIter
12228: oPop 2
12230: oPushResult
12231: oNodeIterValue
12232: oPop 1
12234: oAssign
12235: oGetLocal 2
12237: oPushResult
12238: oSetResult 22
12240: oPushResult
12241: oNodeGetInt
12242: oPop 2
12244: oReturn
12245: oJumpForward 12275
12247: oGetParam 1
12249: oPushResult
12250: oSetResult 39
12252: oPushResult
12253: oNodeGetInt
12254: oPop 2
12256: oReturn
12257: oJumpForward 12275
12259: Choice Lookup Table
          37   12247
          41   12205
          33   12200
          31   12195
          29   12191
12270: oError 3
12272: oSetResult 0
12274: oReturn
12275: oReturn
12276: oLocalSpace 2
12278: oGetParam 1
12280: oPushResult
12281: oNodeType
12282: oPop 1
12284: oChoice 12354
12286: oMAXINT
12287: oReturn
12288: oJumpForward 12370
12290: oSetResult 1
12292: oReturn
12293: oJumpForward 12370
12295: oSetResult 255
12297: oReturn
12298: oJumpForward 12370
12300: oGetAddrLocal 1
12302: oPushResult
12303: oGetParam 1
12305: oPushResult
12306: oSetResult 41
12308: oPushResult
12309: oNodeGet
12310: oPop 2
12312: oAssign
12313: oGetAddrLocal 2
12315: oPushResult
12316: oGetLocal 1
12318: oPushResult
12319: oSetResult 15
12321: oPushResult
12322: oNodeGetIterLast
12323: oPop 2
12325: oPushResult
12326: oNodeIterValue
12327: oPop 1
12329: oAssign
12330: oGetLocal 2
12332: oPushResult
12333: oSetResult 22
12335: oPushResult
12336: oNodeGetInt
12337: oPop 2
12339: oReturn
12340: oJumpForward 12370
12342: oGetParam 1
12344: oPushResult
12345: oSetResult 40
12347: oPushResult
12348: oNodeGetInt
12349: oPop 2
12351: oReturn
12352: oJumpForward 12370
12354: Choice Lookup Table
          37   12342
          41   12300
          33   12295
          31   12290
          29   12286
12365: oError 3
12367: oSetResult 0
12369: oReturn
12370: oReturn
12371: oLocalSpace 5
12373: oGetAddrGlobal 1
12375: oPushResult
12376: oWorkspaceNew
12377: oAssign
12378: oSetResult 0
12380: oPushResult
12381: oSetResult 0
12383: oPushResult
12384: oScopeBegin
12385: oPop 2
12387: oGetAddrLocal 2
12389: oPushResult
12390: oScopeCurrent
12391: oAssign
12392: oCall 13120
12394: oEmit 67
12396: oSetResult 0
12398: oPushResult
12399: oEmitInt
12400: oPop 1
12402: oGetAddrLocal 3
12404: oPushResult
12405: oLabelNew
12406: oAssign
12407: oEmit 61
12409: oSetResult 0
12411: oPushResult
12412: oEmitInt
12413: oPop 1
12415: oEmit 64
12417: oGetLocal 3
12419: oPushResult
12420: oEmitLabel
12421: oPop 1
12423: oEmit 63
12425: oSetResult 0
12427: oPushResult
12428: oEmitInt
12429: oPop 1
12431: oEmit 66
12433: oInput 28
12435: oInput 0
12437: oGetAddrLocal 4
12439: oPushResult
12440: oSetResult 4
12442: oPushResult
12443: oNodeNew
12444: oPop 1
12446: oAssign
12447: oGetLocal 4
12449: oPushResult
12450: oSetResult 4
12452: oPushResult
12453: LAST_ID
12454: oPushResult
12455: oNodeSetInt
12456: oPop 3
12458: oGetGlobal 1
12460: oPushResult
12461: oSetResult 2
12463: oPushResult
12464: oGetLocal 4
12466: oPushResult
12467: oNodeSet
12468: oPop 3
12470: oInputChoice 12544
12472: oInput 0
12474: oGetAddrLocal 1
12476: oPushResult
12477: oSetResult 20
12479: oPushResult
12480: LAST_ID
12481: oPushResult
12482: oCall 13050
12484: oPop 2
12486: oAssign
12487: oGetLocal 1
12489: oPushResult
12490: oSetResult 21
12492: oPushResult
12493: oGetGlobal 5
12495: oPushResult
12496: oNodeSet
12497: oPop 3
12499: oGetLocal 1
12501: oPushResult
12502: oScopeDeclareAlloc
12503: oPop 1
12505: oInput 13
12507: oInput 0
12509: oGetAddrLocal 1
12511: oPushResult
12512: oSetResult 20
12514: oPushResult
12515: LAST_ID
12516: oPushResult
12517: oCall 13050
12519: oPop 2
12521: oAssign
12522: oGetLocal 1
12524: oPushResult
12525: oSetResult 21
12527: oPushResult
12528: oGetGlobal 5
12530: oPushResult
12531: oNodeSet
12532: oPop 3
12534: oGetLocal 1
12536: oPushResult
12537: oScopeDeclareAlloc
12538: oPop 1
12540: oInput 15
12542: oJumpForward 12547
12544: Choice Lookup Table
          14   12472
12547: oInput 5
12549: oGetLocal 4
12551: oPushResult
12552: oCall 34
12554: oPop 1
12556: oInputChoice 12567
12558: oGetLocal 4
12560: oPushResult
12561: oCall 7
12563: oPop 1
12565: oJumpForward 12570
12567: Choice Lookup Table
          59   12558
12570: oGetLocal 4
12572: oPushResult
12573: oCall 287
12575: oPop 1
12577: oSetResult 0
12579: oPushResult
12580: oSetResult 0
12582: oPushResult
12583: oScopeBegin
12584: oPop 2
12586: oGetAddrGlobal 2
12588: oPushResult
12589: oScopeCurrent
12590: oAssign
12591: oSetResult 0
12593: oPushResult
12594: oSetResult 1
12596: oPushResult
12597: oScopeBegin
12598: oPop 2
12600: oScopeCurrent
12601: oPushResult
12602: oSetResult 16
12604: oPushResult
12605: oGetGlobal 2
12607: oPushResult
12608: oNodeSet
12609: oPop 3
12611: oGetAddrGlobal 3
12613: oPushResult
12614: oScopeCurrent
12615: oAssign
12616: oGetLocal 4
12618: oPushResult
12619: oSetResult 7
12621: oPushResult
12622: oGetGlobal 3
12624: oPushResult
12625: oNodeSet
12626: oPop 3
12628: oScopeEnd
12629: oSetResult 21
12631: oPushResult
12632: oCall 12699
12634: oPop 1
12636: oGetGlobal 3
12638: oPushResult
12639: oScopeEnter
12640: oPop 1
12642: oGetAddrLocal 5
12644: oPushResult
12645: oSetResult 1
12647: oAssign
12648: oGetLocal 3
12650: oPushResult
12651: oGetGlobal 2
12653: oPushResult
12654: oGetLocal 5
12656: oPushResult
12657: oCall 12850
12659: oPop 3
12661: oScopeEnd
12662: oInput 20
12664: oCall 12755
12666: oScopeEnd
12667: oGetLocal 4
12669: oPushResult
12670: oCall 349
12672: oPop 1
12674: oReturn
12675: oLocalSpace 0
12677: oGetParam 2
12679: oPushResult
12680: oCall 12699
12682: oPop 1
12684: oGetParam 1
12686: oPushResult
12687: oScopeCurrent
12688: oPushResult
12689: oSetResult 0
12691: oPushResult
12692: oCall 12850
12694: oPop 3
12696: oCall 12755
12698: oReturn
12699: oLocalSpace 0
12701: oInputChoice 12732
12703: oCall 2513
12705: oJumpForward 12747
12707: oCall 3171
12709: oJumpForward 12747
12711: oGetParam 1
12713: oPushResult
12714: oCall 3227
12716: oPop 1
12718: oJumpForward 12747
12720: oCall 3461
12722: oJumpForward 12747
12724: oCall 1736
12726: oJumpForward 12747
12728: oCall 2171
12730: oJumpForward 12747
12732: Choice Lookup Table
          30   12728
          29   12724
          34   12720
          33   12711
          32   12707
          31   12703
12745: oJumpForward 12749
12747: oJumpBack 12701
12749: oCall 12752
12751: oReturn
12752: oLocalSpace 0
12754: oReturn
12755: oLocalSpace 2
12757: oGetAddrLocal 1
12759: oPushResult
12760: oScopeCurrent
12761: oPushResult
12762: oSetResult 15
12764: oPushResult
12765: oNodeGetIter
12766: oPop 2
12768: oAssign
12769: oGetAddrLocal 2
12771: oPushResult
12772: oGetLocal 1
12774: oPushResult
12775: oNodeIterValue
12776: oPop 1
12778: oAssign
12779: oGetLocal 2
12781: oPushResult
12782: oNodeNull
12783: oPop 1
12785: oChoice 12789
12787: oJumpForward 12794
12789: Choice Lookup Table
           0   12787
12792: oJumpForward 12849
12794: oGetLocal 2
12796: oPushResult
12797: oNodeType
12798: oPop 1
12800: oChoice 12838
12802: oGetLocal 2
12804: oPushResult
12805: oSetResult 35
12807: oPushResult
12808: oNodeGetBoolean
12809: oPop 2
12811: oChoice 12833
12813: oGetLocal 2
12815: oPushResult
12816: oSetResult 28
12818: oPushResult
12819: oNodeGetBoolean
12820: oPop 2
12822: oChoice 12828
12824: oError 27
12826: oJumpForward 12831
12828: Choice Lookup Table
           1   12824
12831: oJumpForward 12836
12833: Choice Lookup Table
           0   12813
12836: oJumpForward 12841
12838: Choice Lookup Table
          26   12802
12841: oGetAddrLocal 1
12843: oPushResult
12844: oNodeIterNext
12845: oPop 1
12847: oJumpBack 12769
12849: oReturn
12850: oLocalSpace 3
12852: oEmit 77
12854: oGetParam 3
12856: oPushResult
12857: oEmitLabel
12858: oPop 1
12860: oEmit 67
12862: oGetAddrLocal 1
12864: oPushResult
12865: Here
12866: oAssign
12867: oEmit 90
12869: oGetParam 1
12871: oChoice 12877
12873: oCall 1220
12875: oJumpForward 12880
12877: Choice Lookup Table
           1   12873
12880: oGetAddrLocal 2
12882: oPushResult
12883: oGetParam 2
12885: oPushResult
12886: oSetResult 19
12888: oPushResult
12889: oNodeGetCode
12890: oPop 2
12892: oAssign
12893: oGetLocal 2
12895: oPushResult
12896: oEmitCode
12897: oPop 1
12899: oGetParam 2
12901: oPushResult
12902: oSetResult 19
12904: oPushResult
12905: oSetResult 0
12907: oPushResult
12908: oNodeSetCode
12909: oPop 3
12911: oCall 8098
12913: oGetParam 1
12915: oChoice 12921
12917: oCall 1305
12919: oJumpForward 12924
12921: Choice Lookup Table
           1   12917
12924: oEmit 66
12926: oGetAddrLocal 3
12928: oPushResult
12929: oScopeCurrent
12930: oPushResult
12931: oSetResult 17
12933: oPushResult
12934: oNodeGetInt
12935: oPop 2
12937: oAssign
12938: oGetLocal 1
12940: oPushResult
12941: oGetLocal 3
12943: oPushResult
12944: oPatch
12945: oPop 2
12947: oReturn
12948: oLocalSpace 1
12950: oGetAddrLocal 1
12952: oPushResult
12953: oGetParam 1
12955: oPushResult
12956: oSetResult 19
12958: oPushResult
12959: oNodeGetCode
12960: oPop 2
12962: oAssign
12963: oGetLocal 1
12965: oPushResult
12966: oSetResult 0
12968: oPushResult
12969: equal_code
12970: oPop 2
12972: oChoice 12993
12974: oGetAddrLocal 1
12976: oPushResult
12977: oCodeNew
12978: oAssign
12979: oGetParam 1
12981: oPushResult
12982: oSetResult 19
12984: oPushResult
12985: oGetLocal 1
12987: oPushResult
12988: oNodeSetCode
12989: oPop 3
12991: oJumpForward 12996
12993: Choice Lookup Table
           1   12974
12996: oGetLocal 1
12998: oReturn
12999: oReturn
13000: oLocalSpace 0
13002: oScopeCurrent
13003: oPushResult
13004: oSetResult 14
13006: oPushResult
13007: oNodeGetInt
13008: oPop 2
13010: oReturn
13011: oReturn
13012: oLocalSpace 0
13014: oGetParam 1
13016: oPushResult
13017: oSetResult 20
13019: oPushResult
13020: oNodeGet
13021: oPop 2
13023: oPushResult
13024: oSetResult 14
13026: oPushResult
13027: oNodeGetInt
13028: oPop 2
13030: oReturn
13031: oReturn
13032: oLocalSpace 0
13034: oCall 13000
13036: oPushResult
13037: oGetParam 1
13039: oPushResult
13040: oCall 13012
13042: oPop 1
13044: oPushResult
13045: subtract
13046: oPop 2
13048: oReturn
13049: oReturn
13050: oLocalSpace 1
13052: oGetAddrLocal 1
13054: oPushResult
13055: oGetParam 2
13057: oPushResult
13058: oNodeNew
13059: oPop 1
13061: oAssign
13062: oGetLocal 1
13064: oPushResult
13065: oSetResult 4
13067: oPushResult
13068: oGetParam 1
13070: oPushResult
13071: oNodeSetInt
13072: oPop 3
13074: oGetLocal 1
13076: oReturn
13077: oReturn
13078: oLocalSpace 0
13080: oGetParam 1
13082: oPushResult
13083: oSetResult 22
13085: oPushResult
13086: oNodeGetInt
13087: oPop 2
13089: oPushResult
13090: oEmitInt
13091: oPop 1
13093: oReturn
13094: oLocalSpace 1
13096: oGetAddrLocal 1
13098: oPushResult
13099: oSetResult 14
13101: oPushResult
13102: oGetParam 1
13104: oPushResult
13105: oCall 13050
13107: oPop 2
13109: oAssign
13110: oGetLocal 1
13112: oPushResult
13113: oScopeDeclare
13114: oPop 1
13116: oGetLocal 1
13118: oReturn
13119: oReturn
13120: oLocalSpace 1
13122: oGetAddrGlobal 4
13124: oPushResult
13125: oId_mysystem
13126: oAssign
13127: oGetAddrGlobal 5
13129: oPushResult
13130: oSetResult 28
13132: oPushResult
13133: oSetResult 4
13135: oPushResult
13136: oCall 10984
13138: oPop 2
13140: oAssign
13141: oGetAddrGlobal 6
13143: oPushResult
13144: oSetResult 29
13146: oPushResult
13147: oSetResult 4
13149: oPushResult
13150: oCall 10984
13152: oPop 2
13154: oAssign
13155: oGetAddrGlobal 7
13157: oPushResult
13158: oSetResult 31
13160: oPushResult
13161: oSetResult 1
13163: oPushResult
13164: oCall 10984
13166: oPop 2
13168: oAssign
13169: oGetAddrGlobal 8
13171: oPushResult
13172: oSetResult 32
13174: oPushResult
13175: oSetResult 1
13177: oPushResult
13178: oCall 10984
13180: oPop 2
13182: oAssign
13183: oGetAddrGlobal 9
13185: oPushResult
13186: oSetResult 33
13188: oPushResult
13189: oSetResult 1
13191: oPushResult
13192: oCall 10984
13194: oPop 2
13196: oAssign
13197: oGetAddrGlobal 10
13199: oPushResult
13200: oGetGlobal 9
13202: oPushResult
13203: oCall 12097
13205: oPop 1
13207: oAssign
13208: oGetAddrGlobal 11
13210: oPushResult
13211: oSetResult 30
13213: oPushResult
13214: oSetResult 1
13216: oPushResult
13217: oCall 10984
13219: oPop 2
13221: oAssign
13222: oGetAddrGlobal 12
13224: oPushResult
13225: oSetResult 35
13227: oPushResult
13228: oSetResult 8
13230: oPushResult
13231: oCall 10984
13233: oPop 2
13235: oAssign
13236: oGetGlobal 12
13238: oPushResult
13239: oSetResult 37
13241: oPushResult
13242: oGetGlobal 11
13244: oPushResult
13245: oNodeSet
13246: oPop 3
13248: oGetAddrGlobal 13
13250: oPushResult
13251: oSetResult 39
13253: oPushResult
13254: oSetResult 256
13256: oPushResult
13257: oCall 10984
13259: oPop 2
13261: oAssign
13262: oGetAddrGlobal 14
13264: oPushResult
13265: oSetResult 40
13267: oPushResult
13268: oSetResult 256
13270: oPushResult
13271: oCall 10984
13273: oPop 2
13275: oAssign
13276: oGetGlobal 14
13278: oPushResult
13279: oSetResult 42
13281: oPushResult
13282: oSetResult 255
13284: oPushResult
13285: oNodeSetInt
13286: oPop 3
13288: oGetAddrLocal 1
13290: oPushResult
13291: oSetResult 19
13293: oPushResult
13294: oId_File
13295: oPushResult
13296: oCall 13050
13298: oPop 2
13300: oAssign
13301: oGetLocal 1
13303: oPushResult
13304: oSetResult 21
13306: oPushResult
13307: oGetGlobal 5
13309: oPushResult
13310: oNodeSet
13311: oPop 3
13313: oGetLocal 1
13315: oPushResult
13316: oScopeDeclare
13317: oPop 1
13319: oGetAddrLocal 1
13321: oPushResult
13322: oSetResult 19
13324: oPushResult
13325: oId_Integer
13326: oPushResult
13327: oCall 13050
13329: oPop 2
13331: oAssign
13332: oGetLocal 1
13334: oPushResult
13335: oSetResult 21
13337: oPushResult
13338: oGetGlobal 6
13340: oPushResult
13341: oNodeSet
13342: oPop 3
13344: oGetLocal 1
13346: oPushResult
13347: oScopeDeclare
13348: oPop 1
13350: oGetAddrLocal 1
13352: oPushResult
13353: oSetResult 19
13355: oPushResult
13356: oId_Boolean
13357: oPushResult
13358: oCall 13050
13360: oPop 2
13362: oAssign
13363: oGetLocal 1
13365: oPushResult
13366: oSetResult 21
13368: oPushResult
13369: oGetGlobal 7
13371: oPushResult
13372: oNodeSet
13373: oPop 3
13375: oGetLocal 1
13377: oPushResult
13378: oScopeDeclare
13379: oPop 1
13381: oGetAddrLocal 1
13383: oPushResult
13384: oSetResult 19
13386: oPushResult
13387: oId_Char
13388: oPushResult
13389: oCall 13050
13391: oPop 2
13393: oAssign
13394: oGetLocal 1
13396: oPushResult
13397: oSetResult 21
13399: oPushResult
13400: oGetGlobal 9
13402: oPushResult
13403: oNodeSet
13404: oPop 3
13406: oGetLocal 1
13408: oPushResult
13409: oScopeDeclare
13410: oPop 1
13412: oGetAddrLocal 1
13414: oPushResult
13415: oSetResult 19
13417: oPushResult
13418: oId_Byte
13419: oPushResult
13420: oCall 13050
13422: oPop 2
13424: oAssign
13425: oGetLocal 1
13427: oPushResult
13428: oSetResult 21
13430: oPushResult
13431: oGetGlobal 11
13433: oPushResult
13434: oNodeSet
13435: oPop 3
13437: oGetLocal 1
13439: oPushResult
13440: oScopeDeclare
13441: oPop 1
13443: oGetAddrLocal 1
13445: oPushResult
13446: oSetResult 19
13448: oPushResult
13449: oId_Pointer
13450: oPushResult
13451: oCall 13050
13453: oPop 2
13455: oAssign
13456: oGetLocal 1
13458: oPushResult
13459: oSetResult 21
13461: oPushResult
13462: oGetGlobal 12
13464: oPushResult
13465: oNodeSet
13466: oPop 3
13468: oGetLocal 1
13470: oPushResult
13471: oScopeDeclare
13472: oPop 1
13474: oGetAddrLocal 1
13476: oPushResult
13477: oSetResult 19
13479: oPushResult
13480: oId_ShortString
13481: oPushResult
13482: oCall 13050
13484: oPop 2
13486: oAssign
13487: oGetLocal 1
13489: oPushResult
13490: oSetResult 21
13492: oPushResult
13493: oGetGlobal 14
13495: oPushResult
13496: oNodeSet
13497: oPop 3
13499: oGetLocal 1
13501: oPushResult
13502: oScopeDeclare
13503: oPop 1
13505: oGetAddrLocal 1
13507: oPushResult
13508: oSetResult 16
13510: oPushResult
13511: oId_True
13512: oPushResult
13513: oCall 13050
13515: oPop 2
13517: oAssign
13518: oGetLocal 1
13520: oPushResult
13521: oSetResult 21
13523: oPushResult
13524: oGetGlobal 7
13526: oPushResult
13527: oNodeSet
13528: oPop 3
13530: oGetLocal 1
13532: oPushResult
13533: oSetResult 22
13535: oPushResult
13536: oSetResult 1
13538: oPushResult
13539: oNodeSetInt
13540: oPop 3
13542: oGetLocal 1
13544: oPushResult
13545: oScopeDeclare
13546: oPop 1
13548: oGetAddrLocal 1
13550: oPushResult
13551: oSetResult 16
13553: oPushResult
13554: oId_False
13555: oPushResult
13556: oCall 13050
13558: oPop 2
13560: oAssign
13561: oGetLocal 1
13563: oPushResult
13564: oSetResult 21
13566: oPushResult
13567: oGetGlobal 7
13569: oPushResult
13570: oNodeSet
13571: oPop 3
13573: oGetLocal 1
13575: oPushResult
13576: oSetResult 22
13578: oPushResult
13579: oSetResult 0
13581: oPushResult
13582: oNodeSetInt
13583: oPop 3
13585: oGetLocal 1
13587: oPushResult
13588: oScopeDeclare
13589: oPop 1
13591: oGetAddrLocal 1
13593: oPushResult
13594: oSetResult 16
13596: oPushResult
13597: oId_Nil
13598: oPushResult
13599: oCall 13050
13601: oPop 2
13603: oAssign
13604: oGetLocal 1
13606: oPushResult
13607: oSetResult 21
13609: oPushResult
13610: oGetGlobal 12
13612: oPushResult
13613: oNodeSet
13614: oPop 3
13616: oGetLocal 1
13618: oPushResult
13619: oSetResult 22
13621: oPushResult
13622: oSetResult 0
13624: oPushResult
13625: oNodeSetInt
13626: oPop 3
13628: oGetLocal 1
13630: oPushResult
13631: oScopeDeclare
13632: oPop 1
13634: oGetAddrGlobal 15
13636: oPushResult
13637: oId_Ord
13638: oPushResult
13639: oCall 13094
13641: oPop 1
13643: oAssign
13644: oGetAddrGlobal 16
13646: oPushResult
13647: oId_Chr
13648: oPushResult
13649: oCall 13094
13651: oPop 1
13653: oAssign
13654: oGetAddrGlobal 17
13656: oPushResult
13657: oId_Pred
13658: oPushResult
13659: oCall 13094
13661: oPop 1
13663: oAssign
13664: oGetAddrGlobal 18
13666: oPushResult
13667: oId_Succ
13668: oPushResult
13669: oCall 13094
13671: oPop 1
13673: oAssign
13674: oReturn
