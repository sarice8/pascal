   2: title: 'Pascal Compiler 1.1.5 -- Jan 01 ''90';
         
      %
      %  Pascal.ssl
      %
      %  Pascal Compiler for the Amiga, by Steve Rice.
      %
      %  HISTORY
      %    11Sep89   First version, framework of parser.
      %    18Sep89   Added some semantic mechanisms.
      %    21Sep89   Added simple type references; expressions generate code.
      %    22Sep89   Allocate variable addresses as they're declared.
      %    24Sep89   Added arrays, pointers.
      %    27Sep89   Added for statement.
      %    23Oct89   Fixed for statement, so CYCLE goes to next step.
      %    01Jan90   Added string literals
      %    09Sep22   I have returned.  Migrate symbol table to schema, to ease development.
      %    01Oct22   Language: Switch from cycle/exit (Mac Pascal extension) to continue/break (Borland).
      %
      %  NOTES
      %    -  The 'value' of a var symbol is its allocated address.
      %    -  References to vars of intrinsic types, and pointer types,
      %       pushes the value of the var on the expr stack.  Referenecs to
      %       vars of compound types (arrays, records...) pushes the address
      %       on the expr stack.
      %    -  Just as there is only one type table entry for a given (named) type,
      %       there is only one type table entry for a pointer to a named type.
      %       When a pointer type is declared, a field in the TT entry of the
      %       type pointed to will be set to indicate the TT entry of the pointer
      %       to that type (0 means none defined yet).  When evaluating the
      %       expression @x, the type in that field in the entry for the type of x
      %       will be used (unless it's 0, in which case a new TT entry will be
      %       created).
      %
      %
      %  MISSING
      %
      %    - Consider non-ISO extensions.  e.g. 
      %      Dynamic arrays.  Objects.  But, perhaps stick to my old goal, standard Pascal.
      %
      %  PASCAL DOCS
      %      Here's some handy language material:
      %      https://www.freepascal.org/docs-html/ref/ref.html
      %      https://www.freepascal.org/docs-html/prog/prog.html
      %      https://en.wikipedia.org/wiki/Turbo_Pascal
      %      https://en.wikipedia.org/wiki/Pascal_(programming_language)#Standards
      %      http://www.standardpascaline.org/
      %
      
   2: input:
   2:    pIdent
   2:    pIntLit
   2:    pStrLit
   2:    pCharLit
   2:    pAssign       ':='
   2:    pSemiColon    ';'
   2:    pEqual        '='
   2:    pNotEqual     '<>'
   2:    pLess         '<'
   2:    pGreater      '>'
   2:    pLessEqual    '<='
   2:    pGreaterEqual '>='
   2:    pColon        ':'
   2:    pComma        ','
   2:    pLParen       '('
   2:    pRParen       ')'
   2:    pLSquare      '['
   2:    pRSquare      ']'
   2:    pCarat        '^'
   2:    pAt           '@'
   2:    pDot          '.'
   2:    pDotDot       '..'
   2:    pTimes        '*'
   2:    pDivide       '/'
   2:    pPlus         '+'
   2:    pMinus        '-'
   2:    pEof
   2:    pInvalid
      
      %  keywords  (built-in types 'integer', 'byte', 'char', etc, are not keywords,
      %             type constructors 'array', 'record', 'set' are keywords,
      %             pseudo-procedures 'writeln', 'readln' are keywords)
      %
      %             forward/external/name/cdecl appear in method modifiers, in fpc grammar.
      %             I'm making them keywords to simplify parsing, but could reconsider.
      
   2:    pProgram
   2:    pProcedure
   2:    pFunction
   2:    pConst
   2:    pType
   2:    pVar
   2:    pLabel
   2:    pBegin
   2:    pEnd
   2:    pArray
   2:    pRecord
   2:    pSet
   2:    pOf
   2:    pIf
   2:    pThen
   2:    pElse
   2:    pFor
   2:    pTo
   2:    pDownto
   2:    pDo
   2:    pWhile
   2:    pRepeat
   2:    pUntil
   2:    pContinue
   2:    pBreak
   2:    pGoto
   2:    pAnd
   2:    pOr
   2:    pNot
   2:    pUses
   2:    pUnit
   2:    pInterface
   2:    pImplementation
   2:    pInitialization
   2:    pFinalization
   2:    pWriteln
   2:    pWrite
   2:    pReadln
   2:    pRead
      
   2:    pForward
   2:    pExternal
   2:    pName
   2:    pCdecl
   2:    ;
      
      
   2: output:
      
      %  Instructions for a stack machine (all vars are 32-bit integers)
      
   2:    tPushGlobalI      % <ptr> - push int value read from ptr
   2:    tPushGlobalB      % <ptr> - push byte value read from ptr
   2:    tPushGlobalP      % <ptr> - push ptr value read from ptr
   2:    tPushLocalI       % <offset> - push int value read from local var in current scope
   2:    tPushLocalB       % <offset> - push byte value read from local var in current scope
   2:    tPushLocalP       % <offset> - push ptr value read from local var in current scope
   2:    tPushParamI       % <offset> - push int value read from param in current scope
   2:    tPushParamB       % <offset> - push byte value read from param in current scope
   2:    tPushParamP       % <offset> - push ptr value read from param in current scope
   2:    tPushUpLocalI     % <uplevels> <offset> - push int value read from local var in a parent static scope
   2:    tPushUpLocalB     % <uplevels> <offset> - push byte value read from local var in a parent static scope
   2:    tPushUpLocalP     % <uplevels> <offset> - push ptr value read from local var in a parent static scope
   2:    tPushUpParamI     % <uplevels> <offset> - push int value read from param in a parent static scope
   2:    tPushUpParamB     % <uplevels> <offset> - push byte value read from param in a parent static scope
   2:    tPushUpParamP     % <uplevels> <offset> - push ptr value read from param in a parent static scope
   2:    tPushConstI       % <int> - push int value on stack (NOTE, used for BOOLEAN too)
   2:    tPushAddrGlobal   % <offset> - push ptr to global var (same as tPushConstP)
   2:    tPushAddrLocal    % <offset> - push ptr to local var
   2:    tPushAddrParam    % <offset> - push ptr to formal param (used by method to see its param)
   2:    tPushAddrActual   % <offset> - push ptr to actual param, in actuals space (used by caller)
   2:    tPushAddrUpLocal  % <uplevels> <offset> - push ptr to local var in a parent static scope
   2:    tPushAddrUpParam  % <uplevels> <offset> - push ptr to formal param in a parent static scope
   2:    tFetchI           % pop ptr from stack, and push int value it points to
   2:    tFetchB           %    "      "      "     "     byte  "   "    "
   2:    tFetchP           %    "      "      "     "     ptr   "   "    "   
   2:    tAssignI          % assign int value on top of stack to addr under it (pop both)
   2:    tAssignB          %   "    byte   "    "   "  "   "    "    "   "   "
   2:    tAssignP          %   "    ptr    "    "   "  "   "    "    "   "   "
   2:    tCopy             % <#bytes> - copy bytes.  tos=src, 2nd=dest (pop 2)
   2:    tCastBtoI         % zero-extend uint8_t to int32_t
   2:    tCastItoB         % truncate int32_t to uint8_t
   2:    tIncI             % increment int value on top of expr stack
   2:    tDecI             % decrement int value on top of expr stack
   2:    tMultI            % multiply top two integers (replacing with result)
   2:    tDivI
   2:    tAddPI            % add ptr (2nd value) and int (top value), resulting in a ptr
   2:    tAddI
   2:    tSubI
   2:    tNegI             % top entry *= -1
   2:    tNot              % negate top boolean
   2:    tEqualI           % top two entries equal? (pop 2, push 1) (true=1)
   2:    tNotEqualI        %    NOTE, these all work for booleans too
   2:    tGreaterI         % 2nd entry greater than top entry? (pop 2, push answer)
   2:    tLessI  
   2:    tGreaterEqualI
   2:    tLessEqualI
   2:    tEqualP           % two two pointer values equal? (pop 2, push 1) (true=1)
   2:    tNotEqualP
   2:    tAllocActuals     % <#bytes> - make space on call stack for actual params (adjusting call stack sp)
   2:    tAllocActualsCdecl  % <#bytes> - starting a call to a cdecl method.  tcode still describes my own calling convention.
   2:    tFreeActuals      % <#bytes> - discard space on call stack allocated by tAllocActuals
   2:    tCall             % <label#>
   2:    tCallCdecl        % <label#> - call a method using native (C) calling convention. Only supported for extern labels.
   2:    tReturn
   2:    tEnter            % <#bytes> - start a stack frame on the call stack, reserving #bytes of local variable space
   2:    tJump             % <label#>
   2:    tJumpTrue         % <label#>  (pops top of stack, jumps if true)
   2:    tJumpFalse        % <label#>  (pops top of stack, jumps if false)
   2:    tLabel            % <label#> - define label# at the current address
   2:    tLabelAlias       % <label#> <aliasToLabel#> - defines label to be an alias of another label
   2:    tLabelExtern      % <label#> <offsetToStrLit> - defines label to mean an extern symbol, whose name is in global data
   2:    tWriteI           % for writeln : write integer on tos, pop
   2:    tWriteBool        %  "     "    : write TRUE/FALSE, pop
   2:    tWriteChar        %  "     "    : write char, pop
   2:    tWriteStr         %  "     "    : write string whose addr is on tos, pop
   2:    tWriteP           %  "     "    : write ptr var whose addr is on tos, pop
   2:    tWriteEnum        %  "     "    : write enum name.  Name table on tos, value under it, pop both
   2:    tWriteCR          %  "     "    : write cr
      
      %  Other:
      
   2:    tSpace            % emit a hole, to be patched later
   2:    ;
      
   2: error:
   2:    eBadStatement
   2:    eNotConst
   2:    eNotType
   2:    eNotOrdinalType
   2:    eNotVar
   2:    eNotIntVar
   2:    eNotValue
   2:    eNotInteger
   2:    eNotBoolean
   2:    eNotPointer
   2:    eNotArray
   2:    eNotRecord
   2:    eNotRecordField
   2:    eTooManySubscripts
   2:    eTypeMismatch
   2:    eMissingParameter
   2:    eNotImplemented
   2:    eNotAllowed
   2:    eNotInALoop
   2:    eRecordEmpty
   2:    eNotCurrentFunction
   2:    eAlreadyDefined
   2:    eOnlyOneVarCanBeInitialized
   2:    eExternalMethodCannotBeNested
   2:    eCantFindUnitFile
   2:    eInternalScopeMismatch
   2:    eEnumValueNotAscending
   2:    eUsedButNotDefined
   2:    eCantUsePredSuccOnEnumWithValueGaps
   2:    ;
      
   2: include 'pascal_schema.ssl'
      
      % Generated automatically by schema
      
   2: type node_type:
   2: 	nINVALID
   2: 	Object
   2: 	nWorkspace
   2: 	nModule
   2: 	nProgram
   2: 	nUnit
   2: 	nUnitImpl
   2: 	nScope
   2: 	nDeclaration
   2: 	nIdent
   2: 	nUnitRef
   2: 	nMethod
   2: 	nProc
   2: 	nFunc
   2: 	nBuiltInFunc
   2: 	nBuiltInProc
   2: 	nConst
   2: 	nEnumValue
   2: 	nTypeDecl
   2: 	nVar
   2: 	nGlobalVar
   2: 	nLocalVar
   2: 	nRecordField
   2: 	nParam
   2: 	nTypedConst
   2: 	nLabel
   2: 	nType
   2: 	nFileType
   2: 	nIntegerType
   2: 	nByteType
   2: 	nBooleanType
   2: 	nBooleanCFType
   2: 	nCharType
   2: 	nStringType
   2: 	nPointerType
   2: 	nArrayType
   2: 	nSubrangeType
   2: 	nRecordType
   2: 	nEnumType
   2: 	nSetType
   2: 	;
      
   2: type node_attribute:
   2: 	qINVALID
   2: 	qUnits
   2: 	qProgram
   2: 	qGlobalSize
   2: 	qIdent
   2: 	qUsedUnits
   2: 	qChildScope
   2: 	qMainRoutineScope
   2: 	qImpl
   2: 	qPublicScope
   2: 	qPrivateScope
   2: 	qInitLabel
   2: 	qFinalLabel
   2: 	qInitRoutineScope
   2: 	qLevel
   2: 	qDecls
   2: 	qExtends
   2: 	qSize
   2: 	qAllocMode
   2: 	qInitCode
   2: 	qParentScope
   2: 	qType
   2: 	qValue
   2: 	qParams
   2: 	qBodyDefined
   2: 	qExternal
   2: 	qExternalName
   2: 	qCdecl
   2: 	qUsed
   2: 	qOldParams
   2: 	qOldType
   2: 	qResultOffset
   2: 	qNameOffset
   2: 	qInOut
   2: 	qDefined
   2: 	qPointerType
   2: 	qBaseType
   2: 	qIndexType
   2: 	qLow
   2: 	qHigh
   2: 	qScope
   2: 	qNameTable
   2: 	qHasGap
   2: 	;
      
      
   2: type Node:     % A pointer to a node in the schema database (symbol database)
   2:    Null = 0
   2:    ;
      
   2: type NodeIter:   % An iterator over nodes in a list, in the schema database
   2:    NullIter = 0
   2:    ;
      
   2: type NodeVec:  % A pointer to a vector of Node.  See mechanism node_vec_mech
   2:    NullVec = 0
   2:    ;
      
   2: type boolean:
   2:    false    = 0
   2:    true     = 1;
      
      % intrinsic types & type constructs
      
   2: type typ:
   2:    tyNone     = 0    % in ptrTyp field of TT, means no ptr to type defined
   2:    tyInteger
   2:    tyBoolean
   2:    tyChar
   2:    tyString
   2:    tyFile            % tyInteger..tyFile are scalars (types on their own)
   2:    tyPointer         % following are type constructor classes...
   2:    tyArray           %   (they are not type#'s)
   2:    tyRecord
   2:    tyParams          % like record; a collection of proc/func params
   2:    tySet;
      
   2: type Label:
   2:    labelNull = 0;
      
      % An output code stream.
   2: type Code:
   2:    codeNull = 0
   2:    codeDefault = 1
   2:    ;
      
      % A string
   2: type String:
   2:    stringNull = 0
   2:    ;
      
      % allocation modes for oScopeBegin
   2: type AllocMode:
   2:    allocGlobal = 0  % allocate from global data
   2:    allocDown        % allocate down the stack
   2:    allocUp          % allocate up the stack
   2:    ;
      
      % Some general schema node operations.
      % node_type and node_attribute are defined in generated file pascal_schema.ssl included above.
      %
   2: mechanism node_mech:
   2:     oNodeNew (node_type) >> Node         % create new node
   2:     oNodeSet (Node, node_attribute, Node)   % set Node attribute of node
   2:     oNodeSetString (Node, node_attribute, String)
   2:     oNodeSetInt (Node, node_attribute, int) % set int attribute of node
   2:     oNodeSetBoolean (Node, node_attribute, boolean)
   2:     oNodeSetLabel( Node, node_attribute, Label )  % set Label attribute of node
   2:     oNodeSetCode( Node, node_attribute, Code )    % set Code attribute of node
   2:     oNodeAddLast( Node, node_attribute, Node value )  % append to a List attribute of node
   2:     oNodeGet (Node, node_attribute) >> Node    % get Node attribute of node
   2:     oNodeGetString (Node, node_attribute) >> String
   2:     oNodeGetInt (Node, node_attribute) >> int  % get int attribute of node
   2:     oNodeGetBoolean (Node, node_attribute) >> boolean  % get int attribute of node
   2:     oNodeGetLabel (Node, node_attribute) >> Label      % get Label attribute of node
   2:     oNodeGetCode (Node, node_attribute) >> Code        % get code stream attribute of node
   2:     oNodeNull (Node) >> boolean          % is node null?
   2:     oNodeFind (Node, node_attribute listAttr, node_attribute valueAttr, int value) >> Node  % find node with value in list
   2:     oNodeGetIter (Node, node_attribute) >> NodeIter   % get an iterator over nodes in a List attribute
   2:     oNodeGetIterLast (Node, node_attribute) >> NodeIter  % get an iterator over nodes in a List, starting at last
   2:     oNodeIterValue (NodeIter) >> Node             % the node that iter is referring to (NodeNull if no more nodes)
   2:     oNodeIterNext (inout NodeIter)                % advance iterator through list
   2:     oNodeIterPrev (inout NodeIter)                % advance iterator backwards through list
   2:     oNodeType (Node) >> node_type        % return node type of node
   2:     oNodeEqual (Node, Node) >> boolean   % compare two nodes for equality
                                               % (i.e. same node, not just same contents)
   2:     ;
      
      
      % Manipulate a temporary vector of Node
      %
   2: mechanism node_vec_mech:
   2:     oNodeVecNew >> NodeVec
   2:     oNodeVecDelete( NodeVec nv )
   2:     oNodeVecAppend( NodeVec nv, Node n )
   2:     oNodeVecSize( NodeVec nv ) >> int                % how many elements
   2:     oNodeVecElement( NodeVec nv, int idx ) >> Node   % element at index idx (0..size-1)
   2:     ;
      
      
      
   2: mechanism emit_mech:
   2:     oEmitInt( int )              % emit int into the generated code
   2:     oEmitLabel( Label )
   2:     oEmitCode( Code )            % append a code stream to the current code stream
   2:     Here >> int                  % current address in the generated code
                                       %   (only usable in the default code stream)
   2:     oPatch( int addr, int val )  % patch an int into address in the generated code
                                       %   (only usable in the default code stream)
   2:     ;
      
   2: mechanism math:
   2:     inc (inout int)
   2:     dec (inout int)
   2:     negate (int) >> int
   2:     add( int x, int y ) >> int
   2:     subtract( int x, int y ) >> int     % x - y
   2:     multiply( int x, int y ) >> int     % x * y
   2:     equal( int x, int y ) >> boolean
   2:     equal_zero (int) >> boolean
   2:     equal_node( Node, Node ) >> boolean
   2:     equal_string( String, String ) >> boolean
   2:     equal_node_type (node_type, node_type) >> boolean     % Want equal_<type> for every type
   2:     equal_label( Label, Label ) >> boolean
   2:     equal_code( Code, Code ) >> boolean
   2:     greater( int x, int y ) >> boolean
   2:     oMININT >> int    % the minimum 32-bit integer.
   2:     oMAXINT >> int    % the maximum 32-bit integer.
   2:     ;
      
   2: mechanism more_builtins:      % These should be built-in SSL operations
   2:     TOKEN_VALUE >> int        % value of just accepted token, e.g. IntLit token
   2:     LAST_ID >> int            % id number of last accepted identifier
   2:     ID_STRING( int id ) >> String       % text name of identifier with given id
   2:     CURRENT_STRLIT >> String            % text value of just-accepted string literal
   2:     ;
      
   2: mechanism workspace_mech:
   2:     oWorkspaceNew >> Node
   2:     ;
      
   2: mechanism scope_mech:
   2:     oScopeBegin( int level, AllocMode )  % create a new scope. Subsequent declarations will go here.
                                               %  level = static scope depth (0 = globals)
   2:     oScopeEnter( Node scope )            % enter an existing scope.
   2:     oScopeEnd                            % end current scope. Subsequent declarations will go to previous scope.
   2:     oScopeCurrent >> Node                % returns current scope
   2:     oScopeDeclare( Node decl )           % add declaration to current scope.
   2:     oScopeDeclareAlloc( Node decl )      % add declaration to current scope, and allocate space according to its type
   2:     oScopeAllocType( Node theType ) >> int   % allocate space for type in current scope, and return its address
   2:     oScopeAlloc( int size, int align ) >> int % allocate bytes, with given alignment in bytes 
   2:     oScopeFind >> Node                   % find declaration of last accepted identifier.  Returns Null if not found.
   2:     oScopeFindRequire >> Node            % find declaration of last accepted identifier.  Error if not found.
   2:     oScopeFindInCurrentScope >> Node     % find declaration of last accepted identifier, only within the current scope.  Null if not found.
   2:     oScopeFindRequireInScope( Node scope ) >> Node  % find decl of last accepted identifier, only within the given scope.  Error it not found.
   2:     ;
      
   2: mechanism type_mech:
   2:     oTypeAdd( Node node )     % add the given nType to the type table
   2:     ;
      
   2: mechanism type_stack_mech:
   2:     oTypeSPush( Node node )
   2:     oTypeSPop
   2:     oTypeSTop >> Node
   2:     oTypeSNodeType >> node_type          % node_type of the node on top of type stack, skipping subranges
   2:     ;
      
      
   2: mechanism id_mech:
          % adds a predefined id to the scanner's id table, and returns the id code
   2:     oIdAdd_File >> int
   2:     oIdAdd_Integer >> int
   2:     oIdAdd_Boolean >> int
   2:     oIdAdd_Char >> int
   2:     oIdAdd_Byte >> int
   2:     oIdAdd_String >> int
   2:     oIdAdd_True >> int
   2:     oIdAdd_False >> int
   2:     oIdAdd_Ord >> int
   2:     oIdAdd_Chr >> int
   2:     oIdAdd_Pred >> int
   2:     oIdAdd_Succ >> int
   2:     oChangeIntLitToLabelIdent    % change current token from pIntLit to pIdent "_label_<intlit>"
   2:     ;
      
      
      
   2: mechanism label_mech:
   2:    oLabelNew >> Label
   2:    ;
      
   2: mechanism code_mech:
   2:    oCodeNew >> Code         % create a new empty code stream
   2:    oCodePush( Code )        % change the current output code stream to the given one
   2:    oCodePop                 % restore the current code stream to the previous one
   2:    ;
      
   2: mechanism include_mech:
   2:    oIncludeUnitFile( int id ) >> boolean  % search for <unit>.pas and include it.
                                                % returns false if can't find.
   2:    oIncludeEnd              % stop including the current file
   2:    ;
      
      
   2: mechanism count :
   2:    oCountPush(int)          % start a new counter, with initial value
   2:    oCountInc
   2:    oCountDec
   2:    oCountIsZero >> boolean
   2:    oCountPop;
      
      
   2: mechanism value :              % value stack, to calc. const expr's
   2:    oValuePush(int)             % push an explicit int lit
   2:    oValueNegate                % negate top value
   2:    oValueTop >> int            % get top value on value stack
   2:    oValuePop;
      
   2: mechanism string :
   2:    oStringAllocLit( String ) >> int      % alloc global space for strlit, return address
   2:    ;
      
      % track labels for the loop we're in, if any
   2: mechanism loop_mech:
   2:    oLoopPush( Label continueLabel, Label breakLabel )
   2:    oLoopContinueLabel >> Label
   2:    oLoopBreakLabel >> Label
   2:    oLoopPop
   2:    ;
      
      % for hacky debugging
   2: mechanism msg_mech:
   2:    oMsg( int num )             % print message "oMsg <num>"
   2:    oMsgTrace( int num )        % print message "oMsg <num>" followed by ssl traceback
   2:    oMsgNode( Node node )       % print node
   2:    oMsgNodeLong( Node node )   % print node with more detail
   2:    oMsgNodeVec( NodeVec vec )  % print node vec
   2:    ;
      
      
   2: rules
      
      % ----------------------------- Global Variables ----------------------------
      
   2: Node    workspace              % root of database
   2: Node    globalScope            % scope for globals in the current module
   2: Node    initScope              % scope for temporaries global var init,
                                     % and program main stmt / unit initialization stmts
      % built-in nTypes
   2: Node    FileType
   2: Node    IntegerType
   2: Node    BooleanType
   2: Node    BooleanCFType
   2: Node    CharType
   2: Node    ByteType
   2: Node    StringType
      
      % nBuiltInFunc
   2: Node    BuiltIn_Ord
   2: Node    BuiltIn_Chr
   2: Node    BuiltIn_Pred
   2: Node    BuiltIn_Succ
      
      
      % -------------------------- Forward Declarations -------------------------
      
   2: Block( node_type varNodeType, Label labelForBody );
   2: BlockDecls( node_type varNodeType );
   2: BlockStmt( Label labelForBody, Node varScope, boolean isMain );
   2: VarDecl( node_type varNodeType );
   2: newType( node_type nt, int size ) >> Node;
   2: newIdent( node_type nt, int id ) >> Node;
   2: EmitValue( Node decl );
   2: TypeRef( out Node theType );
   2: EnumTypeRef( out Node resultType );
   2: PointerTypeTo( Node theType ) >> Node;
   2: OrdinalLow( Node theType ) >> int;
   2: OrdinalHigh( Node theType ) >> int;
   2: AssignStmt( Node decl );
   2: BooleanExprControlFlow( out Label falseLabel );
   2: ExprAllowCF( out Label falseLabel );
   2: BoolExprAllowCF( out Label falseLabel );
   2: BoolTermAllowCF( out Label falseLabel );
   2: BoolFactorAllowCF( out Label falseLabel );
   2: ArithExprAllowCF( out Label falseLabel );
   2: TermAllowCF( out Label falseLabel );
   2: FactorAllowCF( out Label falseLabel );
   2: PrimaryAllowCF( out Label falseLabel );
      
   2: VarExpr( Node decl );
   2: LValueVar( Node decl );
   2: IncVar( Node decl );
   2: DecVar( Node decl );
      
   2: CFToVal( inout Label falseLabel );
   2: ValToCF( out Label falseLabel );
      
   2: DeclLevel( Node decl ) >> int;
   2: DeclUpLevels( Node decl ) >> int;
      
      % ----------------------------- Declarations ----------------------------
      
   2: Program:
   4:    Node t
      
   4:    workspace = oWorkspaceNew
      
         % root scope is used for builtins e.g. Integer,
         % and is a parent to any used units, and the program's own global scope.
   9:    oScopeBegin( 0, allocGlobal )
  18:    Node rootScope = oScopeCurrent
      
  23:    @installBuiltIns
      
         % Start by calling the main program routine.
      
         % This dummy call to main needs to look like a normal method itself,
         % so jit can align the stack properly.  So we need .tEnter,
         % and .tAllocActuals / .tFreeActuals.
  25:    .tEnter  oEmitInt( 0 )
  33:    Label mainLabel = oLabelNew
      
  38:    .tAllocActuals  oEmitInt( 0 )
  46:    .tCall  oEmitLabel( mainLabel )
  54:    .tFreeActuals  oEmitInt( 0 )
  62:    .tReturn
      
  64:    pProgram
  66:    pIdent
      
  68:    Node program = oNodeNew( nProgram )
  78:    oNodeSetInt( program, qIdent, LAST_ID )
  89:    oNodeSet( workspace, qProgram, program )
      
      
 101:    [
 101:       | '(' :
 103:          pIdent      % input, output files
      
 105:          t = @newIdent( nVar, LAST_ID )
 118:          oNodeSet( t, qType, FileType )
 130:          oScopeDeclareAlloc( t )
               % TO DO: I shouldn't declare the files in root scope.
               %        Should save them for program's global scope.
      
 136:          ','
 138:          pIdent
      
 140:          t = @newIdent( nVar, LAST_ID )
 153:          oNodeSet( t, qType, FileType )
 165:          oScopeDeclareAlloc( t )
      
 171:          ')'
 173:       | * :
 178:    ]
 178:    ';'
      
         % The uses clause may only appear once, immediately after the program declaration.
 180:    [
 180:       | pUses :  @UsesClause( program )
 189:       | * :
 194:    ]
 194:    @EnterUsedUnits( program )
      
         % Global scope for the program, below any used units.
 201:    oScopeBegin( 0, allocGlobal )
 210:    globalScope = oScopeCurrent
      
         % A new scope just for temporaries in the main routine
         % Create it up front, in case it's needed by variable initialization exprs.
         % But we won't stay in it here.
         % Note we say it extends the global scope, so that during main statement evaluation
         % any user labels declared in the global scope are considered to be part of the current scope.
 215:    oScopeBegin( 0, allocDown )
 224:    oNodeSet( oScopeCurrent, qExtends, globalScope )
 235:    initScope = oScopeCurrent
 240:    oNodeSet( program, qMainRoutineScope, initScope )
 252:    oScopeEnd
      
 253:    @BlockDecls( nGlobalVar )
      
      
 260:    oScopeEnter( initScope )
      
         % The block statement includes a stack frame, and enter/return,
         % even for the main routine.
         % That will be necessary for temporaries allocated in the main routine.
      
         % isMain means we'll generate calls to the unit init/final methods in here too.
         % Alternatively we could do that in a higher level method that calls main.
 266:    boolean isMain = true
 272:    @BlockStmt( mainLabel, globalScope, isMain )
      
 285:    oScopeEnd   % main routine scope
      
 286:    '.'
 288:    @CheckForUndefinedLabels
 290:    oScopeEnd   % global scope
 291:    @EndUsedUnits( program )   % used units scopes
 299:    ;
      
      
      % The uses clause is a list of units required by the user program or unit.
      % We will find and compile the named units (unless already loaded).
      % We do not make the unit interface visible to the user, the caller will do so later.
 299: UsesClause( Node user ):
 301:    {
 301:       pIdent
 303:       Node unit = @FindOrCompileUnit( LAST_ID )
 313:       [ equal_node( unit, Null )
 323:          | false :
 324:             oNodeAddLast( user, qUsedUnits, unit )
      
                  % Put a declaration in the current scope, naming the unit and pointing to it.
                  % This is to allow references to  <unit>.<identifier_in_unit>
 336:             Node unitRef = oNodeNew( nUnitRef )
 346:             oNodeSetInt( unitRef, qIdent, oNodeGetInt( unit, qIdent ) )
 365:             oNodeSet( unitRef, qPublicScope, oNodeGet( unit, qPublicScope ) )
 384:             oScopeDeclare( unitRef )
 390:          | * :
 395:       ]
 395:       [
 395:          | ',' :
 397:          | * :  >
 404:       ]
 404:    }   
 406:    ';'
 409:    ;
      
      
      % If the given decl is for an nUnitRef, the program is using syntax <unit>.<identifier>
      % Parse the rest of that to find the intended decl.
      %
 409: ResolveUnitRef( inout Node decl ):
 411:    [ oNodeType( decl )
 418:       | nUnitRef :
 419:          Node scope = oNodeGet( decl, qPublicScope )
 432:          '.'
 434:          pIdent
 436:          decl = oScopeFindRequireInScope( scope )
 446:       | * :
 451:    ];
      
      
 452: EnterUsedUnits( Node user ):
         % Make the used units' public scopes directly visible.
         % This is done after the units are all compiled, so they don't interfere with each other incorrectly.
         % Units later in the list have priority.
 454:    NodeIter unitIt = oNodeGetIter( user, qUsedUnits )
 467:    {
 467:       Node unit = oNodeIterValue( unitIt )
 477:       [ oNodeNull( unit )
 484:          | false :
 485:             oScopeEnter( oNodeGet( unit, qPublicScope ) )
 498:          | * :
 503:             >
 505:       ]
 505:       oNodeIterNext( unitIt )
 511:    }
 514:    ;
      
 514: EndUsedUnits( Node user ):
         % Leave the units' public scopes, so no longer visible.
 516:    NodeIter unitIt = oNodeGetIterLast( user, qUsedUnits )
 529:    {
 529:       Node unit = oNodeIterValue( unitIt )
 539:       [ oNodeNull( unit )
 546:          | false :
                  % Consistency check.  Make sure our scope enter / end have lined up correctly.
 547:             [ oNodeEqual( oScopeCurrent, oNodeGet( unit, qPublicScope ) )
 563:                | true :
 564:                | false :  #eInternalScopeMismatch
 568:             ]
 576:             oScopeEnd
 577:          | * :
 582:             >
 584:       ]
 584:       oNodeIterPrev( unitIt )
 590:    }
 593:    ;
      
      
 593: FindOrCompileUnit( int id ) >> Node:
         % We might have this unit loaded already
 595:    Node unit = oNodeFind( workspace, qUnits, qIdent, id )
 614:    [ equal_node( unit, Null )
 624:       | false :  >> unit
 628:       | * :
 633:    ]
      
         % If not, search for the source file on disk
 633:    boolean ok = oIncludeUnitFile( id )
 643:    [ ok
 646:       | false :  #eCantFindUnitFile  >> Null
 652:       | * :
 657:    ]
      
         % compile it, adding it into the workspace
         % then return it.
 657:    unit = @Unit
      
         % TO DO: ensure we are at pEof
         % end the include
 663:    oIncludeEnd
 664:    >> unit;
      
      
      
 668: Unit >> Node:
 670:    pUnit
 672:    pIdent
 674:    Node unit = oNodeNew( nUnit )
 684:    oNodeSetInt( unit, qIdent, LAST_ID )
 695:    Node unitImpl = oNodeNew( nUnitImpl )
 705:    oNodeSetInt( unitImpl, qIdent, LAST_ID )
 716:    oNodeSet( unit, qImpl, unitImpl )
 728:    ';'
      
         % mandatory sections
      
 730:    pInterface
 732:    [
 732:       | pUses :   @UsesClause( unit )
 741:       | * :
 746:    ]
 746:    @EnterUsedUnits( unit )
      
 753:    oScopeBegin( 0, allocGlobal )
 762:    oNodeSet( unit, qPublicScope, oScopeCurrent )
 773:    globalScope = oScopeCurrent
      
         % A scope for temporaries needed by variable initialization
 778:    oScopeBegin( 0, allocDown )
 787:    initScope = oScopeCurrent
 792:    oNodeSet( unit, qInitRoutineScope, initScope )
 804:    oScopeEnd
      
 805:    @UnitInterface( unit )
 812:    oScopeEnd  % interface scope
      
 813:    pImplementation
 815:    [
 815:       | pUses :   @UsesClause( unitImpl )
 824:       | * :
 829:    ]
 829:    @EnterUsedUnits( unitImpl )
         % re-enter interface scope after impl's uses.  interface still has priority.
 836:    oScopeEnter( oNodeGet( unit, qPublicScope ) )
         
 849:    oScopeBegin( 0, allocGlobal )
 858:    oNodeSet( unit, qPrivateScope, oScopeCurrent )
 869:    oNodeSet( oScopeCurrent, qExtends, oNodeGet( unit, qPublicScope ) )
 887:    globalScope = oScopeCurrent
 892:    @UnitImplementation( unit )
      
 899:    [
 899:       | pInitialization :  @UnitInitialization( unit, true )   % init routine with statements from init section
 911:       | * :                @UnitInitialization( unit, false )  % implicit init routine
 926:    ]
 926:    [
 926:       | pFinalization :  @UnitFinalization( unit, true )
 938:       | * :              @UnitFinalization( unit, false )   % implicit final routine, may be handy later
 953:    ]
 953:    pEnd  '.'
      
 957:    oScopeEnd  % impl scope
 958:    oScopeEnd  % interface scope
 959:    @EndUsedUnits( unitImpl )  % used units scopes
 966:    @EndUsedUnits( unit )
 973:    oNodeAddLast( workspace, qUnits, unit )
 985:    >> unit;
      
      
 989: UnitInterface( Node unit ):
 991:    {[
 991:       | pConst :     @ConstDecl
 995:       | pType :      @TypeDecl
 999:       | pVar :       @VarDecl( nGlobalVar )
            % label declaration not allowed in interface
      
1008:       | pProcedure :
1010:          Node decl = @ProcHeaderDecl
               % despite syntax diagrams, fpc does allow external clause on methods in unit interface,
               % even though this clause is an alternative for the body statement.
1016:          [
1016:             | pExternal :
1018:                @ExternalDecl( decl )
1025:                ';'
1027:             | * :
1032:          ]
      
1032:       | pFunction :
1034:          Node decl = @FuncHeaderDecl
1040:          [
1040:             | pExternal :
1042:                @ExternalDecl( decl )
1049:                ';'
1051:             | * :
1056:          ]
      
1056:       | * :          >
1071:    ]}
1074:    ;
      
1074: UnitImplementation( Node unit ):
1076:    @BlockDecls( nGlobalVar )
1084:    ;
      
      
1084: UnitInitialization( Node unit, boolean hasStmts ):
1086:    Label label = oLabelNew
1091:    .tLabel  oEmitLabel( label )
1099:    oNodeSetLabel( unit, qInitLabel, label )
      
1111:    int patchLS
1111:    .tEnter  patchLS = Here  .tSpace
      
         % insert any code for initialization of this unit's variables.
         
1120:    Node scope
1120:    Code initCode
      
1120:    scope = oNodeGet( unit, qPublicScope )
1133:    initCode = oNodeGetCode( scope, qInitCode )
1146:    oEmitCode( initCode )
1152:    oNodeSetCode( scope, qInitCode, codeNull )
      
1164:    scope = oNodeGet( unit, qPrivateScope )
1177:    initCode = oNodeGetCode( scope, qInitCode )
1190:    oEmitCode( initCode )
1196:    oNodeSetCode( scope, qInitCode, codeNull )
      
1208:    oScopeEnter( oNodeGet( unit, qInitRoutineScope ) )
      
1221:    [ hasStmts
1224:       | true :     
1225:          @Statement
1227:          {[
1227:             | ';' :  @Statement
1231:             | * :    >
1238:          ]}
1240:       | * :
1245:    ]
      
1245:    .tReturn
      
1247:    int localSpace = oNodeGetInt( oScopeCurrent, qSize )
1259:    oPatch( patchLS, localSpace )
1268:    oScopeEnd   % init routine scope, for temporaries
1270:    ;
      
      
1270: UnitFinalization( Node unit, boolean hasStmts ):
1272:    Label label = oLabelNew
1277:    .tLabel  oEmitLabel( label )
1285:    oNodeSetLabel( unit, qFinalLabel, label )
      
1297:    int patchLS
1297:    .tEnter  patchLS = Here  .tSpace
      
         % final routine scope, for temporaries
1306:    oScopeBegin( 0, allocDown )
      
1315:    [ hasStmts
1318:       | true :     
1319:          @Statement
1321:          {[
1321:             | ';' :  @Statement
1325:             | * :    >
1332:          ]}
1334:       | * :
1339:    ]
      
1339:    .tReturn
      
1341:    int localSpace = oNodeGetInt( oScopeCurrent, qSize )
1353:    oPatch( patchLS, localSpace )
1362:    oScopeEnd   % final routine scope, for temporaries
1364:    ;
      
      
1364: Block( node_type varNodeType, Label labelForBody ):
1366:    @BlockDecls( varNodeType )
1373:    @BlockStmt( labelForBody, oScopeCurrent, false )
1385:    @CheckForUndefinedLabels
1388:    ;
      
      
1388: BlockDecls( node_type varNodeType ):
1390:    {[
1390:       | pConst :     @ConstDecl
1394:       | pType :      @TypeDecl
1398:       | pVar :       @VarDecl( varNodeType )
1407:       | pLabel :     @LabelDecl
1411:       | pProcedure : @ProcDecl
1415:       | pFunction :  @FuncDecl
1419:       | * :          >
1436:    ]}
1438:    @CheckForUndefinedMethods
1441:    ;
      
      
      % were there any procedures or functions declared in this scope
      % that were never defined?
1441: CheckForUndefinedMethods:
         % TO DO
         % Note: disregard methods marked external
1444:    ;
      
      % were there any labels declared in the current scope, and used,
      % but never defined (as the prefix of a stement)?
      %
1444: CheckForUndefinedLabels:
1446:    NodeIter it = oNodeGetIter( oScopeCurrent, qDecls )
1458:    {
1458:       Node decl = oNodeIterValue( it )
1468:       [ oNodeNull( decl )
1475:          | false :
1476:          | * :  >
1483:       ]
1483:       [ oNodeType( decl )
1490:          | nLabel :
1491:             [ oNodeGetBoolean( decl, qDefined )
1501:                | false :
1502:                   [ oNodeGetBoolean( decl, qUsed )
1512:                      | true :    #eUsedButNotDefined  % TO DO: give the decl in the message
1515:                      | * :
1520:                   ]
1520:                | * :
1525:             ]
1525:          | * :
1530:       ]
1530:       oNodeIterNext( it )
1536:    }
1539:    ;
      
      
1539: InitializeUnits:
         % call init routine of each loaded unit, in the order they were loaded
         % (used directly or indirectly by the main program).
1541:    NodeIter it = oNodeGetIter( workspace, qUnits )
1554:    {
1554:       Node unit = oNodeIterValue( it )
1564:       [ oNodeNull( unit )
1571:          | true :  >
1574:          | false :
1576:             .tAllocActuals  oEmitInt( 0 )  % not sure I need this. maybe for stack alignment.
1584:             .tCall  oEmitLabel( oNodeGetLabel( unit, qInitLabel ) )
1599:             .tFreeActuals  oEmitInt( 0 )
1607:             oNodeIterNext( it )
1613:       ]
1621:    };
      
      
1624: FinalizeUnits:
1626:    NodeIter it = oNodeGetIterLast( workspace, qUnits )
1639:    {
1639:       Node unit = oNodeIterValue( it )
1649:       [ oNodeNull( unit )
1656:          | true :  >
1659:          | false :
1661:             .tAllocActuals  oEmitInt( 0 )  % not sure I need this. maybe for stack alignment.
1669:             .tCall  oEmitLabel( oNodeGetLabel( unit, qFinalLabel ) )
1684:             .tFreeActuals  oEmitInt( 0 )
1692:             oNodeIterPrev( it )
1698:       ]
1706:    };
      
      
      % Given the scope of vars in this block.
      % Usually it's the current scope, but it's a bit different for the main statement.
      %
1709: BlockStmt( Label labelForBody, Node varScope, boolean isMain ):
1711:    .tLabel  oEmitLabel( labelForBody )
      
         % Proc, func, and main routine all start with tEnter
         % to create a stack frame.  This will be used for temporaries
         % (and local vars in the case of proc, func).
      
1719:    int patchLS
1719:    .tEnter  patchLS = Here  .tSpace
      
         % If we're generating the program main method,
         % add in calls to the loaded units' initialization and finalization.
1728:    [ isMain
1731:       | true :  @InitializeUnits
1734:       | * :
1739:    ]
      
         % insert any code for initialization of this scope's variables
1739:    Code initCode = oNodeGetCode( varScope, qInitCode )
1752:    oEmitCode( initCode )
1758:    oNodeSetCode( varScope, qInitCode, codeNull )
      
1770:    @Statement
      
1772:    [ isMain
1775:       | true :  @FinalizeUnits
1778:       | * :
1783:    ]
      
1783:    .tReturn
      
1785:    int localSpace = oNodeGetInt( oScopeCurrent, qSize )
1797:    oPatch( patchLS, localSpace )
1807:    ;
      
      
      % modifers that may appear on a proc/function declaration.
      %
1807: MethodModifiers( Node decl ):
1809:    {[
1809:       | pCdecl :
1811:          oNodeSetBoolean( decl, qCdecl, true )
1823:          ';'
      
1825:       | * : >
1832:    ]}
1835:    ;
      
      
      % We need an initCode code stream for the given scope.
      % Create it if not present yet.  Return it.
      % (This will be used for variable initialization.)
      %
1835: GetOrCreateInitCode( Node scope ) >> Code:
1837:    Code initCode = oNodeGetCode( scope, qInitCode )
1850:    [ equal_code( initCode, codeNull )
1860:       | true :
1861:          initCode = oCodeNew
1866:          oNodeSetCode( scope, qInitCode, initCode )
1878:       | * :
1883:    ]
1883:    >> initCode;
      
      
      % external method resides in an external object file
      % (or in my system, the built-in runtime library).
      % The method has a label, as usual, which callers will use.
      % But we define that label with .tLabelExtern rather than .tLabel.
      %
      % Note, I'll hold off on issuing the .tLabelExtern until we see that
      % the external method is actually called.  Otherwise we'd fill each output file
      % with all the external method names in my included libraries, which seems dumb.
      %
      % Note this is fpc syntax.  I'm not sure about other Pascals.
      %
1887: ExternalDecl( Node decl ):
1889:    [ equal_zero( @DeclLevel( decl ) )
1901:       | false :  #eExternalMethodCannotBeNested
1904:       | * :
1909:    ]
1909:    oNodeSetBoolean( decl, qExternal, true )
1921:    [
1921:       | pStrLit :
               % that was the optional library name containing the method.
               % TO DO: I'm currently ignoring this.
1923:          [
1923:             | pName :
1925:                pStrLit
                     % that was the optional method name defined in that library,
                     % which might differ from the Pascal name.
1927:                oNodeSetString( decl, qExternalName, CURRENT_STRLIT )
1938:             | * :
1943:          ]
1943:       | * :
1948:    ]
1949:    ;
      
      
1949: ProcHeaderDecl >> Node:
1951:    pIdent
      
         % If we already have a forward declaration, we'll modify that decl
         % instead of creating a second symbol table entry.
         % (Alternatively could delete or hide the old entry.)
1953:    boolean redeclaring = false
1959:    Node decl = oScopeFindInCurrentScope
      
1964:    [ oNodeNull( decl )
1971:       | true :
               % first declaration
1972:          decl = @newIdent( nProc, LAST_ID )
1985:          oNodeSetLabel( decl, qValue, oLabelNew )
      
1996:       | false :
               % we already have a declaration.
               % Keep it, and its label.
1998:          redeclaring = true
2004:          [ oNodeGetBoolean( decl, qBodyDefined )
2014:             | true : #eAlreadyDefined
2017:             | * :
2022:          ]
2022:          [ oNodeGetBoolean( decl, qExternal )
2032:             | true : #eAlreadyDefined
2035:             | * :
2040:          ]
2040:          [ oNodeType( decl )
2047:             | nProc :
2048:             | * : #eAlreadyDefined   % wrong kind
2055:          ]
               % Move the existing param scope aside, so we can check that the
               % new one is consistent.  And, the body will want to see the new one
               % since the names might differ.
               % TO DO: If qOldParams already set, we have multiple forward decls,
               % which I believe is supposed to be an error.
2055:          oNodeSet( decl, qOldParams, oNodeGet( decl, qParams ) )
2074:          oNodeSet( decl, qParams, Null )
2086:    ]
      
2094:    int level = @ScopeLevel
2100:    boolean nested = greater( level, 0 )
2113:    inc( level )
2119:    oScopeBegin( level, allocUp )
2128:    Node paramScope = oScopeCurrent
      
         % A nested method has a hidden first param for the parent static scope.
         % This won't appear in the param decls list, just reserve space for it.
         % It's first so the static chain is always at a fixed offset from the frame pointer.
2133:    [ nested
2136:       | true :
2137:          int offset = oScopeAllocType( @PointerTypeTo( IntegerType ) )   % arbitrary ptr type
2152:       | * :
2157:    ]
      
2157:    @FormalArgDecl
2159:    oNodeSet( decl, qParams, paramScope )
2171:    oScopeEnd
2172:    ';'
      
2174:    [ redeclaring
2177:       | false : oScopeDeclare( decl )
2184:       | true :  % TO DO: check that qParams is consistent with qOldParams
2186:    ]
      
2194:    @MethodModifiers( decl )
2201:    >> decl;
      
      
2205: ProcDecl:
2207:    Node decl = @ProcHeaderDecl
      
         % Body may be a statement, "forward", "external".
         % Note, this syntax is based on FPC, and I'm not sure if other Pascals are similar.
         % FPC says that forward, external, cdecl, name, etc are not reserved words -
         % I think this means the user may declare other things with those names, but if so the
         % original meaning is lost.  I'll make them keywords for simplicity, for now
         % (just not too happy about "name").
      
2213:    [
2213:       | pForward :
               % Nothing to do.  We simply won't set qBodyDefined.
      
2215:       | pExternal : @ExternalDecl( decl )
      
2224:       | * :
               % Body statement
      
               % Enter the params scope again, so params are visible in body.
               % TO DO: Perhaps I could mark the scope read-only at this point.
2231:          Node paramScope = oNodeGet( decl, qParams )
2244:          oScopeEnter( paramScope )
      
               % Start scope for declarations within the proc
2250:          int level = oNodeGetInt( paramScope, qLevel )
2263:          oScopeBegin( level, allocDown )
2272:          oNodeSet( decl, qChildScope, oScopeCurrent )
      
2283:          Label label = oNodeGetLabel( decl, qValue )
2296:          @Block( nLocalVar, label )
2306:          oNodeSetBoolean( decl, qBodyDefined, true )
2318:          oScopeEnd
      
2319:          oScopeEnd  % paramScope
2320:    ]
2320:    ';';
      
      
      
2323: FuncHeaderDecl >> Node:
2325:    pIdent
      
         % If we already have a forward declaration, we'll modify that decl
         % instead of creating a second symbol table entry.
         % (Alternatively could delete or hide the old entry.)
2327:    boolean redeclaring = false
2333:    Node decl = oScopeFindInCurrentScope
      
2338:    [ oNodeNull( decl )
2345:       | true :
               % first declaration
2346:          decl = @newIdent( nFunc, LAST_ID )
2359:          oNodeSetLabel( decl, qValue, oLabelNew )
      
2370:       | false :
               % we already have a declaration.
               % Keep it, and its label.
2372:          redeclaring = true
2378:          [ oNodeGetBoolean( decl, qBodyDefined )
2388:             | true : #eAlreadyDefined
2391:             | * :
2396:          ]
2396:          [ oNodeType( decl )
2403:             | nFunc :
2404:             | * : #eAlreadyDefined   % wrong kind
2411:          ]
               % Move the existing param scope and return value aside,
               % so we can check that the new one is consistent.
               % And, the body will want to see the new one since the names might differ.
               % TO DO: If qOldParams already set, we have multiple forward decls,
               % which I believe is supposed to be an error.
2411:          oNodeSet( decl, qOldParams, oNodeGet( decl, qParams ) )
2430:          oNodeSet( decl, qParams, Null )
2442:          oNodeSet( decl, qOldType, oNodeGet( decl, qType ) )
2461:          oNodeSet( decl, qType, Null )
2473:    ]
      
2481:    int level = @ScopeLevel
2487:    boolean nested = greater( level, 0 )
2500:    inc( level )
2506:    oScopeBegin( level, allocUp )
2515:    Node paramScope = oScopeCurrent
      
         % A nested method has a hidden first param for the parent static scope.
         % This won't appear in the param decls list, just reserve space for it.
         % It's first so the static chain is always at a fixed offset from the frame pointer.
2520:    [ nested
2523:       | true :
2524:          int offset = oScopeAllocType( @PointerTypeTo( IntegerType ) )   % arbitrary ptr type
2539:       | * :
2544:    ]
      
2544:    @FormalArgDecl
2546:    oNodeSet( decl, qParams, paramScope )
      
2558:    ':'
      
2560:    Node theType
2560:    @TypeRef( theType )
2567:    oNodeSet( decl, qType, theType )
      
         % The function's param space gets an additional pointer,
         % which will point to a temporary in the caller's scope.
         % This pointer is essentially a VAR param, but I won't create an nParam for it.
      
2579:    Node ptrType = @PointerTypeTo( theType )
2590:    oNodeSetInt( decl, qResultOffset, oScopeAllocType( ptrType ) )
2606:    oScopeEnd
2607:    ';'
      
2609:    [ redeclaring
2612:       | false : oScopeDeclare( decl )
2619:       | true :  % TO DO: check that qParams is consistent with qOldParams
                      % and qType is consistent with qOldType
2621:    ]
      
2629:    @MethodModifiers( decl )
      
2636:    >> decl;
      
      
2640: FuncDecl:
2642:    Node decl = @FuncHeaderDecl
      
         % Body may be a statement, "forward", "external".
2648:    [
2648:       | pForward :
               % Nothing to do.  We simply won't set qBodyDefined.
      
2650:       | pExternal : @ExternalDecl( decl )
      
2659:       | * :
               % Body statement
      
               % Enter the params scope again, so params are visible in body.
               % TO DO: Perhaps I could mark the scope read-only at this point.
2666:          Node paramScope = oNodeGet( decl, qParams )
2679:          oScopeEnter( paramScope )
      
               % Start scope for declarations within the func
2685:          int level = oNodeGetInt( paramScope, qLevel )
2698:          oScopeBegin( level, allocDown )
2707:          oNodeSet( decl, qChildScope, oScopeCurrent )
      
2718:          Label label = oNodeGetLabel( decl, qValue )
2731:          @Block( nLocalVar, label )
2741:          oNodeSetBoolean( decl, qBodyDefined, true )
2753:          oScopeEnd
      
2754:          oScopeEnd  % paramScope
2755:    ]
2755:    ';';
      
      
2758: FormalArgDecl:
2760:    [
2760:       | '(' :
2762:          {
2762:             NodeVec decls = oNodeVecNew
2767:             Node decl
2767:             boolean isInOut = false
      
2773:             [
2773:                | pVar : isInOut = true
2781:                | * :
2786:             ]
      
2786:             {  pIdent
      
2788:                decl = @newIdent( nParam, LAST_ID )
2801:                oNodeSetBoolean( decl, qInOut, isInOut )
2813:                oNodeVecAppend( decls, decl )
      
2822:                [
2822:                   | ':' : >
2826:                   | ',' :
2828:                ]
2836:             }
      
2838:             Node theType
2838:             @TypeRef( theType )
      
                  % VAR param is declared with its given type, but allocated as a pointer.
2845:             Node allocType
2845:             [ isInOut
2848:                | true :   allocType = @PointerTypeTo( theType )
2860:                | * :      allocType = theType
2871:             ]
      
2871:             int i = 0
2877:             {[ equal( i, oNodeVecSize( decls ) )
2891:                | false :
2892:                   decl = oNodeVecElement( decls, i )
      
2905:                   oNodeSet( decl, qType, theType )
2917:                   oScopeDeclare( decl )
2923:                   oNodeSetInt( decl, qValue, oScopeAllocType( allocType ) )
2939:                   inc( i )
2945:                | * :
2950:                   >
2952:             ]}
      
2954:             oNodeVecDelete( decls )
      
2960:             [
2960:                | ')' : >
2964:                | ';' :
2966:             ]
2974:          }
2976:       | * :
2981:    ];
      
      
2982: ConstDecl:
2984:    {[
2984:       | pIdent :
2986:          [
2986:             | ':' :
2988:                @TypedConstDecl
2990:             | * :
2995:                @UntypedConstDecl
2997:          ]
2997:       | * :
3002:          >
3004:    ]};
      
      
      % Parse an untyped const declaration.
      % We've just accepted the identifier.
      %
3007: UntypedConstDecl:
3009:    Node decl = @newIdent( nConst, LAST_ID )
3022:    '='
      
3024:    @ConstExpr
         % TO DO: currently ConstExpr leaves int result on oValue stack
3026:    int val = oValueTop
3031:    oValuePop
3032:    oNodeSetInt( decl, qValue, val )
      
         % TO DO: different types.  Currently assumes int!
         % Untyped const decl is supposed to allow:
         %   ordinal types, set types, pointer types (but only Nil), real types, char, string.
3044:    oNodeSet( decl, qType, IntegerType )
      
3056:    oScopeDeclare( decl )
3062:    ';'
3065:    ;
      
      
      % Parse a typed const declaration.
      % We've just accepted the identifier and ':'
      %
3065: TypedConstDecl:
3067:    Node decl = @newIdent( nTypedConst, LAST_ID )
      
3080:    Node theType
3080:    @TypeRef( theType )
3087:    oNodeSet( decl, qType, theType )
      
         % TO DO: array and record consts are allocated in global memory,
         % with global offset stored as decl value.
         % Scalar consts are not allocated in memory, and their value is
         % stored directly as the decl value.
      
         % TO DO: skip subranges, similar to oTypeSNodeType.
3099:    [ oNodeType( theType )
3106:       | nBooleanType, nByteType, nCharType, nIntegerType, nEnumType:
               % Parse expression and store value in decl
3107:          '='
      
3109:          @ConstExpr
               % TO DO: currently ConstExpr leaves int result on oValue stack
3111:          int val = oValueTop
3116:          oValuePop
3117:          oNodeSetInt( decl, qValue, val )
3129:          oScopeDeclare( decl )
3135:          ';'
      
3137:       | nStringType, nFileType, nPointerType :
3139:          #eNotImplemented
      
3141:       | nArrayType, nRecordType :
               % Allocate global space, store address in decl.
               % Push into global scope init code stream (since we'll be issuing code
               % rather than creating static data, at the moment).
               % Parse expression and store in global memory.
3143:          oScopeEnter( globalScope )
3149:          int addr = oScopeAllocType( theType )
3159:          oScopeEnd
3160:          oCodePush( @GetOrCreateInitCode( globalScope ) )
3171:          oNodeSetInt( decl, qValue, addr )
3183:          '='
3185:          @TypedConstInit( theType, addr )
3195:          oCodePop
3196:          oScopeDeclare( decl )
3202:          ';'
3204:    ]
3229:    ;
      
      
      % Parse the initial value of a constant that's being stored in global memory.
      % (An array or record constant, and recursively all its elements.)
      % Given the type, and the address in global memory for the const value.
      % The caller has already pushed into the global init code stream.
      %
3229: TypedConstInit( Node theType, int addr ):
         % TO DO: need to write into global init code stream
         % which might not be current code stream (e.g. a const declared in a procedure)
         % Probably the caller should do that, since it also allocated the global memory.
      
         % TO DO: skip subranges, similar to oTypeSNodeTYpe
3231:    [ oNodeType( theType )
3238:       | nArrayType :
3239:          Node baseType = oNodeGet( theType, qBaseType )
3252:          Node indexType = oNodeGet( theType, qIndexType )
3265:          int low = @OrdinalLow( indexType )
3276:          int high = @OrdinalHigh( indexType )
3287:          int elementSize = oNodeGetInt( baseType, qSize )
      
3300:          '('
               % Loop over elements
3302:          int i = low
3308:          {
3308:             @TypedConstInit( baseType, addr )
3318:             [ equal( i, high )
3328:                | true : >
3331:                | false :
3333:             ]
3341:             ','
3343:             addr = add( addr, elementSize )
3356:             inc( i )
3362:          }
3364:          ')'
      
3366:       | nRecordType :
3368:          #eNotImplemented
3370:       | nBooleanType, nByteType, nCharType:
3372:          .tPushAddrGlobal  oEmitInt( addr )
3380:          @ConstExpr
3382:          .tPushConstI  oEmitInt( oValueTop )
3389:          oValuePop
3390:          .tAssignB
3392:       | nIntegerType, nEnumType:
3394:          .tPushAddrGlobal  oEmitInt( addr )
3402:          @ConstExpr
3404:          .tPushConstI  oEmitInt( oValueTop )
3411:          oValuePop
3412:          .tAssignI
3414:       | nStringType, nFileType, nPointerType :
3416:          #eNotImplemented
3418:    ]
3443:    ;
      
      
3443: TypeDecl:
3445:    {[
3445:       | pIdent :
3447:          Node decl = @newIdent( nTypeDecl, LAST_ID )
3460:          '='
3462:          Node theType
3462:          @TypeRef( theType )
3469:          oNodeSet( decl, qType, theType )
3481:          oScopeDeclare( decl )
3487:          ';'
3489:       | * :
3494:          >
3496:    ]};
      
3499: VarDecl( node_type varNodeType ):
3501:    {[
3501:       | pIdent :
3503:          NodeVec decls = oNodeVecNew
3508:          Node decl
3508:          {
3508:             decl = @newIdent( varNodeType, LAST_ID )
3521:             oNodeVecAppend( decls, decl )
3530:             [
3530:                | ',' :
3532:                   pIdent
3534:                | * :
3539:                   >
3541:             ]
3541:          }
3543:          ':'
3545:          Node theType
3545:          @TypeRef( theType )
      
3552:          int i = 0
3558:          {[ equal( i, oNodeVecSize( decls ) )
3572:             | false :
3573:                decl = oNodeVecElement( decls, i )
3586:                oNodeSet( decl, qType, theType )
3598:                oScopeDeclareAlloc( decl )
3604:                inc( i )
3610:             | * :
3615:               >
3617:          ]}
      
               % optional initialization
3619:          [
3619:             | '=' :
3621:                [ oNodeVecSize( decls )
3628:                   | 1 :
3629:                   | * :  #eOnlyOneVarCanBeInitialized
3636:                ]
      
                     % we need an initCode stream for this scope
3636:                Code initCode = @GetOrCreateInitCode( oScopeCurrent )
3646:                oCodePush( initCode )
      
                     % currently the global level has two scopes:
                     % the one for declarations e.g. vars and methods,
                     % and a second one for temporaries needed by the main block stmt.
                     % During evaluation of the init expr, we need to be in the 2nd scope
                     % in case the expression requires temporaries
                     % (so the temporaries get allocated in the right scope).
                     % TO DO: Maybe I should make the global scope the special case, instead.
3652:                boolean changedScope = false
3658:                [ equal_zero( @ScopeLevel )
3665:                   | true : oScopeEnter( initScope )
3672:                            changedScope = true
3678:                   | * :
3683:                ]
                     % generate assignment in initCode stream
3683:                @LValueVar( decl )
3690:                @Expr
3692:                @MatchTypes
3694:                @Assign
3696:                [ changedScope
3699:                   | true : oScopeEnd
3701:                   | * :
3706:                ]
3706:                oCodePop
                   
3707:             | * :
3712:          ]
      
3712:          oNodeVecDelete( decls )
3718:          ';'
3720:       | * :
3725:          >
3727:    ]};
      
      
      % Parse a list of label declarations.
      % We'll create a tcode label at declaration time, for each user label.
      % If the user label is an integer, we'll record it as _label_<int> in the decl.
      %
3730: LabelDecl:
3732:    {
3732:       Node decl
3732:       [
3732:          | pIdent :
3734:          | pIntLit :
                  % Replace token with identifier "_label_<intlit>"
3736:             oChangeIntLitToLabelIdent
3737:       ]
3745:       decl = @newIdent( nLabel, LAST_ID )
            % TO DO: ensure not already declared in this scope.
            %        Or maybe that can be part of oScopeDeclare.
3758:       Label label = oLabelNew
3763:       oNodeSetLabel( decl, qValue, label )
3775:       oScopeDeclare( decl )
3781:       [
3781:          | ',' :
3783:          | * :
3788:             >
3790:       ]
3790:    }
3792:    ';'
3795:    ;
      
      
      % Parse a type reference, returning the nType.
      % This will add types to the type table, as needed.
      %
      % Style question - at the moment I think callers look clearer if we use
      % an out param here, rather than a return value.
      %
3795: TypeRef( out Node resultType ):
3797:    [
3797:       | pIdent :           % previously named type (including intrinsics)
3799:          Node decl = oScopeFindRequire
3804:          @ResolveUnitRef( decl )
3811:          [ oNodeType( decl )
3818:             | nTypeDecl :
3819:                resultType = oNodeGet( decl, qType )
3832:             | * :
3837:                #eNotType
3839:                resultType = IntegerType
3845:          ]
         
3845:       | pArray :
3847:          '['
      
               % A multi-dimensional array is represented as a chain
               %    array [subrange1] of array [subrange2] of elementType
      
               % First, we build a vector of nArray's, each with one subrange as its index type,
               % but without setting the "of" type or size.
      
3849:          NodeVec dimensions = oNodeVecNew
      
3854:          {
                  % to do: probably should use general subrange parsing, incl minimal size value
                  %   In fact, supposed to parse ordinal_type here.  all ordinal types have a static low, high.
                  %   Not necessary to be a subrange.
      
3854:             Node subrange = oNodeNew( nSubrangeType )
                  % TO DO: currently assuming subrange of integer
3864:             oNodeSet( subrange, qBaseType, IntegerType )
      
                  % TO DO: currently ConstExpr leaves int result on oValue stack
3876:             @ConstExpr
3878:             oNodeSetInt( subrange, qLow, oValueTop )
3889:             oValuePop
3890:             '..'
3892:             @ConstExpr
3894:             oNodeSetInt( subrange, qHigh, oValueTop )
3905:             oValuePop
3906:             oNodeSetInt( subrange, qSize, 4 )   % maybe don't need
      
3918:             oTypeAdd( subrange )
      
3924:             Node a = oNodeNew( nArrayType )
3934:             oNodeSet( a, qIndexType, subrange )
      
3946:             oNodeVecAppend( dimensions, a )
                  % I'll hold off on adding 'a' to the type table since not fully formed yet
      
3955:             [
3955:                | ']' : >
3959:                | ',' :
3961:             ]
3969:          }
      
3971:          pOf
3973:          Node baseType
3973:          @TypeRef( baseType )
      
               % Work backwards through the dimensions,
               % hooking up the 'of' type and calculating the size.
               % At each iteration, baseType is the 'of' type.
      
3980:          int dim = oNodeVecSize( dimensions )
      
3990:          {
3990:              dec(dim)
      
3996:              Node a = oNodeVecElement( dimensions, dim )
      
4009:              oNodeSet( a, qBaseType, baseType )
4021:              Node subrange = oNodeGet( a, qIndexType )
4034:              int width = subtract( oNodeGetInt( subrange, qHigh ), oNodeGetInt( subrange, qLow ) )
4061:              inc( width )
4067:              oNodeSetInt( a, qSize, multiply( width, oNodeGetInt( baseType, qSize ) ) )
      
4093:              oTypeAdd( a )
4099:              baseType = a
      
4105:              [ equal_zero(dim)
4112:                  | true:  >
4115:                  | *:
4120:              ]
4120:          }
      
4122:          resultType = oNodeVecElement( dimensions, 0 )
4135:          oNodeVecDelete( dimensions )
      
4141:       | '^' :
4143:          Node theType
4143:          @TypeRef( theType )
4150:          resultType = @PointerTypeTo( theType )
      
4161:       | pRecord :
4163:          resultType = oNodeNew( nRecordType )
4173:          oScopeBegin( -1, allocUp )    % level is meaningless here
      
4182:          @VarDecl( nRecordField )
      
4189:          int size = oNodeGetInt( oScopeCurrent, qSize )
               % to do: padding
4201:          [ equal_zero( size )
4208:             | true : #eRecordEmpty
4211:             | * :
4216:          ]
      
4216:          pEnd
      
4218:          oNodeSet( resultType, qScope, oScopeCurrent )
4229:          oNodeSetInt( resultType, qSize, size )
4241:          oScopeEnd
4242:          oTypeAdd( resultType )
      
      
4248:       | '(' :
               % An enum type declaration.
4250:          @EnumTypeRef( resultType )
      
      
            % *** TO DO: following type constructors are not implemented *** 
4257:       | pSet :
4259:          pOf
4261:          Node theType
4261:          @TypeRef( theType )
4268:       | * :       % this works for cases except where expr starts with an id
4283:          @ConstExpr '..' @ConstExpr
4289:    ];
      
      
      % Parse an enum type.
      % We've already accepted the '('
      % Returns the new type.
      %
4290: EnumTypeRef( out Node resultType ):
      
4292:    resultType = oNodeNew( nEnumType )
4302:    int value = 0
4308:    int numValues = 0
4314:    boolean first = true
      
         % We'll declare the enum values in two scopes: the current scope, and a scope nested in the enum type.
         % That will let programs use either <val> or <enumType>.<val>
4320:    Node outerScope = oScopeCurrent
4325:    oScopeBegin( -1, allocUp )   % level is meaningless, and we won't use allocate
      
4334:    {
            % TO DO: assert that name not already seen in this scope, i.e. this enum.
            %  And possibly not in the outerScope either, since that probably wouldn't count as shadowing.
            %  It might be in some other higher/used scope.
4334:       pIdent
4336:       Node decl = @newIdent( nEnumValue, LAST_ID )
4349:       Node decl2 = @newIdent( nEnumValue, LAST_ID )
4362:       oNodeSet( decl, qType, resultType )
4374:       oNodeSet( decl2, qType, resultType )
      
            % build up name table, for i/o
4386:       int nameOffset = oStringAllocLit( ID_STRING( LAST_ID ) )
4399:       oNodeSetInt( decl, qNameOffset, nameOffset )
4411:       oNodeSetInt( decl2, qNameOffset, nameOffset )
4423:       [
4423:          | '=', ':=' :
4425:             @ConstExpr
                  % value must be ascending
                  % this obviously doesn't apply to the first value
4427:             [ equal_zero( numValues )
4434:                | false :
4435:                   [ greater( oValueTop, value )
4444:                      | false :   #eEnumValueNotAscending
4447:                      | * :
4452:                   ]
4452:                | * :
4457:             ]
4457:             [ equal( value, oValueTop )
4466:                | false :
                        % The values differ from 0..N-1.  pred/succ may not be used with this type.
4467:                   oNodeSetBoolean( resultType, qHasGap, true )
4479:                | * :
4484:             ]
4484:             value = oValueTop
4489:             oValuePop
4490:          | * :
4497:       ]
4497:       oNodeSetInt( decl, qValue, value )
4509:       oNodeSetInt( decl2, qValue, value )
4521:       oScopeDeclare( decl )
      
4527:       oScopeEnter( outerScope )
4533:       oScopeDeclare( decl2 )
4539:       oScopeEnd
      
4540:       inc( value )
4546:       inc( numValues )
4552:       [
4552:          | ',' :
4554:          | * :    >
4561:       ]
4561:    }
4563:    ')'
      
4565:    oNodeSet( resultType, qScope, oScopeCurrent )
4576:    oNodeSetInt( resultType, qSize, 4 )   % always integer sized
4588:    oScopeEnd
      
         % Finish creation of the name table
         %    struct {
         %      int    value;
         %      int    padding;
         %      char*  name;
         %    } table[ numValues + 1 ];
         %  final entry will have name == nullptr
         %
         % I'll need to generate init code, to store pointers in global data,
         % since I don't have a relocation mechanism for static data at the moment.
4589:    oCodePush( @GetOrCreateInitCode( globalScope ) )
4600:    oScopeEnter( globalScope )
4606:    int size = multiply( add( numValues, 1 ), 16 )
4626:    int addr = oScopeAlloc( size, 8 )
4639:    oScopeEnd
4640:    oNodeSetInt( resultType, qNameTable, addr )
         % loop over enum values
4652:    NodeIter it = oNodeGetIter( oNodeGet( resultType, qScope ), qDecls )
4672:    {
4672:       Node enumValue = oNodeIterValue( it )
4682:       [ oNodeNull( enumValue )
4689:          | true :  >
4692:          | * :
4697:       ]
4697:       .tPushAddrGlobal  oEmitInt( addr )
4705:       .tPushConstI  oEmitInt( oNodeGetInt( enumValue, qValue ) )
4720:       .tAssignI
4722:       addr = add( addr, 8 )
4735:       .tPushAddrGlobal  oEmitInt( addr )
4743:       .tPushAddrGlobal  oEmitInt( oNodeGetInt( enumValue, qNameOffset ) )
4758:       .tAssignP
4760:       addr = add( addr, 8 )
4773:       oNodeIterNext( it )
4779:    }
         % final table entry
4781:    .tPushAddrGlobal  oEmitInt( addr )
4789:    .tPushConstI  oEmitInt( 0 )
4797:    .tAssignI
4799:    addr = add( addr, 8 )
4812:    .tPushAddrGlobal  oEmitInt( addr )
4820:    .tPushConstI  oEmitInt( 0 )
4828:    .tAssignP
4830:    addr = add( addr, 8 )
4843:    oCodePop
      
4844:    oTypeAdd( resultType )
4851:    ;
      
      
      % --------------------------- Const Expressions --------------------------
      
      % Constant expressions: currently, only literal integers or previously
      % named constant integers are supported, possibly with a negation.
      % Constant expressions are evaluated at compile time.
      
4851: ConstExpr:
4853:    [
4853:       | pIntLit :
4855:          oValuePush( TOKEN_VALUE )
4860:       | pIdent :
4862:          Node decl = oScopeFindRequire
4867:          @ResolveUnitRef( decl )
4874:          [ oNodeType( decl )
4881:             | nConst :
4882:                oValuePush( oNodeGetInt( decl, qValue ) )
4895:             | * :
4900:                #eNotConst
4902:                oValuePush( 0 )
4908:          ]
4908:       | pMinus :
4910:          @ConstExpr
4912:          oValueNegate
4913:    ];
      
      
      
      % ------------------------------ Expressions -----------------------------
      
      % There are two wrappers leading into expression parsing:
      %   Expr()
      %   BooleanExprControlFlow( out Label falseLabel )
      %
      % Expr always produces a value on the runtime expr stack,
      % and pushes its type on the type stack.
      %
      % BooleanExprControlFlow always generates control-flow code.
      % It does not push a value on the runtime expr stack.
      % It does not push a type on the type stack.
      % The control flow code ends up at Here if the expr is true,
      % and jumps to falseLabel if the expr is false.
      % This rule allocates falseLabel, and passes it back.
      % The caller will need to define its location.
      %
      % The internal methods of expr parsing may produce a mix of
      % values and control flow, depending on the operators seen.
      % We don't always do one or the other, hoping to be efficient for
      % cases like   "func_call( bool_var1, bool_var2 )"
      % as well as  "if bool_expr1 or bool_expr2 then ...".
      % If a subexpression rule produces control flow, it will allocate a
      % falseLabel and pass it back up.  And it will push the
      % result type as BooleanCFType, to distinguish from BooleanType
      % which corresponds with a boolean value on the expr stack.
      % 
      % Note that my expression parsing is broken into more levels than
      % grammars describe for Pascal precedence levels.  This follows my
      % original parser implementation.  I think my rationale was that
      % operators from the levels that I split up couldn't have been
      % mixed anyway, since they require different data types
      % (e.g. boolean vs int/real).  And splitting them up simplified
      % my code.  But, I should revisit this.
      %
      
      
      % Public entry point:
      %
      % Parse an expression, leaving a value on the runtime expr stack
      % and its type on the type stack.
      %
      % This rule does not export control flow (though it may generate
      % control flow internally for subexpressions).
      %
4924: Expr:
4926:    Label falseLabel = labelNull
      
4932:    @ExprAllowCF( falseLabel )
4939:    @CFToVal( falseLabel );
      
      
      % Public entry point:
      %
      % Parse a Boolean expression, producing control flow code rather than a value.
      % Does not leave a value on the runtime expr stack.
      % Does not leave a type on the type stack.
      %
      % If the expression is true, the code will fall through to the end (Here).
      % If the expression is false, the code will jump to the given falseLabel,
      % which this rule will allocate but not define the location for.
      % The caller must do so.
      %
4947: BooleanExprControlFlow( out Label falseLabel ):
4949:    @ExprAllowCF( falseLabel )
4956:    [ oTypeSNodeType
4958:       | nBooleanCFType :
4959:       | nBooleanType :
               % convert value to control flow
4961:          falseLabel = oLabelNew
4966:          .tJumpFalse  oEmitLabel( falseLabel )
4974:       | * :
4981:          #eNotBoolean
4983:    ]
4983:    oTypeSPop;
      
      
      % If the current expr result is control flow, convert it to a value.
      % falseLabel is the label that had been used by the control flow.
      % On return it will be set to labelNull.
      %
4985: CFToVal( inout Label falseLabel ):
4987:    [ oTypeSNodeType
4989:       | nBooleanCFType :
4990:          Label doneLabel = oLabelNew
4995:          .tPushConstI  oEmitInt( 1 )
5003:          .tJump  oEmitLabel( doneLabel )
5011:          .tLabel  oEmitLabel( falseLabel )
5019:          .tPushConstI  oEmitInt( 0 )
5027:          .tLabel  oEmitLabel( doneLabel )
5035:          oTypeSPop
5036:          oTypeSPush( BooleanType )
5042:          falseLabel = labelNull
5048:       | * :
5053:    ];
      
      
      % If the current expr result is boolean value, convert it to control flow.
      % falseLabel will be allocated by this rule and passed back.
      % The caller must define its location.
      %
5054: ValToCF( out Label falseLabel ):
5056:    [ oTypeSNodeType
5058:       | nBooleanType :
5059:          falseLabel = oLabelNew
5064:          .tJumpFalse  oEmitLabel( falseLabel )
5072:          oTypeSPop
5073:          oTypeSPush( BooleanCFType )
5079:       | * :
5084:    ];
      
      
      % Parse an expression.  It may produce a value on the expr stack,
      % or control flow, depending on what's seen in the expression.
      % Leaves the expression type on the type stack.
      %
      % If the expression produces control flow, the expression type will be
      % nBooleanCFType.  In this case, a true value falls through to Here,
      % and a false value jumps to falseLabel.  This rule will allocate falseLabel
      % and return it, but will not define its location; the caller must do so.
      %
      % If the expression produces a value, the value will be left on the
      % expression stack, and the type will be some type other than nBooleanCFType.
      % In this case, falseLabel is ignored.
      %
5085: ExprAllowCF( out Label falseLabel ):
5087:    @BoolExprAllowCF( falseLabel )
5094:    {[
5094:       | '=' :
5096:          @CFToVal( falseLabel )
5103:          @PromoteToIntOptional
5105:          @BoolExprAllowCF( falseLabel )
5112:          @CFToVal( falseLabel )
5119:          @PromoteToIntOptional
5121:          @MatchTypes
5123:          [ oTypeSNodeType
5125:             | nIntegerType, nEnumType, nBooleanType :  .tEqualI
5128:             | nPointerType :                .tEqualP
5132:             | nCharType, nStringType :      #eNotImplemented
5136:             | * :                           #eNotAllowed
5153:          ]
5153:          oTypeSPop
5154:          oTypeSPush( BooleanType )
      
5160:       | '<>' :
5162:          @CFToVal( falseLabel )
5169:          @PromoteToIntOptional
5171:          @BoolExprAllowCF( falseLabel )
5178:          @CFToVal( falseLabel )
5185:          @PromoteToIntOptional
5187:          @MatchTypes
5189:          [ oTypeSNodeType
5191:             | nIntegerType, nEnumType, nBooleanType :  .tNotEqualI
5194:             | nPointerType :                .tNotEqualP
5198:             | nCharType, nStringType :      #eNotImplemented
5202:             | * :                           #eNotAllowed
5219:          ]
5219:          oTypeSPop
5220:          oTypeSPush( BooleanType )
      
5226:       | '<' :
5228:          @CFToVal( falseLabel )
5235:          @PromoteToIntOptional
5237:          @BoolExprAllowCF( falseLabel )
5244:          @CFToVal( falseLabel )
5251:          @PromoteToIntOptional
5253:          @MatchTypes
5255:          [ oTypeSNodeType
5257:             | nIntegerType, nEnumType, nBooleanType :  .tLessI
5260:             | nCharType, nStringType :      #eNotImplemented
5264:             | * :                           #eNotAllowed
5279:          ]
5279:          oTypeSPop
5280:          oTypeSPush( BooleanType )
      
5286:       | '>' :
5288:          @CFToVal( falseLabel )
5295:          @PromoteToIntOptional
5297:          @BoolExprAllowCF( falseLabel )
5304:          @CFToVal( falseLabel )
5311:          @PromoteToIntOptional
5313:          @MatchTypes
5315:          [ oTypeSNodeType
5317:             | nIntegerType, nEnumType, nBooleanType :  .tGreaterI
5320:             | nCharType, nStringType :      #eNotImplemented
5324:             | * :                           #eNotAllowed
5339:          ]
5339:          oTypeSPop
5340:          oTypeSPush( BooleanType )
      
5346:       | '<=' :
5348:          @CFToVal( falseLabel )
5355:          @PromoteToIntOptional
5357:          @BoolExprAllowCF( falseLabel )
5364:          @CFToVal( falseLabel )
5371:          @PromoteToIntOptional
5373:          @MatchTypes
5375:          [ oTypeSNodeType
5377:             | nIntegerType, nEnumType, nBooleanType :  .tLessEqualI
5380:             | nCharType, nStringType :      #eNotImplemented
5384:             | * :                           #eNotAllowed
5399:          ]
5399:          oTypeSPop
5400:          oTypeSPush( BooleanType )
      
5406:       | '>=' :
5408:          @CFToVal( falseLabel )
5415:          @PromoteToIntOptional
5417:          @BoolExprAllowCF( falseLabel )
5424:          @CFToVal( falseLabel )
5431:          @PromoteToIntOptional
5433:          @MatchTypes
5435:          [ oTypeSNodeType
5437:             | nIntegerType, nEnumType, nBooleanType :  .tGreaterEqualI
5440:             | nCharType, nStringType :      #eNotImplemented
5444:             | * :                           #eNotAllowed
5459:          ]
5459:          oTypeSPop
5460:          oTypeSPush( BooleanType )
      
5466:       | * :
5481:          >
5483:    ]};
      
      
5486: BoolExprAllowCF( out Label falseLabel ):
5488:    Label trueLabel = labelNull
      
5494:    @BoolTermAllowCF( falseLabel )
5501:    {[
5501:       | pOr :
5503:          [ oTypeSNodeType
5505:             | nBooleanCFType :
                     % We are true here. Jump ahead to done
5506:                [ equal_label( trueLabel, labelNull )
5516:                   | true :  trueLabel = oLabelNew
5522:                   | * :
5527:                ]
5527:                .tJump  oEmitLabel( trueLabel )
5535:             | nBooleanType :
5537:                @ValToCF( falseLabel )
                     % We are true here. Jump ahead to done
5544:                [ equal_label( trueLabel, labelNull )
5554:                   | true :  trueLabel = oLabelNew
5560:                   | * :
5565:                ]
5565:                .tJump  oEmitLabel( trueLabel )
5573:             | * : #eNotBoolean
5582:          ]
5582:          oTypeSPop
      
               % false in previous term will jump here, to try this alternative term
5583:          .tLabel  oEmitLabel( falseLabel )
      
               % we'll get a new falseLabel for this term
5591:          falseLabel = labelNull
5597:          @BoolTermAllowCF( falseLabel )
      
5604:          [ oTypeSNodeType
5606:             | nBooleanCFType :
5607:             | nBooleanType :
5609:                @ValToCF( falseLabel )
5616:             | * : #eNotBoolean
5625:          ]
      
5625:          oTypeSPop
5626:          oTypeSPush( BooleanCFType )
      
5632:       | * :
5637:          >
5639:    ]}
      
         % any short-circuit trues jump here to the end
5641:    [ equal_label( trueLabel, labelNull )
5651:       | false :
5652:          .tLabel  oEmitLabel( trueLabel )
5660:       | * :
5665:    ]
5666:    ;
      
      
5666: BoolTermAllowCF( out Label falseLabel ):
5668:    Label overallFalseLabel = labelNull
      
5674:    @BoolFactorAllowCF( falseLabel )
5681:    {[
5681:       | pAnd :
5683:          [ oTypeSNodeType
5685:             | nBooleanCFType :
5686:             | nBooleanType :
5688:                @ValToCF( falseLabel )
5695:             | * :
5702:                #eNotBoolean
5704:          ]
5704:          oTypeSPop
      
               % We're going to have a different falseLabel for each term,
               % because we let each rule allocate its own (rather than accepting labels passed in).
               % And in this case we want them all to go to the same place,
               % to be determined by the caller.
               %
               % I'll allow for label aliases.  This will be more optimal than generating
               % multiple private false-handling code segments, that the true path would have to
               % jump around.  That would be hard to eliminate afterwards.
      
5705:          [ equal_label( overallFalseLabel, labelNull )
5715:             | true :
5716:                overallFalseLabel = oLabelNew
5721:                .tLabelAlias  oEmitLabel( falseLabel )  oEmitLabel( overallFalseLabel )
5735:                falseLabel = overallFalseLabel
5741:             | * :
5746:          ]
      
5746:          Label factorFalseLabel = labelNull
5752:          @BoolFactorAllowCF( factorFalseLabel )
      
5759:          [ oTypeSNodeType
5761:             | nBooleanCFType :
5762:             | nBooleanType :
5764:                @ValToCF( factorFalseLabel )
5771:             | * : #eNotBoolean
5780:          ]
5780:         .tLabelAlias  oEmitLabel( factorFalseLabel )  oEmitLabel( overallFalseLabel )
      
5794:       | * :
5799:          >
5801:    ]};
      
5804: BoolFactorAllowCF( out Label falseLabel ):
5806:    [
5806:       | pNot :
5808:          Label factorFalseLabel = labelNull
      
5814:          @BoolFactorAllowCF( factorFalseLabel )
5821:          [ oTypeSNodeType
5823:             | nBooleanCFType :
                     % We have control flow, and are sitting at the point that has value false.
5824:                falseLabel = oLabelNew
5829:                .tJump  oEmitLabel( falseLabel )
                     % The true path jumps here
5837:                .tLabel  oEmitLabel( factorFalseLabel )
      
5845:             | nBooleanType :
                     % I have a value.  I'll leave it as a value, rather than create control flow.
                     % See how this goes.
5847:                .tNot
      
5849:             | * : #eNotBoolean
5858:          ]
      
5858:       | * :
5863:          @ArithExprAllowCF( falseLabel )
5870:    ];
      
5871: ArithExprAllowCF( out Label falseLabel ):
5873:    @TermAllowCF( falseLabel )
5880:    {[
5880:       | pPlus :
5882:          @PromoteToIntPop
5884:          @TermAllowCF( falseLabel )  % actually not allowing CF, will be caught by type check
5891:          @PromoteToInt
5893:          .tAddI
5895:       | pMinus :
5897:          @PromoteToIntPop
5899:          @TermAllowCF( falseLabel )
5906:          @PromoteToInt
5908:          .tSubI
5910:       | * :
5917:          >
5919:    ]};
      
5922: TermAllowCF( out Label falseLabel ):
5924:    @FactorAllowCF( falseLabel )
5931:    {[
5931:       | pTimes :
5933:          @PromoteToIntPop
5935:          @FactorAllowCF( falseLabel )  % actually not allowing CF, will be caught by type check
5942:          @PromoteToInt
5944:          .tMultI
5946:       | pDivide :
5948:          @PromoteToIntPop
5950:          @FactorAllowCF( falseLabel )
5957:          @PromoteToInt
5959:          .tDivI
5961:       | * :
5968:          >
5970:    ]};
      
5973: FactorAllowCF( out Label falseLabel ):
5975:    [
5975:       | pPlus :
5977:          @PrimaryAllowCF( falseLabel )  % actually not allowing CF, will be caught by type check
               % TO DO: unary +/- is supposed to leave expression type as-is.
5984:          @PromoteToInt
5986:       | pMinus :
5988:          @PrimaryAllowCF( falseLabel )
               % TO DO: unary +/- is supposed to leave expression type as-is.
5995:          @PromoteToInt
5997:          .tNegI
5999:       | * :
6006:          @PrimaryAllowCF( falseLabel )
6013:    ];
      
6014: PrimaryAllowCF( out Label falseLabel ):
6016:    [
6016:       | pIntLit :
6018:          .tPushConstI  oEmitInt( TOKEN_VALUE )
6025:          oTypeSPush( IntegerType )
      
6031:       | pCharLit :
6033:          .tPushConstI  oEmitInt( TOKEN_VALUE )
6040:          oTypeSPush( CharType )
      
6046:       | '(' :
6048:          @ExprAllowCF( falseLabel )
6055:          ')'
      
6057:       | pStrLit :
6059:          int addr = oStringAllocLit( CURRENT_STRLIT )     % store in global data
6068:          .tPushAddrGlobal oEmitInt( addr )
               % TO DO: do we need to create a type with the literal's length?
6076:          oTypeSPush( StringType )
      
6082:       | pIdent :
6084:          Node decl = oScopeFindRequire
6089:          @ResolveUnitRef( decl )
6096:          Node theType
      
6096:          [ oNodeType( decl )
6103:             | nFunc :
6104:                @Call( decl )
      
6111:             | nBuiltInFunc :
6113:                @CallBuiltInFunc( decl )
      
6120:             | nConst, nEnumValue :
6122:                theType = oNodeGet( decl, qType )
6135:                oTypeSPush( theType )
6141:                [ oTypeSNodeType
6143:                   | nIntegerType, nEnumType, nBooleanType :
6144:                      .tPushConstI @EmitValue( decl )
6153:                   | * :
6162:                      #eNotImplemented
6164:                ]
      
6164:             | nGlobalVar, nLocalVar, nParam, nTypedConst :
6166:                @VarExpr( decl )
      
6173:             | * :
6192:                #eNotValue
6194:                oTypeSPush( IntegerType )
6200:          ]
      
6200:       | '@' :        % @var -- pointer to var
6202:          pIdent
      
6204:          Node decl = oScopeFindRequire
6209:          @ResolveUnitRef( decl )
6216:          Node theType
      
6216:          @LValueVar( decl )
      
               % The above leaves the pointed-to type on type stack.
               % Replace with ptr-to-<type>.
6223:          theType = oTypeSTop
6228:          oTypeSPop
6229:          Node ptrType = @PointerTypeTo( theType )
6240:          oTypeSPush( ptrType )
      
6246:       | * :
6261:          #eNotValue
6263:          oTypeSPush( IntegerType )
6269:    ];
      
      
      % Parse a variable expression, given the declaration of the
      % just-accepted identifier.
      % Leaves the value on the expression stack, and type on the type stack.
      %
6270: VarExpr( Node decl ):
6272:    Node theType = oNodeGet( decl, qType )
         % how many levels up the static scope? Will ignore for globals.
6285:    int uplevels = @DeclUpLevels( decl )
      
6296:    oTypeSPush( theType )
6302:    [ oTypeSNodeType
6304:       | nIntegerType, nEnumType :
6305:          [ oNodeType( decl )
6312:             | nGlobalVar, nTypedConst :   .tPushGlobalI  @EmitValue( decl )
6322:             | nLocalVar :
6324:                [ equal_zero( uplevels )
6331:                   | true :  .tPushLocalI  @EmitValue( decl )
6341:                   | * :     .tPushUpLocalI  oEmitInt( uplevels )  @EmitValue( decl )
6361:                ]
6361:             | nParam :
6363:                [ oNodeGetBoolean( decl, qInOut )
6373:                   | true :    % VAR param points to the var.  Auto dereference.
6374:                      [ equal_zero( uplevels )
6381:                         | true :  .tPushParamP  @EmitValue( decl )
6391:                         | * :     .tPushUpParamP  oEmitInt( uplevels )  @EmitValue( decl )
6411:                      ]
6411:                      .tFetchI
6413:                   | * :
6418:                      [ equal_zero( uplevels )
6425:                         | true :  .tPushParamI  @EmitValue( decl )
6435:                         | * :     .tPushUpParamI  oEmitInt( uplevels )  @EmitValue( decl )
6455:                      ]
6455:                ]
6455:          ]
      
6467:       | nBooleanType, nByteType, nCharType :
6469:          [ oNodeType( decl )
6476:             | nGlobalVar, nTypedConst :   .tPushGlobalB  @EmitValue( decl )
6486:             | nLocalVar :
6488:                [ equal_zero( uplevels )
6495:                   | true :  .tPushLocalB  @EmitValue( decl )
6505:                   | * :     .tPushUpLocalB  oEmitInt( uplevels )  @EmitValue( decl )
6525:                ]
6525:             | nParam :
6527:                [ oNodeGetBoolean( decl, qInOut )
6537:                   | true :    % VAR param points to the var.  Auto dereference.
6538:                      [ equal_zero( uplevels )
6545:                         | true :  .tPushParamP  @EmitValue( decl )
6555:                         | * :     .tPushUpParamP  oEmitInt( uplevels )  @EmitValue( decl )
6575:                      ]
6575:                      .tFetchB
6577:                   | * :
6582:                      [ equal_zero( uplevels )
6589:                         | true :  .tPushParamB  @EmitValue( decl )
6599:                         | * :     .tPushUpParamB  oEmitInt( uplevels )  @EmitValue( decl )
6619:                      ]
6619:                ]
6619:          ]
      
6631:       | nStringType, nFileType :
6633:          #eNotImplemented
      
6635:       | nPointerType :
6637:          [ oNodeType( decl )
6644:             | nGlobalVar, nTypedConst :   .tPushGlobalP @EmitValue( decl )
6654:             | nLocalVar :
6656:                [ equal_zero( uplevels )
6663:                   | true :  .tPushLocalP  @EmitValue( decl )
6673:                   | * :     .tPushUpLocalP  oEmitInt( uplevels )  @EmitValue( decl )
6693:                ]
6693:             | nParam :
6695:                [ oNodeGetBoolean( decl, qInOut )
6705:                   | true :    % VAR param points to the var.  Auto dereference.
6706:                      [ equal_zero( uplevels )
6713:                         | true :  .tPushParamP  @EmitValue( decl )
6723:                         | * :     .tPushUpParamP  oEmitInt( uplevels )  @EmitValue( decl )
6743:                      ]
6743:                      .tFetchP
6745:                   | * :
6750:                      [ equal_zero( uplevels )
6757:                         | true :  .tPushParamP  @EmitValue( decl )
6767:                         | * :     .tPushUpParamP  oEmitInt( uplevels )  @EmitValue( decl )
6787:                      ]
6787:                ]
6787:          ]
6799:          [
6799:             | '^' :             % dereferenced
6801:                oTypeSPop
6802:                oTypeSPush( oNodeGet( theType, qBaseType ) )
6815:                @LValueIndexes
6817:                @FetchVar
6819:             | * :               % just ptr value alone
6824:          ]
      
6824:       | nArrayType, nRecordType :
               % compound type
               % first, push addr of start of var
6826:          [ oNodeType( decl )
6833:             | nGlobalVar, nTypedConst :   .tPushAddrGlobal @EmitValue( decl )
6843:             | nLocalVar :
6845:                [ equal_zero( uplevels )
6852:                   | true :  .tPushAddrLocal  @EmitValue( decl )
6862:                   | * :     .tPushAddrUpLocal  oEmitInt( uplevels )  @EmitValue( decl )
6882:                ]
6882:             | nParam :
6884:                [ oNodeGetBoolean( decl, qInOut )
6894:                   | true :    % VAR param points to the var.  Auto dereference.
6895:                      [ equal_zero( uplevels )
6902:                         | true :  .tPushParamP  @EmitValue( decl )
6912:                         | * :     .tPushUpParamP  oEmitInt( uplevels )  @EmitValue( decl )
6932:                      ]
6932:                   | * :
6937:                      [ equal_zero( uplevels )
6944:                         | true :  .tPushAddrParam  @EmitValue( decl )
6954:                         | * :     .tPushAddrUpParam  oEmitInt( uplevels )  @EmitValue( decl )
6974:                      ]
6974:                ]
6974:          ]
               % modify addr for subscripts, field references, etc
6986:          @LValueIndexes
               % get final value
6988:          @FetchVar
6990:    ];
      
      
      % Addr of start of var is on expr stack; type is on type stack.
      % Replace expr stack with value of var.
      % (In the case of compound vars, this remains as the addr of the var).
      
7015: FetchVar:
7017:    [ oTypeSNodeType
7019:       | nIntegerType, nEnumType :  .tFetchI
7022:       | nBooleanType, nByteType, nCharType :  .tFetchB
7026:       | nStringType, nFileType :   #eNotImplemented
7030:       | nPointerType :             .tFetchP
7034:       | nArrayType, nRecordType :  % compound type; leave as addr
7036:    ];
      
      
      % Addr of start of var is already on run stack, and type is on type stack.
      % Read subscripts, record fields, etc, to get final addr on run stack, and final type
      % on type stack.
      
7061: LValueIndexes:
7063:    {[
7063:       | '[' :       @ArraySubscripts
7067:       | '.' :       @RecordFieldRef
7071:       | '^' :       @PointerDeref
7075:       | * :         >
7086:    ]};
      
7089: ArraySubscripts:
7091:    [ oTypeSNodeType
7093:       | nArrayType :
7094:       | * :       #eNotArray
7101:    ]
7101:    {
7101:       [ oTypeSNodeType
7103:          | nArrayType :
7104:          | * :    #eTooManySubscripts
7111:       ]
      
            % low subscript of this dimension
7111:       int low = @OrdinalLow( oNodeGet( oTypeSTop, qIndexType ) )
      
            % replace type stack with next dimension, or OF type
7128:       Node baseType
7128:       baseType = oNodeGet( oTypeSTop, qBaseType )
7140:       oTypeSPop
7141:       oTypeSPush( baseType )
      
7147:       @Expr
7149:       @RequireIntPop
            % adjust for low subscript
7151:       [ equal_zero( low )
7158:          | false :
7159:             .tPushConstI oEmitInt( low ) .tSubI
7169:          | * :
7174:       ]
      
            % multiply by element size
7174:       int size = oNodeGetInt( baseType, qSize )
7187:       [ equal( size, 1 )
7197:          | false :
7198:             .tPushConstI oEmitInt( size ) .tMultI
7208:          | * :
7213:       ]
      
            % update start address
7213:       .tAddPI
7215:       [
7215:          | ']' :  >
7219:          | ',' :
7221:       ]
7229:    };
      
      
7232: RecordFieldRef:
7234:    [ oTypeSNodeType
7236:       | nRecordType :
7237:       | * :    #eNotRecord
7244:    ]
7244:    oScopeEnter( oNodeGet( oTypeSTop, qScope ) )
7256:    pIdent
7258:    Node field = oScopeFindRequire
         % oScopeFind searches all open scopes, so make sure we found nRecordField
         % which could only be seen in the local scope we entered above.
7263:    [ oNodeType( field )
7270:       | nRecordField :
7271:       | * :   #eNotRecordField
7278:    ]
7278:    oScopeEnd
7279:    int offset = oNodeGetInt( field, qValue )
7292:    [ equal_zero( offset )
7299:       | false :
7300:          .tPushConstI oEmitInt( offset ) .tAddPI
7310:       | * :
7315:    ]
      
         % replace the type on the type stack, with the field type
7315:    oTypeSPop
7316:    oTypeSPush( oNodeGet( field, qType ) )
7330:    ;
      
      
      % ptr deref on left side, i.e. BEFORE addr of ptr var is on stack,
      %                              AFTER addr of thing pointed to is on stack
7330: PointerDeref:
7332:    [ oTypeSNodeType
7334:       | nPointerType :
7335:       | * :       #eNotPointer
7342:    ]
7342:    .tFetchP           % now addr on stack is addr of what we're pointing to
      
7344:    Node theType = oTypeSTop
7349:    oTypeSPop
7350:    oTypeSPush( oNodeGet( theType, qBaseType ) )
7364:    ;
      
      
      % The expr stack contains a value whose type is on top of the type stack.
      % Generate code to coerce the value to the type under it in the type stack
      % (pop the type stack, leaving only the desired type).
      % This is used for assignment.
      %
7364: CoerceType:
7366:    node_type nt = oTypeSNodeType
7371:    oTypeSPop
7372:    [ equal_node_type( nt, oTypeSNodeType )
7381:       | false :
               % Can we implicitly convert the value to the desired type?
7382:          [ oTypeSNodeType
7384:             | nIntegerType :
7385:                [ nt
7388:                   | nByteType :   .tCastBtoI  >>
7392:                   | * :
7397:                ]
7397:             | nByteType :
7399:                [ nt
7402:                   | nIntegerType :   .tCastItoB  >>
7406:                   | * :
7411:                ]
7411:             | * :
7418:          ]
7418:          #eTypeMismatch
7420:       | * :
7425:    ];
      
      
      % Called on first use of an extern method
      %
7426: DefineExternLabel( Node method ):
         % The extern name might be given explicitly, otherwise the pascal method name.
7428:    int strAddr
7428:    String externalName = oNodeGetString( method, qExternalName )
7441:    [ equal_string( externalName, stringNull )
7451:       | true :
7452:          strAddr = oStringAllocLit( ID_STRING( oNodeGetInt( method, qIdent ) ) )
7473:       | false :
7475:          strAddr = oStringAllocLit( externalName )
7485:    ]
7493:    .tLabelExtern  @EmitValue( method )  oEmitInt( strAddr )
7509:    ;
      
      
      % Parse a call, given an nProc or nFunc for the just-accepted identifier.
      % If a func, this will also generate the code to push the return value on the expr stack,
      % and push the return type on the type stack.
      %
7509: Call( Node method ):
      
         % Prior to first call, issue extern label for a called method.
         % I don't want to issue .tLabelExtern for unused methods, that seems inefficient.
7511:    [ oNodeGetBoolean( method, qExternal )
7521:       | true :
7522:          [ oNodeGetBoolean( method, qUsed )
7532:             | false :
                     % define the extern label on first use
7533:                @DefineExternLabel( method )
7540:             | * :
7545:          ]
7545:      | * :
7550:    ]
7550:    oNodeSetBoolean( method, qUsed, true )
      
         % If the method has a cdecl modifier, the back end will need to use the native
         % calling convention, instead of my own.  But, the convention varies by platform,
         % so the front end won't assume what it needs.  I'll still generate the normal tcode
         % that copies values into actuals space on the stack.
         % However, to help the back end, I will at least use a different instruction for the
         % allocation of the actuals space, and for the actual call.
         %
         % p.s. I only support cdecl on external methods, because I don't have a way
         % to let my own Pascal methods read params passed in with the cdecl calling convention.
         %
7562:    boolean cdecl = oNodeGetBoolean( method, qCdecl )
      
         % If this is a function, we will allocate a temporary
         % in the current scope, to hold the result value.
         % And pass a pointer to that temporary as an extra parameter.
7575:    Node resultType
7575:    int tempOffset
      
7575:    boolean isFunc = equal_node_type( oNodeType( method ), nFunc )
      
7592:    [ isFunc
7595:       | true :
7596:          resultType = oNodeGet( method, qType )
7609:          tempOffset = oScopeAllocType( resultType )
               % TO DO: we could manage temp allocation, so temp space can be reused
               %        by different code branches.
7619:       | * :
7624:    ]
         
      
7624:    Node paramScope = oNodeGet( method, qParams )
7637:    int actualsSize = oNodeGetInt( paramScope, qSize )
7650:    [ cdecl
7653:       | true : .tAllocActualsCdecl  oEmitInt( actualsSize )
7662:       | false :  .tAllocActuals  oEmitInt( actualsSize )
7672:    ]
      
         % If method is nested, it takes a hidden first parameter:
         % a pointer to the frame of the static scope in which the method is declared.
         % The location of a scope's frame is equivalent to offset 0 in the scope's locals space
         % (since local offsets are relative to the scope's frame pointer).
         %
         % The nested method may be in a higher scope (upLevels > 1),
         % or a sibling of the method we're in (upLevels = 1),
         % or an immediate child of the current method (upLevels = 0).
         %
         % To understand the upLevels computation, remember that a method's declaration
         % and its contents (variables, nested functions, and body statement)
         % are in two different scopes.
      
7680:    [ greater( @DeclLevel( method ), 0 )
7695:       | true :
7696:          .tPushAddrActual  oEmitInt( 0 )    % hidden param is at param offset 0
7704:          .tPushAddrUpLocal  oEmitInt( @DeclUpLevels( method ) )  oEmitInt( 0 )
7723:          .tAssignP
7725:       | * :
7730:    ]
      
      
7730:    NodeIter paramIter = oNodeGetIter( paramScope, qDecls )
7743:    Node param = oNodeIterValue( paramIter )
7753:    [
7753:       | '(' :
            
7755:          {
7755:             [ oNodeNull( param )
7762:                | true : >
7765:                | * :
7770:             ]
      
7770:             int offset = oNodeGetInt( param, qValue )
      
                  % Assign actual value to spot in actuals space
7783:             .tPushAddrActual oEmitInt( offset )
7791:             oTypeSPush( oNodeGet( param, qType ) )
      
7804:             [ oNodeGetBoolean( param, qInOut )
7814:                | true :   % A VAR param.
                                % The actual is a pointer to the value.
                                % The type on the type stack (pushed above) is for the pointed-to value.
      
7815:                           @LValueExpr
                                % Addr of the referenced variable is on the expr stack,
                                % type of the variable is on the type stack.
      
                                % Match types more exactly. It's not sufficient to be assign compatible
                                % since the method will be assigning to the actual using the param type.
                                % Maybe something like type contents must match, incl subrange bounds.
7817:                           @MatchTypes
      
7819:                           .tAssignP
      
7821:                | false :  @Expr
7825:                           @CoerceType
                                
                                % Assign to offset in actuals space
      
7827:                           [ oTypeSNodeType
7829:                              | nIntegerType, nEnumType : .tAssignI
7832:                              | nBooleanType, nByteType, nCharType :  .tAssignB
7836:                              | nStringType, nFileType :   #eNotImplemented
7840:                              | nPointerType :            .tAssignP
7844:                              | nArrayType, nRecordType :
                                       % compound types: copy value into actuals space
7846:                                  int size = oNodeGetInt( oTypeSTop, qSize )
7858:                                  .tCopy  oEmitInt( size )    % multi-word copy
7866:                           ]
7890:             ]
7898:             oTypeSPop
      
7899:             oNodeIterNext( paramIter )
7905:             param = oNodeIterValue( paramIter )
7915:             [ oNodeNull( param )
7922:                | true :  >
7925:                | false :
7927:             ]
      
7935:             ','
7937:          }
      
7939:          ')'
      
7941:       | * :
7946:    ]
      
7946:    [ oNodeNull( param )
7953:       | false :    #eMissingParameter
7956:       | * :
7961:    ]
      
7961:    [ isFunc
7964:       | true :
               % Pass result temp as an additional VAR parameter.
7965:          .tPushAddrActual oEmitInt( oNodeGetInt( method, qResultOffset ) )
7980:          .tPushAddrLocal  oEmitInt( tempOffset )
7988:          .tAssignP
7990:       | * :
7995:    ]
      
7995:    [ cdecl
7998:       | true :
7999:          .tCallCdecl  @EmitValue( method )
8008:       | false :
8010:          .tCall   @EmitValue( method )
8019:    ]
      
8027:    [ isFunc
8030:       | true :
               % push return value from temp
8031:          oTypeSPush( resultType )
      
8037:          [ oTypeSNodeType
8039:             | nIntegerType, nEnumType :   .tPushLocalI  oEmitInt( tempOffset )
8048:             | nBooleanType, nByteType, nCharType :   .tPushLocalB  oEmitInt( tempOffset )
8058:             | nStringType, nFileType :  #eNotImplemented
8062:             | nPointerType :   .tPushLocalP  oEmitInt( tempOffset )
8072:             | nArrayType, nRecordType :   % compound type: push address
8074:                                .tPushAddrLocal  oEmitInt( tempOffset )
8082:          ]
8106:       | * :
8111:    ]
         
8111:    .tFreeActuals  oEmitInt( actualsSize )
8120:    ;
      
      
      % Parse a call to a built-in function, identified by the just-accepted identifier.
      % This will also generate the code to push the return value on the expr stack,
      % and push the return type on the type stack.
      %
8120: CallBuiltInFunc( Node method ):
      
         % Ord(x)
8122:    [ oNodeEqual( method, BuiltIn_Ord )
8132:       | true :
               % parameter is any scalar type (including boolean, enum, char)
               % result is integer
8133:          '('
8135:          @Expr
8137:          [ oTypeSNodeType
8139:             | nIntegerType, nEnumType :
8140:             | nBooleanType, nByteType, nCharType :  .tCastBtoI
8144:             | * :  #eTypeMismatch
8159:          ]
8159:          oTypeSPop
8160:          oTypeSPush( IntegerType )
8166:          ')'
8168:          >>
8169:       | * :
8174:    ]
      
         % Chr(x)
8174:    [ oNodeEqual( method, BuiltIn_Chr )
8184:       | true :
               % parameter is integer
               % result is char
8185:          '('
8187:          @Expr
8189:          [ oTypeSNodeType
8191:             | nIntegerType :    .tCastItoB
8194:             | nByteType :
8196:             | * :  #eTypeMismatch
8205:          ]
8205:          oTypeSPop
8206:          oTypeSPush( CharType )
8212:          ')'
8214:          >>
8215:       | * :
8220:    ]
      
         % Pred(x)
8220:    [ oNodeEqual( method, BuiltIn_Pred )
8230:       | true :
               % parameter is any enum type, as long as it has values 0..N-1
               % result is the same enum type
8231:          '('
8233:          @Expr
8235:          [ oTypeSNodeType
8237:             | nEnumType :
                     % TO DO: does this skip past type aliases?
                     % TO DO: what if using pred/succ on a subrange type?
8238:                [ oNodeGetBoolean( oTypeSTop, qHasGap )
8247:                   | true :   #eCantUsePredSuccOnEnumWithValueGaps
8250:                   | * :
8255:                ]
8255:             | * :  #eTypeMismatch
8262:          ]
8262:          .tDecI
8264:          ')'
8266:          >>
8267:       | * :
8272:    ]
      
         % Succ(x)
8272:    [ oNodeEqual( method, BuiltIn_Succ )
8282:       | true :
               % parameter is any enum type, as long as it has values 0..N-1
               % result is the same enum type
8283:          '('
8285:          @Expr
8287:          [ oTypeSNodeType
8289:             | nEnumType :
                     % TO DO: does this skip past type aliases?
                     % TO DO: what if using pred/succ on a subrange type?
8290:                [ oNodeGetBoolean( oTypeSTop, qHasGap )
8299:                   | true :   #eCantUsePredSuccOnEnumWithValueGaps
8302:                   | * :
8307:                ]
8307:             | * :  #eTypeMismatch
8314:          ]
8314:          .tIncI
8316:          ')'
8318:          >>
8319:       | * :
8324:    ]
      
8324:    #eNotImplemented
8327:    ;
      
      
      % ------------------------------ Statements -----------------------------
      
8327: Statement:
8329:    [
8329:       | pWriteln :     @WritelnStmt
8333:       | pWrite :       @WriteStmt
8337:       | pReadln :      @ReadlnStmt
8341:       | pRead :        @ReadStmt
8345:       | pIf :          @IfStmt
8349:       | pWhile :       @WhileStmt
8353:       | pFor :         @ForStmt
8357:       | pRepeat :      @RepeatStmt
8361:       | pBreak :       @BreakStmt
8365:       | pContinue :    @ContinueStmt
8369:       | pBegin :       @BeginStmt
8373:       | pIdent :       @LabelOrAssignOrCallStmt
8377:       | pGoto :        @GotoStmt
8381:       | pIntLit :      % should be an integer label
8383:                        oChangeIntLitToLabelIdent
8384:                        @LabelOrAssignOrCallStmt
8386:       | * :            % null statement : don't accept any tokens
8417:    ];
      
      
8418: LabelOrAssignOrCallStmt:
8420:    Node decl = oScopeFindRequire
8425:    @ResolveUnitRef( decl )
8432:    [ oNodeType( decl )
8439:       | nLabel :                          @LabelDefinition( decl )
8447:                                           @Statement
8449:       | nProc :                           @Call( decl )
8458:       | nGlobalVar, nLocalVar, nParam :   @AssignStmt( decl )
8467:       | nFunc :                           @AssignResultStmt( decl )
8476:       | * :                               #eBadStatement
8493:    ];
      
      
      % Parse a "label:" prefix in front of a statement.
      %
8494: LabelDefinition( Node decl ):
8496:    [ oNodeGetBoolean( decl, qDefined )
8506:       | true :  #eAlreadyDefined
8509:       | * :
8514:    ]
8514:    .tLabel  oEmitLabel( oNodeGetLabel( decl, qValue ) )
8529:    oNodeSetBoolean( decl, qDefined, true )
8541:    ':'
8544:    ;
      
      
      % Given decl, the just-accepted first identifier on the left hand side.
      %
8544: AssignStmt( Node decl ):
      
8546:    @LValueVar( decl )
8553:    ':=' 
8555:    @Expr
8557:    @CoerceType
8559:    @Assign
8562:    ;
      
      
      % Performs a raw assignment.
      % Given lvalue 2nd on stack, and expr value top of stack,
      % and type of both of these on the type stack,
      % perform the assignment and pop the type off the type stack.
      %
8562: Assign:
8564:    [ oTypeSNodeType
8566:       | nIntegerType, nEnumType :  .tAssignI
8569:       | nBooleanType, nByteType, nCharType :  .tAssignB
8573:       | nStringType, nFileType :   #eNotImplemented
8577:       | nPointerType :             .tAssignP
            % compound var assigns; addrs of src, dest on stack
8581:       | nArrayType, nRecordType :
8583:           int size = oNodeGetInt( oTypeSTop, qSize )
8595:           .tCopy  oEmitInt( size )    % multi-word copy
8603:    ]
8627:    oTypeSPop
8629:    ;
      
      % Given nFunc for the just-accepted identifier on the left hand side.
      % Parse an assignment that represents assignment of the function result.
      %
8629: AssignResultStmt( Node funcDecl ):
         % Only allowed to assign the result of the immediately enclosing function, I think.
8631:    [ oNodeEqual( oNodeGet( funcDecl, qChildScope ), oScopeCurrent )
8647:       | false :   #eNotCurrentFunction
8650:       | * :
8655:    ]
      
         % Result value is stored in the caller's space, via a hidden VAR parameter.
8655:    .tPushParamP  oEmitInt( oNodeGetInt( funcDecl, qResultOffset ) )
8670:    oTypeSPush( oNodeGet( funcDecl, qType ) )
      
8683:    ':='
8685:    @Expr
8687:    @CoerceType
8689:    [ oTypeSNodeType
8691:       | nIntegerType, nEnumType : .tAssignI
8694:       | nBooleanType, nByteType, nCharType :  .tAssignB
8698:       | nStringType, nFileType :   #eNotImplemented
8702:       | nPointerType :            .tAssignP
            % compound var assigns; addrs of src, dest on stack
8706:       | nArrayType, nRecordType :
8708:           int size = oNodeGetInt( oTypeSTop, qSize )
8720:           .tCopy  oEmitInt( size )    % multi-word copy
8728:    ]
8752:    oTypeSPop
8754:    ;
      
      
      
      % Parse an lvalue expression, from scratch.
      % This is an expression that may appear on the left side of an assignment.
      % Leaves the address of the value on the expr stack,
      % and the type of the value at that address on the type stack.
      %
8754: LValueExpr:
         % At the moment, all lvalue expressions start with a variable name.
         % I think there can also be typecasts, not supported yet.  Check standard syntax.
8756:    pIdent
8758:    Node decl = oScopeFindRequire
8763:    @ResolveUnitRef( decl )
8770:    [ oNodeType( decl )
8777:       | nGlobalVar, nLocalVar, nParam :
8778:       | * :  #eNotVar
8789:    ]
8789:    @LValueVar( decl )
8797:    ;
      
      
      % Parse an lvalue expression (e.g. left side of an assign statement)
      % that starts with the just-accepted identifier indicated by the given decl.
      % Leaves the lvalue address on the expression stack,
      % and the type of the value at that address on the type stack.
      %
8797: LValueVar( Node decl ):
8799:    [ oNodeType( decl )
8806:       | nGlobalVar :   .tPushAddrGlobal @EmitValue( decl )
8816:       | nLocalVar :    .tPushAddrLocal @EmitValue( decl )
8827:       | nParam :
8829:          [ oNodeGetBoolean( decl, qInOut )
8839:             | true :   % VAR param points to variable.  No dereference.
8840:                        .tPushParamP @EmitValue( decl )
8849:             | * :      .tPushAddrParam @EmitValue( decl )
8863:          ]
8863:       | * :            #eNotVar
8874:    ]
      
8874:    oTypeSPush( oNodeGet( decl, qType ) )
8887:    @LValueIndexes        % handle subscripts, if any
8890:    ;
      
      
8890: IncVar( Node decl ):
8892:    @LValueVar( decl )
8899:    @RequireIntPop
8901:    @VarExpr( decl )
8908:    oTypeSPop
8909:    .tIncI
8911:    .tAssignI;
      
8914: DecVar( Node decl ):
8916:    @LValueVar( decl )
8923:    @RequireIntPop
8925:    @VarExpr( decl )
8932:    oTypeSPop
8933:    .tDecI
8935:    .tAssignI;
      
      
8938: IfStmt:
8940:    Label falseLabel = labelNull
      
8946:    @BooleanExprControlFlow( falseLabel )
8953:    pThen
8955:    @Statement
8957:    [
8957:       | pElse :
8959:          Label doneLabel = oLabelNew
      
8964:          .tJump  oEmitLabel( doneLabel )
8972:          .tLabel oEmitLabel( falseLabel )
8980:          @Statement
8982:          .tLabel oEmitLabel( doneLabel )
      
8990:       | * :
8995:          .tLabel oEmitLabel( falseLabel )
9003:    ];
      
      
9004: ForStmt:
9006:    pIdent
      
9008:    Node decl = oScopeFindRequire
         % TO DO: disallow use of a compound variable field.
         %        Could do that by disallowing use of LValueIndexes,
         %        or by double-checking the decl's qType here.
         % TO DO: I think I read somewhere that the variable must be in current scope.
9013:    @LValueVar( decl )
9020:    @RequireIntPop
      
9022:    ':='
      
9024:    @Expr
9026:    @RequireIntPop
9028:    .tAssignI
      
9030:    Label breakLabel = oLabelNew
      
9035:    Label checkLabel = oLabelNew
9040:    .tJump  oEmitLabel( checkLabel )
      
9048:    Label continueLabel = oLabelNew
9053:    .tLabel  oEmitLabel( continueLabel )
9061:    [
9061:       | pTo :
9063:          @IncVar( decl )
9070:          .tLabel  oEmitLabel( checkLabel )
9078:          @VarExpr( decl )  oTypeSPop
9086:          @Expr
9088:          @RequireIntPop
9090:          .tGreaterI
9092:          .tJumpTrue  oEmitLabel( breakLabel )
9100:       | pDownto :
9102:          @DecVar( decl )
9109:          .tLabel  oEmitLabel( checkLabel )
9117:          @VarExpr( decl )  oTypeSPop
9125:          @Expr
9127:          @RequireIntPop
9129:          .tLessI
9131:          .tJumpTrue  oEmitLabel( breakLabel )
9139:    ]
9147:    oLoopPush( continueLabel, breakLabel )
9156:    pDo
9158:    @Statement
9160:    .tJump  oEmitLabel( continueLabel )
9168:    .tLabel  oEmitLabel( breakLabel )
9176:    oLoopPop;
      
      
9178: RepeatStmt:
9180:    Label continueLabel = oLabelNew
9185:    .tLabel  oEmitLabel( continueLabel )
      
9193:    Label breakLabel = oLabelNew
      
9198:    oLoopPush( continueLabel, breakLabel )
9207:    @Statement
9209:    {[
9209:       | ';' :
9211:          @Statement
9213:       | pUntil :
9215:          Label falseLabel
9215:          @BooleanExprControlFlow( falseLabel )
9222:          .tLabelAlias  oEmitLabel( falseLabel )  oEmitLabel( continueLabel )
9236:          >
9238:    ]}
9248:    .tLabel  oEmitLabel( breakLabel )
9256:    oLoopPop;
      
      
9258: WhileStmt:
9260:    Label continueLabel = oLabelNew
9265:    .tLabel  oEmitLabel( continueLabel )
      
9273:    Label breakLabel
9273:    @BooleanExprControlFlow( breakLabel )
      
9280:    oLoopPush( continueLabel, breakLabel )
9289:    pDo
9291:    @Statement
9293:    .tJump  oEmitLabel( continueLabel )
9301:    .tLabel  oEmitLabel( breakLabel )
9309:    oLoopPop;
      
      
9311: ContinueStmt:                     % NOTE, for repeat..until, skips test (??)
9313:    [ equal_label( oLoopContinueLabel, labelNull )
9322:       | true :
9323:          #eNotInALoop
9325:       | false :
9327:          .tJump  oEmitLabel( oLoopContinueLabel )
9334:    ];
      
      
9343: BreakStmt:
9345:    [ equal_label( oLoopBreakLabel, labelNull )
9354:       | true :
9355:          #eNotInALoop
9357:       | false :
9359:          .tJump  oEmitLabel( oLoopBreakLabel )
9366:    ];
      
      
9375: GotoStmt:
9377:    [
9377:       | pIdent :
9379:       | pIntLit :
               % Replace token with identifier "_label_<intlit>"
9381:          oChangeIntLitToLabelIdent
9382:    ]
      
         % Some pascals have rules about where you can jump (to a sibling statement or
         % higher level statement in the block, but not into a lower lower level statement.)
         % fpc just says "jumping into a nested statement can have strange effects."
         % I'm going to follow that and not prohibit any goto, as long as it's in the same block.
      
         % Label must be declared in the same block (same scope) it is used.
         % Some pascals allow non-local goto, but we do not.
         % That would require more tracking of dynamic scope, to unwind stack.
         % Note: in main program statement, this relies on the temporaries scope extending
         %  the main scope (where a label declaration would occur).
9390:    Node decl = oScopeFindRequireInScope( oScopeCurrent )
9399:    oNodeSetBoolean( decl, qUsed, true )
9411:    .tJump  oEmitLabel( oNodeGetLabel( decl, qValue ) )
9427:    ;
      
      
9427: BeginStmt:
9429:    @Statement
9431:    {[
9431:       | ';' :   @Statement
9435:       | pEnd :  >
9439:    ]};
      
      
9450: WritelnStmt:
9452:    @WriteStmt
9454:    .tWriteCR;
      
      
9457: WriteStmt:
9459:    [
9459:       | '(' :
9461:          {
9461:             @Expr
9463:             [ oTypeSNodeType
9465:                | nIntegerType :             .tWriteI
9468:                | nBooleanType :             .tWriteBool
9472:                | nByteType :                .tCastBtoI  .tWriteI
9478:                | nCharType :                .tWriteChar
9482:                | nStringType :              .tWriteStr
9486:                | nFileType :                #eNotImplemented
9490:                | nEnumType :
                        % write name via table lookup
9492:                   .tPushAddrGlobal  oEmitInt( oNodeGetInt( oTypeSTop, qNameTable ) )
9506:                   .tWriteEnum
9508:                | nPointerType :             .tWriteP
9512:                | * :                        #eNotAllowed
9533:             ]
9533:             oTypeSPop
9534:             [
9534:                | ')' : >
9538:                | ',' :
9540:             ]
9548:          }
9550:       | * :
9555:    ];
      
      
9556: ReadlnStmt:      % ***
         % TO DO
9559:    ;
      
9559: ReadStmt:
         % TO DO
9562:    ;
      
      % -------------------------------- Utilities -------------------------------
      
      % Return the static scope level of the current scope
      %
9562: ScopeLevel >> int:
9564:    >> oNodeGetInt( oScopeCurrent, qLevel );
      
      % Return the static scope level of the given declaration
      %
9574: DeclLevel( Node decl ) >> int:
9576:    >> oNodeGetInt( oNodeGet( decl, qParentScope ), qLevel );
         
      
      % How many levels higher is the given declaration from the current scope?
      %
9594: DeclUpLevels( Node decl ) >> int:
9596:    >> subtract( @ScopeLevel, @DeclLevel( decl ) );
      
      
      % Require that the top two types on the type stack are matching (ignoring subranges).
      % Pop one of them, leaving only one.
      %
9612: MatchTypes:
9614:    node_type nt = oTypeSNodeType
9619:    oTypeSPop
9620:    [ equal_node_type( nt, oTypeSNodeType )
9629:       | false :
9630:          #eTypeMismatch
9632:       | * :
9637:    ];
      
      
      % Require that the top type on the type stack is integer (ignoring subranges).
      % Pop it.
      %
9638: RequireIntPop:
9640:    [ oTypeSNodeType
9642:       | nIntegerType :
9643:       | * :          #eNotInteger
9650:    ]
9650:    oTypeSPop;
      
9652: RequireInt:
9654:    [ oTypeSNodeType
9656:       | nIntegerType :
9657:       | * :          #eNotInteger
9664:    ];
      
      
      % Convert the top value to integer (if it isn't already).
      % It must be implicitly convertable to integer.
      % Pop the type stack.
      %
9665: PromoteToIntPop:
9667:    [ oTypeSNodeType
9669:       | nIntegerType :
9670:       | nByteType :        .tCastBtoI
9674:       | * :                #eNotInteger
9683:    ]
9683:    oTypeSPop;
      
      % Convert the top value to integer (if it isn't already).
      % It must be implicitly convertable to integer.
      % Leave integer on the type stack.
      %
9685: PromoteToInt:
9687:    [ oTypeSNodeType
9689:       | nIntegerType :
9690:       | nByteType :        .tCastBtoI
9694:                            oTypeSPop
9695:                            oTypeSPush( IntegerType )
9701:       | * :                #eNotInteger
9710:    ];
      
      
      % If the top value is implicitly convertable to integer, do so.
      % Otherwise leave it as-is.
      %
9711: PromoteToIntOptional:
9713:    [ oTypeSNodeType
9715:       | nByteType :        .tCastBtoI
9718:                            oTypeSPop
9719:                            oTypeSPush( IntegerType )
9725:       | * :
9730:    ];
      
      
      
      
9731: RequireBoolPop:
9733:    [ oTypeSNodeType
9735:       | nBooleanType :
9736:       | * :          #eNotBoolean
9743:    ]
9743:    oTypeSPop;
      
9745: RequireBool:
9747:    [ oTypeSNodeType
9749:       | nBooleanType :
9750:       | * :          #eNotBoolean
9757:    ];
      
      
      % Create and return a new nType of the given node_type, adding it to the type table.
      %
9758: newType( node_type nt, int size ) >> Node:
9760:   Node node = oNodeNew( nt )
9770:   oNodeSetInt( node, qSize, size )
9782:   oTypeAdd( node )
9788:   >> node
9792:   ;
      
      
      % Create and return a new nIdent of the given node_type, with the given ident id.
      % Does not add it to any scope.
      %
9792: newIdent( node_type nt, int id ) >> Node:
9794:   Node t = oNodeNew( nt )
9804:   oNodeSetInt( t, qIdent, id )
9816:   >> t
9820:   ;
      
      
      % Return an nType representing a pointer to the given type.
      % (Creates a new type if necessary.)
      %
9820: PointerTypeTo( Node theType ) >> Node:
9822:    Node ptrType = oNodeGet( theType, qPointerType )
9835:    [ oNodeNull( ptrType )
9842:       | true :
9843:          ptrType = oNodeNew( nPointerType )
9853:          oNodeSet( ptrType, qBaseType, theType )
9865:          oNodeSetInt( ptrType, qSize, 8 )
9877:          oTypeAdd( ptrType )
9883:          oNodeSet( theType, qPointerType, ptrType )
9895:       | * :
9900:    ]
9900:    >> ptrType;
      
      
      % Return the low value of an ordinal type
      %
9904: OrdinalLow( Node theType ) >> int:
9906:    [ oNodeType( theType )
9913:       | nIntegerType :  >> oMININT
9916:       | nBooleanType :  >> 0
9921:       | nCharType :     >> 0
9926:       | nEnumType :
9928:          Node enumScope = oNodeGet( theType, qScope )
9941:          Node first = oNodeIterValue( oNodeGetIter( enumScope, qDecls ) )
9958:          >> oNodeGetInt( first, qValue )
9968:       | nSubrangeType : >> oNodeGetInt( theType, qLow )
9980:       | * :             #eNotOrdinalType
9995:                         >> 0
9998:    ];
      
      
      % Return the high value of an ordinal type
      %
9999: OrdinalHigh( Node theType ) >> int:
10001:    [ oNodeType( theType )
10008:       | nIntegerType :  >> oMAXINT
10011:       | nBooleanType :  >> 1
10016:       | nCharType :     >> 255
10021:       | nEnumType :
10023:          Node enumScope = oNodeGet( theType, qScope )
10036:          Node last = oNodeIterValue( oNodeGetIterLast( enumScope, qDecls ) )
10053:          >> oNodeGetInt( last, qValue )
10063:       | nSubrangeType : >> oNodeGetInt( theType, qHigh )
10075:       | * :             #eNotOrdinalType
10090:                         >> 0
10093:    ];
      
      
      % Emit the value in a declaration.
      % For a constant integer, this is the constant value.
      % For a global variable, this is the global address.
      % For a local variable, this is the local address relative to the call stack frame.
      %
10094: EmitValue( Node decl ):
10096:     oEmitInt( oNodeGetInt( decl, qValue ));
      
      
10110: DeclareBuiltInFunc( int id ) >> Node:
10112:    Node decl = @newIdent( nBuiltInFunc, id )
10126:    oScopeDeclare( decl )
10132:    >> decl;
      
      
10136: installBuiltIns:
      
         % install built-in types
10138:    FileType = @newType( nFileType, 4 )
10152:    IntegerType = @newType( nIntegerType, 4 )
10166:    BooleanType = @newType( nBooleanType, 1 )
10180:    BooleanCFType = @newType( nBooleanCFType, 1 )
10194:    CharType = @newType( nCharType, 1 )
10208:    ByteType = @newType( nByteType, 1 )
10222:    StringType = @newType( nStringType, 256 )    % string with default length 256
      
         % Declare those type identifiers.
         % SSL doesn't support strings, so need help from operations e.g. oIdAdd_File
      
10236:    Node t
      
10236:    t = @newIdent( nTypeDecl, oIdAdd_File )
10249:    oNodeSet( t, qType, FileType )
10261:    oScopeDeclare( t )
      
10267:    t = @newIdent( nTypeDecl, oIdAdd_Integer )
10280:    oNodeSet( t, qType, IntegerType )
10292:    oScopeDeclare( t )
      
10298:    t = @newIdent( nTypeDecl, oIdAdd_Boolean )
10311:    oNodeSet( t, qType, BooleanType )
10323:    oScopeDeclare( t )
      
10329:    t = @newIdent( nTypeDecl, oIdAdd_Char )
10342:    oNodeSet( t, qType, CharType )
10354:    oScopeDeclare( t )
      
10360:    t = @newIdent( nTypeDecl, oIdAdd_Byte )
10373:    oNodeSet( t, qType, ByteType )
10385:    oScopeDeclare( t )
      
10391:    t = @newIdent( nTypeDecl, oIdAdd_String )
10404:    oNodeSet( t, qType, StringType )
10416:    oScopeDeclare( t )
      
         % Built-in constants
      
10422:    t = @newIdent( nConst, oIdAdd_True )
10435:    oNodeSet( t, qType, BooleanType )
10447:    oNodeSetInt( t, qValue, 1 )
10459:    oScopeDeclare( t )
      
10465:    t = @newIdent( nConst, oIdAdd_False )
10478:    oNodeSet( t, qType, BooleanType )
10490:    oNodeSetInt( t, qValue, 0 )
10502:    oScopeDeclare( t )
      
         % Built-in methods
         % These aren't declared like normal methods, because they may have
         % special rules for parameter types (e.g. any scalar type).
         % Calls to these methods will be handled specially by the compiler.
      
10508:    BuiltIn_Ord = @DeclareBuiltInFunc( oIdAdd_Ord )
10518:    BuiltIn_Chr = @DeclareBuiltInFunc( oIdAdd_Chr )
10528:    BuiltIn_Pred = @DeclareBuiltInFunc( oIdAdd_Pred )
10538:    BuiltIn_Succ = @DeclareBuiltInFunc( oIdAdd_Succ )
10549:    ;
      
10549: end
      
10549: 

Generated code:

   0: oGlobalSpace 15
   2: oLocalSpace 5
   4: oGetAddrGlobal 1
   6: oPushResult
   7: oWorkspaceNew
   8: oAssign
   9: oSetResult 0
  11: oPushResult
  12: oSetResult 0
  14: oPushResult
  15: oScopeBegin
  16: oPop 2
  18: oGetAddrLocal 2
  20: oPushResult
  21: oScopeCurrent
  22: oAssign
  23: oCall 10136
  25: oEmit 54
  27: oSetResult 0
  29: oPushResult
  30: oEmitInt
  31: oPop 1
  33: oGetAddrLocal 3
  35: oPushResult
  36: oLabelNew
  37: oAssign
  38: oEmit 48
  40: oSetResult 0
  42: oPushResult
  43: oEmitInt
  44: oPop 1
  46: oEmit 51
  48: oGetLocal 3
  50: oPushResult
  51: oEmitLabel
  52: oPop 1
  54: oEmit 50
  56: oSetResult 0
  58: oPushResult
  59: oEmitInt
  60: oPop 1
  62: oEmit 53
  64: oInput 28
  66: oInput 0
  68: oGetAddrLocal 4
  70: oPushResult
  71: oSetResult 4
  73: oPushResult
  74: oNodeNew
  75: oPop 1
  77: oAssign
  78: oGetLocal 4
  80: oPushResult
  81: oSetResult 4
  83: oPushResult
  84: LAST_ID
  85: oPushResult
  86: oNodeSetInt
  87: oPop 3
  89: oGetGlobal 1
  91: oPushResult
  92: oSetResult 2
  94: oPushResult
  95: oGetLocal 4
  97: oPushResult
  98: oNodeSet
  99: oPop 3
 101: oInputChoice 175
 103: oInput 0
 105: oGetAddrLocal 1
 107: oPushResult
 108: oSetResult 19
 110: oPushResult
 111: LAST_ID
 112: oPushResult
 113: oCall 9792
 115: oPop 2
 117: oAssign
 118: oGetLocal 1
 120: oPushResult
 121: oSetResult 21
 123: oPushResult
 124: oGetGlobal 4
 126: oPushResult
 127: oNodeSet
 128: oPop 3
 130: oGetLocal 1
 132: oPushResult
 133: oScopeDeclareAlloc
 134: oPop 1
 136: oInput 13
 138: oInput 0
 140: oGetAddrLocal 1
 142: oPushResult
 143: oSetResult 19
 145: oPushResult
 146: LAST_ID
 147: oPushResult
 148: oCall 9792
 150: oPop 2
 152: oAssign
 153: oGetLocal 1
 155: oPushResult
 156: oSetResult 21
 158: oPushResult
 159: oGetGlobal 4
 161: oPushResult
 162: oNodeSet
 163: oPop 3
 165: oGetLocal 1
 167: oPushResult
 168: oScopeDeclareAlloc
 169: oPop 1
 171: oInput 15
 173: oJumpForward 178
 175: Choice Lookup Table
          14    103
 178: oInput 5
 180: oInputChoice 191
 182: oGetLocal 4
 184: oPushResult
 185: oCall 299
 187: oPop 1
 189: oJumpForward 194
 191: Choice Lookup Table
          57    182
 194: oGetLocal 4
 196: oPushResult
 197: oCall 452
 199: oPop 1
 201: oSetResult 0
 203: oPushResult
 204: oSetResult 0
 206: oPushResult
 207: oScopeBegin
 208: oPop 2
 210: oGetAddrGlobal 2
 212: oPushResult
 213: oScopeCurrent
 214: oAssign
 215: oSetResult 0
 217: oPushResult
 218: oSetResult 1
 220: oPushResult
 221: oScopeBegin
 222: oPop 2
 224: oScopeCurrent
 225: oPushResult
 226: oSetResult 16
 228: oPushResult
 229: oGetGlobal 2
 231: oPushResult
 232: oNodeSet
 233: oPop 3
 235: oGetAddrGlobal 3
 237: oPushResult
 238: oScopeCurrent
 239: oAssign
 240: oGetLocal 4
 242: oPushResult
 243: oSetResult 7
 245: oPushResult
 246: oGetGlobal 3
 248: oPushResult
 249: oNodeSet
 250: oPop 3
 252: oScopeEnd
 253: oSetResult 20
 255: oPushResult
 256: oCall 1388
 258: oPop 1
 260: oGetGlobal 3
 262: oPushResult
 263: oScopeEnter
 264: oPop 1
 266: oGetAddrLocal 5
 268: oPushResult
 269: oSetResult 1
 271: oAssign
 272: oGetLocal 3
 274: oPushResult
 275: oGetGlobal 2
 277: oPushResult
 278: oGetLocal 5
 280: oPushResult
 281: oCall 1709
 283: oPop 3
 285: oScopeEnd
 286: oInput 20
 288: oCall 1444
 290: oScopeEnd
 291: oGetLocal 4
 293: oPushResult
 294: oCall 514
 296: oPop 1
 298: oReturn
 299: oLocalSpace 2
 301: oInput 0
 303: oGetAddrLocal 1
 305: oPushResult
 306: LAST_ID
 307: oPushResult
 308: oCall 593
 310: oPop 1
 312: oAssign
 313: oGetLocal 1
 315: oPushResult
 316: oSetResult 0
 318: oPushResult
 319: equal_node
 320: oPop 2
 322: oChoice 392
 324: oGetParam 1
 326: oPushResult
 327: oSetResult 5
 329: oPushResult
 330: oGetLocal 1
 332: oPushResult
 333: oNodeAddLast
 334: oPop 3
 336: oGetAddrLocal 2
 338: oPushResult
 339: oSetResult 10
 341: oPushResult
 342: oNodeNew
 343: oPop 1
 345: oAssign
 346: oGetLocal 2
 348: oPushResult
 349: oSetResult 4
 351: oPushResult
 352: oGetLocal 1
 354: oPushResult
 355: oSetResult 4
 357: oPushResult
 358: oNodeGetInt
 359: oPop 2
 361: oPushResult
 362: oNodeSetInt
 363: oPop 3
 365: oGetLocal 2
 367: oPushResult
 368: oSetResult 9
 370: oPushResult
 371: oGetLocal 1
 373: oPushResult
 374: oSetResult 9
 376: oPushResult
 377: oNodeGet
 378: oPop 2
 380: oPushResult
 381: oNodeSet
 382: oPop 3
 384: oGetLocal 2
 386: oPushResult
 387: oScopeDeclare
 388: oPop 1
 390: oJumpForward 395
 392: Choice Lookup Table
           0    324
 395: oInputChoice 399
 397: oJumpForward 404
 399: Choice Lookup Table
          13    397
 402: oJumpForward 406
 404: oJumpBack 301
 406: oInput 5
 408: oReturn
 409: oLocalSpace 1
 411: oGetFromParam 1
 413: oPushResult
 414: oNodeType
 415: oPop 1
 417: oChoice 448
 419: oGetAddrLocal 1
 421: oPushResult
 422: oGetFromParam 1
 424: oPushResult
 425: oSetResult 9
 427: oPushResult
 428: oNodeGet
 429: oPop 2
 431: oAssign
 432: oInput 20
 434: oInput 0
 436: oGetParam 1
 438: oPushResult
 439: oGetLocal 1
 441: oPushResult
 442: oScopeFindRequireInScope
 443: oPop 1
 445: oAssign
 446: oJumpForward 451
 448: Choice Lookup Table
          10    419
 451: oReturn
 452: oLocalSpace 2
 454: oGetAddrLocal 1
 456: oPushResult
 457: oGetParam 1
 459: oPushResult
 460: oSetResult 5
 462: oPushResult
 463: oNodeGetIter
 464: oPop 2
 466: oAssign
 467: oGetAddrLocal 2
 469: oPushResult
 470: oGetLocal 1
 472: oPushResult
 473: oNodeIterValue
 474: oPop 1
 476: oAssign
 477: oGetLocal 2
 479: oPushResult
 480: oNodeNull
 481: oPop 1
 483: oChoice 500
 485: oGetLocal 2
 487: oPushResult
 488: oSetResult 9
 490: oPushResult
 491: oNodeGet
 492: oPop 2
 494: oPushResult
 495: oScopeEnter
 496: oPop 1
 498: oJumpForward 505
 500: Choice Lookup Table
           0    485
 503: oJumpForward 513
 505: oGetAddrLocal 1
 507: oPushResult
 508: oNodeIterNext
 509: oPop 1
 511: oJumpBack 467
 513: oReturn
 514: oLocalSpace 2
 516: oGetAddrLocal 1
 518: oPushResult
 519: oGetParam 1
 521: oPushResult
 522: oSetResult 5
 524: oPushResult
 525: oNodeGetIterLast
 526: oPop 2
 528: oAssign
 529: oGetAddrLocal 2
 531: oPushResult
 532: oGetLocal 1
 534: oPushResult
 535: oNodeIterValue
 536: oPop 1
 538: oAssign
 539: oGetLocal 2
 541: oPushResult
 542: oNodeNull
 543: oPop 1
 545: oChoice 579
 547: oScopeCurrent
 548: oPushResult
 549: oGetLocal 2
 551: oPushResult
 552: oSetResult 9
 554: oPushResult
 555: oNodeGet
 556: oPop 2
 558: oPushResult
 559: oNodeEqual
 560: oPop 2
 562: oChoice 570
 564: oJumpForward 576
 566: oError 25
 568: oJumpForward 576
 570: Choice Lookup Table
           0    566
           1    564
 575: oEndChoice
 576: oScopeEnd
 577: oJumpForward 584
 579: Choice Lookup Table
           0    547
 582: oJumpForward 592
 584: oGetAddrLocal 1
 586: oPushResult
 587: oNodeIterPrev
 588: oPop 1
 590: oJumpBack 529
 592: oReturn
 593: oLocalSpace 2
 595: oGetAddrLocal 1
 597: oPushResult
 598: oGetGlobal 1
 600: oPushResult
 601: oSetResult 1
 603: oPushResult
 604: oSetResult 4
 606: oPushResult
 607: oGetParam 1
 609: oPushResult
 610: oNodeFind
 611: oPop 4
 613: oAssign
 614: oGetLocal 1
 616: oPushResult
 617: oSetResult 0
 619: oPushResult
 620: equal_node
 621: oPop 2
 623: oChoice 630
 625: oGetLocal 1
 627: oReturn
 628: oJumpForward 633
 630: Choice Lookup Table
           0    625
 633: oGetAddrLocal 2
 635: oPushResult
 636: oGetParam 1
 638: oPushResult
 639: oIncludeUnitFile
 640: oPop 1
 642: oAssign
 643: oGetLocal 2
 645: oChoice 654
 647: oError 24
 649: oSetResult 0
 651: oReturn
 652: oJumpForward 657
 654: Choice Lookup Table
           0    647
 657: oGetAddrLocal 1
 659: oPushResult
 660: oCall 668
 662: oAssign
 663: oIncludeEnd
 664: oGetLocal 1
 666: oReturn
 667: oReturn
 668: oLocalSpace 2
 670: oInput 58
 672: oInput 0
 674: oGetAddrLocal 1
 676: oPushResult
 677: oSetResult 5
 679: oPushResult
 680: oNodeNew
 681: oPop 1
 683: oAssign
 684: oGetLocal 1
 686: oPushResult
 687: oSetResult 4
 689: oPushResult
 690: LAST_ID
 691: oPushResult
 692: oNodeSetInt
 693: oPop 3
 695: oGetAddrLocal 2
 697: oPushResult
 698: oSetResult 6
 700: oPushResult
 701: oNodeNew
 702: oPop 1
 704: oAssign
 705: oGetLocal 2
 707: oPushResult
 708: oSetResult 4
 710: oPushResult
 711: LAST_ID
 712: oPushResult
 713: oNodeSetInt
 714: oPop 3
 716: oGetLocal 1
 718: oPushResult
 719: oSetResult 8
 721: oPushResult
 722: oGetLocal 2
 724: oPushResult
 725: oNodeSet
 726: oPop 3
 728: oInput 5
 730: oInput 59
 732: oInputChoice 743
 734: oGetLocal 1
 736: oPushResult
 737: oCall 299
 739: oPop 1
 741: oJumpForward 746
 743: Choice Lookup Table
          57    734
 746: oGetLocal 1
 748: oPushResult
 749: oCall 452
 751: oPop 1
 753: oSetResult 0
 755: oPushResult
 756: oSetResult 0
 758: oPushResult
 759: oScopeBegin
 760: oPop 2
 762: oGetLocal 1
 764: oPushResult
 765: oSetResult 9
 767: oPushResult
 768: oScopeCurrent
 769: oPushResult
 770: oNodeSet
 771: oPop 3
 773: oGetAddrGlobal 2
 775: oPushResult
 776: oScopeCurrent
 777: oAssign
 778: oSetResult 0
 780: oPushResult
 781: oSetResult 1
 783: oPushResult
 784: oScopeBegin
 785: oPop 2
 787: oGetAddrGlobal 3
 789: oPushResult
 790: oScopeCurrent
 791: oAssign
 792: oGetLocal 1
 794: oPushResult
 795: oSetResult 13
 797: oPushResult
 798: oGetGlobal 3
 800: oPushResult
 801: oNodeSet
 802: oPop 3
 804: oScopeEnd
 805: oGetLocal 1
 807: oPushResult
 808: oCall 989
 810: oPop 1
 812: oScopeEnd
 813: oInput 60
 815: oInputChoice 826
 817: oGetLocal 2
 819: oPushResult
 820: oCall 299
 822: oPop 1
 824: oJumpForward 829
 826: Choice Lookup Table
          57    817
 829: oGetLocal 2
 831: oPushResult
 832: oCall 452
 834: oPop 1
 836: oGetLocal 1
 838: oPushResult
 839: oSetResult 9
 841: oPushResult
 842: oNodeGet
 843: oPop 2
 845: oPushResult
 846: oScopeEnter
 847: oPop 1
 849: oSetResult 0
 851: oPushResult
 852: oSetResult 0
 854: oPushResult
 855: oScopeBegin
 856: oPop 2
 858: oGetLocal 1
 860: oPushResult
 861: oSetResult 10
 863: oPushResult
 864: oScopeCurrent
 865: oPushResult
 866: oNodeSet
 867: oPop 3
 869: oScopeCurrent
 870: oPushResult
 871: oSetResult 16
 873: oPushResult
 874: oGetLocal 1
 876: oPushResult
 877: oSetResult 9
 879: oPushResult
 880: oNodeGet
 881: oPop 2
 883: oPushResult
 884: oNodeSet
 885: oPop 3
 887: oGetAddrGlobal 2
 889: oPushResult
 890: oScopeCurrent
 891: oAssign
 892: oGetLocal 1
 894: oPushResult
 895: oCall 1074
 897: oPop 1
 899: oInputChoice 913
 901: oGetLocal 1
 903: oPushResult
 904: oSetResult 1
 906: oPushResult
 907: oCall 1084
 909: oPop 2
 911: oJumpForward 926
 913: Choice Lookup Table
          61    901
 916: oGetLocal 1
 918: oPushResult
 919: oSetResult 0
 921: oPushResult
 922: oCall 1084
 924: oPop 2
 926: oInputChoice 940
 928: oGetLocal 1
 930: oPushResult
 931: oSetResult 1
 933: oPushResult
 934: oCall 1270
 936: oPop 2
 938: oJumpForward 953
 940: Choice Lookup Table
          62    928
 943: oGetLocal 1
 945: oPushResult
 946: oSetResult 0
 948: oPushResult
 949: oCall 1270
 951: oPop 2
 953: oInput 36
 955: oInput 20
 957: oScopeEnd
 958: oScopeEnd
 959: oGetLocal 2
 961: oPushResult
 962: oCall 514
 964: oPop 1
 966: oGetLocal 1
 968: oPushResult
 969: oCall 514
 971: oPop 1
 973: oGetGlobal 1
 975: oPushResult
 976: oSetResult 1
 978: oPushResult
 979: oGetLocal 1
 981: oPushResult
 982: oNodeAddLast
 983: oPop 3
 985: oGetLocal 1
 987: oReturn
 988: oReturn
 989: oLocalSpace 2
 991: oInputChoice 1058
 993: oCall 2982
 995: oJumpForward 1071
 997: oCall 3443
 999: oJumpForward 1071
1001: oSetResult 20
1003: oPushResult
1004: oCall 3499
1006: oPop 1
1008: oJumpForward 1071
1010: oGetAddrLocal 1
1012: oPushResult
1013: oCall 1949
1015: oAssign
1016: oInputChoice 1029
1018: oGetLocal 1
1020: oPushResult
1021: oCall 1887
1023: oPop 1
1025: oInput 5
1027: oJumpForward 1032
1029: Choice Lookup Table
          68   1018
1032: oJumpForward 1071
1034: oGetAddrLocal 2
1036: oPushResult
1037: oCall 2323
1039: oAssign
1040: oInputChoice 1053
1042: oGetLocal 2
1044: oPushResult
1045: oCall 1887
1047: oPop 1
1049: oInput 5
1051: oJumpForward 1056
1053: Choice Lookup Table
          68   1042
1056: oJumpForward 1071
1058: Choice Lookup Table
          30   1034
          29   1010
          33   1001
          32    997
          31    993
1069: oJumpForward 1073
1071: oJumpBack 991
1073: oReturn
1074: oLocalSpace 0
1076: oSetResult 20
1078: oPushResult
1079: oCall 1388
1081: oPop 1
1083: oReturn
1084: oLocalSpace 5
1086: oGetAddrLocal 1
1088: oPushResult
1089: oLabelNew
1090: oAssign
1091: oEmit 58
1093: oGetLocal 1
1095: oPushResult
1096: oEmitLabel
1097: oPop 1
1099: oGetParam 2
1101: oPushResult
1102: oSetResult 11
1104: oPushResult
1105: oGetLocal 1
1107: oPushResult
1108: oNodeSetLabel
1109: oPop 3
1111: oEmit 54
1113: oGetAddrLocal 2
1115: oPushResult
1116: Here
1117: oAssign
1118: oEmit 68
1120: oGetAddrLocal 3
1122: oPushResult
1123: oGetParam 2
1125: oPushResult
1126: oSetResult 9
1128: oPushResult
1129: oNodeGet
1130: oPop 2
1132: oAssign
1133: oGetAddrLocal 4
1135: oPushResult
1136: oGetLocal 3
1138: oPushResult
1139: oSetResult 19
1141: oPushResult
1142: oNodeGetCode
1143: oPop 2
1145: oAssign
1146: oGetLocal 4
1148: oPushResult
1149: oEmitCode
1150: oPop 1
1152: oGetLocal 3
1154: oPushResult
1155: oSetResult 19
1157: oPushResult
1158: oSetResult 0
1160: oPushResult
1161: oNodeSetCode
1162: oPop 3
1164: oGetAddrLocal 3
1166: oPushResult
1167: oGetParam 2
1169: oPushResult
1170: oSetResult 10
1172: oPushResult
1173: oNodeGet
1174: oPop 2
1176: oAssign
1177: oGetAddrLocal 4
1179: oPushResult
1180: oGetLocal 3
1182: oPushResult
1183: oSetResult 19
1185: oPushResult
1186: oNodeGetCode
1187: oPop 2
1189: oAssign
1190: oGetLocal 4
1192: oPushResult
1193: oEmitCode
1194: oPop 1
1196: oGetLocal 3
1198: oPushResult
1199: oSetResult 19
1201: oPushResult
1202: oSetResult 0
1204: oPushResult
1205: oNodeSetCode
1206: oPop 3
1208: oGetParam 2
1210: oPushResult
1211: oSetResult 13
1213: oPushResult
1214: oNodeGet
1215: oPop 2
1217: oPushResult
1218: oScopeEnter
1219: oPop 1
1221: oGetParam 1
1223: oChoice 1242
1225: oCall 8327
1227: oInputChoice 1233
1229: oCall 8327
1231: oJumpForward 1238
1233: Choice Lookup Table
           5   1229
1236: oJumpForward 1240
1238: oJumpBack 1227
1240: oJumpForward 1245
1242: Choice Lookup Table
           1   1225
1245: oEmit 53
1247: oGetAddrLocal 5
1249: oPushResult
1250: oScopeCurrent
1251: oPushResult
1252: oSetResult 17
1254: oPushResult
1255: oNodeGetInt
1256: oPop 2
1258: oAssign
1259: oGetLocal 2
1261: oPushResult
1262: oGetLocal 5
1264: oPushResult
1265: oPatch
1266: oPop 2
1268: oScopeEnd
1269: oReturn
1270: oLocalSpace 3
1272: oGetAddrLocal 1
1274: oPushResult
1275: oLabelNew
1276: oAssign
1277: oEmit 58
1279: oGetLocal 1
1281: oPushResult
1282: oEmitLabel
1283: oPop 1
1285: oGetParam 2
1287: oPushResult
1288: oSetResult 12
1290: oPushResult
1291: oGetLocal 1
1293: oPushResult
1294: oNodeSetLabel
1295: oPop 3
1297: oEmit 54
1299: oGetAddrLocal 2
1301: oPushResult
1302: Here
1303: oAssign
1304: oEmit 68
1306: oSetResult 0
1308: oPushResult
1309: oSetResult 1
1311: oPushResult
1312: oScopeBegin
1313: oPop 2
1315: oGetParam 1
1317: oChoice 1336
1319: oCall 8327
1321: oInputChoice 1327
1323: oCall 8327
1325: oJumpForward 1332
1327: Choice Lookup Table
           5   1323
1330: oJumpForward 1334
1332: oJumpBack 1321
1334: oJumpForward 1339
1336: Choice Lookup Table
           1   1319
1339: oEmit 53
1341: oGetAddrLocal 3
1343: oPushResult
1344: oScopeCurrent
1345: oPushResult
1346: oSetResult 17
1348: oPushResult
1349: oNodeGetInt
1350: oPop 2
1352: oAssign
1353: oGetLocal 2
1355: oPushResult
1356: oGetLocal 3
1358: oPushResult
1359: oPatch
1360: oPop 2
1362: oScopeEnd
1363: oReturn
1364: oLocalSpace 0
1366: oGetParam 2
1368: oPushResult
1369: oCall 1388
1371: oPop 1
1373: oGetParam 1
1375: oPushResult
1376: oScopeCurrent
1377: oPushResult
1378: oSetResult 0
1380: oPushResult
1381: oCall 1709
1383: oPop 3
1385: oCall 1444
1387: oReturn
1388: oLocalSpace 0
1390: oInputChoice 1421
1392: oCall 2982
1394: oJumpForward 1436
1396: oCall 3443
1398: oJumpForward 1436
1400: oGetParam 1
1402: oPushResult
1403: oCall 3499
1405: oPop 1
1407: oJumpForward 1436
1409: oCall 3730
1411: oJumpForward 1436
1413: oCall 2205
1415: oJumpForward 1436
1417: oCall 2640
1419: oJumpForward 1436
1421: Choice Lookup Table
          30   1417
          29   1413
          34   1409
          33   1400
          32   1396
          31   1392
1434: oJumpForward 1438
1436: oJumpBack 1390
1438: oCall 1441
1440: oReturn
1441: oLocalSpace 0
1443: oReturn
1444: oLocalSpace 2
1446: oGetAddrLocal 1
1448: oPushResult
1449: oScopeCurrent
1450: oPushResult
1451: oSetResult 15
1453: oPushResult
1454: oNodeGetIter
1455: oPop 2
1457: oAssign
1458: oGetAddrLocal 2
1460: oPushResult
1461: oGetLocal 1
1463: oPushResult
1464: oNodeIterValue
1465: oPop 1
1467: oAssign
1468: oGetLocal 2
1470: oPushResult
1471: oNodeNull
1472: oPop 1
1474: oChoice 1478
1476: oJumpForward 1483
1478: Choice Lookup Table
           0   1476
1481: oJumpForward 1538
1483: oGetLocal 2
1485: oPushResult
1486: oNodeType
1487: oPop 1
1489: oChoice 1527
1491: oGetLocal 2
1493: oPushResult
1494: oSetResult 34
1496: oPushResult
1497: oNodeGetBoolean
1498: oPop 2
1500: oChoice 1522
1502: oGetLocal 2
1504: oPushResult
1505: oSetResult 28
1507: oPushResult
1508: oNodeGetBoolean
1509: oPop 2
1511: oChoice 1517
1513: oError 27
1515: oJumpForward 1520
1517: Choice Lookup Table
           1   1513
1520: oJumpForward 1525
1522: Choice Lookup Table
           0   1502
1525: oJumpForward 1530
1527: Choice Lookup Table
          25   1491
1530: oGetAddrLocal 1
1532: oPushResult
1533: oNodeIterNext
1534: oPop 1
1536: oJumpBack 1458
1538: oReturn
1539: oLocalSpace 2
1541: oGetAddrLocal 1
1543: oPushResult
1544: oGetGlobal 1
1546: oPushResult
1547: oSetResult 1
1549: oPushResult
1550: oNodeGetIter
1551: oPop 2
1553: oAssign
1554: oGetAddrLocal 2
1556: oPushResult
1557: oGetLocal 1
1559: oPushResult
1560: oNodeIterValue
1561: oPop 1
1563: oAssign
1564: oGetLocal 2
1566: oPushResult
1567: oNodeNull
1568: oPop 1
1570: oChoice 1615
1572: oJumpForward 1623
1574: oJumpForward 1621
1576: oEmit 48
1578: oSetResult 0
1580: oPushResult
1581: oEmitInt
1582: oPop 1
1584: oEmit 51
1586: oGetLocal 2
1588: oPushResult
1589: oSetResult 11
1591: oPushResult
1592: oNodeGetLabel
1593: oPop 2
1595: oPushResult
1596: oEmitLabel
1597: oPop 1
1599: oEmit 50
1601: oSetResult 0
1603: oPushResult
1604: oEmitInt
1605: oPop 1
1607: oGetAddrLocal 1
1609: oPushResult
1610: oNodeIterNext
1611: oPop 1
1613: oJumpForward 1621
1615: Choice Lookup Table
           0   1576
           1   1572
1620: oEndChoice
1621: oJumpBack 1554
1623: oReturn
1624: oLocalSpace 2
1626: oGetAddrLocal 1
1628: oPushResult
1629: oGetGlobal 1
1631: oPushResult
1632: oSetResult 1
1634: oPushResult
1635: oNodeGetIterLast
1636: oPop 2
1638: oAssign
1639: oGetAddrLocal 2
1641: oPushResult
1642: oGetLocal 1
1644: oPushResult
1645: oNodeIterValue
1646: oPop 1
1648: oAssign
1649: oGetLocal 2
1651: oPushResult
1652: oNodeNull
1653: oPop 1
1655: oChoice 1700
1657: oJumpForward 1708
1659: oJumpForward 1706
1661: oEmit 48
1663: oSetResult 0
1665: oPushResult
1666: oEmitInt
1667: oPop 1
1669: oEmit 51
1671: oGetLocal 2
1673: oPushResult
1674: oSetResult 12
1676: oPushResult
1677: oNodeGetLabel
1678: oPop 2
1680: oPushResult
1681: oEmitLabel
1682: oPop 1
1684: oEmit 50
1686: oSetResult 0
1688: oPushResult
1689: oEmitInt
1690: oPop 1
1692: oGetAddrLocal 1
1694: oPushResult
1695: oNodeIterPrev
1696: oPop 1
1698: oJumpForward 1706
1700: Choice Lookup Table
           0   1661
           1   1657
1705: oEndChoice
1706: oJumpBack 1639
1708: oReturn
1709: oLocalSpace 3
1711: oEmit 58
1713: oGetParam 3
1715: oPushResult
1716: oEmitLabel
1717: oPop 1
1719: oEmit 54
1721: oGetAddrLocal 1
1723: oPushResult
1724: Here
1725: oAssign
1726: oEmit 68
1728: oGetParam 1
1730: oChoice 1736
1732: oCall 1539
1734: oJumpForward 1739
1736: Choice Lookup Table
           1   1732
1739: oGetAddrLocal 2
1741: oPushResult
1742: oGetParam 2
1744: oPushResult
1745: oSetResult 19
1747: oPushResult
1748: oNodeGetCode
1749: oPop 2
1751: oAssign
1752: oGetLocal 2
1754: oPushResult
1755: oEmitCode
1756: oPop 1
1758: oGetParam 2
1760: oPushResult
1761: oSetResult 19
1763: oPushResult
1764: oSetResult 0
1766: oPushResult
1767: oNodeSetCode
1768: oPop 3
1770: oCall 8327
1772: oGetParam 1
1774: oChoice 1780
1776: oCall 1624
1778: oJumpForward 1783
1780: Choice Lookup Table
           1   1776
1783: oEmit 53
1785: oGetAddrLocal 3
1787: oPushResult
1788: oScopeCurrent
1789: oPushResult
1790: oSetResult 17
1792: oPushResult
1793: oNodeGetInt
1794: oPop 2
1796: oAssign
1797: oGetLocal 1
1799: oPushResult
1800: oGetLocal 3
1802: oPushResult
1803: oPatch
1804: oPop 2
1806: oReturn
1807: oLocalSpace 0
1809: oInputChoice 1827
1811: oGetParam 1
1813: oPushResult
1814: oSetResult 27
1816: oPushResult
1817: oSetResult 1
1819: oPushResult
1820: oNodeSetBoolean
1821: oPop 3
1823: oInput 5
1825: oJumpForward 1832
1827: Choice Lookup Table
          70   1811
1830: oJumpForward 1834
1832: oJumpBack 1809
1834: oReturn
1835: oLocalSpace 1
1837: oGetAddrLocal 1
1839: oPushResult
1840: oGetParam 1
1842: oPushResult
1843: oSetResult 19
1845: oPushResult
1846: oNodeGetCode
1847: oPop 2
1849: oAssign
1850: oGetLocal 1
1852: oPushResult
1853: oSetResult 0
1855: oPushResult
1856: equal_code
1857: oPop 2
1859: oChoice 1880
1861: oGetAddrLocal 1
1863: oPushResult
1864: oCodeNew
1865: oAssign
1866: oGetParam 1
1868: oPushResult
1869: oSetResult 19
1871: oPushResult
1872: oGetLocal 1
1874: oPushResult
1875: oNodeSetCode
1876: oPop 3
1878: oJumpForward 1883
1880: Choice Lookup Table
           1   1861
1883: oGetLocal 1
1885: oReturn
1886: oReturn
1887: oLocalSpace 0
1889: oGetParam 1
1891: oPushResult
1892: oCall 9574
1894: oPop 1
1896: oPushResult
1897: equal_zero
1898: oPop 1
1900: oChoice 1906
1902: oError 23
1904: oJumpForward 1909
1906: Choice Lookup Table
           0   1902
1909: oGetParam 1
1911: oPushResult
1912: oSetResult 25
1914: oPushResult
1915: oSetResult 1
1917: oPushResult
1918: oNodeSetBoolean
1919: oPop 3
1921: oInputChoice 1945
1923: oInputChoice 1940
1925: oInput 2
1927: oGetParam 1
1929: oPushResult
1930: oSetResult 26
1932: oPushResult
1933: CURRENT_STRLIT
1934: oPushResult
1935: oNodeSetString
1936: oPop 3
1938: oJumpForward 1943
1940: Choice Lookup Table
          69   1925
1943: oJumpForward 1948
1945: Choice Lookup Table
           2   1923
1948: oReturn
1949: oLocalSpace 6
1951: oInput 0
1953: oGetAddrLocal 1
1955: oPushResult
1956: oSetResult 0
1958: oAssign
1959: oGetAddrLocal 2
1961: oPushResult
1962: oScopeFindInCurrentScope
1963: oAssign
1964: oGetLocal 2
1966: oPushResult
1967: oNodeNull
1968: oPop 1
1970: oChoice 2088
1972: oGetAddrLocal 2
1974: oPushResult
1975: oSetResult 12
1977: oPushResult
1978: LAST_ID
1979: oPushResult
1980: oCall 9792
1982: oPop 2
1984: oAssign
1985: oGetLocal 2
1987: oPushResult
1988: oSetResult 22
1990: oPushResult
1991: oLabelNew
1992: oPushResult
1993: oNodeSetLabel
1994: oPop 3
1996: oJumpForward 2094
1998: oGetAddrLocal 1
2000: oPushResult
2001: oSetResult 1
2003: oAssign
2004: oGetLocal 2
2006: oPushResult
2007: oSetResult 24
2009: oPushResult
2010: oNodeGetBoolean
2011: oPop 2
2013: oChoice 2019
2015: oError 21
2017: oJumpForward 2022
2019: Choice Lookup Table
           1   2015
2022: oGetLocal 2
2024: oPushResult
2025: oSetResult 25
2027: oPushResult
2028: oNodeGetBoolean
2029: oPop 2
2031: oChoice 2037
2033: oError 21
2035: oJumpForward 2040
2037: Choice Lookup Table
           1   2033
2040: oGetLocal 2
2042: oPushResult
2043: oNodeType
2044: oPop 1
2046: oChoice 2050
2048: oJumpForward 2055
2050: Choice Lookup Table
          12   2048
2053: oError 21
2055: oGetLocal 2
2057: oPushResult
2058: oSetResult 29
2060: oPushResult
2061: oGetLocal 2
2063: oPushResult
2064: oSetResult 23
2066: oPushResult
2067: oNodeGet
2068: oPop 2
2070: oPushResult
2071: oNodeSet
2072: oPop 3
2074: oGetLocal 2
2076: oPushResult
2077: oSetResult 23
2079: oPushResult
2080: oSetResult 0
2082: oPushResult
2083: oNodeSet
2084: oPop 3
2086: oJumpForward 2094
2088: Choice Lookup Table
           0   1998
           1   1972
2093: oEndChoice
2094: oGetAddrLocal 3
2096: oPushResult
2097: oCall 9562
2099: oAssign
2100: oGetAddrLocal 4
2102: oPushResult
2103: oGetLocal 3
2105: oPushResult
2106: oSetResult 0
2108: oPushResult
2109: greater
2110: oPop 2
2112: oAssign
2113: oGetAddrLocal 3
2115: oPushResult
2116: inc
2117: oPop 1
2119: oGetLocal 3
2121: oPushResult
2122: oSetResult 2
2124: oPushResult
2125: oScopeBegin
2126: oPop 2
2128: oGetAddrLocal 5
2130: oPushResult
2131: oScopeCurrent
2132: oAssign
2133: oGetLocal 4
2135: oChoice 2154
2137: oGetAddrLocal 6
2139: oPushResult
2140: oGetGlobal 5
2142: oPushResult
2143: oCall 9820
2145: oPop 1
2147: oPushResult
2148: oScopeAllocType
2149: oPop 1
2151: oAssign
2152: oJumpForward 2157
2154: Choice Lookup Table
           1   2137
2157: oCall 2758
2159: oGetLocal 2
2161: oPushResult
2162: oSetResult 23
2164: oPushResult
2165: oGetLocal 5
2167: oPushResult
2168: oNodeSet
2169: oPop 3
2171: oScopeEnd
2172: oInput 5
2174: oGetLocal 1
2176: oChoice 2188
2178: oGetLocal 2
2180: oPushResult
2181: oScopeDeclare
2182: oPop 1
2184: oJumpForward 2194
2186: oJumpForward 2194
2188: Choice Lookup Table
           1   2186
           0   2178
2193: oEndChoice
2194: oGetLocal 2
2196: oPushResult
2197: oCall 1807
2199: oPop 1
2201: oGetLocal 2
2203: oReturn
2204: oReturn
2205: oLocalSpace 4
2207: oGetAddrLocal 1
2209: oPushResult
2210: oCall 1949
2212: oAssign
2213: oInputChoice 2226
2215: oJumpForward 2320
2217: oGetLocal 1
2219: oPushResult
2220: oCall 1887
2222: oPop 1
2224: oJumpForward 2320
2226: Choice Lookup Table
          68   2217
          67   2215
2231: oGetAddrLocal 2
2233: oPushResult
2234: oGetLocal 1
2236: oPushResult
2237: oSetResult 23
2239: oPushResult
2240: oNodeGet
2241: oPop 2
2243: oAssign
2244: oGetLocal 2
2246: oPushResult
2247: oScopeEnter
2248: oPop 1
2250: oGetAddrLocal 3
2252: oPushResult
2253: oGetLocal 2
2255: oPushResult
2256: oSetResult 14
2258: oPushResult
2259: oNodeGetInt
2260: oPop 2
2262: oAssign
2263: oGetLocal 3
2265: oPushResult
2266: oSetResult 1
2268: oPushResult
2269: oScopeBegin
2270: oPop 2
2272: oGetLocal 1
2274: oPushResult
2275: oSetResult 6
2277: oPushResult
2278: oScopeCurrent
2279: oPushResult
2280: oNodeSet
2281: oPop 3
2283: oGetAddrLocal 4
2285: oPushResult
2286: oGetLocal 1
2288: oPushResult
2289: oSetResult 22
2291: oPushResult
2292: oNodeGetLabel
2293: oPop 2
2295: oAssign
2296: oSetResult 21
2298: oPushResult
2299: oGetLocal 4
2301: oPushResult
2302: oCall 1364
2304: oPop 2
2306: oGetLocal 1
2308: oPushResult
2309: oSetResult 24
2311: oPushResult
2312: oSetResult 1
2314: oPushResult
2315: oNodeSetBoolean
2316: oPop 3
2318: oScopeEnd
2319: oScopeEnd
2320: oInput 5
2322: oReturn
2323: oLocalSpace 8
2325: oInput 0
2327: oGetAddrLocal 1
2329: oPushResult
2330: oSetResult 0
2332: oAssign
2333: oGetAddrLocal 2
2335: oPushResult
2336: oScopeFindInCurrentScope
2337: oAssign
2338: oGetLocal 2
2340: oPushResult
2341: oNodeNull
2342: oPop 1
2344: oChoice 2475
2346: oGetAddrLocal 2
2348: oPushResult
2349: oSetResult 13
2351: oPushResult
2352: LAST_ID
2353: oPushResult
2354: oCall 9792
2356: oPop 2
2358: oAssign
2359: oGetLocal 2
2361: oPushResult
2362: oSetResult 22
2364: oPushResult
2365: oLabelNew
2366: oPushResult
2367: oNodeSetLabel
2368: oPop 3
2370: oJumpForward 2481
2372: oGetAddrLocal 1
2374: oPushResult
2375: oSetResult 1
2377: oAssign
2378: oGetLocal 2
2380: oPushResult
2381: oSetResult 24
2383: oPushResult
2384: oNodeGetBoolean
2385: oPop 2
2387: oChoice 2393
2389: oError 21
2391: oJumpForward 2396
2393: Choice Lookup Table
           1   2389
2396: oGetLocal 2
2398: oPushResult
2399: oNodeType
2400: oPop 1
2402: oChoice 2406
2404: oJumpForward 2411
2406: Choice Lookup Table
          13   2404
2409: oError 21
2411: oGetLocal 2
2413: oPushResult
2414: oSetResult 29
2416: oPushResult
2417: oGetLocal 2
2419: oPushResult
2420: oSetResult 23
2422: oPushResult
2423: oNodeGet
2424: oPop 2
2426: oPushResult
2427: oNodeSet
2428: oPop 3
2430: oGetLocal 2
2432: oPushResult
2433: oSetResult 23
2435: oPushResult
2436: oSetResult 0
2438: oPushResult
2439: oNodeSet
2440: oPop 3
2442: oGetLocal 2
2444: oPushResult
2445: oSetResult 30
2447: oPushResult
2448: oGetLocal 2
2450: oPushResult
2451: oSetResult 21
2453: oPushResult
2454: oNodeGet
2455: oPop 2
2457: oPushResult
2458: oNodeSet
2459: oPop 3
2461: oGetLocal 2
2463: oPushResult
2464: oSetResult 21
2466: oPushResult
2467: oSetResult 0
2469: oPushResult
2470: oNodeSet
2471: oPop 3
2473: oJumpForward 2481
2475: Choice Lookup Table
           0   2372
           1   2346
2480: oEndChoice
2481: oGetAddrLocal 3
2483: oPushResult
2484: oCall 9562
2486: oAssign
2487: oGetAddrLocal 4
2489: oPushResult
2490: oGetLocal 3
2492: oPushResult
2493: oSetResult 0
2495: oPushResult
2496: greater
2497: oPop 2
2499: oAssign
2500: oGetAddrLocal 3
2502: oPushResult
2503: inc
2504: oPop 1
2506: oGetLocal 3
2508: oPushResult
2509: oSetResult 2
2511: oPushResult
2512: oScopeBegin
2513: oPop 2
2515: oGetAddrLocal 5
2517: oPushResult
2518: oScopeCurrent
2519: oAssign
2520: oGetLocal 4
2522: oChoice 2541
2524: oGetAddrLocal 6
2526: oPushResult
2527: oGetGlobal 5
2529: oPushResult
2530: oCall 9820
2532: oPop 1
2534: oPushResult
2535: oScopeAllocType
2536: oPop 1
2538: oAssign
2539: oJumpForward 2544
2541: Choice Lookup Table
           1   2524
2544: oCall 2758
2546: oGetLocal 2
2548: oPushResult
2549: oSetResult 23
2551: oPushResult
2552: oGetLocal 5
2554: oPushResult
2555: oNodeSet
2556: oPop 3
2558: oInput 12
2560: oGetAddrLocal 7
2562: oPushResult
2563: oCall 3795
2565: oPop 1
2567: oGetLocal 2
2569: oPushResult
2570: oSetResult 21
2572: oPushResult
2573: oGetLocal 7
2575: oPushResult
2576: oNodeSet
2577: oPop 3
2579: oGetAddrLocal 8
2581: oPushResult
2582: oGetLocal 7
2584: oPushResult
2585: oCall 9820
2587: oPop 1
2589: oAssign
2590: oGetLocal 2
2592: oPushResult
2593: oSetResult 31
2595: oPushResult
2596: oGetLocal 8
2598: oPushResult
2599: oScopeAllocType
2600: oPop 1
2602: oPushResult
2603: oNodeSetInt
2604: oPop 3
2606: oScopeEnd
2607: oInput 5
2609: oGetLocal 1
2611: oChoice 2623
2613: oGetLocal 2
2615: oPushResult
2616: oScopeDeclare
2617: oPop 1
2619: oJumpForward 2629
2621: oJumpForward 2629
2623: Choice Lookup Table
           1   2621
           0   2613
2628: oEndChoice
2629: oGetLocal 2
2631: oPushResult
2632: oCall 1807
2634: oPop 1
2636: oGetLocal 2
2638: oReturn
2639: oReturn
2640: oLocalSpace 4
2642: oGetAddrLocal 1
2644: oPushResult
2645: oCall 2323
2647: oAssign
2648: oInputChoice 2661
2650: oJumpForward 2755
2652: oGetLocal 1
2654: oPushResult
2655: oCall 1887
2657: oPop 1
2659: oJumpForward 2755
2661: Choice Lookup Table
          68   2652
          67   2650
2666: oGetAddrLocal 2
2668: oPushResult
2669: oGetLocal 1
2671: oPushResult
2672: oSetResult 23
2674: oPushResult
2675: oNodeGet
2676: oPop 2
2678: oAssign
2679: oGetLocal 2
2681: oPushResult
2682: oScopeEnter
2683: oPop 1
2685: oGetAddrLocal 3
2687: oPushResult
2688: oGetLocal 2
2690: oPushResult
2691: oSetResult 14
2693: oPushResult
2694: oNodeGetInt
2695: oPop 2
2697: oAssign
2698: oGetLocal 3
2700: oPushResult
2701: oSetResult 1
2703: oPushResult
2704: oScopeBegin
2705: oPop 2
2707: oGetLocal 1
2709: oPushResult
2710: oSetResult 6
2712: oPushResult
2713: oScopeCurrent
2714: oPushResult
2715: oNodeSet
2716: oPop 3
2718: oGetAddrLocal 4
2720: oPushResult
2721: oGetLocal 1
2723: oPushResult
2724: oSetResult 22
2726: oPushResult
2727: oNodeGetLabel
2728: oPop 2
2730: oAssign
2731: oSetResult 21
2733: oPushResult
2734: oGetLocal 4
2736: oPushResult
2737: oCall 1364
2739: oPop 2
2741: oGetLocal 1
2743: oPushResult
2744: oSetResult 24
2746: oPushResult
2747: oSetResult 1
2749: oPushResult
2750: oNodeSetBoolean
2751: oPop 3
2753: oScopeEnd
2754: oScopeEnd
2755: oInput 5
2757: oReturn
2758: oLocalSpace 6
2760: oInputChoice 2978
2762: oGetAddrLocal 1
2764: oPushResult
2765: oNodeVecNew
2766: oAssign
2767: oGetAddrLocal 3
2769: oPushResult
2770: oSetResult 0
2772: oAssign
2773: oInputChoice 2783
2775: oGetAddrLocal 3
2777: oPushResult
2778: oSetResult 1
2780: oAssign
2781: oJumpForward 2786
2783: Choice Lookup Table
          33   2775
2786: oInput 0
2788: oGetAddrLocal 2
2790: oPushResult
2791: oSetResult 23
2793: oPushResult
2794: LAST_ID
2795: oPushResult
2796: oCall 9792
2798: oPop 2
2800: oAssign
2801: oGetLocal 2
2803: oPushResult
2804: oSetResult 33
2806: oPushResult
2807: oGetLocal 3
2809: oPushResult
2810: oNodeSetBoolean
2811: oPop 3
2813: oGetLocal 1
2815: oPushResult
2816: oGetLocal 2
2818: oPushResult
2819: oNodeVecAppend
2820: oPop 2
2822: oInputChoice 2830
2824: oJumpForward 2838
2826: oJumpForward 2836
2828: oJumpForward 2836
2830: Choice Lookup Table
          13   2828
          12   2824
2835: oEndChoice
2836: oJumpBack 2786
2838: oGetAddrLocal 4
2840: oPushResult
2841: oCall 3795
2843: oPop 1
2845: oGetLocal 3
2847: oChoice 2862
2849: oGetAddrLocal 5
2851: oPushResult
2852: oGetLocal 4
2854: oPushResult
2855: oCall 9820
2857: oPop 1
2859: oAssign
2860: oJumpForward 2871
2862: Choice Lookup Table
           1   2849
2865: oGetAddrLocal 5
2867: oPushResult
2868: oGetLocal 4
2870: oAssign
2871: oGetAddrLocal 6
2873: oPushResult
2874: oSetResult 0
2876: oAssign
2877: oGetLocal 6
2879: oPushResult
2880: oGetLocal 1
2882: oPushResult
2883: oNodeVecSize
2884: oPop 1
2886: oPushResult
2887: equal
2888: oPop 2
2890: oChoice 2947
2892: oGetAddrLocal 2
2894: oPushResult
2895: oGetLocal 1
2897: oPushResult
2898: oGetLocal 6
2900: oPushResult
2901: oNodeVecElement
2902: oPop 2
2904: oAssign
2905: oGetLocal 2
2907: oPushResult
2908: oSetResult 21
2910: oPushResult
2911: oGetLocal 4
2913: oPushResult
2914: oNodeSet
2915: oPop 3
2917: oGetLocal 2
2919: oPushResult
2920: oScopeDeclare
2921: oPop 1
2923: oGetLocal 2
2925: oPushResult
2926: oSetResult 22
2928: oPushResult
2929: oGetLocal 5
2931: oPushResult
2932: oScopeAllocType
2933: oPop 1
2935: oPushResult
2936: oNodeSetInt
2937: oPop 3
2939: oGetAddrLocal 6
2941: oPushResult
2942: inc
2943: oPop 1
2945: oJumpForward 2952
2947: Choice Lookup Table
           0   2892
2950: oJumpForward 2954
2952: oJumpBack 2877
2954: oGetLocal 1
2956: oPushResult
2957: oNodeVecDelete
2958: oPop 1
2960: oInputChoice 2968
2962: oJumpForward 2976
2964: oJumpForward 2974
2966: oJumpForward 2974
2968: Choice Lookup Table
           5   2966
          15   2962
2973: oEndChoice
2974: oJumpBack 2762
2976: oJumpForward 2981
2978: Choice Lookup Table
          14   2762
2981: oReturn
2982: oLocalSpace 0
2984: oInputChoice 2999
2986: oInputChoice 2992
2988: oCall 3065
2990: oJumpForward 2997
2992: Choice Lookup Table
          12   2988
2995: oCall 3007
2997: oJumpForward 3004
2999: Choice Lookup Table
           0   2986
3002: oJumpForward 3006
3004: oJumpBack 2984
3006: oReturn
3007: oLocalSpace 2
3009: oGetAddrLocal 1
3011: oPushResult
3012: oSetResult 16
3014: oPushResult
3015: LAST_ID
3016: oPushResult
3017: oCall 9792
3019: oPop 2
3021: oAssign
3022: oInput 6
3024: oCall 4851
3026: oGetAddrLocal 2
3028: oPushResult
3029: oValueTop
3030: oAssign
3031: oValuePop
3032: oGetLocal 1
3034: oPushResult
3035: oSetResult 22
3037: oPushResult
3038: oGetLocal 2
3040: oPushResult
3041: oNodeSetInt
3042: oPop 3
3044: oGetLocal 1
3046: oPushResult
3047: oSetResult 21
3049: oPushResult
3050: oGetGlobal 5
3052: oPushResult
3053: oNodeSet
3054: oPop 3
3056: oGetLocal 1
3058: oPushResult
3059: oScopeDeclare
3060: oPop 1
3062: oInput 5
3064: oReturn
3065: oLocalSpace 4
3067: oGetAddrLocal 1
3069: oPushResult
3070: oSetResult 24
3072: oPushResult
3073: LAST_ID
3074: oPushResult
3075: oCall 9792
3077: oPop 2
3079: oAssign
3080: oGetAddrLocal 2
3082: oPushResult
3083: oCall 3795
3085: oPop 1
3087: oGetLocal 1
3089: oPushResult
3090: oSetResult 21
3092: oPushResult
3093: oGetLocal 2
3095: oPushResult
3096: oNodeSet
3097: oPop 3
3099: oGetLocal 2
3101: oPushResult
3102: oNodeType
3103: oPop 1
3105: oChoice 3206
3107: oInput 6
3109: oCall 4851
3111: oGetAddrLocal 3
3113: oPushResult
3114: oValueTop
3115: oAssign
3116: oValuePop
3117: oGetLocal 1
3119: oPushResult
3120: oSetResult 22
3122: oPushResult
3123: oGetLocal 3
3125: oPushResult
3126: oNodeSetInt
3127: oPop 3
3129: oGetLocal 1
3131: oPushResult
3132: oScopeDeclare
3133: oPop 1
3135: oInput 5
3137: oJumpForward 3228
3139: oError 16
3141: oJumpForward 3228
3143: oGetGlobal 2
3145: oPushResult
3146: oScopeEnter
3147: oPop 1
3149: oGetAddrLocal 4
3151: oPushResult
3152: oGetLocal 2
3154: oPushResult
3155: oScopeAllocType
3156: oPop 1
3158: oAssign
3159: oScopeEnd
3160: oGetGlobal 2
3162: oPushResult
3163: oCall 1835
3165: oPop 1
3167: oPushResult
3168: oCodePush
3169: oPop 1
3171: oGetLocal 1
3173: oPushResult
3174: oSetResult 22
3176: oPushResult
3177: oGetLocal 4
3179: oPushResult
3180: oNodeSetInt
3181: oPop 3
3183: oInput 6
3185: oGetLocal 2
3187: oPushResult
3188: oGetLocal 4
3190: oPushResult
3191: oCall 3229
3193: oPop 2
3195: oCodePop
3196: oGetLocal 1
3198: oPushResult
3199: oScopeDeclare
3200: oPop 1
3202: oInput 5
3204: oJumpForward 3228
3206: Choice Lookup Table
          37   3143
          35   3143
          34   3139
          27   3139
          33   3139
          38   3107
          28   3107
          32   3107
          29   3107
          30   3107
3227: oEndChoice
3228: oReturn
3229: oLocalSpace 6
3231: oGetParam 2
3233: oPushResult
3234: oNodeType
3235: oPop 1
3237: oChoice 3420
3239: oGetAddrLocal 1
3241: oPushResult
3242: oGetParam 2
3244: oPushResult
3245: oSetResult 36
3247: oPushResult
3248: oNodeGet
3249: oPop 2
3251: oAssign
3252: oGetAddrLocal 2
3254: oPushResult
3255: oGetParam 2
3257: oPushResult
3258: oSetResult 37
3260: oPushResult
3261: oNodeGet
3262: oPop 2
3264: oAssign
3265: oGetAddrLocal 3
3267: oPushResult
3268: oGetLocal 2
3270: oPushResult
3271: oCall 9904
3273: oPop 1
3275: oAssign
3276: oGetAddrLocal 4
3278: oPushResult
3279: oGetLocal 2
3281: oPushResult
3282: oCall 9999
3284: oPop 1
3286: oAssign
3287: oGetAddrLocal 5
3289: oPushResult
3290: oGetLocal 1
3292: oPushResult
3293: oSetResult 17
3295: oPushResult
3296: oNodeGetInt
3297: oPop 2
3299: oAssign
3300: oInput 14
3302: oGetAddrLocal 6
3304: oPushResult
3305: oGetLocal 3
3307: oAssign
3308: oGetLocal 1
3310: oPushResult
3311: oGetParam 1
3313: oPushResult
3314: oCall 3229
3316: oPop 2
3318: oGetLocal 6
3320: oPushResult
3321: oGetLocal 4
3323: oPushResult
3324: equal
3325: oPop 2
3327: oChoice 3335
3329: oJumpForward 3364
3331: oJumpForward 3341
3333: oJumpForward 3341
3335: Choice Lookup Table
           0   3333
           1   3329
3340: oEndChoice
3341: oInput 13
3343: oGetAddrParam 1
3345: oPushResult
3346: oGetParam 1
3348: oPushResult
3349: oGetLocal 5
3351: oPushResult
3352: add
3353: oPop 2
3355: oAssign
3356: oGetAddrLocal 6
3358: oPushResult
3359: inc
3360: oPop 1
3362: oJumpBack 3308
3364: oInput 15
3366: oJumpForward 3442
3368: oError 16
3370: oJumpForward 3442
3372: oEmit 16
3374: oGetParam 1
3376: oPushResult
3377: oEmitInt
3378: oPop 1
3380: oCall 4851
3382: oEmit 15
3384: oValueTop
3385: oPushResult
3386: oEmitInt
3387: oPop 1
3389: oValuePop
3390: oEmit 26
3392: oJumpForward 3442
3394: oEmit 16
3396: oGetParam 1
3398: oPushResult
3399: oEmitInt
3400: oPop 1
3402: oCall 4851
3404: oEmit 15
3406: oValueTop
3407: oPushResult
3408: oEmitInt
3409: oPop 1
3411: oValuePop
3412: oEmit 25
3414: oJumpForward 3442
3416: oError 16
3418: oJumpForward 3442
3420: Choice Lookup Table
          34   3416
          27   3416
          33   3416
          38   3394
          28   3394
          32   3372
          29   3372
          30   3372
          37   3368
          35   3239
3441: oEndChoice
3442: oReturn
3443: oLocalSpace 2
3445: oInputChoice 3491
3447: oGetAddrLocal 1
3449: oPushResult
3450: oSetResult 18
3452: oPushResult
3453: LAST_ID
3454: oPushResult
3455: oCall 9792
3457: oPop 2
3459: oAssign
3460: oInput 6
3462: oGetAddrLocal 2
3464: oPushResult
3465: oCall 3795
3467: oPop 1
3469: oGetLocal 1
3471: oPushResult
3472: oSetResult 21
3474: oPushResult
3475: oGetLocal 2
3477: oPushResult
3478: oNodeSet
3479: oPop 3
3481: oGetLocal 1
3483: oPushResult
3484: oScopeDeclare
3485: oPop 1
3487: oInput 5
3489: oJumpForward 3496
3491: Choice Lookup Table
           0   3447
3494: oJumpForward 3498
3496: oJumpBack 3445
3498: oReturn
3499: oLocalSpace 6
3501: oInputChoice 3722
3503: oGetAddrLocal 1
3505: oPushResult
3506: oNodeVecNew
3507: oAssign
3508: oGetAddrLocal 2
3510: oPushResult
3511: oGetParam 1
3513: oPushResult
3514: LAST_ID
3515: oPushResult
3516: oCall 9792
3518: oPop 2
3520: oAssign
3521: oGetLocal 1
3523: oPushResult
3524: oGetLocal 2
3526: oPushResult
3527: oNodeVecAppend
3528: oPop 2
3530: oInputChoice 3536
3532: oInput 0
3534: oJumpForward 3541
3536: Choice Lookup Table
          13   3532
3539: oJumpForward 3543
3541: oJumpBack 3508
3543: oInput 12
3545: oGetAddrLocal 3
3547: oPushResult
3548: oCall 3795
3550: oPop 1
3552: oGetAddrLocal 4
3554: oPushResult
3555: oSetResult 0
3557: oAssign
3558: oGetLocal 4
3560: oPushResult
3561: oGetLocal 1
3563: oPushResult
3564: oNodeVecSize
3565: oPop 1
3567: oPushResult
3568: equal
3569: oPop 2
3571: oChoice 3612
3573: oGetAddrLocal 2
3575: oPushResult
3576: oGetLocal 1
3578: oPushResult
3579: oGetLocal 4
3581: oPushResult
3582: oNodeVecElement
3583: oPop 2
3585: oAssign
3586: oGetLocal 2
3588: oPushResult
3589: oSetResult 21
3591: oPushResult
3592: oGetLocal 3
3594: oPushResult
3595: oNodeSet
3596: oPop 3
3598: oGetLocal 2
3600: oPushResult
3601: oScopeDeclareAlloc
3602: oPop 1
3604: oGetAddrLocal 4
3606: oPushResult
3607: inc
3608: oPop 1
3610: oJumpForward 3617
3612: Choice Lookup Table
           0   3573
3615: oJumpForward 3619
3617: oJumpBack 3558
3619: oInputChoice 3709
3621: oGetLocal 1
3623: oPushResult
3624: oNodeVecSize
3625: oPop 1
3627: oChoice 3631
3629: oJumpForward 3636
3631: Choice Lookup Table
           1   3629
3634: oError 22
3636: oGetAddrLocal 5
3638: oPushResult
3639: oScopeCurrent
3640: oPushResult
3641: oCall 1835
3643: oPop 1
3645: oAssign
3646: oGetLocal 5
3648: oPushResult
3649: oCodePush
3650: oPop 1
3652: oGetAddrLocal 6
3654: oPushResult
3655: oSetResult 0
3657: oAssign
3658: oCall 9562
3660: oPushResult
3661: equal_zero
3662: oPop 1
3664: oChoice 3680
3666: oGetGlobal 3
3668: oPushResult
3669: oScopeEnter
3670: oPop 1
3672: oGetAddrLocal 6
3674: oPushResult
3675: oSetResult 1
3677: oAssign
3678: oJumpForward 3683
3680: Choice Lookup Table
           1   3666
3683: oGetLocal 2
3685: oPushResult
3686: oCall 8797
3688: oPop 1
3690: oCall 4924
3692: oCall 9612
3694: oCall 8562
3696: oGetLocal 6
3698: oChoice 3703
3700: oScopeEnd
3701: oJumpForward 3706
3703: Choice Lookup Table
           1   3700
3706: oCodePop
3707: oJumpForward 3712
3709: Choice Lookup Table
           6   3621
3712: oGetLocal 1
3714: oPushResult
3715: oNodeVecDelete
3716: oPop 1
3718: oInput 5
3720: oJumpForward 3727
3722: Choice Lookup Table
           0   3503
3725: oJumpForward 3729
3727: oJumpBack 3501
3729: oReturn
3730: oLocalSpace 2
3732: oInputChoice 3739
3734: oJumpForward 3745
3736: oChangeIntLitToLabelIdent
3737: oJumpForward 3745
3739: Choice Lookup Table
           1   3736
           0   3734
3744: oEndChoice
3745: oGetAddrLocal 1
3747: oPushResult
3748: oSetResult 25
3750: oPushResult
3751: LAST_ID
3752: oPushResult
3753: oCall 9792
3755: oPop 2
3757: oAssign
3758: oGetAddrLocal 2
3760: oPushResult
3761: oLabelNew
3762: oAssign
3763: oGetLocal 1
3765: oPushResult
3766: oSetResult 22
3768: oPushResult
3769: oGetLocal 2
3771: oPushResult
3772: oNodeSetLabel
3773: oPop 3
3775: oGetLocal 1
3777: oPushResult
3778: oScopeDeclare
3779: oPop 1
3781: oInputChoice 3785
3783: oJumpForward 3790
3785: Choice Lookup Table
          13   3783
3788: oJumpForward 3792
3790: oJumpBack 3732
3792: oInput 5
3794: oReturn
3795: oLocalSpace 12
3797: oInputChoice 4270
3799: oGetAddrLocal 1
3801: oPushResult
3802: oScopeFindRequire
3803: oAssign
3804: oGetAddrLocal 1
3806: oPushResult
3807: oCall 409
3809: oPop 1
3811: oGetLocal 1
3813: oPushResult
3814: oNodeType
3815: oPop 1
3817: oChoice 3834
3819: oGetParam 1
3821: oPushResult
3822: oGetLocal 1
3824: oPushResult
3825: oSetResult 21
3827: oPushResult
3828: oNodeGet
3829: oPop 2
3831: oAssign
3832: oJumpForward 3845
3834: Choice Lookup Table
          18   3819
3837: oError 2
3839: oGetParam 1
3841: oPushResult
3842: oGetGlobal 5
3844: oAssign
3845: oJumpForward 4289
3847: oInput 16
3849: oGetAddrLocal 2
3851: oPushResult
3852: oNodeVecNew
3853: oAssign
3854: oGetAddrLocal 3
3856: oPushResult
3857: oSetResult 36
3859: oPushResult
3860: oNodeNew
3861: oPop 1
3863: oAssign
3864: oGetLocal 3
3866: oPushResult
3867: oSetResult 36
3869: oPushResult
3870: oGetGlobal 5
3872: oPushResult
3873: oNodeSet
3874: oPop 3
3876: oCall 4851
3878: oGetLocal 3
3880: oPushResult
3881: oSetResult 38
3883: oPushResult
3884: oValueTop
3885: oPushResult
3886: oNodeSetInt
3887: oPop 3
3889: oValuePop
3890: oInput 21
3892: oCall 4851
3894: oGetLocal 3
3896: oPushResult
3897: oSetResult 39
3899: oPushResult
3900: oValueTop
3901: oPushResult
3902: oNodeSetInt
3903: oPop 3
3905: oValuePop
3906: oGetLocal 3
3908: oPushResult
3909: oSetResult 17
3911: oPushResult
3912: oSetResult 4
3914: oPushResult
3915: oNodeSetInt
3916: oPop 3
3918: oGetLocal 3
3920: oPushResult
3921: oTypeAdd
3922: oPop 1
3924: oGetAddrLocal 4
3926: oPushResult
3927: oSetResult 35
3929: oPushResult
3930: oNodeNew
3931: oPop 1
3933: oAssign
3934: oGetLocal 4
3936: oPushResult
3937: oSetResult 37
3939: oPushResult
3940: oGetLocal 3
3942: oPushResult
3943: oNodeSet
3944: oPop 3
3946: oGetLocal 2
3948: oPushResult
3949: oGetLocal 4
3951: oPushResult
3952: oNodeVecAppend
3953: oPop 2
3955: oInputChoice 3963
3957: oJumpForward 3971
3959: oJumpForward 3969
3961: oJumpForward 3969
3963: Choice Lookup Table
          13   3961
          17   3957
3968: oEndChoice
3969: oJumpBack 3854
3971: oInput 40
3973: oGetAddrLocal 5
3975: oPushResult
3976: oCall 3795
3978: oPop 1
3980: oGetAddrLocal 6
3982: oPushResult
3983: oGetLocal 2
3985: oPushResult
3986: oNodeVecSize
3987: oPop 1
3989: oAssign
3990: oGetAddrLocal 6
3992: oPushResult
3993: dec
3994: oPop 1
3996: oGetAddrLocal 7
3998: oPushResult
3999: oGetLocal 2
4001: oPushResult
4002: oGetLocal 6
4004: oPushResult
4005: oNodeVecElement
4006: oPop 2
4008: oAssign
4009: oGetLocal 7
4011: oPushResult
4012: oSetResult 36
4014: oPushResult
4015: oGetLocal 5
4017: oPushResult
4018: oNodeSet
4019: oPop 3
4021: oGetAddrLocal 8
4023: oPushResult
4024: oGetLocal 7
4026: oPushResult
4027: oSetResult 37
4029: oPushResult
4030: oNodeGet
4031: oPop 2
4033: oAssign
4034: oGetAddrLocal 9
4036: oPushResult
4037: oGetLocal 8
4039: oPushResult
4040: oSetResult 39
4042: oPushResult
4043: oNodeGetInt
4044: oPop 2
4046: oPushResult
4047: oGetLocal 8
4049: oPushResult
4050: oSetResult 38
4052: oPushResult
4053: oNodeGetInt
4054: oPop 2
4056: oPushResult
4057: subtract
4058: oPop 2
4060: oAssign
4061: oGetAddrLocal 9
4063: oPushResult
4064: inc
4065: oPop 1
4067: oGetLocal 7
4069: oPushResult
4070: oSetResult 17
4072: oPushResult
4073: oGetLocal 9
4075: oPushResult
4076: oGetLocal 5
4078: oPushResult
4079: oSetResult 17
4081: oPushResult
4082: oNodeGetInt
4083: oPop 2
4085: oPushResult
4086: multiply
4087: oPop 2
4089: oPushResult
4090: oNodeSetInt
4091: oPop 3
4093: oGetLocal 7
4095: oPushResult
4096: oTypeAdd
4097: oPop 1
4099: oGetAddrLocal 5
4101: oPushResult
4102: oGetLocal 7
4104: oAssign
4105: oGetLocal 6
4107: oPushResult
4108: equal_zero
4109: oPop 1
4111: oChoice 4117
4113: oJumpForward 4122
4115: oJumpForward 4120
4117: Choice Lookup Table
           1   4113
4120: oJumpBack 3990
4122: oGetParam 1
4124: oPushResult
4125: oGetLocal 2
4127: oPushResult
4128: oSetResult 0
4130: oPushResult
4131: oNodeVecElement
4132: oPop 2
4134: oAssign
4135: oGetLocal 2
4137: oPushResult
4138: oNodeVecDelete
4139: oPop 1
4141: oJumpForward 4289
4143: oGetAddrLocal 10
4145: oPushResult
4146: oCall 3795
4148: oPop 1
4150: oGetParam 1
4152: oPushResult
4153: oGetLocal 10
4155: oPushResult
4156: oCall 9820
4158: oPop 1
4160: oAssign
4161: oJumpForward 4289
4163: oGetParam 1
4165: oPushResult
4166: oSetResult 37
4168: oPushResult
4169: oNodeNew
4170: oPop 1
4172: oAssign
4173: oSetResult -1
4175: oPushResult
4176: oSetResult 2
4178: oPushResult
4179: oScopeBegin
4180: oPop 2
4182: oSetResult 22
4184: oPushResult
4185: oCall 3499
4187: oPop 1
4189: oGetAddrLocal 11
4191: oPushResult
4192: oScopeCurrent
4193: oPushResult
4194: oSetResult 17
4196: oPushResult
4197: oNodeGetInt
4198: oPop 2
4200: oAssign
4201: oGetLocal 11
4203: oPushResult
4204: equal_zero
4205: oPop 1
4207: oChoice 4213
4209: oError 19
4211: oJumpForward 4216
4213: Choice Lookup Table
           1   4209
4216: oInput 36
4218: oGetFromParam 1
4220: oPushResult
4221: oSetResult 40
4223: oPushResult
4224: oScopeCurrent
4225: oPushResult
4226: oNodeSet
4227: oPop 3
4229: oGetFromParam 1
4231: oPushResult
4232: oSetResult 17
4234: oPushResult
4235: oGetLocal 11
4237: oPushResult
4238: oNodeSetInt
4239: oPop 3
4241: oScopeEnd
4242: oGetFromParam 1
4244: oPushResult
4245: oTypeAdd
4246: oPop 1
4248: oJumpForward 4289
4250: oGetParam 1
4252: oPushResult
4253: oCall 4290
4255: oPop 1
4257: oJumpForward 4289
4259: oInput 40
4261: oGetAddrLocal 12
4263: oPushResult
4264: oCall 3795
4266: oPop 1
4268: oJumpForward 4289
4270: Choice Lookup Table
          39   4259
          14   4250
          38   4163
          18   4143
          37   3847
           0   3799
4283: oCall 4851
4285: oInput 21
4287: oCall 4851
4289: oReturn
4290: oLocalSpace 11
4292: oGetParam 1
4294: oPushResult
4295: oSetResult 38
4297: oPushResult
4298: oNodeNew
4299: oPop 1
4301: oAssign
4302: oGetAddrLocal 1
4304: oPushResult
4305: oSetResult 0
4307: oAssign
4308: oGetAddrLocal 2
4310: oPushResult
4311: oSetResult 0
4313: oAssign
4314: oGetAddrLocal 3
4316: oPushResult
4317: oSetResult 1
4319: oAssign
4320: oGetAddrLocal 4
4322: oPushResult
4323: oScopeCurrent
4324: oAssign
4325: oSetResult -1
4327: oPushResult
4328: oSetResult 2
4330: oPushResult
4331: oScopeBegin
4332: oPop 2
4334: oInput 0
4336: oGetAddrLocal 5
4338: oPushResult
4339: oSetResult 17
4341: oPushResult
4342: LAST_ID
4343: oPushResult
4344: oCall 9792
4346: oPop 2
4348: oAssign
4349: oGetAddrLocal 6
4351: oPushResult
4352: oSetResult 17
4354: oPushResult
4355: LAST_ID
4356: oPushResult
4357: oCall 9792
4359: oPop 2
4361: oAssign
4362: oGetLocal 5
4364: oPushResult
4365: oSetResult 21
4367: oPushResult
4368: oGetFromParam 1
4370: oPushResult
4371: oNodeSet
4372: oPop 3
4374: oGetLocal 6
4376: oPushResult
4377: oSetResult 21
4379: oPushResult
4380: oGetFromParam 1
4382: oPushResult
4383: oNodeSet
4384: oPop 3
4386: oGetAddrLocal 7
4388: oPushResult
4389: LAST_ID
4390: oPushResult
4391: ID_STRING
4392: oPop 1
4394: oPushResult
4395: oStringAllocLit
4396: oPop 1
4398: oAssign
4399: oGetLocal 5
4401: oPushResult
4402: oSetResult 32
4404: oPushResult
4405: oGetLocal 7
4407: oPushResult
4408: oNodeSetInt
4409: oPop 3
4411: oGetLocal 6
4413: oPushResult
4414: oSetResult 32
4416: oPushResult
4417: oGetLocal 7
4419: oPushResult
4420: oNodeSetInt
4421: oPop 3
4423: oInputChoice 4492
4425: oCall 4851
4427: oGetLocal 2
4429: oPushResult
4430: equal_zero
4431: oPop 1
4433: oChoice 4454
4435: oValueTop
4436: oPushResult
4437: oGetLocal 1
4439: oPushResult
4440: greater
4441: oPop 2
4443: oChoice 4449
4445: oError 26
4447: oJumpForward 4452
4449: Choice Lookup Table
           0   4445
4452: oJumpForward 4457
4454: Choice Lookup Table
           0   4435
4457: oGetLocal 1
4459: oPushResult
4460: oValueTop
4461: oPushResult
4462: equal
4463: oPop 2
4465: oChoice 4481
4467: oGetFromParam 1
4469: oPushResult
4470: oSetResult 42
4472: oPushResult
4473: oSetResult 1
4475: oPushResult
4476: oNodeSetBoolean
4477: oPop 3
4479: oJumpForward 4484
4481: Choice Lookup Table
           0   4467
4484: oGetAddrLocal 1
4486: oPushResult
4487: oValueTop
4488: oAssign
4489: oValuePop
4490: oJumpForward 4497
4492: Choice Lookup Table
           4   4425
           6   4425
4497: oGetLocal 5
4499: oPushResult
4500: oSetResult 22
4502: oPushResult
4503: oGetLocal 1
4505: oPushResult
4506: oNodeSetInt
4507: oPop 3
4509: oGetLocal 6
4511: oPushResult
4512: oSetResult 22
4514: oPushResult
4515: oGetLocal 1
4517: oPushResult
4518: oNodeSetInt
4519: oPop 3
4521: oGetLocal 5
4523: oPushResult
4524: oScopeDeclare
4525: oPop 1
4527: oGetLocal 4
4529: oPushResult
4530: oScopeEnter
4531: oPop 1
4533: oGetLocal 6
4535: oPushResult
4536: oScopeDeclare
4537: oPop 1
4539: oScopeEnd
4540: oGetAddrLocal 1
4542: oPushResult
4543: inc
4544: oPop 1
4546: oGetAddrLocal 2
4548: oPushResult
4549: inc
4550: oPop 1
4552: oInputChoice 4556
4554: oJumpForward 4561
4556: Choice Lookup Table
          13   4554
4559: oJumpForward 4563
4561: oJumpBack 4334
4563: oInput 15
4565: oGetFromParam 1
4567: oPushResult
4568: oSetResult 40
4570: oPushResult
4571: oScopeCurrent
4572: oPushResult
4573: oNodeSet
4574: oPop 3
4576: oGetFromParam 1
4578: oPushResult
4579: oSetResult 17
4581: oPushResult
4582: oSetResult 4
4584: oPushResult
4585: oNodeSetInt
4586: oPop 3
4588: oScopeEnd
4589: oGetGlobal 2
4591: oPushResult
4592: oCall 1835
4594: oPop 1
4596: oPushResult
4597: oCodePush
4598: oPop 1
4600: oGetGlobal 2
4602: oPushResult
4603: oScopeEnter
4604: oPop 1
4606: oGetAddrLocal 8
4608: oPushResult
4609: oGetLocal 2
4611: oPushResult
4612: oSetResult 1
4614: oPushResult
4615: add
4616: oPop 2
4618: oPushResult
4619: oSetResult 16
4621: oPushResult
4622: multiply
4623: oPop 2
4625: oAssign
4626: oGetAddrLocal 9
4628: oPushResult
4629: oGetLocal 8
4631: oPushResult
4632: oSetResult 8
4634: oPushResult
4635: oScopeAlloc
4636: oPop 2
4638: oAssign
4639: oScopeEnd
4640: oGetFromParam 1
4642: oPushResult
4643: oSetResult 41
4645: oPushResult
4646: oGetLocal 9
4648: oPushResult
4649: oNodeSetInt
4650: oPop 3
4652: oGetAddrLocal 10
4654: oPushResult
4655: oGetFromParam 1
4657: oPushResult
4658: oSetResult 40
4660: oPushResult
4661: oNodeGet
4662: oPop 2
4664: oPushResult
4665: oSetResult 15
4667: oPushResult
4668: oNodeGetIter
4669: oPop 2
4671: oAssign
4672: oGetAddrLocal 11
4674: oPushResult
4675: oGetLocal 10
4677: oPushResult
4678: oNodeIterValue
4679: oPop 1
4681: oAssign
4682: oGetLocal 11
4684: oPushResult
4685: oNodeNull
4686: oPop 1
4688: oChoice 4694
4690: oJumpForward 4781
4692: oJumpForward 4697
4694: Choice Lookup Table
           1   4690
4697: oEmit 16
4699: oGetLocal 9
4701: oPushResult
4702: oEmitInt
4703: oPop 1
4705: oEmit 15
4707: oGetLocal 11
4709: oPushResult
4710: oSetResult 22
4712: oPushResult
4713: oNodeGetInt
4714: oPop 2
4716: oPushResult
4717: oEmitInt
4718: oPop 1
4720: oEmit 25
4722: oGetAddrLocal 9
4724: oPushResult
4725: oGetLocal 9
4727: oPushResult
4728: oSetResult 8
4730: oPushResult
4731: add
4732: oPop 2
4734: oAssign
4735: oEmit 16
4737: oGetLocal 9
4739: oPushResult
4740: oEmitInt
4741: oPop 1
4743: oEmit 16
4745: oGetLocal 11
4747: oPushResult
4748: oSetResult 32
4750: oPushResult
4751: oNodeGetInt
4752: oPop 2
4754: oPushResult
4755: oEmitInt
4756: oPop 1
4758: oEmit 27
4760: oGetAddrLocal 9
4762: oPushResult
4763: oGetLocal 9
4765: oPushResult
4766: oSetResult 8
4768: oPushResult
4769: add
4770: oPop 2
4772: oAssign
4773: oGetAddrLocal 10
4775: oPushResult
4776: oNodeIterNext
4777: oPop 1
4779: oJumpBack 4672
4781: oEmit 16
4783: oGetLocal 9
4785: oPushResult
4786: oEmitInt
4787: oPop 1
4789: oEmit 15
4791: oSetResult 0
4793: oPushResult
4794: oEmitInt
4795: oPop 1
4797: oEmit 25
4799: oGetAddrLocal 9
4801: oPushResult
4802: oGetLocal 9
4804: oPushResult
4805: oSetResult 8
4807: oPushResult
4808: add
4809: oPop 2
4811: oAssign
4812: oEmit 16
4814: oGetLocal 9
4816: oPushResult
4817: oEmitInt
4818: oPop 1
4820: oEmit 15
4822: oSetResult 0
4824: oPushResult
4825: oEmitInt
4826: oPop 1
4828: oEmit 27
4830: oGetAddrLocal 9
4832: oPushResult
4833: oGetLocal 9
4835: oPushResult
4836: oSetResult 8
4838: oPushResult
4839: add
4840: oPop 2
4842: oAssign
4843: oCodePop
4844: oGetFromParam 1
4846: oPushResult
4847: oTypeAdd
4848: oPop 1
4850: oReturn
4851: oLocalSpace 1
4853: oInputChoice 4915
4855: TOKEN_VALUE
4856: oPushResult
4857: oValuePush
4858: oPop 1
4860: oJumpForward 4923
4862: oGetAddrLocal 1
4864: oPushResult
4865: oScopeFindRequire
4866: oAssign
4867: oGetAddrLocal 1
4869: oPushResult
4870: oCall 409
4872: oPop 1
4874: oGetLocal 1
4876: oPushResult
4877: oNodeType
4878: oPop 1
4880: oChoice 4897
4882: oGetLocal 1
4884: oPushResult
4885: oSetResult 22
4887: oPushResult
4888: oNodeGetInt
4889: oPop 2
4891: oPushResult
4892: oValuePush
4893: oPop 1
4895: oJumpForward 4908
4897: Choice Lookup Table
          16   4882
4900: oError 1
4902: oSetResult 0
4904: oPushResult
4905: oValuePush
4906: oPop 1
4908: oJumpForward 4923
4910: oCall 4851
4912: oValueNegate
4913: oJumpForward 4923
4915: Choice Lookup Table
          25   4910
           0   4862
           1   4855
4922: oEndChoice
4923: oReturn
4924: oLocalSpace 1
4926: oGetAddrLocal 1
4928: oPushResult
4929: oSetResult 0
4931: oAssign
4932: oGetAddrLocal 1
4934: oPushResult
4935: oCall 5085
4937: oPop 1
4939: oGetAddrLocal 1
4941: oPushResult
4942: oCall 4985
4944: oPop 1
4946: oReturn
4947: oLocalSpace 0
4949: oGetParam 1
4951: oPushResult
4952: oCall 5085
4954: oPop 1
4956: oTypeSNodeType
4957: oChoice 4976
4959: oJumpForward 4983
4961: oGetParam 1
4963: oPushResult
4964: oLabelNew
4965: oAssign
4966: oEmit 57
4968: oGetFromParam 1
4970: oPushResult
4971: oEmitLabel
4972: oPop 1
4974: oJumpForward 4983
4976: Choice Lookup Table
          30   4961
          31   4959
4981: oError 8
4983: oTypeSPop
4984: oReturn
4985: oLocalSpace 1
4987: oTypeSNodeType
4988: oChoice 5050
4990: oGetAddrLocal 1
4992: oPushResult
4993: oLabelNew
4994: oAssign
4995: oEmit 15
4997: oSetResult 1
4999: oPushResult
5000: oEmitInt
5001: oPop 1
5003: oEmit 55
5005: oGetLocal 1
5007: oPushResult
5008: oEmitLabel
5009: oPop 1
5011: oEmit 58
5013: oGetFromParam 1
5015: oPushResult
5016: oEmitLabel
5017: oPop 1
5019: oEmit 15
5021: oSetResult 0
5023: oPushResult
5024: oEmitInt
5025: oPop 1
5027: oEmit 58
5029: oGetLocal 1
5031: oPushResult
5032: oEmitLabel
5033: oPop 1
5035: oTypeSPop
5036: oGetGlobal 6
5038: oPushResult
5039: oTypeSPush
5040: oPop 1
5042: oGetParam 1
5044: oPushResult
5045: oSetResult 0
5047: oAssign
5048: oJumpForward 5053
5050: Choice Lookup Table
          31   4990
5053: oReturn
5054: oLocalSpace 0
5056: oTypeSNodeType
5057: oChoice 5081
5059: oGetParam 1
5061: oPushResult
5062: oLabelNew
5063: oAssign
5064: oEmit 57
5066: oGetFromParam 1
5068: oPushResult
5069: oEmitLabel
5070: oPop 1
5072: oTypeSPop
5073: oGetGlobal 7
5075: oPushResult
5076: oTypeSPush
5077: oPop 1
5079: oJumpForward 5084
5081: Choice Lookup Table
          30   5059
5084: oReturn
5085: oLocalSpace 0
5087: oGetParam 1
5089: oPushResult
5090: oCall 5486
5092: oPop 1
5094: oInputChoice 5468
5096: oGetParam 1
5098: oPushResult
5099: oCall 4985
5101: oPop 1
5103: oCall 9711
5105: oGetParam 1
5107: oPushResult
5108: oCall 5486
5110: oPop 1
5112: oGetParam 1
5114: oPushResult
5115: oCall 4985
5117: oPop 1
5119: oCall 9711
5121: oCall 9612
5123: oTypeSNodeType
5124: oChoice 5138
5126: oEmit 40
5128: oJumpForward 5153
5130: oEmit 46
5132: oJumpForward 5153
5134: oError 16
5136: oJumpForward 5153
5138: Choice Lookup Table
          33   5134
          32   5134
          34   5130
          30   5126
          38   5126
          28   5126
5151: oError 17
5153: oTypeSPop
5154: oGetGlobal 6
5156: oPushResult
5157: oTypeSPush
5158: oPop 1
5160: oJumpForward 5483
5162: oGetParam 1
5164: oPushResult
5165: oCall 4985
5167: oPop 1
5169: oCall 9711
5171: oGetParam 1
5173: oPushResult
5174: oCall 5486
5176: oPop 1
5178: oGetParam 1
5180: oPushResult
5181: oCall 4985
5183: oPop 1
5185: oCall 9711
5187: oCall 9612
5189: oTypeSNodeType
5190: oChoice 5204
5192: oEmit 41
5194: oJumpForward 5219
5196: oEmit 47
5198: oJumpForward 5219
5200: oError 16
5202: oJumpForward 5219
5204: Choice Lookup Table
          33   5200
          32   5200
          34   5196
          30   5192
          38   5192
          28   5192
5217: oError 17
5219: oTypeSPop
5220: oGetGlobal 6
5222: oPushResult
5223: oTypeSPush
5224: oPop 1
5226: oJumpForward 5483
5228: oGetParam 1
5230: oPushResult
5231: oCall 4985
5233: oPop 1
5235: oCall 9711
5237: oGetParam 1
5239: oPushResult
5240: oCall 5486
5242: oPop 1
5244: oGetParam 1
5246: oPushResult
5247: oCall 4985
5249: oPop 1
5251: oCall 9711
5253: oCall 9612
5255: oTypeSNodeType
5256: oChoice 5266
5258: oEmit 43
5260: oJumpForward 5279
5262: oError 16
5264: oJumpForward 5279
5266: Choice Lookup Table
          33   5262
          32   5262
          30   5258
          38   5258
          28   5258
5277: oError 17
5279: oTypeSPop
5280: oGetGlobal 6
5282: oPushResult
5283: oTypeSPush
5284: oPop 1
5286: oJumpForward 5483
5288: oGetParam 1
5290: oPushResult
5291: oCall 4985
5293: oPop 1
5295: oCall 9711
5297: oGetParam 1
5299: oPushResult
5300: oCall 5486
5302: oPop 1
5304: oGetParam 1
5306: oPushResult
5307: oCall 4985
5309: oPop 1
5311: oCall 9711
5313: oCall 9612
5315: oTypeSNodeType
5316: oChoice 5326
5318: oEmit 42
5320: oJumpForward 5339
5322: oError 16
5324: oJumpForward 5339
5326: Choice Lookup Table
          33   5322
          32   5322
          30   5318
          38   5318
          28   5318
5337: oError 17
5339: oTypeSPop
5340: oGetGlobal 6
5342: oPushResult
5343: oTypeSPush
5344: oPop 1
5346: oJumpForward 5483
5348: oGetParam 1
5350: oPushResult
5351: oCall 4985
5353: oPop 1
5355: oCall 9711
5357: oGetParam 1
5359: oPushResult
5360: oCall 5486
5362: oPop 1
5364: oGetParam 1
5366: oPushResult
5367: oCall 4985
5369: oPop 1
5371: oCall 9711
5373: oCall 9612
5375: oTypeSNodeType
5376: oChoice 5386
5378: oEmit 45
5380: oJumpForward 5399
5382: oError 16
5384: oJumpForward 5399
5386: Choice Lookup Table
          33   5382
          32   5382
          30   5378
          38   5378
          28   5378
5397: oError 17
5399: oTypeSPop
5400: oGetGlobal 6
5402: oPushResult
5403: oTypeSPush
5404: oPop 1
5406: oJumpForward 5483
5408: oGetParam 1
5410: oPushResult
5411: oCall 4985
5413: oPop 1
5415: oCall 9711
5417: oGetParam 1
5419: oPushResult
5420: oCall 5486
5422: oPop 1
5424: oGetParam 1
5426: oPushResult
5427: oCall 4985
5429: oPop 1
5431: oCall 9711
5433: oCall 9612
5435: oTypeSNodeType
5436: oChoice 5446
5438: oEmit 44
5440: oJumpForward 5459
5442: oError 16
5444: oJumpForward 5459
5446: Choice Lookup Table
          33   5442
          32   5442
          30   5438
          38   5438
          28   5438
5457: oError 17
5459: oTypeSPop
5460: oGetGlobal 6
5462: oPushResult
5463: oTypeSPush
5464: oPop 1
5466: oJumpForward 5483
5468: Choice Lookup Table
          11   5408
          10   5348
           9   5288
           8   5228
           7   5162
           6   5096
5481: oJumpForward 5485
5483: oJumpBack 5094
5485: oReturn
5486: oLocalSpace 1
5488: oGetAddrLocal 1
5490: oPushResult
5491: oSetResult 0
5493: oAssign
5494: oGetParam 1
5496: oPushResult
5497: oCall 5666
5499: oPop 1
5501: oInputChoice 5634
5503: oTypeSNodeType
5504: oChoice 5575
5506: oGetLocal 1
5508: oPushResult
5509: oSetResult 0
5511: oPushResult
5512: equal_label
5513: oPop 2
5515: oChoice 5524
5517: oGetAddrLocal 1
5519: oPushResult
5520: oLabelNew
5521: oAssign
5522: oJumpForward 5527
5524: Choice Lookup Table
           1   5517
5527: oEmit 55
5529: oGetLocal 1
5531: oPushResult
5532: oEmitLabel
5533: oPop 1
5535: oJumpForward 5582
5537: oGetParam 1
5539: oPushResult
5540: oCall 5054
5542: oPop 1
5544: oGetLocal 1
5546: oPushResult
5547: oSetResult 0
5549: oPushResult
5550: equal_label
5551: oPop 2
5553: oChoice 5562
5555: oGetAddrLocal 1
5557: oPushResult
5558: oLabelNew
5559: oAssign
5560: oJumpForward 5565
5562: Choice Lookup Table
           1   5555
5565: oEmit 55
5567: oGetLocal 1
5569: oPushResult
5570: oEmitLabel
5571: oPop 1
5573: oJumpForward 5582
5575: Choice Lookup Table
          30   5537
          31   5506
5580: oError 8
5582: oTypeSPop
5583: oEmit 58
5585: oGetFromParam 1
5587: oPushResult
5588: oEmitLabel
5589: oPop 1
5591: oGetParam 1
5593: oPushResult
5594: oSetResult 0
5596: oAssign
5597: oGetParam 1
5599: oPushResult
5600: oCall 5666
5602: oPop 1
5604: oTypeSNodeType
5605: oChoice 5618
5607: oJumpForward 5625
5609: oGetParam 1
5611: oPushResult
5612: oCall 5054
5614: oPop 1
5616: oJumpForward 5625
5618: Choice Lookup Table
          30   5609
          31   5607
5623: oError 8
5625: oTypeSPop
5626: oGetGlobal 7
5628: oPushResult
5629: oTypeSPush
5630: oPop 1
5632: oJumpForward 5639
5634: Choice Lookup Table
          55   5503
5637: oJumpForward 5641
5639: oJumpBack 5501
5641: oGetLocal 1
5643: oPushResult
5644: oSetResult 0
5646: oPushResult
5647: equal_label
5648: oPop 2
5650: oChoice 5662
5652: oEmit 58
5654: oGetLocal 1
5656: oPushResult
5657: oEmitLabel
5658: oPop 1
5660: oJumpForward 5665
5662: Choice Lookup Table
           0   5652
5665: oReturn
5666: oLocalSpace 2
5668: oGetAddrLocal 1
5670: oPushResult
5671: oSetResult 0
5673: oAssign
5674: oGetParam 1
5676: oPushResult
5677: oCall 5804
5679: oPop 1
5681: oInputChoice 5796
5683: oTypeSNodeType
5684: oChoice 5697
5686: oJumpForward 5704
5688: oGetParam 1
5690: oPushResult
5691: oCall 5054
5693: oPop 1
5695: oJumpForward 5704
5697: Choice Lookup Table
          30   5688
          31   5686
5702: oError 8
5704: oTypeSPop
5705: oGetLocal 1
5707: oPushResult
5708: oSetResult 0
5710: oPushResult
5711: equal_label
5712: oPop 2
5714: oChoice 5743
5716: oGetAddrLocal 1
5718: oPushResult
5719: oLabelNew
5720: oAssign
5721: oEmit 59
5723: oGetFromParam 1
5725: oPushResult
5726: oEmitLabel
5727: oPop 1
5729: oGetLocal 1
5731: oPushResult
5732: oEmitLabel
5733: oPop 1
5735: oGetParam 1
5737: oPushResult
5738: oGetLocal 1
5740: oAssign
5741: oJumpForward 5746
5743: Choice Lookup Table
           1   5716
5746: oGetAddrLocal 2
5748: oPushResult
5749: oSetResult 0
5751: oAssign
5752: oGetAddrLocal 2
5754: oPushResult
5755: oCall 5804
5757: oPop 1
5759: oTypeSNodeType
5760: oChoice 5773
5762: oJumpForward 5780
5764: oGetAddrLocal 2
5766: oPushResult
5767: oCall 5054
5769: oPop 1
5771: oJumpForward 5780
5773: Choice Lookup Table
          30   5764
          31   5762
5778: oError 8
5780: oEmit 59
5782: oGetLocal 2
5784: oPushResult
5785: oEmitLabel
5786: oPop 1
5788: oGetLocal 1
5790: oPushResult
5791: oEmitLabel
5792: oPop 1
5794: oJumpForward 5801
5796: Choice Lookup Table
          54   5683
5799: oJumpForward 5803
5801: oJumpBack 5681
5803: oReturn
5804: oLocalSpace 1
5806: oInputChoice 5860
5808: oGetAddrLocal 1
5810: oPushResult
5811: oSetResult 0
5813: oAssign
5814: oGetAddrLocal 1
5816: oPushResult
5817: oCall 5804
5819: oPop 1
5821: oTypeSNodeType
5822: oChoice 5851
5824: oGetParam 1
5826: oPushResult
5827: oLabelNew
5828: oAssign
5829: oEmit 55
5831: oGetFromParam 1
5833: oPushResult
5834: oEmitLabel
5835: oPop 1
5837: oEmit 58
5839: oGetLocal 1
5841: oPushResult
5842: oEmitLabel
5843: oPop 1
5845: oJumpForward 5858
5847: oEmit 39
5849: oJumpForward 5858
5851: Choice Lookup Table
          30   5847
          31   5824
5856: oError 8
5858: oJumpForward 5870
5860: Choice Lookup Table
          56   5808
5863: oGetParam 1
5865: oPushResult
5866: oCall 5871
5868: oPop 1
5870: oReturn
5871: oLocalSpace 0
5873: oGetParam 1
5875: oPushResult
5876: oCall 5922
5878: oPop 1
5880: oInputChoice 5912
5882: oCall 9665
5884: oGetParam 1
5886: oPushResult
5887: oCall 5922
5889: oPop 1
5891: oCall 9685
5893: oEmit 36
5895: oJumpForward 5919
5897: oCall 9665
5899: oGetParam 1
5901: oPushResult
5902: oCall 5922
5904: oPop 1
5906: oCall 9685
5908: oEmit 37
5910: oJumpForward 5919
5912: Choice Lookup Table
          25   5897
          24   5882
5917: oJumpForward 5921
5919: oJumpBack 5880
5921: oReturn
5922: oLocalSpace 0
5924: oGetParam 1
5926: oPushResult
5927: oCall 5973
5929: oPop 1
5931: oInputChoice 5963
5933: oCall 9665
5935: oGetParam 1
5937: oPushResult
5938: oCall 5973
5940: oPop 1
5942: oCall 9685
5944: oEmit 33
5946: oJumpForward 5970
5948: oCall 9665
5950: oGetParam 1
5952: oPushResult
5953: oCall 5973
5955: oPop 1
5957: oCall 9685
5959: oEmit 34
5961: oJumpForward 5970
5963: Choice Lookup Table
          23   5948
          22   5933
5968: oJumpForward 5972
5970: oJumpBack 5931
5972: oReturn
5973: oLocalSpace 0
5975: oInputChoice 6001
5977: oGetParam 1
5979: oPushResult
5980: oCall 6014
5982: oPop 1
5984: oCall 9685
5986: oJumpForward 6013
5988: oGetParam 1
5990: oPushResult
5991: oCall 6014
5993: oPop 1
5995: oCall 9685
5997: oEmit 38
5999: oJumpForward 6013
6001: Choice Lookup Table
          25   5988
          24   5977
6006: oGetParam 1
6008: oPushResult
6009: oCall 6014
6011: oPop 1
6013: oReturn
6014: oLocalSpace 6
6016: oInputChoice 6248
6018: oEmit 15
6020: TOKEN_VALUE
6021: oPushResult
6022: oEmitInt
6023: oPop 1
6025: oGetGlobal 5
6027: oPushResult
6028: oTypeSPush
6029: oPop 1
6031: oJumpForward 6269
6033: oEmit 15
6035: TOKEN_VALUE
6036: oPushResult
6037: oEmitInt
6038: oPop 1
6040: oGetGlobal 8
6042: oPushResult
6043: oTypeSPush
6044: oPop 1
6046: oJumpForward 6269
6048: oGetParam 1
6050: oPushResult
6051: oCall 5085
6053: oPop 1
6055: oInput 15
6057: oJumpForward 6269
6059: oGetAddrLocal 1
6061: oPushResult
6062: CURRENT_STRLIT
6063: oPushResult
6064: oStringAllocLit
6065: oPop 1
6067: oAssign
6068: oEmit 16
6070: oGetLocal 1
6072: oPushResult
6073: oEmitInt
6074: oPop 1
6076: oGetGlobal 10
6078: oPushResult
6079: oTypeSPush
6080: oPop 1
6082: oJumpForward 6269
6084: oGetAddrLocal 2
6086: oPushResult
6087: oScopeFindRequire
6088: oAssign
6089: oGetAddrLocal 2
6091: oPushResult
6092: oCall 409
6094: oPop 1
6096: oGetLocal 2
6098: oPushResult
6099: oNodeType
6100: oPop 1
6102: oChoice 6175
6104: oGetLocal 2
6106: oPushResult
6107: oCall 7509
6109: oPop 1
6111: oJumpForward 6200
6113: oGetLocal 2
6115: oPushResult
6116: oCall 8120
6118: oPop 1
6120: oJumpForward 6200
6122: oGetAddrLocal 3
6124: oPushResult
6125: oGetLocal 2
6127: oPushResult
6128: oSetResult 21
6130: oPushResult
6131: oNodeGet
6132: oPop 2
6134: oAssign
6135: oGetLocal 3
6137: oPushResult
6138: oTypeSPush
6139: oPop 1
6141: oTypeSNodeType
6142: oChoice 6155
6144: oEmit 15
6146: oGetLocal 2
6148: oPushResult
6149: oCall 10094
6151: oPop 1
6153: oJumpForward 6164
6155: Choice Lookup Table
          30   6144
          38   6144
          28   6144
6162: oError 16
6164: oJumpForward 6200
6166: oGetLocal 2
6168: oPushResult
6169: oCall 6270
6171: oPop 1
6173: oJumpForward 6200
6175: Choice Lookup Table
          24   6166
          23   6166
          21   6166
          20   6166
          17   6122
          16   6122
          14   6113
          13   6104
6192: oError 6
6194: oGetGlobal 5
6196: oPushResult
6197: oTypeSPush
6198: oPop 1
6200: oJumpForward 6269
6202: oInput 0
6204: oGetAddrLocal 4
6206: oPushResult
6207: oScopeFindRequire
6208: oAssign
6209: oGetAddrLocal 4
6211: oPushResult
6212: oCall 409
6214: oPop 1
6216: oGetLocal 4
6218: oPushResult
6219: oCall 8797
6221: oPop 1
6223: oGetAddrLocal 5
6225: oPushResult
6226: oTypeSTop
6227: oAssign
6228: oTypeSPop
6229: oGetAddrLocal 6
6231: oPushResult
6232: oGetLocal 5
6234: oPushResult
6235: oCall 9820
6237: oPop 1
6239: oAssign
6240: oGetLocal 6
6242: oPushResult
6243: oTypeSPush
6244: oPop 1
6246: oJumpForward 6269
6248: Choice Lookup Table
          19   6202
           0   6084
           2   6059
          14   6048
           3   6033
           1   6018
6261: oError 6
6263: oGetGlobal 5
6265: oPushResult
6266: oTypeSPush
6267: oPop 1
6269: oReturn
6270: oLocalSpace 2
6272: oGetAddrLocal 1
6274: oPushResult
6275: oGetParam 1
6277: oPushResult
6278: oSetResult 21
6280: oPushResult
6281: oNodeGet
6282: oPop 2
6284: oAssign
6285: oGetAddrLocal 2
6287: oPushResult
6288: oGetParam 1
6290: oPushResult
6291: oCall 9594
6293: oPop 1
6295: oAssign
6296: oGetLocal 1
6298: oPushResult
6299: oTypeSPush
6300: oPop 1
6302: oTypeSNodeType
6303: oChoice 6992
6305: oGetParam 1
6307: oPushResult
6308: oNodeType
6309: oPop 1
6311: oChoice 6457
6313: oEmit 0
6315: oGetParam 1
6317: oPushResult
6318: oCall 10094
6320: oPop 1
6322: oJumpForward 6467
6324: oGetLocal 2
6326: oPushResult
6327: equal_zero
6328: oPop 1
6330: oChoice 6343
6332: oEmit 3
6334: oGetParam 1
6336: oPushResult
6337: oCall 10094
6339: oPop 1
6341: oJumpForward 6361
6343: Choice Lookup Table
           1   6332
6346: oEmit 9
6348: oGetLocal 2
6350: oPushResult
6351: oEmitInt
6352: oPop 1
6354: oGetParam 1
6356: oPushResult
6357: oCall 10094
6359: oPop 1
6361: oJumpForward 6467
6363: oGetParam 1
6365: oPushResult
6366: oSetResult 33
6368: oPushResult
6369: oNodeGetBoolean
6370: oPop 2
6372: oChoice 6415
6374: oGetLocal 2
6376: oPushResult
6377: equal_zero
6378: oPop 1
6380: oChoice 6393
6382: oEmit 8
6384: oGetParam 1
6386: oPushResult
6387: oCall 10094
6389: oPop 1
6391: oJumpForward 6411
6393: Choice Lookup Table
           1   6382
6396: oEmit 14
6398: oGetLocal 2
6400: oPushResult
6401: oEmitInt
6402: oPop 1
6404: oGetParam 1
6406: oPushResult
6407: oCall 10094
6409: oPop 1
6411: oEmit 22
6413: oJumpForward 6455
6415: Choice Lookup Table
           1   6374
6418: oGetLocal 2
6420: oPushResult
6421: equal_zero
6422: oPop 1
6424: oChoice 6437
6426: oEmit 6
6428: oGetParam 1
6430: oPushResult
6431: oCall 10094
6433: oPop 1
6435: oJumpForward 6455
6437: Choice Lookup Table
           1   6426
6440: oEmit 12
6442: oGetLocal 2
6444: oPushResult
6445: oEmitInt
6446: oPop 1
6448: oGetParam 1
6450: oPushResult
6451: oCall 10094
6453: oPop 1
6455: oJumpForward 6467
6457: Choice Lookup Table
          23   6363
          21   6324
          24   6313
          20   6313
6466: oEndChoice
6467: oJumpForward 7014
6469: oGetParam 1
6471: oPushResult
6472: oNodeType
6473: oPop 1
6475: oChoice 6621
6477: oEmit 1
6479: oGetParam 1
6481: oPushResult
6482: oCall 10094
6484: oPop 1
6486: oJumpForward 6631
6488: oGetLocal 2
6490: oPushResult
6491: equal_zero
6492: oPop 1
6494: oChoice 6507
6496: oEmit 4
6498: oGetParam 1
6500: oPushResult
6501: oCall 10094
6503: oPop 1
6505: oJumpForward 6525
6507: Choice Lookup Table
           1   6496
6510: oEmit 10
6512: oGetLocal 2
6514: oPushResult
6515: oEmitInt
6516: oPop 1
6518: oGetParam 1
6520: oPushResult
6521: oCall 10094
6523: oPop 1
6525: oJumpForward 6631
6527: oGetParam 1
6529: oPushResult
6530: oSetResult 33
6532: oPushResult
6533: oNodeGetBoolean
6534: oPop 2
6536: oChoice 6579
6538: oGetLocal 2
6540: oPushResult
6541: equal_zero
6542: oPop 1
6544: oChoice 6557
6546: oEmit 8
6548: oGetParam 1
6550: oPushResult
6551: oCall 10094
6553: oPop 1
6555: oJumpForward 6575
6557: Choice Lookup Table
           1   6546
6560: oEmit 14
6562: oGetLocal 2
6564: oPushResult
6565: oEmitInt
6566: oPop 1
6568: oGetParam 1
6570: oPushResult
6571: oCall 10094
6573: oPop 1
6575: oEmit 23
6577: oJumpForward 6619
6579: Choice Lookup Table
           1   6538
6582: oGetLocal 2
6584: oPushResult
6585: equal_zero
6586: oPop 1
6588: oChoice 6601
6590: oEmit 7
6592: oGetParam 1
6594: oPushResult
6595: oCall 10094
6597: oPop 1
6599: oJumpForward 6619
6601: Choice Lookup Table
           1   6590
6604: oEmit 13
6606: oGetLocal 2
6608: oPushResult
6609: oEmitInt
6610: oPop 1
6612: oGetParam 1
6614: oPushResult
6615: oCall 10094
6617: oPop 1
6619: oJumpForward 6631
6621: Choice Lookup Table
          23   6527
          21   6488
          24   6477
          20   6477
6630: oEndChoice
6631: oJumpForward 7014
6633: oError 16
6635: oJumpForward 7014
6637: oGetParam 1
6639: oPushResult
6640: oNodeType
6641: oPop 1
6643: oChoice 6789
6645: oEmit 2
6647: oGetParam 1
6649: oPushResult
6650: oCall 10094
6652: oPop 1
6654: oJumpForward 6799
6656: oGetLocal 2
6658: oPushResult
6659: equal_zero
6660: oPop 1
6662: oChoice 6675
6664: oEmit 5
6666: oGetParam 1
6668: oPushResult
6669: oCall 10094
6671: oPop 1
6673: oJumpForward 6693
6675: Choice Lookup Table
           1   6664
6678: oEmit 11
6680: oGetLocal 2
6682: oPushResult
6683: oEmitInt
6684: oPop 1
6686: oGetParam 1
6688: oPushResult
6689: oCall 10094
6691: oPop 1
6693: oJumpForward 6799
6695: oGetParam 1
6697: oPushResult
6698: oSetResult 33
6700: oPushResult
6701: oNodeGetBoolean
6702: oPop 2
6704: oChoice 6747
6706: oGetLocal 2
6708: oPushResult
6709: equal_zero
6710: oPop 1
6712: oChoice 6725
6714: oEmit 8
6716: oGetParam 1
6718: oPushResult
6719: oCall 10094
6721: oPop 1
6723: oJumpForward 6743
6725: Choice Lookup Table
           1   6714
6728: oEmit 14
6730: oGetLocal 2
6732: oPushResult
6733: oEmitInt
6734: oPop 1
6736: oGetParam 1
6738: oPushResult
6739: oCall 10094
6741: oPop 1
6743: oEmit 24
6745: oJumpForward 6787
6747: Choice Lookup Table
           1   6706
6750: oGetLocal 2
6752: oPushResult
6753: equal_zero
6754: oPop 1
6756: oChoice 6769
6758: oEmit 8
6760: oGetParam 1
6762: oPushResult
6763: oCall 10094
6765: oPop 1
6767: oJumpForward 6787
6769: Choice Lookup Table
           1   6758
6772: oEmit 14
6774: oGetLocal 2
6776: oPushResult
6777: oEmitInt
6778: oPop 1
6780: oGetParam 1
6782: oPushResult
6783: oCall 10094
6785: oPop 1
6787: oJumpForward 6799
6789: Choice Lookup Table
          23   6695
          21   6656
          24   6645
          20   6645
6798: oEndChoice
6799: oInputChoice 6821
6801: oTypeSPop
6802: oGetLocal 1
6804: oPushResult
6805: oSetResult 36
6807: oPushResult
6808: oNodeGet
6809: oPop 2
6811: oPushResult
6812: oTypeSPush
6813: oPop 1
6815: oCall 7061
6817: oCall 7015
6819: oJumpForward 6824
6821: Choice Lookup Table
          18   6801
6824: oJumpForward 7014
6826: oGetParam 1
6828: oPushResult
6829: oNodeType
6830: oPop 1
6832: oChoice 6976
6834: oEmit 16
6836: oGetParam 1
6838: oPushResult
6839: oCall 10094
6841: oPop 1
6843: oJumpForward 6986
6845: oGetLocal 2
6847: oPushResult
6848: equal_zero
6849: oPop 1
6851: oChoice 6864
6853: oEmit 17
6855: oGetParam 1
6857: oPushResult
6858: oCall 10094
6860: oPop 1
6862: oJumpForward 6882
6864: Choice Lookup Table
           1   6853
6867: oEmit 20
6869: oGetLocal 2
6871: oPushResult
6872: oEmitInt
6873: oPop 1
6875: oGetParam 1
6877: oPushResult
6878: oCall 10094
6880: oPop 1
6882: oJumpForward 6986
6884: oGetParam 1
6886: oPushResult
6887: oSetResult 33
6889: oPushResult
6890: oNodeGetBoolean
6891: oPop 2
6893: oChoice 6934
6895: oGetLocal 2
6897: oPushResult
6898: equal_zero
6899: oPop 1
6901: oChoice 6914
6903: oEmit 8
6905: oGetParam 1
6907: oPushResult
6908: oCall 10094
6910: oPop 1
6912: oJumpForward 6932
6914: Choice Lookup Table
           1   6903
6917: oEmit 14
6919: oGetLocal 2
6921: oPushResult
6922: oEmitInt
6923: oPop 1
6925: oGetParam 1
6927: oPushResult
6928: oCall 10094
6930: oPop 1
6932: oJumpForward 6974
6934: Choice Lookup Table
           1   6895
6937: oGetLocal 2
6939: oPushResult
6940: equal_zero
6941: oPop 1
6943: oChoice 6956
6945: oEmit 18
6947: oGetParam 1
6949: oPushResult
6950: oCall 10094
6952: oPop 1
6954: oJumpForward 6974
6956: Choice Lookup Table
           1   6945
6959: oEmit 21
6961: oGetLocal 2
6963: oPushResult
6964: oEmitInt
6965: oPop 1
6967: oGetParam 1
6969: oPushResult
6970: oCall 10094
6972: oPop 1
6974: oJumpForward 6986
6976: Choice Lookup Table
          23   6884
          21   6845
          24   6834
          20   6834
6985: oEndChoice
6986: oCall 7061
6988: oCall 7015
6990: oJumpForward 7014
6992: Choice Lookup Table
          37   6826
          35   6826
          34   6637
          27   6633
          33   6633
          32   6469
          29   6469
          30   6469
          38   6305
          28   6305
7013: oEndChoice
7014: oReturn
7015: oLocalSpace 0
7017: oTypeSNodeType
7018: oChoice 7038
7020: oEmit 22
7022: oJumpForward 7060
7024: oEmit 23
7026: oJumpForward 7060
7028: oError 16
7030: oJumpForward 7060
7032: oEmit 24
7034: oJumpForward 7060
7036: oJumpForward 7060
7038: Choice Lookup Table
          37   7036
          35   7036
          34   7032
          27   7028
          33   7028
          32   7024
          29   7024
          30   7024
          38   7020
          28   7020
7059: oEndChoice
7060: oReturn
7061: oLocalSpace 0
7063: oInputChoice 7077
7065: oCall 7089
7067: oJumpForward 7086
7069: oCall 7232
7071: oJumpForward 7086
7073: oCall 7330
7075: oJumpForward 7086
7077: Choice Lookup Table
          18   7073
          20   7069
          16   7065
7084: oJumpForward 7088
7086: oJumpBack 7063
7088: oReturn
7089: oLocalSpace 3
7091: oTypeSNodeType
7092: oChoice 7096
7094: oJumpForward 7101
7096: Choice Lookup Table
          35   7094
7099: oError 10
7101: oTypeSNodeType
7102: oChoice 7106
7104: oJumpForward 7111
7106: Choice Lookup Table
          35   7104
7109: oError 13
7111: oGetAddrLocal 1
7113: oPushResult
7114: oTypeSTop
7115: oPushResult
7116: oSetResult 37
7118: oPushResult
7119: oNodeGet
7120: oPop 2
7122: oPushResult
7123: oCall 9904
7125: oPop 1
7127: oAssign
7128: oGetAddrLocal 2
7130: oPushResult
7131: oTypeSTop
7132: oPushResult
7133: oSetResult 36
7135: oPushResult
7136: oNodeGet
7137: oPop 2
7139: oAssign
7140: oTypeSPop
7141: oGetLocal 2
7143: oPushResult
7144: oTypeSPush
7145: oPop 1
7147: oCall 4924
7149: oCall 9638
7151: oGetLocal 1
7153: oPushResult
7154: equal_zero
7155: oPop 1
7157: oChoice 7171
7159: oEmit 15
7161: oGetLocal 1
7163: oPushResult
7164: oEmitInt
7165: oPop 1
7167: oEmit 37
7169: oJumpForward 7174
7171: Choice Lookup Table
           0   7159
7174: oGetAddrLocal 3
7176: oPushResult
7177: oGetLocal 2
7179: oPushResult
7180: oSetResult 17
7182: oPushResult
7183: oNodeGetInt
7184: oPop 2
7186: oAssign
7187: oGetLocal 3
7189: oPushResult
7190: oSetResult 1
7192: oPushResult
7193: equal
7194: oPop 2
7196: oChoice 7210
7198: oEmit 15
7200: oGetLocal 3
7202: oPushResult
7203: oEmitInt
7204: oPop 1
7206: oEmit 33
7208: oJumpForward 7213
7210: Choice Lookup Table
           0   7198
7213: oEmit 35
7215: oInputChoice 7223
7217: oJumpForward 7231
7219: oJumpForward 7229
7221: oJumpForward 7229
7223: Choice Lookup Table
          13   7221
          17   7217
7228: oEndChoice
7229: oJumpBack 7101
7231: oReturn
7232: oLocalSpace 2
7234: oTypeSNodeType
7235: oChoice 7239
7237: oJumpForward 7244
7239: Choice Lookup Table
          37   7237
7242: oError 11
7244: oTypeSTop
7245: oPushResult
7246: oSetResult 40
7248: oPushResult
7249: oNodeGet
7250: oPop 2
7252: oPushResult
7253: oScopeEnter
7254: oPop 1
7256: oInput 0
7258: oGetAddrLocal 1
7260: oPushResult
7261: oScopeFindRequire
7262: oAssign
7263: oGetLocal 1
7265: oPushResult
7266: oNodeType
7267: oPop 1
7269: oChoice 7273
7271: oJumpForward 7278
7273: Choice Lookup Table
          22   7271
7276: oError 12
7278: oScopeEnd
7279: oGetAddrLocal 2
7281: oPushResult
7282: oGetLocal 1
7284: oPushResult
7285: oSetResult 22
7287: oPushResult
7288: oNodeGetInt
7289: oPop 2
7291: oAssign
7292: oGetLocal 2
7294: oPushResult
7295: equal_zero
7296: oPop 1
7298: oChoice 7312
7300: oEmit 15
7302: oGetLocal 2
7304: oPushResult
7305: oEmitInt
7306: oPop 1
7308: oEmit 35
7310: oJumpForward 7315
7312: Choice Lookup Table
           0   7300
7315: oTypeSPop
7316: oGetLocal 1
7318: oPushResult
7319: oSetResult 21
7321: oPushResult
7322: oNodeGet
7323: oPop 2
7325: oPushResult
7326: oTypeSPush
7327: oPop 1
7329: oReturn
7330: oLocalSpace 1
7332: oTypeSNodeType
7333: oChoice 7337
7335: oJumpForward 7342
7337: Choice Lookup Table
          34   7335
7340: oError 9
7342: oEmit 24
7344: oGetAddrLocal 1
7346: oPushResult
7347: oTypeSTop
7348: oAssign
7349: oTypeSPop
7350: oGetLocal 1
7352: oPushResult
7353: oSetResult 36
7355: oPushResult
7356: oNodeGet
7357: oPop 2
7359: oPushResult
7360: oTypeSPush
7361: oPop 1
7363: oReturn
7364: oLocalSpace 1
7366: oGetAddrLocal 1
7368: oPushResult
7369: oTypeSNodeType
7370: oAssign
7371: oTypeSPop
7372: oGetLocal 1
7374: oPushResult
7375: oTypeSNodeType
7376: oPushResult
7377: equal_node_type
7378: oPop 2
7380: oChoice 7422
7382: oTypeSNodeType
7383: oChoice 7413
7385: oGetLocal 1
7387: oChoice 7394
7389: oEmit 29
7391: oReturn
7392: oJumpForward 7397
7394: Choice Lookup Table
          29   7389
7397: oJumpForward 7418
7399: oGetLocal 1
7401: oChoice 7408
7403: oEmit 30
7405: oReturn
7406: oJumpForward 7411
7408: Choice Lookup Table
          28   7403
7411: oJumpForward 7418
7413: Choice Lookup Table
          29   7399
          28   7385
7418: oError 14
7420: oJumpForward 7425
7422: Choice Lookup Table
           0   7382
7425: oReturn
7426: oLocalSpace 2
7428: oGetAddrLocal 2
7430: oPushResult
7431: oGetParam 1
7433: oPushResult
7434: oSetResult 26
7436: oPushResult
7437: oNodeGetString
7438: oPop 2
7440: oAssign
7441: oGetLocal 2
7443: oPushResult
7444: oSetResult 0
7446: oPushResult
7447: equal_string
7448: oPop 2
7450: oChoice 7487
7452: oGetAddrLocal 1
7454: oPushResult
7455: oGetParam 1
7457: oPushResult
7458: oSetResult 4
7460: oPushResult
7461: oNodeGetInt
7462: oPop 2
7464: oPushResult
7465: ID_STRING
7466: oPop 1
7468: oPushResult
7469: oStringAllocLit
7470: oPop 1
7472: oAssign
7473: oJumpForward 7493
7475: oGetAddrLocal 1
7477: oPushResult
7478: oGetLocal 2
7480: oPushResult
7481: oStringAllocLit
7482: oPop 1
7484: oAssign
7485: oJumpForward 7493
7487: Choice Lookup Table
           0   7475
           1   7452
7492: oEndChoice
7493: oEmit 60
7495: oGetParam 1
7497: oPushResult
7498: oCall 10094
7500: oPop 1
7502: oGetLocal 1
7504: oPushResult
7505: oEmitInt
7506: oPop 1
7508: oReturn
7509: oLocalSpace 10
7511: oGetParam 1
7513: oPushResult
7514: oSetResult 25
7516: oPushResult
7517: oNodeGetBoolean
7518: oPop 2
7520: oChoice 7547
7522: oGetParam 1
7524: oPushResult
7525: oSetResult 28
7527: oPushResult
7528: oNodeGetBoolean
7529: oPop 2
7531: oChoice 7542
7533: oGetParam 1
7535: oPushResult
7536: oCall 7426
7538: oPop 1
7540: oJumpForward 7545
7542: Choice Lookup Table
           0   7533
7545: oJumpForward 7550
7547: Choice Lookup Table
           1   7522
7550: oGetParam 1
7552: oPushResult
7553: oSetResult 28
7555: oPushResult
7556: oSetResult 1
7558: oPushResult
7559: oNodeSetBoolean
7560: oPop 3
7562: oGetAddrLocal 1
7564: oPushResult
7565: oGetParam 1
7567: oPushResult
7568: oSetResult 27
7570: oPushResult
7571: oNodeGetBoolean
7572: oPop 2
7574: oAssign
7575: oGetAddrLocal 4
7577: oPushResult
7578: oGetParam 1
7580: oPushResult
7581: oNodeType
7582: oPop 1
7584: oPushResult
7585: oSetResult 13
7587: oPushResult
7588: equal_node_type
7589: oPop 2
7591: oAssign
7592: oGetLocal 4
7594: oChoice 7621
7596: oGetAddrLocal 2
7598: oPushResult
7599: oGetParam 1
7601: oPushResult
7602: oSetResult 21
7604: oPushResult
7605: oNodeGet
7606: oPop 2
7608: oAssign
7609: oGetAddrLocal 3
7611: oPushResult
7612: oGetLocal 2
7614: oPushResult
7615: oScopeAllocType
7616: oPop 1
7618: oAssign
7619: oJumpForward 7624
7621: Choice Lookup Table
           1   7596
7624: oGetAddrLocal 5
7626: oPushResult
7627: oGetParam 1
7629: oPushResult
7630: oSetResult 23
7632: oPushResult
7633: oNodeGet
7634: oPop 2
7636: oAssign
7637: oGetAddrLocal 6
7639: oPushResult
7640: oGetLocal 5
7642: oPushResult
7643: oSetResult 17
7645: oPushResult
7646: oNodeGetInt
7647: oPop 2
7649: oAssign
7650: oGetLocal 1
7652: oChoice 7674
7654: oEmit 49
7656: oGetLocal 6
7658: oPushResult
7659: oEmitInt
7660: oPop 1
7662: oJumpForward 7680
7664: oEmit 48
7666: oGetLocal 6
7668: oPushResult
7669: oEmitInt
7670: oPop 1
7672: oJumpForward 7680
7674: Choice Lookup Table
           0   7664
           1   7654
7679: oEndChoice
7680: oGetParam 1
7682: oPushResult
7683: oCall 9574
7685: oPop 1
7687: oPushResult
7688: oSetResult 0
7690: oPushResult
7691: greater
7692: oPop 2
7694: oChoice 7727
7696: oEmit 19
7698: oSetResult 0
7700: oPushResult
7701: oEmitInt
7702: oPop 1
7704: oEmit 20
7706: oGetParam 1
7708: oPushResult
7709: oCall 9594
7711: oPop 1
7713: oPushResult
7714: oEmitInt
7715: oPop 1
7717: oSetResult 0
7719: oPushResult
7720: oEmitInt
7721: oPop 1
7723: oEmit 27
7725: oJumpForward 7730
7727: Choice Lookup Table
           1   7696
7730: oGetAddrLocal 7
7732: oPushResult
7733: oGetLocal 5
7735: oPushResult
7736: oSetResult 15
7738: oPushResult
7739: oNodeGetIter
7740: oPop 2
7742: oAssign
7743: oGetAddrLocal 8
7745: oPushResult
7746: oGetLocal 7
7748: oPushResult
7749: oNodeIterValue
7750: oPop 1
7752: oAssign
7753: oInputChoice 7943
7755: oGetLocal 8
7757: oPushResult
7758: oNodeNull
7759: oPop 1
7761: oChoice 7767
7763: oJumpForward 7939
7765: oJumpForward 7770
7767: Choice Lookup Table
           1   7763
7770: oGetAddrLocal 9
7772: oPushResult
7773: oGetLocal 8
7775: oPushResult
7776: oSetResult 22
7778: oPushResult
7779: oNodeGetInt
7780: oPop 2
7782: oAssign
7783: oEmit 19
7785: oGetLocal 9
7787: oPushResult
7788: oEmitInt
7789: oPop 1
7791: oGetLocal 8
7793: oPushResult
7794: oSetResult 21
7796: oPushResult
7797: oNodeGet
7798: oPop 2
7800: oPushResult
7801: oTypeSPush
7802: oPop 1
7804: oGetLocal 8
7806: oPushResult
7807: oSetResult 33
7809: oPushResult
7810: oNodeGetBoolean
7811: oPop 2
7813: oChoice 7892
7815: oCall 8754
7817: oCall 9612
7819: oEmit 27
7821: oJumpForward 7898
7823: oCall 4924
7825: oCall 7364
7827: oTypeSNodeType
7828: oChoice 7868
7830: oEmit 25
7832: oJumpForward 7890
7834: oEmit 26
7836: oJumpForward 7890
7838: oError 16
7840: oJumpForward 7890
7842: oEmit 27
7844: oJumpForward 7890
7846: oGetAddrLocal 10
7848: oPushResult
7849: oTypeSTop
7850: oPushResult
7851: oSetResult 17
7853: oPushResult
7854: oNodeGetInt
7855: oPop 2
7857: oAssign
7858: oEmit 28
7860: oGetLocal 10
7862: oPushResult
7863: oEmitInt
7864: oPop 1
7866: oJumpForward 7890
7868: Choice Lookup Table
          37   7846
          35   7846
          34   7842
          27   7838
          33   7838
          32   7834
          29   7834
          30   7834
          38   7830
          28   7830
7889: oEndChoice
7890: oJumpForward 7898
7892: Choice Lookup Table
           0   7823
           1   7815
7897: oEndChoice
7898: oTypeSPop
7899: oGetAddrLocal 7
7901: oPushResult
7902: oNodeIterNext
7903: oPop 1
7905: oGetAddrLocal 8
7907: oPushResult
7908: oGetLocal 7
7910: oPushResult
7911: oNodeIterValue
7912: oPop 1
7914: oAssign
7915: oGetLocal 8
7917: oPushResult
7918: oNodeNull
7919: oPop 1
7921: oChoice 7929
7923: oJumpForward 7939
7925: oJumpForward 7935
7927: oJumpForward 7935
7929: Choice Lookup Table
           0   7927
           1   7923
7934: oEndChoice
7935: oInput 13
7937: oJumpBack 7755
7939: oInput 15
7941: oJumpForward 7946
7943: Choice Lookup Table
          14   7755
7946: oGetLocal 8
7948: oPushResult
7949: oNodeNull
7950: oPop 1
7952: oChoice 7958
7954: oError 15
7956: oJumpForward 7961
7958: Choice Lookup Table
           0   7954
7961: oGetLocal 4
7963: oChoice 7992
7965: oEmit 19
7967: oGetParam 1
7969: oPushResult
7970: oSetResult 31
7972: oPushResult
7973: oNodeGetInt
7974: oPop 2
7976: oPushResult
7977: oEmitInt
7978: oPop 1
7980: oEmit 17
7982: oGetLocal 3
7984: oPushResult
7985: oEmitInt
7986: oPop 1
7988: oEmit 27
7990: oJumpForward 7995
7992: Choice Lookup Table
           1   7965
7995: oGetLocal 1
7997: oChoice 8021
7999: oEmit 52
8001: oGetParam 1
8003: oPushResult
8004: oCall 10094
8006: oPop 1
8008: oJumpForward 8027
8010: oEmit 51
8012: oGetParam 1
8014: oPushResult
8015: oCall 10094
8017: oPop 1
8019: oJumpForward 8027
8021: Choice Lookup Table
           0   8010
           1   7999
8026: oEndChoice
8027: oGetLocal 4
8029: oChoice 8108
8031: oGetLocal 2
8033: oPushResult
8034: oTypeSPush
8035: oPop 1
8037: oTypeSNodeType
8038: oChoice 8084
8040: oEmit 3
8042: oGetLocal 3
8044: oPushResult
8045: oEmitInt
8046: oPop 1
8048: oJumpForward 8106
8050: oEmit 4
8052: oGetLocal 3
8054: oPushResult
8055: oEmitInt
8056: oPop 1
8058: oJumpForward 8106
8060: oError 16
8062: oJumpForward 8106
8064: oEmit 5
8066: oGetLocal 3
8068: oPushResult
8069: oEmitInt
8070: oPop 1
8072: oJumpForward 8106
8074: oEmit 17
8076: oGetLocal 3
8078: oPushResult
8079: oEmitInt
8080: oPop 1
8082: oJumpForward 8106
8084: Choice Lookup Table
          37   8074
          35   8074
          34   8064
          27   8060
          33   8060
          32   8050
          29   8050
          30   8050
          38   8040
          28   8040
8105: oEndChoice
8106: oJumpForward 8111
8108: Choice Lookup Table
           1   8031
8111: oEmit 50
8113: oGetLocal 6
8115: oPushResult
8116: oEmitInt
8117: oPop 1
8119: oReturn
8120: oLocalSpace 0
8122: oGetParam 1
8124: oPushResult
8125: oGetGlobal 11
8127: oPushResult
8128: oNodeEqual
8129: oPop 2
8131: oChoice 8171
8133: oInput 14
8135: oCall 4924
8137: oTypeSNodeType
8138: oChoice 8146
8140: oJumpForward 8159
8142: oEmit 29
8144: oJumpForward 8159
8146: Choice Lookup Table
          32   8142
          29   8142
          30   8142
          38   8140
          28   8140
8157: oError 14
8159: oTypeSPop
8160: oGetGlobal 5
8162: oPushResult
8163: oTypeSPush
8164: oPop 1
8166: oInput 15
8168: oReturn
8169: oJumpForward 8174
8171: Choice Lookup Table
           1   8133
8174: oGetParam 1
8176: oPushResult
8177: oGetGlobal 12
8179: oPushResult
8180: oNodeEqual
8181: oPop 2
8183: oChoice 8217
8185: oInput 14
8187: oCall 4924
8189: oTypeSNodeType
8190: oChoice 8198
8192: oEmit 30
8194: oJumpForward 8205
8196: oJumpForward 8205
8198: Choice Lookup Table
          29   8196
          28   8192
8203: oError 14
8205: oTypeSPop
8206: oGetGlobal 8
8208: oPushResult
8209: oTypeSPush
8210: oPop 1
8212: oInput 15
8214: oReturn
8215: oJumpForward 8220
8217: Choice Lookup Table
           1   8185
8220: oGetParam 1
8222: oPushResult
8223: oGetGlobal 13
8225: oPushResult
8226: oNodeEqual
8227: oPop 2
8229: oChoice 8269
8231: oInput 14
8233: oCall 4924
8235: oTypeSNodeType
8236: oChoice 8257
8238: oTypeSTop
8239: oPushResult
8240: oSetResult 42
8242: oPushResult
8243: oNodeGetBoolean
8244: oPop 2
8246: oChoice 8252
8248: oError 28
8250: oJumpForward 8255
8252: Choice Lookup Table
           1   8248
8255: oJumpForward 8262
8257: Choice Lookup Table
          38   8238
8260: oError 14
8262: oEmit 32
8264: oInput 15
8266: oReturn
8267: oJumpForward 8272
8269: Choice Lookup Table
           1   8231
8272: oGetParam 1
8274: oPushResult
8275: oGetGlobal 14
8277: oPushResult
8278: oNodeEqual
8279: oPop 2
8281: oChoice 8321
8283: oInput 14
8285: oCall 4924
8287: oTypeSNodeType
8288: oChoice 8309
8290: oTypeSTop
8291: oPushResult
8292: oSetResult 42
8294: oPushResult
8295: oNodeGetBoolean
8296: oPop 2
8298: oChoice 8304
8300: oError 28
8302: oJumpForward 8307
8304: Choice Lookup Table
           1   8300
8307: oJumpForward 8314
8309: Choice Lookup Table
          38   8290
8312: oError 14
8314: oEmit 31
8316: oInput 15
8318: oReturn
8319: oJumpForward 8324
8321: Choice Lookup Table
           1   8283
8324: oError 16
8326: oReturn
8327: oLocalSpace 0
8329: oInputChoice 8388
8331: oCall 9450
8333: oJumpForward 8417
8335: oCall 9457
8337: oJumpForward 8417
8339: oCall 9556
8341: oJumpForward 8417
8343: oCall 9559
8345: oJumpForward 8417
8347: oCall 8938
8349: oJumpForward 8417
8351: oCall 9258
8353: oJumpForward 8417
8355: oCall 9004
8357: oJumpForward 8417
8359: oCall 9178
8361: oJumpForward 8417
8363: oCall 9343
8365: oJumpForward 8417
8367: oCall 9311
8369: oJumpForward 8417
8371: oCall 9427
8373: oJumpForward 8417
8375: oCall 8418
8377: oJumpForward 8417
8379: oCall 9375
8381: oJumpForward 8417
8383: oChangeIntLitToLabelIdent
8384: oCall 8418
8386: oJumpForward 8417
8388: Choice Lookup Table
           1   8383
          53   8379
           0   8375
          35   8371
          51   8367
          52   8363
          49   8359
          44   8355
          48   8351
          41   8347
          66   8343
          65   8339
          64   8335
          63   8331
8417: oReturn
8418: oLocalSpace 1
8420: oGetAddrLocal 1
8422: oPushResult
8423: oScopeFindRequire
8424: oAssign
8425: oGetAddrLocal 1
8427: oPushResult
8428: oCall 409
8430: oPop 1
8432: oGetLocal 1
8434: oPushResult
8435: oNodeType
8436: oPop 1
8438: oChoice 8478
8440: oGetLocal 1
8442: oPushResult
8443: oCall 8494
8445: oPop 1
8447: oCall 8327
8449: oJumpForward 8493
8451: oGetLocal 1
8453: oPushResult
8454: oCall 7509
8456: oPop 1
8458: oJumpForward 8493
8460: oGetLocal 1
8462: oPushResult
8463: oCall 8544
8465: oPop 1
8467: oJumpForward 8493
8469: oGetLocal 1
8471: oPushResult
8472: oCall 8629
8474: oPop 1
8476: oJumpForward 8493
8478: Choice Lookup Table
          13   8469
          23   8460
          21   8460
          20   8460
          12   8451
          25   8440
8491: oError 0
8493: oReturn
8494: oLocalSpace 0
8496: oGetParam 1
8498: oPushResult
8499: oSetResult 34
8501: oPushResult
8502: oNodeGetBoolean
8503: oPop 2
8505: oChoice 8511
8507: oError 21
8509: oJumpForward 8514
8511: Choice Lookup Table
           1   8507
8514: oEmit 58
8516: oGetParam 1
8518: oPushResult
8519: oSetResult 22
8521: oPushResult
8522: oNodeGetLabel
8523: oPop 2
8525: oPushResult
8526: oEmitLabel
8527: oPop 1
8529: oGetParam 1
8531: oPushResult
8532: oSetResult 34
8534: oPushResult
8535: oSetResult 1
8537: oPushResult
8538: oNodeSetBoolean
8539: oPop 3
8541: oInput 12
8543: oReturn
8544: oLocalSpace 0
8546: oGetParam 1
8548: oPushResult
8549: oCall 8797
8551: oPop 1
8553: oInput 4
8555: oCall 4924
8557: oCall 7364
8559: oCall 8562
8561: oReturn
8562: oLocalSpace 1
8564: oTypeSNodeType
8565: oChoice 8605
8567: oEmit 25
8569: oJumpForward 8627
8571: oEmit 26
8573: oJumpForward 8627
8575: oError 16
8577: oJumpForward 8627
8579: oEmit 27
8581: oJumpForward 8627
8583: oGetAddrLocal 1
8585: oPushResult
8586: oTypeSTop
8587: oPushResult
8588: oSetResult 17
8590: oPushResult
8591: oNodeGetInt
8592: oPop 2
8594: oAssign
8595: oEmit 28
8597: oGetLocal 1
8599: oPushResult
8600: oEmitInt
8601: oPop 1
8603: oJumpForward 8627
8605: Choice Lookup Table
          37   8583
          35   8583
          34   8579
          27   8575
          33   8575
          32   8571
          29   8571
          30   8571
          38   8567
          28   8567
8626: oEndChoice
8627: oTypeSPop
8628: oReturn
8629: oLocalSpace 1
8631: oGetParam 1
8633: oPushResult
8634: oSetResult 6
8636: oPushResult
8637: oNodeGet
8638: oPop 2
8640: oPushResult
8641: oScopeCurrent
8642: oPushResult
8643: oNodeEqual
8644: oPop 2
8646: oChoice 8652
8648: oError 20
8650: oJumpForward 8655
8652: Choice Lookup Table
           0   8648
8655: oEmit 8
8657: oGetParam 1
8659: oPushResult
8660: oSetResult 31
8662: oPushResult
8663: oNodeGetInt
8664: oPop 2
8666: oPushResult
8667: oEmitInt
8668: oPop 1
8670: oGetParam 1
8672: oPushResult
8673: oSetResult 21
8675: oPushResult
8676: oNodeGet
8677: oPop 2
8679: oPushResult
8680: oTypeSPush
8681: oPop 1
8683: oInput 4
8685: oCall 4924
8687: oCall 7364
8689: oTypeSNodeType
8690: oChoice 8730
8692: oEmit 25
8694: oJumpForward 8752
8696: oEmit 26
8698: oJumpForward 8752
8700: oError 16
8702: oJumpForward 8752
8704: oEmit 27
8706: oJumpForward 8752
8708: oGetAddrLocal 1
8710: oPushResult
8711: oTypeSTop
8712: oPushResult
8713: oSetResult 17
8715: oPushResult
8716: oNodeGetInt
8717: oPop 2
8719: oAssign
8720: oEmit 28
8722: oGetLocal 1
8724: oPushResult
8725: oEmitInt
8726: oPop 1
8728: oJumpForward 8752
8730: Choice Lookup Table
          37   8708
          35   8708
          34   8704
          27   8700
          33   8700
          32   8696
          29   8696
          30   8696
          38   8692
          28   8692
8751: oEndChoice
8752: oTypeSPop
8753: oReturn
8754: oLocalSpace 1
8756: oInput 0
8758: oGetAddrLocal 1
8760: oPushResult
8761: oScopeFindRequire
8762: oAssign
8763: oGetAddrLocal 1
8765: oPushResult
8766: oCall 409
8768: oPop 1
8770: oGetLocal 1
8772: oPushResult
8773: oNodeType
8774: oPop 1
8776: oChoice 8780
8778: oJumpForward 8789
8780: Choice Lookup Table
          23   8778
          21   8778
          20   8778
8787: oError 4
8789: oGetLocal 1
8791: oPushResult
8792: oCall 8797
8794: oPop 1
8796: oReturn
8797: oLocalSpace 0
8799: oGetParam 1
8801: oPushResult
8802: oNodeType
8803: oPop 1
8805: oChoice 8865
8807: oEmit 16
8809: oGetParam 1
8811: oPushResult
8812: oCall 10094
8814: oPop 1
8816: oJumpForward 8874
8818: oEmit 17
8820: oGetParam 1
8822: oPushResult
8823: oCall 10094
8825: oPop 1
8827: oJumpForward 8874
8829: oGetParam 1
8831: oPushResult
8832: oSetResult 33
8834: oPushResult
8835: oNodeGetBoolean
8836: oPop 2
8838: oChoice 8851
8840: oEmit 8
8842: oGetParam 1
8844: oPushResult
8845: oCall 10094
8847: oPop 1
8849: oJumpForward 8863
8851: Choice Lookup Table
           1   8840
8854: oEmit 18
8856: oGetParam 1
8858: oPushResult
8859: oCall 10094
8861: oPop 1
8863: oJumpForward 8874
8865: Choice Lookup Table
          23   8829
          21   8818
          20   8807
8872: oError 4
8874: oGetParam 1
8876: oPushResult
8877: oSetResult 21
8879: oPushResult
8880: oNodeGet
8881: oPop 2
8883: oPushResult
8884: oTypeSPush
8885: oPop 1
8887: oCall 7061
8889: oReturn
8890: oLocalSpace 0
8892: oGetParam 1
8894: oPushResult
8895: oCall 8797
8897: oPop 1
8899: oCall 9638
8901: oGetParam 1
8903: oPushResult
8904: oCall 6270
8906: oPop 1
8908: oTypeSPop
8909: oEmit 31
8911: oEmit 25
8913: oReturn
8914: oLocalSpace 0
8916: oGetParam 1
8918: oPushResult
8919: oCall 8797
8921: oPop 1
8923: oCall 9638
8925: oGetParam 1
8927: oPushResult
8928: oCall 6270
8930: oPop 1
8932: oTypeSPop
8933: oEmit 32
8935: oEmit 25
8937: oReturn
8938: oLocalSpace 2
8940: oGetAddrLocal 1
8942: oPushResult
8943: oSetResult 0
8945: oAssign
8946: oGetAddrLocal 1
8948: oPushResult
8949: oCall 4947
8951: oPop 1
8953: oInput 42
8955: oCall 8327
8957: oInputChoice 8992
8959: oGetAddrLocal 2
8961: oPushResult
8962: oLabelNew
8963: oAssign
8964: oEmit 55
8966: oGetLocal 2
8968: oPushResult
8969: oEmitLabel
8970: oPop 1
8972: oEmit 58
8974: oGetLocal 1
8976: oPushResult
8977: oEmitLabel
8978: oPop 1
8980: oCall 8327
8982: oEmit 58
8984: oGetLocal 2
8986: oPushResult
8987: oEmitLabel
8988: oPop 1
8990: oJumpForward 9003
8992: Choice Lookup Table
          43   8959
8995: oEmit 58
8997: oGetLocal 1
8999: oPushResult
9000: oEmitLabel
9001: oPop 1
9003: oReturn
9004: oLocalSpace 4
9006: oInput 0
9008: oGetAddrLocal 1
9010: oPushResult
9011: oScopeFindRequire
9012: oAssign
9013: oGetLocal 1
9015: oPushResult
9016: oCall 8797
9018: oPop 1
9020: oCall 9638
9022: oInput 4
9024: oCall 4924
9026: oCall 9638
9028: oEmit 25
9030: oGetAddrLocal 2
9032: oPushResult
9033: oLabelNew
9034: oAssign
9035: oGetAddrLocal 3
9037: oPushResult
9038: oLabelNew
9039: oAssign
9040: oEmit 55
9042: oGetLocal 3
9044: oPushResult
9045: oEmitLabel
9046: oPop 1
9048: oGetAddrLocal 4
9050: oPushResult
9051: oLabelNew
9052: oAssign
9053: oEmit 58
9055: oGetLocal 4
9057: oPushResult
9058: oEmitLabel
9059: oPop 1
9061: oInputChoice 9141
9063: oGetLocal 1
9065: oPushResult
9066: oCall 8890
9068: oPop 1
9070: oEmit 58
9072: oGetLocal 3
9074: oPushResult
9075: oEmitLabel
9076: oPop 1
9078: oGetLocal 1
9080: oPushResult
9081: oCall 6270
9083: oPop 1
9085: oTypeSPop
9086: oCall 4924
9088: oCall 9638
9090: oEmit 42
9092: oEmit 56
9094: oGetLocal 2
9096: oPushResult
9097: oEmitLabel
9098: oPop 1
9100: oJumpForward 9147
9102: oGetLocal 1
9104: oPushResult
9105: oCall 8914
9107: oPop 1
9109: oEmit 58
9111: oGetLocal 3
9113: oPushResult
9114: oEmitLabel
9115: oPop 1
9117: oGetLocal 1
9119: oPushResult
9120: oCall 6270
9122: oPop 1
9124: oTypeSPop
9125: oCall 4924
9127: oCall 9638
9129: oEmit 43
9131: oEmit 56
9133: oGetLocal 2
9135: oPushResult
9136: oEmitLabel
9137: oPop 1
9139: oJumpForward 9147
9141: Choice Lookup Table
          46   9102
          45   9063
9146: oEndChoice
9147: oGetLocal 4
9149: oPushResult
9150: oGetLocal 2
9152: oPushResult
9153: oLoopPush
9154: oPop 2
9156: oInput 47
9158: oCall 8327
9160: oEmit 55
9162: oGetLocal 4
9164: oPushResult
9165: oEmitLabel
9166: oPop 1
9168: oEmit 58
9170: oGetLocal 2
9172: oPushResult
9173: oEmitLabel
9174: oPop 1
9176: oLoopPop
9177: oReturn
9178: oLocalSpace 3
9180: oGetAddrLocal 1
9182: oPushResult
9183: oLabelNew
9184: oAssign
9185: oEmit 58
9187: oGetLocal 1
9189: oPushResult
9190: oEmitLabel
9191: oPop 1
9193: oGetAddrLocal 2
9195: oPushResult
9196: oLabelNew
9197: oAssign
9198: oGetLocal 1
9200: oPushResult
9201: oGetLocal 2
9203: oPushResult
9204: oLoopPush
9205: oPop 2
9207: oCall 8327
9209: oInputChoice 9240
9211: oCall 8327
9213: oJumpForward 9246
9215: oGetAddrLocal 3
9217: oPushResult
9218: oCall 4947
9220: oPop 1
9222: oEmit 59
9224: oGetLocal 3
9226: oPushResult
9227: oEmitLabel
9228: oPop 1
9230: oGetLocal 1
9232: oPushResult
9233: oEmitLabel
9234: oPop 1
9236: oJumpForward 9248
9238: oJumpForward 9246
9240: Choice Lookup Table
          50   9215
           5   9211
9245: oEndChoice
9246: oJumpBack 9209
9248: oEmit 58
9250: oGetLocal 2
9252: oPushResult
9253: oEmitLabel
9254: oPop 1
9256: oLoopPop
9257: oReturn
9258: oLocalSpace 2
9260: oGetAddrLocal 1
9262: oPushResult
9263: oLabelNew
9264: oAssign
9265: oEmit 58
9267: oGetLocal 1
9269: oPushResult
9270: oEmitLabel
9271: oPop 1
9273: oGetAddrLocal 2
9275: oPushResult
9276: oCall 4947
9278: oPop 1
9280: oGetLocal 1
9282: oPushResult
9283: oGetLocal 2
9285: oPushResult
9286: oLoopPush
9287: oPop 2
9289: oInput 47
9291: oCall 8327
9293: oEmit 55
9295: oGetLocal 1
9297: oPushResult
9298: oEmitLabel
9299: oPop 1
9301: oEmit 58
9303: oGetLocal 2
9305: oPushResult
9306: oEmitLabel
9307: oPop 1
9309: oLoopPop
9310: oReturn
9311: oLocalSpace 0
9313: oLoopContinueLabel
9314: oPushResult
9315: oSetResult 0
9317: oPushResult
9318: equal_label
9319: oPop 2
9321: oChoice 9336
9323: oError 18
9325: oJumpForward 9342
9327: oEmit 55
9329: oLoopContinueLabel
9330: oPushResult
9331: oEmitLabel
9332: oPop 1
9334: oJumpForward 9342
9336: Choice Lookup Table
           0   9327
           1   9323
9341: oEndChoice
9342: oReturn
9343: oLocalSpace 0
9345: oLoopBreakLabel
9346: oPushResult
9347: oSetResult 0
9349: oPushResult
9350: equal_label
9351: oPop 2
9353: oChoice 9368
9355: oError 18
9357: oJumpForward 9374
9359: oEmit 55
9361: oLoopBreakLabel
9362: oPushResult
9363: oEmitLabel
9364: oPop 1
9366: oJumpForward 9374
9368: Choice Lookup Table
           0   9359
           1   9355
9373: oEndChoice
9374: oReturn
9375: oLocalSpace 1
9377: oInputChoice 9384
9379: oJumpForward 9390
9381: oChangeIntLitToLabelIdent
9382: oJumpForward 9390
9384: Choice Lookup Table
           1   9381
           0   9379
9389: oEndChoice
9390: oGetAddrLocal 1
9392: oPushResult
9393: oScopeCurrent
9394: oPushResult
9395: oScopeFindRequireInScope
9396: oPop 1
9398: oAssign
9399: oGetLocal 1
9401: oPushResult
9402: oSetResult 28
9404: oPushResult
9405: oSetResult 1
9407: oPushResult
9408: oNodeSetBoolean
9409: oPop 3
9411: oEmit 55
9413: oGetLocal 1
9415: oPushResult
9416: oSetResult 22
9418: oPushResult
9419: oNodeGetLabel
9420: oPop 2
9422: oPushResult
9423: oEmitLabel
9424: oPop 1
9426: oReturn
9427: oLocalSpace 0
9429: oCall 8327
9431: oInputChoice 9441
9433: oCall 8327
9435: oJumpForward 9447
9437: oJumpForward 9449
9439: oJumpForward 9447
9441: Choice Lookup Table
          36   9437
           5   9433
9446: oEndChoice
9447: oJumpBack 9431
9449: oReturn
9450: oLocalSpace 0
9452: oCall 9457
9454: oEmit 67
9456: oReturn
9457: oLocalSpace 0
9459: oInputChoice 9552
9461: oCall 4924
9463: oTypeSNodeType
9464: oChoice 9514
9466: oEmit 61
9468: oJumpForward 9533
9470: oEmit 62
9472: oJumpForward 9533
9474: oEmit 29
9476: oEmit 61
9478: oJumpForward 9533
9480: oEmit 63
9482: oJumpForward 9533
9484: oEmit 64
9486: oJumpForward 9533
9488: oError 16
9490: oJumpForward 9533
9492: oEmit 16
9494: oTypeSTop
9495: oPushResult
9496: oSetResult 41
9498: oPushResult
9499: oNodeGetInt
9500: oPop 2
9502: oPushResult
9503: oEmitInt
9504: oPop 1
9506: oEmit 66
9508: oJumpForward 9533
9510: oEmit 65
9512: oJumpForward 9533
9514: Choice Lookup Table
          34   9510
          38   9492
          27   9488
          33   9484
          32   9480
          29   9474
          30   9470
          28   9466
9531: oError 17
9533: oTypeSPop
9534: oInputChoice 9542
9536: oJumpForward 9550
9538: oJumpForward 9548
9540: oJumpForward 9548
9542: Choice Lookup Table
          13   9540
          15   9536
9547: oEndChoice
9548: oJumpBack 9461
9550: oJumpForward 9555
9552: Choice Lookup Table
          14   9461
9555: oReturn
9556: oLocalSpace 0
9558: oReturn
9559: oLocalSpace 0
9561: oReturn
9562: oLocalSpace 0
9564: oScopeCurrent
9565: oPushResult
9566: oSetResult 14
9568: oPushResult
9569: oNodeGetInt
9570: oPop 2
9572: oReturn
9573: oReturn
9574: oLocalSpace 0
9576: oGetParam 1
9578: oPushResult
9579: oSetResult 20
9581: oPushResult
9582: oNodeGet
9583: oPop 2
9585: oPushResult
9586: oSetResult 14
9588: oPushResult
9589: oNodeGetInt
9590: oPop 2
9592: oReturn
9593: oReturn
9594: oLocalSpace 0
9596: oCall 9562
9598: oPushResult
9599: oGetParam 1
9601: oPushResult
9602: oCall 9574
9604: oPop 1
9606: oPushResult
9607: subtract
9608: oPop 2
9610: oReturn
9611: oReturn
9612: oLocalSpace 1
9614: oGetAddrLocal 1
9616: oPushResult
9617: oTypeSNodeType
9618: oAssign
9619: oTypeSPop
9620: oGetLocal 1
9622: oPushResult
9623: oTypeSNodeType
9624: oPushResult
9625: equal_node_type
9626: oPop 2
9628: oChoice 9634
9630: oError 14
9632: oJumpForward 9637
9634: Choice Lookup Table
           0   9630
9637: oReturn
9638: oLocalSpace 0
9640: oTypeSNodeType
9641: oChoice 9645
9643: oJumpForward 9650
9645: Choice Lookup Table
          28   9643
9648: oError 7
9650: oTypeSPop
9651: oReturn
9652: oLocalSpace 0
9654: oTypeSNodeType
9655: oChoice 9659
9657: oJumpForward 9664
9659: Choice Lookup Table
          28   9657
9662: oError 7
9664: oReturn
9665: oLocalSpace 0
9667: oTypeSNodeType
9668: oChoice 9676
9670: oJumpForward 9683
9672: oEmit 29
9674: oJumpForward 9683
9676: Choice Lookup Table
          29   9672
          28   9670
9681: oError 7
9683: oTypeSPop
9684: oReturn
9685: oLocalSpace 0
9687: oTypeSNodeType
9688: oChoice 9703
9690: oJumpForward 9710
9692: oEmit 29
9694: oTypeSPop
9695: oGetGlobal 5
9697: oPushResult
9698: oTypeSPush
9699: oPop 1
9701: oJumpForward 9710
9703: Choice Lookup Table
          29   9692
          28   9690
9708: oError 7
9710: oReturn
9711: oLocalSpace 0
9713: oTypeSNodeType
9714: oChoice 9727
9716: oEmit 29
9718: oTypeSPop
9719: oGetGlobal 5
9721: oPushResult
9722: oTypeSPush
9723: oPop 1
9725: oJumpForward 9730
9727: Choice Lookup Table
          29   9716
9730: oReturn
9731: oLocalSpace 0
9733: oTypeSNodeType
9734: oChoice 9738
9736: oJumpForward 9743
9738: Choice Lookup Table
          30   9736
9741: oError 8
9743: oTypeSPop
9744: oReturn
9745: oLocalSpace 0
9747: oTypeSNodeType
9748: oChoice 9752
9750: oJumpForward 9757
9752: Choice Lookup Table
          30   9750
9755: oError 8
9757: oReturn
9758: oLocalSpace 1
9760: oGetAddrLocal 1
9762: oPushResult
9763: oGetParam 2
9765: oPushResult
9766: oNodeNew
9767: oPop 1
9769: oAssign
9770: oGetLocal 1
9772: oPushResult
9773: oSetResult 17
9775: oPushResult
9776: oGetParam 1
9778: oPushResult
9779: oNodeSetInt
9780: oPop 3
9782: oGetLocal 1
9784: oPushResult
9785: oTypeAdd
9786: oPop 1
9788: oGetLocal 1
9790: oReturn
9791: oReturn
9792: oLocalSpace 1
9794: oGetAddrLocal 1
9796: oPushResult
9797: oGetParam 2
9799: oPushResult
9800: oNodeNew
9801: oPop 1
9803: oAssign
9804: oGetLocal 1
9806: oPushResult
9807: oSetResult 4
9809: oPushResult
9810: oGetParam 1
9812: oPushResult
9813: oNodeSetInt
9814: oPop 3
9816: oGetLocal 1
9818: oReturn
9819: oReturn
9820: oLocalSpace 1
9822: oGetAddrLocal 1
9824: oPushResult
9825: oGetParam 1
9827: oPushResult
9828: oSetResult 35
9830: oPushResult
9831: oNodeGet
9832: oPop 2
9834: oAssign
9835: oGetLocal 1
9837: oPushResult
9838: oNodeNull
9839: oPop 1
9841: oChoice 9897
9843: oGetAddrLocal 1
9845: oPushResult
9846: oSetResult 34
9848: oPushResult
9849: oNodeNew
9850: oPop 1
9852: oAssign
9853: oGetLocal 1
9855: oPushResult
9856: oSetResult 36
9858: oPushResult
9859: oGetParam 1
9861: oPushResult
9862: oNodeSet
9863: oPop 3
9865: oGetLocal 1
9867: oPushResult
9868: oSetResult 17
9870: oPushResult
9871: oSetResult 8
9873: oPushResult
9874: oNodeSetInt
9875: oPop 3
9877: oGetLocal 1
9879: oPushResult
9880: oTypeAdd
9881: oPop 1
9883: oGetParam 1
9885: oPushResult
9886: oSetResult 35
9888: oPushResult
9889: oGetLocal 1
9891: oPushResult
9892: oNodeSet
9893: oPop 3
9895: oJumpForward 9900
9897: Choice Lookup Table
           1   9843
9900: oGetLocal 1
9902: oReturn
9903: oReturn
9904: oLocalSpace 2
9906: oGetParam 1
9908: oPushResult
9909: oNodeType
9910: oPop 1
9912: oChoice 9982
9914: oMININT
9915: oReturn
9916: oJumpForward 9998
9918: oSetResult 0
9920: oReturn
9921: oJumpForward 9998
9923: oSetResult 0
9925: oReturn
9926: oJumpForward 9998
9928: oGetAddrLocal 1
9930: oPushResult
9931: oGetParam 1
9933: oPushResult
9934: oSetResult 40
9936: oPushResult
9937: oNodeGet
9938: oPop 2
9940: oAssign
9941: oGetAddrLocal 2
9943: oPushResult
9944: oGetLocal 1
9946: oPushResult
9947: oSetResult 15
9949: oPushResult
9950: oNodeGetIter
9951: oPop 2
9953: oPushResult
9954: oNodeIterValue
9955: oPop 1
9957: oAssign
9958: oGetLocal 2
9960: oPushResult
9961: oSetResult 22
9963: oPushResult
9964: oNodeGetInt
9965: oPop 2
9967: oReturn
9968: oJumpForward 9998
9970: oGetParam 1
9972: oPushResult
9973: oSetResult 38
9975: oPushResult
9976: oNodeGetInt
9977: oPop 2
9979: oReturn
9980: oJumpForward 9998
9982: Choice Lookup Table
          36   9970
          38   9928
          32   9923
          30   9918
          28   9914
9993: oError 3
9995: oSetResult 0
9997: oReturn
9998: oReturn
9999: oLocalSpace 2
10001: oGetParam 1
10003: oPushResult
10004: oNodeType
10005: oPop 1
10007: oChoice 10077
10009: oMAXINT
10010: oReturn
10011: oJumpForward 10093
10013: oSetResult 1
10015: oReturn
10016: oJumpForward 10093
10018: oSetResult 255
10020: oReturn
10021: oJumpForward 10093
10023: oGetAddrLocal 1
10025: oPushResult
10026: oGetParam 1
10028: oPushResult
10029: oSetResult 40
10031: oPushResult
10032: oNodeGet
10033: oPop 2
10035: oAssign
10036: oGetAddrLocal 2
10038: oPushResult
10039: oGetLocal 1
10041: oPushResult
10042: oSetResult 15
10044: oPushResult
10045: oNodeGetIterLast
10046: oPop 2
10048: oPushResult
10049: oNodeIterValue
10050: oPop 1
10052: oAssign
10053: oGetLocal 2
10055: oPushResult
10056: oSetResult 22
10058: oPushResult
10059: oNodeGetInt
10060: oPop 2
10062: oReturn
10063: oJumpForward 10093
10065: oGetParam 1
10067: oPushResult
10068: oSetResult 39
10070: oPushResult
10071: oNodeGetInt
10072: oPop 2
10074: oReturn
10075: oJumpForward 10093
10077: Choice Lookup Table
          36   10065
          38   10023
          32   10018
          30   10013
          28   10009
10088: oError 3
10090: oSetResult 0
10092: oReturn
10093: oReturn
10094: oLocalSpace 0
10096: oGetParam 1
10098: oPushResult
10099: oSetResult 22
10101: oPushResult
10102: oNodeGetInt
10103: oPop 2
10105: oPushResult
10106: oEmitInt
10107: oPop 1
10109: oReturn
10110: oLocalSpace 1
10112: oGetAddrLocal 1
10114: oPushResult
10115: oSetResult 14
10117: oPushResult
10118: oGetParam 1
10120: oPushResult
10121: oCall 9792
10123: oPop 2
10125: oAssign
10126: oGetLocal 1
10128: oPushResult
10129: oScopeDeclare
10130: oPop 1
10132: oGetLocal 1
10134: oReturn
10135: oReturn
10136: oLocalSpace 1
10138: oGetAddrGlobal 4
10140: oPushResult
10141: oSetResult 27
10143: oPushResult
10144: oSetResult 4
10146: oPushResult
10147: oCall 9758
10149: oPop 2
10151: oAssign
10152: oGetAddrGlobal 5
10154: oPushResult
10155: oSetResult 28
10157: oPushResult
10158: oSetResult 4
10160: oPushResult
10161: oCall 9758
10163: oPop 2
10165: oAssign
10166: oGetAddrGlobal 6
10168: oPushResult
10169: oSetResult 30
10171: oPushResult
10172: oSetResult 1
10174: oPushResult
10175: oCall 9758
10177: oPop 2
10179: oAssign
10180: oGetAddrGlobal 7
10182: oPushResult
10183: oSetResult 31
10185: oPushResult
10186: oSetResult 1
10188: oPushResult
10189: oCall 9758
10191: oPop 2
10193: oAssign
10194: oGetAddrGlobal 8
10196: oPushResult
10197: oSetResult 32
10199: oPushResult
10200: oSetResult 1
10202: oPushResult
10203: oCall 9758
10205: oPop 2
10207: oAssign
10208: oGetAddrGlobal 9
10210: oPushResult
10211: oSetResult 29
10213: oPushResult
10214: oSetResult 1
10216: oPushResult
10217: oCall 9758
10219: oPop 2
10221: oAssign
10222: oGetAddrGlobal 10
10224: oPushResult
10225: oSetResult 33
10227: oPushResult
10228: oSetResult 256
10230: oPushResult
10231: oCall 9758
10233: oPop 2
10235: oAssign
10236: oGetAddrLocal 1
10238: oPushResult
10239: oSetResult 18
10241: oPushResult
10242: oIdAdd_File
10243: oPushResult
10244: oCall 9792
10246: oPop 2
10248: oAssign
10249: oGetLocal 1
10251: oPushResult
10252: oSetResult 21
10254: oPushResult
10255: oGetGlobal 4
10257: oPushResult
10258: oNodeSet
10259: oPop 3
10261: oGetLocal 1
10263: oPushResult
10264: oScopeDeclare
10265: oPop 1
10267: oGetAddrLocal 1
10269: oPushResult
10270: oSetResult 18
10272: oPushResult
10273: oIdAdd_Integer
10274: oPushResult
10275: oCall 9792
10277: oPop 2
10279: oAssign
10280: oGetLocal 1
10282: oPushResult
10283: oSetResult 21
10285: oPushResult
10286: oGetGlobal 5
10288: oPushResult
10289: oNodeSet
10290: oPop 3
10292: oGetLocal 1
10294: oPushResult
10295: oScopeDeclare
10296: oPop 1
10298: oGetAddrLocal 1
10300: oPushResult
10301: oSetResult 18
10303: oPushResult
10304: oIdAdd_Boolean
10305: oPushResult
10306: oCall 9792
10308: oPop 2
10310: oAssign
10311: oGetLocal 1
10313: oPushResult
10314: oSetResult 21
10316: oPushResult
10317: oGetGlobal 6
10319: oPushResult
10320: oNodeSet
10321: oPop 3
10323: oGetLocal 1
10325: oPushResult
10326: oScopeDeclare
10327: oPop 1
10329: oGetAddrLocal 1
10331: oPushResult
10332: oSetResult 18
10334: oPushResult
10335: oIdAdd_Char
10336: oPushResult
10337: oCall 9792
10339: oPop 2
10341: oAssign
10342: oGetLocal 1
10344: oPushResult
10345: oSetResult 21
10347: oPushResult
10348: oGetGlobal 8
10350: oPushResult
10351: oNodeSet
10352: oPop 3
10354: oGetLocal 1
10356: oPushResult
10357: oScopeDeclare
10358: oPop 1
10360: oGetAddrLocal 1
10362: oPushResult
10363: oSetResult 18
10365: oPushResult
10366: oIdAdd_Byte
10367: oPushResult
10368: oCall 9792
10370: oPop 2
10372: oAssign
10373: oGetLocal 1
10375: oPushResult
10376: oSetResult 21
10378: oPushResult
10379: oGetGlobal 9
10381: oPushResult
10382: oNodeSet
10383: oPop 3
10385: oGetLocal 1
10387: oPushResult
10388: oScopeDeclare
10389: oPop 1
10391: oGetAddrLocal 1
10393: oPushResult
10394: oSetResult 18
10396: oPushResult
10397: oIdAdd_String
10398: oPushResult
10399: oCall 9792
10401: oPop 2
10403: oAssign
10404: oGetLocal 1
10406: oPushResult
10407: oSetResult 21
10409: oPushResult
10410: oGetGlobal 10
10412: oPushResult
10413: oNodeSet
10414: oPop 3
10416: oGetLocal 1
10418: oPushResult
10419: oScopeDeclare
10420: oPop 1
10422: oGetAddrLocal 1
10424: oPushResult
10425: oSetResult 16
10427: oPushResult
10428: oIdAdd_True
10429: oPushResult
10430: oCall 9792
10432: oPop 2
10434: oAssign
10435: oGetLocal 1
10437: oPushResult
10438: oSetResult 21
10440: oPushResult
10441: oGetGlobal 6
10443: oPushResult
10444: oNodeSet
10445: oPop 3
10447: oGetLocal 1
10449: oPushResult
10450: oSetResult 22
10452: oPushResult
10453: oSetResult 1
10455: oPushResult
10456: oNodeSetInt
10457: oPop 3
10459: oGetLocal 1
10461: oPushResult
10462: oScopeDeclare
10463: oPop 1
10465: oGetAddrLocal 1
10467: oPushResult
10468: oSetResult 16
10470: oPushResult
10471: oIdAdd_False
10472: oPushResult
10473: oCall 9792
10475: oPop 2
10477: oAssign
10478: oGetLocal 1
10480: oPushResult
10481: oSetResult 21
10483: oPushResult
10484: oGetGlobal 6
10486: oPushResult
10487: oNodeSet
10488: oPop 3
10490: oGetLocal 1
10492: oPushResult
10493: oSetResult 22
10495: oPushResult
10496: oSetResult 0
10498: oPushResult
10499: oNodeSetInt
10500: oPop 3
10502: oGetLocal 1
10504: oPushResult
10505: oScopeDeclare
10506: oPop 1
10508: oGetAddrGlobal 11
10510: oPushResult
10511: oIdAdd_Ord
10512: oPushResult
10513: oCall 10110
10515: oPop 1
10517: oAssign
10518: oGetAddrGlobal 12
10520: oPushResult
10521: oIdAdd_Chr
10522: oPushResult
10523: oCall 10110
10525: oPop 1
10527: oAssign
10528: oGetAddrGlobal 13
10530: oPushResult
10531: oIdAdd_Pred
10532: oPushResult
10533: oCall 10110
10535: oPop 1
10537: oAssign
10538: oGetAddrGlobal 14
10540: oPushResult
10541: oIdAdd_Succ
10542: oPushResult
10543: oCall 10110
10545: oPop 1
10547: oAssign
10548: oReturn
