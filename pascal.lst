   2: title: 'Pascal Compiler 1.1.5 -- Jan 01 ''90';
         
      %
      %  Pascal.ssl
      %
      %  Pascal Compiler for the Amiga, by Steve Rice.
      %
      %  HISTORY
      %    11Sep89   First version, framework of parser.
      %    18Sep89   Added some semantic mechanisms.
      %    21Sep89   Added simple type references; expressions generate code.
      %    22Sep89   Allocate variable addresses as they're declared.
      %    24Sep89   Added arrays, pointers.
      %    27Sep89   Added for statement.
      %    23Oct89   Fixed for statement, so CYCLE goes to next step.
      %    01Jan90   Added string literals
      %    09Sep22   I have returned.  Migrate symbol table to schema, to ease development.
      %
      %  NOTES
      %    1) During a loop, the top counter counts the number of 'exit'
      %       statements to be patched.
      %    2) During a loop, the top entry in the patchLoop stack is the addr
      %       of the start of the loop (used by 'cycle' to repeat the loop).
      %    3) The 'value' of a var symbol is its allocated address.
      %    4) References to vars of intrinsic types, and pointer types,
      %       pushes the value of the var on the expr stack.  Referenecs to
      %       vars of compound types (arrays, records...) pushes the address
      %       on the expr stack.
      %    5) Just as there is only one type table entry for a given (named) type,
      %       there is only one type table entry for a pointer to a named type.
      %       When a pointer type is declared, a field in the TT entry of the
      %       type pointed to will be set to indicate the TT entry of the pointer
      %       to that type (0 means none defined yet).  When evaluating the
      %       expression ^x, the type in that field in the entry for the type of x
      %       will be used (unless it's 0, in which case a new TT entry will be
      %       created).
      %
      %
      %  MISSING
      %
      %    - proceudre and function forward declarations.
      %      I think it uses the keyword 'forward' in place of the body.
      %      Only one forward declaration is allowed.  I will overwrite the nMethod info
      %      with the final addr and param names when the true body is seen.
      %      If a call is made to a foward declared method, add the forward decl node & Here to patch table.
      % 
      %    - procedure and function declarations may be nested within other procs/funcs!
      %      They are allowed to see locals within those parent scopes.
      %      Pass a hidden parameter to nested methods, to follow up to parent scopes as needed.
      %      Need a level counter at each scope, and uplevels count on reference to local/param.
      %      
      %    - Confirm that var decls can't be nested inside statements as they can in C.
      %      (i.e. is my "Block" concept correct?)
      %      
      %    - Non-ISO extensions.  Look at "Units" e.g. from Turbo Pascal wikipedia page.
      %
      %  PASCAL DOCS
      %      Here's some handy language material:
      %      https://www.freepascal.org/docs-html/ref/ref.html
      %      https://www.freepascal.org/docs-html/prog/prog.html
      %      https://en.wikipedia.org/wiki/Turbo_Pascal
      %      https://en.wikipedia.org/wiki/Pascal_(programming_language)#Standards
      %
      
   2: input:
   2:    pIdent
   2:    pIntLit
   2:    pStrLit
   2:    pAssign       ':='
   2:    pSemiColon    ';'
   2:    pEqual        '='
   2:    pNotEqual     '<>'
   2:    pLess         '<'
   2:    pGreater      '>'
   2:    pLessEqual    '<='
   2:    pGreaterEqual '>='
   2:    pColon        ':'
   2:    pComma        ','
   2:    pLParen       '('
   2:    pRParen       ')'
   2:    pLSquare      '['
   2:    pRSquare      ']'
   2:    pCarat        '^'
   2:    pDot          '.'
   2:    pDotDot       '..'
   2:    pTimes        '*'
   2:    pDivide       '/'
   2:    pPlus         '+'
   2:    pMinus        '-'
   2:    pEof
   2:    pInvalid
      
      %  keywords  (built-in types 'integer', 'char', etc, are not keywords,
      %             type constructors 'array', 'record', 'set' are keywords,
      %             pseudo-procedures 'writeln', 'readln' are keywords)
      
   2:    pProgram
   2:    pProcedure
   2:    pFunction
   2:    pConst
   2:    pType
   2:    pVar
   2:    pBegin
   2:    pEnd
   2:    pArray
   2:    pRecord
   2:    pSet
   2:    pOf
   2:    pIf
   2:    pThen
   2:    pElse
   2:    pFor
   2:    pTo
   2:    pDownto
   2:    pDo
   2:    pWhile
   2:    pRepeat
   2:    pUntil
   2:    pCycle
   2:    pExit
   2:    pReturn
   2:    pAnd
   2:    pOr
   2:    pNot
   2:    pWriteln
   2:    pWrite
   2:    pReadln
   2:    pRead;
      
      
   2: output:
      
      %  Instructions for a stack machine (all vars are 32-bit integers)
      
   2:    tPushGlobalI      % <ptr> - push int value read from ptr
   2:    tPushGlobalB      % <ptr> - push byte value read from ptr
   2:    tPushGlobalP      % <ptr> - push ptr value read from ptr
   2:    tPushLocalI       % <offset> - push int value read from local var
   2:    tPushLocalB       % <offset> - push byte value read from local var
   2:    tPushLocalP       % <offset> - push ptr value read from local var
   2:    tPushParamI       % <offset> - push int value read from local var
   2:    tPushParamB       % <offset> - push byte value read from local var
   2:    tPushParamP       % <offset> - push ptr value read from local var
      
   2:    tPushConstI       % <int> - push int value on stack (NOTE, used for BOOLEAN too)
   2:    tPushConstP       % <ptr> - push constant ptr value
   2:    tPushAddrGlobal   % <offset> - push ptr to global var (same as tPushConstP)
   2:    tPushAddrLocal    % <offset> - push ptr to local var
   2:    tPushAddrParam    % <offset> - push ptr to formal param (used by method to see its param)
   2:    tPushAddrActual   % <offset> - push ptr to actual param, in actuals space (used by caller)
   2:    tFetchI           % pop ptr from stack, and push int value it points to
   2:    tFetchB           %    "      "      "     "     byte  "   "    "
   2:    tFetchP           %    "      "      "     "     ptr   "   "    "   
   2:    tAssignI          % assign int value on top of stack to addr under it (pop both)
   2:    tAssignB          %   "    byte   "    "   "  "   "    "    "   "   "
   2:    tAssignP          %   "    ptr    "    "   "  "   "    "    "   "   "
   2:    tCopy             % #words follows.  tos=src, 2nd=dest (pop 2)
   2:    tIncGlobalI       % <ptr> - increment int value pointed to by ptr
   2:    tDecGlobalI       % <ptr> - decrement int value pointed to by ptr
   2:    tMultI            % multiply top two integers (replacing with result)
   2:    tDivI
   2:    tAddI  
   2:    tSubI
   2:    tNegI             % top entry *= -1
   2:    tNot              % negate top boolean
   2:    tAnd              % boolean AND of top 2 (pop 2, push 1)
   2:    tOr               % boolean OR or top 2 (pop 2, push 1)
   2:    tEqualI           % top two entries equal? (pop 2, push 1) (true=1)
   2:    tNotEqualI        %    NOTE, these all work for booleans too
   2:    tGreaterI         % 2nd entry greater than top entry? (pop 2, push answer)
   2:    tLessI  
   2:    tGreaterEqualI
   2:    tLessEqualI
   2:    tEqualP           % two two pointer values equal? (pop 2, push 1) (true=1)
   2:    tNotEqualP
   2:    tAllocActuals     % <#bytes> - make space on call stack for actual params (adjusting call stack sp)
   2:    tFreeActuals      % <#bytes> - discard space on call stack allocated by tAllocActuals
   2:    tCall             % addr follows
   2:    tReturn
   2:    tEnter            % <#bytes> - start a stack frame on the call stack, reserving #bytes of local variable space
   2:    tJump             % addr follows
   2:    tJumpTrue         % addr follows  (pops top of stack, jumps if true)
   2:    tJumpFalse        % addr follows  (pops top of stack, jumps if false)
   2:    tWriteI           % for writeln : write integer on tos, pop
   2:    tWriteBool        %  "     "    : write TRUE/FALSE, pop
   2:    tWriteStr         %  "     "    : write string whose addr is on tos, pop
   2:    tWriteP           %  "     "    : write ptr var whose addr is on tos, pop
   2:    tWriteCR          %  "     "    : write cr
      
      %  Other:
      
   2:    tSpace            % emit a hole, to be patched later
   2:    ;
      
   2: error:
   2:    eBadStatement
   2:    eNotConst
   2:    eNotType
   2:    eNotOrdinalType
   2:    eNotVar
   2:    eNotIntVar
   2:    eNotValue
   2:    eNotInteger
   2:    eNotBoolean
   2:    eNotPointer
   2:    eNotArray
   2:    eNotRecord
   2:    eNotRecordField
   2:    eTooManySubscripts
   2:    eTypeMismatch
   2:    eMissingParameter
   2:    eNotImplemented
   2:    eNotAllowed
   2:    eNotInALoop
   2:    eRecordEmpty
   2:    ;
      
   2: include 'pascal_schema.ssl'
      
      % Generated automatically by schema
      
   2: type node_type:
   2: 	nINVALID
   2: 	Object
   2: 	nScope
   2: 	nDeclaration
   2: 	nIdent
   2: 	nProgram
   2: 	nMethod
   2: 	nProc
   2: 	nFunc
   2: 	nConst
   2: 	nTypeDecl
   2: 	nVar
   2: 	nGlobalVar
   2: 	nLocalVar
   2: 	nRecordField
   2: 	nParam
   2: 	nType
   2: 	nFileType
   2: 	nIntegerType
   2: 	nBooleanType
   2: 	nCharType
   2: 	nStringType
   2: 	nPointerType
   2: 	nArrayType
   2: 	nSubrangeType
   2: 	nRecordType
   2: 	nEnumType
   2: 	nSetType
   2: 	;
      
   2: type node_attribute:
   2: 	qINVALID
   2: 	qParentScope
   2: 	qDecls
   2: 	qNextOffset
   2: 	qIdent
   2: 	qKind
   2: 	qType
   2: 	qParamType
   2: 	qValue
   2: 	qParams
   2: 	qChildScope
   2: 	qAddrDefined
   2: 	qInOut
   2: 	qSize
   2: 	qPointerType
   2: 	qBaseType
   2: 	qIndexType
   2: 	qLow
   2: 	qHigh
   2: 	qScope
   2: 	;
      
      
   2: type Node:     % A pointer to a node in the schema database (symbol database)
   2:     Null = 0
   2:     ;
      
   2: type NodeVec:  % A pointer to a vector of Node.  See mechanism node_vec_mech
   2:     NullVec = 0
   2:     ;
      
   2: type boolean:
   2:    false    = 0
   2:    true     = 1;
      
   2: type kind:           % kind of identifier
   2:    kUndefined        % not yet added to symbol table
   2:    kProgram
   2:    kProc
   2:    kFunc
   2:    kConst
   2:    kType
   2:    kVar;
      
      % intrinsic types & type constructs
      
   2: type typ:
   2:    tyNone     = 0    % in ptrTyp field of TT, means no ptr to type defined
   2:    tyInteger
   2:    tyBoolean
   2:    tyChar
   2:    tyString
   2:    tyFile            % tyInteger..tyFile are scalars (types on their own)
   2:    tyPointer         % following are type constructor classes...
   2:    tyArray           %   (they are not type#'s)
   2:    tyRecord
   2:    tyParams          % like record; a collection of proc/func params
   2:    tySet;
      
      
      % Some general schema node operations.
      % node_type and node_attribute are defined in generated file pascal_schema.ssl included above.
      %
   2: mechanism node_mech:
   2:     oNodeNew (node_type) >> Node         % create new node
   2:     oNodeSet (Node, node_attribute, Node)   % set Node attribute of node
   2:     oNodeSetInt (Node, node_attribute, int) % set int attribute of node
   2:     oNodeSetBoolean (Node, node_attribute, boolean)
   2:     oNodeSetKind (Node, node_attribute, kind) % set attribute of node  *** MIGHT NOT NEED
   2:     oNodeGet (Node, node_attribute) >> Node    % get Node attribute of node
   2:     oNodeGetInt (Node, node_attribute) >> int  % get int attribute of node
   2:     oNodeGetBoolean (Node, node_attribute) >> boolean  % get int attribute of node
   2:     oNodeNull (Node) >> boolean          % is node null?
   2:     oNodeNext (inout Node)               % advance Node to next in list
   2:     oNodeType (Node) >> node_type        % return node type of node
   2:     oNodeEqual (Node, Node) >> boolean   % compare two nodes for equality
                                               % (i.e. same node, not just same contents)
   2:     ;
      
      
      % Manipulate a temporary vector of Node
      %
   2: mechanism node_vec_mech:
   2:     oNodeVecNew >> NodeVec
   2:     oNodeVecDelete( NodeVec nv )
   2:     oNodeVecAppend( NodeVec nv, Node n )
   2:     oNodeVecSize( NodeVec nv ) >> int                % how many elements
   2:     oNodeVecElement( NodeVec nv, int idx ) >> Node   % element at index idx (0..size-1)
   2:     ;
      
      
   2: mechanism emit_mech:
   2:     oEmitInt( int )              % emit int into the generated code
   2:     Here >> int                  % current address in the generated code
   2:     oPatch( int addr, int val )  % patch an int into address in the generated code
   2:     ;
      
   2: mechanism math:
   2:     inc (inout int)
   2:     dec (inout int)
   2:     negate (int) >> int
   2:     subtract( int x, int y ) >> int     % x - y
   2:     multiply( int x, int y ) >> int     % x * y
   2:     equal( int x, int y ) >> boolean
   2:     equal_zero (int) >> boolean
   2:     equal_node_type (node_type, node_type) >> boolean     % Want equal_<type> for every type
   2:     ;
      
   2: mechanism more_builtins:      % These should be built-in SSL operations
   2:     TOKEN_VALUE >> int        % value of just accepted token, e.g. IntLit token
   2:     LAST_ID >> int            % id number of last accepted identifier
   2:     ;
      
   2: mechanism scope_mech:
   2:     oScopeBegin                          % create a new scope. Subsequent declarations will go here.
   2:     oScopeEnter( Node scope )            % enter an existing scope.
   2:     oScopeEnd                            % end current scope. Subsequent declarations will go to previous scope.
   2:     oScopeCurrent >> Node                % returns current scope
   2:     oScopeDeclare( Node )                % add declaration to current scope.
   2:     oScopeDeclareAlloc( Node )           % add declaration to current scope, and allocate space according to its type
   2:     oScopeFind >> Node                   % find declaration of last accepted identifier.  Returns Null if not found.
   2:     oScopeFindRequire >> Node            % find declaration of last accepted identifier.  Error if not found.
   2:     ;
      
      
   2: mechanism type_mech:
   2:     oTypeAdd( Node node )     % add the given nType to the type table
   2:     ;
      
   2: mechanism type_stack_mech:
   2:     oTypeSPush( Node node )
   2:     oTypeSPop
   2:     oTypeSTop >> Node
   2:     oTypeSNodeType >> node_type          % node_type of the node on top of type stack, skipping subranges
   2:     ;
      
      
   2: mechanism id_mech:
          % adds a predefined id to the scanner's id table, and returns the id code
   2:     oIdAdd_File >> int
   2:     oIdAdd_Integer >> int
   2:     oIdAdd_Boolean >> int
   2:     oIdAdd_Char >> int
   2:     oIdAdd_String >> int
   2:     oIdAdd_True >> int
   2:     oIdAdd_False >> int
   2:     ;
      
      
   2: mechanism count :
   2:    oCountPush(int)          % start a new counter, with initial value
   2:    oCountInc
   2:    oCountDec
   2:    oCountIsZero >> boolean
   2:    oCountPop;
      
      
   2: mechanism value :              % value stack, to calc. const expr's
   2:    oValuePush(int)             % push an explicit int lit
   2:    oValueNegate                % negate top value
   2:    oValueTop >> int            % get top value on value stack
   2:    oValuePop;
      
   2: mechanism string :
   2:    oStringAllocLit;            % alloc data space for strlit, push address
                                     %   on value stack
      
   2: type patchStack:
   2:    patchLoop                   % addr of start of loop (repeat, while, for)
   2:    patchExit                   % addrs where jumps out of loop are
                                     %   (use count mechanism to count how many)
   2:    patchIf;                    % addr of jump around code in 'if' statement
      
   2: mechanism patch:               % note, creates absolute-address jumps
   2:    oPatchPushHere(patchStack)  % put current address on a patch stack
   2:    oPatchAnyEntries(patchStack) >> boolean     % anything in patch stack?
   2:    oPatchSwap(patchStack)      % swap top two entries
   2:    oPatchDup(patchStack)       % duplicate the top entry
   2:    oPatchPopFwd(patchStack)    % store here at x (x=top of stack), pop stack
   2:    oPatchPopBack(patchStack);  % emit x (so advance 'here'), pop stack
      
   2: rules
      
      % ----------------------------- Global Variables ----------------------------
      
   2: Node    globalScope            % global nScope
      
      % built-in nTypes
   2: Node    FileType
   2: Node    IntegerType
   2: Node    BooleanType
   2: Node    CharType
   2: Node    StringType
      
      % -------------------------- Forward Declarations -------------------------
      
   2: Block( node_type varNodeType, out int addr );
   2: VarDecl( node_type varNodeType );
   2: newType( node_type nt, int size ) >> Node;
   2: newIdent( node_type nt, kind k, int id ) >> Node;
   2: EmitValue( Node decl );
   2: TypeRef( out Node theType );
   2: PointerTypeTo( Node theType ) >> Node;
   2: OrdinalLow( Node theType ) >> int;
   2: AssignStmt( Node decl );
   2: VarExpr( Node decl );
   2: VarLValue( Node decl );
      
      
      % ----------------------------- Declarations ----------------------------
      
   2: Program:
   4:    Node t
      
   4:    oScopeBegin
   5:    globalScope = oScopeCurrent
      
  10:    @installBuiltIns
      
         % Start by jumping to the main program statement
  12:    int patchJumpMain
  12:    .tJump 
  14:    patchJumpMain = Here
  19:    .tSpace
      
  21:    pProgram
  23:    pIdent
      
  25:    t = @newIdent( nProgram, kProgram, LAST_ID )
  41:    oScopeDeclare( t )
      
  47:    [
  47:       | '(' :
  49:          pIdent      % input, output files
      
  51:          t = @newIdent( nVar, kVar, LAST_ID )
  67:          oNodeSet( t, qType, FileType )
  79:          oScopeDeclareAlloc( t )
      
  85:          ','
  87:          pIdent
      
  89:          t = @newIdent( nVar, kVar, LAST_ID )
 105:          oNodeSet( t, qType, FileType )
 117:          oScopeDeclareAlloc( t )
      
 123:          ')'
 125:       | * :
 130:    ]
 130:    ';'
      
 132:    int addr
 132:    @Block( nGlobalVar, addr )    % not including punctuation after body's 'end'
 142:    oPatch( patchJumpMain, addr )
      
 151:    '.'
 153:    oScopeEnd
 155:    ;
      
      
      % Returns the addr of the block's statements.
      % This might differ from the Here on entry to this rule,
      % due to method declarations in the block.
      %
 155: Block( node_type varNodeType, out int addr ):
 157:    {[
 157:       | pConst :     @ConstDecl
 161:       | pType :      @TypeDecl
 165:       | pVar :       @VarDecl( varNodeType )
 174:       | pProcedure : @ProcDecl
 178:       | pFunction :  @FuncDecl
 182:       | * :          >
 197:    ]}
 199:    addr = Here
      
         % proc/func body begins with tEnter
 204:    int patchLS
 204:    [ equal_node_type( varNodeType, nLocalVar )
 214:       | true :       .tEnter  patchLS = Here  .tSpace
 224:       | * :
 229:    ]
      
 229:    @Statement
 231:    .tReturn
      
 233:    [ equal_node_type( varNodeType, nLocalVar )
 243:       | true :
 244:          int localSpace
 244:          localSpace = oNodeGetInt( oScopeCurrent, qNextOffset )
 256:          oPatch( patchLS, localSpace )
 265:       | * :
 270:    ];
      
      
 271: ProcDecl:
 273:    Node decl
      
 273:    pIdent
 275:    decl = @newIdent( nProc, kProc, LAST_ID )
      
 291:    oScopeBegin
 292:    Node paramScope
 292:    paramScope = oScopeCurrent
      
 297:    @FormalArgDecl
 299:    oNodeSet( decl, qParams, paramScope )
 311:    oScopeEnd
      
 312:    oScopeDeclare( decl )
 318:    ';'
      
         % Enter the params scope again, so params are visible in body.
         % TO DO: Perhaps I could mark the scope read-only at this point.
 320:    oScopeEnter( paramScope )
      
         % Start scope for declarations within the proc
 326:    oScopeBegin
 327:    int addr
 327:    @Block( nLocalVar, addr )
 337:    oNodeSet( decl, qChildScope, oScopeCurrent )
 348:    oNodeSetInt( decl, qValue, addr )
 360:    oNodeSetBoolean( decl, qAddrDefined, true )
 372:    oScopeEnd
      
 373:    oScopeEnd  % paramScope
 374:    ';';
      
 377: FuncDecl:
 379:    Node decl
 379:    Node theType
      
 379:    pIdent
 381:    decl = @newIdent( nFunc, kFunc, LAST_ID )
      
 397:    oScopeBegin
 398:    Node paramScope
 398:    paramScope = oScopeCurrent
      
 403:    @FormalArgDecl
 405:    oNodeSet( decl, qParams, paramScope )
 417:    oScopeEnd
      
 418:    oScopeDeclare( decl )
 424:    ':'
      
 426:    @TypeRef( theType )
 433:    oNodeSet( decl, qType, theType )
 445:    ';'
      
         % Enter the params scope again, so params are visible in body.
         % TO DO: Perhaps I could mark the scope read-only at this point.
 447:    oScopeEnter( paramScope )
      
 453:    oScopeBegin
 454:    int addr
 454:    @Block( nLocalVar, addr )
 464:    oNodeSet( decl, qChildScope, oScopeCurrent )
 475:    oNodeSetInt( decl, qValue, addr )
 487:    oNodeSetBoolean( decl, qAddrDefined, true )
 499:    oScopeEnd
      
 500:    oScopeEnd  % paramScope
 501:    ';';
      
      
      % TO DO:
      %   This code is declaring params in the wrong order.
      %   Also ignoring var keyword.
      %   Also not using schema yet.
      %   Also should use a var instead of count stack.
      %
 504: FormalArgDecl:
 506:    [
 506:       | '(' :
 508:          {
 508:             NodeVec decls
 508:             decls = oNodeVecNew
 513:             Node decl
 513:             boolean isInOut
 513:             isInOut = false
      
 519:             [
 519:                | pVar : isInOut = true
 527:                | * :
 532:             ]
      
 532:             {  pIdent
      
 534:                decl = @newIdent( nParam, kVar, LAST_ID )
 550:                oNodeSetBoolean( decl, qInOut, isInOut )
 562:                oNodeVecAppend( decls, decl )
      
 571:                [
 571:                   | ':' : >
 575:                   | ',' :
 577:                ]
 585:             }
      
 587:             Node theType
 587:             @TypeRef( theType )
      
 594:             int i
 594:             i = 0
 600:             {[ equal( i, oNodeVecSize( decls ) )
 614:                | false :
 615:                   decl = oNodeVecElement( decls, i )
 628:                   oNodeSet( decl, qType, theType )
 640:                   oScopeDeclareAlloc( decl )
 646:                   inc( i )
 652:                | * :
 657:                   >
 659:             ]}
      
 661:             oNodeVecDelete( decls )
      
 667:             [
 667:                | ')' : >
 671:                | ';' :
 673:             ]
 681:          }
 683:       | * :
 688:    ];
      
 689: ConstDecl:
 691:    {[
 691:       | pIdent :
 693:          Node decl
 693:          decl = @newIdent( nConst, kConst, LAST_ID )
 709:          '='
      
 711:          @ConstExpr
               % TO DO: currently ConstExpr leaves int result on oValue stack
 713:          int val
 713:          val = oValueTop
 718:          oValuePop
 719:          oNodeSetInt( decl, qValue, val )
      
               % TO DO: different types.  Currently assumes int!
 731:          oNodeSet( decl, qType, IntegerType )
      
 743:          oScopeDeclare( decl )
 749:          ';'
 751:       | * :
 756:          >
 758:    ]};
      
 761: TypeDecl:
 763:    {[
 763:       | pIdent :
 765:          Node decl
 765:          decl = @newIdent( nTypeDecl, kType, LAST_ID )
 781:          '='
 783:          Node theType
 783:          @TypeRef( theType )
 790:          oNodeSet( decl, qType, theType )
 802:          oScopeDeclare( decl )
 808:          ';'
 810:       | * :
 815:          >
 817:    ]};
      
 820: VarDecl( node_type varNodeType ):
 822:    {[
 822:       | pIdent :
 824:          NodeVec decls
 824:          decls = oNodeVecNew
 829:          Node decl
 829:          {
 829:             decl = @newIdent( varNodeType, kVar, LAST_ID )
 845:             oNodeVecAppend( decls, decl )
 854:             [
 854:                | ',' :
 856:                   pIdent
 858:                | * :
 863:                   >
 865:             ]
 865:          }
 867:          ':'
 869:          Node theType
 869:          @TypeRef( theType )
      
 876:          int i
 876:          i = 0
 882:          {[ equal( i, oNodeVecSize( decls ) )
 896:            | false :
 897:              decl = oNodeVecElement( decls, i )
 910:              oNodeSet( decl, qType, theType )
 922:              oScopeDeclareAlloc( decl )
 928:              inc( i )
 934:             | * :
 939:               >
 941:          ]}
      
 943:          oNodeVecDelete( decls )
 949:          ';'
 951:       | * :
 956:          >
 958:    ]};
      
      
      % Parse a type reference, returning the nType.
      % This will add types to the type table, as needed.
      %
      % Style question - at the moment I think callers look clearer if we use
      % an out param here, rather than a return value.
      %
 961: TypeRef( out Node resultType ):
 963:    [
 963:       | pIdent :           % previously named type (including intrinsics)
 965:          Node decl
 965:          decl = oScopeFindRequire
 970:          [ oNodeType( decl )
 977:            | nTypeDecl :
 978:                resultType = oNodeGet( decl, qType )
 991:            | * :
 996:                #eNotType
 998:                resultType = IntegerType
1004:          ]
         
1004:       | pArray :
1006:          '['
      
               % A multi-dimensional array is represented as a chain
               %    array [subrange1] of array [subrange2] of elementType
      
               % First, we build a vector of nArray's, each with one subrange as its index type,
               % but without setting the "of" type or size.
      
1008:          NodeVec dimensions
1008:          dimensions = oNodeVecNew
      
1013:          {
                  % to do: probably should use general subrange parsing, incl minimal size value
                  %   In fact, supposed to parse ordinal_type here.  all ordinal types have a static low, high.
                  %   Not necessary to be a subrange.
      
1013:             Node subrange
1013:             subrange = oNodeNew( nSubrangeType )
                  % TO DO: currently assuming subrange of integer
1023:             oNodeSet( subrange, qBaseType, IntegerType )
      
                  % TO DO: currently ConstExpr leaves int result on oValue stack
1035:             @ConstExpr
1037:             oNodeSetInt( subrange, qLow, oValueTop )
1048:             oValuePop
1049:             '..'
1051:             @ConstExpr
1053:             oNodeSetInt( subrange, qHigh, oValueTop )
1064:             oValuePop
1065:             oNodeSetInt( subrange, qSize, 4 )   % maybe don't need
      
1077:             oTypeAdd( subrange )
      
1083:             Node a
1083:             a = oNodeNew( nArrayType )
1093:             oNodeSet( a, qIndexType, subrange )
      
1105:             oNodeVecAppend( dimensions, a )
                  % I'll hold off on adding 'a' to the type table since not fully formed yet
      
1114:             [
1114:                | ']' : >
1118:                | ',' :
1120:             ]
1128:          }
1130:          pOf
1132:          Node baseType
1132:          @TypeRef( baseType )
      
               % Work backwards through the dimensions,
               % hooking up the 'of' type and calculating the size.
               % At each iteration, baseType is the 'of' type.
      
1139:          int dim
1139:          dim = oNodeVecSize( dimensions )
1149:          {
1149:              dec(dim)
      
1155:              Node a
1155:              a = oNodeVecElement( dimensions, dim )
1168:              oNodeSet( a, qBaseType, baseType )
1180:              Node subrange
1180:              subrange = oNodeGet( a, qIndexType )
1193:              int width
1193:              width = subtract( oNodeGetInt( subrange, qHigh ), oNodeGetInt( subrange, qLow ) )
1220:              inc( width )
1226:              oNodeSetInt( a, qSize, multiply( width, oNodeGetInt( baseType, qSize ) ) )
      
1252:              oTypeAdd( a )
1258:              baseType = a
      
1264:              [ equal_zero(dim)
1271:                  | true:  >
1274:                  | *:
1279:              ]
1279:          }
      
1281:          resultType = oNodeVecElement( dimensions, 0 )
1294:          oNodeVecDelete( dimensions )
      
1300:       | '^' :
1302:          Node theType
1302:          @TypeRef( theType )
1309:          resultType = @PointerTypeTo( theType )
      
1320:       | pRecord :
1322:          resultType = oNodeNew( nRecordType )
1332:          oScopeBegin
      
1333:          @VarDecl( nRecordField )
      
1340:          int size
1340:          size = oNodeGetInt( oScopeCurrent, qNextOffset )
               % to do: padding
1352:          [ equal_zero( size )
1359:             | true : #eRecordEmpty
1362:             | * :
1367:          ]
      
1367:          pEnd
      
1369:          oNodeSet( resultType, qScope, oScopeCurrent )
1380:          oNodeSetInt( resultType, qSize, size )
1392:          oScopeEnd
1393:          oTypeAdd( resultType )
      
      
            % *** TO DO: following type constructors are not implemented *** 
            % *** TO DO: also missing declaration of enum type
1399:       | pSet :
1401:          pOf
1403:          Node theType
1403:          @TypeRef( theType )
1410:       | * :       % this works for cases except where expr starts with an id
1423:          @ConstExpr '..' @ConstExpr
1429:    ];
      
      
      % ------------------------------ Expressions -----------------------------
      
      % Constant expressions: currently, only literal integers or previously
      % named constant integers are supported, possibly with a negation.
      % Constant expressions are evaluated at compile time.
      
1430: ConstExpr:
1432:    [
1432:       | pIntLit :
1434:          oValuePush( TOKEN_VALUE )
1439:       | pIdent :
1441:          Node decl
1441:          decl = oScopeFindRequire
1446:          [ oNodeType( decl )
1453:             | nConst :
1454:                oValuePush( oNodeGetInt( decl, qValue ) )
1467:             | * :
1472:                #eNotConst
1474:                oValuePush( 0 )
1480:          ]
1480:       | pMinus :
1482:          @ConstExpr
1484:          oValueNegate
1485:    ];
      
      %
      % General run-time expressions
      % The type stack tracks the type of the expression.
      %
      
1496: Expr:
1498:    @BoolExpr
1500:    {[
1500:       | '=' :
1502:          @BoolExpr
1504:          @MatchTypes
1506:          [ oTypeSNodeType
1508:             | nIntegerType, nBooleanType :  .tEqualI
1511:             | nPointerType :                .tEqualP
1515:             | nCharType, nStringType :      #eNotImplemented
1519:             | * :                           #eNotAllowed
1534:          ]
1534:          oTypeSPop
1535:          oTypeSPush( BooleanType )
      
1541:       | '<>' :
1543:          @BoolExpr
1545:          @MatchTypes
1547:          [ oTypeSNodeType
1549:             | nIntegerType, nBooleanType :  .tNotEqualI
1552:             | nPointerType :                .tNotEqualP
1556:             | nCharType, nStringType :      #eNotImplemented
1560:             | * :                           #eNotAllowed
1575:          ]
1575:          oTypeSPop
1576:          oTypeSPush( BooleanType )
      
1582:       | '<' :
1584:          @BoolExpr
1586:          @MatchTypes
1588:          [ oTypeSNodeType
1590:             | nIntegerType, nBooleanType :  .tLessI
1593:             | nCharType, nStringType :      #eNotImplemented
1597:             | * :                           #eNotAllowed
1610:          ]
1610:          oTypeSPop
1611:          oTypeSPush( BooleanType )
      
1617:       | '>' :
1619:          @BoolExpr
1621:          @MatchTypes
1623:          [ oTypeSNodeType
1625:             | nIntegerType, nBooleanType :  .tGreaterI
1628:             | nCharType, nStringType :      #eNotImplemented
1632:             | * :                           #eNotAllowed
1645:          ]
1645:          oTypeSPop
1646:          oTypeSPush( BooleanType )
      
1652:       | '<=' :
1654:          @BoolExpr
1656:          @MatchTypes
1658:          [ oTypeSNodeType
1660:             | nIntegerType, nBooleanType :  .tLessEqualI
1663:             | nCharType, nStringType :      #eNotImplemented
1667:             | * :                           #eNotAllowed
1680:          ]
1680:          oTypeSPop
1681:          oTypeSPush( BooleanType )
      
1687:       | '>=' :
1689:          @BoolExpr
1691:          @MatchTypes
1693:          [ oTypeSNodeType
1695:             | nIntegerType, nBooleanType :  .tGreaterEqualI
1698:             | nCharType, nStringType :      #eNotImplemented
1702:             | * :                           #eNotAllowed
1715:          ]
1715:          oTypeSPop
1716:          oTypeSPush( BooleanType )
      
1722:       | * :
1737:          >
1739:    ]};
      
1742: BoolExpr:
1744:    @BoolTerm
1746:    {[
1746:       | pOr :
1748:          @RequireBoolPop
1750:          @BoolTerm
1752:          @RequireBool
1754:          .tOr
1756:       | * :
1761:          >
1763:    ]};
      
1766: BoolTerm:
1768:    @BoolFactor
1770:    {[
1770:       | pAnd :
1772:          @RequireBoolPop
1774:          @BoolFactor
1776:          @RequireBool
1778:          .tAnd
1780:       | * :
1785:          >
1787:    ]};
      
1790: BoolFactor:
1792:    [
1792:       | pNot :
1794:          @ArithExpr
1796:          @RequireBool
1798:          .tNot
1800:       | * :
1805:          @ArithExpr
1807:    ];
      
1808: ArithExpr:
1810:    @Term
1812:    {[
1812:       | pPlus :
1814:          @RequireIntPop
1816:          @Term
1818:          @RequireInt
1820:          .tAddI
1822:       | pMinus :
1824:          @RequireIntPop
1826:          @Term
1828:          @RequireInt
1830:          .tSubI
1832:       | * :
1839:          >
1841:    ]};
      
1844: Term:
1846:    @Factor
1848:    {[
1848:       | pTimes :
1850:          @RequireIntPop
1852:          @Factor
1854:          @RequireInt
1856:          .tMultI
1858:       | pDivide :
1860:          @RequireIntPop
1862:          @Factor
1864:          @RequireInt
1866:          .tDivI
1868:       | * :
1875:          >
1877:    ]};
      
1880: Factor:
1882:    [
1882:       | pPlus :
1884:          @Primary
1886:          @RequireInt
1888:       | pMinus :
1890:          @Primary
1892:          @RequireInt
1894:          .tNegI
1896:       | * :
1903:          @Primary
1905:    ];
      
1906: Primary:
1908:    [
1908:       | pIntLit :
1910:          .tPushConstI  oEmitInt( TOKEN_VALUE )
1917:          oTypeSPush( IntegerType )
      
1923:       | '(' :
1925:          @Expr
1927:          ')'
      
1929:       | pStrLit :
1931:          oStringAllocLit     % store, put addr on value stack
1932:          .tPushConstP oEmitInt( oValueTop )  oValuePop
               % TO DO: do we need to create a type with the literal's length?
1940:          oTypeSPush( StringType )
      
1946:       | pIdent :
1948:          Node decl
1948:          Node theType
1948:          decl = oScopeFindRequire
      
1953:          [ oNodeType( decl )
1960:             | nFunc :
      
1961:                @Call( decl )
      
1968:             | nConst :
1970:                theType = oNodeGet( decl, qType )
1983:                oTypeSPush( theType )
1989:                [ oTypeSNodeType
1991:                   | nIntegerType, nBooleanType :
1992:                      .tPushConstI @EmitValue( decl )
2001:                   | * :
2008:                      #eNotImplemented
2010:                ]
      
2010:             | nGlobalVar, nLocalVar, nParam :
2012:                @VarExpr( decl )
      
2019:             | * :
2032:                #eNotValue
2034:                oTypeSPush( IntegerType )
2040:          ]
      
2040:       | '^' :        % ^var
2042:          pIdent
      
2044:          Node decl
2044:          Node theType
2044:          decl = oScopeFindRequire
      
2049:          @VarLValue( decl )
      
               % The above leaves the pointed-to type on type stack.
               % But our expression type is actually ptr-to-<type>.
2056:          theType = oTypeSTop
2061:          oTypeSPop
2062:          Node ptrType
2062:          ptrType = @PointerTypeTo( theType )
2073:          oTypeSPush( ptrType )
      
2079:       | * :
2092:          #eNotValue
2094:          oTypeSPush( IntegerType )
2100:    ];
      
      
      % Parse a variable expression, given the declaration of the
      % just-accepted identifier.
      % Leaves the value on the expression stack, and type on the type stack.
      %
2101: VarExpr( Node decl ):
2103:    Node theType
2103:    theType = oNodeGet( decl, qType )
2116:    oTypeSPush( theType )
2122:    [ oTypeSNodeType
2124:       | nIntegerType :
2125:          [ oNodeType( decl )
2132:             | nGlobalVar :   .tPushGlobalI @EmitValue( decl )
2142:             | nLocalVar :    .tPushLocalI @EmitValue( decl )
2153:             | nParam :       .tPushParamI @EmitValue( decl )
                           % TO DO:   VAR params may need adjustment? (also cases below...)
2164:          ]
      
2174:       | nBooleanType :
2176:          [ oNodeType( decl )
2183:             | nGlobalVar :   .tPushGlobalB @EmitValue( decl )
2193:             | nLocalVar :    .tPushLocalB @EmitValue( decl )
2204:             | nParam :       .tPushParamB @EmitValue( decl )
2215:          ]
      
2225:       | nCharType, nStringType, nFileType :
2227:          #eNotImplemented
      
2229:       | nPointerType :
2231:          [ oNodeType( decl )
2238:             | nGlobalVar :   .tPushGlobalP @EmitValue( decl )
2248:             | nLocalVar :    .tPushLocalP @EmitValue( decl )
2259:             | nParam :       .tPushParamP @EmitValue( decl )
2270:          ]
2280:          [
2280:             | '^' :             % dereferenced
2282:                oTypeSPop
2283:                oTypeSPush( oNodeGet( theType, qBaseType ) )
2296:                @LValue
2298:                @FetchVar
2300:             | * :               % just ptr value alone
2305:          ]
      
2305:       | * :
               % compound type
               % first, push addr of start of var
2320:          [ oNodeType( decl )
2327:             | nGlobalVar :   .tPushAddrGlobal @EmitValue( decl )
2337:             | nLocalVar :    .tPushAddrLocal @EmitValue( decl )
2348:             | nParam :       .tPushAddrParam @EmitValue( decl )
2359:          ]
               % modify addr for subscripts, field references, etc
2369:          @LValue
               % get final value
2371:          @FetchVar
2373:    ];
      
      
      % Addr of start of var is on expr stack; type is on type stack.
      % Replace expr stack with value of var.
      % (In the case of compound vars, this remains as the addr of the var).
      
2374: FetchVar:
2376:    [ oTypeSNodeType
2378:       | nIntegerType :   .tFetchI
2381:       | nBooleanType :   .tFetchB
2385:       | nCharType, nStringType, nFileType : #eNotImplemented
2389:       | nPointerType :   .tFetchP
2393:       | * :              % compound type; leave as addr
2408:    ];
      
      
      % Addr of start of var is already on run stack, and type is on type stack.
      % Read subscripts, etc, to get final addr on run stack, and final type
      % on type stack.
      
2409: LValue:
2411:    {[
2411:       | '[' :       @ArraySubscripts
2415:       | '.' :       @RecordFieldRef
2419:       | '^' :       @PointerDeref
2423:       | * :         >
2434:    ]};
      
2437: ArraySubscripts:
2439:    [ oTypeSNodeType
2441:       | nArrayType :
2442:       | * :       #eNotArray
2449:    ]
2449:    {
2449:       [ oTypeSNodeType
2451:          | nArrayType :
2452:          | * :    #eTooManySubscripts
2459:       ]
      
            % low subscript of this dimension
2459:       int low
2459:       low = @OrdinalLow( oNodeGet( oTypeSTop, qIndexType ) )
      
            % replace type stack with next dimension, or OF type
2476:       Node baseType
2476:       baseType = oNodeGet( oTypeSTop, qBaseType )
2488:       oTypeSPop
2489:       oTypeSPush( baseType )
      
2495:       @Expr
2497:       @RequireIntPop
            % adjust for low subscript
2499:       [ equal_zero( low )
2506:          | false :
2507:             .tPushConstI oEmitInt( low ) .tSubI
2517:          | * :
2522:       ]
      
            % multiply by element size
2522:       int size
2522:       size = oNodeGetInt( baseType, qSize )
2535:       [ equal( size, 1 )
2545:          | false :
2546:             .tPushConstI oEmitInt( size ) .tMultI
2556:          | * :
2561:       ]
      
            % update start address
2561:       .tAddI
2563:       [
2563:          | ']' :  >
2567:          | ',' :
2569:       ]
2577:    };
      
      
2580: RecordFieldRef:
2582:    [ oTypeSNodeType
2584:       | nRecordType :
2585:       | * :    #eNotRecord
2592:    ]
2592:    oScopeEnter( oNodeGet( oTypeSTop, qScope ) )
2604:    pIdent
2606:    Node field
2606:    field = oScopeFindRequire
         % oScopeFind searches all open scopes, so make sure we found nRecordField
         % which could only be seen in the local scope we entered above.
2611:    [ oNodeType( field )
2618:       | nRecordField :
2619:       | * :   #eNotRecordField
2626:    ]
2626:    oScopeEnd
2627:    int offset
2627:    offset = oNodeGetInt( field, qValue )
2640:    [ equal_zero( offset )
2647:       | false :
2648:          .tPushConstI oEmitInt( offset ) .tAddI
2658:       | * :
2663:    ]
      
         % replace the type on the type stack, with the field type
2663:    oTypeSPop
2664:    oTypeSPush( oNodeGet( field, qType ) )
2678:    ;
      
      
      % ptr deref on left side, i.e. BEFORE addr of ptr var is on stack,
      %                              AFTER addr of thing pointed to is on stack
2678: PointerDeref:
2680:    [ oTypeSNodeType
2682:       | nPointerType :
2683:       | * :       #eNotPointer
2690:    ]
2690:    .tFetchP           % now addr on stack is addr of what we're pointing to
      
2692:    Node theType
2692:    theType = oTypeSTop
2697:    oTypeSPop
2698:    oTypeSPush( oNodeGet( theType, qBaseType ) )
2712:    ;
      
      
      % The expr stack contains a value whose type is on top of the type stack.
      % Generate code to coerce the value to the type under it in the type stack
      % (pop the type stack, leaving only the desired type).
      % This is used for assignment.
      %
2712: CoerceType:
         % TO DO: not implemented yet.  For now I require exact type match.
2714:    @MatchTypes
2717:    ;
      
      
      % Parse a call, given an nProc or nFunc for the just-accepted identifier.
      % If a func, this will also generate the code to push the return value on the expr stack,
      % and push the return type on the type stack.
      %
2717: Call( Node method ):
      
2719:    Node paramScope
2719:    paramScope = oNodeGet( method, qParams )
2732:    int actualsSize
2732:    actualsSize = oNodeGetInt( paramScope, qNextOffset )
2745:    .tAllocActuals  oEmitInt( actualsSize )
      
2753:    Node param
2753:    param = oNodeGet( paramScope, qDecls )
2766:    [
2766:       | '(' :
            
2768:          {
2768:             [ oNodeNull( param )
2775:                | true : >
2778:                | * :
2783:             ]
      
2783:             Node actualType
2783:             actualType = oNodeGet( param, qType )
2796:             int offset
2796:             offset = oNodeGetInt( param, qValue )
      
                  % Assign actual value to spot in actuals space
2809:             .tPushAddrActual oEmitInt( offset )
2817:             oTypeSPush( oNodeGet( param, qType ) )
      
2830:             [ oNodeGetBoolean( param, qInOut )
2840:                | true :
                                % I need something like @LvalueExpr
                                % that parses expr, generating code to push addr, and push type on type stack.
                                % Close to what I have but need to refactor.
2841:                           #eNotImplemented
                                % TO DO: match types more exactly. not sufficient to be assign compatible
                                %        since the method will be assigning to the actual using the param type.
                                %        Maybe something like type contents must match, incl subrange bounds.
2843:                           .tAssignP
      
2845:                | false :  @Expr
2849:                           @CoerceType
                                
                                % Assign to offset in actuals space
      
2851:                           [ oTypeSNodeType
2853:                              | nIntegerType :            .tAssignI
2856:                              | nBooleanType :            .tAssignB
2860:                              | nCharType, nStringType, nFileType :   #eNotImplemented
2864:                              | nPointerType :            .tAssignP
2868:                              | * :
                                       % compound types: copy value into actuals space
2883:                                  int size
2883:                                  size = oNodeGetInt( oTypeSTop, qSize )
2895:                                  .tCopy  oEmitInt( size )    % multi-word copy
2903:                           ]
2903:             ]
      
2911:             oNodeNext( param )
2917:             [ oNodeNull( param )
2924:                | true :  >
2927:                | false :
2929:             ]
      
2937:             ','
2939:          }
      
2941:          ')'
      
2943:       | * :
2948:          [ oNodeNull( param )
2955:             | false :    #eMissingParameter
2958:             | * :
2963:          ]
2963:    ]
      
2963:    .tCall   @EmitValue( method )
      
2972:    [ oNodeType( method )
2979:       | nFunc :
               % TO DO: push return value from actuals space
2980:          oTypeSPush( oNodeGet( method, qType ) )
2993:       | * :
2998:    ]
         
2998:    .tFreeActuals  oEmitInt( actualsSize )
3007:    ;
      
      
      % ------------------------------ Statements -----------------------------
      
3007: Statement:
3009:    [
3009:       | pWriteln :     @WritelnStmt
3013:       | pWrite :       @WriteStmt
3017:       | pReadln :      @ReadlnStmt
3021:       | pRead :        @ReadStmt
3025:       | pIf :          @IfStmt
3029:       | pWhile :       @WhileStmt
3033:       | pFor :         @ForStmt
3037:       | pRepeat :      @RepeatStmt
3041:       | pExit :        @ExitStmt
3045:       | pCycle :       @CycleStmt
3049:       | pBegin :       @BeginStmt
3053:       | pIdent :       @AssignOrCallStmt
3057:       | * :            % null statement : don't accept any tokens
3084:    ];
      
      
3085: AssignOrCallStmt:
3087:    Node decl
3087:    decl = oScopeFindRequire
3092:    [ oNodeType( decl )
3099:       | nProc :                           @Call( decl )
3107:       | nGlobalVar, nLocalVar, nParam :   @AssignStmt( decl )
3116:       | * :                               #eBadStatement
3129:    ];
      
      
      % Given decl, the just-accepted first identifier on the left hand side.
      %
3130: AssignStmt( Node decl ):
      
3132:    @VarLValue( decl )
      
3139:    ':=' 
3141:    @Expr
3143:    @MatchTypes
3145:    [ oTypeSNodeType
3147:       | nIntegerType :            .tAssignI
3150:       | nBooleanType :            .tAssignB
3154:       | nCharType, nStringType, nFileType :   #eNotImplemented
      
            % compound var assigns; addrs of src, dest on stack
3158:       | nPointerType :            .tAssignP
3162:       | * :
3177:           int size
3177:           size = oNodeGetInt( oTypeSTop, qSize )
3189:           .tCopy  oEmitInt( size )    % multi-word copy
3197:    ]
3197:    oTypeSPop
3199:    ;
      
      
      
      % Parse an lvalue expression (e.g. left side of an assign statement)
      % that stars with the just-accepted identifier indicated by the given decl.
      % Leaves the lvalue address on the expression stack, and the type on the type stack.
      %
3199: VarLValue( Node decl ):
3201:    [ oNodeType( decl )
3208:       | nGlobalVar :   .tPushAddrGlobal @EmitValue( decl )
3218:       | nLocalVar :    .tPushAddrLocal @EmitValue( decl )
3229:       | nParam :       .tPushAddrParam @EmitValue( decl )
                % TO DO:   VAR params may need adjustment?
3240:       | * :            #eNotVar
3251:    ]
      
3251:    oTypeSPush( oNodeGet( decl, qType ) )
3264:    @LValue        % handle subscripts, if any
3267:    ;
      
      
3267: IfStmt:
3269:    @Expr
3271:    @RequireBoolPop
3273:    pThen
3275:    .tJumpFalse
3277:    oPatchPushHere(patchIf)
3283:    .tSpace
3285:    @Statement
3287:    [
3287:       | pElse :
3289:          .tJump
3291:          oPatchPushHere(patchIf)
3297:          .tSpace
3299:          oPatchSwap(patchIf)
3305:          oPatchPopFwd(patchIf)
3311:          @Statement
3313:       | * :
3318:    ]
3318:    oPatchPopFwd(patchIf);
      
3325: ForStmt:
3327:    pIdent
      
3329:    Node decl
3329:    decl = oScopeFindRequire
3334:    [ oNodeType( decl )
3341:       | nGlobalVar :
3342:       | nLocalVar :    #eNotImplemented
3346:       | nParam :       #eNotImplemented
3350:       | * :            #eNotIntVar
3361:    ]
3361:    oTypeSPush( oNodeGet( decl, qType ) )
3374:    @RequireIntPop
3376:    .tPushConstP  @EmitValue( decl )
      
3385:    ':='
      
3387:    @Expr
3389:    @RequireIntPop
3391:    .tAssignI
      
3393:    .tJump oPatchPushHere(patchLoop) .tSpace
3403:    oPatchPushHere(patchLoop)
3409:    oPatchSwap(patchLoop)
3415:    [
3415:       | pTo :
3417:          .tIncGlobalI @EmitValue( decl )
3426:          oPatchPopFwd(patchLoop)
3432:          .tPushGlobalI @EmitValue( decl )
3441:          @Expr
3443:          @RequireIntPop
3445:          .tGreaterI
3447:          .tJumpTrue oPatchPushHere(patchLoop) .tSpace
3457:          oPatchSwap(patchLoop)
3463:       | pDownto :
3465:          .tDecGlobalI @EmitValue( decl )
3474:          oPatchPopFwd(patchLoop)
3480:          .tPushGlobalI @EmitValue( decl )
3489:          @Expr
3491:          @RequireIntPop
3493:          .tLessI
3495:          .tJumpTrue oPatchPushHere(patchLoop) .tSpace
3505:          oPatchSwap(patchLoop)
3511:    ]
3519:    oCountPush(0)          % count 'exit' patches
3525:    pDo
3527:    @Statement
3529:    .tJump oPatchPopBack(patchLoop)
3537:    oPatchPopFwd(patchLoop)
3543:    @PatchExitsPop;
      
3546: RepeatStmt:
3548:    oPatchPushHere(patchLoop) % start of loop
3554:    oCountPush(0)          % count the 'exit' patches
3560:    @Statement
3562:    {[
3562:       | ';' :
3564:          @Statement
3566:       | pUntil :
3568:          @Expr
3570:          @RequireBoolPop
3572:          .tJumpFalse
3574:          oPatchPopBack(patchLoop)
3580:          @PatchExitsPop
3582:          >
3584:    ]};
      
3595: WhileStmt:
3597:    oPatchPushHere(patchLoop)    % start of loop
3603:    oCountPush(0)
3609:    @Expr
3611:    @RequireBoolPop
3613:    pDo
3615:    .tJumpFalse
3617:    oPatchPushHere(patchLoop)    % jump out
3623:    .tSpace
3625:    oPatchSwap(patchLoop)        % start on top
3631:    @Statement
3633:    .tJump
3635:    oPatchPopBack(patchLoop)
3641:    oPatchPopFwd(patchLoop)
3647:    @PatchExitsPop;
      
3650: CycleStmt:                     % NOTE, for repeat..until, skips test (??)
3652:    [ oPatchAnyEntries(patchLoop)
3659:       | true :
3660:          .tJump
3662:          oPatchDup(patchLoop)  % addr of start
3668:          oPatchPopBack(patchLoop)
3674:       | * :
3679:          #eNotInALoop
3681:    ];
      
3682: ExitStmt:
3684:    [ oPatchAnyEntries(patchLoop)
3691:       | true :
3692:          .tJump
3694:          oPatchPushHere(patchExit)
3700:          .tSpace
3702:          oCountInc
3703:       | * :
3708:          #eNotInALoop
3710:    ];
      
3711: BeginStmt:
3713:    @Statement
3715:    {[
3715:       | ';' :   @Statement
3719:       | pEnd :  >
3723:    ]};
      
3734: WritelnStmt:
3736:    @WriteStmt
3738:    .tWriteCR;
      
3741: WriteStmt:
3743:    [
3743:       | '(' :
3745:          {
3745:             @Expr
3747:             [ oTypeSNodeType
3749:                | nIntegerType :             .tWriteI
3752:                | nBooleanType :             .tWriteBool
3756:                | nStringType :              .tWriteStr
3760:                | nCharType, nFileType :     #eNotImplemented
3764:                | nPointerType :             .tWriteP
3768:                | * :                        #eNotAllowed
3785:             ]
3785:             oTypeSPop
3786:             [
3786:                | ')' : >
3790:                | ',' :
3792:             ]
3800:          }
3802:       | * :
3807:    ];
      
      
3808: ReadlnStmt:      % ***
3811:    ;
3811: ReadStmt:
3814:    ;
      
      % -------------------------------- Utilities -------------------------------
      
3814: PatchExitsPop:
3816:    {[ oCountIsZero
3818:       | false : oPatchPopFwd(patchExit)
3825:                 oCountDec
3826:       | * :     >
3833:    ]}
3835:    oCountPop;
      
      
      % Require that the top two types on the type stack are matching (ignoring subranges).
      % Pop one of them, leaving only one.
      %
3837: MatchTypes:
3839:    node_type nt
3839:    nt = oTypeSNodeType
3844:    oTypeSPop
3845:    [ equal_node_type( nt, oTypeSNodeType )
3854:       | false :
3855:          #eTypeMismatch
3857:       | * :
3862:    ];
      
      
      % Require that the top type on the type stack is integer (ignoring subranges).
      % Pop it.
      %
3863: RequireIntPop:
3865:    [ oTypeSNodeType
3867:       | nIntegerType :
3868:       | * :          #eNotInteger
3875:    ]
3875:    oTypeSPop;
      
3877: RequireInt:
3879:    [ oTypeSNodeType
3881:       | nIntegerType :
3882:       | * :          #eNotInteger
3889:    ];
      
3890: RequireBoolPop:
3892:    [ oTypeSNodeType
3894:       | nBooleanType :
3895:       | * :          #eNotBoolean
3902:    ]
3902:    oTypeSPop;
      
3904: RequireBool:
3906:    [ oTypeSNodeType
3908:       | nBooleanType :
3909:       | * :          #eNotBoolean
3916:    ];
      
      
      % Create and return a new nType of the given node_type, adding it to the type table.
      %
3917: newType( node_type nt, int size ) >> Node:
3919:   Node node
3919:   node = oNodeNew( nt )
3929:   oNodeSetInt( node, qSize, size )
3941:   oTypeAdd( node )
3947:   >> node
3951:   ;
      
      
      % Create and return a new nIdent of the given node_type, with the given ident id.
      % Does not add it to any scope.
      %
3951: newIdent( node_type nt, kind k, int id ) >> Node:
3953:   Node t
3953:   t = oNodeNew( nt )
3963:   oNodeSetKind( t, qKind, k )   % deprecated attribute
3975:   oNodeSetInt( t, qIdent, id )
3987:   >> t
3991:   ;
      
      
      % Return an nType representing a pointer to the given type.
      % (Creates a new type if necessary.)
      %
3991: PointerTypeTo( Node theType ) >> Node:
3993:    Node ptrType
3993:    ptrType = oNodeGet( theType, qPointerType )
4006:    [ oNodeNull( ptrType )
4013:       | true :
4014:          ptrType = oNodeNew( nPointerType )
4024:          oNodeSet( ptrType, qBaseType, theType )
4036:          oNodeSetInt( ptrType, qSize, 8 )
4048:          oTypeAdd( ptrType )
4054:          oNodeSet( theType, qPointerType, ptrType )
4066:       | * :
4071:    ]
4071:    >> ptrType;
      
      
      % Return the low value of an ordinal type
      %
4075: OrdinalLow( Node theType ) >> int:
4077:    [ oNodeType( theType )
4084:       | nIntegerType :  >> -2147483648
4088:       | nBooleanType :  >> 0
4093:       | nCharType :     >> 0
4098:       | nSubrangeType : >> oNodeGetInt( theType, qLow )
4110:       | * :             #eNotOrdinalType
4123:                         >> 0
4126:    ];
      
      
      
      % Emit the value in a declaration.
      % For a constant integer, this is the constant value.
      % For a global variable, this is the global address.
      % For a local variable, this is the local address relative to the call stack frame.
      %
4127: EmitValue( Node decl ):
4129:     oEmitInt( oNodeGetInt( decl, qValue ));
      
      
4143: installBuiltIns:
      
         % install built-in types
4145:    FileType = @newType( nFileType, 4 )
4159:    IntegerType = @newType( nIntegerType, 4 )
4173:    BooleanType = @newType( nBooleanType, 1 )
4187:    CharType = @newType( nCharType, 1 )
4201:    StringType = @newType( nStringType, 256 )    % string with default length 256
      
         % Declare those type identifiers.
         % SSL doesn't support strings, so need help from operations e.g. oIdAdd_File
      
4215:    Node t
      
4215:    t = @newIdent( nTypeDecl, kType, oIdAdd_File )
4231:    oNodeSet( t, qType, FileType )
4243:    oScopeDeclare( t )
      
4249:    t = @newIdent( nTypeDecl, kType, oIdAdd_Integer )
4265:    oNodeSet( t, qType, IntegerType )
4277:    oScopeDeclare( t )
      
4283:    t = @newIdent( nTypeDecl, kType, oIdAdd_Boolean )
4299:    oNodeSet( t, qType, BooleanType )
4311:    oScopeDeclare( t )
      
4317:    t = @newIdent( nTypeDecl, kType, oIdAdd_Char )
4333:    oNodeSet( t, qType, CharType )
4345:    oScopeDeclare( t )
      
4351:    t = @newIdent( nTypeDecl, kType, oIdAdd_String )
4367:    oNodeSet( t, qType, StringType )
4379:    oScopeDeclare( t )
      
         % Built-in constants
      
4385:    t = @newIdent( nConst, kConst, oIdAdd_True )
4401:    oNodeSet( t, qType, BooleanType )
4413:    oNodeSetInt( t, qValue, 1 )
4425:    oScopeDeclare( t )
      
4431:    t = @newIdent( nConst, kConst, oIdAdd_False )
4447:    oNodeSet( t, qType, BooleanType )
4459:    oNodeSetInt( t, qValue, 0 )
4471:    oScopeDeclare( t )
      
4478:    ;
      
4478: end
      
4478: 

Generated code:

   0: oGlobalSpace 7
   2: oLocalSpace 3
   4: oScopeBegin
   5: oGetAddrGlobal 1
   7: oPushResult
   8: oScopeCurrent
   9: oAssign
  10: oCall 4143
  12: oEmit 45
  14: oGetAddrLocal 2
  16: oPushResult
  17: Here
  18: oAssign
  19: oEmit 53
  21: oInput 26
  23: oInput 0
  25: oGetAddrLocal 1
  27: oPushResult
  28: oSetResult 5
  30: oPushResult
  31: oSetResult 1
  33: oPushResult
  34: LAST_ID
  35: oPushResult
  36: oCall 3951
  38: oPop 3
  40: oAssign
  41: oGetLocal 1
  43: oPushResult
  44: oScopeDeclare
  45: oPop 1
  47: oInputChoice 127
  49: oInput 0
  51: oGetAddrLocal 1
  53: oPushResult
  54: oSetResult 11
  56: oPushResult
  57: oSetResult 6
  59: oPushResult
  60: LAST_ID
  61: oPushResult
  62: oCall 3951
  64: oPop 3
  66: oAssign
  67: oGetLocal 1
  69: oPushResult
  70: oSetResult 6
  72: oPushResult
  73: oGetGlobal 2
  75: oPushResult
  76: oNodeSet
  77: oPop 3
  79: oGetLocal 1
  81: oPushResult
  82: oScopeDeclareAlloc
  83: oPop 1
  85: oInput 12
  87: oInput 0
  89: oGetAddrLocal 1
  91: oPushResult
  92: oSetResult 11
  94: oPushResult
  95: oSetResult 6
  97: oPushResult
  98: LAST_ID
  99: oPushResult
 100: oCall 3951
 102: oPop 3
 104: oAssign
 105: oGetLocal 1
 107: oPushResult
 108: oSetResult 6
 110: oPushResult
 111: oGetGlobal 2
 113: oPushResult
 114: oNodeSet
 115: oPop 3
 117: oGetLocal 1
 119: oPushResult
 120: oScopeDeclareAlloc
 121: oPop 1
 123: oInput 14
 125: oJumpForward 130
 127: Choice Lookup Table
          13     49
 130: oInput 4
 132: oSetResult 12
 134: oPushResult
 135: oGetAddrLocal 3
 137: oPushResult
 138: oCall 155
 140: oPop 2
 142: oGetLocal 2
 144: oPushResult
 145: oGetLocal 3
 147: oPushResult
 148: oPatch
 149: oPop 2
 151: oInput 18
 153: oScopeEnd
 154: oReturn
 155: oLocalSpace 2
 157: oInputChoice 184
 159: oCall 689
 161: oJumpForward 197
 163: oCall 761
 165: oJumpForward 197
 167: oGetParam 2
 169: oPushResult
 170: oCall 820
 172: oPop 1
 174: oJumpForward 197
 176: oCall 271
 178: oJumpForward 197
 180: oCall 377
 182: oJumpForward 197
 184: Choice Lookup Table
          28    180
          27    176
          31    167
          30    163
          29    159
 195: oJumpForward 199
 197: oJumpBack 157
 199: oGetParam 1
 201: oPushResult
 202: Here
 203: oAssign
 204: oGetParam 2
 206: oPushResult
 207: oSetResult 13
 209: oPushResult
 210: equal_node_type
 211: oPop 2
 213: oChoice 226
 215: oEmit 44
 217: oGetAddrLocal 1
 219: oPushResult
 220: Here
 221: oAssign
 222: oEmit 53
 224: oJumpForward 229
 226: Choice Lookup Table
           1    215
 229: oCall 3007
 231: oEmit 43
 233: oGetParam 2
 235: oPushResult
 236: oSetResult 13
 238: oPushResult
 239: equal_node_type
 240: oPop 2
 242: oChoice 267
 244: oGetAddrLocal 2
 246: oPushResult
 247: oScopeCurrent
 248: oPushResult
 249: oSetResult 3
 251: oPushResult
 252: oNodeGetInt
 253: oPop 2
 255: oAssign
 256: oGetLocal 1
 258: oPushResult
 259: oGetLocal 2
 261: oPushResult
 262: oPatch
 263: oPop 2
 265: oJumpForward 270
 267: Choice Lookup Table
           1    244
 270: oReturn
 271: oLocalSpace 3
 273: oInput 0
 275: oGetAddrLocal 1
 277: oPushResult
 278: oSetResult 7
 280: oPushResult
 281: oSetResult 2
 283: oPushResult
 284: LAST_ID
 285: oPushResult
 286: oCall 3951
 288: oPop 3
 290: oAssign
 291: oScopeBegin
 292: oGetAddrLocal 2
 294: oPushResult
 295: oScopeCurrent
 296: oAssign
 297: oCall 504
 299: oGetLocal 1
 301: oPushResult
 302: oSetResult 9
 304: oPushResult
 305: oGetLocal 2
 307: oPushResult
 308: oNodeSet
 309: oPop 3
 311: oScopeEnd
 312: oGetLocal 1
 314: oPushResult
 315: oScopeDeclare
 316: oPop 1
 318: oInput 4
 320: oGetLocal 2
 322: oPushResult
 323: oScopeEnter
 324: oPop 1
 326: oScopeBegin
 327: oSetResult 13
 329: oPushResult
 330: oGetAddrLocal 3
 332: oPushResult
 333: oCall 155
 335: oPop 2
 337: oGetLocal 1
 339: oPushResult
 340: oSetResult 10
 342: oPushResult
 343: oScopeCurrent
 344: oPushResult
 345: oNodeSet
 346: oPop 3
 348: oGetLocal 1
 350: oPushResult
 351: oSetResult 8
 353: oPushResult
 354: oGetLocal 3
 356: oPushResult
 357: oNodeSetInt
 358: oPop 3
 360: oGetLocal 1
 362: oPushResult
 363: oSetResult 11
 365: oPushResult
 366: oSetResult 1
 368: oPushResult
 369: oNodeSetBoolean
 370: oPop 3
 372: oScopeEnd
 373: oScopeEnd
 374: oInput 4
 376: oReturn
 377: oLocalSpace 4
 379: oInput 0
 381: oGetAddrLocal 1
 383: oPushResult
 384: oSetResult 8
 386: oPushResult
 387: oSetResult 3
 389: oPushResult
 390: LAST_ID
 391: oPushResult
 392: oCall 3951
 394: oPop 3
 396: oAssign
 397: oScopeBegin
 398: oGetAddrLocal 3
 400: oPushResult
 401: oScopeCurrent
 402: oAssign
 403: oCall 504
 405: oGetLocal 1
 407: oPushResult
 408: oSetResult 9
 410: oPushResult
 411: oGetLocal 3
 413: oPushResult
 414: oNodeSet
 415: oPop 3
 417: oScopeEnd
 418: oGetLocal 1
 420: oPushResult
 421: oScopeDeclare
 422: oPop 1
 424: oInput 11
 426: oGetAddrLocal 2
 428: oPushResult
 429: oCall 961
 431: oPop 1
 433: oGetLocal 1
 435: oPushResult
 436: oSetResult 6
 438: oPushResult
 439: oGetLocal 2
 441: oPushResult
 442: oNodeSet
 443: oPop 3
 445: oInput 4
 447: oGetLocal 3
 449: oPushResult
 450: oScopeEnter
 451: oPop 1
 453: oScopeBegin
 454: oSetResult 13
 456: oPushResult
 457: oGetAddrLocal 4
 459: oPushResult
 460: oCall 155
 462: oPop 2
 464: oGetLocal 1
 466: oPushResult
 467: oSetResult 10
 469: oPushResult
 470: oScopeCurrent
 471: oPushResult
 472: oNodeSet
 473: oPop 3
 475: oGetLocal 1
 477: oPushResult
 478: oSetResult 8
 480: oPushResult
 481: oGetLocal 4
 483: oPushResult
 484: oNodeSetInt
 485: oPop 3
 487: oGetLocal 1
 489: oPushResult
 490: oSetResult 11
 492: oPushResult
 493: oSetResult 1
 495: oPushResult
 496: oNodeSetBoolean
 497: oPop 3
 499: oScopeEnd
 500: oScopeEnd
 501: oInput 4
 503: oReturn
 504: oLocalSpace 5
 506: oInputChoice 685
 508: oGetAddrLocal 1
 510: oPushResult
 511: oNodeVecNew
 512: oAssign
 513: oGetAddrLocal 3
 515: oPushResult
 516: oSetResult 0
 518: oAssign
 519: oInputChoice 529
 521: oGetAddrLocal 3
 523: oPushResult
 524: oSetResult 1
 526: oAssign
 527: oJumpForward 532
 529: Choice Lookup Table
          31    521
 532: oInput 0
 534: oGetAddrLocal 2
 536: oPushResult
 537: oSetResult 15
 539: oPushResult
 540: oSetResult 6
 542: oPushResult
 543: LAST_ID
 544: oPushResult
 545: oCall 3951
 547: oPop 3
 549: oAssign
 550: oGetLocal 2
 552: oPushResult
 553: oSetResult 12
 555: oPushResult
 556: oGetLocal 3
 558: oPushResult
 559: oNodeSetBoolean
 560: oPop 3
 562: oGetLocal 1
 564: oPushResult
 565: oGetLocal 2
 567: oPushResult
 568: oNodeVecAppend
 569: oPop 2
 571: oInputChoice 579
 573: oJumpForward 587
 575: oJumpForward 585
 577: oJumpForward 585
 579: Choice Lookup Table
          12    577
          11    573
 584: oEndChoice
 585: oJumpBack 532
 587: oGetAddrLocal 4
 589: oPushResult
 590: oCall 961
 592: oPop 1
 594: oGetAddrLocal 5
 596: oPushResult
 597: oSetResult 0
 599: oAssign
 600: oGetLocal 5
 602: oPushResult
 603: oGetLocal 1
 605: oPushResult
 606: oNodeVecSize
 607: oPop 1
 609: oPushResult
 610: equal
 611: oPop 2
 613: oChoice 654
 615: oGetAddrLocal 2
 617: oPushResult
 618: oGetLocal 1
 620: oPushResult
 621: oGetLocal 5
 623: oPushResult
 624: oNodeVecElement
 625: oPop 2
 627: oAssign
 628: oGetLocal 2
 630: oPushResult
 631: oSetResult 6
 633: oPushResult
 634: oGetLocal 4
 636: oPushResult
 637: oNodeSet
 638: oPop 3
 640: oGetLocal 2
 642: oPushResult
 643: oScopeDeclareAlloc
 644: oPop 1
 646: oGetAddrLocal 5
 648: oPushResult
 649: inc
 650: oPop 1
 652: oJumpForward 659
 654: Choice Lookup Table
           0    615
 657: oJumpForward 661
 659: oJumpBack 600
 661: oGetLocal 1
 663: oPushResult
 664: oNodeVecDelete
 665: oPop 1
 667: oInputChoice 675
 669: oJumpForward 683
 671: oJumpForward 681
 673: oJumpForward 681
 675: Choice Lookup Table
           4    673
          14    669
 680: oEndChoice
 681: oJumpBack 508
 683: oJumpForward 688
 685: Choice Lookup Table
          13    508
 688: oReturn
 689: oLocalSpace 2
 691: oInputChoice 753
 693: oGetAddrLocal 1
 695: oPushResult
 696: oSetResult 9
 698: oPushResult
 699: oSetResult 4
 701: oPushResult
 702: LAST_ID
 703: oPushResult
 704: oCall 3951
 706: oPop 3
 708: oAssign
 709: oInput 5
 711: oCall 1430
 713: oGetAddrLocal 2
 715: oPushResult
 716: oValueTop
 717: oAssign
 718: oValuePop
 719: oGetLocal 1
 721: oPushResult
 722: oSetResult 8
 724: oPushResult
 725: oGetLocal 2
 727: oPushResult
 728: oNodeSetInt
 729: oPop 3
 731: oGetLocal 1
 733: oPushResult
 734: oSetResult 6
 736: oPushResult
 737: oGetGlobal 3
 739: oPushResult
 740: oNodeSet
 741: oPop 3
 743: oGetLocal 1
 745: oPushResult
 746: oScopeDeclare
 747: oPop 1
 749: oInput 4
 751: oJumpForward 758
 753: Choice Lookup Table
           0    693
 756: oJumpForward 760
 758: oJumpBack 691
 760: oReturn
 761: oLocalSpace 2
 763: oInputChoice 812
 765: oGetAddrLocal 1
 767: oPushResult
 768: oSetResult 10
 770: oPushResult
 771: oSetResult 5
 773: oPushResult
 774: LAST_ID
 775: oPushResult
 776: oCall 3951
 778: oPop 3
 780: oAssign
 781: oInput 5
 783: oGetAddrLocal 2
 785: oPushResult
 786: oCall 961
 788: oPop 1
 790: oGetLocal 1
 792: oPushResult
 793: oSetResult 6
 795: oPushResult
 796: oGetLocal 2
 798: oPushResult
 799: oNodeSet
 800: oPop 3
 802: oGetLocal 1
 804: oPushResult
 805: oScopeDeclare
 806: oPop 1
 808: oInput 4
 810: oJumpForward 817
 812: Choice Lookup Table
           0    765
 815: oJumpForward 819
 817: oJumpBack 763
 819: oReturn
 820: oLocalSpace 4
 822: oInputChoice 953
 824: oGetAddrLocal 1
 826: oPushResult
 827: oNodeVecNew
 828: oAssign
 829: oGetAddrLocal 2
 831: oPushResult
 832: oGetParam 1
 834: oPushResult
 835: oSetResult 6
 837: oPushResult
 838: LAST_ID
 839: oPushResult
 840: oCall 3951
 842: oPop 3
 844: oAssign
 845: oGetLocal 1
 847: oPushResult
 848: oGetLocal 2
 850: oPushResult
 851: oNodeVecAppend
 852: oPop 2
 854: oInputChoice 860
 856: oInput 0
 858: oJumpForward 865
 860: Choice Lookup Table
          12    856
 863: oJumpForward 867
 865: oJumpBack 829
 867: oInput 11
 869: oGetAddrLocal 3
 871: oPushResult
 872: oCall 961
 874: oPop 1
 876: oGetAddrLocal 4
 878: oPushResult
 879: oSetResult 0
 881: oAssign
 882: oGetLocal 4
 884: oPushResult
 885: oGetLocal 1
 887: oPushResult
 888: oNodeVecSize
 889: oPop 1
 891: oPushResult
 892: equal
 893: oPop 2
 895: oChoice 936
 897: oGetAddrLocal 2
 899: oPushResult
 900: oGetLocal 1
 902: oPushResult
 903: oGetLocal 4
 905: oPushResult
 906: oNodeVecElement
 907: oPop 2
 909: oAssign
 910: oGetLocal 2
 912: oPushResult
 913: oSetResult 6
 915: oPushResult
 916: oGetLocal 3
 918: oPushResult
 919: oNodeSet
 920: oPop 3
 922: oGetLocal 2
 924: oPushResult
 925: oScopeDeclareAlloc
 926: oPop 1
 928: oGetAddrLocal 4
 930: oPushResult
 931: inc
 932: oPop 1
 934: oJumpForward 941
 936: Choice Lookup Table
           0    897
 939: oJumpForward 943
 941: oJumpBack 882
 943: oGetLocal 1
 945: oPushResult
 946: oNodeVecDelete
 947: oPop 1
 949: oInput 4
 951: oJumpForward 958
 953: Choice Lookup Table
           0    824
 956: oJumpForward 960
 958: oJumpBack 822
 960: oReturn
 961: oLocalSpace 12
 963: oInputChoice 1412
 965: oGetAddrLocal 1
 967: oPushResult
 968: oScopeFindRequire
 969: oAssign
 970: oGetLocal 1
 972: oPushResult
 973: oNodeType
 974: oPop 1
 976: oChoice 993
 978: oGetParam 1
 980: oPushResult
 981: oGetLocal 1
 983: oPushResult
 984: oSetResult 6
 986: oPushResult
 987: oNodeGet
 988: oPop 2
 990: oAssign
 991: oJumpForward 1004
 993: Choice Lookup Table
          10    978
 996: oError 2
 998: oGetParam 1
1000: oPushResult
1001: oGetGlobal 3
1003: oAssign
1004: oJumpForward 1429
1006: oInput 15
1008: oGetAddrLocal 2
1010: oPushResult
1011: oNodeVecNew
1012: oAssign
1013: oGetAddrLocal 3
1015: oPushResult
1016: oSetResult 24
1018: oPushResult
1019: oNodeNew
1020: oPop 1
1022: oAssign
1023: oGetLocal 3
1025: oPushResult
1026: oSetResult 15
1028: oPushResult
1029: oGetGlobal 3
1031: oPushResult
1032: oNodeSet
1033: oPop 3
1035: oCall 1430
1037: oGetLocal 3
1039: oPushResult
1040: oSetResult 17
1042: oPushResult
1043: oValueTop
1044: oPushResult
1045: oNodeSetInt
1046: oPop 3
1048: oValuePop
1049: oInput 19
1051: oCall 1430
1053: oGetLocal 3
1055: oPushResult
1056: oSetResult 18
1058: oPushResult
1059: oValueTop
1060: oPushResult
1061: oNodeSetInt
1062: oPop 3
1064: oValuePop
1065: oGetLocal 3
1067: oPushResult
1068: oSetResult 13
1070: oPushResult
1071: oSetResult 4
1073: oPushResult
1074: oNodeSetInt
1075: oPop 3
1077: oGetLocal 3
1079: oPushResult
1080: oTypeAdd
1081: oPop 1
1083: oGetAddrLocal 4
1085: oPushResult
1086: oSetResult 23
1088: oPushResult
1089: oNodeNew
1090: oPop 1
1092: oAssign
1093: oGetLocal 4
1095: oPushResult
1096: oSetResult 16
1098: oPushResult
1099: oGetLocal 3
1101: oPushResult
1102: oNodeSet
1103: oPop 3
1105: oGetLocal 2
1107: oPushResult
1108: oGetLocal 4
1110: oPushResult
1111: oNodeVecAppend
1112: oPop 2
1114: oInputChoice 1122
1116: oJumpForward 1130
1118: oJumpForward 1128
1120: oJumpForward 1128
1122: Choice Lookup Table
          12   1120
          16   1116
1127: oEndChoice
1128: oJumpBack 1013
1130: oInput 37
1132: oGetAddrLocal 5
1134: oPushResult
1135: oCall 961
1137: oPop 1
1139: oGetAddrLocal 6
1141: oPushResult
1142: oGetLocal 2
1144: oPushResult
1145: oNodeVecSize
1146: oPop 1
1148: oAssign
1149: oGetAddrLocal 6
1151: oPushResult
1152: dec
1153: oPop 1
1155: oGetAddrLocal 4
1157: oPushResult
1158: oGetLocal 2
1160: oPushResult
1161: oGetLocal 6
1163: oPushResult
1164: oNodeVecElement
1165: oPop 2
1167: oAssign
1168: oGetLocal 4
1170: oPushResult
1171: oSetResult 15
1173: oPushResult
1174: oGetLocal 5
1176: oPushResult
1177: oNodeSet
1178: oPop 3
1180: oGetAddrLocal 3
1182: oPushResult
1183: oGetLocal 4
1185: oPushResult
1186: oSetResult 16
1188: oPushResult
1189: oNodeGet
1190: oPop 2
1192: oAssign
1193: oGetAddrLocal 9
1195: oPushResult
1196: oGetLocal 3
1198: oPushResult
1199: oSetResult 18
1201: oPushResult
1202: oNodeGetInt
1203: oPop 2
1205: oPushResult
1206: oGetLocal 3
1208: oPushResult
1209: oSetResult 17
1211: oPushResult
1212: oNodeGetInt
1213: oPop 2
1215: oPushResult
1216: subtract
1217: oPop 2
1219: oAssign
1220: oGetAddrLocal 9
1222: oPushResult
1223: inc
1224: oPop 1
1226: oGetLocal 4
1228: oPushResult
1229: oSetResult 13
1231: oPushResult
1232: oGetLocal 9
1234: oPushResult
1235: oGetLocal 5
1237: oPushResult
1238: oSetResult 13
1240: oPushResult
1241: oNodeGetInt
1242: oPop 2
1244: oPushResult
1245: multiply
1246: oPop 2
1248: oPushResult
1249: oNodeSetInt
1250: oPop 3
1252: oGetLocal 4
1254: oPushResult
1255: oTypeAdd
1256: oPop 1
1258: oGetAddrLocal 5
1260: oPushResult
1261: oGetLocal 4
1263: oAssign
1264: oGetLocal 6
1266: oPushResult
1267: equal_zero
1268: oPop 1
1270: oChoice 1276
1272: oJumpForward 1281
1274: oJumpForward 1279
1276: Choice Lookup Table
           1   1272
1279: oJumpBack 1149
1281: oGetParam 1
1283: oPushResult
1284: oGetLocal 2
1286: oPushResult
1287: oSetResult 0
1289: oPushResult
1290: oNodeVecElement
1291: oPop 2
1293: oAssign
1294: oGetLocal 2
1296: oPushResult
1297: oNodeVecDelete
1298: oPop 1
1300: oJumpForward 1429
1302: oGetAddrLocal 10
1304: oPushResult
1305: oCall 961
1307: oPop 1
1309: oGetParam 1
1311: oPushResult
1312: oGetLocal 10
1314: oPushResult
1315: oCall 3991
1317: oPop 1
1319: oAssign
1320: oJumpForward 1429
1322: oGetParam 1
1324: oPushResult
1325: oSetResult 25
1327: oPushResult
1328: oNodeNew
1329: oPop 1
1331: oAssign
1332: oScopeBegin
1333: oSetResult 14
1335: oPushResult
1336: oCall 820
1338: oPop 1
1340: oGetAddrLocal 11
1342: oPushResult
1343: oScopeCurrent
1344: oPushResult
1345: oSetResult 3
1347: oPushResult
1348: oNodeGetInt
1349: oPop 2
1351: oAssign
1352: oGetLocal 11
1354: oPushResult
1355: equal_zero
1356: oPop 1
1358: oChoice 1364
1360: oError 19
1362: oJumpForward 1367
1364: Choice Lookup Table
           1   1360
1367: oInput 33
1369: oGetFromParam 1
1371: oPushResult
1372: oSetResult 19
1374: oPushResult
1375: oScopeCurrent
1376: oPushResult
1377: oNodeSet
1378: oPop 3
1380: oGetFromParam 1
1382: oPushResult
1383: oSetResult 13
1385: oPushResult
1386: oGetLocal 11
1388: oPushResult
1389: oNodeSetInt
1390: oPop 3
1392: oScopeEnd
1393: oGetFromParam 1
1395: oPushResult
1396: oTypeAdd
1397: oPop 1
1399: oJumpForward 1429
1401: oInput 37
1403: oGetAddrLocal 10
1405: oPushResult
1406: oCall 961
1408: oPop 1
1410: oJumpForward 1429
1412: Choice Lookup Table
          36   1401
          35   1322
          17   1302
          34   1006
           0    965
1423: oCall 1430
1425: oInput 19
1427: oCall 1430
1429: oReturn
1430: oLocalSpace 1
1432: oInputChoice 1487
1434: TOKEN_VALUE
1435: oPushResult
1436: oValuePush
1437: oPop 1
1439: oJumpForward 1495
1441: oGetAddrLocal 1
1443: oPushResult
1444: oScopeFindRequire
1445: oAssign
1446: oGetLocal 1
1448: oPushResult
1449: oNodeType
1450: oPop 1
1452: oChoice 1469
1454: oGetLocal 1
1456: oPushResult
1457: oSetResult 8
1459: oPushResult
1460: oNodeGetInt
1461: oPop 2
1463: oPushResult
1464: oValuePush
1465: oPop 1
1467: oJumpForward 1480
1469: Choice Lookup Table
           9   1454
1472: oError 1
1474: oSetResult 0
1476: oPushResult
1477: oValuePush
1478: oPop 1
1480: oJumpForward 1495
1482: oCall 1430
1484: oValueNegate
1485: oJumpForward 1495
1487: Choice Lookup Table
          23   1482
           0   1441
           1   1434
1494: oEndChoice
1495: oReturn
1496: oLocalSpace 0
1498: oCall 1742
1500: oInputChoice 1724
1502: oCall 1742
1504: oCall 3837
1506: oTypeSNodeType
1507: oChoice 1521
1509: oEmit 32
1511: oJumpForward 1534
1513: oEmit 38
1515: oJumpForward 1534
1517: oError 16
1519: oJumpForward 1534
1521: Choice Lookup Table
          21   1517
          20   1517
          22   1513
          19   1509
          18   1509
1532: oError 17
1534: oTypeSPop
1535: oGetGlobal 4
1537: oPushResult
1538: oTypeSPush
1539: oPop 1
1541: oJumpForward 1739
1543: oCall 1742
1545: oCall 3837
1547: oTypeSNodeType
1548: oChoice 1562
1550: oEmit 33
1552: oJumpForward 1575
1554: oEmit 39
1556: oJumpForward 1575
1558: oError 16
1560: oJumpForward 1575
1562: Choice Lookup Table
          21   1558
          20   1558
          22   1554
          19   1550
          18   1550
1573: oError 17
1575: oTypeSPop
1576: oGetGlobal 4
1578: oPushResult
1579: oTypeSPush
1580: oPop 1
1582: oJumpForward 1739
1584: oCall 1742
1586: oCall 3837
1588: oTypeSNodeType
1589: oChoice 1599
1591: oEmit 35
1593: oJumpForward 1610
1595: oError 16
1597: oJumpForward 1610
1599: Choice Lookup Table
          21   1595
          20   1595
          19   1591
          18   1591
1608: oError 17
1610: oTypeSPop
1611: oGetGlobal 4
1613: oPushResult
1614: oTypeSPush
1615: oPop 1
1617: oJumpForward 1739
1619: oCall 1742
1621: oCall 3837
1623: oTypeSNodeType
1624: oChoice 1634
1626: oEmit 34
1628: oJumpForward 1645
1630: oError 16
1632: oJumpForward 1645
1634: Choice Lookup Table
          21   1630
          20   1630
          19   1626
          18   1626
1643: oError 17
1645: oTypeSPop
1646: oGetGlobal 4
1648: oPushResult
1649: oTypeSPush
1650: oPop 1
1652: oJumpForward 1739
1654: oCall 1742
1656: oCall 3837
1658: oTypeSNodeType
1659: oChoice 1669
1661: oEmit 37
1663: oJumpForward 1680
1665: oError 16
1667: oJumpForward 1680
1669: Choice Lookup Table
          21   1665
          20   1665
          19   1661
          18   1661
1678: oError 17
1680: oTypeSPop
1681: oGetGlobal 4
1683: oPushResult
1684: oTypeSPush
1685: oPop 1
1687: oJumpForward 1739
1689: oCall 1742
1691: oCall 3837
1693: oTypeSNodeType
1694: oChoice 1704
1696: oEmit 36
1698: oJumpForward 1715
1700: oError 16
1702: oJumpForward 1715
1704: Choice Lookup Table
          21   1700
          20   1700
          19   1696
          18   1696
1713: oError 17
1715: oTypeSPop
1716: oGetGlobal 4
1718: oPushResult
1719: oTypeSPush
1720: oPop 1
1722: oJumpForward 1739
1724: Choice Lookup Table
          10   1689
           9   1654
           8   1619
           7   1584
           6   1543
           5   1502
1737: oJumpForward 1741
1739: oJumpBack 1500
1741: oReturn
1742: oLocalSpace 0
1744: oCall 1766
1746: oInputChoice 1758
1748: oCall 3890
1750: oCall 1766
1752: oCall 3904
1754: oEmit 31
1756: oJumpForward 1763
1758: Choice Lookup Table
          52   1748
1761: oJumpForward 1765
1763: oJumpBack 1746
1765: oReturn
1766: oLocalSpace 0
1768: oCall 1790
1770: oInputChoice 1782
1772: oCall 3890
1774: oCall 1790
1776: oCall 3904
1778: oEmit 30
1780: oJumpForward 1787
1782: Choice Lookup Table
          51   1772
1785: oJumpForward 1789
1787: oJumpBack 1770
1789: oReturn
1790: oLocalSpace 0
1792: oInputChoice 1802
1794: oCall 1808
1796: oCall 3904
1798: oEmit 29
1800: oJumpForward 1807
1802: Choice Lookup Table
          53   1794
1805: oCall 1808
1807: oReturn
1808: oLocalSpace 0
1810: oCall 1844
1812: oInputChoice 1834
1814: oCall 3863
1816: oCall 1844
1818: oCall 3877
1820: oEmit 26
1822: oJumpForward 1841
1824: oCall 3863
1826: oCall 1844
1828: oCall 3877
1830: oEmit 27
1832: oJumpForward 1841
1834: Choice Lookup Table
          23   1824
          22   1814
1839: oJumpForward 1843
1841: oJumpBack 1812
1843: oReturn
1844: oLocalSpace 0
1846: oCall 1880
1848: oInputChoice 1870
1850: oCall 3863
1852: oCall 1880
1854: oCall 3877
1856: oEmit 24
1858: oJumpForward 1877
1860: oCall 3863
1862: oCall 1880
1864: oCall 3877
1866: oEmit 25
1868: oJumpForward 1877
1870: Choice Lookup Table
          21   1860
          20   1850
1875: oJumpForward 1879
1877: oJumpBack 1848
1879: oReturn
1880: oLocalSpace 0
1882: oInputChoice 1898
1884: oCall 1906
1886: oCall 3877
1888: oJumpForward 1905
1890: oCall 1906
1892: oCall 3877
1894: oEmit 28
1896: oJumpForward 1905
1898: Choice Lookup Table
          23   1890
          22   1884
1903: oCall 1906
1905: oReturn
1906: oLocalSpace 5
1908: oInputChoice 2081
1910: oEmit 9
1912: TOKEN_VALUE
1913: oPushResult
1914: oEmitInt
1915: oPop 1
1917: oGetGlobal 3
1919: oPushResult
1920: oTypeSPush
1921: oPop 1
1923: oJumpForward 2100
1925: oCall 1496
1927: oInput 14
1929: oJumpForward 2100
1931: oStringAllocLit
1932: oEmit 10
1934: oValueTop
1935: oPushResult
1936: oEmitInt
1937: oPop 1
1939: oValuePop
1940: oGetGlobal 6
1942: oPushResult
1943: oTypeSPush
1944: oPop 1
1946: oJumpForward 2100
1948: oGetAddrLocal 1
1950: oPushResult
1951: oScopeFindRequire
1952: oAssign
1953: oGetLocal 1
1955: oPushResult
1956: oNodeType
1957: oPop 1
1959: oChoice 2021
1961: oGetLocal 1
1963: oPushResult
1964: oCall 2717
1966: oPop 1
1968: oJumpForward 2040
1970: oGetAddrLocal 2
1972: oPushResult
1973: oGetLocal 1
1975: oPushResult
1976: oSetResult 6
1978: oPushResult
1979: oNodeGet
1980: oPop 2
1982: oAssign
1983: oGetLocal 2
1985: oPushResult
1986: oTypeSPush
1987: oPop 1
1989: oTypeSNodeType
1990: oChoice 2003
1992: oEmit 9
1994: oGetLocal 1
1996: oPushResult
1997: oCall 4127
1999: oPop 1
2001: oJumpForward 2010
2003: Choice Lookup Table
          19   1992
          18   1992
2008: oError 16
2010: oJumpForward 2040
2012: oGetLocal 1
2014: oPushResult
2015: oCall 2101
2017: oPop 1
2019: oJumpForward 2040
2021: Choice Lookup Table
          15   2012
          13   2012
          12   2012
           9   1970
           8   1961
2032: oError 6
2034: oGetGlobal 3
2036: oPushResult
2037: oTypeSPush
2038: oPop 1
2040: oJumpForward 2100
2042: oInput 0
2044: oGetAddrLocal 1
2046: oPushResult
2047: oScopeFindRequire
2048: oAssign
2049: oGetLocal 1
2051: oPushResult
2052: oCall 3199
2054: oPop 1
2056: oGetAddrLocal 2
2058: oPushResult
2059: oTypeSTop
2060: oAssign
2061: oTypeSPop
2062: oGetAddrLocal 5
2064: oPushResult
2065: oGetLocal 2
2067: oPushResult
2068: oCall 3991
2070: oPop 1
2072: oAssign
2073: oGetLocal 5
2075: oPushResult
2076: oTypeSPush
2077: oPop 1
2079: oJumpForward 2100
2081: Choice Lookup Table
          17   2042
           0   1948
           2   1931
          13   1925
           1   1910
2092: oError 6
2094: oGetGlobal 3
2096: oPushResult
2097: oTypeSPush
2098: oPop 1
2100: oReturn
2101: oLocalSpace 1
2103: oGetAddrLocal 1
2105: oPushResult
2106: oGetParam 1
2108: oPushResult
2109: oSetResult 6
2111: oPushResult
2112: oNodeGet
2113: oPop 2
2115: oAssign
2116: oGetLocal 1
2118: oPushResult
2119: oTypeSPush
2120: oPop 1
2122: oTypeSNodeType
2123: oChoice 2307
2125: oGetParam 1
2127: oPushResult
2128: oNodeType
2129: oPop 1
2131: oChoice 2166
2133: oEmit 0
2135: oGetParam 1
2137: oPushResult
2138: oCall 4127
2140: oPop 1
2142: oJumpForward 2174
2144: oEmit 3
2146: oGetParam 1
2148: oPushResult
2149: oCall 4127
2151: oPop 1
2153: oJumpForward 2174
2155: oEmit 6
2157: oGetParam 1
2159: oPushResult
2160: oCall 4127
2162: oPop 1
2164: oJumpForward 2174
2166: Choice Lookup Table
          15   2155
          13   2144
          12   2133
2173: oEndChoice
2174: oJumpForward 2373
2176: oGetParam 1
2178: oPushResult
2179: oNodeType
2180: oPop 1
2182: oChoice 2217
2184: oEmit 1
2186: oGetParam 1
2188: oPushResult
2189: oCall 4127
2191: oPop 1
2193: oJumpForward 2225
2195: oEmit 4
2197: oGetParam 1
2199: oPushResult
2200: oCall 4127
2202: oPop 1
2204: oJumpForward 2225
2206: oEmit 7
2208: oGetParam 1
2210: oPushResult
2211: oCall 4127
2213: oPop 1
2215: oJumpForward 2225
2217: Choice Lookup Table
          15   2206
          13   2195
          12   2184
2224: oEndChoice
2225: oJumpForward 2373
2227: oError 16
2229: oJumpForward 2373
2231: oGetParam 1
2233: oPushResult
2234: oNodeType
2235: oPop 1
2237: oChoice 2272
2239: oEmit 2
2241: oGetParam 1
2243: oPushResult
2244: oCall 4127
2246: oPop 1
2248: oJumpForward 2280
2250: oEmit 5
2252: oGetParam 1
2254: oPushResult
2255: oCall 4127
2257: oPop 1
2259: oJumpForward 2280
2261: oEmit 8
2263: oGetParam 1
2265: oPushResult
2266: oCall 4127
2268: oPop 1
2270: oJumpForward 2280
2272: Choice Lookup Table
          15   2261
          13   2250
          12   2239
2279: oEndChoice
2280: oInputChoice 2302
2282: oTypeSPop
2283: oGetLocal 1
2285: oPushResult
2286: oSetResult 15
2288: oPushResult
2289: oNodeGet
2290: oPop 2
2292: oPushResult
2293: oTypeSPush
2294: oPop 1
2296: oCall 2409
2298: oCall 2374
2300: oJumpForward 2305
2302: Choice Lookup Table
          17   2282
2305: oJumpForward 2373
2307: Choice Lookup Table
          22   2231
          17   2227
          21   2227
          20   2227
          19   2176
          18   2125
2320: oGetParam 1
2322: oPushResult
2323: oNodeType
2324: oPop 1
2326: oChoice 2361
2328: oEmit 11
2330: oGetParam 1
2332: oPushResult
2333: oCall 4127
2335: oPop 1
2337: oJumpForward 2369
2339: oEmit 12
2341: oGetParam 1
2343: oPushResult
2344: oCall 4127
2346: oPop 1
2348: oJumpForward 2369
2350: oEmit 13
2352: oGetParam 1
2354: oPushResult
2355: oCall 4127
2357: oPop 1
2359: oJumpForward 2369
2361: Choice Lookup Table
          15   2350
          13   2339
          12   2328
2368: oEndChoice
2369: oCall 2409
2371: oCall 2374
2373: oReturn
2374: oLocalSpace 0
2376: oTypeSNodeType
2377: oChoice 2395
2379: oEmit 15
2381: oJumpForward 2408
2383: oEmit 16
2385: oJumpForward 2408
2387: oError 16
2389: oJumpForward 2408
2391: oEmit 17
2393: oJumpForward 2408
2395: Choice Lookup Table
          22   2391
          17   2387
          21   2387
          20   2387
          19   2383
          18   2379
2408: oReturn
2409: oLocalSpace 0
2411: oInputChoice 2425
2413: oCall 2437
2415: oJumpForward 2434
2417: oCall 2580
2419: oJumpForward 2434
2421: oCall 2678
2423: oJumpForward 2434
2425: Choice Lookup Table
          17   2421
          18   2417
          15   2413
2432: oJumpForward 2436
2434: oJumpBack 2411
2436: oReturn
2437: oLocalSpace 3
2439: oTypeSNodeType
2440: oChoice 2444
2442: oJumpForward 2449
2444: Choice Lookup Table
          23   2442
2447: oError 10
2449: oTypeSNodeType
2450: oChoice 2454
2452: oJumpForward 2459
2454: Choice Lookup Table
          23   2452
2457: oError 13
2459: oGetAddrLocal 1
2461: oPushResult
2462: oTypeSTop
2463: oPushResult
2464: oSetResult 16
2466: oPushResult
2467: oNodeGet
2468: oPop 2
2470: oPushResult
2471: oCall 4075
2473: oPop 1
2475: oAssign
2476: oGetAddrLocal 2
2478: oPushResult
2479: oTypeSTop
2480: oPushResult
2481: oSetResult 15
2483: oPushResult
2484: oNodeGet
2485: oPop 2
2487: oAssign
2488: oTypeSPop
2489: oGetLocal 2
2491: oPushResult
2492: oTypeSPush
2493: oPop 1
2495: oCall 1496
2497: oCall 3863
2499: oGetLocal 1
2501: oPushResult
2502: equal_zero
2503: oPop 1
2505: oChoice 2519
2507: oEmit 9
2509: oGetLocal 1
2511: oPushResult
2512: oEmitInt
2513: oPop 1
2515: oEmit 27
2517: oJumpForward 2522
2519: Choice Lookup Table
           0   2507
2522: oGetAddrLocal 3
2524: oPushResult
2525: oGetLocal 2
2527: oPushResult
2528: oSetResult 13
2530: oPushResult
2531: oNodeGetInt
2532: oPop 2
2534: oAssign
2535: oGetLocal 3
2537: oPushResult
2538: oSetResult 1
2540: oPushResult
2541: equal
2542: oPop 2
2544: oChoice 2558
2546: oEmit 9
2548: oGetLocal 3
2550: oPushResult
2551: oEmitInt
2552: oPop 1
2554: oEmit 24
2556: oJumpForward 2561
2558: Choice Lookup Table
           0   2546
2561: oEmit 26
2563: oInputChoice 2571
2565: oJumpForward 2579
2567: oJumpForward 2577
2569: oJumpForward 2577
2571: Choice Lookup Table
          12   2569
          16   2565
2576: oEndChoice
2577: oJumpBack 2449
2579: oReturn
2580: oLocalSpace 2
2582: oTypeSNodeType
2583: oChoice 2587
2585: oJumpForward 2592
2587: Choice Lookup Table
          25   2585
2590: oError 11
2592: oTypeSTop
2593: oPushResult
2594: oSetResult 19
2596: oPushResult
2597: oNodeGet
2598: oPop 2
2600: oPushResult
2601: oScopeEnter
2602: oPop 1
2604: oInput 0
2606: oGetAddrLocal 1
2608: oPushResult
2609: oScopeFindRequire
2610: oAssign
2611: oGetLocal 1
2613: oPushResult
2614: oNodeType
2615: oPop 1
2617: oChoice 2621
2619: oJumpForward 2626
2621: Choice Lookup Table
          14   2619
2624: oError 12
2626: oScopeEnd
2627: oGetAddrLocal 2
2629: oPushResult
2630: oGetLocal 1
2632: oPushResult
2633: oSetResult 8
2635: oPushResult
2636: oNodeGetInt
2637: oPop 2
2639: oAssign
2640: oGetLocal 2
2642: oPushResult
2643: equal_zero
2644: oPop 1
2646: oChoice 2660
2648: oEmit 9
2650: oGetLocal 2
2652: oPushResult
2653: oEmitInt
2654: oPop 1
2656: oEmit 26
2658: oJumpForward 2663
2660: Choice Lookup Table
           0   2648
2663: oTypeSPop
2664: oGetLocal 1
2666: oPushResult
2667: oSetResult 6
2669: oPushResult
2670: oNodeGet
2671: oPop 2
2673: oPushResult
2674: oTypeSPush
2675: oPop 1
2677: oReturn
2678: oLocalSpace 1
2680: oTypeSNodeType
2681: oChoice 2685
2683: oJumpForward 2690
2685: Choice Lookup Table
          22   2683
2688: oError 9
2690: oEmit 17
2692: oGetAddrLocal 1
2694: oPushResult
2695: oTypeSTop
2696: oAssign
2697: oTypeSPop
2698: oGetLocal 1
2700: oPushResult
2701: oSetResult 15
2703: oPushResult
2704: oNodeGet
2705: oPop 2
2707: oPushResult
2708: oTypeSPush
2709: oPop 1
2711: oReturn
2712: oLocalSpace 0
2714: oCall 3837
2716: oReturn
2717: oLocalSpace 6
2719: oGetAddrLocal 1
2721: oPushResult
2722: oGetParam 1
2724: oPushResult
2725: oSetResult 9
2727: oPushResult
2728: oNodeGet
2729: oPop 2
2731: oAssign
2732: oGetAddrLocal 2
2734: oPushResult
2735: oGetLocal 1
2737: oPushResult
2738: oSetResult 3
2740: oPushResult
2741: oNodeGetInt
2742: oPop 2
2744: oAssign
2745: oEmit 40
2747: oGetLocal 2
2749: oPushResult
2750: oEmitInt
2751: oPop 1
2753: oGetAddrLocal 3
2755: oPushResult
2756: oGetLocal 1
2758: oPushResult
2759: oSetResult 2
2761: oPushResult
2762: oNodeGet
2763: oPop 2
2765: oAssign
2766: oInputChoice 2945
2768: oGetLocal 3
2770: oPushResult
2771: oNodeNull
2772: oPop 1
2774: oChoice 2780
2776: oJumpForward 2941
2778: oJumpForward 2783
2780: Choice Lookup Table
           1   2776
2783: oGetAddrLocal 4
2785: oPushResult
2786: oGetLocal 3
2788: oPushResult
2789: oSetResult 6
2791: oPushResult
2792: oNodeGet
2793: oPop 2
2795: oAssign
2796: oGetAddrLocal 5
2798: oPushResult
2799: oGetLocal 3
2801: oPushResult
2802: oSetResult 8
2804: oPushResult
2805: oNodeGetInt
2806: oPop 2
2808: oAssign
2809: oEmit 14
2811: oGetLocal 5
2813: oPushResult
2814: oEmitInt
2815: oPop 1
2817: oGetLocal 3
2819: oPushResult
2820: oSetResult 6
2822: oPushResult
2823: oNodeGet
2824: oPop 2
2826: oPushResult
2827: oTypeSPush
2828: oPop 1
2830: oGetLocal 3
2832: oPushResult
2833: oSetResult 12
2835: oPushResult
2836: oNodeGetBoolean
2837: oPop 2
2839: oChoice 2905
2841: oError 16
2843: oEmit 20
2845: oJumpForward 2911
2847: oCall 1496
2849: oCall 2712
2851: oTypeSNodeType
2852: oChoice 2870
2854: oEmit 18
2856: oJumpForward 2903
2858: oEmit 19
2860: oJumpForward 2903
2862: oError 16
2864: oJumpForward 2903
2866: oEmit 20
2868: oJumpForward 2903
2870: Choice Lookup Table
          22   2866
          17   2862
          21   2862
          20   2862
          19   2858
          18   2854
2883: oGetAddrLocal 6
2885: oPushResult
2886: oTypeSTop
2887: oPushResult
2888: oSetResult 13
2890: oPushResult
2891: oNodeGetInt
2892: oPop 2
2894: oAssign
2895: oEmit 21
2897: oGetLocal 6
2899: oPushResult
2900: oEmitInt
2901: oPop 1
2903: oJumpForward 2911
2905: Choice Lookup Table
           0   2847
           1   2841
2910: oEndChoice
2911: oGetAddrLocal 3
2913: oPushResult
2914: oNodeNext
2915: oPop 1
2917: oGetLocal 3
2919: oPushResult
2920: oNodeNull
2921: oPop 1
2923: oChoice 2931
2925: oJumpForward 2941
2927: oJumpForward 2937
2929: oJumpForward 2937
2931: Choice Lookup Table
           0   2929
           1   2925
2936: oEndChoice
2937: oInput 12
2939: oJumpBack 2768
2941: oInput 14
2943: oJumpForward 2963
2945: Choice Lookup Table
          13   2768
2948: oGetLocal 3
2950: oPushResult
2951: oNodeNull
2952: oPop 1
2954: oChoice 2960
2956: oError 15
2958: oJumpForward 2963
2960: Choice Lookup Table
           0   2956
2963: oEmit 42
2965: oGetParam 1
2967: oPushResult
2968: oCall 4127
2970: oPop 1
2972: oGetParam 1
2974: oPushResult
2975: oNodeType
2976: oPop 1
2978: oChoice 2995
2980: oGetParam 1
2982: oPushResult
2983: oSetResult 6
2985: oPushResult
2986: oNodeGet
2987: oPop 2
2989: oPushResult
2990: oTypeSPush
2991: oPop 1
2993: oJumpForward 2998
2995: Choice Lookup Table
           8   2980
2998: oEmit 41
3000: oGetLocal 2
3002: oPushResult
3003: oEmitInt
3004: oPop 1
3006: oReturn
3007: oLocalSpace 0
3009: oInputChoice 3059
3011: oCall 3734
3013: oJumpForward 3084
3015: oCall 3741
3017: oJumpForward 3084
3019: oCall 3808
3021: oJumpForward 3084
3023: oCall 3811
3025: oJumpForward 3084
3027: oCall 3267
3029: oJumpForward 3084
3031: oCall 3595
3033: oJumpForward 3084
3035: oCall 3325
3037: oJumpForward 3084
3039: oCall 3546
3041: oJumpForward 3084
3043: oCall 3682
3045: oJumpForward 3084
3047: oCall 3650
3049: oJumpForward 3084
3051: oCall 3711
3053: oJumpForward 3084
3055: oCall 3085
3057: oJumpForward 3084
3059: Choice Lookup Table
           0   3055
          32   3051
          48   3047
          49   3043
          46   3039
          41   3035
          45   3031
          38   3027
          57   3023
          56   3019
          55   3015
          54   3011
3084: oReturn
3085: oLocalSpace 1
3087: oGetAddrLocal 1
3089: oPushResult
3090: oScopeFindRequire
3091: oAssign
3092: oGetLocal 1
3094: oPushResult
3095: oNodeType
3096: oPop 1
3098: oChoice 3118
3100: oGetLocal 1
3102: oPushResult
3103: oCall 2717
3105: oPop 1
3107: oJumpForward 3129
3109: oGetLocal 1
3111: oPushResult
3112: oCall 3130
3114: oPop 1
3116: oJumpForward 3129
3118: Choice Lookup Table
          15   3109
          13   3109
          12   3109
           7   3100
3127: oError 0
3129: oReturn
3130: oLocalSpace 1
3132: oGetParam 1
3134: oPushResult
3135: oCall 3199
3137: oPop 1
3139: oInput 3
3141: oCall 1496
3143: oCall 3837
3145: oTypeSNodeType
3146: oChoice 3164
3148: oEmit 18
3150: oJumpForward 3197
3152: oEmit 19
3154: oJumpForward 3197
3156: oError 16
3158: oJumpForward 3197
3160: oEmit 20
3162: oJumpForward 3197
3164: Choice Lookup Table
          22   3160
          17   3156
          21   3156
          20   3156
          19   3152
          18   3148
3177: oGetAddrLocal 1
3179: oPushResult
3180: oTypeSTop
3181: oPushResult
3182: oSetResult 13
3184: oPushResult
3185: oNodeGetInt
3186: oPop 2
3188: oAssign
3189: oEmit 21
3191: oGetLocal 1
3193: oPushResult
3194: oEmitInt
3195: oPop 1
3197: oTypeSPop
3198: oReturn
3199: oLocalSpace 0
3201: oGetParam 1
3203: oPushResult
3204: oNodeType
3205: oPop 1
3207: oChoice 3242
3209: oEmit 11
3211: oGetParam 1
3213: oPushResult
3214: oCall 4127
3216: oPop 1
3218: oJumpForward 3251
3220: oEmit 12
3222: oGetParam 1
3224: oPushResult
3225: oCall 4127
3227: oPop 1
3229: oJumpForward 3251
3231: oEmit 13
3233: oGetParam 1
3235: oPushResult
3236: oCall 4127
3238: oPop 1
3240: oJumpForward 3251
3242: Choice Lookup Table
          15   3231
          13   3220
          12   3209
3249: oError 4
3251: oGetParam 1
3253: oPushResult
3254: oSetResult 6
3256: oPushResult
3257: oNodeGet
3258: oPop 2
3260: oPushResult
3261: oTypeSPush
3262: oPop 1
3264: oCall 2409
3266: oReturn
3267: oLocalSpace 0
3269: oCall 1496
3271: oCall 3890
3273: oInput 39
3275: oEmit 47
3277: oSetResult 2
3279: oPushResult
3280: oPatchPushHere
3281: oPop 1
3283: oEmit 53
3285: oCall 3007
3287: oInputChoice 3315
3289: oEmit 45
3291: oSetResult 2
3293: oPushResult
3294: oPatchPushHere
3295: oPop 1
3297: oEmit 53
3299: oSetResult 2
3301: oPushResult
3302: oPatchSwap
3303: oPop 1
3305: oSetResult 2
3307: oPushResult
3308: oPatchPopFwd
3309: oPop 1
3311: oCall 3007
3313: oJumpForward 3318
3315: Choice Lookup Table
          40   3289
3318: oSetResult 2
3320: oPushResult
3321: oPatchPopFwd
3322: oPop 1
3324: oReturn
3325: oLocalSpace 1
3327: oInput 0
3329: oGetAddrLocal 1
3331: oPushResult
3332: oScopeFindRequire
3333: oAssign
3334: oGetLocal 1
3336: oPushResult
3337: oNodeType
3338: oPop 1
3340: oChoice 3352
3342: oJumpForward 3361
3344: oError 16
3346: oJumpForward 3361
3348: oError 16
3350: oJumpForward 3361
3352: Choice Lookup Table
          15   3348
          13   3344
          12   3342
3359: oError 5
3361: oGetLocal 1
3363: oPushResult
3364: oSetResult 6
3366: oPushResult
3367: oNodeGet
3368: oPop 2
3370: oPushResult
3371: oTypeSPush
3372: oPop 1
3374: oCall 3863
3376: oEmit 10
3378: oGetLocal 1
3380: oPushResult
3381: oCall 4127
3383: oPop 1
3385: oInput 3
3387: oCall 1496
3389: oCall 3863
3391: oEmit 18
3393: oEmit 45
3395: oSetResult 0
3397: oPushResult
3398: oPatchPushHere
3399: oPop 1
3401: oEmit 53
3403: oSetResult 0
3405: oPushResult
3406: oPatchPushHere
3407: oPop 1
3409: oSetResult 0
3411: oPushResult
3412: oPatchSwap
3413: oPop 1
3415: oInputChoice 3513
3417: oEmit 22
3419: oGetLocal 1
3421: oPushResult
3422: oCall 4127
3424: oPop 1
3426: oSetResult 0
3428: oPushResult
3429: oPatchPopFwd
3430: oPop 1
3432: oEmit 0
3434: oGetLocal 1
3436: oPushResult
3437: oCall 4127
3439: oPop 1
3441: oCall 1496
3443: oCall 3863
3445: oEmit 34
3447: oEmit 46
3449: oSetResult 0
3451: oPushResult
3452: oPatchPushHere
3453: oPop 1
3455: oEmit 53
3457: oSetResult 0
3459: oPushResult
3460: oPatchSwap
3461: oPop 1
3463: oJumpForward 3519
3465: oEmit 23
3467: oGetLocal 1
3469: oPushResult
3470: oCall 4127
3472: oPop 1
3474: oSetResult 0
3476: oPushResult
3477: oPatchPopFwd
3478: oPop 1
3480: oEmit 0
3482: oGetLocal 1
3484: oPushResult
3485: oCall 4127
3487: oPop 1
3489: oCall 1496
3491: oCall 3863
3493: oEmit 35
3495: oEmit 46
3497: oSetResult 0
3499: oPushResult
3500: oPatchPushHere
3501: oPop 1
3503: oEmit 53
3505: oSetResult 0
3507: oPushResult
3508: oPatchSwap
3509: oPop 1
3511: oJumpForward 3519
3513: Choice Lookup Table
          43   3465
          42   3417
3518: oEndChoice
3519: oSetResult 0
3521: oPushResult
3522: oCountPush
3523: oPop 1
3525: oInput 44
3527: oCall 3007
3529: oEmit 45
3531: oSetResult 0
3533: oPushResult
3534: oPatchPopBack
3535: oPop 1
3537: oSetResult 0
3539: oPushResult
3540: oPatchPopFwd
3541: oPop 1
3543: oCall 3814
3545: oReturn
3546: oLocalSpace 0
3548: oSetResult 0
3550: oPushResult
3551: oPatchPushHere
3552: oPop 1
3554: oSetResult 0
3556: oPushResult
3557: oCountPush
3558: oPop 1
3560: oCall 3007
3562: oInputChoice 3586
3564: oCall 3007
3566: oJumpForward 3592
3568: oCall 1496
3570: oCall 3890
3572: oEmit 47
3574: oSetResult 0
3576: oPushResult
3577: oPatchPopBack
3578: oPop 1
3580: oCall 3814
3582: oJumpForward 3594
3584: oJumpForward 3592
3586: Choice Lookup Table
          47   3568
           4   3564
3591: oEndChoice
3592: oJumpBack 3562
3594: oReturn
3595: oLocalSpace 0
3597: oSetResult 0
3599: oPushResult
3600: oPatchPushHere
3601: oPop 1
3603: oSetResult 0
3605: oPushResult
3606: oCountPush
3607: oPop 1
3609: oCall 1496
3611: oCall 3890
3613: oInput 44
3615: oEmit 47
3617: oSetResult 0
3619: oPushResult
3620: oPatchPushHere
3621: oPop 1
3623: oEmit 53
3625: oSetResult 0
3627: oPushResult
3628: oPatchSwap
3629: oPop 1
3631: oCall 3007
3633: oEmit 45
3635: oSetResult 0
3637: oPushResult
3638: oPatchPopBack
3639: oPop 1
3641: oSetResult 0
3643: oPushResult
3644: oPatchPopFwd
3645: oPop 1
3647: oCall 3814
3649: oReturn
3650: oLocalSpace 0
3652: oSetResult 0
3654: oPushResult
3655: oPatchAnyEntries
3656: oPop 1
3658: oChoice 3676
3660: oEmit 45
3662: oSetResult 0
3664: oPushResult
3665: oPatchDup
3666: oPop 1
3668: oSetResult 0
3670: oPushResult
3671: oPatchPopBack
3672: oPop 1
3674: oJumpForward 3681
3676: Choice Lookup Table
           1   3660
3679: oError 18
3681: oReturn
3682: oLocalSpace 0
3684: oSetResult 0
3686: oPushResult
3687: oPatchAnyEntries
3688: oPop 1
3690: oChoice 3705
3692: oEmit 45
3694: oSetResult 1
3696: oPushResult
3697: oPatchPushHere
3698: oPop 1
3700: oEmit 53
3702: oCountInc
3703: oJumpForward 3710
3705: Choice Lookup Table
           1   3692
3708: oError 18
3710: oReturn
3711: oLocalSpace 0
3713: oCall 3007
3715: oInputChoice 3725
3717: oCall 3007
3719: oJumpForward 3731
3721: oJumpForward 3733
3723: oJumpForward 3731
3725: Choice Lookup Table
          33   3721
           4   3717
3730: oEndChoice
3731: oJumpBack 3715
3733: oReturn
3734: oLocalSpace 0
3736: oCall 3741
3738: oEmit 52
3740: oReturn
3741: oLocalSpace 0
3743: oInputChoice 3804
3745: oCall 1496
3747: oTypeSNodeType
3748: oChoice 3770
3750: oEmit 48
3752: oJumpForward 3785
3754: oEmit 49
3756: oJumpForward 3785
3758: oEmit 50
3760: oJumpForward 3785
3762: oError 16
3764: oJumpForward 3785
3766: oEmit 51
3768: oJumpForward 3785
3770: Choice Lookup Table
          22   3766
          17   3762
          20   3762
          21   3758
          19   3754
          18   3750
3783: oError 17
3785: oTypeSPop
3786: oInputChoice 3794
3788: oJumpForward 3802
3790: oJumpForward 3800
3792: oJumpForward 3800
3794: Choice Lookup Table
          12   3792
          14   3788
3799: oEndChoice
3800: oJumpBack 3745
3802: oJumpForward 3807
3804: Choice Lookup Table
          13   3745
3807: oReturn
3808: oLocalSpace 0
3810: oReturn
3811: oLocalSpace 0
3813: oReturn
3814: oLocalSpace 0
3816: oCountIsZero
3817: oChoice 3828
3819: oSetResult 1
3821: oPushResult
3822: oPatchPopFwd
3823: oPop 1
3825: oCountDec
3826: oJumpForward 3833
3828: Choice Lookup Table
           0   3819
3831: oJumpForward 3835
3833: oJumpBack 3816
3835: oCountPop
3836: oReturn
3837: oLocalSpace 1
3839: oGetAddrLocal 1
3841: oPushResult
3842: oTypeSNodeType
3843: oAssign
3844: oTypeSPop
3845: oGetLocal 1
3847: oPushResult
3848: oTypeSNodeType
3849: oPushResult
3850: equal_node_type
3851: oPop 2
3853: oChoice 3859
3855: oError 14
3857: oJumpForward 3862
3859: Choice Lookup Table
           0   3855
3862: oReturn
3863: oLocalSpace 0
3865: oTypeSNodeType
3866: oChoice 3870
3868: oJumpForward 3875
3870: Choice Lookup Table
          18   3868
3873: oError 7
3875: oTypeSPop
3876: oReturn
3877: oLocalSpace 0
3879: oTypeSNodeType
3880: oChoice 3884
3882: oJumpForward 3889
3884: Choice Lookup Table
          18   3882
3887: oError 7
3889: oReturn
3890: oLocalSpace 0
3892: oTypeSNodeType
3893: oChoice 3897
3895: oJumpForward 3902
3897: Choice Lookup Table
          19   3895
3900: oError 8
3902: oTypeSPop
3903: oReturn
3904: oLocalSpace 0
3906: oTypeSNodeType
3907: oChoice 3911
3909: oJumpForward 3916
3911: Choice Lookup Table
          19   3909
3914: oError 8
3916: oReturn
3917: oLocalSpace 1
3919: oGetAddrLocal 1
3921: oPushResult
3922: oGetParam 2
3924: oPushResult
3925: oNodeNew
3926: oPop 1
3928: oAssign
3929: oGetLocal 1
3931: oPushResult
3932: oSetResult 13
3934: oPushResult
3935: oGetParam 1
3937: oPushResult
3938: oNodeSetInt
3939: oPop 3
3941: oGetLocal 1
3943: oPushResult
3944: oTypeAdd
3945: oPop 1
3947: oGetLocal 1
3949: oReturn
3950: oReturn
3951: oLocalSpace 1
3953: oGetAddrLocal 1
3955: oPushResult
3956: oGetParam 3
3958: oPushResult
3959: oNodeNew
3960: oPop 1
3962: oAssign
3963: oGetLocal 1
3965: oPushResult
3966: oSetResult 5
3968: oPushResult
3969: oGetParam 2
3971: oPushResult
3972: oNodeSetKind
3973: oPop 3
3975: oGetLocal 1
3977: oPushResult
3978: oSetResult 4
3980: oPushResult
3981: oGetParam 1
3983: oPushResult
3984: oNodeSetInt
3985: oPop 3
3987: oGetLocal 1
3989: oReturn
3990: oReturn
3991: oLocalSpace 1
3993: oGetAddrLocal 1
3995: oPushResult
3996: oGetParam 1
3998: oPushResult
3999: oSetResult 14
4001: oPushResult
4002: oNodeGet
4003: oPop 2
4005: oAssign
4006: oGetLocal 1
4008: oPushResult
4009: oNodeNull
4010: oPop 1
4012: oChoice 4068
4014: oGetAddrLocal 1
4016: oPushResult
4017: oSetResult 22
4019: oPushResult
4020: oNodeNew
4021: oPop 1
4023: oAssign
4024: oGetLocal 1
4026: oPushResult
4027: oSetResult 15
4029: oPushResult
4030: oGetParam 1
4032: oPushResult
4033: oNodeSet
4034: oPop 3
4036: oGetLocal 1
4038: oPushResult
4039: oSetResult 13
4041: oPushResult
4042: oSetResult 8
4044: oPushResult
4045: oNodeSetInt
4046: oPop 3
4048: oGetLocal 1
4050: oPushResult
4051: oTypeAdd
4052: oPop 1
4054: oGetParam 1
4056: oPushResult
4057: oSetResult 14
4059: oPushResult
4060: oGetLocal 1
4062: oPushResult
4063: oNodeSet
4064: oPop 3
4066: oJumpForward 4071
4068: Choice Lookup Table
           1   4014
4071: oGetLocal 1
4073: oReturn
4074: oReturn
4075: oLocalSpace 0
4077: oGetParam 1
4079: oPushResult
4080: oNodeType
4081: oPop 1
4083: oChoice 4112
4085: oSetResult 0
4087: oReturn
4088: oJumpForward 4126
4090: oSetResult 0
4092: oReturn
4093: oJumpForward 4126
4095: oSetResult 0
4097: oReturn
4098: oJumpForward 4126
4100: oGetParam 1
4102: oPushResult
4103: oSetResult 17
4105: oPushResult
4106: oNodeGetInt
4107: oPop 2
4109: oReturn
4110: oJumpForward 4126
4112: Choice Lookup Table
          24   4100
          20   4095
          19   4090
          18   4085
4121: oError 3
4123: oSetResult 0
4125: oReturn
4126: oReturn
4127: oLocalSpace 0
4129: oGetParam 1
4131: oPushResult
4132: oSetResult 8
4134: oPushResult
4135: oNodeGetInt
4136: oPop 2
4138: oPushResult
4139: oEmitInt
4140: oPop 1
4142: oReturn
4143: oLocalSpace 1
4145: oGetAddrGlobal 2
4147: oPushResult
4148: oSetResult 17
4150: oPushResult
4151: oSetResult 4
4153: oPushResult
4154: oCall 3917
4156: oPop 2
4158: oAssign
4159: oGetAddrGlobal 3
4161: oPushResult
4162: oSetResult 18
4164: oPushResult
4165: oSetResult 4
4167: oPushResult
4168: oCall 3917
4170: oPop 2
4172: oAssign
4173: oGetAddrGlobal 4
4175: oPushResult
4176: oSetResult 19
4178: oPushResult
4179: oSetResult 1
4181: oPushResult
4182: oCall 3917
4184: oPop 2
4186: oAssign
4187: oGetAddrGlobal 5
4189: oPushResult
4190: oSetResult 20
4192: oPushResult
4193: oSetResult 1
4195: oPushResult
4196: oCall 3917
4198: oPop 2
4200: oAssign
4201: oGetAddrGlobal 6
4203: oPushResult
4204: oSetResult 21
4206: oPushResult
4207: oSetResult 256
4209: oPushResult
4210: oCall 3917
4212: oPop 2
4214: oAssign
4215: oGetAddrLocal 1
4217: oPushResult
4218: oSetResult 10
4220: oPushResult
4221: oSetResult 5
4223: oPushResult
4224: oIdAdd_File
4225: oPushResult
4226: oCall 3951
4228: oPop 3
4230: oAssign
4231: oGetLocal 1
4233: oPushResult
4234: oSetResult 6
4236: oPushResult
4237: oGetGlobal 2
4239: oPushResult
4240: oNodeSet
4241: oPop 3
4243: oGetLocal 1
4245: oPushResult
4246: oScopeDeclare
4247: oPop 1
4249: oGetAddrLocal 1
4251: oPushResult
4252: oSetResult 10
4254: oPushResult
4255: oSetResult 5
4257: oPushResult
4258: oIdAdd_Integer
4259: oPushResult
4260: oCall 3951
4262: oPop 3
4264: oAssign
4265: oGetLocal 1
4267: oPushResult
4268: oSetResult 6
4270: oPushResult
4271: oGetGlobal 3
4273: oPushResult
4274: oNodeSet
4275: oPop 3
4277: oGetLocal 1
4279: oPushResult
4280: oScopeDeclare
4281: oPop 1
4283: oGetAddrLocal 1
4285: oPushResult
4286: oSetResult 10
4288: oPushResult
4289: oSetResult 5
4291: oPushResult
4292: oIdAdd_Boolean
4293: oPushResult
4294: oCall 3951
4296: oPop 3
4298: oAssign
4299: oGetLocal 1
4301: oPushResult
4302: oSetResult 6
4304: oPushResult
4305: oGetGlobal 4
4307: oPushResult
4308: oNodeSet
4309: oPop 3
4311: oGetLocal 1
4313: oPushResult
4314: oScopeDeclare
4315: oPop 1
4317: oGetAddrLocal 1
4319: oPushResult
4320: oSetResult 10
4322: oPushResult
4323: oSetResult 5
4325: oPushResult
4326: oIdAdd_Char
4327: oPushResult
4328: oCall 3951
4330: oPop 3
4332: oAssign
4333: oGetLocal 1
4335: oPushResult
4336: oSetResult 6
4338: oPushResult
4339: oGetGlobal 5
4341: oPushResult
4342: oNodeSet
4343: oPop 3
4345: oGetLocal 1
4347: oPushResult
4348: oScopeDeclare
4349: oPop 1
4351: oGetAddrLocal 1
4353: oPushResult
4354: oSetResult 10
4356: oPushResult
4357: oSetResult 5
4359: oPushResult
4360: oIdAdd_String
4361: oPushResult
4362: oCall 3951
4364: oPop 3
4366: oAssign
4367: oGetLocal 1
4369: oPushResult
4370: oSetResult 6
4372: oPushResult
4373: oGetGlobal 6
4375: oPushResult
4376: oNodeSet
4377: oPop 3
4379: oGetLocal 1
4381: oPushResult
4382: oScopeDeclare
4383: oPop 1
4385: oGetAddrLocal 1
4387: oPushResult
4388: oSetResult 9
4390: oPushResult
4391: oSetResult 4
4393: oPushResult
4394: oIdAdd_True
4395: oPushResult
4396: oCall 3951
4398: oPop 3
4400: oAssign
4401: oGetLocal 1
4403: oPushResult
4404: oSetResult 6
4406: oPushResult
4407: oGetGlobal 4
4409: oPushResult
4410: oNodeSet
4411: oPop 3
4413: oGetLocal 1
4415: oPushResult
4416: oSetResult 8
4418: oPushResult
4419: oSetResult 1
4421: oPushResult
4422: oNodeSetInt
4423: oPop 3
4425: oGetLocal 1
4427: oPushResult
4428: oScopeDeclare
4429: oPop 1
4431: oGetAddrLocal 1
4433: oPushResult
4434: oSetResult 9
4436: oPushResult
4437: oSetResult 4
4439: oPushResult
4440: oIdAdd_False
4441: oPushResult
4442: oCall 3951
4444: oPop 3
4446: oAssign
4447: oGetLocal 1
4449: oPushResult
4450: oSetResult 6
4452: oPushResult
4453: oGetGlobal 4
4455: oPushResult
4456: oNodeSet
4457: oPop 3
4459: oGetLocal 1
4461: oPushResult
4462: oSetResult 8
4464: oPushResult
4465: oSetResult 0
4467: oPushResult
4468: oNodeSetInt
4469: oPop 3
4471: oGetLocal 1
4473: oPushResult
4474: oScopeDeclare
4475: oPop 1
4477: oReturn
