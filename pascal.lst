   2: title: 'Pascal Compiler 1.1.5 -- Jan 01 ''90';
         
      %
      %  Pascal.ssl
      %
      %  Pascal Compiler for the Amiga, by Steve Rice.
      %
      %  HISTORY
      %    11Sep89   First version, framework of parser.
      %    18Sep89   Added some semantic mechanisms.
      %    21Sep89   Added simple type references; expressions generate code.
      %    22Sep89   Allocate variable addresses as they're declared.
      %    24Sep89   Added arrays, pointers.
      %    27Sep89   Added for statement.
      %    23Oct89   Fixed for statement, so CYCLE goes to next step.
      %    01Jan90   Added string literals
      %
      %  *** WORKING ON : Records ***
      %    - fields allocated now, but need to calculate size of whole record
      %    - need to make ST a linked list structure for oSymPopLevelSaveType
      %      (note, this will mess up SD, and oSymLevelAnySyms)
      %    - references to records: currently pushes addr on stack. ok.
      %      Field selection '.' should push the fields on the SD, look up
      %      the next ident only in that level, add the offset if not 0,
      %      replace the current type with the field type, and continue
      %      (note, we're in fetch mode here, working with addresses on run stack
      %      just as with arrays).
      %
      %  *** WORKING ON : Procedures ***
      %    - formal args declared but not saved (see Records)
      %    - allocate args so the #'s match the stack (esp. re VAR flag)
      %    - pay attention to VAR flag
      %    - formal params are visible to body of proc, but requires special
      %      code to access non-global vars.
      %      i.e. in expressions, if var is found at SD level > 0, must take it
      %      off stack. (possibly with indirection).
      %      NOTE, VAR parameters are like pointer vars, with automatic deref ('^')
      %      Maybe this helps with the implementation.
      %    - Big choice: what is runtime environment of stack machine?
      %        Call stack with params, returns
      %        Expr stack used within a statement
      %        These can be the same if Expr stack always empty before/after an
      %        indivisible expression. (??)
      %
      %  NOTES
      %    1) During a loop, the top counter counts the number of 'exit'
      %       statements to be patched.
      %    2) During a loop, the top entry in the patchLoop stack is the addr
      %       of the start of the loop (used by 'cycle' to repeat the loop).
      %    3) The 'value' of a var symbol is its allocated address.
      %    4) References to vars of intrinsic types, and pointer types,
      %       pushes the value of the var on the expr stack.  Referenecs to
      %       vars of compound types (arrays, records...) pushes the address
      %       on the expr stack.
      %    5) Just as there is only one type table entry for a given (named) type,
      %       there is only one type table entry for a pointer to a named type.
      %       When a pointer type is declared, a field in the TT entry of the
      %       type pointed to will be set to indicate the TT entry of the pointer
      %       to that type (0 means none defined yet).  When evaluating the
      %       expression ^x, the type in that field in the entry for the type of x
      %       will be used (unless it's 0, in which case a new TT entry will be
      %       created).
      
   2: input:
   2:    pIdent
   2:    pIntLit
   2:    pStrLit
   2:    pAssign       ':='
   2:    pSemiColon    ';'
   2:    pEqual        '='
   2:    pNotEqual     '<>'
   2:    pLess         '<'
   2:    pGreater      '>'
   2:    pLessEqual    '<='
   2:    pGreaterEqual '>='
   2:    pColon        ':'
   2:    pComma        ','
   2:    pLParen       '('
   2:    pRParen       ')'
   2:    pLSquare      '['
   2:    pRSquare      ']'
   2:    pCarat        '^'
   2:    pDot          '.'
   2:    pDotDot       '..'
   2:    pTimes        '*'
   2:    pDivide       '/'
   2:    pPlus         '+'
   2:    pMinus        '-'
   2:    pEof
   2:    pInvalid
      
      %  keywords  (built-in types 'integer', 'char', etc, are not keywords,
      %             type constructors 'array', 'record', 'set' are keywords,
      %             pseudo-procedures 'writeln', 'readln' are keywords)
      
   2:    pProgram
   2:    pProcedure
   2:    pFunction
   2:    pConst
   2:    pType
   2:    pVar
   2:    pBegin
   2:    pEnd
   2:    pArray
   2:    pRecord
   2:    pSet
   2:    pOf
   2:    pIf
   2:    pThen
   2:    pElse
   2:    pFor
   2:    pTo
   2:    pDownto
   2:    pDo
   2:    pWhile
   2:    pRepeat
   2:    pUntil
   2:    pCycle
   2:    pExit
   2:    pReturn
   2:    pAnd
   2:    pOr
   2:    pNot
   2:    pWriteln
   2:    pWrite
   2:    pReadln
   2:    pRead;
      
      
   2: output:
      
      %  Instructions for a stack machine (all vars are 32-bit integers)
      
   2:    tPushIntVar       % push value of int var; addr follows
   2:    tPushBoolVar
   2:    tPushPtrVar
   2:    tPushAddr         % addr (of a var) follows
   2:    tFetchInt         % replace addr (on tos) of int var with contents
   2:    tFetchBool        %    "      "      "     " bool  "   "    "
   2:    tFetchPtr         %    "      "      "     " ptr   "   "    "   
   2:    tPushIntLit       % int lit follows (NOTE, used for BOOLEAN too)
   2:    tAssignInt        % assign value on tos to addr under it (pop both)
   2:    tAssignBool       %   "      "    "   "  "   "    "    "   "   "
   2:    tAssignPtr        % assign val WHOSE ADDR is on tos to addr under it (pop)
   2:    tCopy             % #words follows.  tos=src, 2nd=dest (pop 2)
   2:    tIncIntVar        % increment int var (addr follows)
   2:    tDecIntVar        % decrement int var (addr follows)
   2:    tMultiplyInt      % multiply top two integers (replacing with result)
   2:    tDivideInt
   2:    tAddInt
   2:    tSubtractInt
   2:    tNegateInt        % top entry *= -1
   2:    tNot              % negate top boolean
   2:    tAnd              % boolean AND of top 2 (pop 2, push 1)
   2:    tOr               % boolean OR or top 2 (pop 2, push 1)
   2:    tEqualInt         % top two entries equal? (pop 2, push 1) (true=1)
   2:    tNotEqualInt      %    NOTE, these all work for booleans too
   2:    tGreaterInt       % 2nd entry greater than top entry? (pop 2, push answer)
   2:    tLessInt
   2:    tGreaterEqualInt
   2:    tLessEqualInt
   2:    tEqualPtr         % are the ptr vars whose addresses are top 2 equal?
   2:    tNotEqualPtr
   2:    tCall             % addr follows
   2:    tReturn
   2:    tJump             % addr follows
   2:    tJumpTrue         % addr follows  (pops top of stack, jumps if true)
   2:    tJumpFalse        % addr follows  (pops top of stack, jumps if false)
   2:    tPutInt           % for writeln : write integer on tos, pop
   2:    tPutBool          %  "     "    : write TRUE/FALSE, pop
   2:    tPutStr           %  "     "    : write string whose addr is on tos, pop
   2:    tPutPtr           %  "     "    : write ptr var whose addr is on tos, pop
   2:    tPutCR            %  "     "    : write cr
      
      %  Other:
      
   2:    tSpace            % emit a hole, to be patched later
   2:    tSymVal           % emit value of symbol looked-up with oSymLookup
   2:    ;
      
   2: error:
   2:    eBadStatement
   2:    eNotConst
   2:    eNotType
   2:    eNotOrdinalType
   2:    eNotVar
   2:    eNotIntVar
   2:    eNotValue
   2:    eNotInteger
   2:    eNotBoolean
   2:    eNotPointer
   2:    eNotArray
   2:    eTooManySubscripts
   2:    eTypeMismatch
   2:    eNotImplemented
   2:    eNotAllowed
   2:    eNotInALoop
   2:    eRecordEmpty
   2:    ;
      
   2: include 'pascal_schema.ssl'
      
      % Generated automatically by schema
      
   2: type node_type:
   2: 	nINVALID
   2: 	Object
   2: 	nScope
   2: 	nDeclaration
   2: 	nIdent
   2: 	nProgram
   2: 	nProc
   2: 	nFunc
   2: 	nConst
   2: 	nTypeDecl
   2: 	nVar
   2: 	nGlobalVar
   2: 	nLocalVar
   2: 	nRecordField
   2: 	nParam
   2: 	nType
   2: 	nFileType
   2: 	nIntegerType
   2: 	nBooleanType
   2: 	nCharType
   2: 	nStringType
   2: 	nPointerType
   2: 	nArrayType
   2: 	nSubrangeType
   2: 	nRecordType
   2: 	nEnumType
   2: 	nSetType
   2: 	;
      
   2: type node_attribute:
   2: 	qINVALID
   2: 	qParentScope
   2: 	qDecls
   2: 	qNextOffset
   2: 	qIdent
   2: 	qKind
   2: 	qType
   2: 	qParamType
   2: 	qValue
   2: 	qParams
   2: 	qChildScope
   2: 	qInOut
   2: 	qSize
   2: 	qPointerType
   2: 	qBaseType
   2: 	qIndexType
   2: 	qLow
   2: 	qHigh
   2: 	qScope
   2: 	;
      
      
   2: type Node:     % A pointer to a node in the schema database (symbol database)
   2:     Null = 0
   2:     ;
      
   2: type NodeVec:  % A pointer to a vector of Node.  See mechanism node_vec_mech
   2:     NullVec = 0
   2:     ;
      
   2: type boolean:
   2:    false    = 0
   2:    true     = 1;
      
   2: type kind:           % kind of identifier
   2:    kUndefined        % not yet added to symbol table
   2:    kProgram
   2:    kProc
   2:    kFunc
   2:    kConst
   2:    kType
   2:    kVar;
      
      % intrinsic types & type constructs
      
   2: type typ:
   2:    tyNone     = 0    % in ptrTyp field of TT, means no ptr to type defined
   2:    tyInteger
   2:    tyBoolean
   2:    tyChar
   2:    tyString
   2:    tyFile            % tyInteger..tyFile are scalars (types on their own)
   2:    tyPointer         % following are type constructor classes...
   2:    tyArray           %   (they are not type#'s)
   2:    tyRecord
   2:    tyParams          % like record; a collection of proc/func params
   2:    tySet;
      
      
      % Some general schema node operations.
      % node_type and node_attribute are defined in generated file pascal_schema.ssl included above.
      %
   2: mechanism node_mech:
   2:     oNodeNew (node_type) >> Node         % create new node
   2:     oNodeSet (Node, node_attribute, Node)   % set Node attribute of node
   2:     oNodeSetInt (Node, node_attribute, int) % set int attribute of node
   2:     oNodeSetBoolean (Node, node_attribute, boolean)
   2:     oNodeSetKind (Node, node_attribute, kind) % set attribute of node  *** MIGHT NOT NEED
   2:     oNodeGet (Node, node_attribute) >> Node    % get Node attribute of node
   2:     oNodeGetInt (Node, node_attribute) >> int  % get int attribute of node
   2:     oNodeGetBoolean (Node, node_attribute) >> boolean  % get int attribute of node
   2:     oNodeNull (Node) >> boolean          % is node null?
   2:     oNodeNext (inout Node)               % advance Node to next in list
   2:     oNodeType (Node) >> node_type        % return node type of node
   2:     oNodeEqual (Node, Node) >> boolean   % compare two nodes for equality
                                               % (i.e. same node, not just same contents)
   2:     ;
      
      
      % Manipulate a temporary vector of Node
      %
   2: mechanism node_vec_mech:
   2:     oNodeVecNew >> NodeVec
   2:     oNodeVecDelete( NodeVec nv )
   2:     oNodeVecAppend( NodeVec nv, Node n )
   2:     oNodeVecSize( NodeVec nv ) >> int                % how many elements
   2:     oNodeVecElement( NodeVec nv, int idx ) >> Node   % element at index idx (0..size-1)
   2:     ;
      
      
   2: mechanism emit_mech:
   2:     oEmitInt( int )              % emit int into the generated code
   2:     Here >> int                  % current address in the generated code
   2:     oPatch( int addr, int val )  % patch an int into address in the generated code
   2:     ;
      
   2: mechanism math:
   2:     inc (inout int)
   2:     dec (inout int)
   2:     negate (int) >> int
   2:     subtract( int x, int y ) >> int     % x - y
   2:     multiply( int x, int y ) >> int     % x * y
   2:     equal( int x, int y ) >> boolean
   2:     equal_zero (int) >> boolean
   2:     equal_node_type (node_type, node_type) >> boolean     % Want equal_<type> for every type
   2:     ;
      
   2: mechanism more_builtins:      % These should be built-in SSL operations
   2:     TOKEN_VALUE >> int        % value of just accepted token, e.g. IntLit token
   2:     LAST_ID >> int            % id number of last accepted identifier
   2:     ;
      
   2: mechanism scope_mech:
   2:     oScopeBegin                          % create a new scope. Subsequent declarations will go here.
   2:     oScopeEnd                            % end current scope. Subsequent declarations will go to parent scope.
   2:     oScopeCurrent >> Node                % returns current scope
   2:     oScopeDeclare( Node )                % add declaration to current scope.
   2:     oScopeDeclareAlloc( Node )           % add declaration to current scope, and allocate space according to its type
   2:     oScopeFind >> Node                   % find declaration of last accepted identifier.  Returns Null if not found.
   2:     oScopeFindRequire >> Node            % find declaration of last accepted identifier.  Error if not found.
   2:     ;
      
      
   2: mechanism type_mech:
   2:     oTypeAdd( Node node )     % add the given nType to the type table
   2:     ;
      
   2: mechanism type_stack_mech:
   2:     oTypeSPush( Node node )
   2:     oTypeSPop
   2:     oTypeSTop >> Node
   2:     oTypeSNodeType >> node_type          % node_type of the node on top of type stack, skipping subranges
   2:     ;
      
      
   2: mechanism id_mech:
          % adds a predefined id to the scanner's id table, and returns the id code
   2:     oIdAdd_File >> int
   2:     oIdAdd_Integer >> int
   2:     oIdAdd_Boolean >> int
   2:     oIdAdd_Char >> int
   2:     oIdAdd_String >> int
   2:     oIdAdd_True >> int
   2:     oIdAdd_False >> int
   2:     ;
      
      
   2: mechanism count :
   2:    oCountPush(int)          % start a new counter, with initial value
   2:    oCountInc
   2:    oCountDec
   2:    oCountIsZero >> boolean
   2:    oCountPop;
      
   2: mechanism sym :                
      
         % symbol table
      
   2:    oSymPushLevel               % new lexical level
   2:    oSymPopLevel                % return to old lexical level
   2:    oSymPopLevelSaveType        % attach id's in lex level to the syms field
                                     %   of the type on top of the type stack
   2:    oSymLookup                  % lookup last id accepted (for use by
                                     %   other semantic operations...)
   2:    oSymChooseKind >> kind      % kind of symbol looked-up
   2:    oSymAddSPop                 % add id on symbol stack to symbol table
                                     %   (pop symbol stack)
   2:    oSymLevelAnySyms >> boolean % any symbols in top lexical level?
      
         % symbol stack
         % (used to construct entries for the symbol table,
         %       and to handle references to symbols)
      
   2:    oSymSPushId                 % push id# of last id accepted
   2:    oSymSSetKind(kind)          % set kind of top symbol (kVar, kType, etc)
                                     %   ... error if it was already set
   2:    oSymSSetValPop              % set val of sym on SS from val on VS (pop VS)
   2:    oSymSSetTypS                % set type of top symbol, from type on
                                     %   type stack (don't pop type stack)
   2:    oSymSSetParamTypS           % set param type of top symbol from type on TS
   2:    oSymSAllocate               % allocate data space for var, using size of
                                     %   type on type stack
   2:    ;
      
   2: mechanism value :              % value stack, to calc. const expr's
   2:    oValuePushToken             % push value of (int lit) token just read
   2:    oValuePushVal               % push val of symbol looked-up
   2:    oValuePush(int)             % push an explicit int lit
   2:    oValuePushSizeTS            % push size of type on type stack
   2:    oValuePushLowTS             % push low subscript of type on type stack
   2:    oValueNegate                % negate top value
   2:    oValueDifference            % pop 2, push (top - 2nd + 1)
   2:    oValueMultiply              % pop 2, push (top * 2nd)
   2:    oValueIsZero >> boolean     % is top value zero?
   2:    oValueIsOne >> boolean      % is top value one?
   2:    oValueTop >> int            % get top value on value stack
   2:    oValuePop;
      
   2: mechanism string :
   2:    oStringAllocLit;            % alloc data space for strlit, push address
                                     %   on value stack
      
   2: mechanism typS :               % type stack
   2:    oTypSPushTyp                % push type# of sym looked-up (not root type)
   2:    oTypSPush(typ)              % push explicit type# (intrinsic)
   2:    oTypSPopPushBase            % replace top TS with type# of its base type
   2:    oTypSPopPushPtr             % replace top TS with its ptrType field
   2:    oTypSMatch >> boolean       % do top 2 types match? (pop both, push 1)
   2:    oTypSChoose >> typ          % return type on TS (not root type)
   2:    oTypSChoosePop >> typ       % return type on TS (not root type), pop it
   2:    oTypSChooseKind >> typ      % return kind (array,etc) of top type; no pop
   2:    oTypSChoosePtr >> typ       % return 'ptrType' field of type; no pop
   2:    oTypSSwap                   % swap top two TS entries
   2:    oTypSPop
      
   2:    oTypNew(typ)                % new TT entry, with type class (e.g. array)
                                     %   push typ# on TS, for use by following:
   2:    oTypSetSize                 % size field = VS (don't pop VS)
   2:    oTypAssignBasePop           % base of 2nd on TS := top of TS, pop TS
   2:    oTypAssignPtr               % ptrType of 2nd on TS := top of TS, no pop
   2: ;
      
   2: type patchStack:
   2:    patchLoop                   % addr of start of loop (repeat, while, for)
   2:    patchExit                   % addrs where jumps out of loop are
                                     %   (use count mechanism to count how many)
   2:    patchIf;                    % addr of jump around code in 'if' statement
      
   2: mechanism patch:               % note, creates absolute-address jumps
   2:    oPatchPushHere(patchStack)  % put current address on a patch stack
   2:    oPatchAnyEntries(patchStack) >> boolean     % anything in patch stack?
   2:    oPatchSwap(patchStack)      % swap top two entries
   2:    oPatchDup(patchStack)       % duplicate the top entry
   2:    oPatchPopFwd(patchStack)    % store here at x (x=top of stack), pop stack
   2:    oPatchPopBack(patchStack);  % emit x (so advance 'here'), pop stack
      
   2: rules
      
      % ----------------------------- Global Variables ----------------------------
      
   2: Node    globalScope            % global nScope
      
      % built-in nTypes
   2: Node    FileType
   2: Node    IntegerType
   2: Node    BooleanType
   2: Node    CharType
   2: Node    StringType
      
      % -------------------------- Forward Declarations -------------------------
      
   2: Block( node_type varNodeType );
   2: VarDecl( node_type varNodeType );
   2: newType( node_type nt, int size ) >> Node;
   2: newIdent( node_type nt, kind k, int id ) >> Node;
   2: EmitValue( Node decl );
   2: TypeRef( out Node theType );
   2: PointerTypeTo( Node theType ) >> Node;
   2: OrdinalLow( Node theType ) >> int;
      
      
      % ----------------------------- Declarations ----------------------------
      
   2: Program:
   4:    Node t
      
   4:    oScopeBegin
   5:    globalScope = oScopeCurrent
      
  10:    @installBuiltIns
      
  12:    pProgram
  14:    pIdent
      
  16:    t = @newIdent( nProgram, kProgram, LAST_ID )
  32:    oScopeDeclare( t )
      
  38:    [
  38:       | '(' :
  40:          pIdent      % input, output files
      
  42:          t = @newIdent( nVar, kVar, LAST_ID )
  58:          oNodeSet( t, qType, FileType )
  70:          oScopeDeclareAlloc( t )
      
  76:          ','
  78:          pIdent
      
  80:          t = @newIdent( nVar, kVar, LAST_ID )
  96:          oNodeSet( t, qType, FileType )
 108:          oScopeDeclareAlloc( t )
      
 114:          ')'
 116:       | * :
 121:    ]
 121:    ';'
 123:    @Block( nGlobalVar )    % not including punctuation after body's 'end'
 130:    '.'
 132:    oScopeEnd
 134:    ;
      
 134: Block( node_type varNodeType ):
 136:    {[
 136:       | pConst :     @ConstDecl
 140:       | pType :      @TypeDecl
 144:       | pVar :       @VarDecl( varNodeType )
 153:       | pProcedure : @ProcDecl
 157:       | pFunction :  @FuncDecl
 161:       | * :          @Statement
 176:                      .tReturn
 178:                      >
 180:    ]};
      
 183: ProcDecl:
 185:    Node decl
      
 185:    pIdent
 187:    decl = @newIdent( nProc, kProc, LAST_ID )
      
 203:    oScopeBegin
 204:    @FormalArgDecl
 206:    oNodeSet( decl, qParams, oScopeCurrent )
 217:    oScopeEnd
 218:    oScopeDeclare( decl )
 224:    ';'
      
 226:    oScopeBegin
 227:    @Block( nLocalVar )
 234:    oNodeSet( decl, qChildScope, oScopeCurrent )
 245:    oScopeEnd
 246:    ';';
      
 249: FuncDecl:
 251:    Node decl
 251:    Node theType
      
 251:    pIdent
 253:    decl = @newIdent( nFunc, kFunc, LAST_ID )
      
 269:    oScopeBegin
 270:    @FormalArgDecl
 272:    oNodeSet( decl, qParams, oScopeCurrent )
 283:    oScopeEnd
 284:    oScopeDeclare( decl )
 290:    ':'
      
 292:    @TypeRef( theType )
 299:    oNodeSet( decl, qType, theType )
 311:    ';'
      
 313:    oScopeBegin
 314:    @Block( nLocalVar )
 321:    oNodeSet( decl, qChildScope, oScopeCurrent )
 332:    oScopeEnd
 333:    ';';
      
      
      % TO DO:
      %   This code is declaring params in the wrong order.
      %   Also ignoring var keyword.
      %   Also not using schema yet.
      %   Also should use a var instead of count stack.
      %
 336: FormalArgDecl:
 338:    [
 338:       | '(' :
 340:          {
 340:             NodeVec decls
 340:             decls = oNodeVecNew
 345:             Node decl
 345:             boolean isInOut
 345:             isInOut = false
      
 351:             [
 351:                | pVar : isInOut = true
 359:                | * :
 364:             ]
      
 364:             {  pIdent
      
 366:                decl = @newIdent( nParam, kVar, LAST_ID )
 382:                oNodeSetBoolean( decl, qInOut, isInOut )
 394:                oNodeVecAppend( decls, decl )
      
 403:                [
 403:                   | ':' : >
 407:                   | ',' :
 409:                ]
 417:             }
      
 419:             Node theType
 419:             @TypeRef( theType )
      
 426:             int i
 426:             i = 0
 432:             {[ equal( i, oNodeVecSize( decls ) )
 446:                | false :
 447:                   decl = oNodeVecElement( decls, i )
 460:                   oNodeSet( decl, qType, theType )
 472:                   oScopeDeclareAlloc( decl )
 478:                   inc( i )
 484:                | * :
 489:                   >
 491:             ]}
      
 493:             oNodeVecDelete( decls )
      
 499:             [
 499:                | ')' : >
 503:                | ';' :
 505:             ]
 513:          }
 515:       | * :
 520:    ];
      
 521: ConstDecl:
 523:    {[
 523:       | pIdent :
 525:          Node decl
 525:          decl = @newIdent( nConst, kConst, LAST_ID )
 541:          '='
      
 543:          @ConstExpr
               % TO DO: currently ConstExpr leaves int result on oValue stack
 545:          int val
 545:          val = oValueTop
 550:          oValuePop
 551:          oNodeSetInt( decl, qValue, val )
      
               % TO DO: different types.  Currently assumes int!
 563:          oNodeSet( decl, qType, IntegerType )
      
 575:          oScopeDeclare( decl )
 581:          ';'
 583:       | * :
 588:          >
 590:    ]};
      
 593: TypeDecl:
 595:    {[
 595:       | pIdent :
 597:          Node decl
 597:          decl = @newIdent( nTypeDecl, kType, LAST_ID )
 613:          '='
 615:          Node theType
 615:          @TypeRef( theType )
 622:          oNodeSet( decl, qType, theType )
 634:          oScopeDeclare( decl )
 640:          ';'
 642:       | * :
 647:          >
 649:    ]};
      
 652: VarDecl( node_type varNodeType ):
 654:    {[
 654:       | pIdent :
 656:          NodeVec decls
 656:          decls = oNodeVecNew
 661:          Node decl
 661:          {
 661:             decl = @newIdent( varNodeType, kVar, LAST_ID )
 677:             oNodeVecAppend( decls, decl )
 686:             [
 686:                | ',' :
 688:                   pIdent
 690:                | * :
 695:                   >
 697:             ]
 697:          }
 699:          ':'
 701:          Node theType
 701:          @TypeRef( theType )
      
 708:          int i
 708:          i = 0
 714:          {[ equal( i, oNodeVecSize( decls ) )
 728:            | false :
 729:              decl = oNodeVecElement( decls, i )
 742:              oNodeSet( decl, qType, theType )
 754:              oScopeDeclareAlloc( decl )
 760:              inc( i )
 766:             | * :
 771:               >
 773:          ]}
      
 775:          oNodeVecDelete( decls )
 781:          ';'
 783:       | * :
 788:          >
 790:    ]};
      
      
      % Parse a type reference, returning the nType.
      % This will add types to the type table, as needed.
      %
      % Style question - at the moment I think callers look clearer if we use
      % an out param here, rather than a return value.
      %
 793: TypeRef( out Node resultType ):
 795:    [
 795:       | pIdent :           % previously named type (including intrinsics)
 797:          Node decl
 797:          decl = oScopeFindRequire
 802:          [ oNodeType( decl )
 809:            | nTypeDecl :
 810:                resultType = oNodeGet( decl, qType )
 823:            | * :
 828:                #eNotType
 830:                resultType = IntegerType
 836:          ]
         
 836:       | pArray :
 838:          '['
      
               % A multi-dimensional array is represented as a chain
               %    array [subrange1] of array [subrange2] of elementType
      
               % First, we build a vector of nArray's, each with one subrange as its index type,
               % but without setting the "of" type or size.
      
 840:          NodeVec dimensions
 840:          dimensions = oNodeVecNew
      
 845:          {
                  % to do: probably should use general subrange parsing, incl minimal size value
                  %   In fact, supposed to parse ordinal_type here.  all ordinal types have a static low, high.
                  %   Not necessary to be a subrange.
      
 845:             Node subrange
 845:             subrange = oNodeNew( nSubrangeType )
                  % TO DO: currently assuming subrange of integer
 855:             oNodeSet( subrange, qBaseType, IntegerType )
      
                  % TO DO: currently ConstExpr leaves int result on oValue stack
 867:             @ConstExpr
 869:             oNodeSetInt( subrange, qLow, oValueTop )
 880:             oValuePop
 881:             '..'
 883:             @ConstExpr
 885:             oNodeSetInt( subrange, qHigh, oValueTop )
 896:             oValuePop
 897:             oNodeSetInt( subrange, qSize, 4 )   % maybe don't need
      
 909:             oTypeAdd( subrange )
      
 915:             Node a
 915:             a = oNodeNew( nArrayType )
 925:             oNodeSet( a, qIndexType, subrange )
      
 937:             oNodeVecAppend( dimensions, a )
                  % I'll hold off on adding 'a' to the type table since not fully formed yet
      
 946:             [
 946:                | ']' : >
 950:                | ',' :
 952:             ]
 960:          }
 962:          pOf
 964:          Node baseType
 964:          @TypeRef( baseType )
      
               % Work backwards through the dimensions,
               % hooking up the 'of' type and calculating the size.
               % At each iteration, baseType is the 'of' type.
      
 971:          int dim
 971:          dim = oNodeVecSize( dimensions )
 981:          {
 981:              dec(dim)
      
 987:              Node a
 987:              a = oNodeVecElement( dimensions, dim )
1000:              oNodeSet( a, qBaseType, baseType )
1012:              Node subrange
1012:              subrange = oNodeGet( a, qIndexType )
1025:              int width
1025:              width = subtract( oNodeGetInt( subrange, qHigh ), oNodeGetInt( subrange, qLow ) )
1052:              inc( width )
1058:              oNodeSetInt( a, qSize, multiply( width, oNodeGetInt( baseType, qSize ) ) )
      
1084:              oTypeAdd( a )
1090:              baseType = a
      
1096:              [ equal_zero(dim)
1103:                  | true:  >
1106:                  | *:
1111:              ]
1111:          }
      
1113:          resultType = oNodeVecElement( dimensions, 0 )
1126:          oNodeVecDelete( dimensions )
      
1132:       | '^' :
1134:          Node theType
1134:          @TypeRef( theType )
1141:          resultType = @PointerTypeTo( theType )
      
1152:       | pRecord :
1154:          resultType = oNodeNew( nRecordType )
1164:          oScopeBegin
      
1165:          @VarDecl( nRecordField )
      
1172:          int size
1172:          size = oNodeGetInt( oScopeCurrent, qNextOffset )
               % to do: padding
1184:          [ equal_zero( size )
1191:             | true : #eRecordEmpty
1194:             | * :
1199:          ]
      
1199:          pEnd
      
1201:          oNodeSet( resultType, qScope, oScopeCurrent )
1212:          oNodeSetInt( resultType, qSize, size )
1224:          oScopeEnd
1225:          oTypeAdd( resultType )
      
      
            % *** TO DO: following type constructors are not implemented *** 
            % *** TO DO: also missing declaration of enum type
1231:       | pSet :
1233:          pOf
1235:          Node theType
1235:          @TypeRef( theType )
1242:       | * :       % this works for cases except where expr starts with an id
1255:          @ConstExpr '..' @ConstExpr
1261:    ];
      
      
      % ------------------------------ Expressions -----------------------------
      
      % Constant expressions: currently, only literal integers or previously
      % named constant integers are supported, possibly with a negation.
      % Constant expressions are evaluated at compile time.
      
1262: ConstExpr:
1264:    [
1264:       | pIntLit :
1266:          oValuePush( TOKEN_VALUE )
1271:       | pIdent :
1273:          Node decl
1273:          decl = oScopeFindRequire
1278:          [ oNodeType( decl )
1285:             | nConst :
1286:                oValuePush( oNodeGetInt( decl, qValue ) )
1299:             | * :
1304:                #eNotConst
1306:                oValuePush( 0 )
1312:          ]
1312:       | pMinus :
1314:          @ConstExpr
1316:          oValueNegate
1317:    ];
      
      %
      % General run-time expressions
      % The type stack tracks the type of the expression.
      %
      
1328: Expr:
1330:    @BoolExpr
1332:    {[
1332:       | '=' :
1334:          @BoolExpr
1336:          @MatchTypes
1338:          [ oTypeSNodeType
1340:             | nIntegerType, nBooleanType :  .tEqualInt
1343:             | nPointerType :                .tEqualPtr
1347:             | nCharType, nStringType :      #eNotImplemented
1351:             | * :                           #eNotAllowed
1366:          ]
1366:          oTypeSPop
1367:          oTypeSPush( BooleanType )
      
1373:       | '<>' :
1375:          @BoolExpr
1377:          @MatchTypes
1379:          [ oTypeSNodeType
1381:             | nIntegerType, nBooleanType :  .tNotEqualInt
1384:             | nPointerType :                .tNotEqualPtr
1388:             | nCharType, nStringType :      #eNotImplemented
1392:             | * :                           #eNotAllowed
1407:          ]
1407:          oTypeSPop
1408:          oTypeSPush( BooleanType )
      
1414:       | '<' :
1416:          @BoolExpr
1418:          @MatchTypes
1420:          [ oTypeSNodeType
1422:             | nIntegerType, nBooleanType :  .tLessInt
1425:             | nCharType, nStringType :      #eNotImplemented
1429:             | * :                           #eNotAllowed
1442:          ]
1442:          oTypeSPop
1443:          oTypeSPush( BooleanType )
      
1449:       | '>' :
1451:          @BoolExpr
1453:          @MatchTypes
1455:          [ oTypeSNodeType
1457:             | nIntegerType, nBooleanType :  .tGreaterInt
1460:             | nCharType, nStringType :      #eNotImplemented
1464:             | * :                           #eNotAllowed
1477:          ]
1477:          oTypeSPop
1478:          oTypeSPush( BooleanType )
      
1484:       | '<=' :
1486:          @BoolExpr
1488:          @MatchTypes
1490:          [ oTypeSNodeType
1492:             | nIntegerType, nBooleanType :  .tLessEqualInt
1495:             | nCharType, nStringType :      #eNotImplemented
1499:             | * :                           #eNotAllowed
1512:          ]
1512:          oTypeSPop
1513:          oTypeSPush( BooleanType )
      
1519:       | '>=' :
1521:          @BoolExpr
1523:          @MatchTypes
1525:          [ oTypeSNodeType
1527:             | nIntegerType, nBooleanType :  .tGreaterEqualInt
1530:             | nCharType, nStringType :      #eNotImplemented
1534:             | * :                           #eNotAllowed
1547:          ]
1547:          oTypeSPop
1548:          oTypeSPush( BooleanType )
      
1554:       | * :
1569:          >
1571:    ]};
      
1574: BoolExpr:
1576:    @BoolTerm
1578:    {[
1578:       | pOr :
1580:          @RequireBoolPop
1582:          @BoolTerm
1584:          @RequireBool
1586:          .tOr
1588:       | * :
1593:          >
1595:    ]};
      
1598: BoolTerm:
1600:    @BoolFactor
1602:    {[
1602:       | pAnd :
1604:          @RequireBoolPop
1606:          @BoolFactor
1608:          @RequireBool
1610:          .tAnd
1612:       | * :
1617:          >
1619:    ]};
      
1622: BoolFactor:
1624:    [
1624:       | pNot :
1626:          @ArithExpr
1628:          @RequireBool
1630:          .tNot
1632:       | * :
1637:          @ArithExpr
1639:    ];
      
1640: ArithExpr:
1642:    @Term
1644:    {[
1644:       | pPlus :
1646:          @RequireIntPop
1648:          @Term
1650:          @RequireInt
1652:          .tAddInt
1654:       | pMinus :
1656:          @RequireIntPop
1658:          @Term
1660:          @RequireInt
1662:          .tSubtractInt
1664:       | * :
1671:          >
1673:    ]};
      
1676: Term:
1678:    @Factor
1680:    {[
1680:       | pTimes :
1682:          @RequireIntPop
1684:          @Factor
1686:          @RequireInt
1688:          .tMultiplyInt
1690:       | pDivide :
1692:          @RequireIntPop
1694:          @Factor
1696:          @RequireInt
1698:          .tDivideInt
1700:       | * :
1707:          >
1709:    ]};
      
1712: Factor:
1714:    [
1714:       | pPlus :
1716:          @Primary
1718:          @RequireInt
1720:       | pMinus :
1722:          @Primary
1724:          @RequireInt
1726:          .tNegateInt
1728:       | * :
1735:          @Primary
1737:    ];
      
1738: Primary:
1740:    [
1740:       | pIntLit :
1742:          .tPushIntLit   oEmitInt( TOKEN_VALUE )
1749:          oTypeSPush( IntegerType )
      
1755:       | '(' :
1757:          @Expr
1759:          ')'
      
1761:       | pStrLit :
1763:          oStringAllocLit     % store, put addr on value stack
1764:          .tPushAddr  oEmitInt( oValueTop )  oValuePop
               % TO DO: do we need to create a type with the literal's length?
1772:          oTypeSPush( StringType )
      
1778:       | pIdent :
1780:          Node decl
1780:          Node theType
1780:          decl = oScopeFindRequire
      
1785:          [ oNodeType( decl )
1792:             | nFunc :
1793:                [
1793:                   | '(' :
1795:                      {  @Expr
      
                              % TO DO: match type against param
                              % TO DO: push the expression onto the call stack e.g. iPush...
                              %  Meanwhile for now we are broken, leaving the value on the runtime value stack
1797:                         oTypeSPop
      
1798:                         [
1798:                           | ')' : >
1802:                           | ',' :
1804:                         ]
1812:                      }
1814:                   | * :
1819:                ]
1819:                .tCall  @EmitValue( decl )
1828:                oTypeSPush( oNodeGet( decl, qType ) )
      
1841:             | nConst :
1843:                theType = oNodeGet( decl, qType )
1856:                oTypeSPush( theType )
1862:                [ oTypeSNodeType
1864:                   | nIntegerType, nBooleanType :
1865:                      .tPushIntLit @EmitValue( decl )
1874:                   | * :
1881:                      #eNotImplemented
1883:                ]
      
1883:             | nGlobalVar :
1885:                theType = oNodeGet( decl, qType )
1898:                oTypeSPush( theType )
1904:                [ oTypeSNodeType
1906:                   | nIntegerType :
1907:                      .tPushIntVar @EmitValue( decl )
1916:                   | nBooleanType :
1918:                      .tPushBoolVar @EmitValue( decl )
1927:                   | nCharType, nStringType, nFileType :
1929:                      #eNotImplemented
1931:                   | nPointerType :
1933:                      .tPushPtrVar @EmitValue( decl )
1942:                      [
1942:                         | '^' :             % dereferenced
1944:                            oTypeSPop
1945:                            oTypeSPush( oNodeGet( theType, qBaseType ) )
1958:                            @LValue
1960:                            @FetchVar
1962:                         | * :               % just ptr value alone
1967:                      ]
1967:                   | * :                     % compound type
1982:                      .tPushAddr @EmitValue( decl )    % addr of start of var
1991:                      @LValue                % get final addr
1993:                      @FetchVar              % get final value
1995:                ]
      
1995:             | * :
2004:                #eNotValue
2006:                oTypeSPush( IntegerType )
2012:          ]
      
2012:       | '^' :        % ^var
2014:          pIdent
      
2016:          Node decl
2016:          Node theType
2016:          decl = oScopeFindRequire
2021:          theType = oNodeGet( decl, qType )
      
2034:          [ oNodeType( decl )
2041:             | nGlobalVar :
2042:                .tPushAddr @EmitValue( decl )
2051:                @LValue     % ptr value to expr stack
      
2053:                Node ptrType
2053:                ptrType = @PointerTypeTo( theType )
2064:                oTypeSPush( ptrType )
      
2070:             | nLocalVar, nParam : #eNotImplemented
2074:                oTypeSPush( IntegerType )
2080:             | * :
2089:                #eNotVar
2091:                oTypeSPush( IntegerType )
2097:          ]
      
2097:       | * :
2110:          #eNotValue
2112:          oTypeSPush( IntegerType )
2118:    ];
      
      
      % Addr of start of var is on expr stack; type is on type stack.
      % Replace expr stack with value of var.
      % (In the case of compound vars, this remains as the addr of the var).
      
2119: FetchVar:
2121:    [ oTypeSNodeType
2123:       | nIntegerType :   .tFetchInt
2126:       | nBooleanType :   .tFetchBool
2130:       | nCharType, nStringType, nFileType : #eNotImplemented
2134:       | nPointerType :   .tFetchPtr
2138:       | * :              % compound type; leave as addr
2153:    ];
      
      
      % Addr of start of var is already on run stack, and type is on type stack.
      % Read subscripts, etc, to get final addr on run stack, and final type
      % on type stack.
      
2154: LValue:
2156:    {[
2156:       | '[' :       @ArraySubscripts
2160:       | '.' :       #eNotImplemented
2164:       | '^' :       @PointerDeref
2168:       | * :         >
2179:    ]};
      
2182: ArraySubscripts:
2184:    [ oTypeSNodeType
2186:       | nArrayType :
2187:       | * :       #eNotArray
2194:    ]
2194:    {
2194:       [ oTypeSNodeType
2196:          | nArrayType :
2197:          | * :    #eTooManySubscripts
2204:       ]
      
            % low subscript of this dimension
2204:       int low
2204:       low = @OrdinalLow( oNodeGet( oTypeSTop, qIndexType ) )
      
            % replace type stack with next dimension, or OF type
2221:       Node baseType
2221:       baseType = oNodeGet( oTypeSTop, qBaseType )
2233:       oTypeSPop
2234:       oTypeSPush( baseType )
      
2240:       @Expr
2242:       @RequireIntPop
            % adjust for low subscript
2244:       [ equal_zero( low )
2251:          | false :
2252:             .tPushIntLit oEmitInt( low ) .tSubtractInt
2262:          | * :
2267:       ]
      
            % multiply by element size
2267:       int size
2267:       size = oNodeGetInt( baseType, qSize )
2280:       [ equal( size, 1 )
2290:          | false :
2291:             .tPushIntLit oEmitInt( size ) .tMultiplyInt
2301:          | * :
2306:       ]
      
            % update start address
2306:       .tAddInt
2308:       [
2308:          | ']' :  >
2312:          | ',' :
2314:       ]
2322:    };
      
      % ptr deref on left side, i.e. BEFORE addr of ptr var is on stack,
      %                              AFTER addr of thing pointed to is on stack
2325: PointerDeref:
2327:    [ oTypeSNodeType
2329:       | nPointerType :
2330:       | * :       #eNotPointer
2337:    ]
2337:    .tFetchPtr           % now addr on stack is addr of what we're pointing to
      
2339:    Node theType
2339:    theType = oTypeSTop
2344:    oTypeSPop
2345:    oTypeSPush( oNodeGet( theType, qBaseType ) )
2359:    ;
      
      
      % ------------------------------ Statements -----------------------------
      
2359: Statement:
2361:    [
2361:       | pWriteln :     @WritelnStmt
2365:       | pWrite :       @WriteStmt
2369:       | pReadln :      @ReadlnStmt
2373:       | pRead :        @ReadStmt
2377:       | pIf :          @IfStmt
2381:       | pWhile :       @WhileStmt
2385:       | pFor :         @ForStmt
2389:       | pRepeat :      @RepeatStmt
2393:       | pExit :        @ExitStmt
2397:       | pCycle :       @CycleStmt
2401:       | pBegin :       @BeginStmt
2405:       | pIdent :       @AssignOrCallStmt
2409:       | * :            % null statement : don't accept any tokens
2436:    ];
      
      
2437: AssignOrCallStmt:         % *** Call doesn't work yet ***
2439:    Node decl
2439:    decl = oScopeFindRequire
2444:    [ oNodeType( decl )    % can parse without semantic info
2451:       | nProc :           %    but this is easier
2452:          [
2452:             | '(' :
2454:                {  @Expr oTypSPop  % ignore type for now
2457:                   [
2457:                     | ')' : >
2461:                     | ',' :
2463:                   ]
2471:                }
2473:             | * :
2478:          ]
2478:          .tCall  @EmitValue( decl )
      
2487:       | nGlobalVar :
2489:          .tPushAddr @EmitValue( decl )
2498:          oTypeSPush( oNodeGet( decl, qType ) )
2511:          @LValue        % handle subscripts, if any
2513:          ':=' 
2515:          @Expr
2517:          @MatchTypes
2519:          [ oTypeSNodeType
2521:             | nIntegerType :            .tAssignInt
2524:             | nBooleanType :            .tAssignBool
2528:             | nCharType, nStringType, nFileType :   #eNotImplemented
      
                  % compound var assigns; addrs of src, dest on stack
2532:             | nPointerType :            .tAssignPtr
2536:             | * :
2551:                 int size
2551:                 size = oNodeGetInt( oTypeSTop, qSize )
2563:                 .tCopy  oEmitInt( size )    % multi-word copy
2571:          ]
2571:          oTypeSPop
      
2572:       | * :
2579:          #eBadStatement
2581:    ];
      
2582: IfStmt:
2584:    @Expr
2586:    @RequireBoolPop
2588:    pThen
2590:    .tJumpFalse
2592:    oPatchPushHere(patchIf)
2598:    .tSpace
2600:    @Statement
2602:    [
2602:       | pElse :
2604:          .tJump
2606:          oPatchPushHere(patchIf)
2612:          .tSpace
2614:          oPatchSwap(patchIf)
2620:          oPatchPopFwd(patchIf)
2626:          @Statement
2628:       | * :
2633:    ]
2633:    oPatchPopFwd(patchIf);
      
2640: ForStmt:
2642:    pIdent
      
2644:    Node decl
2644:    decl = oScopeFindRequire
2649:    [ oNodeType( decl )
2656:       | nGlobalVar :
2657:       | nLocalVar :    #eNotImplemented
2661:       | nParam :       #eNotImplemented
2665:       | * :            #eNotIntVar
2676:    ]
2676:    oTypeSPush( oNodeGet( decl, qType ) )
2689:    @RequireIntPop
2691:    .tPushAddr  @EmitValue( decl )
      
2700:    ':='
      
2702:    @Expr
2704:    @RequireIntPop
2706:    .tAssignInt
      
2708:    .tJump oPatchPushHere(patchLoop) .tSpace
2718:    oPatchPushHere(patchLoop)
2724:    oPatchSwap(patchLoop)
2730:    [
2730:       | pTo :
2732:          .tIncIntVar @EmitValue( decl )
2741:          oPatchPopFwd(patchLoop)
2747:          .tPushIntVar @EmitValue( decl )
2756:          @Expr
2758:          @RequireIntPop
2760:          .tGreaterInt
2762:          .tJumpTrue oPatchPushHere(patchLoop) .tSpace
2772:          oPatchSwap(patchLoop)
2778:       | pDownto :
2780:          .tDecIntVar @EmitValue( decl )
2789:          oPatchPopFwd(patchLoop)
2795:          .tPushIntVar @EmitValue( decl )
2804:          @Expr
2806:          @RequireIntPop
2808:          .tLessInt
2810:          .tJumpTrue oPatchPushHere(patchLoop) .tSpace
2820:          oPatchSwap(patchLoop)
2826:    ]
2834:    oCountPush(0)          % count 'exit' patches
2840:    pDo
2842:    @Statement
2844:    .tJump oPatchPopBack(patchLoop)
2852:    oPatchPopFwd(patchLoop)
2858:    @PatchExitsPop;
      
2861: RepeatStmt:
2863:    oPatchPushHere(patchLoop) % start of loop
2869:    oCountPush(0)          % count the 'exit' patches
2875:    @Statement
2877:    {[
2877:       | ';' :
2879:          @Statement
2881:       | pUntil :
2883:          @Expr
2885:          @RequireBoolPop
2887:          .tJumpFalse
2889:          oPatchPopBack(patchLoop)
2895:          @PatchExitsPop
2897:          >
2899:    ]};
      
2910: WhileStmt:
2912:    oPatchPushHere(patchLoop)    % start of loop
2918:    oCountPush(0)
2924:    @Expr
2926:    @RequireBoolPop
2928:    pDo
2930:    .tJumpFalse
2932:    oPatchPushHere(patchLoop)    % jump out
2938:    .tSpace
2940:    oPatchSwap(patchLoop)        % start on top
2946:    @Statement
2948:    .tJump
2950:    oPatchPopBack(patchLoop)
2956:    oPatchPopFwd(patchLoop)
2962:    @PatchExitsPop;
      
2965: CycleStmt:                     % NOTE, for repeat..until, skips test (??)
2967:    [ oPatchAnyEntries(patchLoop)
2974:       | true :
2975:          .tJump
2977:          oPatchDup(patchLoop)  % addr of start
2983:          oPatchPopBack(patchLoop)
2989:       | * :
2994:          #eNotInALoop
2996:    ];
      
2997: ExitStmt:
2999:    [ oPatchAnyEntries(patchLoop)
3006:       | true :
3007:          .tJump
3009:          oPatchPushHere(patchExit)
3015:          .tSpace
3017:          oCountInc
3018:       | * :
3023:          #eNotInALoop
3025:    ];
      
3026: BeginStmt:
3028:    @Statement
3030:    {[
3030:       | ';' :   @Statement
3034:       | pEnd :  >
3038:    ]};
      
3049: WritelnStmt:
3051:    @WriteStmt
3053:    .tPutCR;
      
3056: WriteStmt:
3058:    [
3058:       | '(' :
3060:          {
3060:             @Expr
3062:             [ oTypeSNodeType
3064:                | nIntegerType :             .tPutInt
3067:                | nBooleanType :             .tPutBool
3071:                | nStringType :              .tPutStr
3075:                | nCharType, nFileType :     #eNotImplemented
3079:                | nPointerType :             .tPutPtr
3083:                | * :                        #eNotAllowed
3100:             ]
3100:             oTypeSPop
3101:             [
3101:                | ')' : >
3105:                | ',' :
3107:             ]
3115:          }
3117:       | * :
3122:    ];
      
      
3123: ReadlnStmt:      % ***
3126:    ;
3126: ReadStmt:
3129:    ;
      
      % -------------------------------- Utilities -------------------------------
      
3129: PatchExitsPop:
3131:    {[ oCountIsZero
3133:       | false : oPatchPopFwd(patchExit)
3140:                 oCountDec
3141:       | * :     >
3148:    ]}
3150:    oCountPop;
      
      
      % Require that the top two types on the type stack are matching (ignoring subranges).
      % Pop one of them, leaving only one.
      %
3152: MatchTypes:
3154:    node_type nt
3154:    nt = oTypeSNodeType
3159:    oTypeSPop
3160:    [ equal_node_type( nt, oTypeSNodeType )
3169:       | false :
3170:          #eTypeMismatch
3172:       | * :
3177:    ];
      
      
      % Require that the top type on the type stack is integer (ignoring subranges).
      % Pop it.
      %
3178: RequireIntPop:
3180:    [ oTypeSNodeType
3182:       | nIntegerType :
3183:       | * :          #eNotInteger
3190:    ]
3190:    oTypeSPop;
      
3192: RequireInt:
3194:    [ oTypeSNodeType
3196:       | nIntegerType :
3197:       | * :          #eNotInteger
3204:    ];
      
3205: RequireBoolPop:
3207:    [ oTypeSNodeType
3209:       | nBooleanType :
3210:       | * :          #eNotBoolean
3217:    ]
3217:    oTypeSPop;
      
3219: RequireBool:
3221:    [ oTypeSNodeType
3223:       | nBooleanType :
3224:       | * :          #eNotBoolean
3231:    ];
      
      
      % Create and return a new nType of the given node_type, adding it to the type table.
      %
3232: newType( node_type nt, int size ) >> Node:
3234:   Node node
3234:   node = oNodeNew( nt )
3244:   oNodeSetInt( node, qSize, size )
3256:   oTypeAdd( node )
3262:   >> node
3266:   ;
      
      
      % Create and return a new nIdent of the given node_type, with the given ident id.
      % Does not add it to any scope.
      %
3266: newIdent( node_type nt, kind k, int id ) >> Node:
3268:   Node t
3268:   t = oNodeNew( nt )
3278:   oNodeSetKind( t, qKind, k )   % deprecated attribute
3290:   oNodeSetInt( t, qIdent, id )
3302:   >> t
3306:   ;
      
      
      % Return an nType representing a pointer to the given type.
      % (Creates a new type if necessary.)
      %
3306: PointerTypeTo( Node theType ) >> Node:
3308:    Node ptrType
3308:    ptrType = oNodeGet( theType, qPointerType )
3321:    [ oNodeNull( ptrType )
3328:       | true :
3329:          ptrType = oNodeNew( nPointerType )
3339:          oNodeSet( ptrType, qBaseType, theType )
3351:          oNodeSetInt( ptrType, qSize, 8 )
3363:          oTypeAdd( ptrType )
3369:          oNodeSet( theType, qPointerType, ptrType )
3381:       | * :
3386:    ]
3386:    >> ptrType;
      
      
      % Return the low value of an ordinal type
      %
3390: OrdinalLow( Node theType ) >> int:
3392:    [ oNodeType( theType )
3399:       | nIntegerType :  >> -2147483648
3403:       | nBooleanType :  >> 0
3408:       | nCharType :     >> 0
3413:       | nSubrangeType : >> oNodeGetInt( theType, qLow )
3425:       | * :             #eNotOrdinalType
3438:                         >> 0
3441:    ];
      
      
      
      % Emit the value in a declaration.
      % For a constant integer, this is the constant value.
      % For a global variable, this is the global address.
      % For a local variable, this is the local address relative to the call stack frame.
      %
3442: EmitValue( Node decl ):
3444:     oEmitInt( oNodeGetInt( decl, qValue ));
      
      
3458: installBuiltIns:
      
         % install built-in types
3460:    FileType = @newType( nFileType, 4 )
3474:    IntegerType = @newType( nIntegerType, 4 )
3488:    BooleanType = @newType( nBooleanType, 1 )
3502:    CharType = @newType( nCharType, 1 )
3516:    StringType = @newType( nStringType, 256 )    % string with default length 256
      
         % Declare those type identifiers.
         % SSL doesn't support strings, so need help from operations e.g. oIdAdd_File
      
3530:    Node t
      
3530:    t = @newIdent( nTypeDecl, kType, oIdAdd_File )
3546:    oNodeSet( t, qType, FileType )
3558:    oScopeDeclare( t )
      
3564:    t = @newIdent( nTypeDecl, kType, oIdAdd_Integer )
3580:    oNodeSet( t, qType, IntegerType )
3592:    oScopeDeclare( t )
      
3598:    t = @newIdent( nTypeDecl, kType, oIdAdd_Boolean )
3614:    oNodeSet( t, qType, BooleanType )
3626:    oScopeDeclare( t )
      
3632:    t = @newIdent( nTypeDecl, kType, oIdAdd_Char )
3648:    oNodeSet( t, qType, CharType )
3660:    oScopeDeclare( t )
      
3666:    t = @newIdent( nTypeDecl, kType, oIdAdd_String )
3682:    oNodeSet( t, qType, StringType )
3694:    oScopeDeclare( t )
      
         % Built-in constants
      
3700:    t = @newIdent( nConst, kConst, oIdAdd_True )
3716:    oNodeSet( t, qType, BooleanType )
3728:    oNodeSetInt( t, qValue, 1 )
3740:    oScopeDeclare( t )
      
3746:    t = @newIdent( nConst, kConst, oIdAdd_False )
3762:    oNodeSet( t, qType, BooleanType )
3774:    oNodeSetInt( t, qValue, 0 )
3786:    oScopeDeclare( t )
      
3793:    ;
      
3793: end
      
3793: 

Generated code:

   0: oGlobalSpace 7
   2: oLocalSpace 1
   4: oScopeBegin
   5: oGetAddrGlobal 1
   7: oPushResult
   8: oScopeCurrent
   9: oAssign
  10: oCall 3458
  12: oInput 26
  14: oInput 0
  16: oGetAddrLocal 1
  18: oPushResult
  19: oSetResult 5
  21: oPushResult
  22: oSetResult 1
  24: oPushResult
  25: LAST_ID
  26: oPushResult
  27: oCall 3266
  29: oPop 3
  31: oAssign
  32: oGetLocal 1
  34: oPushResult
  35: oScopeDeclare
  36: oPop 1
  38: oInputChoice 118
  40: oInput 0
  42: oGetAddrLocal 1
  44: oPushResult
  45: oSetResult 10
  47: oPushResult
  48: oSetResult 6
  50: oPushResult
  51: LAST_ID
  52: oPushResult
  53: oCall 3266
  55: oPop 3
  57: oAssign
  58: oGetLocal 1
  60: oPushResult
  61: oSetResult 6
  63: oPushResult
  64: oGetGlobal 2
  66: oPushResult
  67: oNodeSet
  68: oPop 3
  70: oGetLocal 1
  72: oPushResult
  73: oScopeDeclareAlloc
  74: oPop 1
  76: oInput 12
  78: oInput 0
  80: oGetAddrLocal 1
  82: oPushResult
  83: oSetResult 10
  85: oPushResult
  86: oSetResult 6
  88: oPushResult
  89: LAST_ID
  90: oPushResult
  91: oCall 3266
  93: oPop 3
  95: oAssign
  96: oGetLocal 1
  98: oPushResult
  99: oSetResult 6
 101: oPushResult
 102: oGetGlobal 2
 104: oPushResult
 105: oNodeSet
 106: oPop 3
 108: oGetLocal 1
 110: oPushResult
 111: oScopeDeclareAlloc
 112: oPop 1
 114: oInput 14
 116: oJumpForward 121
 118: Choice Lookup Table
          13     40
 121: oInput 4
 123: oSetResult 11
 125: oPushResult
 126: oCall 134
 128: oPop 1
 130: oInput 18
 132: oScopeEnd
 133: oReturn
 134: oLocalSpace 0
 136: oInputChoice 163
 138: oCall 521
 140: oJumpForward 180
 142: oCall 593
 144: oJumpForward 180
 146: oGetParam 1
 148: oPushResult
 149: oCall 652
 151: oPop 1
 153: oJumpForward 180
 155: oCall 183
 157: oJumpForward 180
 159: oCall 249
 161: oJumpForward 180
 163: Choice Lookup Table
          28    159
          27    155
          31    146
          30    142
          29    138
 174: oCall 2359
 176: oEmit 31
 178: oJumpForward 182
 180: oJumpBack 136
 182: oReturn
 183: oLocalSpace 1
 185: oInput 0
 187: oGetAddrLocal 1
 189: oPushResult
 190: oSetResult 6
 192: oPushResult
 193: oSetResult 2
 195: oPushResult
 196: LAST_ID
 197: oPushResult
 198: oCall 3266
 200: oPop 3
 202: oAssign
 203: oScopeBegin
 204: oCall 336
 206: oGetLocal 1
 208: oPushResult
 209: oSetResult 9
 211: oPushResult
 212: oScopeCurrent
 213: oPushResult
 214: oNodeSet
 215: oPop 3
 217: oScopeEnd
 218: oGetLocal 1
 220: oPushResult
 221: oScopeDeclare
 222: oPop 1
 224: oInput 4
 226: oScopeBegin
 227: oSetResult 12
 229: oPushResult
 230: oCall 134
 232: oPop 1
 234: oGetLocal 1
 236: oPushResult
 237: oSetResult 10
 239: oPushResult
 240: oScopeCurrent
 241: oPushResult
 242: oNodeSet
 243: oPop 3
 245: oScopeEnd
 246: oInput 4
 248: oReturn
 249: oLocalSpace 2
 251: oInput 0
 253: oGetAddrLocal 1
 255: oPushResult
 256: oSetResult 7
 258: oPushResult
 259: oSetResult 3
 261: oPushResult
 262: LAST_ID
 263: oPushResult
 264: oCall 3266
 266: oPop 3
 268: oAssign
 269: oScopeBegin
 270: oCall 336
 272: oGetLocal 1
 274: oPushResult
 275: oSetResult 9
 277: oPushResult
 278: oScopeCurrent
 279: oPushResult
 280: oNodeSet
 281: oPop 3
 283: oScopeEnd
 284: oGetLocal 1
 286: oPushResult
 287: oScopeDeclare
 288: oPop 1
 290: oInput 11
 292: oGetAddrLocal 2
 294: oPushResult
 295: oCall 793
 297: oPop 1
 299: oGetLocal 1
 301: oPushResult
 302: oSetResult 6
 304: oPushResult
 305: oGetLocal 2
 307: oPushResult
 308: oNodeSet
 309: oPop 3
 311: oInput 4
 313: oScopeBegin
 314: oSetResult 12
 316: oPushResult
 317: oCall 134
 319: oPop 1
 321: oGetLocal 1
 323: oPushResult
 324: oSetResult 10
 326: oPushResult
 327: oScopeCurrent
 328: oPushResult
 329: oNodeSet
 330: oPop 3
 332: oScopeEnd
 333: oInput 4
 335: oReturn
 336: oLocalSpace 5
 338: oInputChoice 517
 340: oGetAddrLocal 1
 342: oPushResult
 343: oNodeVecNew
 344: oAssign
 345: oGetAddrLocal 3
 347: oPushResult
 348: oSetResult 0
 350: oAssign
 351: oInputChoice 361
 353: oGetAddrLocal 3
 355: oPushResult
 356: oSetResult 1
 358: oAssign
 359: oJumpForward 364
 361: Choice Lookup Table
          31    353
 364: oInput 0
 366: oGetAddrLocal 2
 368: oPushResult
 369: oSetResult 14
 371: oPushResult
 372: oSetResult 6
 374: oPushResult
 375: LAST_ID
 376: oPushResult
 377: oCall 3266
 379: oPop 3
 381: oAssign
 382: oGetLocal 2
 384: oPushResult
 385: oSetResult 11
 387: oPushResult
 388: oGetLocal 3
 390: oPushResult
 391: oNodeSetBoolean
 392: oPop 3
 394: oGetLocal 1
 396: oPushResult
 397: oGetLocal 2
 399: oPushResult
 400: oNodeVecAppend
 401: oPop 2
 403: oInputChoice 411
 405: oJumpForward 419
 407: oJumpForward 417
 409: oJumpForward 417
 411: Choice Lookup Table
          12    409
          11    405
 416: oEndChoice
 417: oJumpBack 364
 419: oGetAddrLocal 4
 421: oPushResult
 422: oCall 793
 424: oPop 1
 426: oGetAddrLocal 5
 428: oPushResult
 429: oSetResult 0
 431: oAssign
 432: oGetLocal 5
 434: oPushResult
 435: oGetLocal 1
 437: oPushResult
 438: oNodeVecSize
 439: oPop 1
 441: oPushResult
 442: equal
 443: oPop 2
 445: oChoice 486
 447: oGetAddrLocal 2
 449: oPushResult
 450: oGetLocal 1
 452: oPushResult
 453: oGetLocal 5
 455: oPushResult
 456: oNodeVecElement
 457: oPop 2
 459: oAssign
 460: oGetLocal 2
 462: oPushResult
 463: oSetResult 6
 465: oPushResult
 466: oGetLocal 4
 468: oPushResult
 469: oNodeSet
 470: oPop 3
 472: oGetLocal 2
 474: oPushResult
 475: oScopeDeclareAlloc
 476: oPop 1
 478: oGetAddrLocal 5
 480: oPushResult
 481: inc
 482: oPop 1
 484: oJumpForward 491
 486: Choice Lookup Table
           0    447
 489: oJumpForward 493
 491: oJumpBack 432
 493: oGetLocal 1
 495: oPushResult
 496: oNodeVecDelete
 497: oPop 1
 499: oInputChoice 507
 501: oJumpForward 515
 503: oJumpForward 513
 505: oJumpForward 513
 507: Choice Lookup Table
           4    505
          14    501
 512: oEndChoice
 513: oJumpBack 340
 515: oJumpForward 520
 517: Choice Lookup Table
          13    340
 520: oReturn
 521: oLocalSpace 2
 523: oInputChoice 585
 525: oGetAddrLocal 1
 527: oPushResult
 528: oSetResult 8
 530: oPushResult
 531: oSetResult 4
 533: oPushResult
 534: LAST_ID
 535: oPushResult
 536: oCall 3266
 538: oPop 3
 540: oAssign
 541: oInput 5
 543: oCall 1262
 545: oGetAddrLocal 2
 547: oPushResult
 548: oValueTop
 549: oAssign
 550: oValuePop
 551: oGetLocal 1
 553: oPushResult
 554: oSetResult 8
 556: oPushResult
 557: oGetLocal 2
 559: oPushResult
 560: oNodeSetInt
 561: oPop 3
 563: oGetLocal 1
 565: oPushResult
 566: oSetResult 6
 568: oPushResult
 569: oGetGlobal 3
 571: oPushResult
 572: oNodeSet
 573: oPop 3
 575: oGetLocal 1
 577: oPushResult
 578: oScopeDeclare
 579: oPop 1
 581: oInput 4
 583: oJumpForward 590
 585: Choice Lookup Table
           0    525
 588: oJumpForward 592
 590: oJumpBack 523
 592: oReturn
 593: oLocalSpace 2
 595: oInputChoice 644
 597: oGetAddrLocal 1
 599: oPushResult
 600: oSetResult 9
 602: oPushResult
 603: oSetResult 5
 605: oPushResult
 606: LAST_ID
 607: oPushResult
 608: oCall 3266
 610: oPop 3
 612: oAssign
 613: oInput 5
 615: oGetAddrLocal 2
 617: oPushResult
 618: oCall 793
 620: oPop 1
 622: oGetLocal 1
 624: oPushResult
 625: oSetResult 6
 627: oPushResult
 628: oGetLocal 2
 630: oPushResult
 631: oNodeSet
 632: oPop 3
 634: oGetLocal 1
 636: oPushResult
 637: oScopeDeclare
 638: oPop 1
 640: oInput 4
 642: oJumpForward 649
 644: Choice Lookup Table
           0    597
 647: oJumpForward 651
 649: oJumpBack 595
 651: oReturn
 652: oLocalSpace 4
 654: oInputChoice 785
 656: oGetAddrLocal 1
 658: oPushResult
 659: oNodeVecNew
 660: oAssign
 661: oGetAddrLocal 2
 663: oPushResult
 664: oGetParam 1
 666: oPushResult
 667: oSetResult 6
 669: oPushResult
 670: LAST_ID
 671: oPushResult
 672: oCall 3266
 674: oPop 3
 676: oAssign
 677: oGetLocal 1
 679: oPushResult
 680: oGetLocal 2
 682: oPushResult
 683: oNodeVecAppend
 684: oPop 2
 686: oInputChoice 692
 688: oInput 0
 690: oJumpForward 697
 692: Choice Lookup Table
          12    688
 695: oJumpForward 699
 697: oJumpBack 661
 699: oInput 11
 701: oGetAddrLocal 3
 703: oPushResult
 704: oCall 793
 706: oPop 1
 708: oGetAddrLocal 4
 710: oPushResult
 711: oSetResult 0
 713: oAssign
 714: oGetLocal 4
 716: oPushResult
 717: oGetLocal 1
 719: oPushResult
 720: oNodeVecSize
 721: oPop 1
 723: oPushResult
 724: equal
 725: oPop 2
 727: oChoice 768
 729: oGetAddrLocal 2
 731: oPushResult
 732: oGetLocal 1
 734: oPushResult
 735: oGetLocal 4
 737: oPushResult
 738: oNodeVecElement
 739: oPop 2
 741: oAssign
 742: oGetLocal 2
 744: oPushResult
 745: oSetResult 6
 747: oPushResult
 748: oGetLocal 3
 750: oPushResult
 751: oNodeSet
 752: oPop 3
 754: oGetLocal 2
 756: oPushResult
 757: oScopeDeclareAlloc
 758: oPop 1
 760: oGetAddrLocal 4
 762: oPushResult
 763: inc
 764: oPop 1
 766: oJumpForward 773
 768: Choice Lookup Table
           0    729
 771: oJumpForward 775
 773: oJumpBack 714
 775: oGetLocal 1
 777: oPushResult
 778: oNodeVecDelete
 779: oPop 1
 781: oInput 4
 783: oJumpForward 790
 785: Choice Lookup Table
           0    656
 788: oJumpForward 792
 790: oJumpBack 654
 792: oReturn
 793: oLocalSpace 12
 795: oInputChoice 1244
 797: oGetAddrLocal 1
 799: oPushResult
 800: oScopeFindRequire
 801: oAssign
 802: oGetLocal 1
 804: oPushResult
 805: oNodeType
 806: oPop 1
 808: oChoice 825
 810: oGetParam 1
 812: oPushResult
 813: oGetLocal 1
 815: oPushResult
 816: oSetResult 6
 818: oPushResult
 819: oNodeGet
 820: oPop 2
 822: oAssign
 823: oJumpForward 836
 825: Choice Lookup Table
           9    810
 828: oError 2
 830: oGetParam 1
 832: oPushResult
 833: oGetGlobal 3
 835: oAssign
 836: oJumpForward 1261
 838: oInput 15
 840: oGetAddrLocal 2
 842: oPushResult
 843: oNodeVecNew
 844: oAssign
 845: oGetAddrLocal 3
 847: oPushResult
 848: oSetResult 23
 850: oPushResult
 851: oNodeNew
 852: oPop 1
 854: oAssign
 855: oGetLocal 3
 857: oPushResult
 858: oSetResult 14
 860: oPushResult
 861: oGetGlobal 3
 863: oPushResult
 864: oNodeSet
 865: oPop 3
 867: oCall 1262
 869: oGetLocal 3
 871: oPushResult
 872: oSetResult 16
 874: oPushResult
 875: oValueTop
 876: oPushResult
 877: oNodeSetInt
 878: oPop 3
 880: oValuePop
 881: oInput 19
 883: oCall 1262
 885: oGetLocal 3
 887: oPushResult
 888: oSetResult 17
 890: oPushResult
 891: oValueTop
 892: oPushResult
 893: oNodeSetInt
 894: oPop 3
 896: oValuePop
 897: oGetLocal 3
 899: oPushResult
 900: oSetResult 12
 902: oPushResult
 903: oSetResult 4
 905: oPushResult
 906: oNodeSetInt
 907: oPop 3
 909: oGetLocal 3
 911: oPushResult
 912: oTypeAdd
 913: oPop 1
 915: oGetAddrLocal 4
 917: oPushResult
 918: oSetResult 22
 920: oPushResult
 921: oNodeNew
 922: oPop 1
 924: oAssign
 925: oGetLocal 4
 927: oPushResult
 928: oSetResult 15
 930: oPushResult
 931: oGetLocal 3
 933: oPushResult
 934: oNodeSet
 935: oPop 3
 937: oGetLocal 2
 939: oPushResult
 940: oGetLocal 4
 942: oPushResult
 943: oNodeVecAppend
 944: oPop 2
 946: oInputChoice 954
 948: oJumpForward 962
 950: oJumpForward 960
 952: oJumpForward 960
 954: Choice Lookup Table
          12    952
          16    948
 959: oEndChoice
 960: oJumpBack 845
 962: oInput 37
 964: oGetAddrLocal 5
 966: oPushResult
 967: oCall 793
 969: oPop 1
 971: oGetAddrLocal 6
 973: oPushResult
 974: oGetLocal 2
 976: oPushResult
 977: oNodeVecSize
 978: oPop 1
 980: oAssign
 981: oGetAddrLocal 6
 983: oPushResult
 984: dec
 985: oPop 1
 987: oGetAddrLocal 4
 989: oPushResult
 990: oGetLocal 2
 992: oPushResult
 993: oGetLocal 6
 995: oPushResult
 996: oNodeVecElement
 997: oPop 2
 999: oAssign
1000: oGetLocal 4
1002: oPushResult
1003: oSetResult 14
1005: oPushResult
1006: oGetLocal 5
1008: oPushResult
1009: oNodeSet
1010: oPop 3
1012: oGetAddrLocal 3
1014: oPushResult
1015: oGetLocal 4
1017: oPushResult
1018: oSetResult 15
1020: oPushResult
1021: oNodeGet
1022: oPop 2
1024: oAssign
1025: oGetAddrLocal 9
1027: oPushResult
1028: oGetLocal 3
1030: oPushResult
1031: oSetResult 17
1033: oPushResult
1034: oNodeGetInt
1035: oPop 2
1037: oPushResult
1038: oGetLocal 3
1040: oPushResult
1041: oSetResult 16
1043: oPushResult
1044: oNodeGetInt
1045: oPop 2
1047: oPushResult
1048: subtract
1049: oPop 2
1051: oAssign
1052: oGetAddrLocal 9
1054: oPushResult
1055: inc
1056: oPop 1
1058: oGetLocal 4
1060: oPushResult
1061: oSetResult 12
1063: oPushResult
1064: oGetLocal 9
1066: oPushResult
1067: oGetLocal 5
1069: oPushResult
1070: oSetResult 12
1072: oPushResult
1073: oNodeGetInt
1074: oPop 2
1076: oPushResult
1077: multiply
1078: oPop 2
1080: oPushResult
1081: oNodeSetInt
1082: oPop 3
1084: oGetLocal 4
1086: oPushResult
1087: oTypeAdd
1088: oPop 1
1090: oGetAddrLocal 5
1092: oPushResult
1093: oGetLocal 4
1095: oAssign
1096: oGetLocal 6
1098: oPushResult
1099: equal_zero
1100: oPop 1
1102: oChoice 1108
1104: oJumpForward 1113
1106: oJumpForward 1111
1108: Choice Lookup Table
           1   1104
1111: oJumpBack 981
1113: oGetParam 1
1115: oPushResult
1116: oGetLocal 2
1118: oPushResult
1119: oSetResult 0
1121: oPushResult
1122: oNodeVecElement
1123: oPop 2
1125: oAssign
1126: oGetLocal 2
1128: oPushResult
1129: oNodeVecDelete
1130: oPop 1
1132: oJumpForward 1261
1134: oGetAddrLocal 10
1136: oPushResult
1137: oCall 793
1139: oPop 1
1141: oGetParam 1
1143: oPushResult
1144: oGetLocal 10
1146: oPushResult
1147: oCall 3306
1149: oPop 1
1151: oAssign
1152: oJumpForward 1261
1154: oGetParam 1
1156: oPushResult
1157: oSetResult 24
1159: oPushResult
1160: oNodeNew
1161: oPop 1
1163: oAssign
1164: oScopeBegin
1165: oSetResult 13
1167: oPushResult
1168: oCall 652
1170: oPop 1
1172: oGetAddrLocal 11
1174: oPushResult
1175: oScopeCurrent
1176: oPushResult
1177: oSetResult 3
1179: oPushResult
1180: oNodeGetInt
1181: oPop 2
1183: oAssign
1184: oGetLocal 11
1186: oPushResult
1187: equal_zero
1188: oPop 1
1190: oChoice 1196
1192: oError 16
1194: oJumpForward 1199
1196: Choice Lookup Table
           1   1192
1199: oInput 33
1201: oGetFromParam 1
1203: oPushResult
1204: oSetResult 18
1206: oPushResult
1207: oScopeCurrent
1208: oPushResult
1209: oNodeSet
1210: oPop 3
1212: oGetFromParam 1
1214: oPushResult
1215: oSetResult 12
1217: oPushResult
1218: oGetLocal 11
1220: oPushResult
1221: oNodeSetInt
1222: oPop 3
1224: oScopeEnd
1225: oGetFromParam 1
1227: oPushResult
1228: oTypeAdd
1229: oPop 1
1231: oJumpForward 1261
1233: oInput 37
1235: oGetAddrLocal 10
1237: oPushResult
1238: oCall 793
1240: oPop 1
1242: oJumpForward 1261
1244: Choice Lookup Table
          36   1233
          35   1154
          17   1134
          34    838
           0    797
1255: oCall 1262
1257: oInput 19
1259: oCall 1262
1261: oReturn
1262: oLocalSpace 1
1264: oInputChoice 1319
1266: TOKEN_VALUE
1267: oPushResult
1268: oValuePush
1269: oPop 1
1271: oJumpForward 1327
1273: oGetAddrLocal 1
1275: oPushResult
1276: oScopeFindRequire
1277: oAssign
1278: oGetLocal 1
1280: oPushResult
1281: oNodeType
1282: oPop 1
1284: oChoice 1301
1286: oGetLocal 1
1288: oPushResult
1289: oSetResult 8
1291: oPushResult
1292: oNodeGetInt
1293: oPop 2
1295: oPushResult
1296: oValuePush
1297: oPop 1
1299: oJumpForward 1312
1301: Choice Lookup Table
           8   1286
1304: oError 1
1306: oSetResult 0
1308: oPushResult
1309: oValuePush
1310: oPop 1
1312: oJumpForward 1327
1314: oCall 1262
1316: oValueNegate
1317: oJumpForward 1327
1319: Choice Lookup Table
          23   1314
           0   1273
           1   1266
1326: oEndChoice
1327: oReturn
1328: oLocalSpace 0
1330: oCall 1574
1332: oInputChoice 1556
1334: oCall 1574
1336: oCall 3152
1338: oTypeSNodeType
1339: oChoice 1353
1341: oEmit 22
1343: oJumpForward 1366
1345: oEmit 28
1347: oJumpForward 1366
1349: oError 13
1351: oJumpForward 1366
1353: Choice Lookup Table
          20   1349
          19   1349
          21   1345
          18   1341
          17   1341
1364: oError 14
1366: oTypeSPop
1367: oGetGlobal 4
1369: oPushResult
1370: oTypeSPush
1371: oPop 1
1373: oJumpForward 1571
1375: oCall 1574
1377: oCall 3152
1379: oTypeSNodeType
1380: oChoice 1394
1382: oEmit 23
1384: oJumpForward 1407
1386: oEmit 29
1388: oJumpForward 1407
1390: oError 13
1392: oJumpForward 1407
1394: Choice Lookup Table
          20   1390
          19   1390
          21   1386
          18   1382
          17   1382
1405: oError 14
1407: oTypeSPop
1408: oGetGlobal 4
1410: oPushResult
1411: oTypeSPush
1412: oPop 1
1414: oJumpForward 1571
1416: oCall 1574
1418: oCall 3152
1420: oTypeSNodeType
1421: oChoice 1431
1423: oEmit 25
1425: oJumpForward 1442
1427: oError 13
1429: oJumpForward 1442
1431: Choice Lookup Table
          20   1427
          19   1427
          18   1423
          17   1423
1440: oError 14
1442: oTypeSPop
1443: oGetGlobal 4
1445: oPushResult
1446: oTypeSPush
1447: oPop 1
1449: oJumpForward 1571
1451: oCall 1574
1453: oCall 3152
1455: oTypeSNodeType
1456: oChoice 1466
1458: oEmit 24
1460: oJumpForward 1477
1462: oError 13
1464: oJumpForward 1477
1466: Choice Lookup Table
          20   1462
          19   1462
          18   1458
          17   1458
1475: oError 14
1477: oTypeSPop
1478: oGetGlobal 4
1480: oPushResult
1481: oTypeSPush
1482: oPop 1
1484: oJumpForward 1571
1486: oCall 1574
1488: oCall 3152
1490: oTypeSNodeType
1491: oChoice 1501
1493: oEmit 27
1495: oJumpForward 1512
1497: oError 13
1499: oJumpForward 1512
1501: Choice Lookup Table
          20   1497
          19   1497
          18   1493
          17   1493
1510: oError 14
1512: oTypeSPop
1513: oGetGlobal 4
1515: oPushResult
1516: oTypeSPush
1517: oPop 1
1519: oJumpForward 1571
1521: oCall 1574
1523: oCall 3152
1525: oTypeSNodeType
1526: oChoice 1536
1528: oEmit 26
1530: oJumpForward 1547
1532: oError 13
1534: oJumpForward 1547
1536: Choice Lookup Table
          20   1532
          19   1532
          18   1528
          17   1528
1545: oError 14
1547: oTypeSPop
1548: oGetGlobal 4
1550: oPushResult
1551: oTypeSPush
1552: oPop 1
1554: oJumpForward 1571
1556: Choice Lookup Table
          10   1521
           9   1486
           8   1451
           7   1416
           6   1375
           5   1334
1569: oJumpForward 1573
1571: oJumpBack 1332
1573: oReturn
1574: oLocalSpace 0
1576: oCall 1598
1578: oInputChoice 1590
1580: oCall 3205
1582: oCall 1598
1584: oCall 3219
1586: oEmit 21
1588: oJumpForward 1595
1590: Choice Lookup Table
          52   1580
1593: oJumpForward 1597
1595: oJumpBack 1578
1597: oReturn
1598: oLocalSpace 0
1600: oCall 1622
1602: oInputChoice 1614
1604: oCall 3205
1606: oCall 1622
1608: oCall 3219
1610: oEmit 20
1612: oJumpForward 1619
1614: Choice Lookup Table
          51   1604
1617: oJumpForward 1621
1619: oJumpBack 1602
1621: oReturn
1622: oLocalSpace 0
1624: oInputChoice 1634
1626: oCall 1640
1628: oCall 3219
1630: oEmit 19
1632: oJumpForward 1639
1634: Choice Lookup Table
          53   1626
1637: oCall 1640
1639: oReturn
1640: oLocalSpace 0
1642: oCall 1676
1644: oInputChoice 1666
1646: oCall 3178
1648: oCall 1676
1650: oCall 3192
1652: oEmit 16
1654: oJumpForward 1673
1656: oCall 3178
1658: oCall 1676
1660: oCall 3192
1662: oEmit 17
1664: oJumpForward 1673
1666: Choice Lookup Table
          23   1656
          22   1646
1671: oJumpForward 1675
1673: oJumpBack 1644
1675: oReturn
1676: oLocalSpace 0
1678: oCall 1712
1680: oInputChoice 1702
1682: oCall 3178
1684: oCall 1712
1686: oCall 3192
1688: oEmit 14
1690: oJumpForward 1709
1692: oCall 3178
1694: oCall 1712
1696: oCall 3192
1698: oEmit 15
1700: oJumpForward 1709
1702: Choice Lookup Table
          21   1692
          20   1682
1707: oJumpForward 1711
1709: oJumpBack 1680
1711: oReturn
1712: oLocalSpace 0
1714: oInputChoice 1730
1716: oCall 1738
1718: oCall 3192
1720: oJumpForward 1737
1722: oCall 1738
1724: oCall 3192
1726: oEmit 18
1728: oJumpForward 1737
1730: Choice Lookup Table
          23   1722
          22   1716
1735: oCall 1738
1737: oReturn
1738: oLocalSpace 5
1740: oInputChoice 2099
1742: oEmit 7
1744: TOKEN_VALUE
1745: oPushResult
1746: oEmitInt
1747: oPop 1
1749: oGetGlobal 3
1751: oPushResult
1752: oTypeSPush
1753: oPop 1
1755: oJumpForward 2118
1757: oCall 1328
1759: oInput 14
1761: oJumpForward 2118
1763: oStringAllocLit
1764: oEmit 3
1766: oValueTop
1767: oPushResult
1768: oEmitInt
1769: oPop 1
1771: oValuePop
1772: oGetGlobal 6
1774: oPushResult
1775: oTypeSPush
1776: oPop 1
1778: oJumpForward 2118
1780: oGetAddrLocal 1
1782: oPushResult
1783: oScopeFindRequire
1784: oAssign
1785: oGetLocal 1
1787: oPushResult
1788: oNodeType
1789: oPop 1
1791: oChoice 1997
1793: oInputChoice 1816
1795: oCall 1328
1797: oTypeSPop
1798: oInputChoice 1806
1800: oJumpForward 1814
1802: oJumpForward 1812
1804: oJumpForward 1812
1806: Choice Lookup Table
          12   1804
          14   1800
1811: oEndChoice
1812: oJumpBack 1795
1814: oJumpForward 1819
1816: Choice Lookup Table
          13   1795
1819: oEmit 30
1821: oGetLocal 1
1823: oPushResult
1824: oCall 3442
1826: oPop 1
1828: oGetLocal 1
1830: oPushResult
1831: oSetResult 6
1833: oPushResult
1834: oNodeGet
1835: oPop 2
1837: oPushResult
1838: oTypeSPush
1839: oPop 1
1841: oJumpForward 2012
1843: oGetAddrLocal 2
1845: oPushResult
1846: oGetLocal 1
1848: oPushResult
1849: oSetResult 6
1851: oPushResult
1852: oNodeGet
1853: oPop 2
1855: oAssign
1856: oGetLocal 2
1858: oPushResult
1859: oTypeSPush
1860: oPop 1
1862: oTypeSNodeType
1863: oChoice 1876
1865: oEmit 7
1867: oGetLocal 1
1869: oPushResult
1870: oCall 3442
1872: oPop 1
1874: oJumpForward 1883
1876: Choice Lookup Table
          18   1865
          17   1865
1881: oError 13
1883: oJumpForward 2012
1885: oGetAddrLocal 2
1887: oPushResult
1888: oGetLocal 1
1890: oPushResult
1891: oSetResult 6
1893: oPushResult
1894: oNodeGet
1895: oPop 2
1897: oAssign
1898: oGetLocal 2
1900: oPushResult
1901: oTypeSPush
1902: oPop 1
1904: oTypeSNodeType
1905: oChoice 1969
1907: oEmit 0
1909: oGetLocal 1
1911: oPushResult
1912: oCall 3442
1914: oPop 1
1916: oJumpForward 1995
1918: oEmit 1
1920: oGetLocal 1
1922: oPushResult
1923: oCall 3442
1925: oPop 1
1927: oJumpForward 1995
1929: oError 13
1931: oJumpForward 1995
1933: oEmit 2
1935: oGetLocal 1
1937: oPushResult
1938: oCall 3442
1940: oPop 1
1942: oInputChoice 1964
1944: oTypeSPop
1945: oGetLocal 2
1947: oPushResult
1948: oSetResult 14
1950: oPushResult
1951: oNodeGet
1952: oPop 2
1954: oPushResult
1955: oTypeSPush
1956: oPop 1
1958: oCall 2154
1960: oCall 2119
1962: oJumpForward 1967
1964: Choice Lookup Table
          17   1944
1967: oJumpForward 1995
1969: Choice Lookup Table
          21   1933
          16   1929
          20   1929
          19   1929
          18   1918
          17   1907
1982: oEmit 3
1984: oGetLocal 1
1986: oPushResult
1987: oCall 3442
1989: oPop 1
1991: oCall 2154
1993: oCall 2119
1995: oJumpForward 2012
1997: Choice Lookup Table
          11   1885
           8   1843
           7   1793
2004: oError 6
2006: oGetGlobal 3
2008: oPushResult
2009: oTypeSPush
2010: oPop 1
2012: oJumpForward 2118
2014: oInput 0
2016: oGetAddrLocal 1
2018: oPushResult
2019: oScopeFindRequire
2020: oAssign
2021: oGetAddrLocal 2
2023: oPushResult
2024: oGetLocal 1
2026: oPushResult
2027: oSetResult 6
2029: oPushResult
2030: oNodeGet
2031: oPop 2
2033: oAssign
2034: oGetLocal 1
2036: oPushResult
2037: oNodeType
2038: oPop 1
2040: oChoice 2082
2042: oEmit 3
2044: oGetLocal 1
2046: oPushResult
2047: oCall 3442
2049: oPop 1
2051: oCall 2154
2053: oGetAddrLocal 5
2055: oPushResult
2056: oGetLocal 2
2058: oPushResult
2059: oCall 3306
2061: oPop 1
2063: oAssign
2064: oGetLocal 5
2066: oPushResult
2067: oTypeSPush
2068: oPop 1
2070: oJumpForward 2097
2072: oError 13
2074: oGetGlobal 3
2076: oPushResult
2077: oTypeSPush
2078: oPop 1
2080: oJumpForward 2097
2082: Choice Lookup Table
          14   2072
          12   2072
          11   2042
2089: oError 4
2091: oGetGlobal 3
2093: oPushResult
2094: oTypeSPush
2095: oPop 1
2097: oJumpForward 2118
2099: Choice Lookup Table
          17   2014
           0   1780
           2   1763
          13   1757
           1   1742
2110: oError 6
2112: oGetGlobal 3
2114: oPushResult
2115: oTypeSPush
2116: oPop 1
2118: oReturn
2119: oLocalSpace 0
2121: oTypeSNodeType
2122: oChoice 2140
2124: oEmit 4
2126: oJumpForward 2153
2128: oEmit 5
2130: oJumpForward 2153
2132: oError 13
2134: oJumpForward 2153
2136: oEmit 6
2138: oJumpForward 2153
2140: Choice Lookup Table
          21   2136
          16   2132
          20   2132
          19   2132
          18   2128
          17   2124
2153: oReturn
2154: oLocalSpace 0
2156: oInputChoice 2170
2158: oCall 2182
2160: oJumpForward 2179
2162: oError 13
2164: oJumpForward 2179
2166: oCall 2325
2168: oJumpForward 2179
2170: Choice Lookup Table
          17   2166
          18   2162
          15   2158
2177: oJumpForward 2181
2179: oJumpBack 2156
2181: oReturn
2182: oLocalSpace 3
2184: oTypeSNodeType
2185: oChoice 2189
2187: oJumpForward 2194
2189: Choice Lookup Table
          22   2187
2192: oError 10
2194: oTypeSNodeType
2195: oChoice 2199
2197: oJumpForward 2204
2199: Choice Lookup Table
          22   2197
2202: oError 11
2204: oGetAddrLocal 1
2206: oPushResult
2207: oTypeSTop
2208: oPushResult
2209: oSetResult 15
2211: oPushResult
2212: oNodeGet
2213: oPop 2
2215: oPushResult
2216: oCall 3390
2218: oPop 1
2220: oAssign
2221: oGetAddrLocal 2
2223: oPushResult
2224: oTypeSTop
2225: oPushResult
2226: oSetResult 14
2228: oPushResult
2229: oNodeGet
2230: oPop 2
2232: oAssign
2233: oTypeSPop
2234: oGetLocal 2
2236: oPushResult
2237: oTypeSPush
2238: oPop 1
2240: oCall 1328
2242: oCall 3178
2244: oGetLocal 1
2246: oPushResult
2247: equal_zero
2248: oPop 1
2250: oChoice 2264
2252: oEmit 7
2254: oGetLocal 1
2256: oPushResult
2257: oEmitInt
2258: oPop 1
2260: oEmit 17
2262: oJumpForward 2267
2264: Choice Lookup Table
           0   2252
2267: oGetAddrLocal 3
2269: oPushResult
2270: oGetLocal 2
2272: oPushResult
2273: oSetResult 12
2275: oPushResult
2276: oNodeGetInt
2277: oPop 2
2279: oAssign
2280: oGetLocal 3
2282: oPushResult
2283: oSetResult 1
2285: oPushResult
2286: equal
2287: oPop 2
2289: oChoice 2303
2291: oEmit 7
2293: oGetLocal 3
2295: oPushResult
2296: oEmitInt
2297: oPop 1
2299: oEmit 14
2301: oJumpForward 2306
2303: Choice Lookup Table
           0   2291
2306: oEmit 16
2308: oInputChoice 2316
2310: oJumpForward 2324
2312: oJumpForward 2322
2314: oJumpForward 2322
2316: Choice Lookup Table
          12   2314
          16   2310
2321: oEndChoice
2322: oJumpBack 2194
2324: oReturn
2325: oLocalSpace 1
2327: oTypeSNodeType
2328: oChoice 2332
2330: oJumpForward 2337
2332: Choice Lookup Table
          21   2330
2335: oError 9
2337: oEmit 6
2339: oGetAddrLocal 1
2341: oPushResult
2342: oTypeSTop
2343: oAssign
2344: oTypeSPop
2345: oGetLocal 1
2347: oPushResult
2348: oSetResult 14
2350: oPushResult
2351: oNodeGet
2352: oPop 2
2354: oPushResult
2355: oTypeSPush
2356: oPop 1
2358: oReturn
2359: oLocalSpace 0
2361: oInputChoice 2411
2363: oCall 3049
2365: oJumpForward 2436
2367: oCall 3056
2369: oJumpForward 2436
2371: oCall 3123
2373: oJumpForward 2436
2375: oCall 3126
2377: oJumpForward 2436
2379: oCall 2582
2381: oJumpForward 2436
2383: oCall 2910
2385: oJumpForward 2436
2387: oCall 2640
2389: oJumpForward 2436
2391: oCall 2861
2393: oJumpForward 2436
2395: oCall 2997
2397: oJumpForward 2436
2399: oCall 2965
2401: oJumpForward 2436
2403: oCall 3026
2405: oJumpForward 2436
2407: oCall 2437
2409: oJumpForward 2436
2411: Choice Lookup Table
           0   2407
          32   2403
          48   2399
          49   2395
          46   2391
          41   2387
          45   2383
          38   2379
          57   2375
          56   2371
          55   2367
          54   2363
2436: oReturn
2437: oLocalSpace 2
2439: oGetAddrLocal 1
2441: oPushResult
2442: oScopeFindRequire
2443: oAssign
2444: oGetLocal 1
2446: oPushResult
2447: oNodeType
2448: oPop 1
2450: oChoice 2574
2452: oInputChoice 2475
2454: oCall 1328
2456: oTypSPop
2457: oInputChoice 2465
2459: oJumpForward 2473
2461: oJumpForward 2471
2463: oJumpForward 2471
2465: Choice Lookup Table
          12   2463
          14   2459
2470: oEndChoice
2471: oJumpBack 2454
2473: oJumpForward 2478
2475: Choice Lookup Table
          13   2454
2478: oEmit 30
2480: oGetLocal 1
2482: oPushResult
2483: oCall 3442
2485: oPop 1
2487: oJumpForward 2581
2489: oEmit 3
2491: oGetLocal 1
2493: oPushResult
2494: oCall 3442
2496: oPop 1
2498: oGetLocal 1
2500: oPushResult
2501: oSetResult 6
2503: oPushResult
2504: oNodeGet
2505: oPop 2
2507: oPushResult
2508: oTypeSPush
2509: oPop 1
2511: oCall 2154
2513: oInput 3
2515: oCall 1328
2517: oCall 3152
2519: oTypeSNodeType
2520: oChoice 2538
2522: oEmit 8
2524: oJumpForward 2571
2526: oEmit 9
2528: oJumpForward 2571
2530: oError 13
2532: oJumpForward 2571
2534: oEmit 10
2536: oJumpForward 2571
2538: Choice Lookup Table
          21   2534
          16   2530
          20   2530
          19   2530
          18   2526
          17   2522
2551: oGetAddrLocal 2
2553: oPushResult
2554: oTypeSTop
2555: oPushResult
2556: oSetResult 12
2558: oPushResult
2559: oNodeGetInt
2560: oPop 2
2562: oAssign
2563: oEmit 11
2565: oGetLocal 2
2567: oPushResult
2568: oEmitInt
2569: oPop 1
2571: oTypeSPop
2572: oJumpForward 2581
2574: Choice Lookup Table
          11   2489
           6   2452
2579: oError 0
2581: oReturn
2582: oLocalSpace 0
2584: oCall 1328
2586: oCall 3205
2588: oInput 39
2590: oEmit 34
2592: oSetResult 2
2594: oPushResult
2595: oPatchPushHere
2596: oPop 1
2598: oEmit 40
2600: oCall 2359
2602: oInputChoice 2630
2604: oEmit 32
2606: oSetResult 2
2608: oPushResult
2609: oPatchPushHere
2610: oPop 1
2612: oEmit 40
2614: oSetResult 2
2616: oPushResult
2617: oPatchSwap
2618: oPop 1
2620: oSetResult 2
2622: oPushResult
2623: oPatchPopFwd
2624: oPop 1
2626: oCall 2359
2628: oJumpForward 2633
2630: Choice Lookup Table
          40   2604
2633: oSetResult 2
2635: oPushResult
2636: oPatchPopFwd
2637: oPop 1
2639: oReturn
2640: oLocalSpace 1
2642: oInput 0
2644: oGetAddrLocal 1
2646: oPushResult
2647: oScopeFindRequire
2648: oAssign
2649: oGetLocal 1
2651: oPushResult
2652: oNodeType
2653: oPop 1
2655: oChoice 2667
2657: oJumpForward 2676
2659: oError 13
2661: oJumpForward 2676
2663: oError 13
2665: oJumpForward 2676
2667: Choice Lookup Table
          14   2663
          12   2659
          11   2657
2674: oError 5
2676: oGetLocal 1
2678: oPushResult
2679: oSetResult 6
2681: oPushResult
2682: oNodeGet
2683: oPop 2
2685: oPushResult
2686: oTypeSPush
2687: oPop 1
2689: oCall 3178
2691: oEmit 3
2693: oGetLocal 1
2695: oPushResult
2696: oCall 3442
2698: oPop 1
2700: oInput 3
2702: oCall 1328
2704: oCall 3178
2706: oEmit 8
2708: oEmit 32
2710: oSetResult 0
2712: oPushResult
2713: oPatchPushHere
2714: oPop 1
2716: oEmit 40
2718: oSetResult 0
2720: oPushResult
2721: oPatchPushHere
2722: oPop 1
2724: oSetResult 0
2726: oPushResult
2727: oPatchSwap
2728: oPop 1
2730: oInputChoice 2828
2732: oEmit 12
2734: oGetLocal 1
2736: oPushResult
2737: oCall 3442
2739: oPop 1
2741: oSetResult 0
2743: oPushResult
2744: oPatchPopFwd
2745: oPop 1
2747: oEmit 0
2749: oGetLocal 1
2751: oPushResult
2752: oCall 3442
2754: oPop 1
2756: oCall 1328
2758: oCall 3178
2760: oEmit 24
2762: oEmit 33
2764: oSetResult 0
2766: oPushResult
2767: oPatchPushHere
2768: oPop 1
2770: oEmit 40
2772: oSetResult 0
2774: oPushResult
2775: oPatchSwap
2776: oPop 1
2778: oJumpForward 2834
2780: oEmit 13
2782: oGetLocal 1
2784: oPushResult
2785: oCall 3442
2787: oPop 1
2789: oSetResult 0
2791: oPushResult
2792: oPatchPopFwd
2793: oPop 1
2795: oEmit 0
2797: oGetLocal 1
2799: oPushResult
2800: oCall 3442
2802: oPop 1
2804: oCall 1328
2806: oCall 3178
2808: oEmit 25
2810: oEmit 33
2812: oSetResult 0
2814: oPushResult
2815: oPatchPushHere
2816: oPop 1
2818: oEmit 40
2820: oSetResult 0
2822: oPushResult
2823: oPatchSwap
2824: oPop 1
2826: oJumpForward 2834
2828: Choice Lookup Table
          43   2780
          42   2732
2833: oEndChoice
2834: oSetResult 0
2836: oPushResult
2837: oCountPush
2838: oPop 1
2840: oInput 44
2842: oCall 2359
2844: oEmit 32
2846: oSetResult 0
2848: oPushResult
2849: oPatchPopBack
2850: oPop 1
2852: oSetResult 0
2854: oPushResult
2855: oPatchPopFwd
2856: oPop 1
2858: oCall 3129
2860: oReturn
2861: oLocalSpace 0
2863: oSetResult 0
2865: oPushResult
2866: oPatchPushHere
2867: oPop 1
2869: oSetResult 0
2871: oPushResult
2872: oCountPush
2873: oPop 1
2875: oCall 2359
2877: oInputChoice 2901
2879: oCall 2359
2881: oJumpForward 2907
2883: oCall 1328
2885: oCall 3205
2887: oEmit 34
2889: oSetResult 0
2891: oPushResult
2892: oPatchPopBack
2893: oPop 1
2895: oCall 3129
2897: oJumpForward 2909
2899: oJumpForward 2907
2901: Choice Lookup Table
          47   2883
           4   2879
2906: oEndChoice
2907: oJumpBack 2877
2909: oReturn
2910: oLocalSpace 0
2912: oSetResult 0
2914: oPushResult
2915: oPatchPushHere
2916: oPop 1
2918: oSetResult 0
2920: oPushResult
2921: oCountPush
2922: oPop 1
2924: oCall 1328
2926: oCall 3205
2928: oInput 44
2930: oEmit 34
2932: oSetResult 0
2934: oPushResult
2935: oPatchPushHere
2936: oPop 1
2938: oEmit 40
2940: oSetResult 0
2942: oPushResult
2943: oPatchSwap
2944: oPop 1
2946: oCall 2359
2948: oEmit 32
2950: oSetResult 0
2952: oPushResult
2953: oPatchPopBack
2954: oPop 1
2956: oSetResult 0
2958: oPushResult
2959: oPatchPopFwd
2960: oPop 1
2962: oCall 3129
2964: oReturn
2965: oLocalSpace 0
2967: oSetResult 0
2969: oPushResult
2970: oPatchAnyEntries
2971: oPop 1
2973: oChoice 2991
2975: oEmit 32
2977: oSetResult 0
2979: oPushResult
2980: oPatchDup
2981: oPop 1
2983: oSetResult 0
2985: oPushResult
2986: oPatchPopBack
2987: oPop 1
2989: oJumpForward 2996
2991: Choice Lookup Table
           1   2975
2994: oError 15
2996: oReturn
2997: oLocalSpace 0
2999: oSetResult 0
3001: oPushResult
3002: oPatchAnyEntries
3003: oPop 1
3005: oChoice 3020
3007: oEmit 32
3009: oSetResult 1
3011: oPushResult
3012: oPatchPushHere
3013: oPop 1
3015: oEmit 40
3017: oCountInc
3018: oJumpForward 3025
3020: Choice Lookup Table
           1   3007
3023: oError 15
3025: oReturn
3026: oLocalSpace 0
3028: oCall 2359
3030: oInputChoice 3040
3032: oCall 2359
3034: oJumpForward 3046
3036: oJumpForward 3048
3038: oJumpForward 3046
3040: Choice Lookup Table
          33   3036
           4   3032
3045: oEndChoice
3046: oJumpBack 3030
3048: oReturn
3049: oLocalSpace 0
3051: oCall 3056
3053: oEmit 39
3055: oReturn
3056: oLocalSpace 0
3058: oInputChoice 3119
3060: oCall 1328
3062: oTypeSNodeType
3063: oChoice 3085
3065: oEmit 35
3067: oJumpForward 3100
3069: oEmit 36
3071: oJumpForward 3100
3073: oEmit 37
3075: oJumpForward 3100
3077: oError 13
3079: oJumpForward 3100
3081: oEmit 38
3083: oJumpForward 3100
3085: Choice Lookup Table
          21   3081
          16   3077
          19   3077
          20   3073
          18   3069
          17   3065
3098: oError 14
3100: oTypeSPop
3101: oInputChoice 3109
3103: oJumpForward 3117
3105: oJumpForward 3115
3107: oJumpForward 3115
3109: Choice Lookup Table
          12   3107
          14   3103
3114: oEndChoice
3115: oJumpBack 3060
3117: oJumpForward 3122
3119: Choice Lookup Table
          13   3060
3122: oReturn
3123: oLocalSpace 0
3125: oReturn
3126: oLocalSpace 0
3128: oReturn
3129: oLocalSpace 0
3131: oCountIsZero
3132: oChoice 3143
3134: oSetResult 1
3136: oPushResult
3137: oPatchPopFwd
3138: oPop 1
3140: oCountDec
3141: oJumpForward 3148
3143: Choice Lookup Table
           0   3134
3146: oJumpForward 3150
3148: oJumpBack 3131
3150: oCountPop
3151: oReturn
3152: oLocalSpace 1
3154: oGetAddrLocal 1
3156: oPushResult
3157: oTypeSNodeType
3158: oAssign
3159: oTypeSPop
3160: oGetLocal 1
3162: oPushResult
3163: oTypeSNodeType
3164: oPushResult
3165: equal_node_type
3166: oPop 2
3168: oChoice 3174
3170: oError 12
3172: oJumpForward 3177
3174: Choice Lookup Table
           0   3170
3177: oReturn
3178: oLocalSpace 0
3180: oTypeSNodeType
3181: oChoice 3185
3183: oJumpForward 3190
3185: Choice Lookup Table
          17   3183
3188: oError 7
3190: oTypeSPop
3191: oReturn
3192: oLocalSpace 0
3194: oTypeSNodeType
3195: oChoice 3199
3197: oJumpForward 3204
3199: Choice Lookup Table
          17   3197
3202: oError 7
3204: oReturn
3205: oLocalSpace 0
3207: oTypeSNodeType
3208: oChoice 3212
3210: oJumpForward 3217
3212: Choice Lookup Table
          18   3210
3215: oError 8
3217: oTypeSPop
3218: oReturn
3219: oLocalSpace 0
3221: oTypeSNodeType
3222: oChoice 3226
3224: oJumpForward 3231
3226: Choice Lookup Table
          18   3224
3229: oError 8
3231: oReturn
3232: oLocalSpace 1
3234: oGetAddrLocal 1
3236: oPushResult
3237: oGetParam 2
3239: oPushResult
3240: oNodeNew
3241: oPop 1
3243: oAssign
3244: oGetLocal 1
3246: oPushResult
3247: oSetResult 12
3249: oPushResult
3250: oGetParam 1
3252: oPushResult
3253: oNodeSetInt
3254: oPop 3
3256: oGetLocal 1
3258: oPushResult
3259: oTypeAdd
3260: oPop 1
3262: oGetLocal 1
3264: oReturn
3265: oReturn
3266: oLocalSpace 1
3268: oGetAddrLocal 1
3270: oPushResult
3271: oGetParam 3
3273: oPushResult
3274: oNodeNew
3275: oPop 1
3277: oAssign
3278: oGetLocal 1
3280: oPushResult
3281: oSetResult 5
3283: oPushResult
3284: oGetParam 2
3286: oPushResult
3287: oNodeSetKind
3288: oPop 3
3290: oGetLocal 1
3292: oPushResult
3293: oSetResult 4
3295: oPushResult
3296: oGetParam 1
3298: oPushResult
3299: oNodeSetInt
3300: oPop 3
3302: oGetLocal 1
3304: oReturn
3305: oReturn
3306: oLocalSpace 1
3308: oGetAddrLocal 1
3310: oPushResult
3311: oGetParam 1
3313: oPushResult
3314: oSetResult 13
3316: oPushResult
3317: oNodeGet
3318: oPop 2
3320: oAssign
3321: oGetLocal 1
3323: oPushResult
3324: oNodeNull
3325: oPop 1
3327: oChoice 3383
3329: oGetAddrLocal 1
3331: oPushResult
3332: oSetResult 21
3334: oPushResult
3335: oNodeNew
3336: oPop 1
3338: oAssign
3339: oGetLocal 1
3341: oPushResult
3342: oSetResult 14
3344: oPushResult
3345: oGetParam 1
3347: oPushResult
3348: oNodeSet
3349: oPop 3
3351: oGetLocal 1
3353: oPushResult
3354: oSetResult 12
3356: oPushResult
3357: oSetResult 8
3359: oPushResult
3360: oNodeSetInt
3361: oPop 3
3363: oGetLocal 1
3365: oPushResult
3366: oTypeAdd
3367: oPop 1
3369: oGetParam 1
3371: oPushResult
3372: oSetResult 13
3374: oPushResult
3375: oGetLocal 1
3377: oPushResult
3378: oNodeSet
3379: oPop 3
3381: oJumpForward 3386
3383: Choice Lookup Table
           1   3329
3386: oGetLocal 1
3388: oReturn
3389: oReturn
3390: oLocalSpace 0
3392: oGetParam 1
3394: oPushResult
3395: oNodeType
3396: oPop 1
3398: oChoice 3427
3400: oSetResult 0
3402: oReturn
3403: oJumpForward 3441
3405: oSetResult 0
3407: oReturn
3408: oJumpForward 3441
3410: oSetResult 0
3412: oReturn
3413: oJumpForward 3441
3415: oGetParam 1
3417: oPushResult
3418: oSetResult 16
3420: oPushResult
3421: oNodeGetInt
3422: oPop 2
3424: oReturn
3425: oJumpForward 3441
3427: Choice Lookup Table
          23   3415
          19   3410
          18   3405
          17   3400
3436: oError 3
3438: oSetResult 0
3440: oReturn
3441: oReturn
3442: oLocalSpace 0
3444: oGetParam 1
3446: oPushResult
3447: oSetResult 8
3449: oPushResult
3450: oNodeGetInt
3451: oPop 2
3453: oPushResult
3454: oEmitInt
3455: oPop 1
3457: oReturn
3458: oLocalSpace 1
3460: oGetAddrGlobal 2
3462: oPushResult
3463: oSetResult 16
3465: oPushResult
3466: oSetResult 4
3468: oPushResult
3469: oCall 3232
3471: oPop 2
3473: oAssign
3474: oGetAddrGlobal 3
3476: oPushResult
3477: oSetResult 17
3479: oPushResult
3480: oSetResult 4
3482: oPushResult
3483: oCall 3232
3485: oPop 2
3487: oAssign
3488: oGetAddrGlobal 4
3490: oPushResult
3491: oSetResult 18
3493: oPushResult
3494: oSetResult 1
3496: oPushResult
3497: oCall 3232
3499: oPop 2
3501: oAssign
3502: oGetAddrGlobal 5
3504: oPushResult
3505: oSetResult 19
3507: oPushResult
3508: oSetResult 1
3510: oPushResult
3511: oCall 3232
3513: oPop 2
3515: oAssign
3516: oGetAddrGlobal 6
3518: oPushResult
3519: oSetResult 20
3521: oPushResult
3522: oSetResult 256
3524: oPushResult
3525: oCall 3232
3527: oPop 2
3529: oAssign
3530: oGetAddrLocal 1
3532: oPushResult
3533: oSetResult 9
3535: oPushResult
3536: oSetResult 5
3538: oPushResult
3539: oIdAdd_File
3540: oPushResult
3541: oCall 3266
3543: oPop 3
3545: oAssign
3546: oGetLocal 1
3548: oPushResult
3549: oSetResult 6
3551: oPushResult
3552: oGetGlobal 2
3554: oPushResult
3555: oNodeSet
3556: oPop 3
3558: oGetLocal 1
3560: oPushResult
3561: oScopeDeclare
3562: oPop 1
3564: oGetAddrLocal 1
3566: oPushResult
3567: oSetResult 9
3569: oPushResult
3570: oSetResult 5
3572: oPushResult
3573: oIdAdd_Integer
3574: oPushResult
3575: oCall 3266
3577: oPop 3
3579: oAssign
3580: oGetLocal 1
3582: oPushResult
3583: oSetResult 6
3585: oPushResult
3586: oGetGlobal 3
3588: oPushResult
3589: oNodeSet
3590: oPop 3
3592: oGetLocal 1
3594: oPushResult
3595: oScopeDeclare
3596: oPop 1
3598: oGetAddrLocal 1
3600: oPushResult
3601: oSetResult 9
3603: oPushResult
3604: oSetResult 5
3606: oPushResult
3607: oIdAdd_Boolean
3608: oPushResult
3609: oCall 3266
3611: oPop 3
3613: oAssign
3614: oGetLocal 1
3616: oPushResult
3617: oSetResult 6
3619: oPushResult
3620: oGetGlobal 4
3622: oPushResult
3623: oNodeSet
3624: oPop 3
3626: oGetLocal 1
3628: oPushResult
3629: oScopeDeclare
3630: oPop 1
3632: oGetAddrLocal 1
3634: oPushResult
3635: oSetResult 9
3637: oPushResult
3638: oSetResult 5
3640: oPushResult
3641: oIdAdd_Char
3642: oPushResult
3643: oCall 3266
3645: oPop 3
3647: oAssign
3648: oGetLocal 1
3650: oPushResult
3651: oSetResult 6
3653: oPushResult
3654: oGetGlobal 5
3656: oPushResult
3657: oNodeSet
3658: oPop 3
3660: oGetLocal 1
3662: oPushResult
3663: oScopeDeclare
3664: oPop 1
3666: oGetAddrLocal 1
3668: oPushResult
3669: oSetResult 9
3671: oPushResult
3672: oSetResult 5
3674: oPushResult
3675: oIdAdd_String
3676: oPushResult
3677: oCall 3266
3679: oPop 3
3681: oAssign
3682: oGetLocal 1
3684: oPushResult
3685: oSetResult 6
3687: oPushResult
3688: oGetGlobal 6
3690: oPushResult
3691: oNodeSet
3692: oPop 3
3694: oGetLocal 1
3696: oPushResult
3697: oScopeDeclare
3698: oPop 1
3700: oGetAddrLocal 1
3702: oPushResult
3703: oSetResult 8
3705: oPushResult
3706: oSetResult 4
3708: oPushResult
3709: oIdAdd_True
3710: oPushResult
3711: oCall 3266
3713: oPop 3
3715: oAssign
3716: oGetLocal 1
3718: oPushResult
3719: oSetResult 6
3721: oPushResult
3722: oGetGlobal 4
3724: oPushResult
3725: oNodeSet
3726: oPop 3
3728: oGetLocal 1
3730: oPushResult
3731: oSetResult 8
3733: oPushResult
3734: oSetResult 1
3736: oPushResult
3737: oNodeSetInt
3738: oPop 3
3740: oGetLocal 1
3742: oPushResult
3743: oScopeDeclare
3744: oPop 1
3746: oGetAddrLocal 1
3748: oPushResult
3749: oSetResult 8
3751: oPushResult
3752: oSetResult 4
3754: oPushResult
3755: oIdAdd_False
3756: oPushResult
3757: oCall 3266
3759: oPop 3
3761: oAssign
3762: oGetLocal 1
3764: oPushResult
3765: oSetResult 6
3767: oPushResult
3768: oGetGlobal 4
3770: oPushResult
3771: oNodeSet
3772: oPop 3
3774: oGetLocal 1
3776: oPushResult
3777: oSetResult 8
3779: oPushResult
3780: oSetResult 0
3782: oPushResult
3783: oNodeSetInt
3784: oPop 3
3786: oGetLocal 1
3788: oPushResult
3789: oScopeDeclare
3790: oPop 1
3792: oReturn
