   2: title: 'Pascal Compiler 1.1.5 -- Jan 01 ''90';
         
      %
      %  Pascal.ssl
      %
      %  Pascal Compiler for the Amiga, by Steve Rice.
      %
      %  HISTORY
      %    11Sep89   First version, framework of parser.
      %    18Sep89   Added some semantic mechanisms.
      %    21Sep89   Added simple type references; expressions generate code.
      %    22Sep89   Allocate variable addresses as they're declared.
      %    24Sep89   Added arrays, pointers.
      %    27Sep89   Added for statement.
      %    23Oct89   Fixed for statement, so CYCLE goes to next step.
      %    01Jan90   Added string literals
      %    09Sep22   I have returned.  Migrate symbol table to schema, to ease development.
      %    01Oct22   Language: Switch from cycle/exit (Mac Pascal extension) to continue/break (Borland).
      %
      %  NOTES
      %    -  The 'value' of a var symbol is its allocated address.
      %    -  References to vars of intrinsic types, and pointer types,
      %       pushes the value of the var on the expr stack.  Referenecs to
      %       vars of compound types (arrays, records...) pushes the address
      %       on the expr stack.
      %    -  Just as there is only one type table entry for a given (named) type,
      %       there is only one type table entry for a pointer to a named type.
      %       When a pointer type is declared, a field in the TT entry of the
      %       type pointed to will be set to indicate the TT entry of the pointer
      %       to that type (0 means none defined yet).  When evaluating the
      %       expression @x, the type in that field in the entry for the type of x
      %       will be used (unless it's 0, in which case a new TT entry will be
      %       created).
      %
      %
      %  MISSING
      %
      %    - Consider non-ISO extensions.  e.g. 
      %      Dynamic arrays.  Objects.  But, perhaps stick to my old goal, standard Pascal.
      %
      %  PASCAL DOCS
      %      Here's some handy language material:
      %      https://www.freepascal.org/docs-html/ref/ref.html
      %      https://www.freepascal.org/docs-html/prog/prog.html
      %      https://en.wikipedia.org/wiki/Turbo_Pascal
      %      https://en.wikipedia.org/wiki/Pascal_(programming_language)#Standards
      %      http://www.standardpascaline.org/
      %
      
   2: input:
   2:    pIdent
   2:    pIntLit
   2:    pStrLit
   2:    pCharLit
   2:    pAssign       ':='
   2:    pSemiColon    ';'
   2:    pEqual        '='
   2:    pNotEqual     '<>'
   2:    pLess         '<'
   2:    pGreater      '>'
   2:    pLessEqual    '<='
   2:    pGreaterEqual '>='
   2:    pColon        ':'
   2:    pComma        ','
   2:    pLParen       '('
   2:    pRParen       ')'
   2:    pLSquare      '['
   2:    pRSquare      ']'
   2:    pCarat        '^'
   2:    pAt           '@'
   2:    pDot          '.'
   2:    pDotDot       '..'
   2:    pTimes        '*'
   2:    pDivide       '/'
   2:    pPlus         '+'
   2:    pMinus        '-'
   2:    pEof
   2:    pInvalid
      
      %  keywords  (built-in types 'integer', 'byte', 'char', etc, are not keywords,
      %             type constructors 'array', 'record', 'set' are keywords,
      %             pseudo-procedures 'writeln', 'readln' are keywords)
      %
      %             forward/external/name/cdecl appear in method modifiers, in fpc grammar.
      %             I'm making them keywords to simplify parsing, but could reconsider.
      
   2:    pProgram
   2:    pProcedure
   2:    pFunction
   2:    pConst
   2:    pType
   2:    pVar
   2:    pLabel
   2:    pBegin
   2:    pEnd
   2:    pArray
   2:    pRecord
   2:    pSet
   2:    pOf
   2:    pIf
   2:    pThen
   2:    pElse
   2:    pFor
   2:    pTo
   2:    pDownto
   2:    pDo
   2:    pWhile
   2:    pRepeat
   2:    pUntil
   2:    pContinue
   2:    pBreak
   2:    pCase
   2:    pOtherwise
   2:    pGoto
   2:    pAnd
   2:    pOr
   2:    pNot
   2:    pUses
   2:    pUnit
   2:    pInterface
   2:    pImplementation
   2:    pInitialization
   2:    pFinalization
   2:    pWriteln
   2:    pWrite
   2:    pReadln
   2:    pRead
      
   2:    pForward
   2:    pExternal
   2:    pName
   2:    pCdecl
   2:    ;
      
      
   2: output:
      
      %  Instructions for a stack machine (all vars are 32-bit integers)
      
   2:    tPushGlobalI      % <ptr> - push int value read from ptr
   2:    tPushGlobalB      % <ptr> - push byte value read from ptr
   2:    tPushGlobalP      % <ptr> - push ptr value read from ptr
   2:    tPushLocalI       % <offset> - push int value read from local var in current scope
   2:    tPushLocalB       % <offset> - push byte value read from local var in current scope
   2:    tPushLocalP       % <offset> - push ptr value read from local var in current scope
   2:    tPushParamI       % <offset> - push int value read from param in current scope
   2:    tPushParamB       % <offset> - push byte value read from param in current scope
   2:    tPushParamP       % <offset> - push ptr value read from param in current scope
   2:    tPushUpLocalI     % <uplevels> <offset> - push int value read from local var in a parent static scope
   2:    tPushUpLocalB     % <uplevels> <offset> - push byte value read from local var in a parent static scope
   2:    tPushUpLocalP     % <uplevels> <offset> - push ptr value read from local var in a parent static scope
   2:    tPushUpParamI     % <uplevels> <offset> - push int value read from param in a parent static scope
   2:    tPushUpParamB     % <uplevels> <offset> - push byte value read from param in a parent static scope
   2:    tPushUpParamP     % <uplevels> <offset> - push ptr value read from param in a parent static scope
   2:    tPushConstI       % <int> - push int value on stack (NOTE, used for BOOLEAN too)
   2:    tPushAddrGlobal   % <offset> - push ptr to global var (same as tPushConstP)
   2:    tPushAddrLocal    % <offset> - push ptr to local var
   2:    tPushAddrParam    % <offset> - push ptr to formal param (used by method to see its param)
   2:    tPushAddrActual   % <offset> - push ptr to actual param, in actuals space (used by caller)
   2:    tPushAddrUpLocal  % <uplevels> <offset> - push ptr to local var in a parent static scope
   2:    tPushAddrUpParam  % <uplevels> <offset> - push ptr to formal param in a parent static scope
   2:    tSwap             % swap the top two entries on the stack
   2:    tFetchI           % pop ptr from stack, and push int value it points to
   2:    tFetchB           %    "      "      "     "     byte  "   "    "
   2:    tFetchP           %    "      "      "     "     ptr   "   "    "   
   2:    tAssignI          % assign int value on top of stack to addr under it (pop both)
   2:    tAssignB          %   "    byte   "    "   "  "   "    "    "   "   "
   2:    tAssignP          %   "    ptr    "    "   "  "   "    "    "   "   "
   2:    tCopy             % <#bytes> - copy bytes.  tos=src, 2nd=dest (pop 2)
   2:    tCastBtoI         % zero-extend uint8_t to int32_t
   2:    tCastItoB         % truncate int32_t to uint8_t
   2:    tIncI             % increment int value on top of expr stack
   2:    tDecI             % decrement int value on top of expr stack
   2:    tMultI            % multiply top two integers (replacing with result)
   2:    tDivI
   2:    tAddPI            % add ptr (2nd value) and int (top value), resulting in a ptr
   2:    tAddI
   2:    tSubP
   2:    tSubPI
   2:    tSubI
   2:    tNegI             % top entry *= -1
   2:    tNot              % negate top boolean
   2:    tEqualB
   2:    tNotEqualB
   2:    tGreaterB         % B is uint8_t, so these are unsigned comparisons
   2:    tLessB
   2:    tGreaterEqualB
   2:    tLessEqualB
   2:    tEqualI           % top two entries equal? (pop 2, push 1) (true=1)
   2:    tNotEqualI        %    NOTE, these all work for booleans too, but I'm moving to tEqualB etc for those
   2:    tGreaterI         % 2nd entry greater than top entry? (pop 2, push answer)
   2:    tLessI  
   2:    tGreaterEqualI
   2:    tLessEqualI
   2:    tEqualP           % two two pointer values equal? (pop 2, push 1) (true=1)
   2:    tNotEqualP
   2:    tGreaterP
   2:    tLessP
   2:    tGreaterEqualP
   2:    tLessEqualP
   2:    tAllocActuals     % <#bytes> - make space on call stack for actual params (adjusting call stack sp)
   2:    tAllocActualsCdecl  % <#bytes> - starting a call to a cdecl method.  tcode still describes my own calling convention.
   2:    tFreeActuals      % <#bytes> - discard space on call stack allocated by tAllocActuals
   2:    tCall             % <label#>
   2:    tCallCdecl        % <label#> - call a method using native (C) calling convention. Only supported for extern labels.
   2:    tReturn
   2:    tEnter            % <#bytes> - start a stack frame on the call stack, reserving #bytes of local variable space
   2:    tJump             % <label#>
   2:    tJumpTrue         % <label#>  (pops top of stack, jumps if true)
   2:    tJumpFalse        % <label#>  (pops top of stack, jumps if false)
   2:    tJumpCaseB        % <label#>  pops uint8_t, jumps to case indicated by table at label (consisting of tCase, tCaseRange, tCaseEnd)
   2:    tJumpCaseI        % <label#>  pops integer, jumps to case indicated by table at label
   2:    tJumpCaseS        % <label#>  pops pointer to ShortString, jumps to case indicated by table at label
   2:    tCase             % <int> <label#>  - case table entry: if match int, goto label.  For tJumpCaseS, int is offset into global data.
   2:    tCaseRange        % <lowint> <highint> <label#>  - case table entry: if lowint <= value <= highint, goto label.  For tJumpCaseS, offsets into global.
   2:    tCaseEnd          % <label#> - end of case table.  Label points to no-match code (otherwise clause or end of statement).
   2:    tLabel            % <label#> - define label# at the current address
   2:    tLabelAlias       % <label#> <aliasToLabel#> - defines label to be an alias of another label
   2:    tLabelExtern      % <label#> <offsetToStrLit> - defines label to mean an extern symbol, whose name is in global data
   2:    tWriteI           % for writeln : write integer on tos, pop
   2:    tWriteBool        %  "     "    : write TRUE/FALSE, pop
   2:    tWriteChar        %  "     "    : write char, pop
   2:    tWriteShortStr    %  "     "    : write ShortString whose addr is on tos, pop
   2:    tWritePChar       %  "     "    : write a null-terminated string whose addr is on tos, pop
   2:    tWriteP           %  "     "    : write ptr var whose addr is on tos, pop
   2:    tWriteEnum        %  "     "    : write enum name.  Name table on tos, value under it, pop both
   2:    tWriteCR          %  "     "    : write cr
   2:    tFile             % <file#> - pascal source file id, for debugging.  I haven't decided yet how I will communicate the corresponding filename.
   2:    tLine             % <line#> - pascal source line number, for debugging
      
      %  Other:
      
   2:    tSpace            % emit a hole, to be patched later
   2:    ;
      
   2: error:
   2:    eBadStatement
   2:    eNotConst
   2:    eNotType
   2:    eNotOrdinalType
   2:    eNotVar
   2:    eNotIntVar
   2:    eNotValue
   2:    eNotInteger
   2:    eNotBoolean
   2:    eNotPointer
   2:    eNotArray
   2:    eNotRecord
   2:    eNotRecordField
   2:    eTooManySubscripts
   2:    eTypeMismatch
   2:    eMissingParameter
   2:    eNotImplemented
   2:    eNotAllowed
   2:    eNotInALoop
   2:    eRecordEmpty
   2:    eNotCurrentFunction
   2:    eAlreadyDefined
   2:    eOnlyOneVarCanBeInitialized
   2:    eExternalMethodCannotBeNested
   2:    eCantFindUnitFile
   2:    eInternalScopeMismatch
   2:    eEnumValueNotAscending
   2:    eUsedButNotDefined
   2:    eCantUsePredSuccOnEnumWithValueGaps
   2:    eCantDereference
   2:    ;
      
   2: include 'pascal_schema.ssl'
      
      % Generated automatically by schema
      
   2: type node_type:
   2: 	nINVALID
   2: 	Object
   2: 	nWorkspace
   2: 	nModule
   2: 	nProgram
   2: 	nUnit
   2: 	nUnitImpl
   2: 	nScope
   2: 	nDeclaration
   2: 	nIdent
   2: 	nUnitRef
   2: 	nMethod
   2: 	nProc
   2: 	nFunc
   2: 	nBuiltInFunc
   2: 	nBuiltInProc
   2: 	nConst
   2: 	nEnumValue
   2: 	nConstStr
   2: 	nTypeDecl
   2: 	nVar
   2: 	nGlobalVar
   2: 	nLocalVar
   2: 	nRecordField
   2: 	nParam
   2: 	nTypedConst
   2: 	nLabel
   2: 	nType
   2: 	nFileType
   2: 	nIntegerType
   2: 	nByteType
   2: 	nBooleanType
   2: 	nBooleanFlowType
   2: 	nCharType
   2: 	nPointerType
   2: 	nUniversalPointerType
   2: 	nArrayType
   2: 	nSubrangeType
   2: 	nRecordType
   2: 	nStrLitType
   2: 	nShortStringType
   2: 	nEnumType
   2: 	nSetType
   2: 	;
      
   2: type node_attribute:
   2: 	qINVALID
   2: 	qUnits
   2: 	qProgram
   2: 	qGlobalSize
   2: 	qIdent
   2: 	qUsedUnits
   2: 	qChildScope
   2: 	qMainRoutineScope
   2: 	qImpl
   2: 	qPublicScope
   2: 	qPrivateScope
   2: 	qInitLabel
   2: 	qFinalLabel
   2: 	qInitRoutineScope
   2: 	qLevel
   2: 	qDecls
   2: 	qExtends
   2: 	qSize
   2: 	qAllocMode
   2: 	qInitCode
   2: 	qParentScope
   2: 	qType
   2: 	qValue
   2: 	qParams
   2: 	qBodyDefined
   2: 	qExternal
   2: 	qExternalName
   2: 	qCdecl
   2: 	qUsed
   2: 	qOldParams
   2: 	qOldType
   2: 	qResultOffset
   2: 	qNameOffset
   2: 	qValueStr
   2: 	qInOut
   2: 	qDefined
   2: 	qPointerType
   2: 	qBaseType
   2: 	qIndexType
   2: 	qLow
   2: 	qHigh
   2: 	qScope
   2: 	qCapacity
   2: 	qNameTable
   2: 	qHasGap
   2: 	;
      
      
   2: type Node:     % A pointer to a node in the schema database (symbol database)
   2:    Null = 0
   2:    ;
      
   2: type NodeIter:   % An iterator over nodes in a list, in the schema database
   2:    NullIter = 0
   2:    ;
      
   2: type NodeVec:  % A pointer to a vector of Node.  See mechanism node_vec_mech
   2:    NullVec = 0
   2:    ;
      
   2: type boolean:
   2:    false    = 0
   2:    true     = 1;
      
      % intrinsic types & type constructs
      
   2: type typ:
   2:    tyNone     = 0    % in ptrTyp field of TT, means no ptr to type defined
   2:    tyInteger
   2:    tyBoolean
   2:    tyChar
   2:    tyString
   2:    tyFile            % tyInteger..tyFile are scalars (types on their own)
   2:    tyPointer         % following are type constructor classes...
   2:    tyArray           %   (they are not type#'s)
   2:    tyRecord
   2:    tyParams          % like record; a collection of proc/func params
   2:    tySet;
      
   2: type Label:
   2:    labelNull = 0;
      
      % An output code stream.
   2: type Code:
   2:    codeNull = 0
   2:    codeDefault = 1
   2:    ;
      
      % A string
   2: type String:
   2:    stringNull = 0
   2:    ;
      
      % allocation modes for oScopeBegin
   2: type AllocMode:
   2:    allocGlobal = 0  % allocate from global data
   2:    allocDown        % allocate down the stack
   2:    allocUp          % allocate up the stack
   2:    ;
      
      % Some general schema node operations.
      % node_type and node_attribute are defined in generated file pascal_schema.ssl included above.
      %
   2: mechanism node_mech:
   2:     oNodeNew (node_type) >> Node         % create new node
   2:     oNodeSet (Node, node_attribute, Node)   % set Node attribute of node
   2:     oNodeSetString (Node, node_attribute, String)
   2:     oNodeSetInt (Node, node_attribute, int) % set int attribute of node
   2:     oNodeSetBoolean (Node, node_attribute, boolean)
   2:     oNodeSetLabel( Node, node_attribute, Label )  % set Label attribute of node
   2:     oNodeSetCode( Node, node_attribute, Code )    % set Code attribute of node
   2:     oNodeAddLast( Node, node_attribute, Node value )  % append to a List attribute of node
   2:     oNodeGet (Node, node_attribute) >> Node    % get Node attribute of node
   2:     oNodeGetString (Node, node_attribute) >> String
   2:     oNodeGetInt (Node, node_attribute) >> int  % get int attribute of node
   2:     oNodeGetBoolean (Node, node_attribute) >> boolean  % get int attribute of node
   2:     oNodeGetLabel (Node, node_attribute) >> Label      % get Label attribute of node
   2:     oNodeGetCode (Node, node_attribute) >> Code        % get code stream attribute of node
   2:     oNodeNull (Node) >> boolean          % is node null?
   2:     oNodeFind (Node, node_attribute listAttr, node_attribute valueAttr, int value) >> Node  % find node with value in list
   2:     oNodeGetIter (Node, node_attribute) >> NodeIter   % get an iterator over nodes in a List attribute
   2:     oNodeGetIterLast (Node, node_attribute) >> NodeIter  % get an iterator over nodes in a List, starting at last
   2:     oNodeIterValue (NodeIter) >> Node             % the node that iter is referring to (NodeNull if no more nodes)
   2:     oNodeIterNext (inout NodeIter)                % advance iterator through list
   2:     oNodeIterPrev (inout NodeIter)                % advance iterator backwards through list
   2:     oNodeType (Node) >> node_type        % return node type of node
   2:     oNodeEqual (Node, Node) >> boolean   % compare two nodes for equality
                                               % (i.e. same node, not just same contents)
   2:     ;
      
      
      % Manipulate a temporary vector of Node
      %
   2: mechanism node_vec_mech:
   2:     oNodeVecNew >> NodeVec
   2:     oNodeVecDelete( NodeVec nv )
   2:     oNodeVecAppend( NodeVec nv, Node n )
   2:     oNodeVecSize( NodeVec nv ) >> int                % how many elements
   2:     oNodeVecElement( NodeVec nv, int idx ) >> Node   % element at index idx (0..size-1)
   2:     ;
      
      
      
   2: mechanism emit_mech:
   2:     oEmitInt( int )              % emit int into the generated code
   2:     oEmitLabel( Label )
   2:     oEmitCode( Code )            % append a code stream to the current code stream
   2:     Here >> int                  % current address in the generated code
                                       %   (only usable in the default code stream)
   2:     oPatch( int addr, int val )  % patch an int into address in the generated code
                                       %   (only usable in the default code stream)
   2:     ;
      
   2: mechanism math:
   2:     inc (inout int)
   2:     dec (inout int)
   2:     negate (int) >> int
   2:     add( int x, int y ) >> int
   2:     subtract( int x, int y ) >> int     % x - y
   2:     multiply( int x, int y ) >> int     % x * y
   2:     equal( int x, int y ) >> boolean
   2:     equal_zero (int) >> boolean
   2:     equal_node( Node, Node ) >> boolean
   2:     equal_string( String, String ) >> boolean
   2:     equal_node_type (node_type, node_type) >> boolean     % Want equal_<type> for every type
   2:     equal_label( Label, Label ) >> boolean
   2:     equal_code( Code, Code ) >> boolean
   2:     greater( int x, int y ) >> boolean
   2:     oMININT >> int    % the minimum 32-bit integer.
   2:     oMAXINT >> int    % the maximum 32-bit integer.
   2:     ;
      
   2: mechanism more_builtins:      % These should be built-in SSL operations
   2:     TOKEN_VALUE >> int        % value of just accepted token, e.g. IntLit token
   2:     LAST_ID >> int            % id number of last accepted identifier
   2:     ID_STRING( int id ) >> String       % text name of identifier with given id
   2:     CURRENT_STRLIT >> String            % text value of just-accepted string literal
   2:     ;
      
   2: mechanism workspace_mech:
   2:     oWorkspaceNew >> Node
   2:     ;
      
   2: mechanism scope_mech:
   2:     oScopeBegin( int level, AllocMode )  % create a new scope. Subsequent declarations will go here.
                                               %  level = static scope depth (0 = globals)
   2:     oScopeEnter( Node scope )            % enter an existing scope.
   2:     oScopeEnd                            % end current scope. Subsequent declarations will go to previous scope.
   2:     oScopeCurrent >> Node                % returns current scope
   2:     oScopeDeclare( Node decl )           % add declaration to current scope.
   2:     oScopeDeclareAlloc( Node decl )      % add declaration to current scope, and allocate space according to its type
   2:     oScopeAllocType( Node theType ) >> int   % allocate space for type in current scope, and return its address
   2:     oScopeAlloc( int size, int align ) >> int % allocate bytes, with given alignment in bytes 
   2:     oScopeFind >> Node                   % find declaration of last accepted identifier.  Returns Null if not found.
   2:     oScopeFindRequire >> Node            % find declaration of last accepted identifier.  Error if not found.
   2:     oScopeFindInCurrentScope >> Node     % find declaration of last accepted identifier, only within the current scope.  Null if not found.
   2:     oScopeFindRequireInScope( Node scope ) >> Node  % find decl of last accepted identifier, only within the given scope.  Error it not found.
   2:     ;
      
   2: mechanism type_mech:
   2:     oTypeAdd( Node node )     % add the given nType to the type table
   2:     ;
      
   2: mechanism type_stack_mech:
   2:     oTypeSPush( Node node )
   2:     oTypeSPop
   2:     oTypeSTop >> Node
   2:     oTypeSNodeType >> node_type          % node_type of the node on top of type stack, skipping subranges
   2:     ;
      
      
   2: mechanism id_mech:
          % gets/adds a predefined id to the scanner's id table, and returns the id code
   2:     oId_mysystem >> int
   2:     oId_ShortStringAppendShortString >> int
   2:     oId_ShortStringAppendChar >> int
   2:     oId_ShortStringCmp >> int
   2:     oId_File >> int
   2:     oId_Integer >> int
   2:     oId_Boolean >> int
   2:     oId_Char >> int
   2:     oId_Byte >> int
   2:     oId_Pointer >> int
   2:     oId_ShortString >> int
   2:     oId_True >> int
   2:     oId_False >> int
   2:     oId_Nil >> int
   2:     oId_Ord >> int
   2:     oId_Chr >> int
   2:     oId_Pred >> int
   2:     oId_Succ >> int
   2:     oChangeIntLitToLabelIdent    % change current token from pIntLit to pIdent "_label_<intlit>"
   2:     ;
      
      
      
   2: mechanism label_mech:
   2:    oLabelNew >> Label
   2:    ;
      
   2: mechanism code_mech:
   2:    oCodeNew >> Code         % create a new empty code stream
   2:    oCodePush( Code )        % change the current output code stream to the given one
   2:    oCodePop                 % restore the current code stream to the previous one
   2:    ;
      
   2: mechanism include_mech:
   2:    oIncludeUnitFile( int id ) >> boolean  % search for <unit>.pas and include it.
                                                % returns false if can't find.
   2:    oIncludeEnd              % stop including the current file
   2:    ;
      
      
   2: mechanism count :
   2:    oCountPush(int)          % start a new counter, with initial value
   2:    oCountInc
   2:    oCountDec
   2:    oCountIsZero >> boolean
   2:    oCountPop;
      
      
   2: mechanism value :              % value stack, to calc. const expr's
   2:    oValuePush(int)             % push an explicit int lit
   2:    oValuePushString(String)    % push string onto value stack
   2:    oValueTop >> int            % get top value on value stack
   2:    oValueTopString >> String
   2:    oValueSwap                  % swap top two
   2:    oValuePop
   2:    oValueCharToString          % convert top value from char to string
   2:    oValueNegate                % negate top numeric value
   2:    oValueEqual
   2:    oValueNotEqual
   2:    oValueLess
   2:    oValueGreater
   2:    oValueLessEqual
   2:    oValueGreaterEqual
   2:    oValueOr                    % boolean or
   2:    oValueAnd
   2:    oValueNot                   % boolean not
   2:    oValueAdd
   2:    oValueSub
   2:    oValueMult
   2:    oValueDiv
   2:    ;
      
   2: mechanism string :
   2:    oStringAllocLit( String ) >> int      % alloc global space for strlit, return address
   2:    oStringAllocShortStringLit( String ) >> int  % alloc global space for ShortString, return address
   2:    ;
      
      % track labels for the loop we're in, if any
   2: mechanism loop_mech:
   2:    oLoopPush( Label continueLabel, Label breakLabel )
   2:    oLoopContinueLabel >> Label
   2:    oLoopBreakLabel >> Label
   2:    oLoopPop
   2:    ;
      
      % for hacky debugging
   2: mechanism msg_mech:
   2:    oMsg( int num )             % print message "oMsg <num>"
   2:    oMsgTrace( int num )        % print message "oMsg <num>" followed by ssl traceback
   2:    oMsgNode( Node node )       % print node
   2:    oMsgNodeLong( Node node )   % print node with more detail
   2:    oMsgNodeVec( NodeVec vec )  % print node vec
   2:    ;
      
      
   2: rules
      
      % ----------------------------- Global Variables ----------------------------
      
   2: Node    workspace              % root of database
   2: Node    globalScope            % scope for globals in the current module
   2: Node    initScope              % scope for temporaries global var init,
                                     % and program main stmt / unit initialization stmts
      
   2: int     mysystemId               % id of identifier "mysystem"
      
      % built-in nTypes
   2: Node    FileType
   2: Node    IntegerType
   2: Node    BooleanType
   2: Node    BooleanFlowType
   2: Node    CharType
   2: Node    PCharType
   2: Node    ByteType
   2: Node    UniversalPointerType
   2: Node    StrLitType
   2: Node    ShortStringType
      
      % nBuiltInFunc
   2: Node    BuiltIn_Ord
   2: Node    BuiltIn_Chr
   2: Node    BuiltIn_Pred
   2: Node    BuiltIn_Succ
      
      % Declarations in unit mysystem that the compiler may refer to directly.
      
   2: Node    System_ShortStringAppendShortString
   2: Node    System_ShortStringAppendChar
   2: Node    System_ShortStringCmp
      
      
      % -------------------------- Forward Declarations -------------------------
      
   2: Block( node_type varNodeType, Label labelForBody );
   2: BlockDecls( node_type varNodeType );
   2: BlockStmt( Label labelForBody, Node varScope, boolean isMain );
   2: VarDecl( node_type varNodeType );
   2: newType( node_type nt, int size ) >> Node;
   2: newIdent( node_type nt, int id ) >> Node;
   2: EmitValue( Node decl );
   2: TypeRef( out Node theType );
   2: EnumTypeRef( out Node resultType );
   2: PointerTypeTo( Node theType ) >> Node;
   2: OrdinalLow( Node theType ) >> int;
   2: OrdinalHigh( Node theType ) >> int;
   2: AssignStmt( Node decl );
   2: BooleanExprControlFlow( out Label falseLabel );
   2: ExprAllowFlow( out Label falseLabel );
   2: BoolExprAllowFlow( out Label falseLabel );
   2: BoolTermAllowFlow( out Label falseLabel );
   2: BoolFactorAllowFlow( out Label falseLabel );
   2: ArithExprAllowFlow( out Label falseLabel );
   2: TermAllowFlow( out Label falseLabel );
   2: FactorAllowFlow( out Label falseLabel );
   2: PrimaryAllowFlow( out Label falseLabel );
      
   2: VarExpr( Node decl );
   2: LValueVar( Node decl, boolean writeable );
   2: IncVar( Node decl );
   2: DecVar( Node decl );
      
   2: FlowToVal( inout Label falseLabel );
   2: ValToFlow( out Label falseLabel );
   2: MoveIntoTempShortString >> int;
      
   2: DeclLevel( Node decl ) >> int;
   2: DeclUpLevels( Node decl ) >> int;
      
      % ----------------------------- Declarations ----------------------------
      
   2: Program:
   4:    Node t
      
   4:    workspace = oWorkspaceNew
      
         % root scope is used for builtins e.g. Integer,
         % and is a parent to any used units, and the program's own global scope.
   9:    oScopeBegin( 0, allocGlobal )
  18:    Node rootScope = oScopeCurrent
      
  23:    @installBuiltIns
      
         % Start by calling the main program routine.
      
         % This dummy call to main needs to look like a normal method itself,
         % so jit can align the stack properly.  So we need .tEnter,
         % and .tAllocActuals / .tFreeActuals.
  25:    .tEnter  oEmitInt( 0 )
  33:    Label mainLabel = oLabelNew
      
  38:    .tAllocActuals  oEmitInt( 0 )
  46:    .tCall  oEmitLabel( mainLabel )
  54:    .tFreeActuals  oEmitInt( 0 )
  62:    .tReturn
      
  64:    pProgram
  66:    pIdent
      
  68:    Node program = oNodeNew( nProgram )
  78:    oNodeSetInt( program, qIdent, LAST_ID )
  89:    oNodeSet( workspace, qProgram, program )
      
      
 101:    [
 101:       | '(' :
 103:          pIdent      % input, output files
      
 105:          t = @newIdent( nVar, LAST_ID )
 118:          oNodeSet( t, qType, FileType )
 130:          oScopeDeclareAlloc( t )
               % TO DO: I shouldn't declare the files in root scope.
               %        Should save them for program's global scope.
      
 136:          ','
 138:          pIdent
      
 140:          t = @newIdent( nVar, LAST_ID )
 153:          oNodeSet( t, qType, FileType )
 165:          oScopeDeclareAlloc( t )
      
 171:          ')'
 173:       | * :
 178:    ]
 178:    ';'
      
 180:    @UsesMySystem( program )
         % The uses clause may only appear once, immediately after the program declaration.
 187:    [
 187:       | pUses :  @UsesClause( program )
 196:       | * :
 201:    ]
 201:    @EnterUsedUnits( program )
      
         % Global scope for the program, below any used units.
 208:    oScopeBegin( 0, allocGlobal )
 217:    globalScope = oScopeCurrent
      
         % A new scope just for temporaries in the main routine
         % Create it up front, in case it's needed by variable initialization exprs.
         % But we won't stay in it here.
         % Note we say it extends the global scope, so that during main statement evaluation
         % any user labels declared in the global scope are considered to be part of the current scope.
 222:    oScopeBegin( 0, allocDown )
 231:    oNodeSet( oScopeCurrent, qExtends, globalScope )
 242:    initScope = oScopeCurrent
 247:    oNodeSet( program, qMainRoutineScope, initScope )
 259:    oScopeEnd
      
 260:    @BlockDecls( nGlobalVar )
      
      
 267:    oScopeEnter( initScope )
      
         % The block statement includes a stack frame, and enter/return,
         % even for the main routine.
         % That will be necessary for temporaries allocated in the main routine.
      
         % isMain means we'll generate calls to the unit init/final methods in here too.
         % Alternatively we could do that in a higher level method that calls main.
 273:    boolean isMain = true
 279:    @BlockStmt( mainLabel, globalScope, isMain )
      
 292:    oScopeEnd   % main routine scope
      
 293:    '.'
 295:    @CheckForUndefinedLabels
 297:    oScopeEnd   % global scope
 298:    @EndUsedUnits( program )   % used units scopes
 306:    ;
      
      
      % The uses clause is a list of units required by the user program or unit.
      % We will find and compile the named units (unless already loaded).
      % We do not make the unit interface visible to the user, the caller will do so later.
 306: UsesClause( Node user ):
 308:    {
 308:       pIdent
 310:       @Uses( LAST_ID, user )
 319:       [
 319:          | ',' :
 321:          | * :  >
 328:       ]
 328:    }   
 330:    ';'
 333:    ;
      
      
      % Process an implicit "uses mysystem" in every module, except in the mysystem unit itself.
      % (I'm calling the unit mysystem rather than system, so fpc doesn't use it to replace its own system unit.)
      %
 333: UsesMySystem( Node user ):
 335:    [ equal( oNodeGetInt( user, qIdent ), mysystemId )
 352:       | true :  >>
 354:       | * :
 359:    ]
 359:    @Uses( mysystemId, user )
 370:    ;
      
      
      % After processing the mysystem unit interface, grab certain declarations from it
      % that the compiler may want to refer to later.
      %
 370: FindSelectSystemDecls( Node unit ):
 372:    [ equal( oNodeGetInt( unit, qIdent ), mysystemId )
 389:       | true :
 390:          System_ShortStringAppendShortString = oNodeFind( oScopeCurrent, qDecls, qIdent, oId_ShortStringAppendShortString )
 407:          System_ShortStringAppendChar = oNodeFind( oScopeCurrent, qDecls, qIdent, oId_ShortStringAppendChar )
 424:          System_ShortStringCmp = oNodeFind( oScopeCurrent, qDecls, qIdent, oId_ShortStringCmp )
 441:       | * :
 446:    ]
 447:    ;
      
      
      % The given user module uses a unit with the given id,
      % which may or may not have been loaded already.
      %
 447: Uses( int id, Node user ):
 449:    Node unit = @FindOrCompileUnit( id )
 460:    [ equal_node( unit, Null )
 470:       | false :
 471:          oNodeAddLast( user, qUsedUnits, unit )
      
               % Put a declaration in the current scope, naming the unit and pointing to it.
               % This is to allow references to  <unit>.<identifier_in_unit>
 483:          Node unitRef = oNodeNew( nUnitRef )
 493:          oNodeSetInt( unitRef, qIdent, oNodeGetInt( unit, qIdent ) )
 512:          oNodeSet( unitRef, qPublicScope, oNodeGet( unit, qPublicScope ) )
 531:          oScopeDeclare( unitRef )
 537:       | * :
 542:    ];
      
      
      % If the given decl is for an nUnitRef, the program is using syntax <unit>.<identifier>
      % Parse the rest of that to find the intended decl.
      %
 543: ResolveUnitRef( inout Node decl ):
 545:    [ oNodeType( decl )
 552:       | nUnitRef :
 553:          Node scope = oNodeGet( decl, qPublicScope )
 566:          '.'
 568:          pIdent
 570:          decl = oScopeFindRequireInScope( scope )
 580:       | * :
 585:    ];
      
      
 586: EnterUsedUnits( Node user ):
         % Make the used units' public scopes directly visible.
         % This is done after the units are all compiled, so they don't interfere with each other incorrectly.
         % Units later in the list have priority.
 588:    NodeIter unitIt = oNodeGetIter( user, qUsedUnits )
 601:    {
 601:       Node unit = oNodeIterValue( unitIt )
 611:       [ oNodeNull( unit )
 618:          | false :
 619:             oScopeEnter( oNodeGet( unit, qPublicScope ) )
 632:          | * :
 637:             >
 639:       ]
 639:       oNodeIterNext( unitIt )
 645:    }
 648:    ;
      
 648: EndUsedUnits( Node user ):
         % Leave the units' public scopes, so no longer visible.
 650:    NodeIter unitIt = oNodeGetIterLast( user, qUsedUnits )
 663:    {
 663:       Node unit = oNodeIterValue( unitIt )
 673:       [ oNodeNull( unit )
 680:          | false :
                  % Consistency check.  Make sure our scope enter / end have lined up correctly.
 681:             [ oNodeEqual( oScopeCurrent, oNodeGet( unit, qPublicScope ) )
 697:                | true :
 698:                | false :  #eInternalScopeMismatch
 702:             ]
 710:             oScopeEnd
 711:          | * :
 716:             >
 718:       ]
 718:       oNodeIterPrev( unitIt )
 724:    }
 727:    ;
      
      
 727: FindOrCompileUnit( int id ) >> Node:
         % We might have this unit loaded already
 729:    Node unit = oNodeFind( workspace, qUnits, qIdent, id )
 748:    [ equal_node( unit, Null )
 758:       | false :  >> unit
 762:       | * :
 767:    ]
      
         % If not, search for the source file on disk
 767:    boolean ok = oIncludeUnitFile( id )
 777:    [ ok
 780:       | false :  #eCantFindUnitFile  >> Null
 786:       | * :
 791:    ]
      
         % compile it, adding it into the workspace
         % then return it.
 791:    unit = @Unit
      
         % TO DO: ensure we are at pEof
         % end the include
 797:    oIncludeEnd
 798:    >> unit;
      
      
      
 802: Unit >> Node:
 804:    pUnit
 806:    pIdent
 808:    Node unit = oNodeNew( nUnit )
 818:    oNodeSetInt( unit, qIdent, LAST_ID )
 829:    Node unitImpl = oNodeNew( nUnitImpl )
 839:    oNodeSetInt( unitImpl, qIdent, LAST_ID )
 850:    oNodeSet( unit, qImpl, unitImpl )
 862:    ';'
      
         % mandatory sections
      
 864:    pInterface
 866:    @UsesMySystem( unit )
 873:    [
 873:       | pUses :   @UsesClause( unit )
 882:       | * :
 887:    ]
 887:    @EnterUsedUnits( unit )
      
 894:    oScopeBegin( 0, allocGlobal )
 903:    oNodeSet( unit, qPublicScope, oScopeCurrent )
 914:    globalScope = oScopeCurrent
      
         % A scope for temporaries needed by variable initialization
 919:    oScopeBegin( 0, allocDown )
 928:    initScope = oScopeCurrent
 933:    oNodeSet( unit, qInitRoutineScope, initScope )
 945:    oScopeEnd
      
 946:    @UnitInterface( unit )
 953:    oScopeEnd  % interface scope
      
 954:    pImplementation
 956:    @UsesMySystem( unitImpl )
 963:    [
 963:       | pUses :   @UsesClause( unitImpl )
 972:       | * :
 977:    ]
 977:    @EnterUsedUnits( unitImpl )
         % re-enter interface scope after impl's uses.  interface still has priority.
 984:    oScopeEnter( oNodeGet( unit, qPublicScope ) )
         
 997:    oScopeBegin( 0, allocGlobal )
1006:    oNodeSet( unit, qPrivateScope, oScopeCurrent )
1017:    oNodeSet( oScopeCurrent, qExtends, oNodeGet( unit, qPublicScope ) )
1035:    globalScope = oScopeCurrent
1040:    @UnitImplementation( unit )
      
1047:    [
1047:       | pInitialization :  @UnitInitialization( unit, true )   % init routine with statements from init section
1059:       | * :                @UnitInitialization( unit, false )  % implicit init routine
1074:    ]
1074:    [
1074:       | pFinalization :  @UnitFinalization( unit, true )
1086:       | * :              @UnitFinalization( unit, false )   % implicit final routine, may be handy later
1101:    ]
1101:    pEnd  '.'
      
1105:    oScopeEnd  % impl scope
1106:    oScopeEnd  % interface scope
1107:    @EndUsedUnits( unitImpl )  % used units scopes
1114:    @EndUsedUnits( unit )
1121:    oNodeAddLast( workspace, qUnits, unit )
1133:    >> unit;
      
      
1137: UnitInterface( Node unit ):
1139:    {[
1139:       | pConst :     @ConstDecl
1143:       | pType :      @TypeDecl
1147:       | pVar :       @VarDecl( nGlobalVar )
            % label declaration not allowed in interface
      
1156:       | pProcedure :
1158:          Node decl = @ProcHeaderDecl
               % despite syntax diagrams, fpc does allow external clause on methods in unit interface,
               % even though this clause is an alternative for the body statement.
1164:          [
1164:             | pExternal :
1166:                @ExternalDecl( decl )
1173:                ';'
1175:             | * :
1180:          ]
      
1180:       | pFunction :
1182:          Node decl = @FuncHeaderDecl
1188:          [
1188:             | pExternal :
1190:                @ExternalDecl( decl )
1197:                ';'
1199:             | * :
1204:          ]
      
1204:       | * :          >
1219:    ]}
1221:    @FindSelectSystemDecls( unit )
1229:    ;
      
1229: UnitImplementation( Node unit ):
1231:    @BlockDecls( nGlobalVar )
1239:    ;
      
      
1239: UnitInitialization( Node unit, boolean hasStmts ):
1241:    Label label = oLabelNew
1246:    .tLabel  oEmitLabel( label )
1254:    oNodeSetLabel( unit, qInitLabel, label )
      
1266:    int patchLS
1266:    .tEnter  patchLS = Here  .tSpace
      
         % insert any code for initialization of this unit's variables.
         
1275:    Node scope
1275:    Code initCode
      
1275:    scope = oNodeGet( unit, qPublicScope )
1288:    initCode = oNodeGetCode( scope, qInitCode )
1301:    oEmitCode( initCode )
1307:    oNodeSetCode( scope, qInitCode, codeNull )
      
1319:    scope = oNodeGet( unit, qPrivateScope )
1332:    initCode = oNodeGetCode( scope, qInitCode )
1345:    oEmitCode( initCode )
1351:    oNodeSetCode( scope, qInitCode, codeNull )
      
1363:    oScopeEnter( oNodeGet( unit, qInitRoutineScope ) )
      
1376:    [ hasStmts
1379:       | true :     
1380:          @Statement
1382:          {[
1382:             | ';' :  @Statement
1386:             | * :    >
1393:          ]}
1395:       | * :
1400:    ]
      
1400:    .tReturn
      
1402:    int localSpace = oNodeGetInt( oScopeCurrent, qSize )
1414:    oPatch( patchLS, localSpace )
1423:    oScopeEnd   % init routine scope, for temporaries
1425:    ;
      
      
1425: UnitFinalization( Node unit, boolean hasStmts ):
1427:    Label label = oLabelNew
1432:    .tLabel  oEmitLabel( label )
1440:    oNodeSetLabel( unit, qFinalLabel, label )
      
1452:    int patchLS
1452:    .tEnter  patchLS = Here  .tSpace
      
         % final routine scope, for temporaries
1461:    oScopeBegin( 0, allocDown )
      
1470:    [ hasStmts
1473:       | true :     
1474:          @Statement
1476:          {[
1476:             | ';' :  @Statement
1480:             | * :    >
1487:          ]}
1489:       | * :
1494:    ]
      
1494:    .tReturn
      
1496:    int localSpace = oNodeGetInt( oScopeCurrent, qSize )
1508:    oPatch( patchLS, localSpace )
1517:    oScopeEnd   % final routine scope, for temporaries
1519:    ;
      
      
1519: Block( node_type varNodeType, Label labelForBody ):
1521:    @BlockDecls( varNodeType )
1528:    @BlockStmt( labelForBody, oScopeCurrent, false )
1540:    @CheckForUndefinedLabels
1543:    ;
      
      
1543: BlockDecls( node_type varNodeType ):
1545:    {[
1545:       | pConst :     @ConstDecl
1549:       | pType :      @TypeDecl
1553:       | pVar :       @VarDecl( varNodeType )
1562:       | pLabel :     @LabelDecl
1566:       | pProcedure : @ProcDecl
1570:       | pFunction :  @FuncDecl
1574:       | * :          >
1591:    ]}
1593:    @CheckForUndefinedMethods
1596:    ;
      
      
      % were there any procedures or functions declared in this scope
      % that were never defined?
1596: CheckForUndefinedMethods:
         % TO DO
         % Note: disregard methods marked external
1599:    ;
      
      % were there any labels declared in the current scope, and used,
      % but never defined (as the prefix of a stement)?
      %
1599: CheckForUndefinedLabels:
1601:    NodeIter it = oNodeGetIter( oScopeCurrent, qDecls )
1613:    {
1613:       Node decl = oNodeIterValue( it )
1623:       [ oNodeNull( decl )
1630:          | false :
1631:          | * :  >
1638:       ]
1638:       [ oNodeType( decl )
1645:          | nLabel :
1646:             [ oNodeGetBoolean( decl, qDefined )
1656:                | false :
1657:                   [ oNodeGetBoolean( decl, qUsed )
1667:                      | true :    #eUsedButNotDefined  % TO DO: give the decl in the message
1670:                      | * :
1675:                   ]
1675:                | * :
1680:             ]
1680:          | * :
1685:       ]
1685:       oNodeIterNext( it )
1691:    }
1694:    ;
      
      
1694: InitializeUnits:
         % call init routine of each loaded unit, in the order they were loaded
         % (used directly or indirectly by the main program).
1696:    NodeIter it = oNodeGetIter( workspace, qUnits )
1709:    {
1709:       Node unit = oNodeIterValue( it )
1719:       [ oNodeNull( unit )
1726:          | true :  >
1729:          | false :
1731:             .tAllocActuals  oEmitInt( 0 )  % not sure I need this. maybe for stack alignment.
1739:             .tCall  oEmitLabel( oNodeGetLabel( unit, qInitLabel ) )
1754:             .tFreeActuals  oEmitInt( 0 )
1762:             oNodeIterNext( it )
1768:       ]
1776:    };
      
      
1779: FinalizeUnits:
1781:    NodeIter it = oNodeGetIterLast( workspace, qUnits )
1794:    {
1794:       Node unit = oNodeIterValue( it )
1804:       [ oNodeNull( unit )
1811:          | true :  >
1814:          | false :
1816:             .tAllocActuals  oEmitInt( 0 )  % not sure I need this. maybe for stack alignment.
1824:             .tCall  oEmitLabel( oNodeGetLabel( unit, qFinalLabel ) )
1839:             .tFreeActuals  oEmitInt( 0 )
1847:             oNodeIterPrev( it )
1853:       ]
1861:    };
      
      
      % Given the scope of vars in this block.
      % Usually it's the current scope, but it's a bit different for the main statement.
      %
1864: BlockStmt( Label labelForBody, Node varScope, boolean isMain ):
1866:    .tLabel  oEmitLabel( labelForBody )
      
         % Proc, func, and main routine all start with tEnter
         % to create a stack frame.  This will be used for temporaries
         % (and local vars in the case of proc, func).
      
1874:    int patchLS
1874:    .tEnter  patchLS = Here  .tSpace
      
         % If we're generating the program main method,
         % add in calls to the loaded units' initialization and finalization.
1883:    [ isMain
1886:       | true :  @InitializeUnits
1889:       | * :
1894:    ]
      
         % insert any code for initialization of this scope's variables
1894:    Code initCode = oNodeGetCode( varScope, qInitCode )
1907:    oEmitCode( initCode )
1913:    oNodeSetCode( varScope, qInitCode, codeNull )
      
1925:    @Statement
      
1927:    [ isMain
1930:       | true :  @FinalizeUnits
1933:       | * :
1938:    ]
      
1938:    .tReturn
      
1940:    int localSpace = oNodeGetInt( oScopeCurrent, qSize )
1952:    oPatch( patchLS, localSpace )
1962:    ;
      
      
      % modifers that may appear on a proc/function declaration.
      %
1962: MethodModifiers( Node decl ):
1964:    {[
1964:       | pCdecl :
1966:          oNodeSetBoolean( decl, qCdecl, true )
1978:          ';'
      
1980:       | * : >
1987:    ]}
1990:    ;
      
      
      % We need an initCode code stream for the given scope.
      % Create it if not present yet.  Return it.
      % (This will be used for variable initialization.)
      %
1990: GetOrCreateInitCode( Node scope ) >> Code:
1992:    Code initCode = oNodeGetCode( scope, qInitCode )
2005:    [ equal_code( initCode, codeNull )
2015:       | true :
2016:          initCode = oCodeNew
2021:          oNodeSetCode( scope, qInitCode, initCode )
2033:       | * :
2038:    ]
2038:    >> initCode;
      
      
      % external method resides in an external object file
      % (or in my system, the built-in runtime library).
      % The method has a label, as usual, which callers will use.
      % But we define that label with .tLabelExtern rather than .tLabel.
      %
      % Note, I'll hold off on issuing the .tLabelExtern until we see that
      % the external method is actually called.  Otherwise we'd fill each output file
      % with all the external method names in my included libraries, which seems dumb.
      %
      % Note this is fpc syntax.  I'm not sure about other Pascals.
      %
2042: ExternalDecl( Node decl ):
2044:    [ equal_zero( @DeclLevel( decl ) )
2056:       | false :  #eExternalMethodCannotBeNested
2059:       | * :
2064:    ]
2064:    oNodeSetBoolean( decl, qExternal, true )
2076:    [
2076:       | pStrLit :
               % that was the optional library name containing the method.
               % TO DO: I'm currently ignoring this.
2078:          [
2078:             | pName :
2080:                pStrLit
                     % that was the optional method name defined in that library,
                     % which might differ from the Pascal name.
2082:                oNodeSetString( decl, qExternalName, CURRENT_STRLIT )
2093:             | * :
2098:          ]
2098:       | * :
2103:    ]
2104:    ;
      
      
2104: ProcHeaderDecl >> Node:
2106:    pIdent
      
         % If we already have a forward declaration, we'll modify that decl
         % instead of creating a second symbol table entry.
         % (Alternatively could delete or hide the old entry.)
2108:    boolean redeclaring = false
2114:    Node decl = oScopeFindInCurrentScope
      
2119:    [ oNodeNull( decl )
2126:       | true :
               % first declaration
2127:          decl = @newIdent( nProc, LAST_ID )
2140:          oNodeSetLabel( decl, qValue, oLabelNew )
      
2151:       | false :
               % we already have a declaration.
               % Keep it, and its label.
2153:          redeclaring = true
2159:          [ oNodeGetBoolean( decl, qBodyDefined )
2169:             | true : #eAlreadyDefined
2172:             | * :
2177:          ]
2177:          [ oNodeGetBoolean( decl, qExternal )
2187:             | true : #eAlreadyDefined
2190:             | * :
2195:          ]
2195:          [ oNodeType( decl )
2202:             | nProc :
2203:             | * : #eAlreadyDefined   % wrong kind
2210:          ]
               % Move the existing param scope aside, so we can check that the
               % new one is consistent.  And, the body will want to see the new one
               % since the names might differ.
               % TO DO: If qOldParams already set, we have multiple forward decls,
               % which I believe is supposed to be an error.
2210:          oNodeSet( decl, qOldParams, oNodeGet( decl, qParams ) )
2229:          oNodeSet( decl, qParams, Null )
2241:    ]
      
2249:    int level = @ScopeLevel
2255:    boolean nested = greater( level, 0 )
2268:    inc( level )
2274:    oScopeBegin( level, allocUp )
2283:    Node paramScope = oScopeCurrent
      
         % A nested method has a hidden first param for the parent static scope.
         % This won't appear in the param decls list, just reserve space for it.
         % It's first so the static chain is always at a fixed offset from the frame pointer.
2288:    [ nested
2291:       | true :
2292:          int offset = oScopeAllocType( @PointerTypeTo( IntegerType ) )   % arbitrary ptr type
2307:       | * :
2312:    ]
      
2312:    @FormalArgDecl
2314:    oNodeSet( decl, qParams, paramScope )
2326:    oScopeEnd
2327:    ';'
      
2329:    [ redeclaring
2332:       | false : oScopeDeclare( decl )
2339:       | true :  % TO DO: check that qParams is consistent with qOldParams
2341:    ]
      
2349:    @MethodModifiers( decl )
2356:    >> decl;
      
      
2360: ProcDecl:
2362:    Node decl = @ProcHeaderDecl
      
         % Body may be a statement, "forward", "external".
         % Note, this syntax is based on FPC, and I'm not sure if other Pascals are similar.
         % FPC says that forward, external, cdecl, name, etc are not reserved words -
         % I think this means the user may declare other things with those names, but if so the
         % original meaning is lost.  I'll make them keywords for simplicity, for now
         % (just not too happy about "name").
      
2368:    [
2368:       | pForward :
               % Nothing to do.  We simply won't set qBodyDefined.
      
2370:       | pExternal : @ExternalDecl( decl )
      
2379:       | * :
               % Body statement
      
               % Enter the params scope again, so params are visible in body.
               % TO DO: Perhaps I could mark the scope read-only at this point.
2386:          Node paramScope = oNodeGet( decl, qParams )
2399:          oScopeEnter( paramScope )
      
               % Start scope for declarations within the proc
2405:          int level = oNodeGetInt( paramScope, qLevel )
2418:          oScopeBegin( level, allocDown )
2427:          oNodeSet( decl, qChildScope, oScopeCurrent )
      
2438:          Label label = oNodeGetLabel( decl, qValue )
2451:          @Block( nLocalVar, label )
2461:          oNodeSetBoolean( decl, qBodyDefined, true )
2473:          oScopeEnd
      
2474:          oScopeEnd  % paramScope
2475:    ]
2475:    ';';
      
      
      
2478: FuncHeaderDecl >> Node:
2480:    pIdent
      
         % If we already have a forward declaration, we'll modify that decl
         % instead of creating a second symbol table entry.
         % (Alternatively could delete or hide the old entry.)
2482:    boolean redeclaring = false
2488:    Node decl = oScopeFindInCurrentScope
      
2493:    [ oNodeNull( decl )
2500:       | true :
               % first declaration
2501:          decl = @newIdent( nFunc, LAST_ID )
2514:          oNodeSetLabel( decl, qValue, oLabelNew )
      
2525:       | false :
               % we already have a declaration.
               % Keep it, and its label.
2527:          redeclaring = true
2533:          [ oNodeGetBoolean( decl, qBodyDefined )
2543:             | true : #eAlreadyDefined
2546:             | * :
2551:          ]
2551:          [ oNodeType( decl )
2558:             | nFunc :
2559:             | * : #eAlreadyDefined   % wrong kind
2566:          ]
               % Move the existing param scope and return value aside,
               % so we can check that the new one is consistent.
               % And, the body will want to see the new one since the names might differ.
               % TO DO: If qOldParams already set, we have multiple forward decls,
               % which I believe is supposed to be an error.
2566:          oNodeSet( decl, qOldParams, oNodeGet( decl, qParams ) )
2585:          oNodeSet( decl, qParams, Null )
2597:          oNodeSet( decl, qOldType, oNodeGet( decl, qType ) )
2616:          oNodeSet( decl, qType, Null )
2628:    ]
      
2636:    int level = @ScopeLevel
2642:    boolean nested = greater( level, 0 )
2655:    inc( level )
2661:    oScopeBegin( level, allocUp )
2670:    Node paramScope = oScopeCurrent
      
         % A nested method has a hidden first param for the parent static scope.
         % This won't appear in the param decls list, just reserve space for it.
         % It's first so the static chain is always at a fixed offset from the frame pointer.
2675:    [ nested
2678:       | true :
2679:          int offset = oScopeAllocType( @PointerTypeTo( IntegerType ) )   % arbitrary ptr type
2694:       | * :
2699:    ]
      
2699:    @FormalArgDecl
2701:    oNodeSet( decl, qParams, paramScope )
      
2713:    ':'
      
2715:    Node theType
2715:    @TypeRef( theType )
2722:    oNodeSet( decl, qType, theType )
      
         % The function's param space gets an additional pointer,
         % which will point to a temporary in the caller's scope.
         % This pointer is essentially a VAR param, but I won't create an nParam for it.
      
2734:    Node ptrType = @PointerTypeTo( theType )
2745:    oNodeSetInt( decl, qResultOffset, oScopeAllocType( ptrType ) )
2761:    oScopeEnd
2762:    ';'
      
2764:    [ redeclaring
2767:       | false : oScopeDeclare( decl )
2774:       | true :  % TO DO: check that qParams is consistent with qOldParams
                      % and qType is consistent with qOldType
2776:    ]
      
2784:    @MethodModifiers( decl )
      
2791:    >> decl;
      
      
2795: FuncDecl:
2797:    Node decl = @FuncHeaderDecl
      
         % Body may be a statement, "forward", "external".
2803:    [
2803:       | pForward :
               % Nothing to do.  We simply won't set qBodyDefined.
      
2805:       | pExternal : @ExternalDecl( decl )
      
2814:       | * :
               % Body statement
      
               % Enter the params scope again, so params are visible in body.
               % TO DO: Perhaps I could mark the scope read-only at this point.
2821:          Node paramScope = oNodeGet( decl, qParams )
2834:          oScopeEnter( paramScope )
      
               % Start scope for declarations within the func
2840:          int level = oNodeGetInt( paramScope, qLevel )
2853:          oScopeBegin( level, allocDown )
2862:          oNodeSet( decl, qChildScope, oScopeCurrent )
      
2873:          Label label = oNodeGetLabel( decl, qValue )
2886:          @Block( nLocalVar, label )
2896:          oNodeSetBoolean( decl, qBodyDefined, true )
2908:          oScopeEnd
      
2909:          oScopeEnd  % paramScope
2910:    ]
2910:    ';';
      
      
2913: FormalArgDecl:
2915:    [
2915:       | '(' :
2917:          {
2917:             NodeVec decls = oNodeVecNew
2922:             Node decl
2922:             boolean isInOut = false
      
2928:             [
2928:                | pVar : isInOut = true
2936:                | * :
2941:             ]
      
2941:             {  pIdent
      
2943:                decl = @newIdent( nParam, LAST_ID )
2956:                oNodeSetBoolean( decl, qInOut, isInOut )
2968:                oNodeVecAppend( decls, decl )
      
2977:                [
2977:                   | ':' : >
2981:                   | ',' :
2983:                ]
2991:             }
      
2993:             Node theType
2993:             @TypeRef( theType )
      
                  % VAR param is declared with its given type, but allocated as a pointer.
3000:             Node allocType
3000:             [ isInOut
3003:                | true :   allocType = @PointerTypeTo( theType )
3015:                | * :      allocType = theType
3026:             ]
      
3026:             int i = 0
3032:             {[ equal( i, oNodeVecSize( decls ) )
3046:                | false :
3047:                   decl = oNodeVecElement( decls, i )
      
3060:                   oNodeSet( decl, qType, theType )
3072:                   oScopeDeclare( decl )
3078:                   oNodeSetInt( decl, qValue, oScopeAllocType( allocType ) )
3094:                   inc( i )
3100:                | * :
3105:                   >
3107:             ]}
      
3109:             oNodeVecDelete( decls )
      
3115:             [
3115:                | ')' : >
3119:                | ';' :
3121:             ]
3129:          }
3131:       | * :
3136:    ];
      
      
3137: ConstDecl:
3139:    {[
3139:       | pIdent :
3141:          [
3141:             | ':' :
3143:                @TypedConstDecl
3145:             | * :
3150:                @TrueConstDecl
3152:          ]
3152:       | * :
3157:          >
3159:    ]};
      
      
      % Parse a true constant declaration (as opposed to a typed const declaration).
      % The "true constant" terminology comes from Delphi docs.  It refers to a const that is
      % evaluated at compile time, rather than at program startup time.
      %
      % We've just accepted the identifier.
      %
3162: TrueConstDecl:
3164:    int id = LAST_ID
3169:    '='
      
3171:    @ConstExpr
      
3173:    Node decl
3173:    [ oTypeSNodeType
3175:       | nBooleanType, nByteType, nCharType, nIntegerType, nEnumType,
3176:         nPointerType, nUniversalPointerType :
3176:          decl = @newIdent( nConst, id )
3190:          oNodeSetInt( decl, qValue, oValueTop )
3201:       | nStrLitType :
3203:          decl = @newIdent( nConstStr, id )
3217:          oNodeSetString( decl, qValueStr, oValueTopString )
3228:       | * :  #eNotAllowed
3249:    ]
3249:    oValuePop
3250:    oNodeSet( decl, qType, oTypeSTop )
3261:    oTypeSPop
3262:    oScopeDeclare( decl )
3268:    ';'
3271:    ;
      
      
      % Parse a typed const declaration.
      % We've just accepted the identifier and ':'
      %
3271: TypedConstDecl:
3273:    Node decl = @newIdent( nTypedConst, LAST_ID )
      
3286:    Node theType
3286:    @TypeRef( theType )
3293:    oNodeSet( decl, qType, theType )
      
         % Array and record consts are allocated in global memory,
         % with global offset stored as decl value.
         % Scalar consts are not allocated in memory, and their value is
         % stored directly as the decl value, as I do with "true constants".
         %
         % TO DO: I probably should store scalar consts in memory too, in case somebody
         % wants to get a pointer to them.  And anyway, typed constants can't be used in
         % constant expressions, so less need to store value in decl node.
      
         % TO DO: skip subranges, similar to oTypeSNodeType.
3305:    [ oNodeType( theType )
3312:       | nBooleanType, nByteType, nCharType, nIntegerType, nEnumType,
3313:         nPointerType, nUniversalPointerType :
               % Parse expression and store value in decl
3313:          '='
      
3315:          oTypeSPush( theType )
3321:          @ConstExpr
3323:          @ConstCoerceType
      
3325:          oNodeSetInt( decl, qValue, oValueTop )
3336:          oValuePop
3337:          oTypeSPop
3338:          oScopeDeclare( decl )
3344:          ';'
      
3346:       | nShortStringType, nFileType :
3348:          #eNotImplemented
      
3350:       | nArrayType, nRecordType :
               % Allocate global space, store address in decl.
               % Push into global scope init code stream (since we'll be issuing code
               % rather than creating static data, at the moment).
               % Parse expression and store in global memory.
3352:          oScopeEnter( globalScope )
3358:          int addr = oScopeAllocType( theType )
3368:          oScopeEnd
3369:          oCodePush( @GetOrCreateInitCode( globalScope ) )
3380:          oNodeSetInt( decl, qValue, addr )
3392:          '='
3394:          @TypedConstInit( theType, addr )
3404:          oCodePop
3405:          oScopeDeclare( decl )
3411:          ';'
3413:    ]
3440:    ;
      
      
      % Parse the initial value of a constant that's being stored in global memory.
      % (An array or record constant, and recursively all its elements.)
      % Given the type, and the address in global memory for the const value.
      % The caller has already pushed into the global init code stream.
      %
3440: TypedConstInit( Node theType, int addr ):
      
         % TO DO: skip subranges, similar to oTypeSNodeTYpe
3442:    [ oNodeType( theType )
3449:       | nArrayType :
3450:          Node baseType = oNodeGet( theType, qBaseType )
3463:          Node indexType = oNodeGet( theType, qIndexType )
3476:          int low = @OrdinalLow( indexType )
3487:          int high = @OrdinalHigh( indexType )
3498:          int elementSize = oNodeGetInt( baseType, qSize )
      
3511:          '('
               % Loop over elements
3513:          int i = low
3519:          {
3519:             @TypedConstInit( baseType, addr )
3529:             [ equal( i, high )
3539:                | true : >
3542:                | false :
3544:             ]
3552:             ','
3554:             addr = add( addr, elementSize )
3567:             inc( i )
3573:          }
3575:          ')'
      
3577:       | nRecordType :
3579:          '('
3581:          Node fieldScope = oNodeGet( theType, qScope )
               % Loop over zero or more named fields.  It's not necessary to name them all.
               % fpc says the names that are given should be in order, but I'm not requiring that.
               % Since this is global memory, uninitialized fields will be left as 0.
3594:          {
3594:             [
3594:                | pIdent :
3596:                | * :  >
3603:             ]
3603:             Node field = oScopeFindRequireInScope( fieldScope )
3613:             ':'
3615:             Node fieldType = oNodeGet( field, qType )
3628:             int fieldAddr = add( addr, oNodeGetInt( field, qValue ) )
3648:             @TypedConstInit( fieldType, fieldAddr )
3658:             [
3658:                | ';' :
3660:                | * :  >
3667:             ]
3667:          }
3669:          ')'
      
3671:       | nBooleanType, nByteType, nCharType:
3673:          .tPushAddrGlobal  oEmitInt( addr )
3681:          oTypeSPush( theType )
3687:          @ConstExpr
3689:          @ConstCoerceType
3691:          .tPushConstI  oEmitInt( oValueTop )
3698:          oValuePop
3699:          oTypeSPop
3700:          .tAssignB
      
3702:       | nIntegerType, nEnumType:
3704:          .tPushAddrGlobal  oEmitInt( addr )
3712:          oTypeSPush( theType )
3718:          @ConstExpr
3720:          @ConstCoerceType
3722:          .tPushConstI  oEmitInt( oValueTop )
3729:          oValuePop
3730:          oTypeSPop
3731:          .tAssignI
      
3733:       | nPointerType, nUniversalPointerType :
3735:          .tPushAddrGlobal  oEmitInt( addr )
3743:          oTypeSPush( theType )
3749:          @ConstExpr
3751:          @ConstCoerceType
3753:          .tPushConstI  oEmitInt( oValueTop )   % only allowing ptr constant Nil so don't need tPushConstP or link redirection
3760:          oValuePop
3761:          oTypeSPop
3762:          .tAssignP
      
3764:       | nShortStringType, nFileType :
3766:          #eNotImplemented
3768:    ]
3795:    ;
      
      
3795: TypeDecl:
3797:    {[
3797:       | pIdent :
3799:          Node decl = @newIdent( nTypeDecl, LAST_ID )
3812:          '='
3814:          Node theType
3814:          @TypeRef( theType )
3821:          oNodeSet( decl, qType, theType )
3833:          oScopeDeclare( decl )
3839:          ';'
3841:       | * :
3846:          >
3848:    ]};
      
3851: VarDecl( node_type varNodeType ):
3853:    {[
3853:       | pIdent :
3855:          NodeVec decls = oNodeVecNew
3860:          Node decl
3860:          {
3860:             decl = @newIdent( varNodeType, LAST_ID )
3873:             oNodeVecAppend( decls, decl )
3882:             [
3882:                | ',' :
3884:                   pIdent
3886:                | * :
3891:                   >
3893:             ]
3893:          }
3895:          ':'
3897:          Node theType
3897:          @TypeRef( theType )
      
3904:          int i = 0
3910:          {[ equal( i, oNodeVecSize( decls ) )
3924:             | false :
3925:                decl = oNodeVecElement( decls, i )
3938:                oNodeSet( decl, qType, theType )
3950:                oScopeDeclareAlloc( decl )
3956:                inc( i )
3962:             | * :
3967:               >
3969:          ]}
      
               % optional initialization
3971:          [
3971:             | '=' :
3973:                [ oNodeVecSize( decls )
3980:                   | 1 :
3981:                   | * :  #eOnlyOneVarCanBeInitialized
3988:                ]
      
                     % we need an initCode stream for this scope
3988:                Code initCode = @GetOrCreateInitCode( oScopeCurrent )
3998:                oCodePush( initCode )
      
                     % currently the global level has two scopes:
                     % the one for declarations e.g. vars and methods,
                     % and a second one for temporaries needed by the main block stmt.
                     % During evaluation of the init expr, we need to be in the 2nd scope
                     % in case the expression requires temporaries
                     % (so the temporaries get allocated in the right scope).
                     % TO DO: Maybe I should make the global scope the special case, instead.
4004:                boolean changedScope = false
4010:                [ equal_zero( @ScopeLevel )
4017:                   | true : oScopeEnter( initScope )
4024:                            changedScope = true
4030:                   | * :
4035:                ]
                     % generate assignment in initCode stream
4035:                @LValueVar( decl, true )
4045:                @Expr
4047:                @CoerceType
4049:                @Assign
4051:                [ changedScope
4054:                   | true : oScopeEnd
4056:                   | * :
4061:                ]
4061:                oCodePop
                   
4062:             | * :
4067:          ]
      
4067:          oNodeVecDelete( decls )
4073:          ';'
4075:       | * :
4080:          >
4082:    ]};
      
      
      % Parse a list of label declarations.
      % We'll create a tcode label at declaration time, for each user label.
      % If the user label is an integer, we'll record it as _label_<int> in the decl.
      %
4085: LabelDecl:
4087:    {
4087:       Node decl
4087:       [
4087:          | pIdent :
4089:          | pIntLit :
                  % Replace token with identifier "_label_<intlit>"
4091:             oChangeIntLitToLabelIdent
4092:       ]
4100:       decl = @newIdent( nLabel, LAST_ID )
            % TO DO: ensure not already declared in this scope.
            %        Or maybe that can be part of oScopeDeclare.
4113:       Label label = oLabelNew
4118:       oNodeSetLabel( decl, qValue, label )
4130:       oScopeDeclare( decl )
4136:       [
4136:          | ',' :
4138:          | * :
4143:             >
4145:       ]
4145:    }
4147:    ';'
4150:    ;
      
      
      % Parse a type reference, returning the nType.
      % This will add types to the type table, as needed.
      %
      % Style question - at the moment I think callers look clearer if we use
      % an out param here, rather than a return value.
      %
4150: TypeRef( out Node resultType ):
4152:    [
4152:       | pIdent :           % previously named type (including intrinsics)
4154:          Node decl = oScopeFindRequire
4159:          @ResolveUnitRef( decl )
4166:          [ oNodeType( decl )
4173:             | nTypeDecl :
4174:                resultType = oNodeGet( decl, qType )
4187:             | * :
4192:                #eNotType
4194:                resultType = IntegerType
4200:          ]
         
4200:       | pArray :
4202:          '['
      
               % A multi-dimensional array is represented as a chain
               %    array [subrange1] of array [subrange2] of elementType
      
               % First, we build a vector of nArray's, each with one subrange as its index type,
               % but without setting the "of" type or size.
      
4204:          NodeVec dimensions = oNodeVecNew
      
4209:          {
                  % to do: probably should use general subrange parsing, incl minimal size value
                  %   In fact, supposed to parse ordinal_type here.  all ordinal types have a static low, high.
                  %   Not necessary to be a subrange.
      
4209:             Node subrange = oNodeNew( nSubrangeType )
      
4219:             @ConstExpr
4221:             oNodeSetInt( subrange, qLow, oValueTop )
4232:             oValuePop
4233:             '..'
4235:             @ConstExpr
4237:             oNodeSetInt( subrange, qHigh, oValueTop )
4248:             oValuePop
      
4249:             @ConstMatchTypes
4251:             oNodeSet( subrange, qBaseType, oTypeSTop )
4262:             oNodeSetInt( subrange, qSize, oNodeGetInt( oTypeSTop, qSize ) )
4280:             oTypeSPop
4281:             oTypeAdd( subrange )
      
4287:             Node a = oNodeNew( nArrayType )
4297:             oNodeSet( a, qIndexType, subrange )
      
4309:             oNodeVecAppend( dimensions, a )
                  % I'll hold off on adding 'a' to the type table since not fully formed yet
      
4318:             [
4318:                | ']' : >
4322:                | ',' :
4324:             ]
4332:          }
      
4334:          pOf
4336:          Node baseType
4336:          @TypeRef( baseType )
      
               % Work backwards through the dimensions,
               % hooking up the 'of' type and calculating the size.
               % At each iteration, baseType is the 'of' type.
      
4343:          int dim = oNodeVecSize( dimensions )
      
4353:          {
4353:              dec(dim)
      
4359:              Node a = oNodeVecElement( dimensions, dim )
      
4372:              oNodeSet( a, qBaseType, baseType )
4384:              Node subrange = oNodeGet( a, qIndexType )
4397:              int width = subtract( oNodeGetInt( subrange, qHigh ), oNodeGetInt( subrange, qLow ) )
4424:              inc( width )
4430:              oNodeSetInt( a, qSize, multiply( width, oNodeGetInt( baseType, qSize ) ) )
      
4456:              oTypeAdd( a )
4462:              baseType = a
      
4468:              [ equal_zero(dim)
4475:                  | true:  >
4478:                  | *:
4483:              ]
4483:          }
      
4485:          resultType = oNodeVecElement( dimensions, 0 )
4498:          oNodeVecDelete( dimensions )
      
4504:       | '^' :
4506:          Node theType
4506:          @TypeRef( theType )
4513:          resultType = @PointerTypeTo( theType )
      
4524:       | pRecord :
4526:          resultType = oNodeNew( nRecordType )
4536:          oScopeBegin( -1, allocUp )    % level is meaningless here
      
4545:          @VarDecl( nRecordField )
      
4552:          int size = oNodeGetInt( oScopeCurrent, qSize )
               % to do: padding
4564:          [ equal_zero( size )
4571:             | true : #eRecordEmpty
4574:             | * :
4579:          ]
      
4579:          pEnd
      
4581:          oNodeSet( resultType, qScope, oScopeCurrent )
4592:          oNodeSetInt( resultType, qSize, size )
4604:          oScopeEnd
4605:          oTypeAdd( resultType )
      
      
4611:       | '(' :
               % An enum type declaration.
4613:          @EnumTypeRef( resultType )
      
      
            % *** TO DO: following type constructors are not implemented *** 
4620:       | pSet :
4622:          pOf
4624:          Node theType
4624:          @TypeRef( theType )
4631:          #eNotImplemented
4633:       | * :       % this works for cases except where expr starts with an id
4648:          @ConstExpr '..' @ConstExpr
4654:          @ConstMatchTypes
4656:          #eNotImplemented
4658:    ];
      
      
      % Parse an enum type.
      % We've already accepted the '('
      % Returns the new type.
      %
4659: EnumTypeRef( out Node resultType ):
      
4661:    resultType = oNodeNew( nEnumType )
4671:    int value = 0
4677:    int numValues = 0
4683:    boolean first = true
      
         % We'll declare the enum values in two scopes: the current scope, and a scope nested in the enum type.
         % That will let programs use either <val> or <enumType>.<val>
4689:    Node outerScope = oScopeCurrent
4694:    oScopeBegin( -1, allocUp )   % level is meaningless, and we won't use allocate
      
4703:    {
            % TO DO: assert that name not already seen in this scope, i.e. this enum.
            %  And possibly not in the outerScope either, since that probably wouldn't count as shadowing.
            %  It might be in some other higher/used scope.
4703:       pIdent
4705:       Node decl = @newIdent( nEnumValue, LAST_ID )
4718:       Node decl2 = @newIdent( nEnumValue, LAST_ID )
4731:       oNodeSet( decl, qType, resultType )
4743:       oNodeSet( decl2, qType, resultType )
      
            % build up name table, for i/o
4755:       int nameOffset = oStringAllocLit( ID_STRING( LAST_ID ) )
4768:       oNodeSetInt( decl, qNameOffset, nameOffset )
4780:       oNodeSetInt( decl2, qNameOffset, nameOffset )
4792:       [
4792:          | '=', ':=' :
4794:             oTypeSPush( IntegerType )
4800:             @ConstExpr
4802:             @ConstCoerceType
4804:             oTypeSPop
                  % value must be ascending
                  % this obviously doesn't apply to the first value
4805:             [ equal_zero( numValues )
4812:                | false :
4813:                   [ greater( oValueTop, value )
4822:                      | false :   #eEnumValueNotAscending
4825:                      | * :
4830:                   ]
4830:                | * :
4835:             ]
4835:             [ equal( value, oValueTop )
4844:                | false :
                        % The values differ from 0..N-1.  pred/succ may not be used with this type.
4845:                   oNodeSetBoolean( resultType, qHasGap, true )
4857:                | * :
4862:             ]
4862:             value = oValueTop
4867:             oValuePop
4868:          | * :
4875:       ]
4875:       oNodeSetInt( decl, qValue, value )
4887:       oNodeSetInt( decl2, qValue, value )
4899:       oScopeDeclare( decl )
      
4905:       oScopeEnter( outerScope )
4911:       oScopeDeclare( decl2 )
4917:       oScopeEnd
      
4918:       inc( value )
4924:       inc( numValues )
4930:       [
4930:          | ',' :
4932:          | * :    >
4939:       ]
4939:    }
4941:    ')'
      
4943:    oNodeSet( resultType, qScope, oScopeCurrent )
4954:    oNodeSetInt( resultType, qSize, 4 )   % always integer sized
4966:    oScopeEnd
      
         % Finish creation of the name table
         %    struct {
         %      int    value;
         %      int    padding;
         %      char*  name;
         %    } table[ numValues + 1 ];
         %  final entry will have name == nullptr
         %
         % I'll need to generate init code, to store pointers in global data,
         % since I don't have a relocation mechanism for static data at the moment.
4967:    oCodePush( @GetOrCreateInitCode( globalScope ) )
4978:    oScopeEnter( globalScope )
4984:    int size = multiply( add( numValues, 1 ), 16 )
5004:    int addr = oScopeAlloc( size, 8 )
5017:    oScopeEnd
5018:    oNodeSetInt( resultType, qNameTable, addr )
         % loop over enum values
5030:    NodeIter it = oNodeGetIter( oNodeGet( resultType, qScope ), qDecls )
5050:    {
5050:       Node enumValue = oNodeIterValue( it )
5060:       [ oNodeNull( enumValue )
5067:          | true :  >
5070:          | * :
5075:       ]
5075:       .tPushAddrGlobal  oEmitInt( addr )
5083:       .tPushConstI  oEmitInt( oNodeGetInt( enumValue, qValue ) )
5098:       .tAssignI
5100:       addr = add( addr, 8 )
5113:       .tPushAddrGlobal  oEmitInt( addr )
5121:       .tPushAddrGlobal  oEmitInt( oNodeGetInt( enumValue, qNameOffset ) )
5136:       .tAssignP
5138:       addr = add( addr, 8 )
5151:       oNodeIterNext( it )
5157:    }
         % final table entry
5159:    .tPushAddrGlobal  oEmitInt( addr )
5167:    .tPushConstI  oEmitInt( 0 )
5175:    .tAssignI
5177:    addr = add( addr, 8 )
5190:    .tPushAddrGlobal  oEmitInt( addr )
5198:    .tPushConstI  oEmitInt( 0 )
5206:    .tAssignP
5208:    addr = add( addr, 8 )
5221:    oCodePop
      
5222:    oTypeAdd( resultType )
5229:    ;
      
      
      % --------------------------- Const Expressions --------------------------
      
      % Constant expressions are evaluated at compile time.
      % They are limited to constant literals, declared constants (not including TypedConstants!)
      % and a small selection of built-in functions. 
      %
      % The value of a constant expression is left on the Value Stack.
      % The type is left on the Type Stack.
      
5229: ConstExpr:
5231:    @ConstBoolExpr
5233:    {[
5233:       | '=' :
5235:          @ConstBoolTerm
5237:          @ConstMatchTypes
5239:          oTypeSPop  oTypeSPush( BooleanType )
5246:          oValueEqual
5247:       | '<>' :
5249:          @ConstBoolExpr
5251:          @ConstMatchTypes
5253:          oTypeSPop  oTypeSPush( BooleanType )
5260:          oValueNotEqual
5261:       | '<' :
5263:          @ConstBoolExpr
5265:          @ConstMatchTypes
5267:          oTypeSPop  oTypeSPush( BooleanType )
5274:          oValueLess
5275:       | '>' :
5277:          @ConstBoolExpr
5279:          @ConstMatchTypes
5281:          oTypeSPop  oTypeSPush( BooleanType )
5288:          oValueGreater
5289:       | '<=' :
5291:          @ConstBoolExpr
5293:          @ConstMatchTypes
5295:          oTypeSPop  oTypeSPush( BooleanType )
5302:          oValueLessEqual
5303:       | '>=' :
5305:          @ConstBoolExpr
5307:          @ConstMatchTypes
5309:          oTypeSPop  oTypeSPush( BooleanType )
5316:          oValueGreaterEqual
5317:       | * :  >
5334:    ]};
      
      
5337: ConstBoolExpr:
5339:    @ConstBoolTerm
5341:    {[
5341:       | pOr :
5343:          @ConstRequireBool
5345:          @ConstBoolTerm
5347:          @ConstRequireBoolPop
5349:          oValueOr
5350:       | * :  >
5357:    ]};
      
      
5360: ConstBoolTerm:
5362:    @ConstBoolFactor
5364:    {[
5364:       | pAnd :
5366:          @ConstRequireBool
5368:          @ConstBoolFactor
5370:          @ConstRequireBoolPop
5372:          oValueAnd
5373:       | * :  >
5380:    ]};
      
      
5383: ConstBoolFactor:
5385:    [
5385:       | pNot :
5387:          @ConstBoolFactor
5389:          @ConstRequireBool
5391:          oValueNot
5392:       | * :
5397:          @ConstArithExpr
5399:    ];
      
      
5400: ConstArithExpr:
5402:    @ConstTerm
5404:    {[
5404:       | '+' :
5406:          @ConstTerm
5408:          @ConstMatchTypes
5410:          oValueAdd
5411:       | '-' :
5413:          @ConstTerm
5415:          @ConstMatchTypes
5417:          oValueSub
5418:       | * :  >
5427:    ]};
      
      
5430: ConstTerm:
5432:    @ConstFactor
5434:    {[
5434:       | pTimes :
5436:          @ConstFactor
5438:          @ConstMatchTypes
5440:          oValueMult
5441:       | pDivide :
5443:          @ConstFactor
5445:          @ConstMatchTypes
5447:          oValueDiv
5448:       | * :  >
5457:    ]};
      
      
5460: ConstFactor:
5462:    [
5462:       | pPlus :
5464:          @ConstPrimary
5466:       | pMinus :
5468:          @ConstPrimary
5470:          oValueNegate
5471:       | * :
5478:          @ConstPrimary
5480:    ];
      
      
5481: ConstPrimary:
5483:    [
5483:       | pIntLit :
5485:          oValuePush( TOKEN_VALUE )
5490:          oTypeSPush( IntegerType )
5496:       | pCharLit :
5498:          oValuePush( TOKEN_VALUE )
5503:          oTypeSPush( CharType )
5509:       | pStrLit :
5511:          oValuePushString( CURRENT_STRLIT )
5516:          oTypeSPush( StrLitType )
5522:       | '(' :
5524:          @ConstExpr
5526:          ')'
5528:       | pIdent :
5530:          Node decl = oScopeFindRequire
5535:          @ResolveUnitRef( decl )
5542:          [ oNodeType( decl )
5549:             | nBuiltInFunc :
5550:                @ConstBuiltInFunc( decl )
5557:             | nConst :
5559:                oValuePush( oNodeGetInt( decl, qValue ) )
5572:                oTypeSPush( oNodeGet( decl, qType ) )
5585:             | nEnumValue :
5587:                oValuePush( oNodeGetInt( decl, qValue ) )
5600:                oTypeSPush( oNodeGet( decl, qType ) )
5613:             | * :
5622:                #eNotConst
5624:                oValuePush( 0 )
5630:                oTypeSPush( IntegerType )
5636:          ]
5636:       | '@' :
5638:          #eNotImplemented
5640:          oValuePush( 0 )
5646:          oTypeSPush( UniversalPointerType )
5652:       | * :
5667:          #eNotConst
5669:          oValuePush( 0 )
5675:          oTypeSPush( IntegerType )
5681:    ];
      
      
5682: ConstBuiltInFunc( Node decl ):
5684:    #eNotImplemented
5687:    ;
      
      
5687: ConstRequireBoolPop:
5689:    [ oTypeSNodeType
5691:       | nBooleanType :
5692:       | * :          #eNotBoolean
5699:    ]
5699:    oTypeSPop;
      
      
5701: ConstRequireBool:
5703:    [ oTypeSNodeType
5705:       | nBooleanType :
5706:       | * :          #eNotBoolean
5713:    ];
      
      
      % Require that the top two types on the type stack are matching (ignoring subranges).
      % Pop one of them, leaving only one.
      % The types refer to constant values on the Value Stack,
      % so any implicit conversion would occur there, not in code.
      %
      % Some implicit conversion is allowed for either of the types.
      % See also ConstCoerceType where only the top type may change.
      %
5714: ConstMatchTypes:
5716:    node_type nt = oTypeSNodeType
5721:    oTypeSPop
5722:    [ equal_node_type( nt, oTypeSNodeType )
5731:       | false :
               % Some implicit conversion is allowed even here
5732:          [ oTypeSNodeType
5734:             | nPointerType :
5735:                [ nt
5738:                   | nUniversalPointerType :  >>
5740:                   | * :
5745:                ]
5745:             | nUniversalPointerType :
5747:                [ nt
5750:                   | nPointerType :  >>
5752:                   | * :
5757:                ]
5757:             | nStrLitType :
5759:                [ nt
5762:                   | nCharType :
5763:                      oValueCharToString
5764:                      >>
5765:                   | * :
5770:                ]
5770:             | nCharType :
5772:                [ nt
5775:                   | nStrLitType :
5776:                      oValueSwap
5777:                      oValueCharToString
5778:                      oValueSwap
5779:                      oTypeSPop
5780:                      oTypeSPush( StrLitType )
5786:                      >>
5787:                   | * :
5792:                ]
5792:             | * :
5803:          ]
5803:          #eTypeMismatch
5805:       | * :
5810:    ];
      
      
      % Given two constant values on the value stack, and two types on the type stack.
      % Perform any necessary implicit conversions so the second value is the type of the
      % value under it.  Pop the top type, leaving only the desired type.
      %
5811: ConstCoerceType:
5813:    node_type nt = oTypeSNodeType
5818:    oTypeSPop
5819:    [ equal_node_type( nt, oTypeSNodeType )
5828:       | false :
               % Some implicit conversion is allowed even here
5829:          [ oTypeSNodeType
5831:             | nPointerType :
5832:                [ nt
5835:                   | nUniversalPointerType :  >>
5837:                   | * :
5842:                ]
5842:             | nUniversalPointerType :
5844:                [ nt
5847:                   | nPointerType :  >>
5849:                   | * :
5854:                ]
5854:             | nStrLitType :
5856:                [ nt
5859:                   | nCharType :
5860:                      oValueCharToString
5861:                      >>
5862:                   | * :
5867:                ]
5867:             | * :
5876:          ]
5876:          #eTypeMismatch
5878:       | * :
5883:    ];
      
      
      
      % ------------------------------ Expressions -----------------------------
      
      % There are two wrappers leading into expression parsing:
      %   Expr()
      %   BooleanExprControlFlow( out Label falseLabel )
      %
      % Expr always produces a value on the runtime expr stack,
      % and pushes its type on the type stack.
      %
      % BooleanExprControlFlow always generates control-flow code.
      % It does not push a value on the runtime expr stack.
      % It does not push a type on the type stack.
      % The control flow code ends up at Here if the expr is true,
      % and jumps to falseLabel if the expr is false.
      % This rule allocates falseLabel, and passes it back.
      % The caller will need to define its location.
      %
      % The internal methods of expr parsing may produce a mix of
      % values and control flow, depending on the operators seen.
      % We don't always do one or the other, hoping to be efficient for
      % cases like   "func_call( bool_var1, bool_var2 )"
      % as well as  "if bool_expr1 or bool_expr2 then ...".
      % If a subexpression rule produces control flow, it will allocate a
      % falseLabel and pass it back up.  And it will push the
      % result type as BooleanFlowType, to distinguish from BooleanType
      % which corresponds with a boolean value on the expr stack.
      % 
      % Note that my expression parsing is broken into more levels than
      % grammars describe for Pascal precedence levels.  This follows my
      % original parser implementation.  I think my rationale was that
      % operators from the levels that I split up couldn't have been
      % mixed anyway, since they require different data types
      % (e.g. boolean vs int/real).  And splitting them up simplified
      % my code.  But, I should revisit this.
      %
      
      
      % Public entry point:
      %
      % Parse an expression, leaving a value on the runtime expr stack
      % and its type on the type stack.
      %
      % This rule does not export control flow (though it may generate
      % control flow internally for subexpressions).
      %
5884: Expr:
5886:    Label falseLabel = labelNull
      
5892:    @ExprAllowFlow( falseLabel )
5899:    @FlowToVal( falseLabel );
      
      
      % Public entry point:
      %
      % Parse a Boolean expression, producing control flow code rather than a value.
      % Does not leave a value on the runtime expr stack.
      % Does not leave a type on the type stack.
      %
      % If the expression is true, the code will fall through to the end (Here).
      % If the expression is false, the code will jump to the given falseLabel,
      % which this rule will allocate but not define the location for.
      % The caller must do so.
      %
5907: BooleanExprControlFlow( out Label falseLabel ):
5909:    @ExprAllowFlow( falseLabel )
5916:    [ oTypeSNodeType
5918:       | nBooleanFlowType :
5919:       | nBooleanType :
               % convert value to control flow
5921:          falseLabel = oLabelNew
5926:          .tJumpFalse  oEmitLabel( falseLabel )
5934:       | * :
5941:          #eNotBoolean
5943:    ]
5943:    oTypeSPop;
      
      
      % If the current expr result is control flow, convert it to a value.
      % falseLabel is the label that had been used by the control flow.
      % On return it will be set to labelNull.
      %
5945: FlowToVal( inout Label falseLabel ):
5947:    [ oTypeSNodeType
5949:       | nBooleanFlowType :
5950:          Label doneLabel = oLabelNew
5955:          .tPushConstI  oEmitInt( 1 )
5963:          .tJump  oEmitLabel( doneLabel )
5971:          .tLabel  oEmitLabel( falseLabel )
5979:          .tPushConstI  oEmitInt( 0 )
5987:          .tLabel  oEmitLabel( doneLabel )
5995:          oTypeSPop
5996:          oTypeSPush( BooleanType )
6002:          falseLabel = labelNull
6008:       | * :
6013:    ];
      
      
      % If the current expr result is boolean value, convert it to control flow.
      % falseLabel will be allocated by this rule and passed back.
      % The caller must define its location.
      %
6014: ValToFlow( out Label falseLabel ):
6016:    [ oTypeSNodeType
6018:       | nBooleanType :
6019:          falseLabel = oLabelNew
6024:          .tJumpFalse  oEmitLabel( falseLabel )
6032:          oTypeSPop
6033:          oTypeSPush( BooleanFlowType )
6039:       | * :
6044:    ];
      
      
      % Parse an expression.  It may produce a value on the expr stack,
      % or control flow, depending on what's seen in the expression.
      % Leaves the expression type on the type stack.
      %
      % If the expression produces control flow, the expression type will be
      % nBooleanFlowType.  In this case, a true value falls through to Here,
      % and a false value jumps to falseLabel.  This rule will allocate falseLabel
      % and return it, but will not define its location; the caller must do so.
      %
      % If the expression produces a value, the value will be left on the
      % expression stack, and the type will be some type other than nBooleanFlowType.
      % In this case, falseLabel is ignored.
      %
6045: ExprAllowFlow( out Label falseLabel ):
6047:    @BoolExprAllowFlow( falseLabel )
6054:    {[
6054:       | '=' :
6056:          @FlowToVal( falseLabel )
6063:          @PromoteToIntOptional
6065:          @BoolExprAllowFlow( falseLabel )
6072:          @FlowToVal( falseLabel )
6079:          @PromoteToIntOptional
6081:          @MatchTypes
6083:          [ oTypeSNodeType
6085:             | nBooleanType, nCharType :     .tEqualB
6088:             | nIntegerType, nEnumType :     .tEqualI
6092:             | nPointerType, nUniversalPointerType :    .tEqualP
6096:             | nShortStringType, nStrLitType :
6098:                @ShortStringCmp  .tPushConstI  oEmitInt( 0 )  .tEqualI
6110:             | * :                           #eNotAllowed
6131:          ]
6131:          oTypeSPop
6132:          oTypeSPush( BooleanType )
      
6138:       | '<>' :
6140:          @FlowToVal( falseLabel )
6147:          @PromoteToIntOptional
6149:          @BoolExprAllowFlow( falseLabel )
6156:          @FlowToVal( falseLabel )
6163:          @PromoteToIntOptional
6165:          @MatchTypes
6167:          [ oTypeSNodeType
6169:             | nBooleanType, nCharType :     .tNotEqualB
6172:             | nIntegerType, nEnumType :     .tNotEqualI
6176:             | nPointerType, nUniversalPointerType :    .tNotEqualP
6180:             | nShortStringType, nStrLitType :
6182:                @ShortStringCmp  .tPushConstI  oEmitInt( 0 )  .tNotEqualI
6194:             | * :                           #eNotAllowed
6215:          ]
6215:          oTypeSPop
6216:          oTypeSPush( BooleanType )
      
6222:       | '<' :
6224:          @FlowToVal( falseLabel )
6231:          @PromoteToIntOptional
6233:          @BoolExprAllowFlow( falseLabel )
6240:          @FlowToVal( falseLabel )
6247:          @PromoteToIntOptional
6249:          @MatchTypes
6251:          [ oTypeSNodeType
6253:             | nBooleanType, nCharType :     .tLessB
6256:             | nIntegerType, nEnumType :     .tLessI
6260:             | nPointerType, nUniversalPointerType :   .tLessP
6264:             | nShortStringType, nStrLitType :
6266:                @ShortStringCmp  .tPushConstI  oEmitInt( 0 )  .tLessI
6278:             | * :                           #eNotAllowed
6299:          ]
6299:          oTypeSPop
6300:          oTypeSPush( BooleanType )
      
6306:       | '>' :
6308:          @FlowToVal( falseLabel )
6315:          @PromoteToIntOptional
6317:          @BoolExprAllowFlow( falseLabel )
6324:          @FlowToVal( falseLabel )
6331:          @PromoteToIntOptional
6333:          @MatchTypes
6335:          [ oTypeSNodeType
6337:             | nBooleanType, nCharType :     .tGreaterB
6340:             | nIntegerType, nEnumType :     .tGreaterI
6344:             | nPointerType, nUniversalPointerType :   .tGreaterP
6348:             | nShortStringType, nStrLitType :
6350:                @ShortStringCmp  .tPushConstI  oEmitInt( 0 )  .tGreaterI
6362:             | * :                           #eNotAllowed
6383:          ]
6383:          oTypeSPop
6384:          oTypeSPush( BooleanType )
      
6390:       | '<=' :
6392:          @FlowToVal( falseLabel )
6399:          @PromoteToIntOptional
6401:          @BoolExprAllowFlow( falseLabel )
6408:          @FlowToVal( falseLabel )
6415:          @PromoteToIntOptional
6417:          @MatchTypes
6419:          [ oTypeSNodeType
6421:             | nBooleanType, nCharType :     .tLessEqualB
6424:             | nIntegerType, nEnumType :     .tLessEqualI
6428:             | nPointerType, nUniversalPointerType :   .tLessEqualP
6432:             | nShortStringType, nStrLitType :
6434:                @ShortStringCmp  .tPushConstI  oEmitInt( 0 )  .tLessEqualI
6446:             | * :                           #eNotAllowed
6467:          ]
6467:          oTypeSPop
6468:          oTypeSPush( BooleanType )
      
6474:       | '>=' :
6476:          @FlowToVal( falseLabel )
6483:          @PromoteToIntOptional
6485:          @BoolExprAllowFlow( falseLabel )
6492:          @FlowToVal( falseLabel )
6499:          @PromoteToIntOptional
6501:          @MatchTypes
6503:          [ oTypeSNodeType
6505:             | nBooleanType, nCharType :     .tGreaterEqualB
6508:             | nIntegerType, nEnumType :     .tGreaterEqualI
6512:             | nPointerType, nUniversalPointerType :   .tGreaterEqualP
6516:             | nShortStringType, nStrLitType :
6518:                @ShortStringCmp  .tPushConstI  oEmitInt( 0 )  .tGreaterEqualI
6530:             | * :                           #eNotAllowed
6551:          ]
6551:          oTypeSPop
6552:          oTypeSPush( BooleanType )
      
6558:       | * :
6573:          >
6575:    ]};
      
      
6578: BoolExprAllowFlow( out Label falseLabel ):
6580:    Label trueLabel = labelNull
      
6586:    @BoolTermAllowFlow( falseLabel )
6593:    {[
6593:       | pOr :
6595:          [ oTypeSNodeType
6597:             | nBooleanFlowType :
                     % We are true here. Jump ahead to done
6598:                [ equal_label( trueLabel, labelNull )
6608:                   | true :  trueLabel = oLabelNew
6614:                   | * :
6619:                ]
6619:                .tJump  oEmitLabel( trueLabel )
6627:             | nBooleanType :
6629:                @ValToFlow( falseLabel )
                     % We are true here. Jump ahead to done
6636:                [ equal_label( trueLabel, labelNull )
6646:                   | true :  trueLabel = oLabelNew
6652:                   | * :
6657:                ]
6657:                .tJump  oEmitLabel( trueLabel )
6665:             | * : #eNotBoolean
6674:          ]
6674:          oTypeSPop
      
               % false in previous term will jump here, to try this alternative term
6675:          .tLabel  oEmitLabel( falseLabel )
      
               % we'll get a new falseLabel for this term
6683:          falseLabel = labelNull
6689:          @BoolTermAllowFlow( falseLabel )
      
6696:          [ oTypeSNodeType
6698:             | nBooleanFlowType :
6699:             | nBooleanType :
6701:                @ValToFlow( falseLabel )
6708:             | * : #eNotBoolean
6717:          ]
      
6717:          oTypeSPop
6718:          oTypeSPush( BooleanFlowType )
      
6724:       | * :
6729:          >
6731:    ]}
      
         % any short-circuit trues jump here to the end
6733:    [ equal_label( trueLabel, labelNull )
6743:       | false :
6744:          .tLabel  oEmitLabel( trueLabel )
6752:       | * :
6757:    ]
6758:    ;
      
      
6758: BoolTermAllowFlow( out Label falseLabel ):
6760:    Label overallFalseLabel = labelNull
      
6766:    @BoolFactorAllowFlow( falseLabel )
6773:    {[
6773:       | pAnd :
6775:          [ oTypeSNodeType
6777:             | nBooleanFlowType :
6778:             | nBooleanType :
6780:                @ValToFlow( falseLabel )
6787:             | * :
6794:                #eNotBoolean
6796:          ]
6796:          oTypeSPop
      
               % We're going to have a different falseLabel for each term,
               % because we let each rule allocate its own (rather than accepting labels passed in).
               % And in this case we want them all to go to the same place,
               % to be determined by the caller.
               %
               % I'll allow for label aliases.  This will be more optimal than generating
               % multiple private false-handling code segments, that the true path would have to
               % jump around.  That would be hard to eliminate afterwards.
      
6797:          [ equal_label( overallFalseLabel, labelNull )
6807:             | true :
6808:                overallFalseLabel = oLabelNew
6813:                .tLabelAlias  oEmitLabel( falseLabel )  oEmitLabel( overallFalseLabel )
6827:                falseLabel = overallFalseLabel
6833:             | * :
6838:          ]
      
6838:          Label factorFalseLabel = labelNull
6844:          @BoolFactorAllowFlow( factorFalseLabel )
      
6851:          [ oTypeSNodeType
6853:             | nBooleanFlowType :
6854:             | nBooleanType :
6856:                @ValToFlow( factorFalseLabel )
6863:             | * : #eNotBoolean
6872:          ]
6872:         .tLabelAlias  oEmitLabel( factorFalseLabel )  oEmitLabel( overallFalseLabel )
      
6886:       | * :
6891:          >
6893:    ]};
      
6896: BoolFactorAllowFlow( out Label falseLabel ):
6898:    [
6898:       | pNot :
6900:          Label factorFalseLabel = labelNull
      
6906:          @BoolFactorAllowFlow( factorFalseLabel )
6913:          [ oTypeSNodeType
6915:             | nBooleanFlowType :
                     % We have control flow, and are sitting at the point that has value false.
6916:                falseLabel = oLabelNew
6921:                .tJump  oEmitLabel( falseLabel )
                     % The true path jumps here
6929:                .tLabel  oEmitLabel( factorFalseLabel )
      
6937:             | nBooleanType :
                     % I have a value.  I'll leave it as a value, rather than create control flow.
                     % See how this goes.
6939:                .tNot
      
6941:             | * : #eNotBoolean
6950:          ]
      
6950:       | * :
6955:          @ArithExprAllowFlow( falseLabel )
6962:    ];
      
6963: ArithExprAllowFlow( out Label falseLabel ):
6965:    boolean first = true
6971:    int tempStrOffset
      
6971:    @TermAllowFlow( falseLabel )
6978:    {[
6978:       | '+' :
6980:          [ oTypeSNodeType
6982:             | nIntegerType, nByteType :
6983:                @PromoteToIntPop
6985:                @TermAllowFlow( falseLabel )  % actually not allowing CF, will be caught by type check
      
6992:                [ oTypeSNodeType
6994:                   | nPointerType, nUniversalPointerType :
                           % int + ptr
6995:                      .tSwap
                           % leave only the ptr type on the type stack (int was already popped above)
6997:                      @PointerAddition
6999:                   | * :
7006:                      @PromoteToInt
7008:                      .tAddI
7010:                ]
      
7010:             | nShortStringType, nStrLitType, nCharType :
                     % String concatenation
7012:                [ first
7015:                   | true :  % move into a temp string, so subsequent term(s) can further modify it.
7016:                             tempStrOffset = @MoveIntoTempShortString
7022:                             first = false
7028:                   | * :
7033:                ]
7033:                @TermAllowFlow( falseLabel )  % actually not allowing CF, will be caught by type check
7040:                [ oTypeSNodeType
7042:                   | nShortStringType, nStrLitType :
7043:                      @ShortStringAppendShortString
                           % Have to re-push the temp string.
                           % If we ever have .tDup then the append method could do it and we wouldn't need this
7045:                      .tPushAddrLocal  oEmitInt( tempStrOffset )
7053:                      oTypeSPush( ShortStringType )
7059:                   | nCharType :
7061:                      @ShortStringAppendChar
                           % Have to re-push the temp string.
                           % If we ever have .tDup then the append method could do it and we wouldn't need this
7063:                      .tPushAddrLocal  oEmitInt( tempStrOffset )
7071:                      oTypeSPush( ShortStringType )
7077:                   | * :
7086:                      #eTypeMismatch
7088:                      oTypeSPop
7089:                ]
      
7089:             | nPointerType, nUniversalPointerType :
7091:                @TermAllowFlow( falseLabel )   % actually not allowing CF
7098:                @PromoteToIntPop
7100:                @PointerAddition
      
7102:             | * :
7119:                #eNotAllowed
7121:          ]
      
7121:       | '-' :
7123:          [ oTypeSNodeType
7125:             | nIntegerType, nByteType :
7126:                @PromoteToIntPop
7128:                @TermAllowFlow( falseLabel )
7135:                @PromoteToInt
7137:                .tSubI
      
7139:             | nPointerType, nUniversalPointerType :
7141:                @TermAllowFlow( falseLabel )
7148:                [ oTypeSNodeType
7150:                   | nIntegerType, nByteType :
7151:                      @PromoteToIntPop
7153:                      @PointerSubInt
7155:                   | nPointerType, nUniversalPointerType :
7157:                      @MatchTypes
7159:                      @PointerSubPointer
7161:                   | * :
7172:                      #eNotAllowed
7174:                ]
      
7174:             | * :  #eNotAllowed
      
7187:          ]
7187:       | * :
7194:          >
7196:    ]};
      
7199: TermAllowFlow( out Label falseLabel ):
7201:    @FactorAllowFlow( falseLabel )
7208:    {[
7208:       | pTimes :
7210:          @PromoteToIntPop
7212:          @FactorAllowFlow( falseLabel )  % actually not allowing CF, will be caught by type check
7219:          @PromoteToInt
7221:          .tMultI
7223:       | pDivide :
7225:          @PromoteToIntPop
7227:          @FactorAllowFlow( falseLabel )
7234:          @PromoteToInt
7236:          .tDivI
7238:       | * :
7245:          >
7247:    ]};
      
7250: FactorAllowFlow( out Label falseLabel ):
7252:    [
7252:       | pPlus :
7254:          @PrimaryAllowFlow( falseLabel )  % actually not allowing CF, will be caught by type check
               % TO DO: unary +/- is supposed to leave expression type as-is.
7261:          @PromoteToInt
7263:       | pMinus :
7265:          @PrimaryAllowFlow( falseLabel )
               % TO DO: unary +/- is supposed to leave expression type as-is.
7272:          @PromoteToInt
7274:          .tNegI
7276:       | * :
7283:          @PrimaryAllowFlow( falseLabel )
7290:    ];
      
7291: PrimaryAllowFlow( out Label falseLabel ):
7293:    [
7293:       | pIntLit :
7295:          .tPushConstI  oEmitInt( TOKEN_VALUE )
7302:          oTypeSPush( IntegerType )
      
7308:       | pCharLit :
7310:          .tPushConstI  oEmitInt( TOKEN_VALUE )
7317:          oTypeSPush( CharType )
      
7323:       | '(' :
7325:          @ExprAllowFlow( falseLabel )
7332:          ')'
      
7334:       | pStrLit :
7336:          int addr = oStringAllocShortStringLit( CURRENT_STRLIT )     % store in global data
7345:          .tPushAddrGlobal oEmitInt( addr )
               % TO DO: consider defining a ShortString type with the exact capacity used.
               % But, I don't think it should matter here, since nobody should be assigning to this string.
7353:          oTypeSPush( StrLitType )
               % This seems unlikely, but the strlit may be followed by
               % array indexing.  Handle this the same way we would with a variable expression (see VarExpr)
               % First, advance the pointer by index if any
7359:          @LValueIndexes
               % get final value of dereferencing, if any
7361:          @FetchVar
      
7363:       | pIdent :
7365:          Node decl = oScopeFindRequire
7370:          @ResolveUnitRef( decl )
7377:          Node theType
      
7377:          [ oNodeType( decl )
7384:             | nFunc :
7385:                @Call( decl )
      
7392:             | nBuiltInFunc :
7394:                @CallBuiltInFunc( decl )
      
7401:             | nConst, nEnumValue :
7403:                theType = oNodeGet( decl, qType )
7416:                oTypeSPush( theType )
7422:                [ oTypeSNodeType
7424:                   | nIntegerType, nEnumType, nBooleanType :
7425:                      .tPushConstI @EmitValue( decl )
7434:                   | nPointerType, nUniversalPointerType :
                           % We have one pointer const, Nil.  It's pushed as I.
                           % Sign-extending I to P won't hurt since it's 0.
7436:                      .tPushConstI @EmitValue( decl )
7445:                   | * :
7458:                      #eNotImplemented
7460:                ]
      
7460:             | nGlobalVar, nLocalVar, nParam, nTypedConst :
7462:                @VarExpr( decl )
      
7469:             | * :
7488:                #eNotValue
7490:                oTypeSPush( IntegerType )
7496:          ]
      
7496:       | '@' :        % @var -- pointer to var
7498:          pIdent
      
7500:          Node decl = oScopeFindRequire
7505:          @ResolveUnitRef( decl )
7512:          Node theType
      
               % writeable is false because we're not on the left hand side of an assignment,
               % or passign into a var parameter.  So it's ok to take the address of a typed const.
7512:          @LValueVar( decl, false )
      
               % The above leaves the pointed-to type on type stack.
               % Replace with ptr-to-<type>.
7522:          theType = oTypeSTop
7527:          oTypeSPop
7528:          Node ptrType = @PointerTypeTo( theType )
7539:          oTypeSPush( ptrType )
      
7545:       | * :
7560:          #eNotValue
7562:          oTypeSPush( IntegerType )
7568:    ];
      
      
      % Parse a variable expression, given the declaration of the
      % just-accepted identifier.
      % Leaves the value on the expression stack, and type on the type stack.
      %
7569: VarExpr( Node decl ):
7571:    Node theType = oNodeGet( decl, qType )
         % how many levels up the static scope? Will ignore for globals.
7584:    int uplevels = @DeclUpLevels( decl )
      
7595:    oTypeSPush( theType )
7601:    [ oTypeSNodeType
7603:       | nIntegerType, nEnumType :
7604:          [ oNodeType( decl )
7611:             | nGlobalVar, nTypedConst :   .tPushGlobalI  @EmitValue( decl )
7621:             | nLocalVar :
7623:                [ equal_zero( uplevels )
7630:                   | true :  .tPushLocalI  @EmitValue( decl )
7640:                   | * :     .tPushUpLocalI  oEmitInt( uplevels )  @EmitValue( decl )
7660:                ]
7660:             | nParam :
7662:                [ oNodeGetBoolean( decl, qInOut )
7672:                   | true :    % VAR param points to the var.  Auto dereference.
7673:                      [ equal_zero( uplevels )
7680:                         | true :  .tPushParamP  @EmitValue( decl )
7690:                         | * :     .tPushUpParamP  oEmitInt( uplevels )  @EmitValue( decl )
7710:                      ]
7710:                      .tFetchI
7712:                   | * :
7717:                      [ equal_zero( uplevels )
7724:                         | true :  .tPushParamI  @EmitValue( decl )
7734:                         | * :     .tPushUpParamI  oEmitInt( uplevels )  @EmitValue( decl )
7754:                      ]
7754:                ]
7754:          ]
      
7766:       | nBooleanType, nByteType, nCharType :
7768:          [ oNodeType( decl )
7775:             | nGlobalVar, nTypedConst :   .tPushGlobalB  @EmitValue( decl )
7785:             | nLocalVar :
7787:                [ equal_zero( uplevels )
7794:                   | true :  .tPushLocalB  @EmitValue( decl )
7804:                   | * :     .tPushUpLocalB  oEmitInt( uplevels )  @EmitValue( decl )
7824:                ]
7824:             | nParam :
7826:                [ oNodeGetBoolean( decl, qInOut )
7836:                   | true :    % VAR param points to the var.  Auto dereference.
7837:                      [ equal_zero( uplevels )
7844:                         | true :  .tPushParamP  @EmitValue( decl )
7854:                         | * :     .tPushUpParamP  oEmitInt( uplevels )  @EmitValue( decl )
7874:                      ]
7874:                      .tFetchB
7876:                   | * :
7881:                      [ equal_zero( uplevels )
7888:                         | true :  .tPushParamB  @EmitValue( decl )
7898:                         | * :     .tPushUpParamB  oEmitInt( uplevels )  @EmitValue( decl )
7918:                      ]
7918:                ]
7918:          ]
      
7930:       | nFileType :
7932:          #eNotImplemented
      
7934:       | nPointerType, nUniversalPointerType :
7936:          [ oNodeType( decl )
7943:             | nGlobalVar, nTypedConst :   .tPushGlobalP @EmitValue( decl )
7953:             | nLocalVar :
7955:                [ equal_zero( uplevels )
7962:                   | true :  .tPushLocalP  @EmitValue( decl )
7972:                   | * :     .tPushUpLocalP  oEmitInt( uplevels )  @EmitValue( decl )
7992:                ]
7992:             | nParam :
7994:                [ oNodeGetBoolean( decl, qInOut )
8004:                   | true :    % VAR param points to the var.  Auto dereference.
8005:                      [ equal_zero( uplevels )
8012:                         | true :  .tPushParamP  @EmitValue( decl )
8022:                         | * :     .tPushUpParamP  oEmitInt( uplevels )  @EmitValue( decl )
8042:                      ]
8042:                      .tFetchP
8044:                   | * :
8049:                      [ equal_zero( uplevels )
8056:                         | true :  .tPushParamP  @EmitValue( decl )
8066:                         | * :     .tPushUpParamP  oEmitInt( uplevels )  @EmitValue( decl )
8086:                      ]
8086:                ]               
8086:          ]
8098:          [
8098:             | '^' :             % dereferenced
8100:                oTypeSPop
8101:                oTypeSPush( oNodeGet( theType, qBaseType ) )
8114:                @LValueIndexes
8116:                @FetchVar
8118:             | '[' :             % dereferencing pointer like an array [0..] of baseType
8120:                @PointerArraySubscript
                     % modify addr for any subsequent subscripts, field references, etc
8122:                @LValueIndexes
8124:                @FetchVar
8126:             | * :               % just ptr value alone
8133:          ]
      
8133:       | nArrayType, nRecordType, nShortStringType :
               % compound type
               % first, push addr of start of var
8135:          [ oNodeType( decl )
8142:             | nGlobalVar, nTypedConst :   .tPushAddrGlobal @EmitValue( decl )
8152:             | nLocalVar :
8154:                [ equal_zero( uplevels )
8161:                   | true :  .tPushAddrLocal  @EmitValue( decl )
8171:                   | * :     .tPushAddrUpLocal  oEmitInt( uplevels )  @EmitValue( decl )
8191:                ]
8191:             | nParam :
8193:                [ oNodeGetBoolean( decl, qInOut )
8203:                   | true :    % VAR param points to the var.  Auto dereference.
8204:                      [ equal_zero( uplevels )
8211:                         | true :  .tPushParamP  @EmitValue( decl )
8221:                         | * :     .tPushUpParamP  oEmitInt( uplevels )  @EmitValue( decl )
8241:                      ]
8241:                   | * :
8246:                      [ equal_zero( uplevels )
8253:                         | true :  .tPushAddrParam  @EmitValue( decl )
8263:                         | * :     .tPushAddrUpParam  oEmitInt( uplevels )  @EmitValue( decl )
8283:                      ]
8283:                ]
8283:          ]
               % modify addr for subscripts, field references, etc
8295:          @LValueIndexes
               % get final value
8297:          @FetchVar
8299:    ];
      
      
      % Addr of start of var is on expr stack; type is on type stack.
      % Replace expr stack with value of var.
      % (In the case of compound vars, this remains as the addr of the var).
      
8326: FetchVar:
8328:    [ oTypeSNodeType
8330:       | nIntegerType, nEnumType :  .tFetchI
8333:       | nBooleanType, nByteType, nCharType :  .tFetchB
8337:       | nFileType :   #eNotImplemented
8341:       | nPointerType :             .tFetchP
8345:       | nUniversalPointerType :    #eCantDereference
8349:       | nArrayType, nRecordType, nStrLitType, nShortStringType :  % compound type; leave as addr
8351:    ];
      
      
      % Addr of start of var is already on run stack, and type is on type stack.
      % Read subscripts, record fields, etc, to get final addr on run stack, and final type
      % on type stack.
      
8380: LValueIndexes:
8382:    {[
8382:       | '[' :
8384:          [ oTypeSNodeType
8386:             | nArrayType :    @ArraySubscripts
8389:             | nPointerType :  @PointerArraySubscript
8393:             | nStrLitType, nShortStringType :  @ShortStringArraySubscript
8397:             | * :             #eNotArray
8410:          ]
8410:       | '.' :       @RecordFieldRef
8414:       | '^' :       @PointerDeref   % TO DO: I suspect I don't have logic right here
                                          % about precondition and using .tFetchP
                                          % Ideally this should take over for the ^ in VarExpr too.
8418:       | * :         >
8429:    ]};
      
8432: ArraySubscripts:
8434:    [ oTypeSNodeType
8436:       | nArrayType :
8437:       | * :       #eNotArray
8444:    ]
8444:    {
8444:       [ oTypeSNodeType
8446:          | nArrayType :
8447:          | * :    #eTooManySubscripts
8454:       ]
      
            % low subscript of this dimension
8454:       int low = @OrdinalLow( oNodeGet( oTypeSTop, qIndexType ) )
      
            % replace type stack with next dimension, or OF type
8471:       Node baseType
8471:       baseType = oNodeGet( oTypeSTop, qBaseType )
8483:       oTypeSPop
8484:       oTypeSPush( baseType )
      
8490:       @Expr
8492:       @RequireIntPop
            % adjust for low subscript
8494:       [ equal_zero( low )
8501:          | false :
8502:             .tPushConstI oEmitInt( low ) .tSubI
8512:          | * :
8517:       ]
      
            % multiply by element size
8517:       int size = oNodeGetInt( baseType, qSize )
8530:       [ equal( size, 1 )
8540:          | false :
8541:             .tPushConstI oEmitInt( size ) .tMultI
8551:          | * :
8556:       ]
      
            % update start address
8556:       .tAddPI
8558:       [
8558:          | ']' :  >
8562:          | ',' :
8564:       ]
8572:    };
      
      
      % pointer[index] - similar to array[index] where index counts from 0.
      % On entry, the pointer value is on the stack, and pointer type is on the type stack.
      % We've already accepted the '['.
      % On exit, the address of the pointed-to element is on the stack,
      % and the element type is on the type stack.
      %
8575: PointerArraySubscript:
8577:    [ oTypeSNodeType
8579:       | nPointerType :
8580:       | * :    #eCantDereference
8587:    ]
         % replace type stack with base type
8587:    Node baseType = oNodeGet( oTypeSTop, qBaseType )
8599:    oTypeSPop
8600:    oTypeSPush( baseType )
         
8606:    @Expr
8608:    @RequireIntPop
         % multiply by element size
8610:    int size = oNodeGetInt( baseType, qSize )
8623:    [ equal( size, 1 )
8633:       | false :
8634:          .tPushConstI  oEmitInt( size )  .tMultI
8644:       | * :
8649:    ]
         % update start address
8649:    .tAddPI
8651:    ']';
      
      
      % Specialization of array indexing for ShortString.
      % We treat the starting index as 0 so that str[1] sees the first string char,
      % past the length byte.
      %
8654: ShortStringArraySubscript:
8656:    [ oTypeSNodeType
8658:       | nStrLitType, nShortStringType :
8659:       | * :    #eCantDereference
8668:    ]
8668:    oTypeSPop
8669:    oTypeSPush( CharType )
8675:    @Expr
8677:    @RequireIntPop
8679:    .tAddPI
8681:    ']';
      
      
8684: RecordFieldRef:
8686:    [ oTypeSNodeType
8688:       | nRecordType :
8689:       | * :    #eNotRecord
8696:    ]
8696:    oScopeEnter( oNodeGet( oTypeSTop, qScope ) )
8708:    pIdent
8710:    Node field = oScopeFindRequire
         % oScopeFind searches all open scopes, so make sure we found nRecordField
         % which could only be seen in the local scope we entered above.
8715:    [ oNodeType( field )
8722:       | nRecordField :
8723:       | * :   #eNotRecordField
8730:    ]
8730:    oScopeEnd
8731:    int offset = oNodeGetInt( field, qValue )
8744:    [ equal_zero( offset )
8751:       | false :
8752:          .tPushConstI oEmitInt( offset ) .tAddPI
8762:       | * :
8767:    ]
      
         % replace the type on the type stack, with the field type
8767:    oTypeSPop
8768:    oTypeSPush( oNodeGet( field, qType ) )
8782:    ;
      
      
      % On entry, expr stack has ptr, and integer index above it.
      % The type stack has just the pointer type.
      % Pop those, and push the ptr advanced to that index
      % (scaled by the pointed-to element size).
      % Leaves the pointer type on the type stack.
      %
8782: PointerAddition:
8784:    Node elementType = oNodeGet( oTypeSTop, qBaseType )
8796:    int elementSize = oNodeGetInt( elementType, qSize )
8809:    [ equal( elementSize, 1 )
8819:       | false :
8820:          .tPushConstI  oEmitInt( elementSize )
8828:          .tMultI
8830:       | * :
8835:    ]
8835:    .tAddPI
8838:    ;
      
      
      % On entry, expr stack has ptr, and integer above it.
      % The type stack has just the pointer type.
      % Pop those, and push the ptr decremented by that integer
      % (scaled by the pointed-to element size).
      % Leaves the pointer type on the type stack.
      %
8838: PointerSubInt:
8840:    Node elementType = oNodeGet( oTypeSTop, qBaseType )
8852:    int elementSize = oNodeGetInt( elementType, qSize )
8865:    [ equal( elementSize, 1 )
8875:       | false :
8876:          .tPushConstI  oEmitInt( elementSize )
8884:          .tMultI
8886:       | * :
8891:    ]
8891:    .tSubPI
8894:    ;
      
      
      % On entry, expr stack has two pointers, P1 and P2 above it.
      % The type stack has the type of P1.  (The type of P2 was already matched to P1.)
      % Replace the pointers on the expression stack with P1 - P2, scaled by the
      % pointed-to element size.  Type stack switched to integer.
      % 
8894: PointerSubPointer:
8896:    .tSubP
8898:    Node elementType = oNodeGet( oTypeSTop, qBaseType )
8910:    int elementSize = oNodeGetInt( elementType, qSize )
8923:    [ equal( elementSize, 1 )
8933:       | false :
8934:          .tPushConstI  oEmitInt( elementSize )
8942:          .tDivI
8944:       | * :
8949:    ]
8949:    oTypeSPop
8950:    oTypeSPush( IntegerType )
8957:    ;
      
      % ptr deref on left side, i.e. BEFORE addr of ptr var is on stack,
      %                              AFTER addr of thing pointed to is on stack
8957: PointerDeref:
8959:    [ oTypeSNodeType
8961:       | nPointerType :
8962:       | nUniversalPointerType :   #eCantDereference
8966:       | * :       #eNotPointer
8975:    ]
8975:    .tFetchP           % now addr on stack is addr of what we're pointing to
      
8977:    Node theType = oTypeSTop
8982:    oTypeSPop
8983:    oTypeSPush( oNodeGet( theType, qBaseType ) )
8997:    ;
      
      
      % The expr stack contains a value whose type is on top of the type stack.
      % Generate code to coerce the value to the type under it in the type stack
      % (pop the type stack, leaving only the desired type).
      % This is used for assignment.
      %
8997: CoerceType:
8999:    node_type nt = oTypeSNodeType
9004:    oTypeSPop
9005:    [ equal_node_type( nt, oTypeSNodeType )
9014:       | false :
               % Can we implicitly convert the value to the desired type?
9015:          [ oTypeSNodeType
9017:             | nIntegerType :
9018:                [ nt
9021:                   | nByteType :   .tCastBtoI  >>
9025:                   | * :
9030:                ]
9030:             | nByteType :
9032:                [ nt
9035:                   | nIntegerType :   .tCastItoB  >>
9039:                   | * :
9044:                ]
9044:             | nPointerType :
9046:                [ nt
9049:                   | nUniversalPointerType :  >>
9051:                   | nStrLitType :
9053:                      [ equal_node( oTypeSTop, PCharType )
9062:                         | true :
                                 % PChar := 'strlit' i.e. point at strlit[1]
9063:                            .tPushConstI  oEmitInt(1)  .tAddPI  >>
9074:                         | * :
9079:                      ]
9079:                   | * :
9086:                ]
9086:             | nUniversalPointerType :
9088:                [ nt
9091:                   | nPointerType :  >>
9093:                   | * :
9098:                ]
9098:             | nShortStringType :
9100:                [ nt
9103:                   | nStrLitType :  >>
9105:                   | nCharType :
                           % Store char as a temp ShortString.
9107:                      oTypeSPush( CharType )
9113:                      int tempOffset = @MoveIntoTempShortString
9119:                      oTypeSPop
9120:                      >>
9121:                   | * :
9128:                ]
9128:             | * :
9141:          ]
9141:          #eTypeMismatch
9143:       | * :
9148:    ];
      
      
      % Given a ShortString, StrLit, or Char on the expression stack
      % (and type on the type stack).  Move the value into a new temporary ShortString.
      % Leave that temp string and type on the stacks.
      % Also returns the offset of the temp string.
      %
9149: MoveIntoTempShortString >> int:
9151:    int tempOffset = oScopeAllocType( ShortStringType )
         % copy the value
9161:    [ oTypeSNodeType
9163:       | nShortStringType, nStrLitType :
9164:          .tPushAddrLocal  oEmitInt( tempOffset )
               % put temp addr under value addr
9172:          .tSwap
               % TO DO: we could just copy length + 1, but tCopy takes a fixed #bytes
9174:          .tCopy  oEmitInt( oNodeGetInt( ShortStringType, qSize ) )
9189:       | nCharType :
               % temp[0] = 1
9191:          .tPushAddrLocal  oEmitInt( tempOffset )
9199:          .tPushConstI  oEmitInt( 1 )
9207:          .tAssignB
               % temp[1] = value
9209:          .tPushAddrLocal  oEmitInt( add( tempOffset, 1 ) )
9224:          .tSwap
9226:          .tAssignB
9228:       | * :   #eTypeMismatch
9239:    ]
9239:    oTypeSPop
         % Leave the temp ShortString on the expr stack and type stack
9240:    .tPushAddrLocal  oEmitInt( tempOffset )
9248:    oTypeSPush( ShortStringType )
9254:    >> tempOffset;
      
      
      % Top of expr stack / type stack is ShortString B.
      % Under it is ShortString A.
      % Change A to append the contents of B to it (truncating if necessary).
      % Removes both A and B from the expr stack / type stack.
      %
9258: ShortStringAppendShortString:
         % TO DO: ideally I would do this directly with tcode.  But I think I need some more
         % enhancements for that to work well.   Meanwhile, generate a call to a method.
         % For the moment, I'll implement the method in Pascal, in the mysystem unit.
9260:    .tAllocActuals  oEmitInt( 16 )
9268:    .tPushAddrActual  oEmitInt( 8 )  .tSwap  .tAssignP
9280:    .tPushAddrActual  oEmitInt( 0 )  .tSwap  .tAssignP
9292:    .tCall   @EmitValue( System_ShortStringAppendShortString )
         % TO DO: Ideally I would leave A on the expr stack / type stack.
         %  But I can't really do that without dup, which I hesitate to add.
         %  I'll have the caller push A again themselves.
9301:    .tFreeActuals  oEmitInt( 16 )
9309:    oTypeSPop
9310:    oTypeSPop
9312:    ;
      
      % Top of expr stack / type stack is Char B.
      % Under it is ShortString A.
      % Change A to append char B to it (truncating if necessary).
      % Removes both A and B from the expr stack / type stack.
      %
9312: ShortStringAppendChar:
         % Note at the moment I don't align params
9314:    .tAllocActuals  oEmitInt( 12 )
9322:    .tPushAddrActual  oEmitInt( 8 )  .tSwap  .tAssignI
9334:    .tPushAddrActual  oEmitInt( 0 )  .tSwap  .tAssignP
9346:    .tCall  @EmitValue( System_ShortStringAppendChar )
9355:    .tFreeActuals  oEmitInt( 12 )
9363:    oTypeSPop
9364:    oTypeSPop
9366:    ;
      
      % Expr stack has ShortString A, and ShortString B above it.
      % Type stack has just the type of ShortString A.
      % Replaces the expr stack with the integer value of string comparison:
      % -1 if A < B,  0 if A = B,  1 if A > B
      % Leaves Integer on the type stack.
      %
9366: ShortStringCmp:
9368:    .tAllocActuals  oEmitInt( 24 )
9376:    .tPushAddrActual  oEmitInt( 8 )  .tSwap  .tAssignP
9388:    .tPushAddrActual  oEmitInt( 0 )  .tSwap  .tAssignP
9400:    int tempOffset = oScopeAllocType( IntegerType )
9410:    .tPushAddrActual  oEmitInt( 16 )  .tPushAddrLocal  oEmitInt( tempOffset )  .tAssignP
9428:    .tCall  @EmitValue( System_ShortStringCmp )
9437:    .tPushLocalI  oEmitInt( tempOffset )
9445:    .tFreeActuals  oEmitInt( 24 )
9453:    oTypeSPop
9454:    oTypeSPush( IntegerType )
9461:    ;
      
      
      % Called on first use of an extern method
      %
9461: DefineExternLabel( Node method ):
         % The extern name might be given explicitly, otherwise the pascal method name.
9463:    int strAddr
9463:    String externalName = oNodeGetString( method, qExternalName )
9476:    [ equal_string( externalName, stringNull )
9486:       | true :
9487:          strAddr = oStringAllocLit( ID_STRING( oNodeGetInt( method, qIdent ) ) )
9508:       | false :
9510:          strAddr = oStringAllocLit( externalName )
9520:    ]
9528:    .tLabelExtern  @EmitValue( method )  oEmitInt( strAddr )
9544:    ;
      
      
      % Parse a call, given an nProc or nFunc for the just-accepted identifier.
      % If a func, this will also generate the code to push the return value on the expr stack,
      % and push the return type on the type stack.
      %
9544: Call( Node method ):
      
         % Prior to first call, issue extern label for a called method.
         % I don't want to issue .tLabelExtern for unused methods, that seems inefficient.
9546:    [ oNodeGetBoolean( method, qExternal )
9556:       | true :
9557:          [ oNodeGetBoolean( method, qUsed )
9567:             | false :
                     % define the extern label on first use
9568:                @DefineExternLabel( method )
9575:             | * :
9580:          ]
9580:      | * :
9585:    ]
9585:    oNodeSetBoolean( method, qUsed, true )
      
         % If the method has a cdecl modifier, the back end will need to use the native
         % calling convention, instead of my own.  But, the convention varies by platform,
         % so the front end won't assume what it needs.  I'll still generate the normal tcode
         % that copies values into actuals space on the stack.
         % However, to help the back end, I will at least use a different instruction for the
         % allocation of the actuals space, and for the actual call.
         %
         % p.s. I only support cdecl on external methods, because I don't have a way
         % to let my own Pascal methods read params passed in with the cdecl calling convention.
         %
9597:    boolean cdecl = oNodeGetBoolean( method, qCdecl )
      
         % If this is a function, we will allocate a temporary
         % in the current scope, to hold the result value.
         % And pass a pointer to that temporary as an extra parameter.
9610:    Node resultType
9610:    int tempOffset
      
9610:    boolean isFunc = equal_node_type( oNodeType( method ), nFunc )
      
9627:    [ isFunc
9630:       | true :
9631:          resultType = oNodeGet( method, qType )
9644:          tempOffset = oScopeAllocType( resultType )
               % TO DO: we could manage temp allocation, so temp space can be reused
               %        by different code branches.
9654:       | * :
9659:    ]
         
      
9659:    Node paramScope = oNodeGet( method, qParams )
9672:    int actualsSize = oNodeGetInt( paramScope, qSize )
9685:    [ cdecl
9688:       | true : .tAllocActualsCdecl  oEmitInt( actualsSize )
9697:       | false :  .tAllocActuals  oEmitInt( actualsSize )
9707:    ]
      
         % If method is nested, it takes a hidden first parameter:
         % a pointer to the frame of the static scope in which the method is declared.
         % The location of a scope's frame is equivalent to offset 0 in the scope's locals space
         % (since local offsets are relative to the scope's frame pointer).
         %
         % The nested method may be in a higher scope (upLevels > 1),
         % or a sibling of the method we're in (upLevels = 1),
         % or an immediate child of the current method (upLevels = 0).
         %
         % To understand the upLevels computation, remember that a method's declaration
         % and its contents (variables, nested functions, and body statement)
         % are in two different scopes.
      
9715:    [ greater( @DeclLevel( method ), 0 )
9730:       | true :
9731:          .tPushAddrActual  oEmitInt( 0 )    % hidden param is at param offset 0
9739:          .tPushAddrUpLocal  oEmitInt( @DeclUpLevels( method ) )  oEmitInt( 0 )
9758:          .tAssignP
9760:       | * :
9765:    ]
      
      
9765:    NodeIter paramIter = oNodeGetIter( paramScope, qDecls )
9778:    Node param = oNodeIterValue( paramIter )
9788:    [
9788:       | '(' :
            
9790:          {
9790:             [ oNodeNull( param )
9797:                | true : >
9800:                | * :
9805:             ]
      
9805:             int offset = oNodeGetInt( param, qValue )
      
                  % Assign actual value to spot in actuals space
9818:             .tPushAddrActual oEmitInt( offset )
9826:             oTypeSPush( oNodeGet( param, qType ) )
      
9839:             [ oNodeGetBoolean( param, qInOut )
9849:                | true :   % A VAR param.
                                % The actual is a pointer to the value.
                                % The type on the type stack (pushed above) is for the pointed-to value.
      
9850:                           @LValueExpr( true )
                                % Addr of the referenced variable is on the expr stack,
                                % type of the variable is on the type stack.
      
                                % Match types more exactly. It's not sufficient to be assign compatible
                                % since the method will be assigning to the actual using the param type.
                                % Maybe something like type contents must match, incl subrange bounds.
9857:                           @MatchTypes
      
9859:                           .tAssignP
      
9861:                | false :  @Expr
9865:                           @CoerceType
                                
                                % Assign to offset in actuals space
      
9867:                           [ oTypeSNodeType
9869:                              | nIntegerType, nEnumType : .tAssignI
9872:                              | nBooleanType, nByteType, nCharType :  .tAssignB
9876:                              | nFileType :   #eNotImplemented
9880:                              | nPointerType, nUniversalPointerType :  .tAssignP
9884:                              | nArrayType, nRecordType, nShortStringType :
                                       % compound types: copy value into actuals space
9886:                                  int size = oNodeGetInt( oTypeSTop, qSize )
9898:                                  .tCopy  oEmitInt( size )    % multi-word copy
9906:                           ]
9932:             ]
9940:             oTypeSPop
      
9941:             oNodeIterNext( paramIter )
9947:             param = oNodeIterValue( paramIter )
9957:             [ oNodeNull( param )
9964:                | true :  >
9967:                | false :
9969:             ]
      
9977:             ','
9979:          }
      
9981:          ')'
      
9983:       | * :
9988:    ]
      
9988:    [ oNodeNull( param )
9995:       | false :    #eMissingParameter
9998:       | * :
10003:    ]
      
10003:    [ isFunc
10006:       | true :
               % Pass result temp as an additional VAR parameter.
10007:          .tPushAddrActual oEmitInt( oNodeGetInt( method, qResultOffset ) )
10022:          .tPushAddrLocal  oEmitInt( tempOffset )
10030:          .tAssignP
10032:       | * :
10037:    ]
      
10037:    [ cdecl
10040:       | true :
10041:          .tCallCdecl  @EmitValue( method )
10050:       | false :
10052:          .tCall   @EmitValue( method )
10061:    ]
      
10069:    [ isFunc
10072:       | true :
               % push return value from temp
10073:          oTypeSPush( resultType )
      
10079:          [ oTypeSNodeType
10081:             | nIntegerType, nEnumType :   .tPushLocalI  oEmitInt( tempOffset )
10090:             | nBooleanType, nByteType, nCharType :   .tPushLocalB  oEmitInt( tempOffset )
10100:             | nFileType :  #eNotImplemented
10104:             | nPointerType, nUniversalPointerType :   .tPushLocalP  oEmitInt( tempOffset )
10114:             | nArrayType, nRecordType, nShortStringType :   % compound type: push address
10116:                                .tPushAddrLocal  oEmitInt( tempOffset )
10124:          ]
10150:       | * :
10155:    ]
         
10155:    .tFreeActuals  oEmitInt( actualsSize )
10164:    ;
      
      
      % Parse a call to a built-in function, identified by the just-accepted identifier.
      % This will also generate the code to push the return value on the expr stack,
      % and push the return type on the type stack.
      %
10164: CallBuiltInFunc( Node method ):
      
         % Ord(x)
10166:    [ oNodeEqual( method, BuiltIn_Ord )
10176:       | true :
               % parameter is any scalar type (including boolean, enum, char)
               % result is integer
10177:          '('
10179:          @Expr
10181:          [ oTypeSNodeType
10183:             | nIntegerType, nEnumType :
10184:             | nBooleanType, nByteType, nCharType :  .tCastBtoI
10188:             | * :  #eTypeMismatch
10203:          ]
10203:          oTypeSPop
10204:          oTypeSPush( IntegerType )
10210:          ')'
10212:          >>
10213:       | * :
10218:    ]
      
         % Chr(x)
10218:    [ oNodeEqual( method, BuiltIn_Chr )
10228:       | true :
               % parameter is integer
               % result is char
10229:          '('
10231:          @Expr
10233:          [ oTypeSNodeType
10235:             | nIntegerType :    .tCastItoB
10238:             | nByteType :
10240:             | * :  #eTypeMismatch
10249:          ]
10249:          oTypeSPop
10250:          oTypeSPush( CharType )
10256:          ')'
10258:          >>
10259:       | * :
10264:    ]
      
         % Pred(x)
10264:    [ oNodeEqual( method, BuiltIn_Pred )
10274:       | true :
               % parameter is any enum type, as long as it has values 0..N-1
               % result is the same enum type
10275:          '('
10277:          @Expr
10279:          [ oTypeSNodeType
10281:             | nEnumType :
                     % TO DO: does this skip past type aliases?
                     % TO DO: what if using pred/succ on a subrange type?
10282:                [ oNodeGetBoolean( oTypeSTop, qHasGap )
10291:                   | true :   #eCantUsePredSuccOnEnumWithValueGaps
10294:                   | * :
10299:                ]
10299:             | * :  #eTypeMismatch
10306:          ]
10306:          .tDecI
10308:          ')'
10310:          >>
10311:       | * :
10316:    ]
      
         % Succ(x)
10316:    [ oNodeEqual( method, BuiltIn_Succ )
10326:       | true :
               % parameter is any enum type, as long as it has values 0..N-1
               % result is the same enum type
10327:          '('
10329:          @Expr
10331:          [ oTypeSNodeType
10333:             | nEnumType :
                     % TO DO: does this skip past type aliases?
                     % TO DO: what if using pred/succ on a subrange type?
10334:                [ oNodeGetBoolean( oTypeSTop, qHasGap )
10343:                   | true :   #eCantUsePredSuccOnEnumWithValueGaps
10346:                   | * :
10351:                ]
10351:             | * :  #eTypeMismatch
10358:          ]
10358:          .tIncI
10360:          ')'
10362:          >>
10363:       | * :
10368:    ]
      
10368:    #eNotImplemented
10371:    ;
      
      
      % ------------------------------ Statements -----------------------------
      
10371: Statement:
10373:    [
10373:       | pWriteln :     @WritelnStmt
10377:       | pWrite :       @WriteStmt
10381:       | pReadln :      @ReadlnStmt
10385:       | pRead :        @ReadStmt
10389:       | pIf :          @IfStmt
10393:       | pWhile :       @WhileStmt
10397:       | pFor :         @ForStmt
10401:       | pRepeat :      @RepeatStmt
10405:       | pBreak :       @BreakStmt
10409:       | pContinue :    @ContinueStmt
10413:       | pBegin :       @BeginStmt
10417:       | pIdent :       @LabelOrAssignOrCallStmt
10421:       | pCase :        @CaseStmt
10425:       | pGoto :        @GotoStmt
10429:       | pIntLit :      % should be an integer label
10431:                        oChangeIntLitToLabelIdent
10432:                        @LabelOrAssignOrCallStmt
10434:       | * :            % null statement : don't accept any tokens
10467:    ];
      
      
10468: LabelOrAssignOrCallStmt:
10470:    Node decl = oScopeFindRequire
10475:    @ResolveUnitRef( decl )
10482:    [ oNodeType( decl )
10489:       | nLabel :                          @LabelDefinition( decl )
10497:                                           @Statement
10499:       | nProc :                           @Call( decl )
10508:       | nGlobalVar, nLocalVar, nParam :   @AssignStmt( decl )
10517:       | nFunc :                           @AssignResultStmt( decl )
10526:       | * :                               #eBadStatement
10543:    ];
      
      
      % Parse a "label:" prefix in front of a statement.
      %
10544: LabelDefinition( Node decl ):
10546:    [ oNodeGetBoolean( decl, qDefined )
10556:       | true :  #eAlreadyDefined
10559:       | * :
10564:    ]
10564:    .tLabel  oEmitLabel( oNodeGetLabel( decl, qValue ) )
10579:    oNodeSetBoolean( decl, qDefined, true )
10591:    ':'
10594:    ;
      
      
      % Given decl, the just-accepted first identifier on the left hand side.
      %
10594: AssignStmt( Node decl ):
      
10596:    @LValueVar( decl, true )
10606:    ':=' 
10608:    @Expr
10610:    @CoerceType
10612:    @Assign
10615:    ;
      
      
      % Performs a raw assignment.
      % Given lvalue 2nd on stack, and expr value top of stack (already coerced to the lvalue type),
      % and type of both of these on the type stack,
      % perform the assignment and pop the type off the type stack.
      %
10615: Assign:
10617:    [ oTypeSNodeType
10619:       | nIntegerType, nEnumType :  .tAssignI
10622:       | nBooleanType, nByteType, nCharType :  .tAssignB
10626:       | nFileType :   #eNotImplemented
10630:       | nPointerType, nUniversalPointerType :  .tAssignP
            % compound var assigns; addrs of src, dest on stack
10634:       | nArrayType, nRecordType, nShortStringType :
                % TO DO: for ShortString, allow destination to be smaller capacity,
                % and truncate the copied value/length.
10636:           int size = oNodeGetInt( oTypeSTop, qSize )
10648:           .tCopy  oEmitInt( size )    % multi-word copy
10656:    ]
10682:    oTypeSPop
10684:    ;
      
      % Given nFunc for the just-accepted identifier on the left hand side.
      % Parse an assignment that represents assignment of the function result.
      %
10684: AssignResultStmt( Node funcDecl ):
         % Only allowed to assign the result of the immediately enclosing function, I think.
10686:    [ oNodeEqual( oNodeGet( funcDecl, qChildScope ), oScopeCurrent )
10702:       | false :   #eNotCurrentFunction
10705:       | * :
10710:    ]
      
         % Result value is stored in the caller's space, via a hidden VAR parameter.
10710:    .tPushParamP  oEmitInt( oNodeGetInt( funcDecl, qResultOffset ) )
10725:    oTypeSPush( oNodeGet( funcDecl, qType ) )
      
10738:    ':='
10740:    @Expr
10742:    @CoerceType
10744:    [ oTypeSNodeType
10746:       | nIntegerType, nEnumType : .tAssignI
10749:       | nBooleanType, nByteType, nCharType :  .tAssignB
10753:       | nFileType :   #eNotImplemented
10757:       | nPointerType, nUniversalPointerType :  .tAssignP
            % compound var assigns; addrs of src, dest on stack
10761:       | nArrayType, nRecordType, nShortStringType :
10763:           int size = oNodeGetInt( oTypeSTop, qSize )
10775:           .tCopy  oEmitInt( size )    % multi-word copy
10783:    ]
10809:    oTypeSPop
10811:    ;
      
      
      
      % Parse an lvalue expression, from scratch.
      % This is an expression that may appear on the left side of an assignment.
      % Leaves the address of the value on the expr stack,
      % and the type of the value at that address on the type stack.
      % If writeable is false, the expression won't be written to, so may access a
      % typed const.
      %
10811: LValueExpr( boolean writeable ):
         % At the moment, all lvalue expressions start with a variable name.
         % I think there can also be typecasts, not supported yet.  Check standard syntax.
10813:    pIdent
10815:    Node decl = oScopeFindRequire
10820:    @ResolveUnitRef( decl )
10827:    [ oNodeType( decl )
10834:       | nGlobalVar, nLocalVar, nParam, nTypedConst :
10835:       | * :  #eNotVar
10848:    ]
10848:    @LValueVar( decl, writeable )
10859:    ;
      
      
      % Parse an lvalue expression (e.g. left side of an assign statement)
      % that starts with the just-accepted identifier indicated by the given decl.
      % Leaves the lvalue address on the expression stack,
      % and the type of the value at that address on the type stack.
      %
10859: LValueVar( Node decl, boolean writeable ):
10861:    [ oNodeType( decl )
10868:       | nGlobalVar :   .tPushAddrGlobal @EmitValue( decl )
10878:       | nLocalVar :    .tPushAddrLocal @EmitValue( decl )
10889:       | nParam :
10891:          [ oNodeGetBoolean( decl, qInOut )
10901:             | true :   % VAR param points to variable.  No dereference.
10902:                        .tPushParamP @EmitValue( decl )
10911:             | * :      .tPushAddrParam @EmitValue( decl )
10925:          ]
10925:       | nTypedConst :
10927:          [ writeable
10930:             | false :  .tPushAddrGlobal @EmitValue( decl )                       
10940:             | * :      #eNotVar
10947:          ]
10947:       | * :            #eNotVar
10960:    ]
      
10960:    oTypeSPush( oNodeGet( decl, qType ) )
      
         % handle subscripts, if any.
         % There is one case that I'm not fitting into the pattern nicely, so need to
         % check for specially here:  if lvalue var is a pointer variable, and is
         % followed by [index], we need to dereference the pointer variable before applying
         % the index.  This is different from handling of [index] on an rvalue expression.
         % Right now I have LValueIndexes working for both lvalue and rvalue (composite types)
         % so can't easily add this behavior in there.
         % TO DO: probably I need separate rules LValueIndexes and RValueIndexes.
         %    This might also explain my confusion about handling of deref operator in LValueIndexes vs rvalue expr,
         %    and having separate rules might clear that up better.
      
10973:    [ oTypeSNodeType
10975:       | nPointerType :
10976:          [
10976:             | '[' :
                     % dereference the pointer var first
10978:                .tFetchP
10980:                @PointerArraySubscript
10982:             | * :
10987:          ]
10987:       | * :
10992:    ]
         % additional subscripts, if any
10992:    @LValueIndexes
10995:    ;
      
      
10995: IncVar( Node decl ):
10997:    @LValueVar( decl, true )
11007:    @RequireIntPop
11009:    @VarExpr( decl )
11016:    oTypeSPop
11017:    .tIncI
11019:    .tAssignI;
      
11022: DecVar( Node decl ):
11024:    @LValueVar( decl, true )
11034:    @RequireIntPop
11036:    @VarExpr( decl )
11043:    oTypeSPop
11044:    .tDecI
11046:    .tAssignI;
      
      
11049: IfStmt:
11051:    Label falseLabel = labelNull
      
11057:    @BooleanExprControlFlow( falseLabel )
11064:    pThen
11066:    @Statement
11068:    [
11068:       | pElse :
11070:          Label doneLabel = oLabelNew
      
11075:          .tJump  oEmitLabel( doneLabel )
11083:          .tLabel oEmitLabel( falseLabel )
11091:          @Statement
11093:          .tLabel oEmitLabel( doneLabel )
      
11101:       | * :
11106:          .tLabel oEmitLabel( falseLabel )
11114:    ];
      
      
11115: ForStmt:
11117:    pIdent
      
11119:    Node decl = oScopeFindRequire
         % TO DO: disallow use of a compound variable field.
         %        Could do that by disallowing use of LValueIndexes,
         %        or by double-checking the decl's qType here.
         % TO DO: I think I read somewhere that the variable must be in current scope.
11124:    @LValueVar( decl, true )
11134:    @RequireIntPop
      
11136:    ':='
      
11138:    @Expr
11140:    @RequireIntPop
11142:    .tAssignI
      
11144:    Label breakLabel = oLabelNew
      
11149:    Label checkLabel = oLabelNew
11154:    .tJump  oEmitLabel( checkLabel )
      
11162:    Label continueLabel = oLabelNew
11167:    .tLabel  oEmitLabel( continueLabel )
11175:    [
11175:       | pTo :
11177:          @IncVar( decl )
11184:          .tLabel  oEmitLabel( checkLabel )
11192:          @VarExpr( decl )  oTypeSPop
11200:          @Expr
11202:          @RequireIntPop
11204:          .tGreaterI
11206:          .tJumpTrue  oEmitLabel( breakLabel )
11214:       | pDownto :
11216:          @DecVar( decl )
11223:          .tLabel  oEmitLabel( checkLabel )
11231:          @VarExpr( decl )  oTypeSPop
11239:          @Expr
11241:          @RequireIntPop
11243:          .tLessI
11245:          .tJumpTrue  oEmitLabel( breakLabel )
11253:    ]
11261:    oLoopPush( continueLabel, breakLabel )
11270:    pDo
11272:    @Statement
11274:    .tJump  oEmitLabel( continueLabel )
11282:    .tLabel  oEmitLabel( breakLabel )
11290:    oLoopPop;
      
      
11292: RepeatStmt:
11294:    Label continueLabel = oLabelNew
11299:    .tLabel  oEmitLabel( continueLabel )
      
11307:    Label breakLabel = oLabelNew
      
11312:    oLoopPush( continueLabel, breakLabel )
11321:    @Statement
11323:    {[
11323:       | ';' :
11325:          @Statement
11327:       | pUntil :
11329:          Label falseLabel
11329:          @BooleanExprControlFlow( falseLabel )
11336:          .tLabelAlias  oEmitLabel( falseLabel )  oEmitLabel( continueLabel )
11350:          >
11352:    ]}
11362:    .tLabel  oEmitLabel( breakLabel )
11370:    oLoopPop;
      
      
11372: WhileStmt:
11374:    Label continueLabel = oLabelNew
11379:    .tLabel  oEmitLabel( continueLabel )
      
11387:    Label breakLabel
11387:    @BooleanExprControlFlow( breakLabel )
      
11394:    oLoopPush( continueLabel, breakLabel )
11403:    pDo
11405:    @Statement
11407:    .tJump  oEmitLabel( continueLabel )
11415:    .tLabel  oEmitLabel( breakLabel )
11423:    oLoopPop;
      
      
11425: ContinueStmt:                     % NOTE, for repeat..until, skips test (??)
11427:    [ equal_label( oLoopContinueLabel, labelNull )
11436:       | true :
11437:          #eNotInALoop
11439:       | false :
11441:          .tJump  oEmitLabel( oLoopContinueLabel )
11448:    ];
      
      
11457: BreakStmt:
11459:    [ equal_label( oLoopBreakLabel, labelNull )
11468:       | true :
11469:          #eNotInALoop
11471:       | false :
11473:          .tJump  oEmitLabel( oLoopBreakLabel )
11480:    ];
      
      
11489: CaseStmt:
11491:    Code tableCode = oCodeNew
11496:    Label tableLabel = oLabelNew
11501:    Label doneLabel = oLabelNew
11506:    Label otherwiseLabel = doneLabel
      
11512:    @Expr
         % Leave the expr type on the type stack throughout case statement
11514:    [ oTypeSNodeType
11516:       | nBooleanType, nByteType, nCharType :   .tJumpCaseB  oEmitLabel( tableLabel )
11525:       | nIntegerType, nEnumType :              .tJumpCaseI  oEmitLabel( tableLabel )
11535:       | nShortStringType, nStrLitType :        #eNotImplemented
11539:       | * :     #eNotAllowed
11558:    ]
11558:    pOf
      
11560:    {
11560:       [
11560:          | pOtherwise, pElse :
11562:             otherwiseLabel = oLabelNew
11567:             .tLabel  oEmitLabel( otherwiseLabel )
      
                  % A bit tricky:
                  % The otherwise clause allows multiple statements (unlike other cases).
                  % ';' might be separating statements in the otherwise clause,
                  % or might be an optional trailing ; after the last statement.
                  % I have to watch for End to know when the statements stop.
                  % (Note, the otherwise clause is the last part of the case statement.)
11575:             {[
11575:                | pEnd :  >
11579:                | * :
11584:                   @Statement
11586:                   [
11586:                      | ';' :
11588:                      | * :   pEnd  >
11597:                   ]
11597:             ]}
11599:             >
      
11601:          | pEnd :
                  % Reached end with no otherwise clause
11603:             >
      
11605:          | * :
11614:             Label caseLabel = oLabelNew
11619:             oCodePush( tableCode )
11625:             {
11625:                @ConstExpr
11627:                @ConstCoerceType
11629:                int val = oValueTop
11634:                oValuePop
11635:                [
11635:                   | '..' :  @ConstExpr
11639:                             @ConstCoerceType
11641:                             int highval = oValueTop
11646:                             oValuePop
11647:                             .tCaseRange  oEmitInt( val )  oEmitInt( highval )  oEmitLabel( caseLabel )
11667:                   | * :     .tCase  oEmitInt( val )  oEmitLabel( caseLabel )
11686:                ]
11686:                [
11686:                   | ',' :
11688:                   | * :  >
11695:                ]
11695:             }
11697:             oCodePop
11698:             ':'
11700:             .tLabel  oEmitLabel( caseLabel )
11708:             @Statement
11710:             .tJump  oEmitLabel( doneLabel )
                  % Swallow optional trailing ';'
11718:             [
11718:                | ';' :
11720:                | * :
11725:             ]
                  
11725:       ]
         
11725:    }
      
11727:    .tLabel  oEmitLabel( tableLabel )
11735:    oEmitCode( tableCode )
11741:    .tCaseEnd  oEmitLabel( otherwiseLabel )
11749:    .tLabel  oEmitLabel( doneLabel )
11757:    oTypeSPop
11759:    ;
      
      
11759: GotoStmt:
11761:    [
11761:       | pIdent :
11763:       | pIntLit :
               % Replace token with identifier "_label_<intlit>"
11765:          oChangeIntLitToLabelIdent
11766:    ]
      
         % Some pascals have rules about where you can jump (to a sibling statement or
         % higher level statement in the block, but not into a lower lower level statement.)
         % fpc just says "jumping into a nested statement can have strange effects."
         % I'm going to follow that and not prohibit any goto, as long as it's in the same block.
      
         % Label must be declared in the same block (same scope) it is used.
         % Some pascals allow non-local goto, but we do not.
         % That would require more tracking of dynamic scope, to unwind stack.
         % Note: in main program statement, this relies on the temporaries scope extending
         %  the main scope (where a label declaration would occur).
11774:    Node decl = oScopeFindRequireInScope( oScopeCurrent )
11783:    oNodeSetBoolean( decl, qUsed, true )
11795:    .tJump  oEmitLabel( oNodeGetLabel( decl, qValue ) )
11811:    ;
      
      
11811: BeginStmt:
11813:    @Statement
11815:    {[
11815:       | ';' :   @Statement
11819:       | pEnd :  >
11823:    ]};
      
      
11834: WritelnStmt:
11836:    @WriteStmt
11838:    .tWriteCR;
      
      
11841: WriteStmt:
11843:    [
11843:       | '(' :
11845:          {
11845:             @Expr
11847:             [ oTypeSNodeType
11849:                | nIntegerType :             .tWriteI
11852:                | nBooleanType :             .tWriteBool
11856:                | nByteType :                .tCastBtoI  .tWriteI
11862:                | nCharType :                .tWriteChar
11866:                | nShortStringType, nStrLitType :   .tWriteShortStr
11870:                | nFileType :                #eNotImplemented
11874:                | nEnumType :
                        % write name via table lookup
11876:                   .tPushAddrGlobal  oEmitInt( oNodeGetInt( oTypeSTop, qNameTable ) )
11890:                   .tWriteEnum
11892:                | nPointerType :
11894:                   [ equal_node( oTypeSTop, PCharType )
11903:                      | true :               .tWritePChar
11906:                      | * :                  .tWriteP
11913:                   ]
11913:                | nUniversalPointerType :    .tWriteP
11917:                | * :                        #eNotAllowed
11942:             ]
11942:             oTypeSPop
11943:             [
11943:                | ')' : >
11947:                | ',' :
11949:             ]
11957:          }
11959:       | * :
11964:    ];
      
      
11965: ReadlnStmt:      % ***
         % TO DO
11968:    ;
      
11968: ReadStmt:
         % TO DO
11971:    ;
      
      % -------------------------------- Utilities -------------------------------
      
      % Return the static scope level of the current scope
      %
11971: ScopeLevel >> int:
11973:    >> oNodeGetInt( oScopeCurrent, qLevel );
      
      % Return the static scope level of the given declaration
      %
11983: DeclLevel( Node decl ) >> int:
11985:    >> oNodeGetInt( oNodeGet( decl, qParentScope ), qLevel );
         
      
      % How many levels higher is the given declaration from the current scope?
      %
12003: DeclUpLevels( Node decl ) >> int:
12005:    >> subtract( @ScopeLevel, @DeclLevel( decl ) );
      
      
      % Require that the top two types on the type stack are matching (ignoring subranges).
      % Pop one of them, leaving only one.
      %
12021: MatchTypes:
12023:    node_type nt = oTypeSNodeType
12028:    oTypeSPop
12029:    [ equal_node_type( nt, oTypeSNodeType )
12038:       | false :
               % Some implicit conversion is allowed even here
12039:          [ oTypeSNodeType
12041:             | nPointerType :
12042:                [ nt
12045:                   | nUniversalPointerType :  >>
12047:                   | * :
12052:                ]
12052:             | nUniversalPointerType :
12054:                [ nt
12057:                   | nPointerType :  >>
12059:                   | * :
12064:                ]
12064:             | * :
12071:          ]
12071:          #eTypeMismatch
12073:       | * :
12078:    ];
      
      
      % Require that the top type on the type stack is integer (ignoring subranges).
      % Pop it.
      %
12079: RequireIntPop:
12081:    [ oTypeSNodeType
12083:       | nIntegerType :
12084:       | * :          #eNotInteger
12091:    ]
12091:    oTypeSPop;
      
12093: RequireInt:
12095:    [ oTypeSNodeType
12097:       | nIntegerType :
12098:       | * :          #eNotInteger
12105:    ];
      
      
      % Convert the top value to integer (if it isn't already).
      % It must be implicitly convertable to integer.
      % Pop the type stack.
      %
12106: PromoteToIntPop:
12108:    [ oTypeSNodeType
12110:       | nIntegerType :
12111:       | nByteType :        .tCastBtoI
12115:       | * :                #eNotInteger
12124:    ]
12124:    oTypeSPop;
      
      % Convert the top value to integer (if it isn't already).
      % It must be implicitly convertable to integer.
      % Leave integer on the type stack.
      %
12126: PromoteToInt:
12128:    [ oTypeSNodeType
12130:       | nIntegerType :
12131:       | nByteType :        .tCastBtoI
12135:                            oTypeSPop
12136:                            oTypeSPush( IntegerType )
12142:       | * :                #eNotInteger
12151:    ];
      
      
      % If the top value is implicitly convertable to integer, do so.
      % Otherwise leave it as-is.
      %
12152: PromoteToIntOptional:
12154:    [ oTypeSNodeType
12156:       | nByteType :        .tCastBtoI
12159:                            oTypeSPop
12160:                            oTypeSPush( IntegerType )
12166:       | * :
12171:    ];
      
      
      
      
12172: RequireBoolPop:
12174:    [ oTypeSNodeType
12176:       | nBooleanType :
12177:       | * :          #eNotBoolean
12184:    ]
12184:    oTypeSPop;
      
12186: RequireBool:
12188:    [ oTypeSNodeType
12190:       | nBooleanType :
12191:       | * :          #eNotBoolean
12198:    ];
      
      
      % Create and return a new nType of the given node_type, adding it to the type table.
      %
12199: newType( node_type nt, int size ) >> Node:
12201:   Node node = oNodeNew( nt )
12211:   oNodeSetInt( node, qSize, size )
12223:   oTypeAdd( node )
12229:   >> node
12233:   ;
      
      
      % Create and return a new nIdent of the given node_type, with the given ident id.
      % Does not add it to any scope.
      %
12233: newIdent( node_type nt, int id ) >> Node:
12235:   Node t = oNodeNew( nt )
12245:   oNodeSetInt( t, qIdent, id )
12257:   >> t
12261:   ;
      
      
      % Return an nType representing a pointer to the given type.
      % (Creates a new type if necessary.)
      %
12261: PointerTypeTo( Node theType ) >> Node:
12263:    Node ptrType = oNodeGet( theType, qPointerType )
12276:    [ oNodeNull( ptrType )
12283:       | true :
12284:          ptrType = oNodeNew( nPointerType )
12294:          oNodeSet( ptrType, qBaseType, theType )
12306:          oNodeSetInt( ptrType, qSize, 8 )
12318:          oTypeAdd( ptrType )
12324:          oNodeSet( theType, qPointerType, ptrType )
12336:       | * :
12341:    ]
12341:    >> ptrType;
      
      
      % Return the low value of an ordinal type
      %
12345: OrdinalLow( Node theType ) >> int:
12347:    [ oNodeType( theType )
12354:       | nIntegerType :  >> oMININT
12357:       | nBooleanType :  >> 0
12362:       | nCharType :     >> 0
12367:       | nEnumType :
12369:          Node enumScope = oNodeGet( theType, qScope )
12382:          Node first = oNodeIterValue( oNodeGetIter( enumScope, qDecls ) )
12399:          >> oNodeGetInt( first, qValue )
12409:       | nSubrangeType : >> oNodeGetInt( theType, qLow )
12421:       | * :             #eNotOrdinalType
12436:                         >> 0
12439:    ];
      
      
      % Return the high value of an ordinal type
      %
12440: OrdinalHigh( Node theType ) >> int:
12442:    [ oNodeType( theType )
12449:       | nIntegerType :  >> oMAXINT
12452:       | nBooleanType :  >> 1
12457:       | nCharType :     >> 255
12462:       | nEnumType :
12464:          Node enumScope = oNodeGet( theType, qScope )
12477:          Node last = oNodeIterValue( oNodeGetIterLast( enumScope, qDecls ) )
12494:          >> oNodeGetInt( last, qValue )
12504:       | nSubrangeType : >> oNodeGetInt( theType, qHigh )
12516:       | * :             #eNotOrdinalType
12531:                         >> 0
12534:    ];
      
      
      % Emit the value in a declaration.
      % For a constant integer, this is the constant value.
      % For a global variable, this is the global address.
      % For a local variable, this is the local address relative to the call stack frame.
      %
12535: EmitValue( Node decl ):
12537:     oEmitInt( oNodeGetInt( decl, qValue ));
      
      
12551: DeclareBuiltInFunc( int id ) >> Node:
12553:    Node decl = @newIdent( nBuiltInFunc, id )
12567:    oScopeDeclare( decl )
12573:    >> decl;
      
      
12577: installBuiltIns:
      
         % "mysystem" is the name of a unit that will be available everywhere.
         % Add its name to the id table so we can easily spot the name later.
12579:    mysystemId = oId_mysystem
      
         % install built-in types
12584:    FileType = @newType( nFileType, 4 )
12598:    IntegerType = @newType( nIntegerType, 4 )
12612:    BooleanType = @newType( nBooleanType, 1 )
12626:    BooleanFlowType = @newType( nBooleanFlowType, 1 )
12640:    CharType = @newType( nCharType, 1 )
12654:    PCharType = @PointerTypeTo( CharType )
12665:    ByteType = @newType( nByteType, 1 )
         % Universal pointer says base type Byte, but this is only for the sake of
         % pointer arithmetic.  It doesn't matter otherwise, because this type cannot be dereferened.
12679:    UniversalPointerType = @newType( nUniversalPointerType, 8 )
12693:    oNodeSet( UniversalPointerType, qBaseType, ByteType )
         % StrLitType is stored with both a length byte and null termination, so it can be assigned to
         % both a ShortString and a PChar.  StrLits longer than 255 characters appear truncated when
         % referenced as a ShortString, but not when referenced as a PChar.
12705:    StrLitType = @newType( nStrLitType, 256 )
         % ShortString is the original Pascal string type: an array of characters, not null-terminated,
         % with the first byte recording the current length.
         % The default ShortString type has capacity for 255 characters.  The user may define
         % additional ShortString types with smaller capacities.
         % The first character can be accessed as myString[1].
12719:    ShortStringType = @newType( nShortStringType, 256 )
12733:    oNodeSetInt( ShortStringType, qCapacity, 255 )
      
         % Declare those type identifiers.
         % SSL doesn't support strings, so need help from operations e.g. oId_File
      
12745:    Node t
      
12745:    t = @newIdent( nTypeDecl, oId_File )
12758:    oNodeSet( t, qType, FileType )
12770:    oScopeDeclare( t )
      
12776:    t = @newIdent( nTypeDecl, oId_Integer )
12789:    oNodeSet( t, qType, IntegerType )
12801:    oScopeDeclare( t )
      
12807:    t = @newIdent( nTypeDecl, oId_Boolean )
12820:    oNodeSet( t, qType, BooleanType )
12832:    oScopeDeclare( t )
      
12838:    t = @newIdent( nTypeDecl, oId_Char )
12851:    oNodeSet( t, qType, CharType )
12863:    oScopeDeclare( t )
      
12869:    t = @newIdent( nTypeDecl, oId_Byte )
12882:    oNodeSet( t, qType, ByteType )
12894:    oScopeDeclare( t )
      
12900:    t = @newIdent( nTypeDecl, oId_Pointer )
12913:    oNodeSet( t, qType, UniversalPointerType )
12925:    oScopeDeclare( t )
      
12931:    t = @newIdent( nTypeDecl, oId_ShortString )
12944:    oNodeSet( t, qType, ShortStringType )
12956:    oScopeDeclare( t )
      
         % Built-in constants
      
12962:    t = @newIdent( nConst, oId_True )
12975:    oNodeSet( t, qType, BooleanType )
12987:    oNodeSetInt( t, qValue, 1 )
12999:    oScopeDeclare( t )
      
13005:    t = @newIdent( nConst, oId_False )
13018:    oNodeSet( t, qType, BooleanType )
13030:    oNodeSetInt( t, qValue, 0 )
13042:    oScopeDeclare( t )
      
13048:    t = @newIdent( nConst, oId_Nil )
13061:    oNodeSet( t, qType, UniversalPointerType )
13073:    oNodeSetInt( t, qValue, 0 )
13085:    oScopeDeclare( t )
      
         % Built-in methods
         % These aren't declared like normal methods, because they may have
         % special rules for parameter types (e.g. any scalar type).
         % Calls to these methods will be handled specially by the compiler.
      
13091:    BuiltIn_Ord = @DeclareBuiltInFunc( oId_Ord )
13101:    BuiltIn_Chr = @DeclareBuiltInFunc( oId_Chr )
13111:    BuiltIn_Pred = @DeclareBuiltInFunc( oId_Pred )
13121:    BuiltIn_Succ = @DeclareBuiltInFunc( oId_Succ )
13132:    ;
      
13132: end
      
13132: 

Generated code:

   0: oGlobalSpace 22
   2: oLocalSpace 5
   4: oGetAddrGlobal 1
   6: oPushResult
   7: oWorkspaceNew
   8: oAssign
   9: oSetResult 0
  11: oPushResult
  12: oSetResult 0
  14: oPushResult
  15: oScopeBegin
  16: oPop 2
  18: oGetAddrLocal 2
  20: oPushResult
  21: oScopeCurrent
  22: oAssign
  23: oCall 12577
  25: oEmit 67
  27: oSetResult 0
  29: oPushResult
  30: oEmitInt
  31: oPop 1
  33: oGetAddrLocal 3
  35: oPushResult
  36: oLabelNew
  37: oAssign
  38: oEmit 61
  40: oSetResult 0
  42: oPushResult
  43: oEmitInt
  44: oPop 1
  46: oEmit 64
  48: oGetLocal 3
  50: oPushResult
  51: oEmitLabel
  52: oPop 1
  54: oEmit 63
  56: oSetResult 0
  58: oPushResult
  59: oEmitInt
  60: oPop 1
  62: oEmit 66
  64: oInput 28
  66: oInput 0
  68: oGetAddrLocal 4
  70: oPushResult
  71: oSetResult 4
  73: oPushResult
  74: oNodeNew
  75: oPop 1
  77: oAssign
  78: oGetLocal 4
  80: oPushResult
  81: oSetResult 4
  83: oPushResult
  84: LAST_ID
  85: oPushResult
  86: oNodeSetInt
  87: oPop 3
  89: oGetGlobal 1
  91: oPushResult
  92: oSetResult 2
  94: oPushResult
  95: oGetLocal 4
  97: oPushResult
  98: oNodeSet
  99: oPop 3
 101: oInputChoice 175
 103: oInput 0
 105: oGetAddrLocal 1
 107: oPushResult
 108: oSetResult 20
 110: oPushResult
 111: LAST_ID
 112: oPushResult
 113: oCall 12233
 115: oPop 2
 117: oAssign
 118: oGetLocal 1
 120: oPushResult
 121: oSetResult 21
 123: oPushResult
 124: oGetGlobal 5
 126: oPushResult
 127: oNodeSet
 128: oPop 3
 130: oGetLocal 1
 132: oPushResult
 133: oScopeDeclareAlloc
 134: oPop 1
 136: oInput 13
 138: oInput 0
 140: oGetAddrLocal 1
 142: oPushResult
 143: oSetResult 20
 145: oPushResult
 146: LAST_ID
 147: oPushResult
 148: oCall 12233
 150: oPop 2
 152: oAssign
 153: oGetLocal 1
 155: oPushResult
 156: oSetResult 21
 158: oPushResult
 159: oGetGlobal 5
 161: oPushResult
 162: oNodeSet
 163: oPop 3
 165: oGetLocal 1
 167: oPushResult
 168: oScopeDeclareAlloc
 169: oPop 1
 171: oInput 15
 173: oJumpForward 178
 175: Choice Lookup Table
          14    103
 178: oInput 5
 180: oGetLocal 4
 182: oPushResult
 183: oCall 333
 185: oPop 1
 187: oInputChoice 198
 189: oGetLocal 4
 191: oPushResult
 192: oCall 306
 194: oPop 1
 196: oJumpForward 201
 198: Choice Lookup Table
          59    189
 201: oGetLocal 4
 203: oPushResult
 204: oCall 586
 206: oPop 1
 208: oSetResult 0
 210: oPushResult
 211: oSetResult 0
 213: oPushResult
 214: oScopeBegin
 215: oPop 2
 217: oGetAddrGlobal 2
 219: oPushResult
 220: oScopeCurrent
 221: oAssign
 222: oSetResult 0
 224: oPushResult
 225: oSetResult 1
 227: oPushResult
 228: oScopeBegin
 229: oPop 2
 231: oScopeCurrent
 232: oPushResult
 233: oSetResult 16
 235: oPushResult
 236: oGetGlobal 2
 238: oPushResult
 239: oNodeSet
 240: oPop 3
 242: oGetAddrGlobal 3
 244: oPushResult
 245: oScopeCurrent
 246: oAssign
 247: oGetLocal 4
 249: oPushResult
 250: oSetResult 7
 252: oPushResult
 253: oGetGlobal 3
 255: oPushResult
 256: oNodeSet
 257: oPop 3
 259: oScopeEnd
 260: oSetResult 21
 262: oPushResult
 263: oCall 1543
 265: oPop 1
 267: oGetGlobal 3
 269: oPushResult
 270: oScopeEnter
 271: oPop 1
 273: oGetAddrLocal 5
 275: oPushResult
 276: oSetResult 1
 278: oAssign
 279: oGetLocal 3
 281: oPushResult
 282: oGetGlobal 2
 284: oPushResult
 285: oGetLocal 5
 287: oPushResult
 288: oCall 1864
 290: oPop 3
 292: oScopeEnd
 293: oInput 20
 295: oCall 1599
 297: oScopeEnd
 298: oGetLocal 4
 300: oPushResult
 301: oCall 648
 303: oPop 1
 305: oReturn
 306: oLocalSpace 0
 308: oInput 0
 310: LAST_ID
 311: oPushResult
 312: oGetParam 1
 314: oPushResult
 315: oCall 447
 317: oPop 2
 319: oInputChoice 323
 321: oJumpForward 328
 323: Choice Lookup Table
          13    321
 326: oJumpForward 330
 328: oJumpBack 308
 330: oInput 5
 332: oReturn
 333: oLocalSpace 0
 335: oGetParam 1
 337: oPushResult
 338: oSetResult 4
 340: oPushResult
 341: oNodeGetInt
 342: oPop 2
 344: oPushResult
 345: oGetGlobal 4
 347: oPushResult
 348: equal
 349: oPop 2
 351: oChoice 356
 353: oReturn
 354: oJumpForward 359
 356: Choice Lookup Table
           1    353
 359: oGetGlobal 4
 361: oPushResult
 362: oGetParam 1
 364: oPushResult
 365: oCall 447
 367: oPop 2
 369: oReturn
 370: oLocalSpace 0
 372: oGetParam 1
 374: oPushResult
 375: oSetResult 4
 377: oPushResult
 378: oNodeGetInt
 379: oPop 2
 381: oPushResult
 382: oGetGlobal 4
 384: oPushResult
 385: equal
 386: oPop 2
 388: oChoice 443
 390: oGetAddrGlobal 19
 392: oPushResult
 393: oScopeCurrent
 394: oPushResult
 395: oSetResult 15
 397: oPushResult
 398: oSetResult 4
 400: oPushResult
 401: oId_ShortStringAppendShortString
 402: oPushResult
 403: oNodeFind
 404: oPop 4
 406: oAssign
 407: oGetAddrGlobal 20
 409: oPushResult
 410: oScopeCurrent
 411: oPushResult
 412: oSetResult 15
 414: oPushResult
 415: oSetResult 4
 417: oPushResult
 418: oId_ShortStringAppendChar
 419: oPushResult
 420: oNodeFind
 421: oPop 4
 423: oAssign
 424: oGetAddrGlobal 21
 426: oPushResult
 427: oScopeCurrent
 428: oPushResult
 429: oSetResult 15
 431: oPushResult
 432: oSetResult 4
 434: oPushResult
 435: oId_ShortStringCmp
 436: oPushResult
 437: oNodeFind
 438: oPop 4
 440: oAssign
 441: oJumpForward 446
 443: Choice Lookup Table
           1    390
 446: oReturn
 447: oLocalSpace 2
 449: oGetAddrLocal 1
 451: oPushResult
 452: oGetParam 2
 454: oPushResult
 455: oCall 727
 457: oPop 1
 459: oAssign
 460: oGetLocal 1
 462: oPushResult
 463: oSetResult 0
 465: oPushResult
 466: equal_node
 467: oPop 2
 469: oChoice 539
 471: oGetParam 1
 473: oPushResult
 474: oSetResult 5
 476: oPushResult
 477: oGetLocal 1
 479: oPushResult
 480: oNodeAddLast
 481: oPop 3
 483: oGetAddrLocal 2
 485: oPushResult
 486: oSetResult 10
 488: oPushResult
 489: oNodeNew
 490: oPop 1
 492: oAssign
 493: oGetLocal 2
 495: oPushResult
 496: oSetResult 4
 498: oPushResult
 499: oGetLocal 1
 501: oPushResult
 502: oSetResult 4
 504: oPushResult
 505: oNodeGetInt
 506: oPop 2
 508: oPushResult
 509: oNodeSetInt
 510: oPop 3
 512: oGetLocal 2
 514: oPushResult
 515: oSetResult 9
 517: oPushResult
 518: oGetLocal 1
 520: oPushResult
 521: oSetResult 9
 523: oPushResult
 524: oNodeGet
 525: oPop 2
 527: oPushResult
 528: oNodeSet
 529: oPop 3
 531: oGetLocal 2
 533: oPushResult
 534: oScopeDeclare
 535: oPop 1
 537: oJumpForward 542
 539: Choice Lookup Table
           0    471
 542: oReturn
 543: oLocalSpace 1
 545: oGetFromParam 1
 547: oPushResult
 548: oNodeType
 549: oPop 1
 551: oChoice 582
 553: oGetAddrLocal 1
 555: oPushResult
 556: oGetFromParam 1
 558: oPushResult
 559: oSetResult 9
 561: oPushResult
 562: oNodeGet
 563: oPop 2
 565: oAssign
 566: oInput 20
 568: oInput 0
 570: oGetParam 1
 572: oPushResult
 573: oGetLocal 1
 575: oPushResult
 576: oScopeFindRequireInScope
 577: oPop 1
 579: oAssign
 580: oJumpForward 585
 582: Choice Lookup Table
          10    553
 585: oReturn
 586: oLocalSpace 2
 588: oGetAddrLocal 1
 590: oPushResult
 591: oGetParam 1
 593: oPushResult
 594: oSetResult 5
 596: oPushResult
 597: oNodeGetIter
 598: oPop 2
 600: oAssign
 601: oGetAddrLocal 2
 603: oPushResult
 604: oGetLocal 1
 606: oPushResult
 607: oNodeIterValue
 608: oPop 1
 610: oAssign
 611: oGetLocal 2
 613: oPushResult
 614: oNodeNull
 615: oPop 1
 617: oChoice 634
 619: oGetLocal 2
 621: oPushResult
 622: oSetResult 9
 624: oPushResult
 625: oNodeGet
 626: oPop 2
 628: oPushResult
 629: oScopeEnter
 630: oPop 1
 632: oJumpForward 639
 634: Choice Lookup Table
           0    619
 637: oJumpForward 647
 639: oGetAddrLocal 1
 641: oPushResult
 642: oNodeIterNext
 643: oPop 1
 645: oJumpBack 601
 647: oReturn
 648: oLocalSpace 2
 650: oGetAddrLocal 1
 652: oPushResult
 653: oGetParam 1
 655: oPushResult
 656: oSetResult 5
 658: oPushResult
 659: oNodeGetIterLast
 660: oPop 2
 662: oAssign
 663: oGetAddrLocal 2
 665: oPushResult
 666: oGetLocal 1
 668: oPushResult
 669: oNodeIterValue
 670: oPop 1
 672: oAssign
 673: oGetLocal 2
 675: oPushResult
 676: oNodeNull
 677: oPop 1
 679: oChoice 713
 681: oScopeCurrent
 682: oPushResult
 683: oGetLocal 2
 685: oPushResult
 686: oSetResult 9
 688: oPushResult
 689: oNodeGet
 690: oPop 2
 692: oPushResult
 693: oNodeEqual
 694: oPop 2
 696: oChoice 704
 698: oJumpForward 710
 700: oError 25
 702: oJumpForward 710
 704: Choice Lookup Table
           0    700
           1    698
 709: oEndChoice
 710: oScopeEnd
 711: oJumpForward 718
 713: Choice Lookup Table
           0    681
 716: oJumpForward 726
 718: oGetAddrLocal 1
 720: oPushResult
 721: oNodeIterPrev
 722: oPop 1
 724: oJumpBack 663
 726: oReturn
 727: oLocalSpace 2
 729: oGetAddrLocal 1
 731: oPushResult
 732: oGetGlobal 1
 734: oPushResult
 735: oSetResult 1
 737: oPushResult
 738: oSetResult 4
 740: oPushResult
 741: oGetParam 1
 743: oPushResult
 744: oNodeFind
 745: oPop 4
 747: oAssign
 748: oGetLocal 1
 750: oPushResult
 751: oSetResult 0
 753: oPushResult
 754: equal_node
 755: oPop 2
 757: oChoice 764
 759: oGetLocal 1
 761: oReturn
 762: oJumpForward 767
 764: Choice Lookup Table
           0    759
 767: oGetAddrLocal 2
 769: oPushResult
 770: oGetParam 1
 772: oPushResult
 773: oIncludeUnitFile
 774: oPop 1
 776: oAssign
 777: oGetLocal 2
 779: oChoice 788
 781: oError 24
 783: oSetResult 0
 785: oReturn
 786: oJumpForward 791
 788: Choice Lookup Table
           0    781
 791: oGetAddrLocal 1
 793: oPushResult
 794: oCall 802
 796: oAssign
 797: oIncludeEnd
 798: oGetLocal 1
 800: oReturn
 801: oReturn
 802: oLocalSpace 2
 804: oInput 60
 806: oInput 0
 808: oGetAddrLocal 1
 810: oPushResult
 811: oSetResult 5
 813: oPushResult
 814: oNodeNew
 815: oPop 1
 817: oAssign
 818: oGetLocal 1
 820: oPushResult
 821: oSetResult 4
 823: oPushResult
 824: LAST_ID
 825: oPushResult
 826: oNodeSetInt
 827: oPop 3
 829: oGetAddrLocal 2
 831: oPushResult
 832: oSetResult 6
 834: oPushResult
 835: oNodeNew
 836: oPop 1
 838: oAssign
 839: oGetLocal 2
 841: oPushResult
 842: oSetResult 4
 844: oPushResult
 845: LAST_ID
 846: oPushResult
 847: oNodeSetInt
 848: oPop 3
 850: oGetLocal 1
 852: oPushResult
 853: oSetResult 8
 855: oPushResult
 856: oGetLocal 2
 858: oPushResult
 859: oNodeSet
 860: oPop 3
 862: oInput 5
 864: oInput 61
 866: oGetLocal 1
 868: oPushResult
 869: oCall 333
 871: oPop 1
 873: oInputChoice 884
 875: oGetLocal 1
 877: oPushResult
 878: oCall 306
 880: oPop 1
 882: oJumpForward 887
 884: Choice Lookup Table
          59    875
 887: oGetLocal 1
 889: oPushResult
 890: oCall 586
 892: oPop 1
 894: oSetResult 0
 896: oPushResult
 897: oSetResult 0
 899: oPushResult
 900: oScopeBegin
 901: oPop 2
 903: oGetLocal 1
 905: oPushResult
 906: oSetResult 9
 908: oPushResult
 909: oScopeCurrent
 910: oPushResult
 911: oNodeSet
 912: oPop 3
 914: oGetAddrGlobal 2
 916: oPushResult
 917: oScopeCurrent
 918: oAssign
 919: oSetResult 0
 921: oPushResult
 922: oSetResult 1
 924: oPushResult
 925: oScopeBegin
 926: oPop 2
 928: oGetAddrGlobal 3
 930: oPushResult
 931: oScopeCurrent
 932: oAssign
 933: oGetLocal 1
 935: oPushResult
 936: oSetResult 13
 938: oPushResult
 939: oGetGlobal 3
 941: oPushResult
 942: oNodeSet
 943: oPop 3
 945: oScopeEnd
 946: oGetLocal 1
 948: oPushResult
 949: oCall 1137
 951: oPop 1
 953: oScopeEnd
 954: oInput 62
 956: oGetLocal 2
 958: oPushResult
 959: oCall 333
 961: oPop 1
 963: oInputChoice 974
 965: oGetLocal 2
 967: oPushResult
 968: oCall 306
 970: oPop 1
 972: oJumpForward 977
 974: Choice Lookup Table
          59    965
 977: oGetLocal 2
 979: oPushResult
 980: oCall 586
 982: oPop 1
 984: oGetLocal 1
 986: oPushResult
 987: oSetResult 9
 989: oPushResult
 990: oNodeGet
 991: oPop 2
 993: oPushResult
 994: oScopeEnter
 995: oPop 1
 997: oSetResult 0
 999: oPushResult
1000: oSetResult 0
1002: oPushResult
1003: oScopeBegin
1004: oPop 2
1006: oGetLocal 1
1008: oPushResult
1009: oSetResult 10
1011: oPushResult
1012: oScopeCurrent
1013: oPushResult
1014: oNodeSet
1015: oPop 3
1017: oScopeCurrent
1018: oPushResult
1019: oSetResult 16
1021: oPushResult
1022: oGetLocal 1
1024: oPushResult
1025: oSetResult 9
1027: oPushResult
1028: oNodeGet
1029: oPop 2
1031: oPushResult
1032: oNodeSet
1033: oPop 3
1035: oGetAddrGlobal 2
1037: oPushResult
1038: oScopeCurrent
1039: oAssign
1040: oGetLocal 1
1042: oPushResult
1043: oCall 1229
1045: oPop 1
1047: oInputChoice 1061
1049: oGetLocal 1
1051: oPushResult
1052: oSetResult 1
1054: oPushResult
1055: oCall 1239
1057: oPop 2
1059: oJumpForward 1074
1061: Choice Lookup Table
          63   1049
1064: oGetLocal 1
1066: oPushResult
1067: oSetResult 0
1069: oPushResult
1070: oCall 1239
1072: oPop 2
1074: oInputChoice 1088
1076: oGetLocal 1
1078: oPushResult
1079: oSetResult 1
1081: oPushResult
1082: oCall 1425
1084: oPop 2
1086: oJumpForward 1101
1088: Choice Lookup Table
          64   1076
1091: oGetLocal 1
1093: oPushResult
1094: oSetResult 0
1096: oPushResult
1097: oCall 1425
1099: oPop 2
1101: oInput 36
1103: oInput 20
1105: oScopeEnd
1106: oScopeEnd
1107: oGetLocal 2
1109: oPushResult
1110: oCall 648
1112: oPop 1
1114: oGetLocal 1
1116: oPushResult
1117: oCall 648
1119: oPop 1
1121: oGetGlobal 1
1123: oPushResult
1124: oSetResult 1
1126: oPushResult
1127: oGetLocal 1
1129: oPushResult
1130: oNodeAddLast
1131: oPop 3
1133: oGetLocal 1
1135: oReturn
1136: oReturn
1137: oLocalSpace 2
1139: oInputChoice 1206
1141: oCall 3137
1143: oJumpForward 1219
1145: oCall 3795
1147: oJumpForward 1219
1149: oSetResult 21
1151: oPushResult
1152: oCall 3851
1154: oPop 1
1156: oJumpForward 1219
1158: oGetAddrLocal 1
1160: oPushResult
1161: oCall 2104
1163: oAssign
1164: oInputChoice 1177
1166: oGetLocal 1
1168: oPushResult
1169: oCall 2042
1171: oPop 1
1173: oInput 5
1175: oJumpForward 1180
1177: Choice Lookup Table
          70   1166
1180: oJumpForward 1219
1182: oGetAddrLocal 2
1184: oPushResult
1185: oCall 2478
1187: oAssign
1188: oInputChoice 1201
1190: oGetLocal 2
1192: oPushResult
1193: oCall 2042
1195: oPop 1
1197: oInput 5
1199: oJumpForward 1204
1201: Choice Lookup Table
          70   1190
1204: oJumpForward 1219
1206: Choice Lookup Table
          30   1182
          29   1158
          33   1149
          32   1145
          31   1141
1217: oJumpForward 1221
1219: oJumpBack 1139
1221: oGetParam 1
1223: oPushResult
1224: oCall 370
1226: oPop 1
1228: oReturn
1229: oLocalSpace 0
1231: oSetResult 21
1233: oPushResult
1234: oCall 1543
1236: oPop 1
1238: oReturn
1239: oLocalSpace 5
1241: oGetAddrLocal 1
1243: oPushResult
1244: oLabelNew
1245: oAssign
1246: oEmit 77
1248: oGetLocal 1
1250: oPushResult
1251: oEmitLabel
1252: oPop 1
1254: oGetParam 2
1256: oPushResult
1257: oSetResult 11
1259: oPushResult
1260: oGetLocal 1
1262: oPushResult
1263: oNodeSetLabel
1264: oPop 3
1266: oEmit 67
1268: oGetAddrLocal 2
1270: oPushResult
1271: Here
1272: oAssign
1273: oEmit 90
1275: oGetAddrLocal 3
1277: oPushResult
1278: oGetParam 2
1280: oPushResult
1281: oSetResult 9
1283: oPushResult
1284: oNodeGet
1285: oPop 2
1287: oAssign
1288: oGetAddrLocal 4
1290: oPushResult
1291: oGetLocal 3
1293: oPushResult
1294: oSetResult 19
1296: oPushResult
1297: oNodeGetCode
1298: oPop 2
1300: oAssign
1301: oGetLocal 4
1303: oPushResult
1304: oEmitCode
1305: oPop 1
1307: oGetLocal 3
1309: oPushResult
1310: oSetResult 19
1312: oPushResult
1313: oSetResult 0
1315: oPushResult
1316: oNodeSetCode
1317: oPop 3
1319: oGetAddrLocal 3
1321: oPushResult
1322: oGetParam 2
1324: oPushResult
1325: oSetResult 10
1327: oPushResult
1328: oNodeGet
1329: oPop 2
1331: oAssign
1332: oGetAddrLocal 4
1334: oPushResult
1335: oGetLocal 3
1337: oPushResult
1338: oSetResult 19
1340: oPushResult
1341: oNodeGetCode
1342: oPop 2
1344: oAssign
1345: oGetLocal 4
1347: oPushResult
1348: oEmitCode
1349: oPop 1
1351: oGetLocal 3
1353: oPushResult
1354: oSetResult 19
1356: oPushResult
1357: oSetResult 0
1359: oPushResult
1360: oNodeSetCode
1361: oPop 3
1363: oGetParam 2
1365: oPushResult
1366: oSetResult 13
1368: oPushResult
1369: oNodeGet
1370: oPop 2
1372: oPushResult
1373: oScopeEnter
1374: oPop 1
1376: oGetParam 1
1378: oChoice 1397
1380: oCall 10371
1382: oInputChoice 1388
1384: oCall 10371
1386: oJumpForward 1393
1388: Choice Lookup Table
           5   1384
1391: oJumpForward 1395
1393: oJumpBack 1382
1395: oJumpForward 1400
1397: Choice Lookup Table
           1   1380
1400: oEmit 66
1402: oGetAddrLocal 5
1404: oPushResult
1405: oScopeCurrent
1406: oPushResult
1407: oSetResult 17
1409: oPushResult
1410: oNodeGetInt
1411: oPop 2
1413: oAssign
1414: oGetLocal 2
1416: oPushResult
1417: oGetLocal 5
1419: oPushResult
1420: oPatch
1421: oPop 2
1423: oScopeEnd
1424: oReturn
1425: oLocalSpace 3
1427: oGetAddrLocal 1
1429: oPushResult
1430: oLabelNew
1431: oAssign
1432: oEmit 77
1434: oGetLocal 1
1436: oPushResult
1437: oEmitLabel
1438: oPop 1
1440: oGetParam 2
1442: oPushResult
1443: oSetResult 12
1445: oPushResult
1446: oGetLocal 1
1448: oPushResult
1449: oNodeSetLabel
1450: oPop 3
1452: oEmit 67
1454: oGetAddrLocal 2
1456: oPushResult
1457: Here
1458: oAssign
1459: oEmit 90
1461: oSetResult 0
1463: oPushResult
1464: oSetResult 1
1466: oPushResult
1467: oScopeBegin
1468: oPop 2
1470: oGetParam 1
1472: oChoice 1491
1474: oCall 10371
1476: oInputChoice 1482
1478: oCall 10371
1480: oJumpForward 1487
1482: Choice Lookup Table
           5   1478
1485: oJumpForward 1489
1487: oJumpBack 1476
1489: oJumpForward 1494
1491: Choice Lookup Table
           1   1474
1494: oEmit 66
1496: oGetAddrLocal 3
1498: oPushResult
1499: oScopeCurrent
1500: oPushResult
1501: oSetResult 17
1503: oPushResult
1504: oNodeGetInt
1505: oPop 2
1507: oAssign
1508: oGetLocal 2
1510: oPushResult
1511: oGetLocal 3
1513: oPushResult
1514: oPatch
1515: oPop 2
1517: oScopeEnd
1518: oReturn
1519: oLocalSpace 0
1521: oGetParam 2
1523: oPushResult
1524: oCall 1543
1526: oPop 1
1528: oGetParam 1
1530: oPushResult
1531: oScopeCurrent
1532: oPushResult
1533: oSetResult 0
1535: oPushResult
1536: oCall 1864
1538: oPop 3
1540: oCall 1599
1542: oReturn
1543: oLocalSpace 0
1545: oInputChoice 1576
1547: oCall 3137
1549: oJumpForward 1591
1551: oCall 3795
1553: oJumpForward 1591
1555: oGetParam 1
1557: oPushResult
1558: oCall 3851
1560: oPop 1
1562: oJumpForward 1591
1564: oCall 4085
1566: oJumpForward 1591
1568: oCall 2360
1570: oJumpForward 1591
1572: oCall 2795
1574: oJumpForward 1591
1576: Choice Lookup Table
          30   1572
          29   1568
          34   1564
          33   1555
          32   1551
          31   1547
1589: oJumpForward 1593
1591: oJumpBack 1545
1593: oCall 1596
1595: oReturn
1596: oLocalSpace 0
1598: oReturn
1599: oLocalSpace 2
1601: oGetAddrLocal 1
1603: oPushResult
1604: oScopeCurrent
1605: oPushResult
1606: oSetResult 15
1608: oPushResult
1609: oNodeGetIter
1610: oPop 2
1612: oAssign
1613: oGetAddrLocal 2
1615: oPushResult
1616: oGetLocal 1
1618: oPushResult
1619: oNodeIterValue
1620: oPop 1
1622: oAssign
1623: oGetLocal 2
1625: oPushResult
1626: oNodeNull
1627: oPop 1
1629: oChoice 1633
1631: oJumpForward 1638
1633: Choice Lookup Table
           0   1631
1636: oJumpForward 1693
1638: oGetLocal 2
1640: oPushResult
1641: oNodeType
1642: oPop 1
1644: oChoice 1682
1646: oGetLocal 2
1648: oPushResult
1649: oSetResult 35
1651: oPushResult
1652: oNodeGetBoolean
1653: oPop 2
1655: oChoice 1677
1657: oGetLocal 2
1659: oPushResult
1660: oSetResult 28
1662: oPushResult
1663: oNodeGetBoolean
1664: oPop 2
1666: oChoice 1672
1668: oError 27
1670: oJumpForward 1675
1672: Choice Lookup Table
           1   1668
1675: oJumpForward 1680
1677: Choice Lookup Table
           0   1657
1680: oJumpForward 1685
1682: Choice Lookup Table
          26   1646
1685: oGetAddrLocal 1
1687: oPushResult
1688: oNodeIterNext
1689: oPop 1
1691: oJumpBack 1613
1693: oReturn
1694: oLocalSpace 2
1696: oGetAddrLocal 1
1698: oPushResult
1699: oGetGlobal 1
1701: oPushResult
1702: oSetResult 1
1704: oPushResult
1705: oNodeGetIter
1706: oPop 2
1708: oAssign
1709: oGetAddrLocal 2
1711: oPushResult
1712: oGetLocal 1
1714: oPushResult
1715: oNodeIterValue
1716: oPop 1
1718: oAssign
1719: oGetLocal 2
1721: oPushResult
1722: oNodeNull
1723: oPop 1
1725: oChoice 1770
1727: oJumpForward 1778
1729: oJumpForward 1776
1731: oEmit 61
1733: oSetResult 0
1735: oPushResult
1736: oEmitInt
1737: oPop 1
1739: oEmit 64
1741: oGetLocal 2
1743: oPushResult
1744: oSetResult 11
1746: oPushResult
1747: oNodeGetLabel
1748: oPop 2
1750: oPushResult
1751: oEmitLabel
1752: oPop 1
1754: oEmit 63
1756: oSetResult 0
1758: oPushResult
1759: oEmitInt
1760: oPop 1
1762: oGetAddrLocal 1
1764: oPushResult
1765: oNodeIterNext
1766: oPop 1
1768: oJumpForward 1776
1770: Choice Lookup Table
           0   1731
           1   1727
1775: oEndChoice
1776: oJumpBack 1709
1778: oReturn
1779: oLocalSpace 2
1781: oGetAddrLocal 1
1783: oPushResult
1784: oGetGlobal 1
1786: oPushResult
1787: oSetResult 1
1789: oPushResult
1790: oNodeGetIterLast
1791: oPop 2
1793: oAssign
1794: oGetAddrLocal 2
1796: oPushResult
1797: oGetLocal 1
1799: oPushResult
1800: oNodeIterValue
1801: oPop 1
1803: oAssign
1804: oGetLocal 2
1806: oPushResult
1807: oNodeNull
1808: oPop 1
1810: oChoice 1855
1812: oJumpForward 1863
1814: oJumpForward 1861
1816: oEmit 61
1818: oSetResult 0
1820: oPushResult
1821: oEmitInt
1822: oPop 1
1824: oEmit 64
1826: oGetLocal 2
1828: oPushResult
1829: oSetResult 12
1831: oPushResult
1832: oNodeGetLabel
1833: oPop 2
1835: oPushResult
1836: oEmitLabel
1837: oPop 1
1839: oEmit 63
1841: oSetResult 0
1843: oPushResult
1844: oEmitInt
1845: oPop 1
1847: oGetAddrLocal 1
1849: oPushResult
1850: oNodeIterPrev
1851: oPop 1
1853: oJumpForward 1861
1855: Choice Lookup Table
           0   1816
           1   1812
1860: oEndChoice
1861: oJumpBack 1794
1863: oReturn
1864: oLocalSpace 3
1866: oEmit 77
1868: oGetParam 3
1870: oPushResult
1871: oEmitLabel
1872: oPop 1
1874: oEmit 67
1876: oGetAddrLocal 1
1878: oPushResult
1879: Here
1880: oAssign
1881: oEmit 90
1883: oGetParam 1
1885: oChoice 1891
1887: oCall 1694
1889: oJumpForward 1894
1891: Choice Lookup Table
           1   1887
1894: oGetAddrLocal 2
1896: oPushResult
1897: oGetParam 2
1899: oPushResult
1900: oSetResult 19
1902: oPushResult
1903: oNodeGetCode
1904: oPop 2
1906: oAssign
1907: oGetLocal 2
1909: oPushResult
1910: oEmitCode
1911: oPop 1
1913: oGetParam 2
1915: oPushResult
1916: oSetResult 19
1918: oPushResult
1919: oSetResult 0
1921: oPushResult
1922: oNodeSetCode
1923: oPop 3
1925: oCall 10371
1927: oGetParam 1
1929: oChoice 1935
1931: oCall 1779
1933: oJumpForward 1938
1935: Choice Lookup Table
           1   1931
1938: oEmit 66
1940: oGetAddrLocal 3
1942: oPushResult
1943: oScopeCurrent
1944: oPushResult
1945: oSetResult 17
1947: oPushResult
1948: oNodeGetInt
1949: oPop 2
1951: oAssign
1952: oGetLocal 1
1954: oPushResult
1955: oGetLocal 3
1957: oPushResult
1958: oPatch
1959: oPop 2
1961: oReturn
1962: oLocalSpace 0
1964: oInputChoice 1982
1966: oGetParam 1
1968: oPushResult
1969: oSetResult 27
1971: oPushResult
1972: oSetResult 1
1974: oPushResult
1975: oNodeSetBoolean
1976: oPop 3
1978: oInput 5
1980: oJumpForward 1987
1982: Choice Lookup Table
          72   1966
1985: oJumpForward 1989
1987: oJumpBack 1964
1989: oReturn
1990: oLocalSpace 1
1992: oGetAddrLocal 1
1994: oPushResult
1995: oGetParam 1
1997: oPushResult
1998: oSetResult 19
2000: oPushResult
2001: oNodeGetCode
2002: oPop 2
2004: oAssign
2005: oGetLocal 1
2007: oPushResult
2008: oSetResult 0
2010: oPushResult
2011: equal_code
2012: oPop 2
2014: oChoice 2035
2016: oGetAddrLocal 1
2018: oPushResult
2019: oCodeNew
2020: oAssign
2021: oGetParam 1
2023: oPushResult
2024: oSetResult 19
2026: oPushResult
2027: oGetLocal 1
2029: oPushResult
2030: oNodeSetCode
2031: oPop 3
2033: oJumpForward 2038
2035: Choice Lookup Table
           1   2016
2038: oGetLocal 1
2040: oReturn
2041: oReturn
2042: oLocalSpace 0
2044: oGetParam 1
2046: oPushResult
2047: oCall 11983
2049: oPop 1
2051: oPushResult
2052: equal_zero
2053: oPop 1
2055: oChoice 2061
2057: oError 23
2059: oJumpForward 2064
2061: Choice Lookup Table
           0   2057
2064: oGetParam 1
2066: oPushResult
2067: oSetResult 25
2069: oPushResult
2070: oSetResult 1
2072: oPushResult
2073: oNodeSetBoolean
2074: oPop 3
2076: oInputChoice 2100
2078: oInputChoice 2095
2080: oInput 2
2082: oGetParam 1
2084: oPushResult
2085: oSetResult 26
2087: oPushResult
2088: CURRENT_STRLIT
2089: oPushResult
2090: oNodeSetString
2091: oPop 3
2093: oJumpForward 2098
2095: Choice Lookup Table
          71   2080
2098: oJumpForward 2103
2100: Choice Lookup Table
           2   2078
2103: oReturn
2104: oLocalSpace 6
2106: oInput 0
2108: oGetAddrLocal 1
2110: oPushResult
2111: oSetResult 0
2113: oAssign
2114: oGetAddrLocal 2
2116: oPushResult
2117: oScopeFindInCurrentScope
2118: oAssign
2119: oGetLocal 2
2121: oPushResult
2122: oNodeNull
2123: oPop 1
2125: oChoice 2243
2127: oGetAddrLocal 2
2129: oPushResult
2130: oSetResult 12
2132: oPushResult
2133: LAST_ID
2134: oPushResult
2135: oCall 12233
2137: oPop 2
2139: oAssign
2140: oGetLocal 2
2142: oPushResult
2143: oSetResult 22
2145: oPushResult
2146: oLabelNew
2147: oPushResult
2148: oNodeSetLabel
2149: oPop 3
2151: oJumpForward 2249
2153: oGetAddrLocal 1
2155: oPushResult
2156: oSetResult 1
2158: oAssign
2159: oGetLocal 2
2161: oPushResult
2162: oSetResult 24
2164: oPushResult
2165: oNodeGetBoolean
2166: oPop 2
2168: oChoice 2174
2170: oError 21
2172: oJumpForward 2177
2174: Choice Lookup Table
           1   2170
2177: oGetLocal 2
2179: oPushResult
2180: oSetResult 25
2182: oPushResult
2183: oNodeGetBoolean
2184: oPop 2
2186: oChoice 2192
2188: oError 21
2190: oJumpForward 2195
2192: Choice Lookup Table
           1   2188
2195: oGetLocal 2
2197: oPushResult
2198: oNodeType
2199: oPop 1
2201: oChoice 2205
2203: oJumpForward 2210
2205: Choice Lookup Table
          12   2203
2208: oError 21
2210: oGetLocal 2
2212: oPushResult
2213: oSetResult 29
2215: oPushResult
2216: oGetLocal 2
2218: oPushResult
2219: oSetResult 23
2221: oPushResult
2222: oNodeGet
2223: oPop 2
2225: oPushResult
2226: oNodeSet
2227: oPop 3
2229: oGetLocal 2
2231: oPushResult
2232: oSetResult 23
2234: oPushResult
2235: oSetResult 0
2237: oPushResult
2238: oNodeSet
2239: oPop 3
2241: oJumpForward 2249
2243: Choice Lookup Table
           0   2153
           1   2127
2248: oEndChoice
2249: oGetAddrLocal 3
2251: oPushResult
2252: oCall 11971
2254: oAssign
2255: oGetAddrLocal 4
2257: oPushResult
2258: oGetLocal 3
2260: oPushResult
2261: oSetResult 0
2263: oPushResult
2264: greater
2265: oPop 2
2267: oAssign
2268: oGetAddrLocal 3
2270: oPushResult
2271: inc
2272: oPop 1
2274: oGetLocal 3
2276: oPushResult
2277: oSetResult 2
2279: oPushResult
2280: oScopeBegin
2281: oPop 2
2283: oGetAddrLocal 5
2285: oPushResult
2286: oScopeCurrent
2287: oAssign
2288: oGetLocal 4
2290: oChoice 2309
2292: oGetAddrLocal 6
2294: oPushResult
2295: oGetGlobal 6
2297: oPushResult
2298: oCall 12261
2300: oPop 1
2302: oPushResult
2303: oScopeAllocType
2304: oPop 1
2306: oAssign
2307: oJumpForward 2312
2309: Choice Lookup Table
           1   2292
2312: oCall 2913
2314: oGetLocal 2
2316: oPushResult
2317: oSetResult 23
2319: oPushResult
2320: oGetLocal 5
2322: oPushResult
2323: oNodeSet
2324: oPop 3
2326: oScopeEnd
2327: oInput 5
2329: oGetLocal 1
2331: oChoice 2343
2333: oGetLocal 2
2335: oPushResult
2336: oScopeDeclare
2337: oPop 1
2339: oJumpForward 2349
2341: oJumpForward 2349
2343: Choice Lookup Table
           1   2341
           0   2333
2348: oEndChoice
2349: oGetLocal 2
2351: oPushResult
2352: oCall 1962
2354: oPop 1
2356: oGetLocal 2
2358: oReturn
2359: oReturn
2360: oLocalSpace 4
2362: oGetAddrLocal 1
2364: oPushResult
2365: oCall 2104
2367: oAssign
2368: oInputChoice 2381
2370: oJumpForward 2475
2372: oGetLocal 1
2374: oPushResult
2375: oCall 2042
2377: oPop 1
2379: oJumpForward 2475
2381: Choice Lookup Table
          70   2372
          69   2370
2386: oGetAddrLocal 2
2388: oPushResult
2389: oGetLocal 1
2391: oPushResult
2392: oSetResult 23
2394: oPushResult
2395: oNodeGet
2396: oPop 2
2398: oAssign
2399: oGetLocal 2
2401: oPushResult
2402: oScopeEnter
2403: oPop 1
2405: oGetAddrLocal 3
2407: oPushResult
2408: oGetLocal 2
2410: oPushResult
2411: oSetResult 14
2413: oPushResult
2414: oNodeGetInt
2415: oPop 2
2417: oAssign
2418: oGetLocal 3
2420: oPushResult
2421: oSetResult 1
2423: oPushResult
2424: oScopeBegin
2425: oPop 2
2427: oGetLocal 1
2429: oPushResult
2430: oSetResult 6
2432: oPushResult
2433: oScopeCurrent
2434: oPushResult
2435: oNodeSet
2436: oPop 3
2438: oGetAddrLocal 4
2440: oPushResult
2441: oGetLocal 1
2443: oPushResult
2444: oSetResult 22
2446: oPushResult
2447: oNodeGetLabel
2448: oPop 2
2450: oAssign
2451: oSetResult 22
2453: oPushResult
2454: oGetLocal 4
2456: oPushResult
2457: oCall 1519
2459: oPop 2
2461: oGetLocal 1
2463: oPushResult
2464: oSetResult 24
2466: oPushResult
2467: oSetResult 1
2469: oPushResult
2470: oNodeSetBoolean
2471: oPop 3
2473: oScopeEnd
2474: oScopeEnd
2475: oInput 5
2477: oReturn
2478: oLocalSpace 8
2480: oInput 0
2482: oGetAddrLocal 1
2484: oPushResult
2485: oSetResult 0
2487: oAssign
2488: oGetAddrLocal 2
2490: oPushResult
2491: oScopeFindInCurrentScope
2492: oAssign
2493: oGetLocal 2
2495: oPushResult
2496: oNodeNull
2497: oPop 1
2499: oChoice 2630
2501: oGetAddrLocal 2
2503: oPushResult
2504: oSetResult 13
2506: oPushResult
2507: LAST_ID
2508: oPushResult
2509: oCall 12233
2511: oPop 2
2513: oAssign
2514: oGetLocal 2
2516: oPushResult
2517: oSetResult 22
2519: oPushResult
2520: oLabelNew
2521: oPushResult
2522: oNodeSetLabel
2523: oPop 3
2525: oJumpForward 2636
2527: oGetAddrLocal 1
2529: oPushResult
2530: oSetResult 1
2532: oAssign
2533: oGetLocal 2
2535: oPushResult
2536: oSetResult 24
2538: oPushResult
2539: oNodeGetBoolean
2540: oPop 2
2542: oChoice 2548
2544: oError 21
2546: oJumpForward 2551
2548: Choice Lookup Table
           1   2544
2551: oGetLocal 2
2553: oPushResult
2554: oNodeType
2555: oPop 1
2557: oChoice 2561
2559: oJumpForward 2566
2561: Choice Lookup Table
          13   2559
2564: oError 21
2566: oGetLocal 2
2568: oPushResult
2569: oSetResult 29
2571: oPushResult
2572: oGetLocal 2
2574: oPushResult
2575: oSetResult 23
2577: oPushResult
2578: oNodeGet
2579: oPop 2
2581: oPushResult
2582: oNodeSet
2583: oPop 3
2585: oGetLocal 2
2587: oPushResult
2588: oSetResult 23
2590: oPushResult
2591: oSetResult 0
2593: oPushResult
2594: oNodeSet
2595: oPop 3
2597: oGetLocal 2
2599: oPushResult
2600: oSetResult 30
2602: oPushResult
2603: oGetLocal 2
2605: oPushResult
2606: oSetResult 21
2608: oPushResult
2609: oNodeGet
2610: oPop 2
2612: oPushResult
2613: oNodeSet
2614: oPop 3
2616: oGetLocal 2
2618: oPushResult
2619: oSetResult 21
2621: oPushResult
2622: oSetResult 0
2624: oPushResult
2625: oNodeSet
2626: oPop 3
2628: oJumpForward 2636
2630: Choice Lookup Table
           0   2527
           1   2501
2635: oEndChoice
2636: oGetAddrLocal 3
2638: oPushResult
2639: oCall 11971
2641: oAssign
2642: oGetAddrLocal 4
2644: oPushResult
2645: oGetLocal 3
2647: oPushResult
2648: oSetResult 0
2650: oPushResult
2651: greater
2652: oPop 2
2654: oAssign
2655: oGetAddrLocal 3
2657: oPushResult
2658: inc
2659: oPop 1
2661: oGetLocal 3
2663: oPushResult
2664: oSetResult 2
2666: oPushResult
2667: oScopeBegin
2668: oPop 2
2670: oGetAddrLocal 5
2672: oPushResult
2673: oScopeCurrent
2674: oAssign
2675: oGetLocal 4
2677: oChoice 2696
2679: oGetAddrLocal 6
2681: oPushResult
2682: oGetGlobal 6
2684: oPushResult
2685: oCall 12261
2687: oPop 1
2689: oPushResult
2690: oScopeAllocType
2691: oPop 1
2693: oAssign
2694: oJumpForward 2699
2696: Choice Lookup Table
           1   2679
2699: oCall 2913
2701: oGetLocal 2
2703: oPushResult
2704: oSetResult 23
2706: oPushResult
2707: oGetLocal 5
2709: oPushResult
2710: oNodeSet
2711: oPop 3
2713: oInput 12
2715: oGetAddrLocal 7
2717: oPushResult
2718: oCall 4150
2720: oPop 1
2722: oGetLocal 2
2724: oPushResult
2725: oSetResult 21
2727: oPushResult
2728: oGetLocal 7
2730: oPushResult
2731: oNodeSet
2732: oPop 3
2734: oGetAddrLocal 8
2736: oPushResult
2737: oGetLocal 7
2739: oPushResult
2740: oCall 12261
2742: oPop 1
2744: oAssign
2745: oGetLocal 2
2747: oPushResult
2748: oSetResult 31
2750: oPushResult
2751: oGetLocal 8
2753: oPushResult
2754: oScopeAllocType
2755: oPop 1
2757: oPushResult
2758: oNodeSetInt
2759: oPop 3
2761: oScopeEnd
2762: oInput 5
2764: oGetLocal 1
2766: oChoice 2778
2768: oGetLocal 2
2770: oPushResult
2771: oScopeDeclare
2772: oPop 1
2774: oJumpForward 2784
2776: oJumpForward 2784
2778: Choice Lookup Table
           1   2776
           0   2768
2783: oEndChoice
2784: oGetLocal 2
2786: oPushResult
2787: oCall 1962
2789: oPop 1
2791: oGetLocal 2
2793: oReturn
2794: oReturn
2795: oLocalSpace 4
2797: oGetAddrLocal 1
2799: oPushResult
2800: oCall 2478
2802: oAssign
2803: oInputChoice 2816
2805: oJumpForward 2910
2807: oGetLocal 1
2809: oPushResult
2810: oCall 2042
2812: oPop 1
2814: oJumpForward 2910
2816: Choice Lookup Table
          70   2807
          69   2805
2821: oGetAddrLocal 2
2823: oPushResult
2824: oGetLocal 1
2826: oPushResult
2827: oSetResult 23
2829: oPushResult
2830: oNodeGet
2831: oPop 2
2833: oAssign
2834: oGetLocal 2
2836: oPushResult
2837: oScopeEnter
2838: oPop 1
2840: oGetAddrLocal 3
2842: oPushResult
2843: oGetLocal 2
2845: oPushResult
2846: oSetResult 14
2848: oPushResult
2849: oNodeGetInt
2850: oPop 2
2852: oAssign
2853: oGetLocal 3
2855: oPushResult
2856: oSetResult 1
2858: oPushResult
2859: oScopeBegin
2860: oPop 2
2862: oGetLocal 1
2864: oPushResult
2865: oSetResult 6
2867: oPushResult
2868: oScopeCurrent
2869: oPushResult
2870: oNodeSet
2871: oPop 3
2873: oGetAddrLocal 4
2875: oPushResult
2876: oGetLocal 1
2878: oPushResult
2879: oSetResult 22
2881: oPushResult
2882: oNodeGetLabel
2883: oPop 2
2885: oAssign
2886: oSetResult 22
2888: oPushResult
2889: oGetLocal 4
2891: oPushResult
2892: oCall 1519
2894: oPop 2
2896: oGetLocal 1
2898: oPushResult
2899: oSetResult 24
2901: oPushResult
2902: oSetResult 1
2904: oPushResult
2905: oNodeSetBoolean
2906: oPop 3
2908: oScopeEnd
2909: oScopeEnd
2910: oInput 5
2912: oReturn
2913: oLocalSpace 6
2915: oInputChoice 3133
2917: oGetAddrLocal 1
2919: oPushResult
2920: oNodeVecNew
2921: oAssign
2922: oGetAddrLocal 3
2924: oPushResult
2925: oSetResult 0
2927: oAssign
2928: oInputChoice 2938
2930: oGetAddrLocal 3
2932: oPushResult
2933: oSetResult 1
2935: oAssign
2936: oJumpForward 2941
2938: Choice Lookup Table
          33   2930
2941: oInput 0
2943: oGetAddrLocal 2
2945: oPushResult
2946: oSetResult 24
2948: oPushResult
2949: LAST_ID
2950: oPushResult
2951: oCall 12233
2953: oPop 2
2955: oAssign
2956: oGetLocal 2
2958: oPushResult
2959: oSetResult 34
2961: oPushResult
2962: oGetLocal 3
2964: oPushResult
2965: oNodeSetBoolean
2966: oPop 3
2968: oGetLocal 1
2970: oPushResult
2971: oGetLocal 2
2973: oPushResult
2974: oNodeVecAppend
2975: oPop 2
2977: oInputChoice 2985
2979: oJumpForward 2993
2981: oJumpForward 2991
2983: oJumpForward 2991
2985: Choice Lookup Table
          13   2983
          12   2979
2990: oEndChoice
2991: oJumpBack 2941
2993: oGetAddrLocal 4
2995: oPushResult
2996: oCall 4150
2998: oPop 1
3000: oGetLocal 3
3002: oChoice 3017
3004: oGetAddrLocal 5
3006: oPushResult
3007: oGetLocal 4
3009: oPushResult
3010: oCall 12261
3012: oPop 1
3014: oAssign
3015: oJumpForward 3026
3017: Choice Lookup Table
           1   3004
3020: oGetAddrLocal 5
3022: oPushResult
3023: oGetLocal 4
3025: oAssign
3026: oGetAddrLocal 6
3028: oPushResult
3029: oSetResult 0
3031: oAssign
3032: oGetLocal 6
3034: oPushResult
3035: oGetLocal 1
3037: oPushResult
3038: oNodeVecSize
3039: oPop 1
3041: oPushResult
3042: equal
3043: oPop 2
3045: oChoice 3102
3047: oGetAddrLocal 2
3049: oPushResult
3050: oGetLocal 1
3052: oPushResult
3053: oGetLocal 6
3055: oPushResult
3056: oNodeVecElement
3057: oPop 2
3059: oAssign
3060: oGetLocal 2
3062: oPushResult
3063: oSetResult 21
3065: oPushResult
3066: oGetLocal 4
3068: oPushResult
3069: oNodeSet
3070: oPop 3
3072: oGetLocal 2
3074: oPushResult
3075: oScopeDeclare
3076: oPop 1
3078: oGetLocal 2
3080: oPushResult
3081: oSetResult 22
3083: oPushResult
3084: oGetLocal 5
3086: oPushResult
3087: oScopeAllocType
3088: oPop 1
3090: oPushResult
3091: oNodeSetInt
3092: oPop 3
3094: oGetAddrLocal 6
3096: oPushResult
3097: inc
3098: oPop 1
3100: oJumpForward 3107
3102: Choice Lookup Table
           0   3047
3105: oJumpForward 3109
3107: oJumpBack 3032
3109: oGetLocal 1
3111: oPushResult
3112: oNodeVecDelete
3113: oPop 1
3115: oInputChoice 3123
3117: oJumpForward 3131
3119: oJumpForward 3129
3121: oJumpForward 3129
3123: Choice Lookup Table
           5   3121
          15   3117
3128: oEndChoice
3129: oJumpBack 2917
3131: oJumpForward 3136
3133: Choice Lookup Table
          14   2917
3136: oReturn
3137: oLocalSpace 0
3139: oInputChoice 3154
3141: oInputChoice 3147
3143: oCall 3271
3145: oJumpForward 3152
3147: Choice Lookup Table
          12   3143
3150: oCall 3162
3152: oJumpForward 3159
3154: Choice Lookup Table
           0   3141
3157: oJumpForward 3161
3159: oJumpBack 3139
3161: oReturn
3162: oLocalSpace 2
3164: oGetAddrLocal 1
3166: oPushResult
3167: LAST_ID
3168: oAssign
3169: oInput 6
3171: oCall 5229
3173: oTypeSNodeType
3174: oChoice 3230
3176: oGetAddrLocal 2
3178: oPushResult
3179: oSetResult 16
3181: oPushResult
3182: oGetLocal 1
3184: oPushResult
3185: oCall 12233
3187: oPop 2
3189: oAssign
3190: oGetLocal 2
3192: oPushResult
3193: oSetResult 22
3195: oPushResult
3196: oValueTop
3197: oPushResult
3198: oNodeSetInt
3199: oPop 3
3201: oJumpForward 3249
3203: oGetAddrLocal 2
3205: oPushResult
3206: oSetResult 18
3208: oPushResult
3209: oGetLocal 1
3211: oPushResult
3212: oCall 12233
3214: oPop 2
3216: oAssign
3217: oGetLocal 2
3219: oPushResult
3220: oSetResult 33
3222: oPushResult
3223: oValueTopString
3224: oPushResult
3225: oNodeSetString
3226: oPop 3
3228: oJumpForward 3249
3230: Choice Lookup Table
          39   3203
          35   3176
          34   3176
          41   3176
          29   3176
          33   3176
          30   3176
          31   3176
3247: oError 17
3249: oValuePop
3250: oGetLocal 2
3252: oPushResult
3253: oSetResult 21
3255: oPushResult
3256: oTypeSTop
3257: oPushResult
3258: oNodeSet
3259: oPop 3
3261: oTypeSPop
3262: oGetLocal 2
3264: oPushResult
3265: oScopeDeclare
3266: oPop 1
3268: oInput 5
3270: oReturn
3271: oLocalSpace 3
3273: oGetAddrLocal 1
3275: oPushResult
3276: oSetResult 25
3278: oPushResult
3279: LAST_ID
3280: oPushResult
3281: oCall 12233
3283: oPop 2
3285: oAssign
3286: oGetAddrLocal 2
3288: oPushResult
3289: oCall 4150
3291: oPop 1
3293: oGetLocal 1
3295: oPushResult
3296: oSetResult 21
3298: oPushResult
3299: oGetLocal 2
3301: oPushResult
3302: oNodeSet
3303: oPop 3
3305: oGetLocal 2
3307: oPushResult
3308: oNodeType
3309: oPop 1
3311: oChoice 3415
3313: oInput 6
3315: oGetLocal 2
3317: oPushResult
3318: oTypeSPush
3319: oPop 1
3321: oCall 5229
3323: oCall 5811
3325: oGetLocal 1
3327: oPushResult
3328: oSetResult 22
3330: oPushResult
3331: oValueTop
3332: oPushResult
3333: oNodeSetInt
3334: oPop 3
3336: oValuePop
3337: oTypeSPop
3338: oGetLocal 1
3340: oPushResult
3341: oScopeDeclare
3342: oPop 1
3344: oInput 5
3346: oJumpForward 3439
3348: oError 16
3350: oJumpForward 3439
3352: oGetGlobal 2
3354: oPushResult
3355: oScopeEnter
3356: oPop 1
3358: oGetAddrLocal 3
3360: oPushResult
3361: oGetLocal 2
3363: oPushResult
3364: oScopeAllocType
3365: oPop 1
3367: oAssign
3368: oScopeEnd
3369: oGetGlobal 2
3371: oPushResult
3372: oCall 1990
3374: oPop 1
3376: oPushResult
3377: oCodePush
3378: oPop 1
3380: oGetLocal 1
3382: oPushResult
3383: oSetResult 22
3385: oPushResult
3386: oGetLocal 3
3388: oPushResult
3389: oNodeSetInt
3390: oPop 3
3392: oInput 6
3394: oGetLocal 2
3396: oPushResult
3397: oGetLocal 3
3399: oPushResult
3400: oCall 3440
3402: oPop 2
3404: oCodePop
3405: oGetLocal 1
3407: oPushResult
3408: oScopeDeclare
3409: oPop 1
3411: oInput 5
3413: oJumpForward 3439
3415: Choice Lookup Table
          38   3352
          36   3352
          28   3348
          40   3348
          35   3313
          34   3313
          41   3313
          29   3313
          33   3313
          30   3313
          31   3313
3438: oEndChoice
3439: oReturn
3440: oLocalSpace 10
3442: oGetParam 2
3444: oPushResult
3445: oNodeType
3446: oPop 1
3448: oChoice 3770
3450: oGetAddrLocal 1
3452: oPushResult
3453: oGetParam 2
3455: oPushResult
3456: oSetResult 37
3458: oPushResult
3459: oNodeGet
3460: oPop 2
3462: oAssign
3463: oGetAddrLocal 2
3465: oPushResult
3466: oGetParam 2
3468: oPushResult
3469: oSetResult 38
3471: oPushResult
3472: oNodeGet
3473: oPop 2
3475: oAssign
3476: oGetAddrLocal 3
3478: oPushResult
3479: oGetLocal 2
3481: oPushResult
3482: oCall 12345
3484: oPop 1
3486: oAssign
3487: oGetAddrLocal 4
3489: oPushResult
3490: oGetLocal 2
3492: oPushResult
3493: oCall 12440
3495: oPop 1
3497: oAssign
3498: oGetAddrLocal 5
3500: oPushResult
3501: oGetLocal 1
3503: oPushResult
3504: oSetResult 17
3506: oPushResult
3507: oNodeGetInt
3508: oPop 2
3510: oAssign
3511: oInput 14
3513: oGetAddrLocal 6
3515: oPushResult
3516: oGetLocal 3
3518: oAssign
3519: oGetLocal 1
3521: oPushResult
3522: oGetParam 1
3524: oPushResult
3525: oCall 3440
3527: oPop 2
3529: oGetLocal 6
3531: oPushResult
3532: oGetLocal 4
3534: oPushResult
3535: equal
3536: oPop 2
3538: oChoice 3546
3540: oJumpForward 3575
3542: oJumpForward 3552
3544: oJumpForward 3552
3546: Choice Lookup Table
           0   3544
           1   3540
3551: oEndChoice
3552: oInput 13
3554: oGetAddrParam 1
3556: oPushResult
3557: oGetParam 1
3559: oPushResult
3560: oGetLocal 5
3562: oPushResult
3563: add
3564: oPop 2
3566: oAssign
3567: oGetAddrLocal 6
3569: oPushResult
3570: inc
3571: oPop 1
3573: oJumpBack 3519
3575: oInput 15
3577: oJumpForward 3794
3579: oInput 14
3581: oGetAddrLocal 7
3583: oPushResult
3584: oGetParam 2
3586: oPushResult
3587: oSetResult 41
3589: oPushResult
3590: oNodeGet
3591: oPop 2
3593: oAssign
3594: oInputChoice 3598
3596: oJumpForward 3603
3598: Choice Lookup Table
           0   3596
3601: oJumpForward 3669
3603: oGetAddrLocal 8
3605: oPushResult
3606: oGetLocal 7
3608: oPushResult
3609: oScopeFindRequireInScope
3610: oPop 1
3612: oAssign
3613: oInput 12
3615: oGetAddrLocal 9
3617: oPushResult
3618: oGetLocal 8
3620: oPushResult
3621: oSetResult 21
3623: oPushResult
3624: oNodeGet
3625: oPop 2
3627: oAssign
3628: oGetAddrLocal 10
3630: oPushResult
3631: oGetParam 1
3633: oPushResult
3634: oGetLocal 8
3636: oPushResult
3637: oSetResult 22
3639: oPushResult
3640: oNodeGetInt
3641: oPop 2
3643: oPushResult
3644: add
3645: oPop 2
3647: oAssign
3648: oGetLocal 9
3650: oPushResult
3651: oGetLocal 10
3653: oPushResult
3654: oCall 3440
3656: oPop 2
3658: oInputChoice 3662
3660: oJumpForward 3667
3662: Choice Lookup Table
           5   3660
3665: oJumpForward 3669
3667: oJumpBack 3594
3669: oInput 15
3671: oJumpForward 3794
3673: oEmit 16
3675: oGetParam 1
3677: oPushResult
3678: oEmitInt
3679: oPop 1
3681: oGetParam 2
3683: oPushResult
3684: oTypeSPush
3685: oPop 1
3687: oCall 5229
3689: oCall 5811
3691: oEmit 15
3693: oValueTop
3694: oPushResult
3695: oEmitInt
3696: oPop 1
3698: oValuePop
3699: oTypeSPop
3700: oEmit 27
3702: oJumpForward 3794
3704: oEmit 16
3706: oGetParam 1
3708: oPushResult
3709: oEmitInt
3710: oPop 1
3712: oGetParam 2
3714: oPushResult
3715: oTypeSPush
3716: oPop 1
3718: oCall 5229
3720: oCall 5811
3722: oEmit 15
3724: oValueTop
3725: oPushResult
3726: oEmitInt
3727: oPop 1
3729: oValuePop
3730: oTypeSPop
3731: oEmit 26
3733: oJumpForward 3794
3735: oEmit 16
3737: oGetParam 1
3739: oPushResult
3740: oEmitInt
3741: oPop 1
3743: oGetParam 2
3745: oPushResult
3746: oTypeSPush
3747: oPop 1
3749: oCall 5229
3751: oCall 5811
3753: oEmit 15
3755: oValueTop
3756: oPushResult
3757: oEmitInt
3758: oPop 1
3760: oValuePop
3761: oTypeSPop
3762: oEmit 28
3764: oJumpForward 3794
3766: oError 16
3768: oJumpForward 3794
3770: Choice Lookup Table
          28   3766
          40   3766
          35   3735
          34   3735
          41   3704
          29   3704
          33   3673
          30   3673
          31   3673
          38   3579
          36   3450
3793: oEndChoice
3794: oReturn
3795: oLocalSpace 2
3797: oInputChoice 3843
3799: oGetAddrLocal 1
3801: oPushResult
3802: oSetResult 19
3804: oPushResult
3805: LAST_ID
3806: oPushResult
3807: oCall 12233
3809: oPop 2
3811: oAssign
3812: oInput 6
3814: oGetAddrLocal 2
3816: oPushResult
3817: oCall 4150
3819: oPop 1
3821: oGetLocal 1
3823: oPushResult
3824: oSetResult 21
3826: oPushResult
3827: oGetLocal 2
3829: oPushResult
3830: oNodeSet
3831: oPop 3
3833: oGetLocal 1
3835: oPushResult
3836: oScopeDeclare
3837: oPop 1
3839: oInput 5
3841: oJumpForward 3848
3843: Choice Lookup Table
           0   3799
3846: oJumpForward 3850
3848: oJumpBack 3797
3850: oReturn
3851: oLocalSpace 6
3853: oInputChoice 4077
3855: oGetAddrLocal 1
3857: oPushResult
3858: oNodeVecNew
3859: oAssign
3860: oGetAddrLocal 2
3862: oPushResult
3863: oGetParam 1
3865: oPushResult
3866: LAST_ID
3867: oPushResult
3868: oCall 12233
3870: oPop 2
3872: oAssign
3873: oGetLocal 1
3875: oPushResult
3876: oGetLocal 2
3878: oPushResult
3879: oNodeVecAppend
3880: oPop 2
3882: oInputChoice 3888
3884: oInput 0
3886: oJumpForward 3893
3888: Choice Lookup Table
          13   3884
3891: oJumpForward 3895
3893: oJumpBack 3860
3895: oInput 12
3897: oGetAddrLocal 3
3899: oPushResult
3900: oCall 4150
3902: oPop 1
3904: oGetAddrLocal 4
3906: oPushResult
3907: oSetResult 0
3909: oAssign
3910: oGetLocal 4
3912: oPushResult
3913: oGetLocal 1
3915: oPushResult
3916: oNodeVecSize
3917: oPop 1
3919: oPushResult
3920: equal
3921: oPop 2
3923: oChoice 3964
3925: oGetAddrLocal 2
3927: oPushResult
3928: oGetLocal 1
3930: oPushResult
3931: oGetLocal 4
3933: oPushResult
3934: oNodeVecElement
3935: oPop 2
3937: oAssign
3938: oGetLocal 2
3940: oPushResult
3941: oSetResult 21
3943: oPushResult
3944: oGetLocal 3
3946: oPushResult
3947: oNodeSet
3948: oPop 3
3950: oGetLocal 2
3952: oPushResult
3953: oScopeDeclareAlloc
3954: oPop 1
3956: oGetAddrLocal 4
3958: oPushResult
3959: inc
3960: oPop 1
3962: oJumpForward 3969
3964: Choice Lookup Table
           0   3925
3967: oJumpForward 3971
3969: oJumpBack 3910
3971: oInputChoice 4064
3973: oGetLocal 1
3975: oPushResult
3976: oNodeVecSize
3977: oPop 1
3979: oChoice 3983
3981: oJumpForward 3988
3983: Choice Lookup Table
           1   3981
3986: oError 22
3988: oGetAddrLocal 5
3990: oPushResult
3991: oScopeCurrent
3992: oPushResult
3993: oCall 1990
3995: oPop 1
3997: oAssign
3998: oGetLocal 5
4000: oPushResult
4001: oCodePush
4002: oPop 1
4004: oGetAddrLocal 6
4006: oPushResult
4007: oSetResult 0
4009: oAssign
4010: oCall 11971
4012: oPushResult
4013: equal_zero
4014: oPop 1
4016: oChoice 4032
4018: oGetGlobal 3
4020: oPushResult
4021: oScopeEnter
4022: oPop 1
4024: oGetAddrLocal 6
4026: oPushResult
4027: oSetResult 1
4029: oAssign
4030: oJumpForward 4035
4032: Choice Lookup Table
           1   4018
4035: oGetLocal 2
4037: oPushResult
4038: oSetResult 1
4040: oPushResult
4041: oCall 10859
4043: oPop 2
4045: oCall 5884
4047: oCall 8997
4049: oCall 10615
4051: oGetLocal 6
4053: oChoice 4058
4055: oScopeEnd
4056: oJumpForward 4061
4058: Choice Lookup Table
           1   4055
4061: oCodePop
4062: oJumpForward 4067
4064: Choice Lookup Table
           6   3973
4067: oGetLocal 1
4069: oPushResult
4070: oNodeVecDelete
4071: oPop 1
4073: oInput 5
4075: oJumpForward 4082
4077: Choice Lookup Table
           0   3855
4080: oJumpForward 4084
4082: oJumpBack 3853
4084: oReturn
4085: oLocalSpace 2
4087: oInputChoice 4094
4089: oJumpForward 4100
4091: oChangeIntLitToLabelIdent
4092: oJumpForward 4100
4094: Choice Lookup Table
           1   4091
           0   4089
4099: oEndChoice
4100: oGetAddrLocal 1
4102: oPushResult
4103: oSetResult 26
4105: oPushResult
4106: LAST_ID
4107: oPushResult
4108: oCall 12233
4110: oPop 2
4112: oAssign
4113: oGetAddrLocal 2
4115: oPushResult
4116: oLabelNew
4117: oAssign
4118: oGetLocal 1
4120: oPushResult
4121: oSetResult 22
4123: oPushResult
4124: oGetLocal 2
4126: oPushResult
4127: oNodeSetLabel
4128: oPop 3
4130: oGetLocal 1
4132: oPushResult
4133: oScopeDeclare
4134: oPop 1
4136: oInputChoice 4140
4138: oJumpForward 4145
4140: Choice Lookup Table
          13   4138
4143: oJumpForward 4147
4145: oJumpBack 4087
4147: oInput 5
4149: oReturn
4150: oLocalSpace 12
4152: oInputChoice 4635
4154: oGetAddrLocal 1
4156: oPushResult
4157: oScopeFindRequire
4158: oAssign
4159: oGetAddrLocal 1
4161: oPushResult
4162: oCall 543
4164: oPop 1
4166: oGetLocal 1
4168: oPushResult
4169: oNodeType
4170: oPop 1
4172: oChoice 4189
4174: oGetParam 1
4176: oPushResult
4177: oGetLocal 1
4179: oPushResult
4180: oSetResult 21
4182: oPushResult
4183: oNodeGet
4184: oPop 2
4186: oAssign
4187: oJumpForward 4200
4189: Choice Lookup Table
          19   4174
4192: oError 2
4194: oGetParam 1
4196: oPushResult
4197: oGetGlobal 6
4199: oAssign
4200: oJumpForward 4658
4202: oInput 16
4204: oGetAddrLocal 2
4206: oPushResult
4207: oNodeVecNew
4208: oAssign
4209: oGetAddrLocal 3
4211: oPushResult
4212: oSetResult 37
4214: oPushResult
4215: oNodeNew
4216: oPop 1
4218: oAssign
4219: oCall 5229
4221: oGetLocal 3
4223: oPushResult
4224: oSetResult 39
4226: oPushResult
4227: oValueTop
4228: oPushResult
4229: oNodeSetInt
4230: oPop 3
4232: oValuePop
4233: oInput 21
4235: oCall 5229
4237: oGetLocal 3
4239: oPushResult
4240: oSetResult 40
4242: oPushResult
4243: oValueTop
4244: oPushResult
4245: oNodeSetInt
4246: oPop 3
4248: oValuePop
4249: oCall 5714
4251: oGetLocal 3
4253: oPushResult
4254: oSetResult 37
4256: oPushResult
4257: oTypeSTop
4258: oPushResult
4259: oNodeSet
4260: oPop 3
4262: oGetLocal 3
4264: oPushResult
4265: oSetResult 17
4267: oPushResult
4268: oTypeSTop
4269: oPushResult
4270: oSetResult 17
4272: oPushResult
4273: oNodeGetInt
4274: oPop 2
4276: oPushResult
4277: oNodeSetInt
4278: oPop 3
4280: oTypeSPop
4281: oGetLocal 3
4283: oPushResult
4284: oTypeAdd
4285: oPop 1
4287: oGetAddrLocal 4
4289: oPushResult
4290: oSetResult 36
4292: oPushResult
4293: oNodeNew
4294: oPop 1
4296: oAssign
4297: oGetLocal 4
4299: oPushResult
4300: oSetResult 38
4302: oPushResult
4303: oGetLocal 3
4305: oPushResult
4306: oNodeSet
4307: oPop 3
4309: oGetLocal 2
4311: oPushResult
4312: oGetLocal 4
4314: oPushResult
4315: oNodeVecAppend
4316: oPop 2
4318: oInputChoice 4326
4320: oJumpForward 4334
4322: oJumpForward 4332
4324: oJumpForward 4332
4326: Choice Lookup Table
          13   4324
          17   4320
4331: oEndChoice
4332: oJumpBack 4209
4334: oInput 40
4336: oGetAddrLocal 5
4338: oPushResult
4339: oCall 4150
4341: oPop 1
4343: oGetAddrLocal 6
4345: oPushResult
4346: oGetLocal 2
4348: oPushResult
4349: oNodeVecSize
4350: oPop 1
4352: oAssign
4353: oGetAddrLocal 6
4355: oPushResult
4356: dec
4357: oPop 1
4359: oGetAddrLocal 7
4361: oPushResult
4362: oGetLocal 2
4364: oPushResult
4365: oGetLocal 6
4367: oPushResult
4368: oNodeVecElement
4369: oPop 2
4371: oAssign
4372: oGetLocal 7
4374: oPushResult
4375: oSetResult 37
4377: oPushResult
4378: oGetLocal 5
4380: oPushResult
4381: oNodeSet
4382: oPop 3
4384: oGetAddrLocal 8
4386: oPushResult
4387: oGetLocal 7
4389: oPushResult
4390: oSetResult 38
4392: oPushResult
4393: oNodeGet
4394: oPop 2
4396: oAssign
4397: oGetAddrLocal 9
4399: oPushResult
4400: oGetLocal 8
4402: oPushResult
4403: oSetResult 40
4405: oPushResult
4406: oNodeGetInt
4407: oPop 2
4409: oPushResult
4410: oGetLocal 8
4412: oPushResult
4413: oSetResult 39
4415: oPushResult
4416: oNodeGetInt
4417: oPop 2
4419: oPushResult
4420: subtract
4421: oPop 2
4423: oAssign
4424: oGetAddrLocal 9
4426: oPushResult
4427: inc
4428: oPop 1
4430: oGetLocal 7
4432: oPushResult
4433: oSetResult 17
4435: oPushResult
4436: oGetLocal 9
4438: oPushResult
4439: oGetLocal 5
4441: oPushResult
4442: oSetResult 17
4444: oPushResult
4445: oNodeGetInt
4446: oPop 2
4448: oPushResult
4449: multiply
4450: oPop 2
4452: oPushResult
4453: oNodeSetInt
4454: oPop 3
4456: oGetLocal 7
4458: oPushResult
4459: oTypeAdd
4460: oPop 1
4462: oGetAddrLocal 5
4464: oPushResult
4465: oGetLocal 7
4467: oAssign
4468: oGetLocal 6
4470: oPushResult
4471: equal_zero
4472: oPop 1
4474: oChoice 4480
4476: oJumpForward 4485
4478: oJumpForward 4483
4480: Choice Lookup Table
           1   4476
4483: oJumpBack 4353
4485: oGetParam 1
4487: oPushResult
4488: oGetLocal 2
4490: oPushResult
4491: oSetResult 0
4493: oPushResult
4494: oNodeVecElement
4495: oPop 2
4497: oAssign
4498: oGetLocal 2
4500: oPushResult
4501: oNodeVecDelete
4502: oPop 1
4504: oJumpForward 4658
4506: oGetAddrLocal 10
4508: oPushResult
4509: oCall 4150
4511: oPop 1
4513: oGetParam 1
4515: oPushResult
4516: oGetLocal 10
4518: oPushResult
4519: oCall 12261
4521: oPop 1
4523: oAssign
4524: oJumpForward 4658
4526: oGetParam 1
4528: oPushResult
4529: oSetResult 38
4531: oPushResult
4532: oNodeNew
4533: oPop 1
4535: oAssign
4536: oSetResult -1
4538: oPushResult
4539: oSetResult 2
4541: oPushResult
4542: oScopeBegin
4543: oPop 2
4545: oSetResult 23
4547: oPushResult
4548: oCall 3851
4550: oPop 1
4552: oGetAddrLocal 11
4554: oPushResult
4555: oScopeCurrent
4556: oPushResult
4557: oSetResult 17
4559: oPushResult
4560: oNodeGetInt
4561: oPop 2
4563: oAssign
4564: oGetLocal 11
4566: oPushResult
4567: equal_zero
4568: oPop 1
4570: oChoice 4576
4572: oError 19
4574: oJumpForward 4579
4576: Choice Lookup Table
           1   4572
4579: oInput 36
4581: oGetFromParam 1
4583: oPushResult
4584: oSetResult 41
4586: oPushResult
4587: oScopeCurrent
4588: oPushResult
4589: oNodeSet
4590: oPop 3
4592: oGetFromParam 1
4594: oPushResult
4595: oSetResult 17
4597: oPushResult
4598: oGetLocal 11
4600: oPushResult
4601: oNodeSetInt
4602: oPop 3
4604: oScopeEnd
4605: oGetFromParam 1
4607: oPushResult
4608: oTypeAdd
4609: oPop 1
4611: oJumpForward 4658
4613: oGetParam 1
4615: oPushResult
4616: oCall 4659
4618: oPop 1
4620: oJumpForward 4658
4622: oInput 40
4624: oGetAddrLocal 12
4626: oPushResult
4627: oCall 4150
4629: oPop 1
4631: oError 16
4633: oJumpForward 4658
4635: Choice Lookup Table
          39   4622
          14   4613
          38   4526
          18   4506
          37   4202
           0   4154
4648: oCall 5229
4650: oInput 21
4652: oCall 5229
4654: oCall 5714
4656: oError 16
4658: oReturn
4659: oLocalSpace 11
4661: oGetParam 1
4663: oPushResult
4664: oSetResult 41
4666: oPushResult
4667: oNodeNew
4668: oPop 1
4670: oAssign
4671: oGetAddrLocal 1
4673: oPushResult
4674: oSetResult 0
4676: oAssign
4677: oGetAddrLocal 2
4679: oPushResult
4680: oSetResult 0
4682: oAssign
4683: oGetAddrLocal 3
4685: oPushResult
4686: oSetResult 1
4688: oAssign
4689: oGetAddrLocal 4
4691: oPushResult
4692: oScopeCurrent
4693: oAssign
4694: oSetResult -1
4696: oPushResult
4697: oSetResult 2
4699: oPushResult
4700: oScopeBegin
4701: oPop 2
4703: oInput 0
4705: oGetAddrLocal 5
4707: oPushResult
4708: oSetResult 17
4710: oPushResult
4711: LAST_ID
4712: oPushResult
4713: oCall 12233
4715: oPop 2
4717: oAssign
4718: oGetAddrLocal 6
4720: oPushResult
4721: oSetResult 17
4723: oPushResult
4724: LAST_ID
4725: oPushResult
4726: oCall 12233
4728: oPop 2
4730: oAssign
4731: oGetLocal 5
4733: oPushResult
4734: oSetResult 21
4736: oPushResult
4737: oGetFromParam 1
4739: oPushResult
4740: oNodeSet
4741: oPop 3
4743: oGetLocal 6
4745: oPushResult
4746: oSetResult 21
4748: oPushResult
4749: oGetFromParam 1
4751: oPushResult
4752: oNodeSet
4753: oPop 3
4755: oGetAddrLocal 7
4757: oPushResult
4758: LAST_ID
4759: oPushResult
4760: ID_STRING
4761: oPop 1
4763: oPushResult
4764: oStringAllocLit
4765: oPop 1
4767: oAssign
4768: oGetLocal 5
4770: oPushResult
4771: oSetResult 32
4773: oPushResult
4774: oGetLocal 7
4776: oPushResult
4777: oNodeSetInt
4778: oPop 3
4780: oGetLocal 6
4782: oPushResult
4783: oSetResult 32
4785: oPushResult
4786: oGetLocal 7
4788: oPushResult
4789: oNodeSetInt
4790: oPop 3
4792: oInputChoice 4870
4794: oGetGlobal 6
4796: oPushResult
4797: oTypeSPush
4798: oPop 1
4800: oCall 5229
4802: oCall 5811
4804: oTypeSPop
4805: oGetLocal 2
4807: oPushResult
4808: equal_zero
4809: oPop 1
4811: oChoice 4832
4813: oValueTop
4814: oPushResult
4815: oGetLocal 1
4817: oPushResult
4818: greater
4819: oPop 2
4821: oChoice 4827
4823: oError 26
4825: oJumpForward 4830
4827: Choice Lookup Table
           0   4823
4830: oJumpForward 4835
4832: Choice Lookup Table
           0   4813
4835: oGetLocal 1
4837: oPushResult
4838: oValueTop
4839: oPushResult
4840: equal
4841: oPop 2
4843: oChoice 4859
4845: oGetFromParam 1
4847: oPushResult
4848: oSetResult 44
4850: oPushResult
4851: oSetResult 1
4853: oPushResult
4854: oNodeSetBoolean
4855: oPop 3
4857: oJumpForward 4862
4859: Choice Lookup Table
           0   4845
4862: oGetAddrLocal 1
4864: oPushResult
4865: oValueTop
4866: oAssign
4867: oValuePop
4868: oJumpForward 4875
4870: Choice Lookup Table
           4   4794
           6   4794
4875: oGetLocal 5
4877: oPushResult
4878: oSetResult 22
4880: oPushResult
4881: oGetLocal 1
4883: oPushResult
4884: oNodeSetInt
4885: oPop 3
4887: oGetLocal 6
4889: oPushResult
4890: oSetResult 22
4892: oPushResult
4893: oGetLocal 1
4895: oPushResult
4896: oNodeSetInt
4897: oPop 3
4899: oGetLocal 5
4901: oPushResult
4902: oScopeDeclare
4903: oPop 1
4905: oGetLocal 4
4907: oPushResult
4908: oScopeEnter
4909: oPop 1
4911: oGetLocal 6
4913: oPushResult
4914: oScopeDeclare
4915: oPop 1
4917: oScopeEnd
4918: oGetAddrLocal 1
4920: oPushResult
4921: inc
4922: oPop 1
4924: oGetAddrLocal 2
4926: oPushResult
4927: inc
4928: oPop 1
4930: oInputChoice 4934
4932: oJumpForward 4939
4934: Choice Lookup Table
          13   4932
4937: oJumpForward 4941
4939: oJumpBack 4703
4941: oInput 15
4943: oGetFromParam 1
4945: oPushResult
4946: oSetResult 41
4948: oPushResult
4949: oScopeCurrent
4950: oPushResult
4951: oNodeSet
4952: oPop 3
4954: oGetFromParam 1
4956: oPushResult
4957: oSetResult 17
4959: oPushResult
4960: oSetResult 4
4962: oPushResult
4963: oNodeSetInt
4964: oPop 3
4966: oScopeEnd
4967: oGetGlobal 2
4969: oPushResult
4970: oCall 1990
4972: oPop 1
4974: oPushResult
4975: oCodePush
4976: oPop 1
4978: oGetGlobal 2
4980: oPushResult
4981: oScopeEnter
4982: oPop 1
4984: oGetAddrLocal 8
4986: oPushResult
4987: oGetLocal 2
4989: oPushResult
4990: oSetResult 1
4992: oPushResult
4993: add
4994: oPop 2
4996: oPushResult
4997: oSetResult 16
4999: oPushResult
5000: multiply
5001: oPop 2
5003: oAssign
5004: oGetAddrLocal 9
5006: oPushResult
5007: oGetLocal 8
5009: oPushResult
5010: oSetResult 8
5012: oPushResult
5013: oScopeAlloc
5014: oPop 2
5016: oAssign
5017: oScopeEnd
5018: oGetFromParam 1
5020: oPushResult
5021: oSetResult 43
5023: oPushResult
5024: oGetLocal 9
5026: oPushResult
5027: oNodeSetInt
5028: oPop 3
5030: oGetAddrLocal 10
5032: oPushResult
5033: oGetFromParam 1
5035: oPushResult
5036: oSetResult 41
5038: oPushResult
5039: oNodeGet
5040: oPop 2
5042: oPushResult
5043: oSetResult 15
5045: oPushResult
5046: oNodeGetIter
5047: oPop 2
5049: oAssign
5050: oGetAddrLocal 11
5052: oPushResult
5053: oGetLocal 10
5055: oPushResult
5056: oNodeIterValue
5057: oPop 1
5059: oAssign
5060: oGetLocal 11
5062: oPushResult
5063: oNodeNull
5064: oPop 1
5066: oChoice 5072
5068: oJumpForward 5159
5070: oJumpForward 5075
5072: Choice Lookup Table
           1   5068
5075: oEmit 16
5077: oGetLocal 9
5079: oPushResult
5080: oEmitInt
5081: oPop 1
5083: oEmit 15
5085: oGetLocal 11
5087: oPushResult
5088: oSetResult 22
5090: oPushResult
5091: oNodeGetInt
5092: oPop 2
5094: oPushResult
5095: oEmitInt
5096: oPop 1
5098: oEmit 26
5100: oGetAddrLocal 9
5102: oPushResult
5103: oGetLocal 9
5105: oPushResult
5106: oSetResult 8
5108: oPushResult
5109: add
5110: oPop 2
5112: oAssign
5113: oEmit 16
5115: oGetLocal 9
5117: oPushResult
5118: oEmitInt
5119: oPop 1
5121: oEmit 16
5123: oGetLocal 11
5125: oPushResult
5126: oSetResult 32
5128: oPushResult
5129: oNodeGetInt
5130: oPop 2
5132: oPushResult
5133: oEmitInt
5134: oPop 1
5136: oEmit 28
5138: oGetAddrLocal 9
5140: oPushResult
5141: oGetLocal 9
5143: oPushResult
5144: oSetResult 8
5146: oPushResult
5147: add
5148: oPop 2
5150: oAssign
5151: oGetAddrLocal 10
5153: oPushResult
5154: oNodeIterNext
5155: oPop 1
5157: oJumpBack 5050
5159: oEmit 16
5161: oGetLocal 9
5163: oPushResult
5164: oEmitInt
5165: oPop 1
5167: oEmit 15
5169: oSetResult 0
5171: oPushResult
5172: oEmitInt
5173: oPop 1
5175: oEmit 26
5177: oGetAddrLocal 9
5179: oPushResult
5180: oGetLocal 9
5182: oPushResult
5183: oSetResult 8
5185: oPushResult
5186: add
5187: oPop 2
5189: oAssign
5190: oEmit 16
5192: oGetLocal 9
5194: oPushResult
5195: oEmitInt
5196: oPop 1
5198: oEmit 15
5200: oSetResult 0
5202: oPushResult
5203: oEmitInt
5204: oPop 1
5206: oEmit 28
5208: oGetAddrLocal 9
5210: oPushResult
5211: oGetLocal 9
5213: oPushResult
5214: oSetResult 8
5216: oPushResult
5217: add
5218: oPop 2
5220: oAssign
5221: oCodePop
5222: oGetFromParam 1
5224: oPushResult
5225: oTypeAdd
5226: oPop 1
5228: oReturn
5229: oLocalSpace 0
5231: oCall 5337
5233: oInputChoice 5319
5235: oCall 5360
5237: oCall 5714
5239: oTypeSPop
5240: oGetGlobal 7
5242: oPushResult
5243: oTypeSPush
5244: oPop 1
5246: oValueEqual
5247: oJumpForward 5334
5249: oCall 5337
5251: oCall 5714
5253: oTypeSPop
5254: oGetGlobal 7
5256: oPushResult
5257: oTypeSPush
5258: oPop 1
5260: oValueNotEqual
5261: oJumpForward 5334
5263: oCall 5337
5265: oCall 5714
5267: oTypeSPop
5268: oGetGlobal 7
5270: oPushResult
5271: oTypeSPush
5272: oPop 1
5274: oValueLess
5275: oJumpForward 5334
5277: oCall 5337
5279: oCall 5714
5281: oTypeSPop
5282: oGetGlobal 7
5284: oPushResult
5285: oTypeSPush
5286: oPop 1
5288: oValueGreater
5289: oJumpForward 5334
5291: oCall 5337
5293: oCall 5714
5295: oTypeSPop
5296: oGetGlobal 7
5298: oPushResult
5299: oTypeSPush
5300: oPop 1
5302: oValueLessEqual
5303: oJumpForward 5334
5305: oCall 5337
5307: oCall 5714
5309: oTypeSPop
5310: oGetGlobal 7
5312: oPushResult
5313: oTypeSPush
5314: oPop 1
5316: oValueGreaterEqual
5317: oJumpForward 5334
5319: Choice Lookup Table
          11   5305
          10   5291
           9   5277
           8   5263
           7   5249
           6   5235
5332: oJumpForward 5336
5334: oJumpBack 5233
5336: oReturn
5337: oLocalSpace 0
5339: oCall 5360
5341: oInputChoice 5352
5343: oCall 5701
5345: oCall 5360
5347: oCall 5687
5349: oValueOr
5350: oJumpForward 5357
5352: Choice Lookup Table
          57   5343
5355: oJumpForward 5359
5357: oJumpBack 5341
5359: oReturn
5360: oLocalSpace 0
5362: oCall 5383
5364: oInputChoice 5375
5366: oCall 5701
5368: oCall 5383
5370: oCall 5687
5372: oValueAnd
5373: oJumpForward 5380
5375: Choice Lookup Table
          56   5366
5378: oJumpForward 5382
5380: oJumpBack 5364
5382: oReturn
5383: oLocalSpace 0
5385: oInputChoice 5394
5387: oCall 5383
5389: oCall 5701
5391: oValueNot
5392: oJumpForward 5399
5394: Choice Lookup Table
          58   5387
5397: oCall 5400
5399: oReturn
5400: oLocalSpace 0
5402: oCall 5430
5404: oInputChoice 5420
5406: oCall 5430
5408: oCall 5714
5410: oValueAdd
5411: oJumpForward 5427
5413: oCall 5430
5415: oCall 5714
5417: oValueSub
5418: oJumpForward 5427
5420: Choice Lookup Table
          25   5413
          24   5406
5425: oJumpForward 5429
5427: oJumpBack 5404
5429: oReturn
5430: oLocalSpace 0
5432: oCall 5460
5434: oInputChoice 5450
5436: oCall 5460
5438: oCall 5714
5440: oValueMult
5441: oJumpForward 5457
5443: oCall 5460
5445: oCall 5714
5447: oValueDiv
5448: oJumpForward 5457
5450: Choice Lookup Table
          23   5443
          22   5436
5455: oJumpForward 5459
5457: oJumpBack 5434
5459: oReturn
5460: oLocalSpace 0
5462: oInputChoice 5473
5464: oCall 5481
5466: oJumpForward 5480
5468: oCall 5481
5470: oValueNegate
5471: oJumpForward 5480
5473: Choice Lookup Table
          25   5468
          24   5464
5478: oCall 5481
5480: oReturn
5481: oLocalSpace 1
5483: oInputChoice 5654
5485: TOKEN_VALUE
5486: oPushResult
5487: oValuePush
5488: oPop 1
5490: oGetGlobal 6
5492: oPushResult
5493: oTypeSPush
5494: oPop 1
5496: oJumpForward 5681
5498: TOKEN_VALUE
5499: oPushResult
5500: oValuePush
5501: oPop 1
5503: oGetGlobal 9
5505: oPushResult
5506: oTypeSPush
5507: oPop 1
5509: oJumpForward 5681
5511: CURRENT_STRLIT
5512: oPushResult
5513: oValuePushString
5514: oPop 1
5516: oGetGlobal 13
5518: oPushResult
5519: oTypeSPush
5520: oPop 1
5522: oJumpForward 5681
5524: oCall 5229
5526: oInput 15
5528: oJumpForward 5681
5530: oGetAddrLocal 1
5532: oPushResult
5533: oScopeFindRequire
5534: oAssign
5535: oGetAddrLocal 1
5537: oPushResult
5538: oCall 543
5540: oPop 1
5542: oGetLocal 1
5544: oPushResult
5545: oNodeType
5546: oPop 1
5548: oChoice 5615
5550: oGetLocal 1
5552: oPushResult
5553: oCall 5682
5555: oPop 1
5557: oJumpForward 5636
5559: oGetLocal 1
5561: oPushResult
5562: oSetResult 22
5564: oPushResult
5565: oNodeGetInt
5566: oPop 2
5568: oPushResult
5569: oValuePush
5570: oPop 1
5572: oGetLocal 1
5574: oPushResult
5575: oSetResult 21
5577: oPushResult
5578: oNodeGet
5579: oPop 2
5581: oPushResult
5582: oTypeSPush
5583: oPop 1
5585: oJumpForward 5636
5587: oGetLocal 1
5589: oPushResult
5590: oSetResult 22
5592: oPushResult
5593: oNodeGetInt
5594: oPop 2
5596: oPushResult
5597: oValuePush
5598: oPop 1
5600: oGetLocal 1
5602: oPushResult
5603: oSetResult 21
5605: oPushResult
5606: oNodeGet
5607: oPop 2
5609: oPushResult
5610: oTypeSPush
5611: oPop 1
5613: oJumpForward 5636
5615: Choice Lookup Table
          17   5587
          16   5559
          14   5550
5622: oError 1
5624: oSetResult 0
5626: oPushResult
5627: oValuePush
5628: oPop 1
5630: oGetGlobal 6
5632: oPushResult
5633: oTypeSPush
5634: oPop 1
5636: oJumpForward 5681
5638: oError 16
5640: oSetResult 0
5642: oPushResult
5643: oValuePush
5644: oPop 1
5646: oGetGlobal 12
5648: oPushResult
5649: oTypeSPush
5650: oPop 1
5652: oJumpForward 5681
5654: Choice Lookup Table
          19   5638
           0   5530
          14   5524
           2   5511
           3   5498
           1   5485
5667: oError 1
5669: oSetResult 0
5671: oPushResult
5672: oValuePush
5673: oPop 1
5675: oGetGlobal 6
5677: oPushResult
5678: oTypeSPush
5679: oPop 1
5681: oReturn
5682: oLocalSpace 0
5684: oError 16
5686: oReturn
5687: oLocalSpace 0
5689: oTypeSNodeType
5690: oChoice 5694
5692: oJumpForward 5699
5694: Choice Lookup Table
          31   5692
5697: oError 8
5699: oTypeSPop
5700: oReturn
5701: oLocalSpace 0
5703: oTypeSNodeType
5704: oChoice 5708
5706: oJumpForward 5713
5708: Choice Lookup Table
          31   5706
5711: oError 8
5713: oReturn
5714: oLocalSpace 1
5716: oGetAddrLocal 1
5718: oPushResult
5719: oTypeSNodeType
5720: oAssign
5721: oTypeSPop
5722: oGetLocal 1
5724: oPushResult
5725: oTypeSNodeType
5726: oPushResult
5727: equal_node_type
5728: oPop 2
5730: oChoice 5807
5732: oTypeSNodeType
5733: oChoice 5794
5735: oGetLocal 1
5737: oChoice 5742
5739: oReturn
5740: oJumpForward 5745
5742: Choice Lookup Table
          35   5739
5745: oJumpForward 5803
5747: oGetLocal 1
5749: oChoice 5754
5751: oReturn
5752: oJumpForward 5757
5754: Choice Lookup Table
          34   5751
5757: oJumpForward 5803
5759: oGetLocal 1
5761: oChoice 5767
5763: oValueCharToString
5764: oReturn
5765: oJumpForward 5770
5767: Choice Lookup Table
          33   5763
5770: oJumpForward 5803
5772: oGetLocal 1
5774: oChoice 5789
5776: oValueSwap
5777: oValueCharToString
5778: oValueSwap
5779: oTypeSPop
5780: oGetGlobal 13
5782: oPushResult
5783: oTypeSPush
5784: oPop 1
5786: oReturn
5787: oJumpForward 5792
5789: Choice Lookup Table
          39   5776
5792: oJumpForward 5803
5794: Choice Lookup Table
          33   5772
          39   5759
          35   5747
          34   5735
5803: oError 14
5805: oJumpForward 5810
5807: Choice Lookup Table
           0   5732
5810: oReturn
5811: oLocalSpace 1
5813: oGetAddrLocal 1
5815: oPushResult
5816: oTypeSNodeType
5817: oAssign
5818: oTypeSPop
5819: oGetLocal 1
5821: oPushResult
5822: oTypeSNodeType
5823: oPushResult
5824: equal_node_type
5825: oPop 2
5827: oChoice 5880
5829: oTypeSNodeType
5830: oChoice 5869
5832: oGetLocal 1
5834: oChoice 5839
5836: oReturn
5837: oJumpForward 5842
5839: Choice Lookup Table
          35   5836
5842: oJumpForward 5876
5844: oGetLocal 1
5846: oChoice 5851
5848: oReturn
5849: oJumpForward 5854
5851: Choice Lookup Table
          34   5848
5854: oJumpForward 5876
5856: oGetLocal 1
5858: oChoice 5864
5860: oValueCharToString
5861: oReturn
5862: oJumpForward 5867
5864: Choice Lookup Table
          33   5860
5867: oJumpForward 5876
5869: Choice Lookup Table
          39   5856
          35   5844
          34   5832
5876: oError 14
5878: oJumpForward 5883
5880: Choice Lookup Table
           0   5829
5883: oReturn
5884: oLocalSpace 1
5886: oGetAddrLocal 1
5888: oPushResult
5889: oSetResult 0
5891: oAssign
5892: oGetAddrLocal 1
5894: oPushResult
5895: oCall 6045
5897: oPop 1
5899: oGetAddrLocal 1
5901: oPushResult
5902: oCall 5945
5904: oPop 1
5906: oReturn
5907: oLocalSpace 0
5909: oGetParam 1
5911: oPushResult
5912: oCall 6045
5914: oPop 1
5916: oTypeSNodeType
5917: oChoice 5936
5919: oJumpForward 5943
5921: oGetParam 1
5923: oPushResult
5924: oLabelNew
5925: oAssign
5926: oEmit 70
5928: oGetFromParam 1
5930: oPushResult
5931: oEmitLabel
5932: oPop 1
5934: oJumpForward 5943
5936: Choice Lookup Table
          31   5921
          32   5919
5941: oError 8
5943: oTypeSPop
5944: oReturn
5945: oLocalSpace 1
5947: oTypeSNodeType
5948: oChoice 6010
5950: oGetAddrLocal 1
5952: oPushResult
5953: oLabelNew
5954: oAssign
5955: oEmit 15
5957: oSetResult 1
5959: oPushResult
5960: oEmitInt
5961: oPop 1
5963: oEmit 68
5965: oGetLocal 1
5967: oPushResult
5968: oEmitLabel
5969: oPop 1
5971: oEmit 77
5973: oGetFromParam 1
5975: oPushResult
5976: oEmitLabel
5977: oPop 1
5979: oEmit 15
5981: oSetResult 0
5983: oPushResult
5984: oEmitInt
5985: oPop 1
5987: oEmit 77
5989: oGetLocal 1
5991: oPushResult
5992: oEmitLabel
5993: oPop 1
5995: oTypeSPop
5996: oGetGlobal 7
5998: oPushResult
5999: oTypeSPush
6000: oPop 1
6002: oGetParam 1
6004: oPushResult
6005: oSetResult 0
6007: oAssign
6008: oJumpForward 6013
6010: Choice Lookup Table
          32   5950
6013: oReturn
6014: oLocalSpace 0
6016: oTypeSNodeType
6017: oChoice 6041
6019: oGetParam 1
6021: oPushResult
6022: oLabelNew
6023: oAssign
6024: oEmit 70
6026: oGetFromParam 1
6028: oPushResult
6029: oEmitLabel
6030: oPop 1
6032: oTypeSPop
6033: oGetGlobal 8
6035: oPushResult
6036: oTypeSPush
6037: oPop 1
6039: oJumpForward 6044
6041: Choice Lookup Table
          31   6019
6044: oReturn
6045: oLocalSpace 0
6047: oGetParam 1
6049: oPushResult
6050: oCall 6578
6052: oPop 1
6054: oInputChoice 6560
6056: oGetParam 1
6058: oPushResult
6059: oCall 5945
6061: oPop 1
6063: oCall 12152
6065: oGetParam 1
6067: oPushResult
6068: oCall 6578
6070: oPop 1
6072: oGetParam 1
6074: oPushResult
6075: oCall 5945
6077: oPop 1
6079: oCall 12152
6081: oCall 12021
6083: oTypeSNodeType
6084: oChoice 6112
6086: oEmit 43
6088: oJumpForward 6131
6090: oEmit 49
6092: oJumpForward 6131
6094: oEmit 55
6096: oJumpForward 6131
6098: oCall 9366
6100: oEmit 15
6102: oSetResult 0
6104: oPushResult
6105: oEmitInt
6106: oPop 1
6108: oEmit 49
6110: oJumpForward 6131
6112: Choice Lookup Table
          39   6098
          40   6098
          35   6094
          34   6094
          41   6090
          29   6090
          33   6086
          31   6086
6129: oError 17
6131: oTypeSPop
6132: oGetGlobal 7
6134: oPushResult
6135: oTypeSPush
6136: oPop 1
6138: oJumpForward 6575
6140: oGetParam 1
6142: oPushResult
6143: oCall 5945
6145: oPop 1
6147: oCall 12152
6149: oGetParam 1
6151: oPushResult
6152: oCall 6578
6154: oPop 1
6156: oGetParam 1
6158: oPushResult
6159: oCall 5945
6161: oPop 1
6163: oCall 12152
6165: oCall 12021
6167: oTypeSNodeType
6168: oChoice 6196
6170: oEmit 44
6172: oJumpForward 6215
6174: oEmit 50
6176: oJumpForward 6215
6178: oEmit 56
6180: oJumpForward 6215
6182: oCall 9366
6184: oEmit 15
6186: oSetResult 0
6188: oPushResult
6189: oEmitInt
6190: oPop 1
6192: oEmit 50
6194: oJumpForward 6215
6196: Choice Lookup Table
          39   6182
          40   6182
          35   6178
          34   6178
          41   6174
          29   6174
          33   6170
          31   6170
6213: oError 17
6215: oTypeSPop
6216: oGetGlobal 7
6218: oPushResult
6219: oTypeSPush
6220: oPop 1
6222: oJumpForward 6575
6224: oGetParam 1
6226: oPushResult
6227: oCall 5945
6229: oPop 1
6231: oCall 12152
6233: oGetParam 1
6235: oPushResult
6236: oCall 6578
6238: oPop 1
6240: oGetParam 1
6242: oPushResult
6243: oCall 5945
6245: oPop 1
6247: oCall 12152
6249: oCall 12021
6251: oTypeSNodeType
6252: oChoice 6280
6254: oEmit 46
6256: oJumpForward 6299
6258: oEmit 52
6260: oJumpForward 6299
6262: oEmit 58
6264: oJumpForward 6299
6266: oCall 9366
6268: oEmit 15
6270: oSetResult 0
6272: oPushResult
6273: oEmitInt
6274: oPop 1
6276: oEmit 52
6278: oJumpForward 6299
6280: Choice Lookup Table
          39   6266
          40   6266
          35   6262
          34   6262
          41   6258
          29   6258
          33   6254
          31   6254
6297: oError 17
6299: oTypeSPop
6300: oGetGlobal 7
6302: oPushResult
6303: oTypeSPush
6304: oPop 1
6306: oJumpForward 6575
6308: oGetParam 1
6310: oPushResult
6311: oCall 5945
6313: oPop 1
6315: oCall 12152
6317: oGetParam 1
6319: oPushResult
6320: oCall 6578
6322: oPop 1
6324: oGetParam 1
6326: oPushResult
6327: oCall 5945
6329: oPop 1
6331: oCall 12152
6333: oCall 12021
6335: oTypeSNodeType
6336: oChoice 6364
6338: oEmit 45
6340: oJumpForward 6383
6342: oEmit 51
6344: oJumpForward 6383
6346: oEmit 57
6348: oJumpForward 6383
6350: oCall 9366
6352: oEmit 15
6354: oSetResult 0
6356: oPushResult
6357: oEmitInt
6358: oPop 1
6360: oEmit 51
6362: oJumpForward 6383
6364: Choice Lookup Table
          39   6350
          40   6350
          35   6346
          34   6346
          41   6342
          29   6342
          33   6338
          31   6338
6381: oError 17
6383: oTypeSPop
6384: oGetGlobal 7
6386: oPushResult
6387: oTypeSPush
6388: oPop 1
6390: oJumpForward 6575
6392: oGetParam 1
6394: oPushResult
6395: oCall 5945
6397: oPop 1
6399: oCall 12152
6401: oGetParam 1
6403: oPushResult
6404: oCall 6578
6406: oPop 1
6408: oGetParam 1
6410: oPushResult
6411: oCall 5945
6413: oPop 1
6415: oCall 12152
6417: oCall 12021
6419: oTypeSNodeType
6420: oChoice 6448
6422: oEmit 48
6424: oJumpForward 6467
6426: oEmit 54
6428: oJumpForward 6467
6430: oEmit 60
6432: oJumpForward 6467
6434: oCall 9366
6436: oEmit 15
6438: oSetResult 0
6440: oPushResult
6441: oEmitInt
6442: oPop 1
6444: oEmit 54
6446: oJumpForward 6467
6448: Choice Lookup Table
          39   6434
          40   6434
          35   6430
          34   6430
          41   6426
          29   6426
          33   6422
          31   6422
6465: oError 17
6467: oTypeSPop
6468: oGetGlobal 7
6470: oPushResult
6471: oTypeSPush
6472: oPop 1
6474: oJumpForward 6575
6476: oGetParam 1
6478: oPushResult
6479: oCall 5945
6481: oPop 1
6483: oCall 12152
6485: oGetParam 1
6487: oPushResult
6488: oCall 6578
6490: oPop 1
6492: oGetParam 1
6494: oPushResult
6495: oCall 5945
6497: oPop 1
6499: oCall 12152
6501: oCall 12021
6503: oTypeSNodeType
6504: oChoice 6532
6506: oEmit 47
6508: oJumpForward 6551
6510: oEmit 53
6512: oJumpForward 6551
6514: oEmit 59
6516: oJumpForward 6551
6518: oCall 9366
6520: oEmit 15
6522: oSetResult 0
6524: oPushResult
6525: oEmitInt
6526: oPop 1
6528: oEmit 53
6530: oJumpForward 6551
6532: Choice Lookup Table
          39   6518
          40   6518
          35   6514
          34   6514
          41   6510
          29   6510
          33   6506
          31   6506
6549: oError 17
6551: oTypeSPop
6552: oGetGlobal 7
6554: oPushResult
6555: oTypeSPush
6556: oPop 1
6558: oJumpForward 6575
6560: Choice Lookup Table
          11   6476
          10   6392
           9   6308
           8   6224
           7   6140
           6   6056
6573: oJumpForward 6577
6575: oJumpBack 6054
6577: oReturn
6578: oLocalSpace 1
6580: oGetAddrLocal 1
6582: oPushResult
6583: oSetResult 0
6585: oAssign
6586: oGetParam 1
6588: oPushResult
6589: oCall 6758
6591: oPop 1
6593: oInputChoice 6726
6595: oTypeSNodeType
6596: oChoice 6667
6598: oGetLocal 1
6600: oPushResult
6601: oSetResult 0
6603: oPushResult
6604: equal_label
6605: oPop 2
6607: oChoice 6616
6609: oGetAddrLocal 1
6611: oPushResult
6612: oLabelNew
6613: oAssign
6614: oJumpForward 6619
6616: Choice Lookup Table
           1   6609
6619: oEmit 68
6621: oGetLocal 1
6623: oPushResult
6624: oEmitLabel
6625: oPop 1
6627: oJumpForward 6674
6629: oGetParam 1
6631: oPushResult
6632: oCall 6014
6634: oPop 1
6636: oGetLocal 1
6638: oPushResult
6639: oSetResult 0
6641: oPushResult
6642: equal_label
6643: oPop 2
6645: oChoice 6654
6647: oGetAddrLocal 1
6649: oPushResult
6650: oLabelNew
6651: oAssign
6652: oJumpForward 6657
6654: Choice Lookup Table
           1   6647
6657: oEmit 68
6659: oGetLocal 1
6661: oPushResult
6662: oEmitLabel
6663: oPop 1
6665: oJumpForward 6674
6667: Choice Lookup Table
          31   6629
          32   6598
6672: oError 8
6674: oTypeSPop
6675: oEmit 77
6677: oGetFromParam 1
6679: oPushResult
6680: oEmitLabel
6681: oPop 1
6683: oGetParam 1
6685: oPushResult
6686: oSetResult 0
6688: oAssign
6689: oGetParam 1
6691: oPushResult
6692: oCall 6758
6694: oPop 1
6696: oTypeSNodeType
6697: oChoice 6710
6699: oJumpForward 6717
6701: oGetParam 1
6703: oPushResult
6704: oCall 6014
6706: oPop 1
6708: oJumpForward 6717
6710: Choice Lookup Table
          31   6701
          32   6699
6715: oError 8
6717: oTypeSPop
6718: oGetGlobal 8
6720: oPushResult
6721: oTypeSPush
6722: oPop 1
6724: oJumpForward 6731
6726: Choice Lookup Table
          57   6595
6729: oJumpForward 6733
6731: oJumpBack 6593
6733: oGetLocal 1
6735: oPushResult
6736: oSetResult 0
6738: oPushResult
6739: equal_label
6740: oPop 2
6742: oChoice 6754
6744: oEmit 77
6746: oGetLocal 1
6748: oPushResult
6749: oEmitLabel
6750: oPop 1
6752: oJumpForward 6757
6754: Choice Lookup Table
           0   6744
6757: oReturn
6758: oLocalSpace 2
6760: oGetAddrLocal 1
6762: oPushResult
6763: oSetResult 0
6765: oAssign
6766: oGetParam 1
6768: oPushResult
6769: oCall 6896
6771: oPop 1
6773: oInputChoice 6888
6775: oTypeSNodeType
6776: oChoice 6789
6778: oJumpForward 6796
6780: oGetParam 1
6782: oPushResult
6783: oCall 6014
6785: oPop 1
6787: oJumpForward 6796
6789: Choice Lookup Table
          31   6780
          32   6778
6794: oError 8
6796: oTypeSPop
6797: oGetLocal 1
6799: oPushResult
6800: oSetResult 0
6802: oPushResult
6803: equal_label
6804: oPop 2
6806: oChoice 6835
6808: oGetAddrLocal 1
6810: oPushResult
6811: oLabelNew
6812: oAssign
6813: oEmit 78
6815: oGetFromParam 1
6817: oPushResult
6818: oEmitLabel
6819: oPop 1
6821: oGetLocal 1
6823: oPushResult
6824: oEmitLabel
6825: oPop 1
6827: oGetParam 1
6829: oPushResult
6830: oGetLocal 1
6832: oAssign
6833: oJumpForward 6838
6835: Choice Lookup Table
           1   6808
6838: oGetAddrLocal 2
6840: oPushResult
6841: oSetResult 0
6843: oAssign
6844: oGetAddrLocal 2
6846: oPushResult
6847: oCall 6896
6849: oPop 1
6851: oTypeSNodeType
6852: oChoice 6865
6854: oJumpForward 6872
6856: oGetAddrLocal 2
6858: oPushResult
6859: oCall 6014
6861: oPop 1
6863: oJumpForward 6872
6865: Choice Lookup Table
          31   6856
          32   6854
6870: oError 8
6872: oEmit 78
6874: oGetLocal 2
6876: oPushResult
6877: oEmitLabel
6878: oPop 1
6880: oGetLocal 1
6882: oPushResult
6883: oEmitLabel
6884: oPop 1
6886: oJumpForward 6893
6888: Choice Lookup Table
          56   6775
6891: oJumpForward 6895
6893: oJumpBack 6773
6895: oReturn
6896: oLocalSpace 1
6898: oInputChoice 6952
6900: oGetAddrLocal 1
6902: oPushResult
6903: oSetResult 0
6905: oAssign
6906: oGetAddrLocal 1
6908: oPushResult
6909: oCall 6896
6911: oPop 1
6913: oTypeSNodeType
6914: oChoice 6943
6916: oGetParam 1
6918: oPushResult
6919: oLabelNew
6920: oAssign
6921: oEmit 68
6923: oGetFromParam 1
6925: oPushResult
6926: oEmitLabel
6927: oPop 1
6929: oEmit 77
6931: oGetLocal 1
6933: oPushResult
6934: oEmitLabel
6935: oPop 1
6937: oJumpForward 6950
6939: oEmit 42
6941: oJumpForward 6950
6943: Choice Lookup Table
          31   6939
          32   6916
6948: oError 8
6950: oJumpForward 6962
6952: Choice Lookup Table
          58   6900
6955: oGetParam 1
6957: oPushResult
6958: oCall 6963
6960: oPop 1
6962: oReturn
6963: oLocalSpace 2
6965: oGetAddrLocal 1
6967: oPushResult
6968: oSetResult 1
6970: oAssign
6971: oGetParam 1
6973: oPushResult
6974: oCall 7199
6976: oPop 1
6978: oInputChoice 7189
6980: oTypeSNodeType
6981: oChoice 7104
6983: oCall 12106
6985: oGetParam 1
6987: oPushResult
6988: oCall 7199
6990: oPop 1
6992: oTypeSNodeType
6993: oChoice 7001
6995: oEmit 22
6997: oCall 8782
6999: oJumpForward 7010
7001: Choice Lookup Table
          35   6995
          34   6995
7006: oCall 12126
7008: oEmit 37
7010: oJumpForward 7121
7012: oGetLocal 1
7014: oChoice 7030
7016: oGetAddrLocal 2
7018: oPushResult
7019: oCall 9149
7021: oAssign
7022: oGetAddrLocal 1
7024: oPushResult
7025: oSetResult 0
7027: oAssign
7028: oJumpForward 7033
7030: Choice Lookup Table
           1   7016
7033: oGetParam 1
7035: oPushResult
7036: oCall 7199
7038: oPop 1
7040: oTypeSNodeType
7041: oChoice 7079
7043: oCall 9258
7045: oEmit 17
7047: oGetLocal 2
7049: oPushResult
7050: oEmitInt
7051: oPop 1
7053: oGetGlobal 14
7055: oPushResult
7056: oTypeSPush
7057: oPop 1
7059: oJumpForward 7089
7061: oCall 9312
7063: oEmit 17
7065: oGetLocal 2
7067: oPushResult
7068: oEmitInt
7069: oPop 1
7071: oGetGlobal 14
7073: oPushResult
7074: oTypeSPush
7075: oPop 1
7077: oJumpForward 7089
7079: Choice Lookup Table
          33   7061
          39   7043
          40   7043
7086: oError 14
7088: oTypeSPop
7089: oJumpForward 7121
7091: oGetParam 1
7093: oPushResult
7094: oCall 7199
7096: oPop 1
7098: oCall 12106
7100: oCall 8782
7102: oJumpForward 7121
7104: Choice Lookup Table
          35   7091
          34   7091
          33   7012
          39   7012
          40   7012
          30   6983
          29   6983
7119: oError 17
7121: oJumpForward 7196
7123: oTypeSNodeType
7124: oChoice 7176
7126: oCall 12106
7128: oGetParam 1
7130: oPushResult
7131: oCall 7199
7133: oPop 1
7135: oCall 12126
7137: oEmit 40
7139: oJumpForward 7187
7141: oGetParam 1
7143: oPushResult
7144: oCall 7199
7146: oPop 1
7148: oTypeSNodeType
7149: oChoice 7163
7151: oCall 12106
7153: oCall 8838
7155: oJumpForward 7174
7157: oCall 12021
7159: oCall 8894
7161: oJumpForward 7174
7163: Choice Lookup Table
          35   7157
          34   7157
          30   7151
          29   7151
7172: oError 17
7174: oJumpForward 7187
7176: Choice Lookup Table
          35   7141
          34   7141
          30   7126
          29   7126
7185: oError 17
7187: oJumpForward 7196
7189: Choice Lookup Table
          25   7123
          24   6980
7194: oJumpForward 7198
7196: oJumpBack 6978
7198: oReturn
7199: oLocalSpace 0
7201: oGetParam 1
7203: oPushResult
7204: oCall 7250
7206: oPop 1
7208: oInputChoice 7240
7210: oCall 12106
7212: oGetParam 1
7214: oPushResult
7215: oCall 7250
7217: oPop 1
7219: oCall 12126
7221: oEmit 34
7223: oJumpForward 7247
7225: oCall 12106
7227: oGetParam 1
7229: oPushResult
7230: oCall 7250
7232: oPop 1
7234: oCall 12126
7236: oEmit 35
7238: oJumpForward 7247
7240: Choice Lookup Table
          23   7225
          22   7210
7245: oJumpForward 7249
7247: oJumpBack 7208
7249: oReturn
7250: oLocalSpace 0
7252: oInputChoice 7278
7254: oGetParam 1
7256: oPushResult
7257: oCall 7291
7259: oPop 1
7261: oCall 12126
7263: oJumpForward 7290
7265: oGetParam 1
7267: oPushResult
7268: oCall 7291
7270: oPop 1
7272: oCall 12126
7274: oEmit 41
7276: oJumpForward 7290
7278: Choice Lookup Table
          25   7265
          24   7254
7283: oGetParam 1
7285: oPushResult
7286: oCall 7291
7288: oPop 1
7290: oReturn
7291: oLocalSpace 6
7293: oInputChoice 7547
7295: oEmit 15
7297: TOKEN_VALUE
7298: oPushResult
7299: oEmitInt
7300: oPop 1
7302: oGetGlobal 6
7304: oPushResult
7305: oTypeSPush
7306: oPop 1
7308: oJumpForward 7568
7310: oEmit 15
7312: TOKEN_VALUE
7313: oPushResult
7314: oEmitInt
7315: oPop 1
7317: oGetGlobal 9
7319: oPushResult
7320: oTypeSPush
7321: oPop 1
7323: oJumpForward 7568
7325: oGetParam 1
7327: oPushResult
7328: oCall 6045
7330: oPop 1
7332: oInput 15
7334: oJumpForward 7568
7336: oGetAddrLocal 1
7338: oPushResult
7339: CURRENT_STRLIT
7340: oPushResult
7341: oStringAllocShortStringLit
7342: oPop 1
7344: oAssign
7345: oEmit 16
7347: oGetLocal 1
7349: oPushResult
7350: oEmitInt
7351: oPop 1
7353: oGetGlobal 13
7355: oPushResult
7356: oTypeSPush
7357: oPop 1
7359: oCall 8380
7361: oCall 8326
7363: oJumpForward 7568
7365: oGetAddrLocal 2
7367: oPushResult
7368: oScopeFindRequire
7369: oAssign
7370: oGetAddrLocal 2
7372: oPushResult
7373: oCall 543
7375: oPop 1
7377: oGetLocal 2
7379: oPushResult
7380: oNodeType
7381: oPop 1
7383: oChoice 7471
7385: oGetLocal 2
7387: oPushResult
7388: oCall 9544
7390: oPop 1
7392: oJumpForward 7496
7394: oGetLocal 2
7396: oPushResult
7397: oCall 10164
7399: oPop 1
7401: oJumpForward 7496
7403: oGetAddrLocal 3
7405: oPushResult
7406: oGetLocal 2
7408: oPushResult
7409: oSetResult 21
7411: oPushResult
7412: oNodeGet
7413: oPop 2
7415: oAssign
7416: oGetLocal 3
7418: oPushResult
7419: oTypeSPush
7420: oPop 1
7422: oTypeSNodeType
7423: oChoice 7447
7425: oEmit 15
7427: oGetLocal 2
7429: oPushResult
7430: oCall 12535
7432: oPop 1
7434: oJumpForward 7460
7436: oEmit 15
7438: oGetLocal 2
7440: oPushResult
7441: oCall 12535
7443: oPop 1
7445: oJumpForward 7460
7447: Choice Lookup Table
          35   7436
          34   7436
          31   7425
          41   7425
          29   7425
7458: oError 16
7460: oJumpForward 7496
7462: oGetLocal 2
7464: oPushResult
7465: oCall 7569
7467: oPop 1
7469: oJumpForward 7496
7471: Choice Lookup Table
          25   7462
          24   7462
          22   7462
          21   7462
          17   7403
          16   7403
          14   7394
          13   7385
7488: oError 6
7490: oGetGlobal 6
7492: oPushResult
7493: oTypeSPush
7494: oPop 1
7496: oJumpForward 7568
7498: oInput 0
7500: oGetAddrLocal 4
7502: oPushResult
7503: oScopeFindRequire
7504: oAssign
7505: oGetAddrLocal 4
7507: oPushResult
7508: oCall 543
7510: oPop 1
7512: oGetLocal 4
7514: oPushResult
7515: oSetResult 0
7517: oPushResult
7518: oCall 10859
7520: oPop 2
7522: oGetAddrLocal 5
7524: oPushResult
7525: oTypeSTop
7526: oAssign
7527: oTypeSPop
7528: oGetAddrLocal 6
7530: oPushResult
7531: oGetLocal 5
7533: oPushResult
7534: oCall 12261
7536: oPop 1
7538: oAssign
7539: oGetLocal 6
7541: oPushResult
7542: oTypeSPush
7543: oPop 1
7545: oJumpForward 7568
7547: Choice Lookup Table
          19   7498
           0   7365
           2   7336
          14   7325
           3   7310
           1   7295
7560: oError 6
7562: oGetGlobal 6
7564: oPushResult
7565: oTypeSPush
7566: oPop 1
7568: oReturn
7569: oLocalSpace 2
7571: oGetAddrLocal 1
7573: oPushResult
7574: oGetParam 1
7576: oPushResult
7577: oSetResult 21
7579: oPushResult
7580: oNodeGet
7581: oPop 2
7583: oAssign
7584: oGetAddrLocal 2
7586: oPushResult
7587: oGetParam 1
7589: oPushResult
7590: oCall 12003
7592: oPop 1
7594: oAssign
7595: oGetLocal 1
7597: oPushResult
7598: oTypeSPush
7599: oPop 1
7601: oTypeSNodeType
7602: oChoice 8301
7604: oGetParam 1
7606: oPushResult
7607: oNodeType
7608: oPop 1
7610: oChoice 7756
7612: oEmit 0
7614: oGetParam 1
7616: oPushResult
7617: oCall 12535
7619: oPop 1
7621: oJumpForward 7766
7623: oGetLocal 2
7625: oPushResult
7626: equal_zero
7627: oPop 1
7629: oChoice 7642
7631: oEmit 3
7633: oGetParam 1
7635: oPushResult
7636: oCall 12535
7638: oPop 1
7640: oJumpForward 7660
7642: Choice Lookup Table
           1   7631
7645: oEmit 9
7647: oGetLocal 2
7649: oPushResult
7650: oEmitInt
7651: oPop 1
7653: oGetParam 1
7655: oPushResult
7656: oCall 12535
7658: oPop 1
7660: oJumpForward 7766
7662: oGetParam 1
7664: oPushResult
7665: oSetResult 34
7667: oPushResult
7668: oNodeGetBoolean
7669: oPop 2
7671: oChoice 7714
7673: oGetLocal 2
7675: oPushResult
7676: equal_zero
7677: oPop 1
7679: oChoice 7692
7681: oEmit 8
7683: oGetParam 1
7685: oPushResult
7686: oCall 12535
7688: oPop 1
7690: oJumpForward 7710
7692: Choice Lookup Table
           1   7681
7695: oEmit 14
7697: oGetLocal 2
7699: oPushResult
7700: oEmitInt
7701: oPop 1
7703: oGetParam 1
7705: oPushResult
7706: oCall 12535
7708: oPop 1
7710: oEmit 23
7712: oJumpForward 7754
7714: Choice Lookup Table
           1   7673
7717: oGetLocal 2
7719: oPushResult
7720: equal_zero
7721: oPop 1
7723: oChoice 7736
7725: oEmit 6
7727: oGetParam 1
7729: oPushResult
7730: oCall 12535
7732: oPop 1
7734: oJumpForward 7754
7736: Choice Lookup Table
           1   7725
7739: oEmit 12
7741: oGetLocal 2
7743: oPushResult
7744: oEmitInt
7745: oPop 1
7747: oGetParam 1
7749: oPushResult
7750: oCall 12535
7752: oPop 1
7754: oJumpForward 7766
7756: Choice Lookup Table
          24   7662
          22   7623
          25   7612
          21   7612
7765: oEndChoice
7766: oJumpForward 8325
7768: oGetParam 1
7770: oPushResult
7771: oNodeType
7772: oPop 1
7774: oChoice 7920
7776: oEmit 1
7778: oGetParam 1
7780: oPushResult
7781: oCall 12535
7783: oPop 1
7785: oJumpForward 7930
7787: oGetLocal 2
7789: oPushResult
7790: equal_zero
7791: oPop 1
7793: oChoice 7806
7795: oEmit 4
7797: oGetParam 1
7799: oPushResult
7800: oCall 12535
7802: oPop 1
7804: oJumpForward 7824
7806: Choice Lookup Table
           1   7795
7809: oEmit 10
7811: oGetLocal 2
7813: oPushResult
7814: oEmitInt
7815: oPop 1
7817: oGetParam 1
7819: oPushResult
7820: oCall 12535
7822: oPop 1
7824: oJumpForward 7930
7826: oGetParam 1
7828: oPushResult
7829: oSetResult 34
7831: oPushResult
7832: oNodeGetBoolean
7833: oPop 2
7835: oChoice 7878
7837: oGetLocal 2
7839: oPushResult
7840: equal_zero
7841: oPop 1
7843: oChoice 7856
7845: oEmit 8
7847: oGetParam 1
7849: oPushResult
7850: oCall 12535
7852: oPop 1
7854: oJumpForward 7874
7856: Choice Lookup Table
           1   7845
7859: oEmit 14
7861: oGetLocal 2
7863: oPushResult
7864: oEmitInt
7865: oPop 1
7867: oGetParam 1
7869: oPushResult
7870: oCall 12535
7872: oPop 1
7874: oEmit 24
7876: oJumpForward 7918
7878: Choice Lookup Table
           1   7837
7881: oGetLocal 2
7883: oPushResult
7884: equal_zero
7885: oPop 1
7887: oChoice 7900
7889: oEmit 7
7891: oGetParam 1
7893: oPushResult
7894: oCall 12535
7896: oPop 1
7898: oJumpForward 7918
7900: Choice Lookup Table
           1   7889
7903: oEmit 13
7905: oGetLocal 2
7907: oPushResult
7908: oEmitInt
7909: oPop 1
7911: oGetParam 1
7913: oPushResult
7914: oCall 12535
7916: oPop 1
7918: oJumpForward 7930
7920: Choice Lookup Table
          24   7826
          22   7787
          25   7776
          21   7776
7929: oEndChoice
7930: oJumpForward 8325
7932: oError 16
7934: oJumpForward 8325
7936: oGetParam 1
7938: oPushResult
7939: oNodeType
7940: oPop 1
7942: oChoice 8088
7944: oEmit 2
7946: oGetParam 1
7948: oPushResult
7949: oCall 12535
7951: oPop 1
7953: oJumpForward 8098
7955: oGetLocal 2
7957: oPushResult
7958: equal_zero
7959: oPop 1
7961: oChoice 7974
7963: oEmit 5
7965: oGetParam 1
7967: oPushResult
7968: oCall 12535
7970: oPop 1
7972: oJumpForward 7992
7974: Choice Lookup Table
           1   7963
7977: oEmit 11
7979: oGetLocal 2
7981: oPushResult
7982: oEmitInt
7983: oPop 1
7985: oGetParam 1
7987: oPushResult
7988: oCall 12535
7990: oPop 1
7992: oJumpForward 8098
7994: oGetParam 1
7996: oPushResult
7997: oSetResult 34
7999: oPushResult
8000: oNodeGetBoolean
8001: oPop 2
8003: oChoice 8046
8005: oGetLocal 2
8007: oPushResult
8008: equal_zero
8009: oPop 1
8011: oChoice 8024
8013: oEmit 8
8015: oGetParam 1
8017: oPushResult
8018: oCall 12535
8020: oPop 1
8022: oJumpForward 8042
8024: Choice Lookup Table
           1   8013
8027: oEmit 14
8029: oGetLocal 2
8031: oPushResult
8032: oEmitInt
8033: oPop 1
8035: oGetParam 1
8037: oPushResult
8038: oCall 12535
8040: oPop 1
8042: oEmit 25
8044: oJumpForward 8086
8046: Choice Lookup Table
           1   8005
8049: oGetLocal 2
8051: oPushResult
8052: equal_zero
8053: oPop 1
8055: oChoice 8068
8057: oEmit 8
8059: oGetParam 1
8061: oPushResult
8062: oCall 12535
8064: oPop 1
8066: oJumpForward 8086
8068: Choice Lookup Table
           1   8057
8071: oEmit 14
8073: oGetLocal 2
8075: oPushResult
8076: oEmitInt
8077: oPop 1
8079: oGetParam 1
8081: oPushResult
8082: oCall 12535
8084: oPop 1
8086: oJumpForward 8098
8088: Choice Lookup Table
          24   7994
          22   7955
          25   7944
          21   7944
8097: oEndChoice
8098: oInputChoice 8128
8100: oTypeSPop
8101: oGetLocal 1
8103: oPushResult
8104: oSetResult 37
8106: oPushResult
8107: oNodeGet
8108: oPop 2
8110: oPushResult
8111: oTypeSPush
8112: oPop 1
8114: oCall 8380
8116: oCall 8326
8118: oJumpForward 8133
8120: oCall 8575
8122: oCall 8380
8124: oCall 8326
8126: oJumpForward 8133
8128: Choice Lookup Table
          16   8120
          18   8100
8133: oJumpForward 8325
8135: oGetParam 1
8137: oPushResult
8138: oNodeType
8139: oPop 1
8141: oChoice 8285
8143: oEmit 16
8145: oGetParam 1
8147: oPushResult
8148: oCall 12535
8150: oPop 1
8152: oJumpForward 8295
8154: oGetLocal 2
8156: oPushResult
8157: equal_zero
8158: oPop 1
8160: oChoice 8173
8162: oEmit 17
8164: oGetParam 1
8166: oPushResult
8167: oCall 12535
8169: oPop 1
8171: oJumpForward 8191
8173: Choice Lookup Table
           1   8162
8176: oEmit 20
8178: oGetLocal 2
8180: oPushResult
8181: oEmitInt
8182: oPop 1
8184: oGetParam 1
8186: oPushResult
8187: oCall 12535
8189: oPop 1
8191: oJumpForward 8295
8193: oGetParam 1
8195: oPushResult
8196: oSetResult 34
8198: oPushResult
8199: oNodeGetBoolean
8200: oPop 2
8202: oChoice 8243
8204: oGetLocal 2
8206: oPushResult
8207: equal_zero
8208: oPop 1
8210: oChoice 8223
8212: oEmit 8
8214: oGetParam 1
8216: oPushResult
8217: oCall 12535
8219: oPop 1
8221: oJumpForward 8241
8223: Choice Lookup Table
           1   8212
8226: oEmit 14
8228: oGetLocal 2
8230: oPushResult
8231: oEmitInt
8232: oPop 1
8234: oGetParam 1
8236: oPushResult
8237: oCall 12535
8239: oPop 1
8241: oJumpForward 8283
8243: Choice Lookup Table
           1   8204
8246: oGetLocal 2
8248: oPushResult
8249: equal_zero
8250: oPop 1
8252: oChoice 8265
8254: oEmit 18
8256: oGetParam 1
8258: oPushResult
8259: oCall 12535
8261: oPop 1
8263: oJumpForward 8283
8265: Choice Lookup Table
           1   8254
8268: oEmit 21
8270: oGetLocal 2
8272: oPushResult
8273: oEmitInt
8274: oPop 1
8276: oGetParam 1
8278: oPushResult
8279: oCall 12535
8281: oPop 1
8283: oJumpForward 8295
8285: Choice Lookup Table
          24   8193
          22   8154
          25   8143
          21   8143
8294: oEndChoice
8295: oCall 8380
8297: oCall 8326
8299: oJumpForward 8325
8301: Choice Lookup Table
          40   8135
          38   8135
          36   8135
          35   7936
          34   7936
          28   7932
          33   7768
          30   7768
          31   7768
          41   7604
          29   7604
8324: oEndChoice
8325: oReturn
8326: oLocalSpace 0
8328: oTypeSNodeType
8329: oChoice 8353
8331: oEmit 23
8333: oJumpForward 8379
8335: oEmit 24
8337: oJumpForward 8379
8339: oError 16
8341: oJumpForward 8379
8343: oEmit 25
8345: oJumpForward 8379
8347: oError 29
8349: oJumpForward 8379
8351: oJumpForward 8379
8353: Choice Lookup Table
          40   8351
          39   8351
          38   8351
          36   8351
          35   8347
          34   8343
          28   8339
          33   8335
          30   8335
          31   8335
          41   8331
          29   8331
8378: oEndChoice
8379: oReturn
8380: oLocalSpace 0
8382: oInputChoice 8420
8384: oTypeSNodeType
8385: oChoice 8399
8387: oCall 8432
8389: oJumpForward 8410
8391: oCall 8575
8393: oJumpForward 8410
8395: oCall 8654
8397: oJumpForward 8410
8399: Choice Lookup Table
          40   8395
          39   8395
          34   8391
          36   8387
8408: oError 10
8410: oJumpForward 8429
8412: oCall 8684
8414: oJumpForward 8429
8416: oCall 8957
8418: oJumpForward 8429
8420: Choice Lookup Table
          18   8416
          20   8412
          16   8384
8427: oJumpForward 8431
8429: oJumpBack 8382
8431: oReturn
8432: oLocalSpace 3
8434: oTypeSNodeType
8435: oChoice 8439
8437: oJumpForward 8444
8439: Choice Lookup Table
          36   8437
8442: oError 10
8444: oTypeSNodeType
8445: oChoice 8449
8447: oJumpForward 8454
8449: Choice Lookup Table
          36   8447
8452: oError 13
8454: oGetAddrLocal 1
8456: oPushResult
8457: oTypeSTop
8458: oPushResult
8459: oSetResult 38
8461: oPushResult
8462: oNodeGet
8463: oPop 2
8465: oPushResult
8466: oCall 12345
8468: oPop 1
8470: oAssign
8471: oGetAddrLocal 2
8473: oPushResult
8474: oTypeSTop
8475: oPushResult
8476: oSetResult 37
8478: oPushResult
8479: oNodeGet
8480: oPop 2
8482: oAssign
8483: oTypeSPop
8484: oGetLocal 2
8486: oPushResult
8487: oTypeSPush
8488: oPop 1
8490: oCall 5884
8492: oCall 12079
8494: oGetLocal 1
8496: oPushResult
8497: equal_zero
8498: oPop 1
8500: oChoice 8514
8502: oEmit 15
8504: oGetLocal 1
8506: oPushResult
8507: oEmitInt
8508: oPop 1
8510: oEmit 40
8512: oJumpForward 8517
8514: Choice Lookup Table
           0   8502
8517: oGetAddrLocal 3
8519: oPushResult
8520: oGetLocal 2
8522: oPushResult
8523: oSetResult 17
8525: oPushResult
8526: oNodeGetInt
8527: oPop 2
8529: oAssign
8530: oGetLocal 3
8532: oPushResult
8533: oSetResult 1
8535: oPushResult
8536: equal
8537: oPop 2
8539: oChoice 8553
8541: oEmit 15
8543: oGetLocal 3
8545: oPushResult
8546: oEmitInt
8547: oPop 1
8549: oEmit 34
8551: oJumpForward 8556
8553: Choice Lookup Table
           0   8541
8556: oEmit 36
8558: oInputChoice 8566
8560: oJumpForward 8574
8562: oJumpForward 8572
8564: oJumpForward 8572
8566: Choice Lookup Table
          13   8564
          17   8560
8571: oEndChoice
8572: oJumpBack 8444
8574: oReturn
8575: oLocalSpace 2
8577: oTypeSNodeType
8578: oChoice 8582
8580: oJumpForward 8587
8582: Choice Lookup Table
          34   8580
8585: oError 29
8587: oGetAddrLocal 1
8589: oPushResult
8590: oTypeSTop
8591: oPushResult
8592: oSetResult 37
8594: oPushResult
8595: oNodeGet
8596: oPop 2
8598: oAssign
8599: oTypeSPop
8600: oGetLocal 1
8602: oPushResult
8603: oTypeSPush
8604: oPop 1
8606: oCall 5884
8608: oCall 12079
8610: oGetAddrLocal 2
8612: oPushResult
8613: oGetLocal 1
8615: oPushResult
8616: oSetResult 17
8618: oPushResult
8619: oNodeGetInt
8620: oPop 2
8622: oAssign
8623: oGetLocal 2
8625: oPushResult
8626: oSetResult 1
8628: oPushResult
8629: equal
8630: oPop 2
8632: oChoice 8646
8634: oEmit 15
8636: oGetLocal 2
8638: oPushResult
8639: oEmitInt
8640: oPop 1
8642: oEmit 34
8644: oJumpForward 8649
8646: Choice Lookup Table
           0   8634
8649: oEmit 36
8651: oInput 17
8653: oReturn
8654: oLocalSpace 0
8656: oTypeSNodeType
8657: oChoice 8661
8659: oJumpForward 8668
8661: Choice Lookup Table
          40   8659
          39   8659
8666: oError 29
8668: oTypeSPop
8669: oGetGlobal 9
8671: oPushResult
8672: oTypeSPush
8673: oPop 1
8675: oCall 5884
8677: oCall 12079
8679: oEmit 36
8681: oInput 17
8683: oReturn
8684: oLocalSpace 2
8686: oTypeSNodeType
8687: oChoice 8691
8689: oJumpForward 8696
8691: Choice Lookup Table
          38   8689
8694: oError 11
8696: oTypeSTop
8697: oPushResult
8698: oSetResult 41
8700: oPushResult
8701: oNodeGet
8702: oPop 2
8704: oPushResult
8705: oScopeEnter
8706: oPop 1
8708: oInput 0
8710: oGetAddrLocal 1
8712: oPushResult
8713: oScopeFindRequire
8714: oAssign
8715: oGetLocal 1
8717: oPushResult
8718: oNodeType
8719: oPop 1
8721: oChoice 8725
8723: oJumpForward 8730
8725: Choice Lookup Table
          23   8723
8728: oError 12
8730: oScopeEnd
8731: oGetAddrLocal 2
8733: oPushResult
8734: oGetLocal 1
8736: oPushResult
8737: oSetResult 22
8739: oPushResult
8740: oNodeGetInt
8741: oPop 2
8743: oAssign
8744: oGetLocal 2
8746: oPushResult
8747: equal_zero
8748: oPop 1
8750: oChoice 8764
8752: oEmit 15
8754: oGetLocal 2
8756: oPushResult
8757: oEmitInt
8758: oPop 1
8760: oEmit 36
8762: oJumpForward 8767
8764: Choice Lookup Table
           0   8752
8767: oTypeSPop
8768: oGetLocal 1
8770: oPushResult
8771: oSetResult 21
8773: oPushResult
8774: oNodeGet
8775: oPop 2
8777: oPushResult
8778: oTypeSPush
8779: oPop 1
8781: oReturn
8782: oLocalSpace 2
8784: oGetAddrLocal 1
8786: oPushResult
8787: oTypeSTop
8788: oPushResult
8789: oSetResult 37
8791: oPushResult
8792: oNodeGet
8793: oPop 2
8795: oAssign
8796: oGetAddrLocal 2
8798: oPushResult
8799: oGetLocal 1
8801: oPushResult
8802: oSetResult 17
8804: oPushResult
8805: oNodeGetInt
8806: oPop 2
8808: oAssign
8809: oGetLocal 2
8811: oPushResult
8812: oSetResult 1
8814: oPushResult
8815: equal
8816: oPop 2
8818: oChoice 8832
8820: oEmit 15
8822: oGetLocal 2
8824: oPushResult
8825: oEmitInt
8826: oPop 1
8828: oEmit 34
8830: oJumpForward 8835
8832: Choice Lookup Table
           0   8820
8835: oEmit 36
8837: oReturn
8838: oLocalSpace 2
8840: oGetAddrLocal 1
8842: oPushResult
8843: oTypeSTop
8844: oPushResult
8845: oSetResult 37
8847: oPushResult
8848: oNodeGet
8849: oPop 2
8851: oAssign
8852: oGetAddrLocal 2
8854: oPushResult
8855: oGetLocal 1
8857: oPushResult
8858: oSetResult 17
8860: oPushResult
8861: oNodeGetInt
8862: oPop 2
8864: oAssign
8865: oGetLocal 2
8867: oPushResult
8868: oSetResult 1
8870: oPushResult
8871: equal
8872: oPop 2
8874: oChoice 8888
8876: oEmit 15
8878: oGetLocal 2
8880: oPushResult
8881: oEmitInt
8882: oPop 1
8884: oEmit 34
8886: oJumpForward 8891
8888: Choice Lookup Table
           0   8876
8891: oEmit 39
8893: oReturn
8894: oLocalSpace 2
8896: oEmit 38
8898: oGetAddrLocal 1
8900: oPushResult
8901: oTypeSTop
8902: oPushResult
8903: oSetResult 37
8905: oPushResult
8906: oNodeGet
8907: oPop 2
8909: oAssign
8910: oGetAddrLocal 2
8912: oPushResult
8913: oGetLocal 1
8915: oPushResult
8916: oSetResult 17
8918: oPushResult
8919: oNodeGetInt
8920: oPop 2
8922: oAssign
8923: oGetLocal 2
8925: oPushResult
8926: oSetResult 1
8928: oPushResult
8929: equal
8930: oPop 2
8932: oChoice 8946
8934: oEmit 15
8936: oGetLocal 2
8938: oPushResult
8939: oEmitInt
8940: oPop 1
8942: oEmit 35
8944: oJumpForward 8949
8946: Choice Lookup Table
           0   8934
8949: oTypeSPop
8950: oGetGlobal 6
8952: oPushResult
8953: oTypeSPush
8954: oPop 1
8956: oReturn
8957: oLocalSpace 1
8959: oTypeSNodeType
8960: oChoice 8968
8962: oJumpForward 8975
8964: oError 29
8966: oJumpForward 8975
8968: Choice Lookup Table
          35   8964
          34   8962
8973: oError 9
8975: oEmit 25
8977: oGetAddrLocal 1
8979: oPushResult
8980: oTypeSTop
8981: oAssign
8982: oTypeSPop
8983: oGetLocal 1
8985: oPushResult
8986: oSetResult 37
8988: oPushResult
8989: oNodeGet
8990: oPop 2
8992: oPushResult
8993: oTypeSPush
8994: oPop 1
8996: oReturn
8997: oLocalSpace 2
8999: oGetAddrLocal 1
9001: oPushResult
9002: oTypeSNodeType
9003: oAssign
9004: oTypeSPop
9005: oGetLocal 1
9007: oPushResult
9008: oTypeSNodeType
9009: oPushResult
9010: equal_node_type
9011: oPop 2
9013: oChoice 9145
9015: oTypeSNodeType
9016: oChoice 9130
9018: oGetLocal 1
9020: oChoice 9027
9022: oEmit 30
9024: oReturn
9025: oJumpForward 9030
9027: Choice Lookup Table
          30   9022
9030: oJumpForward 9141
9032: oGetLocal 1
9034: oChoice 9041
9036: oEmit 31
9038: oReturn
9039: oJumpForward 9044
9041: Choice Lookup Table
          29   9036
9044: oJumpForward 9141
9046: oGetLocal 1
9048: oChoice 9081
9050: oReturn
9051: oJumpForward 9086
9053: oTypeSTop
9054: oPushResult
9055: oGetGlobal 10
9057: oPushResult
9058: equal_node
9059: oPop 2
9061: oChoice 9076
9063: oEmit 15
9065: oSetResult 1
9067: oPushResult
9068: oEmitInt
9069: oPop 1
9071: oEmit 36
9073: oReturn
9074: oJumpForward 9079
9076: Choice Lookup Table
           1   9063
9079: oJumpForward 9086
9081: Choice Lookup Table
          39   9053
          35   9050
9086: oJumpForward 9141
9088: oGetLocal 1
9090: oChoice 9095
9092: oReturn
9093: oJumpForward 9098
9095: Choice Lookup Table
          34   9092
9098: oJumpForward 9141
9100: oGetLocal 1
9102: oChoice 9123
9104: oReturn
9105: oJumpForward 9128
9107: oGetGlobal 9
9109: oPushResult
9110: oTypeSPush
9111: oPop 1
9113: oGetAddrLocal 2
9115: oPushResult
9116: oCall 9149
9118: oAssign
9119: oTypeSPop
9120: oReturn
9121: oJumpForward 9128
9123: Choice Lookup Table
          33   9107
          39   9104
9128: oJumpForward 9141
9130: Choice Lookup Table
          40   9100
          35   9088
          34   9046
          30   9032
          29   9018
9141: oError 14
9143: oJumpForward 9148
9145: Choice Lookup Table
           0   9015
9148: oReturn
9149: oLocalSpace 1
9151: oGetAddrLocal 1
9153: oPushResult
9154: oGetGlobal 14
9156: oPushResult
9157: oScopeAllocType
9158: oPop 1
9160: oAssign
9161: oTypeSNodeType
9162: oChoice 9230
9164: oEmit 17
9166: oGetLocal 1
9168: oPushResult
9169: oEmitInt
9170: oPop 1
9172: oEmit 22
9174: oEmit 29
9176: oGetGlobal 14
9178: oPushResult
9179: oSetResult 17
9181: oPushResult
9182: oNodeGetInt
9183: oPop 2
9185: oPushResult
9186: oEmitInt
9187: oPop 1
9189: oJumpForward 9239
9191: oEmit 17
9193: oGetLocal 1
9195: oPushResult
9196: oEmitInt
9197: oPop 1
9199: oEmit 15
9201: oSetResult 1
9203: oPushResult
9204: oEmitInt
9205: oPop 1
9207: oEmit 27
9209: oEmit 17
9211: oGetLocal 1
9213: oPushResult
9214: oSetResult 1
9216: oPushResult
9217: add
9218: oPop 2
9220: oPushResult
9221: oEmitInt
9222: oPop 1
9224: oEmit 22
9226: oEmit 27
9228: oJumpForward 9239
9230: Choice Lookup Table
          33   9191
          39   9164
          40   9164
9237: oError 14
9239: oTypeSPop
9240: oEmit 17
9242: oGetLocal 1
9244: oPushResult
9245: oEmitInt
9246: oPop 1
9248: oGetGlobal 14
9250: oPushResult
9251: oTypeSPush
9252: oPop 1
9254: oGetLocal 1
9256: oReturn
9257: oReturn
9258: oLocalSpace 0
9260: oEmit 61
9262: oSetResult 16
9264: oPushResult
9265: oEmitInt
9266: oPop 1
9268: oEmit 19
9270: oSetResult 8
9272: oPushResult
9273: oEmitInt
9274: oPop 1
9276: oEmit 22
9278: oEmit 28
9280: oEmit 19
9282: oSetResult 0
9284: oPushResult
9285: oEmitInt
9286: oPop 1
9288: oEmit 22
9290: oEmit 28
9292: oEmit 64
9294: oGetGlobal 19
9296: oPushResult
9297: oCall 12535
9299: oPop 1
9301: oEmit 63
9303: oSetResult 16
9305: oPushResult
9306: oEmitInt
9307: oPop 1
9309: oTypeSPop
9310: oTypeSPop
9311: oReturn
9312: oLocalSpace 0
9314: oEmit 61
9316: oSetResult 12
9318: oPushResult
9319: oEmitInt
9320: oPop 1
9322: oEmit 19
9324: oSetResult 8
9326: oPushResult
9327: oEmitInt
9328: oPop 1
9330: oEmit 22
9332: oEmit 26
9334: oEmit 19
9336: oSetResult 0
9338: oPushResult
9339: oEmitInt
9340: oPop 1
9342: oEmit 22
9344: oEmit 28
9346: oEmit 64
9348: oGetGlobal 20
9350: oPushResult
9351: oCall 12535
9353: oPop 1
9355: oEmit 63
9357: oSetResult 12
9359: oPushResult
9360: oEmitInt
9361: oPop 1
9363: oTypeSPop
9364: oTypeSPop
9365: oReturn
9366: oLocalSpace 1
9368: oEmit 61
9370: oSetResult 24
9372: oPushResult
9373: oEmitInt
9374: oPop 1
9376: oEmit 19
9378: oSetResult 8
9380: oPushResult
9381: oEmitInt
9382: oPop 1
9384: oEmit 22
9386: oEmit 28
9388: oEmit 19
9390: oSetResult 0
9392: oPushResult
9393: oEmitInt
9394: oPop 1
9396: oEmit 22
9398: oEmit 28
9400: oGetAddrLocal 1
9402: oPushResult
9403: oGetGlobal 6
9405: oPushResult
9406: oScopeAllocType
9407: oPop 1
9409: oAssign
9410: oEmit 19
9412: oSetResult 16
9414: oPushResult
9415: oEmitInt
9416: oPop 1
9418: oEmit 17
9420: oGetLocal 1
9422: oPushResult
9423: oEmitInt
9424: oPop 1
9426: oEmit 28
9428: oEmit 64
9430: oGetGlobal 21
9432: oPushResult
9433: oCall 12535
9435: oPop 1
9437: oEmit 3
9439: oGetLocal 1
9441: oPushResult
9442: oEmitInt
9443: oPop 1
9445: oEmit 63
9447: oSetResult 24
9449: oPushResult
9450: oEmitInt
9451: oPop 1
9453: oTypeSPop
9454: oGetGlobal 6
9456: oPushResult
9457: oTypeSPush
9458: oPop 1
9460: oReturn
9461: oLocalSpace 2
9463: oGetAddrLocal 2
9465: oPushResult
9466: oGetParam 1
9468: oPushResult
9469: oSetResult 26
9471: oPushResult
9472: oNodeGetString
9473: oPop 2
9475: oAssign
9476: oGetLocal 2
9478: oPushResult
9479: oSetResult 0
9481: oPushResult
9482: equal_string
9483: oPop 2
9485: oChoice 9522
9487: oGetAddrLocal 1
9489: oPushResult
9490: oGetParam 1
9492: oPushResult
9493: oSetResult 4
9495: oPushResult
9496: oNodeGetInt
9497: oPop 2
9499: oPushResult
9500: ID_STRING
9501: oPop 1
9503: oPushResult
9504: oStringAllocLit
9505: oPop 1
9507: oAssign
9508: oJumpForward 9528
9510: oGetAddrLocal 1
9512: oPushResult
9513: oGetLocal 2
9515: oPushResult
9516: oStringAllocLit
9517: oPop 1
9519: oAssign
9520: oJumpForward 9528
9522: Choice Lookup Table
           0   9510
           1   9487
9527: oEndChoice
9528: oEmit 79
9530: oGetParam 1
9532: oPushResult
9533: oCall 12535
9535: oPop 1
9537: oGetLocal 1
9539: oPushResult
9540: oEmitInt
9541: oPop 1
9543: oReturn
9544: oLocalSpace 10
9546: oGetParam 1
9548: oPushResult
9549: oSetResult 25
9551: oPushResult
9552: oNodeGetBoolean
9553: oPop 2
9555: oChoice 9582
9557: oGetParam 1
9559: oPushResult
9560: oSetResult 28
9562: oPushResult
9563: oNodeGetBoolean
9564: oPop 2
9566: oChoice 9577
9568: oGetParam 1
9570: oPushResult
9571: oCall 9461
9573: oPop 1
9575: oJumpForward 9580
9577: Choice Lookup Table
           0   9568
9580: oJumpForward 9585
9582: Choice Lookup Table
           1   9557
9585: oGetParam 1
9587: oPushResult
9588: oSetResult 28
9590: oPushResult
9591: oSetResult 1
9593: oPushResult
9594: oNodeSetBoolean
9595: oPop 3
9597: oGetAddrLocal 1
9599: oPushResult
9600: oGetParam 1
9602: oPushResult
9603: oSetResult 27
9605: oPushResult
9606: oNodeGetBoolean
9607: oPop 2
9609: oAssign
9610: oGetAddrLocal 4
9612: oPushResult
9613: oGetParam 1
9615: oPushResult
9616: oNodeType
9617: oPop 1
9619: oPushResult
9620: oSetResult 13
9622: oPushResult
9623: equal_node_type
9624: oPop 2
9626: oAssign
9627: oGetLocal 4
9629: oChoice 9656
9631: oGetAddrLocal 2
9633: oPushResult
9634: oGetParam 1
9636: oPushResult
9637: oSetResult 21
9639: oPushResult
9640: oNodeGet
9641: oPop 2
9643: oAssign
9644: oGetAddrLocal 3
9646: oPushResult
9647: oGetLocal 2
9649: oPushResult
9650: oScopeAllocType
9651: oPop 1
9653: oAssign
9654: oJumpForward 9659
9656: Choice Lookup Table
           1   9631
9659: oGetAddrLocal 5
9661: oPushResult
9662: oGetParam 1
9664: oPushResult
9665: oSetResult 23
9667: oPushResult
9668: oNodeGet
9669: oPop 2
9671: oAssign
9672: oGetAddrLocal 6
9674: oPushResult
9675: oGetLocal 5
9677: oPushResult
9678: oSetResult 17
9680: oPushResult
9681: oNodeGetInt
9682: oPop 2
9684: oAssign
9685: oGetLocal 1
9687: oChoice 9709
9689: oEmit 62
9691: oGetLocal 6
9693: oPushResult
9694: oEmitInt
9695: oPop 1
9697: oJumpForward 9715
9699: oEmit 61
9701: oGetLocal 6
9703: oPushResult
9704: oEmitInt
9705: oPop 1
9707: oJumpForward 9715
9709: Choice Lookup Table
           0   9699
           1   9689
9714: oEndChoice
9715: oGetParam 1
9717: oPushResult
9718: oCall 11983
9720: oPop 1
9722: oPushResult
9723: oSetResult 0
9725: oPushResult
9726: greater
9727: oPop 2
9729: oChoice 9762
9731: oEmit 19
9733: oSetResult 0
9735: oPushResult
9736: oEmitInt
9737: oPop 1
9739: oEmit 20
9741: oGetParam 1
9743: oPushResult
9744: oCall 12003
9746: oPop 1
9748: oPushResult
9749: oEmitInt
9750: oPop 1
9752: oSetResult 0
9754: oPushResult
9755: oEmitInt
9756: oPop 1
9758: oEmit 28
9760: oJumpForward 9765
9762: Choice Lookup Table
           1   9731
9765: oGetAddrLocal 7
9767: oPushResult
9768: oGetLocal 5
9770: oPushResult
9771: oSetResult 15
9773: oPushResult
9774: oNodeGetIter
9775: oPop 2
9777: oAssign
9778: oGetAddrLocal 8
9780: oPushResult
9781: oGetLocal 7
9783: oPushResult
9784: oNodeIterValue
9785: oPop 1
9787: oAssign
9788: oInputChoice 9985
9790: oGetLocal 8
9792: oPushResult
9793: oNodeNull
9794: oPop 1
9796: oChoice 9802
9798: oJumpForward 9981
9800: oJumpForward 9805
9802: Choice Lookup Table
           1   9798
9805: oGetAddrLocal 9
9807: oPushResult
9808: oGetLocal 8
9810: oPushResult
9811: oSetResult 22
9813: oPushResult
9814: oNodeGetInt
9815: oPop 2
9817: oAssign
9818: oEmit 19
9820: oGetLocal 9
9822: oPushResult
9823: oEmitInt
9824: oPop 1
9826: oGetLocal 8
9828: oPushResult
9829: oSetResult 21
9831: oPushResult
9832: oNodeGet
9833: oPop 2
9835: oPushResult
9836: oTypeSPush
9837: oPop 1
9839: oGetLocal 8
9841: oPushResult
9842: oSetResult 34
9844: oPushResult
9845: oNodeGetBoolean
9846: oPop 2
9848: oChoice 9934
9850: oSetResult 1
9852: oPushResult
9853: oCall 10811
9855: oPop 1
9857: oCall 12021
9859: oEmit 28
9861: oJumpForward 9940
9863: oCall 5884
9865: oCall 8997
9867: oTypeSNodeType
9868: oChoice 9908
9870: oEmit 26
9872: oJumpForward 9932
9874: oEmit 27
9876: oJumpForward 9932
9878: oError 16
9880: oJumpForward 9932
9882: oEmit 28
9884: oJumpForward 9932
9886: oGetAddrLocal 10
9888: oPushResult
9889: oTypeSTop
9890: oPushResult
9891: oSetResult 17
9893: oPushResult
9894: oNodeGetInt
9895: oPop 2
9897: oAssign
9898: oEmit 29
9900: oGetLocal 10
9902: oPushResult
9903: oEmitInt
9904: oPop 1
9906: oJumpForward 9932
9908: Choice Lookup Table
          40   9886
          38   9886
          36   9886
          35   9882
          34   9882
          28   9878
          33   9874
          30   9874
          31   9874
          41   9870
          29   9870
9931: oEndChoice
9932: oJumpForward 9940
9934: Choice Lookup Table
           0   9863
           1   9850
9939: oEndChoice
9940: oTypeSPop
9941: oGetAddrLocal 7
9943: oPushResult
9944: oNodeIterNext
9945: oPop 1
9947: oGetAddrLocal 8
9949: oPushResult
9950: oGetLocal 7
9952: oPushResult
9953: oNodeIterValue
9954: oPop 1
9956: oAssign
9957: oGetLocal 8
9959: oPushResult
9960: oNodeNull
9961: oPop 1
9963: oChoice 9971
9965: oJumpForward 9981
9967: oJumpForward 9977
9969: oJumpForward 9977
9971: Choice Lookup Table
           0   9969
           1   9965
9976: oEndChoice
9977: oInput 13
9979: oJumpBack 9790
9981: oInput 15
9983: oJumpForward 9988
9985: Choice Lookup Table
          14   9790
9988: oGetLocal 8
9990: oPushResult
9991: oNodeNull
9992: oPop 1
9994: oChoice 10000
9996: oError 15
9998: oJumpForward 10003
10000: Choice Lookup Table
           0   9996
10003: oGetLocal 4
10005: oChoice 10034
10007: oEmit 19
10009: oGetParam 1
10011: oPushResult
10012: oSetResult 31
10014: oPushResult
10015: oNodeGetInt
10016: oPop 2
10018: oPushResult
10019: oEmitInt
10020: oPop 1
10022: oEmit 17
10024: oGetLocal 3
10026: oPushResult
10027: oEmitInt
10028: oPop 1
10030: oEmit 28
10032: oJumpForward 10037
10034: Choice Lookup Table
           1   10007
10037: oGetLocal 1
10039: oChoice 10063
10041: oEmit 65
10043: oGetParam 1
10045: oPushResult
10046: oCall 12535
10048: oPop 1
10050: oJumpForward 10069
10052: oEmit 64
10054: oGetParam 1
10056: oPushResult
10057: oCall 12535
10059: oPop 1
10061: oJumpForward 10069
10063: Choice Lookup Table
           0   10052
           1   10041
10068: oEndChoice
10069: oGetLocal 4
10071: oChoice 10152
10073: oGetLocal 2
10075: oPushResult
10076: oTypeSPush
10077: oPop 1
10079: oTypeSNodeType
10080: oChoice 10126
10082: oEmit 3
10084: oGetLocal 3
10086: oPushResult
10087: oEmitInt
10088: oPop 1
10090: oJumpForward 10150
10092: oEmit 4
10094: oGetLocal 3
10096: oPushResult
10097: oEmitInt
10098: oPop 1
10100: oJumpForward 10150
10102: oError 16
10104: oJumpForward 10150
10106: oEmit 5
10108: oGetLocal 3
10110: oPushResult
10111: oEmitInt
10112: oPop 1
10114: oJumpForward 10150
10116: oEmit 17
10118: oGetLocal 3
10120: oPushResult
10121: oEmitInt
10122: oPop 1
10124: oJumpForward 10150
10126: Choice Lookup Table
          40   10116
          38   10116
          36   10116
          35   10106
          34   10106
          28   10102
          33   10092
          30   10092
          31   10092
          41   10082
          29   10082
10149: oEndChoice
10150: oJumpForward 10155
10152: Choice Lookup Table
           1   10073
10155: oEmit 63
10157: oGetLocal 6
10159: oPushResult
10160: oEmitInt
10161: oPop 1
10163: oReturn
10164: oLocalSpace 0
10166: oGetParam 1
10168: oPushResult
10169: oGetGlobal 15
10171: oPushResult
10172: oNodeEqual
10173: oPop 2
10175: oChoice 10215
10177: oInput 14
10179: oCall 5884
10181: oTypeSNodeType
10182: oChoice 10190
10184: oJumpForward 10203
10186: oEmit 30
10188: oJumpForward 10203
10190: Choice Lookup Table
          33   10186
          30   10186
          31   10186
          41   10184
          29   10184
10201: oError 14
10203: oTypeSPop
10204: oGetGlobal 6
10206: oPushResult
10207: oTypeSPush
10208: oPop 1
10210: oInput 15
10212: oReturn
10213: oJumpForward 10218
10215: Choice Lookup Table
           1   10177
10218: oGetParam 1
10220: oPushResult
10221: oGetGlobal 16
10223: oPushResult
10224: oNodeEqual
10225: oPop 2
10227: oChoice 10261
10229: oInput 14
10231: oCall 5884
10233: oTypeSNodeType
10234: oChoice 10242
10236: oEmit 31
10238: oJumpForward 10249
10240: oJumpForward 10249
10242: Choice Lookup Table
          30   10240
          29   10236
10247: oError 14
10249: oTypeSPop
10250: oGetGlobal 9
10252: oPushResult
10253: oTypeSPush
10254: oPop 1
10256: oInput 15
10258: oReturn
10259: oJumpForward 10264
10261: Choice Lookup Table
           1   10229
10264: oGetParam 1
10266: oPushResult
10267: oGetGlobal 17
10269: oPushResult
10270: oNodeEqual
10271: oPop 2
10273: oChoice 10313
10275: oInput 14
10277: oCall 5884
10279: oTypeSNodeType
10280: oChoice 10301
10282: oTypeSTop
10283: oPushResult
10284: oSetResult 44
10286: oPushResult
10287: oNodeGetBoolean
10288: oPop 2
10290: oChoice 10296
10292: oError 28
10294: oJumpForward 10299
10296: Choice Lookup Table
           1   10292
10299: oJumpForward 10306
10301: Choice Lookup Table
          41   10282
10304: oError 14
10306: oEmit 33
10308: oInput 15
10310: oReturn
10311: oJumpForward 10316
10313: Choice Lookup Table
           1   10275
10316: oGetParam 1
10318: oPushResult
10319: oGetGlobal 18
10321: oPushResult
10322: oNodeEqual
10323: oPop 2
10325: oChoice 10365
10327: oInput 14
10329: oCall 5884
10331: oTypeSNodeType
10332: oChoice 10353
10334: oTypeSTop
10335: oPushResult
10336: oSetResult 44
10338: oPushResult
10339: oNodeGetBoolean
10340: oPop 2
10342: oChoice 10348
10344: oError 28
10346: oJumpForward 10351
10348: Choice Lookup Table
           1   10344
10351: oJumpForward 10358
10353: Choice Lookup Table
          41   10334
10356: oError 14
10358: oEmit 32
10360: oInput 15
10362: oReturn
10363: oJumpForward 10368
10365: Choice Lookup Table
           1   10327
10368: oError 16
10370: oReturn
10371: oLocalSpace 0
10373: oInputChoice 10436
10375: oCall 11834
10377: oJumpForward 10467
10379: oCall 11841
10381: oJumpForward 10467
10383: oCall 11965
10385: oJumpForward 10467
10387: oCall 11968
10389: oJumpForward 10467
10391: oCall 11049
10393: oJumpForward 10467
10395: oCall 11372
10397: oJumpForward 10467
10399: oCall 11115
10401: oJumpForward 10467
10403: oCall 11292
10405: oJumpForward 10467
10407: oCall 11457
10409: oJumpForward 10467
10411: oCall 11425
10413: oJumpForward 10467
10415: oCall 11811
10417: oJumpForward 10467
10419: oCall 10468
10421: oJumpForward 10467
10423: oCall 11489
10425: oJumpForward 10467
10427: oCall 11759
10429: oJumpForward 10467
10431: oChangeIntLitToLabelIdent
10432: oCall 10468
10434: oJumpForward 10467
10436: Choice Lookup Table
           1   10431
          55   10427
          53   10423
           0   10419
          35   10415
          51   10411
          52   10407
          49   10403
          44   10399
          48   10395
          41   10391
          68   10387
          67   10383
          66   10379
          65   10375
10467: oReturn
10468: oLocalSpace 1
10470: oGetAddrLocal 1
10472: oPushResult
10473: oScopeFindRequire
10474: oAssign
10475: oGetAddrLocal 1
10477: oPushResult
10478: oCall 543
10480: oPop 1
10482: oGetLocal 1
10484: oPushResult
10485: oNodeType
10486: oPop 1
10488: oChoice 10528
10490: oGetLocal 1
10492: oPushResult
10493: oCall 10544
10495: oPop 1
10497: oCall 10371
10499: oJumpForward 10543
10501: oGetLocal 1
10503: oPushResult
10504: oCall 9544
10506: oPop 1
10508: oJumpForward 10543
10510: oGetLocal 1
10512: oPushResult
10513: oCall 10594
10515: oPop 1
10517: oJumpForward 10543
10519: oGetLocal 1
10521: oPushResult
10522: oCall 10684
10524: oPop 1
10526: oJumpForward 10543
10528: Choice Lookup Table
          13   10519
          24   10510
          22   10510
          21   10510
          12   10501
          26   10490
10541: oError 0
10543: oReturn
10544: oLocalSpace 0
10546: oGetParam 1
10548: oPushResult
10549: oSetResult 35
10551: oPushResult
10552: oNodeGetBoolean
10553: oPop 2
10555: oChoice 10561
10557: oError 21
10559: oJumpForward 10564
10561: Choice Lookup Table
           1   10557
10564: oEmit 77
10566: oGetParam 1
10568: oPushResult
10569: oSetResult 22
10571: oPushResult
10572: oNodeGetLabel
10573: oPop 2
10575: oPushResult
10576: oEmitLabel
10577: oPop 1
10579: oGetParam 1
10581: oPushResult
10582: oSetResult 35
10584: oPushResult
10585: oSetResult 1
10587: oPushResult
10588: oNodeSetBoolean
10589: oPop 3
10591: oInput 12
10593: oReturn
10594: oLocalSpace 0
10596: oGetParam 1
10598: oPushResult
10599: oSetResult 1
10601: oPushResult
10602: oCall 10859
10604: oPop 2
10606: oInput 4
10608: oCall 5884
10610: oCall 8997
10612: oCall 10615
10614: oReturn
10615: oLocalSpace 1
10617: oTypeSNodeType
10618: oChoice 10658
10620: oEmit 26
10622: oJumpForward 10682
10624: oEmit 27
10626: oJumpForward 10682
10628: oError 16
10630: oJumpForward 10682
10632: oEmit 28
10634: oJumpForward 10682
10636: oGetAddrLocal 1
10638: oPushResult
10639: oTypeSTop
10640: oPushResult
10641: oSetResult 17
10643: oPushResult
10644: oNodeGetInt
10645: oPop 2
10647: oAssign
10648: oEmit 29
10650: oGetLocal 1
10652: oPushResult
10653: oEmitInt
10654: oPop 1
10656: oJumpForward 10682
10658: Choice Lookup Table
          40   10636
          38   10636
          36   10636
          35   10632
          34   10632
          28   10628
          33   10624
          30   10624
          31   10624
          41   10620
          29   10620
10681: oEndChoice
10682: oTypeSPop
10683: oReturn
10684: oLocalSpace 1
10686: oGetParam 1
10688: oPushResult
10689: oSetResult 6
10691: oPushResult
10692: oNodeGet
10693: oPop 2
10695: oPushResult
10696: oScopeCurrent
10697: oPushResult
10698: oNodeEqual
10699: oPop 2
10701: oChoice 10707
10703: oError 20
10705: oJumpForward 10710
10707: Choice Lookup Table
           0   10703
10710: oEmit 8
10712: oGetParam 1
10714: oPushResult
10715: oSetResult 31
10717: oPushResult
10718: oNodeGetInt
10719: oPop 2
10721: oPushResult
10722: oEmitInt
10723: oPop 1
10725: oGetParam 1
10727: oPushResult
10728: oSetResult 21
10730: oPushResult
10731: oNodeGet
10732: oPop 2
10734: oPushResult
10735: oTypeSPush
10736: oPop 1
10738: oInput 4
10740: oCall 5884
10742: oCall 8997
10744: oTypeSNodeType
10745: oChoice 10785
10747: oEmit 26
10749: oJumpForward 10809
10751: oEmit 27
10753: oJumpForward 10809
10755: oError 16
10757: oJumpForward 10809
10759: oEmit 28
10761: oJumpForward 10809
10763: oGetAddrLocal 1
10765: oPushResult
10766: oTypeSTop
10767: oPushResult
10768: oSetResult 17
10770: oPushResult
10771: oNodeGetInt
10772: oPop 2
10774: oAssign
10775: oEmit 29
10777: oGetLocal 1
10779: oPushResult
10780: oEmitInt
10781: oPop 1
10783: oJumpForward 10809
10785: Choice Lookup Table
          40   10763
          38   10763
          36   10763
          35   10759
          34   10759
          28   10755
          33   10751
          30   10751
          31   10751
          41   10747
          29   10747
10808: oEndChoice
10809: oTypeSPop
10810: oReturn
10811: oLocalSpace 1
10813: oInput 0
10815: oGetAddrLocal 1
10817: oPushResult
10818: oScopeFindRequire
10819: oAssign
10820: oGetAddrLocal 1
10822: oPushResult
10823: oCall 543
10825: oPop 1
10827: oGetLocal 1
10829: oPushResult
10830: oNodeType
10831: oPop 1
10833: oChoice 10837
10835: oJumpForward 10848
10837: Choice Lookup Table
          25   10835
          24   10835
          22   10835
          21   10835
10846: oError 4
10848: oGetLocal 1
10850: oPushResult
10851: oGetParam 1
10853: oPushResult
10854: oCall 10859
10856: oPop 2
10858: oReturn
10859: oLocalSpace 0
10861: oGetParam 2
10863: oPushResult
10864: oNodeType
10865: oPop 1
10867: oChoice 10949
10869: oEmit 16
10871: oGetParam 2
10873: oPushResult
10874: oCall 12535
10876: oPop 1
10878: oJumpForward 10960
10880: oEmit 17
10882: oGetParam 2
10884: oPushResult
10885: oCall 12535
10887: oPop 1
10889: oJumpForward 10960
10891: oGetParam 2
10893: oPushResult
10894: oSetResult 34
10896: oPushResult
10897: oNodeGetBoolean
10898: oPop 2
10900: oChoice 10913
10902: oEmit 8
10904: oGetParam 2
10906: oPushResult
10907: oCall 12535
10909: oPop 1
10911: oJumpForward 10925
10913: Choice Lookup Table
           1   10902
10916: oEmit 18
10918: oGetParam 2
10920: oPushResult
10921: oCall 12535
10923: oPop 1
10925: oJumpForward 10960
10927: oGetParam 1
10929: oChoice 10942
10931: oEmit 16
10933: oGetParam 2
10935: oPushResult
10936: oCall 12535
10938: oPop 1
10940: oJumpForward 10947
10942: Choice Lookup Table
           0   10931
10945: oError 4
10947: oJumpForward 10960
10949: Choice Lookup Table
          25   10927
          24   10891
          22   10880
          21   10869
10958: oError 4
10960: oGetParam 2
10962: oPushResult
10963: oSetResult 21
10965: oPushResult
10966: oNodeGet
10967: oPop 2
10969: oPushResult
10970: oTypeSPush
10971: oPop 1
10973: oTypeSNodeType
10974: oChoice 10989
10976: oInputChoice 10984
10978: oEmit 25
10980: oCall 8575
10982: oJumpForward 10987
10984: Choice Lookup Table
          16   10978
10987: oJumpForward 10992
10989: Choice Lookup Table
          34   10976
10992: oCall 8380
10994: oReturn
10995: oLocalSpace 0
10997: oGetParam 1
10999: oPushResult
11000: oSetResult 1
11002: oPushResult
11003: oCall 10859
11005: oPop 2
11007: oCall 12079
11009: oGetParam 1
11011: oPushResult
11012: oCall 7569
11014: oPop 1
11016: oTypeSPop
11017: oEmit 32
11019: oEmit 26
11021: oReturn
11022: oLocalSpace 0
11024: oGetParam 1
11026: oPushResult
11027: oSetResult 1
11029: oPushResult
11030: oCall 10859
11032: oPop 2
11034: oCall 12079
11036: oGetParam 1
11038: oPushResult
11039: oCall 7569
11041: oPop 1
11043: oTypeSPop
11044: oEmit 33
11046: oEmit 26
11048: oReturn
11049: oLocalSpace 2
11051: oGetAddrLocal 1
11053: oPushResult
11054: oSetResult 0
11056: oAssign
11057: oGetAddrLocal 1
11059: oPushResult
11060: oCall 5907
11062: oPop 1
11064: oInput 42
11066: oCall 10371
11068: oInputChoice 11103
11070: oGetAddrLocal 2
11072: oPushResult
11073: oLabelNew
11074: oAssign
11075: oEmit 68
11077: oGetLocal 2
11079: oPushResult
11080: oEmitLabel
11081: oPop 1
11083: oEmit 77
11085: oGetLocal 1
11087: oPushResult
11088: oEmitLabel
11089: oPop 1
11091: oCall 10371
11093: oEmit 77
11095: oGetLocal 2
11097: oPushResult
11098: oEmitLabel
11099: oPop 1
11101: oJumpForward 11114
11103: Choice Lookup Table
          43   11070
11106: oEmit 77
11108: oGetLocal 1
11110: oPushResult
11111: oEmitLabel
11112: oPop 1
11114: oReturn
11115: oLocalSpace 4
11117: oInput 0
11119: oGetAddrLocal 1
11121: oPushResult
11122: oScopeFindRequire
11123: oAssign
11124: oGetLocal 1
11126: oPushResult
11127: oSetResult 1
11129: oPushResult
11130: oCall 10859
11132: oPop 2
11134: oCall 12079
11136: oInput 4
11138: oCall 5884
11140: oCall 12079
11142: oEmit 26
11144: oGetAddrLocal 2
11146: oPushResult
11147: oLabelNew
11148: oAssign
11149: oGetAddrLocal 3
11151: oPushResult
11152: oLabelNew
11153: oAssign
11154: oEmit 68
11156: oGetLocal 3
11158: oPushResult
11159: oEmitLabel
11160: oPop 1
11162: oGetAddrLocal 4
11164: oPushResult
11165: oLabelNew
11166: oAssign
11167: oEmit 77
11169: oGetLocal 4
11171: oPushResult
11172: oEmitLabel
11173: oPop 1
11175: oInputChoice 11255
11177: oGetLocal 1
11179: oPushResult
11180: oCall 10995
11182: oPop 1
11184: oEmit 77
11186: oGetLocal 3
11188: oPushResult
11189: oEmitLabel
11190: oPop 1
11192: oGetLocal 1
11194: oPushResult
11195: oCall 7569
11197: oPop 1
11199: oTypeSPop
11200: oCall 5884
11202: oCall 12079
11204: oEmit 51
11206: oEmit 69
11208: oGetLocal 2
11210: oPushResult
11211: oEmitLabel
11212: oPop 1
11214: oJumpForward 11261
11216: oGetLocal 1
11218: oPushResult
11219: oCall 11022
11221: oPop 1
11223: oEmit 77
11225: oGetLocal 3
11227: oPushResult
11228: oEmitLabel
11229: oPop 1
11231: oGetLocal 1
11233: oPushResult
11234: oCall 7569
11236: oPop 1
11238: oTypeSPop
11239: oCall 5884
11241: oCall 12079
11243: oEmit 52
11245: oEmit 69
11247: oGetLocal 2
11249: oPushResult
11250: oEmitLabel
11251: oPop 1
11253: oJumpForward 11261
11255: Choice Lookup Table
          46   11216
          45   11177
11260: oEndChoice
11261: oGetLocal 4
11263: oPushResult
11264: oGetLocal 2
11266: oPushResult
11267: oLoopPush
11268: oPop 2
11270: oInput 47
11272: oCall 10371
11274: oEmit 68
11276: oGetLocal 4
11278: oPushResult
11279: oEmitLabel
11280: oPop 1
11282: oEmit 77
11284: oGetLocal 2
11286: oPushResult
11287: oEmitLabel
11288: oPop 1
11290: oLoopPop
11291: oReturn
11292: oLocalSpace 3
11294: oGetAddrLocal 1
11296: oPushResult
11297: oLabelNew
11298: oAssign
11299: oEmit 77
11301: oGetLocal 1
11303: oPushResult
11304: oEmitLabel
11305: oPop 1
11307: oGetAddrLocal 2
11309: oPushResult
11310: oLabelNew
11311: oAssign
11312: oGetLocal 1
11314: oPushResult
11315: oGetLocal 2
11317: oPushResult
11318: oLoopPush
11319: oPop 2
11321: oCall 10371
11323: oInputChoice 11354
11325: oCall 10371
11327: oJumpForward 11360
11329: oGetAddrLocal 3
11331: oPushResult
11332: oCall 5907
11334: oPop 1
11336: oEmit 78
11338: oGetLocal 3
11340: oPushResult
11341: oEmitLabel
11342: oPop 1
11344: oGetLocal 1
11346: oPushResult
11347: oEmitLabel
11348: oPop 1
11350: oJumpForward 11362
11352: oJumpForward 11360
11354: Choice Lookup Table
          50   11329
           5   11325
11359: oEndChoice
11360: oJumpBack 11323
11362: oEmit 77
11364: oGetLocal 2
11366: oPushResult
11367: oEmitLabel
11368: oPop 1
11370: oLoopPop
11371: oReturn
11372: oLocalSpace 2
11374: oGetAddrLocal 1
11376: oPushResult
11377: oLabelNew
11378: oAssign
11379: oEmit 77
11381: oGetLocal 1
11383: oPushResult
11384: oEmitLabel
11385: oPop 1
11387: oGetAddrLocal 2
11389: oPushResult
11390: oCall 5907
11392: oPop 1
11394: oGetLocal 1
11396: oPushResult
11397: oGetLocal 2
11399: oPushResult
11400: oLoopPush
11401: oPop 2
11403: oInput 47
11405: oCall 10371
11407: oEmit 68
11409: oGetLocal 1
11411: oPushResult
11412: oEmitLabel
11413: oPop 1
11415: oEmit 77
11417: oGetLocal 2
11419: oPushResult
11420: oEmitLabel
11421: oPop 1
11423: oLoopPop
11424: oReturn
11425: oLocalSpace 0
11427: oLoopContinueLabel
11428: oPushResult
11429: oSetResult 0
11431: oPushResult
11432: equal_label
11433: oPop 2
11435: oChoice 11450
11437: oError 18
11439: oJumpForward 11456
11441: oEmit 68
11443: oLoopContinueLabel
11444: oPushResult
11445: oEmitLabel
11446: oPop 1
11448: oJumpForward 11456
11450: Choice Lookup Table
           0   11441
           1   11437
11455: oEndChoice
11456: oReturn
11457: oLocalSpace 0
11459: oLoopBreakLabel
11460: oPushResult
11461: oSetResult 0
11463: oPushResult
11464: equal_label
11465: oPop 2
11467: oChoice 11482
11469: oError 18
11471: oJumpForward 11488
11473: oEmit 68
11475: oLoopBreakLabel
11476: oPushResult
11477: oEmitLabel
11478: oPop 1
11480: oJumpForward 11488
11482: Choice Lookup Table
           0   11473
           1   11469
11487: oEndChoice
11488: oReturn
11489: oLocalSpace 7
11491: oGetAddrLocal 1
11493: oPushResult
11494: oCodeNew
11495: oAssign
11496: oGetAddrLocal 2
11498: oPushResult
11499: oLabelNew
11500: oAssign
11501: oGetAddrLocal 3
11503: oPushResult
11504: oLabelNew
11505: oAssign
11506: oGetAddrLocal 4
11508: oPushResult
11509: oGetLocal 3
11511: oAssign
11512: oCall 5884
11514: oTypeSNodeType
11515: oChoice 11541
11517: oEmit 71
11519: oGetLocal 2
11521: oPushResult
11522: oEmitLabel
11523: oPop 1
11525: oJumpForward 11558
11527: oEmit 72
11529: oGetLocal 2
11531: oPushResult
11532: oEmitLabel
11533: oPop 1
11535: oJumpForward 11558
11537: oError 16
11539: oJumpForward 11558
11541: Choice Lookup Table
          39   11537
          40   11537
          41   11527
          29   11527
          33   11517
          30   11517
          31   11517
11556: oError 17
11558: oInput 40
11560: oInputChoice 11607
11562: oGetAddrLocal 4
11564: oPushResult
11565: oLabelNew
11566: oAssign
11567: oEmit 77
11569: oGetLocal 4
11571: oPushResult
11572: oEmitLabel
11573: oPop 1
11575: oInputChoice 11581
11577: oJumpForward 11599
11579: oJumpForward 11597
11581: Choice Lookup Table
          36   11577
11584: oCall 10371
11586: oInputChoice 11590
11588: oJumpForward 11597
11590: Choice Lookup Table
           5   11588
11593: oInput 36
11595: oJumpForward 11599
11597: oJumpBack 11575
11599: oJumpForward 11727
11601: oJumpForward 11725
11603: oJumpForward 11727
11605: oJumpForward 11725
11607: Choice Lookup Table
          36   11603
          43   11562
          54   11562
11614: oGetAddrLocal 5
11616: oPushResult
11617: oLabelNew
11618: oAssign
11619: oGetLocal 1
11621: oPushResult
11622: oCodePush
11623: oPop 1
11625: oCall 5229
11627: oCall 5811
11629: oGetAddrLocal 6
11631: oPushResult
11632: oValueTop
11633: oAssign
11634: oValuePop
11635: oInputChoice 11669
11637: oCall 5229
11639: oCall 5811
11641: oGetAddrLocal 7
11643: oPushResult
11644: oValueTop
11645: oAssign
11646: oValuePop
11647: oEmit 75
11649: oGetLocal 6
11651: oPushResult
11652: oEmitInt
11653: oPop 1
11655: oGetLocal 7
11657: oPushResult
11658: oEmitInt
11659: oPop 1
11661: oGetLocal 5
11663: oPushResult
11664: oEmitLabel
11665: oPop 1
11667: oJumpForward 11686
11669: Choice Lookup Table
          21   11637
11672: oEmit 74
11674: oGetLocal 6
11676: oPushResult
11677: oEmitInt
11678: oPop 1
11680: oGetLocal 5
11682: oPushResult
11683: oEmitLabel
11684: oPop 1
11686: oInputChoice 11690
11688: oJumpForward 11695
11690: Choice Lookup Table
          13   11688
11693: oJumpForward 11697
11695: oJumpBack 11625
11697: oCodePop
11698: oInput 12
11700: oEmit 77
11702: oGetLocal 5
11704: oPushResult
11705: oEmitLabel
11706: oPop 1
11708: oCall 10371
11710: oEmit 68
11712: oGetLocal 3
11714: oPushResult
11715: oEmitLabel
11716: oPop 1
11718: oInputChoice 11722
11720: oJumpForward 11725
11722: Choice Lookup Table
           5   11720
11725: oJumpBack 11560
11727: oEmit 77
11729: oGetLocal 2
11731: oPushResult
11732: oEmitLabel
11733: oPop 1
11735: oGetLocal 1
11737: oPushResult
11738: oEmitCode
11739: oPop 1
11741: oEmit 76
11743: oGetLocal 4
11745: oPushResult
11746: oEmitLabel
11747: oPop 1
11749: oEmit 77
11751: oGetLocal 3
11753: oPushResult
11754: oEmitLabel
11755: oPop 1
11757: oTypeSPop
11758: oReturn
11759: oLocalSpace 1
11761: oInputChoice 11768
11763: oJumpForward 11774
11765: oChangeIntLitToLabelIdent
11766: oJumpForward 11774
11768: Choice Lookup Table
           1   11765
           0   11763
11773: oEndChoice
11774: oGetAddrLocal 1
11776: oPushResult
11777: oScopeCurrent
11778: oPushResult
11779: oScopeFindRequireInScope
11780: oPop 1
11782: oAssign
11783: oGetLocal 1
11785: oPushResult
11786: oSetResult 28
11788: oPushResult
11789: oSetResult 1
11791: oPushResult
11792: oNodeSetBoolean
11793: oPop 3
11795: oEmit 68
11797: oGetLocal 1
11799: oPushResult
11800: oSetResult 22
11802: oPushResult
11803: oNodeGetLabel
11804: oPop 2
11806: oPushResult
11807: oEmitLabel
11808: oPop 1
11810: oReturn
11811: oLocalSpace 0
11813: oCall 10371
11815: oInputChoice 11825
11817: oCall 10371
11819: oJumpForward 11831
11821: oJumpForward 11833
11823: oJumpForward 11831
11825: Choice Lookup Table
          36   11821
           5   11817
11830: oEndChoice
11831: oJumpBack 11815
11833: oReturn
11834: oLocalSpace 0
11836: oCall 11841
11838: oEmit 87
11840: oReturn
11841: oLocalSpace 0
11843: oInputChoice 11961
11845: oCall 5884
11847: oTypeSNodeType
11848: oChoice 11919
11850: oEmit 80
11852: oJumpForward 11942
11854: oEmit 81
11856: oJumpForward 11942
11858: oEmit 30
11860: oEmit 80
11862: oJumpForward 11942
11864: oEmit 82
11866: oJumpForward 11942
11868: oEmit 83
11870: oJumpForward 11942
11872: oError 16
11874: oJumpForward 11942
11876: oEmit 16
11878: oTypeSTop
11879: oPushResult
11880: oSetResult 43
11882: oPushResult
11883: oNodeGetInt
11884: oPop 2
11886: oPushResult
11887: oEmitInt
11888: oPop 1
11890: oEmit 86
11892: oJumpForward 11942
11894: oTypeSTop
11895: oPushResult
11896: oGetGlobal 10
11898: oPushResult
11899: equal_node
11900: oPop 2
11902: oChoice 11908
11904: oEmit 84
11906: oJumpForward 11913
11908: Choice Lookup Table
           1   11904
11911: oEmit 85
11913: oJumpForward 11942
11915: oEmit 85
11917: oJumpForward 11942
11919: Choice Lookup Table
          35   11915
          34   11894
          41   11876
          28   11872
          39   11868
          40   11868
          33   11864
          30   11858
          31   11854
          29   11850
11940: oError 17
11942: oTypeSPop
11943: oInputChoice 11951
11945: oJumpForward 11959
11947: oJumpForward 11957
11949: oJumpForward 11957
11951: Choice Lookup Table
          13   11949
          15   11945
11956: oEndChoice
11957: oJumpBack 11845
11959: oJumpForward 11964
11961: Choice Lookup Table
          14   11845
11964: oReturn
11965: oLocalSpace 0
11967: oReturn
11968: oLocalSpace 0
11970: oReturn
11971: oLocalSpace 0
11973: oScopeCurrent
11974: oPushResult
11975: oSetResult 14
11977: oPushResult
11978: oNodeGetInt
11979: oPop 2
11981: oReturn
11982: oReturn
11983: oLocalSpace 0
11985: oGetParam 1
11987: oPushResult
11988: oSetResult 20
11990: oPushResult
11991: oNodeGet
11992: oPop 2
11994: oPushResult
11995: oSetResult 14
11997: oPushResult
11998: oNodeGetInt
11999: oPop 2
12001: oReturn
12002: oReturn
12003: oLocalSpace 0
12005: oCall 11971
12007: oPushResult
12008: oGetParam 1
12010: oPushResult
12011: oCall 11983
12013: oPop 1
12015: oPushResult
12016: subtract
12017: oPop 2
12019: oReturn
12020: oReturn
12021: oLocalSpace 1
12023: oGetAddrLocal 1
12025: oPushResult
12026: oTypeSNodeType
12027: oAssign
12028: oTypeSPop
12029: oGetLocal 1
12031: oPushResult
12032: oTypeSNodeType
12033: oPushResult
12034: equal_node_type
12035: oPop 2
12037: oChoice 12075
12039: oTypeSNodeType
12040: oChoice 12066
12042: oGetLocal 1
12044: oChoice 12049
12046: oReturn
12047: oJumpForward 12052
12049: Choice Lookup Table
          35   12046
12052: oJumpForward 12071
12054: oGetLocal 1
12056: oChoice 12061
12058: oReturn
12059: oJumpForward 12064
12061: Choice Lookup Table
          34   12058
12064: oJumpForward 12071
12066: Choice Lookup Table
          35   12054
          34   12042
12071: oError 14
12073: oJumpForward 12078
12075: Choice Lookup Table
           0   12039
12078: oReturn
12079: oLocalSpace 0
12081: oTypeSNodeType
12082: oChoice 12086
12084: oJumpForward 12091
12086: Choice Lookup Table
          29   12084
12089: oError 7
12091: oTypeSPop
12092: oReturn
12093: oLocalSpace 0
12095: oTypeSNodeType
12096: oChoice 12100
12098: oJumpForward 12105
12100: Choice Lookup Table
          29   12098
12103: oError 7
12105: oReturn
12106: oLocalSpace 0
12108: oTypeSNodeType
12109: oChoice 12117
12111: oJumpForward 12124
12113: oEmit 30
12115: oJumpForward 12124
12117: Choice Lookup Table
          30   12113
          29   12111
12122: oError 7
12124: oTypeSPop
12125: oReturn
12126: oLocalSpace 0
12128: oTypeSNodeType
12129: oChoice 12144
12131: oJumpForward 12151
12133: oEmit 30
12135: oTypeSPop
12136: oGetGlobal 6
12138: oPushResult
12139: oTypeSPush
12140: oPop 1
12142: oJumpForward 12151
12144: Choice Lookup Table
          30   12133
          29   12131
12149: oError 7
12151: oReturn
12152: oLocalSpace 0
12154: oTypeSNodeType
12155: oChoice 12168
12157: oEmit 30
12159: oTypeSPop
12160: oGetGlobal 6
12162: oPushResult
12163: oTypeSPush
12164: oPop 1
12166: oJumpForward 12171
12168: Choice Lookup Table
          30   12157
12171: oReturn
12172: oLocalSpace 0
12174: oTypeSNodeType
12175: oChoice 12179
12177: oJumpForward 12184
12179: Choice Lookup Table
          31   12177
12182: oError 8
12184: oTypeSPop
12185: oReturn
12186: oLocalSpace 0
12188: oTypeSNodeType
12189: oChoice 12193
12191: oJumpForward 12198
12193: Choice Lookup Table
          31   12191
12196: oError 8
12198: oReturn
12199: oLocalSpace 1
12201: oGetAddrLocal 1
12203: oPushResult
12204: oGetParam 2
12206: oPushResult
12207: oNodeNew
12208: oPop 1
12210: oAssign
12211: oGetLocal 1
12213: oPushResult
12214: oSetResult 17
12216: oPushResult
12217: oGetParam 1
12219: oPushResult
12220: oNodeSetInt
12221: oPop 3
12223: oGetLocal 1
12225: oPushResult
12226: oTypeAdd
12227: oPop 1
12229: oGetLocal 1
12231: oReturn
12232: oReturn
12233: oLocalSpace 1
12235: oGetAddrLocal 1
12237: oPushResult
12238: oGetParam 2
12240: oPushResult
12241: oNodeNew
12242: oPop 1
12244: oAssign
12245: oGetLocal 1
12247: oPushResult
12248: oSetResult 4
12250: oPushResult
12251: oGetParam 1
12253: oPushResult
12254: oNodeSetInt
12255: oPop 3
12257: oGetLocal 1
12259: oReturn
12260: oReturn
12261: oLocalSpace 1
12263: oGetAddrLocal 1
12265: oPushResult
12266: oGetParam 1
12268: oPushResult
12269: oSetResult 36
12271: oPushResult
12272: oNodeGet
12273: oPop 2
12275: oAssign
12276: oGetLocal 1
12278: oPushResult
12279: oNodeNull
12280: oPop 1
12282: oChoice 12338
12284: oGetAddrLocal 1
12286: oPushResult
12287: oSetResult 34
12289: oPushResult
12290: oNodeNew
12291: oPop 1
12293: oAssign
12294: oGetLocal 1
12296: oPushResult
12297: oSetResult 37
12299: oPushResult
12300: oGetParam 1
12302: oPushResult
12303: oNodeSet
12304: oPop 3
12306: oGetLocal 1
12308: oPushResult
12309: oSetResult 17
12311: oPushResult
12312: oSetResult 8
12314: oPushResult
12315: oNodeSetInt
12316: oPop 3
12318: oGetLocal 1
12320: oPushResult
12321: oTypeAdd
12322: oPop 1
12324: oGetParam 1
12326: oPushResult
12327: oSetResult 36
12329: oPushResult
12330: oGetLocal 1
12332: oPushResult
12333: oNodeSet
12334: oPop 3
12336: oJumpForward 12341
12338: Choice Lookup Table
           1   12284
12341: oGetLocal 1
12343: oReturn
12344: oReturn
12345: oLocalSpace 2
12347: oGetParam 1
12349: oPushResult
12350: oNodeType
12351: oPop 1
12353: oChoice 12423
12355: oMININT
12356: oReturn
12357: oJumpForward 12439
12359: oSetResult 0
12361: oReturn
12362: oJumpForward 12439
12364: oSetResult 0
12366: oReturn
12367: oJumpForward 12439
12369: oGetAddrLocal 1
12371: oPushResult
12372: oGetParam 1
12374: oPushResult
12375: oSetResult 41
12377: oPushResult
12378: oNodeGet
12379: oPop 2
12381: oAssign
12382: oGetAddrLocal 2
12384: oPushResult
12385: oGetLocal 1
12387: oPushResult
12388: oSetResult 15
12390: oPushResult
12391: oNodeGetIter
12392: oPop 2
12394: oPushResult
12395: oNodeIterValue
12396: oPop 1
12398: oAssign
12399: oGetLocal 2
12401: oPushResult
12402: oSetResult 22
12404: oPushResult
12405: oNodeGetInt
12406: oPop 2
12408: oReturn
12409: oJumpForward 12439
12411: oGetParam 1
12413: oPushResult
12414: oSetResult 39
12416: oPushResult
12417: oNodeGetInt
12418: oPop 2
12420: oReturn
12421: oJumpForward 12439
12423: Choice Lookup Table
          37   12411
          41   12369
          33   12364
          31   12359
          29   12355
12434: oError 3
12436: oSetResult 0
12438: oReturn
12439: oReturn
12440: oLocalSpace 2
12442: oGetParam 1
12444: oPushResult
12445: oNodeType
12446: oPop 1
12448: oChoice 12518
12450: oMAXINT
12451: oReturn
12452: oJumpForward 12534
12454: oSetResult 1
12456: oReturn
12457: oJumpForward 12534
12459: oSetResult 255
12461: oReturn
12462: oJumpForward 12534
12464: oGetAddrLocal 1
12466: oPushResult
12467: oGetParam 1
12469: oPushResult
12470: oSetResult 41
12472: oPushResult
12473: oNodeGet
12474: oPop 2
12476: oAssign
12477: oGetAddrLocal 2
12479: oPushResult
12480: oGetLocal 1
12482: oPushResult
12483: oSetResult 15
12485: oPushResult
12486: oNodeGetIterLast
12487: oPop 2
12489: oPushResult
12490: oNodeIterValue
12491: oPop 1
12493: oAssign
12494: oGetLocal 2
12496: oPushResult
12497: oSetResult 22
12499: oPushResult
12500: oNodeGetInt
12501: oPop 2
12503: oReturn
12504: oJumpForward 12534
12506: oGetParam 1
12508: oPushResult
12509: oSetResult 40
12511: oPushResult
12512: oNodeGetInt
12513: oPop 2
12515: oReturn
12516: oJumpForward 12534
12518: Choice Lookup Table
          37   12506
          41   12464
          33   12459
          31   12454
          29   12450
12529: oError 3
12531: oSetResult 0
12533: oReturn
12534: oReturn
12535: oLocalSpace 0
12537: oGetParam 1
12539: oPushResult
12540: oSetResult 22
12542: oPushResult
12543: oNodeGetInt
12544: oPop 2
12546: oPushResult
12547: oEmitInt
12548: oPop 1
12550: oReturn
12551: oLocalSpace 1
12553: oGetAddrLocal 1
12555: oPushResult
12556: oSetResult 14
12558: oPushResult
12559: oGetParam 1
12561: oPushResult
12562: oCall 12233
12564: oPop 2
12566: oAssign
12567: oGetLocal 1
12569: oPushResult
12570: oScopeDeclare
12571: oPop 1
12573: oGetLocal 1
12575: oReturn
12576: oReturn
12577: oLocalSpace 1
12579: oGetAddrGlobal 4
12581: oPushResult
12582: oId_mysystem
12583: oAssign
12584: oGetAddrGlobal 5
12586: oPushResult
12587: oSetResult 28
12589: oPushResult
12590: oSetResult 4
12592: oPushResult
12593: oCall 12199
12595: oPop 2
12597: oAssign
12598: oGetAddrGlobal 6
12600: oPushResult
12601: oSetResult 29
12603: oPushResult
12604: oSetResult 4
12606: oPushResult
12607: oCall 12199
12609: oPop 2
12611: oAssign
12612: oGetAddrGlobal 7
12614: oPushResult
12615: oSetResult 31
12617: oPushResult
12618: oSetResult 1
12620: oPushResult
12621: oCall 12199
12623: oPop 2
12625: oAssign
12626: oGetAddrGlobal 8
12628: oPushResult
12629: oSetResult 32
12631: oPushResult
12632: oSetResult 1
12634: oPushResult
12635: oCall 12199
12637: oPop 2
12639: oAssign
12640: oGetAddrGlobal 9
12642: oPushResult
12643: oSetResult 33
12645: oPushResult
12646: oSetResult 1
12648: oPushResult
12649: oCall 12199
12651: oPop 2
12653: oAssign
12654: oGetAddrGlobal 10
12656: oPushResult
12657: oGetGlobal 9
12659: oPushResult
12660: oCall 12261
12662: oPop 1
12664: oAssign
12665: oGetAddrGlobal 11
12667: oPushResult
12668: oSetResult 30
12670: oPushResult
12671: oSetResult 1
12673: oPushResult
12674: oCall 12199
12676: oPop 2
12678: oAssign
12679: oGetAddrGlobal 12
12681: oPushResult
12682: oSetResult 35
12684: oPushResult
12685: oSetResult 8
12687: oPushResult
12688: oCall 12199
12690: oPop 2
12692: oAssign
12693: oGetGlobal 12
12695: oPushResult
12696: oSetResult 37
12698: oPushResult
12699: oGetGlobal 11
12701: oPushResult
12702: oNodeSet
12703: oPop 3
12705: oGetAddrGlobal 13
12707: oPushResult
12708: oSetResult 39
12710: oPushResult
12711: oSetResult 256
12713: oPushResult
12714: oCall 12199
12716: oPop 2
12718: oAssign
12719: oGetAddrGlobal 14
12721: oPushResult
12722: oSetResult 40
12724: oPushResult
12725: oSetResult 256
12727: oPushResult
12728: oCall 12199
12730: oPop 2
12732: oAssign
12733: oGetGlobal 14
12735: oPushResult
12736: oSetResult 42
12738: oPushResult
12739: oSetResult 255
12741: oPushResult
12742: oNodeSetInt
12743: oPop 3
12745: oGetAddrLocal 1
12747: oPushResult
12748: oSetResult 19
12750: oPushResult
12751: oId_File
12752: oPushResult
12753: oCall 12233
12755: oPop 2
12757: oAssign
12758: oGetLocal 1
12760: oPushResult
12761: oSetResult 21
12763: oPushResult
12764: oGetGlobal 5
12766: oPushResult
12767: oNodeSet
12768: oPop 3
12770: oGetLocal 1
12772: oPushResult
12773: oScopeDeclare
12774: oPop 1
12776: oGetAddrLocal 1
12778: oPushResult
12779: oSetResult 19
12781: oPushResult
12782: oId_Integer
12783: oPushResult
12784: oCall 12233
12786: oPop 2
12788: oAssign
12789: oGetLocal 1
12791: oPushResult
12792: oSetResult 21
12794: oPushResult
12795: oGetGlobal 6
12797: oPushResult
12798: oNodeSet
12799: oPop 3
12801: oGetLocal 1
12803: oPushResult
12804: oScopeDeclare
12805: oPop 1
12807: oGetAddrLocal 1
12809: oPushResult
12810: oSetResult 19
12812: oPushResult
12813: oId_Boolean
12814: oPushResult
12815: oCall 12233
12817: oPop 2
12819: oAssign
12820: oGetLocal 1
12822: oPushResult
12823: oSetResult 21
12825: oPushResult
12826: oGetGlobal 7
12828: oPushResult
12829: oNodeSet
12830: oPop 3
12832: oGetLocal 1
12834: oPushResult
12835: oScopeDeclare
12836: oPop 1
12838: oGetAddrLocal 1
12840: oPushResult
12841: oSetResult 19
12843: oPushResult
12844: oId_Char
12845: oPushResult
12846: oCall 12233
12848: oPop 2
12850: oAssign
12851: oGetLocal 1
12853: oPushResult
12854: oSetResult 21
12856: oPushResult
12857: oGetGlobal 9
12859: oPushResult
12860: oNodeSet
12861: oPop 3
12863: oGetLocal 1
12865: oPushResult
12866: oScopeDeclare
12867: oPop 1
12869: oGetAddrLocal 1
12871: oPushResult
12872: oSetResult 19
12874: oPushResult
12875: oId_Byte
12876: oPushResult
12877: oCall 12233
12879: oPop 2
12881: oAssign
12882: oGetLocal 1
12884: oPushResult
12885: oSetResult 21
12887: oPushResult
12888: oGetGlobal 11
12890: oPushResult
12891: oNodeSet
12892: oPop 3
12894: oGetLocal 1
12896: oPushResult
12897: oScopeDeclare
12898: oPop 1
12900: oGetAddrLocal 1
12902: oPushResult
12903: oSetResult 19
12905: oPushResult
12906: oId_Pointer
12907: oPushResult
12908: oCall 12233
12910: oPop 2
12912: oAssign
12913: oGetLocal 1
12915: oPushResult
12916: oSetResult 21
12918: oPushResult
12919: oGetGlobal 12
12921: oPushResult
12922: oNodeSet
12923: oPop 3
12925: oGetLocal 1
12927: oPushResult
12928: oScopeDeclare
12929: oPop 1
12931: oGetAddrLocal 1
12933: oPushResult
12934: oSetResult 19
12936: oPushResult
12937: oId_ShortString
12938: oPushResult
12939: oCall 12233
12941: oPop 2
12943: oAssign
12944: oGetLocal 1
12946: oPushResult
12947: oSetResult 21
12949: oPushResult
12950: oGetGlobal 14
12952: oPushResult
12953: oNodeSet
12954: oPop 3
12956: oGetLocal 1
12958: oPushResult
12959: oScopeDeclare
12960: oPop 1
12962: oGetAddrLocal 1
12964: oPushResult
12965: oSetResult 16
12967: oPushResult
12968: oId_True
12969: oPushResult
12970: oCall 12233
12972: oPop 2
12974: oAssign
12975: oGetLocal 1
12977: oPushResult
12978: oSetResult 21
12980: oPushResult
12981: oGetGlobal 7
12983: oPushResult
12984: oNodeSet
12985: oPop 3
12987: oGetLocal 1
12989: oPushResult
12990: oSetResult 22
12992: oPushResult
12993: oSetResult 1
12995: oPushResult
12996: oNodeSetInt
12997: oPop 3
12999: oGetLocal 1
13001: oPushResult
13002: oScopeDeclare
13003: oPop 1
13005: oGetAddrLocal 1
13007: oPushResult
13008: oSetResult 16
13010: oPushResult
13011: oId_False
13012: oPushResult
13013: oCall 12233
13015: oPop 2
13017: oAssign
13018: oGetLocal 1
13020: oPushResult
13021: oSetResult 21
13023: oPushResult
13024: oGetGlobal 7
13026: oPushResult
13027: oNodeSet
13028: oPop 3
13030: oGetLocal 1
13032: oPushResult
13033: oSetResult 22
13035: oPushResult
13036: oSetResult 0
13038: oPushResult
13039: oNodeSetInt
13040: oPop 3
13042: oGetLocal 1
13044: oPushResult
13045: oScopeDeclare
13046: oPop 1
13048: oGetAddrLocal 1
13050: oPushResult
13051: oSetResult 16
13053: oPushResult
13054: oId_Nil
13055: oPushResult
13056: oCall 12233
13058: oPop 2
13060: oAssign
13061: oGetLocal 1
13063: oPushResult
13064: oSetResult 21
13066: oPushResult
13067: oGetGlobal 12
13069: oPushResult
13070: oNodeSet
13071: oPop 3
13073: oGetLocal 1
13075: oPushResult
13076: oSetResult 22
13078: oPushResult
13079: oSetResult 0
13081: oPushResult
13082: oNodeSetInt
13083: oPop 3
13085: oGetLocal 1
13087: oPushResult
13088: oScopeDeclare
13089: oPop 1
13091: oGetAddrGlobal 15
13093: oPushResult
13094: oId_Ord
13095: oPushResult
13096: oCall 12551
13098: oPop 1
13100: oAssign
13101: oGetAddrGlobal 16
13103: oPushResult
13104: oId_Chr
13105: oPushResult
13106: oCall 12551
13108: oPop 1
13110: oAssign
13111: oGetAddrGlobal 17
13113: oPushResult
13114: oId_Pred
13115: oPushResult
13116: oCall 12551
13118: oPop 1
13120: oAssign
13121: oGetAddrGlobal 18
13123: oPushResult
13124: oId_Succ
13125: oPushResult
13126: oCall 12551
13128: oPop 1
13130: oAssign
13131: oReturn
