   2: title: 'Pascal Compiler 1.1.5 -- Jan 01 ''90';
         
      %
      %  Pascal.ssl
      %
      %  Pascal Compiler for the Amiga, by Steve Rice.
      %
      %  HISTORY
      %    11Sep89   First version, framework of parser.
      %    18Sep89   Added some semantic mechanisms.
      %    21Sep89   Added simple type references; expressions generate code.
      %    22Sep89   Allocate variable addresses as they're declared.
      %    24Sep89   Added arrays, pointers.
      %    27Sep89   Added for statement.
      %    23Oct89   Fixed for statement, so CYCLE goes to next step.
      %    01Jan90   Added string literals
      %    09Sep22   I have returned.  Migrate symbol table to schema, to ease development.
      %    01Oct22   Language: Switch from cycle/exit (Mac Pascal extension) to continue/break (Borland).
      %
      %  NOTES
      %    -  The 'value' of a var symbol is its allocated address.
      %    -  References to vars of intrinsic types, and pointer types,
      %       pushes the value of the var on the expr stack.  Referenecs to
      %       vars of compound types (arrays, records...) pushes the address
      %       on the expr stack.
      %    -  Just as there is only one type table entry for a given (named) type,
      %       there is only one type table entry for a pointer to a named type.
      %       When a pointer type is declared, a field in the TT entry of the
      %       type pointed to will be set to indicate the TT entry of the pointer
      %       to that type (0 means none defined yet).  When evaluating the
      %       expression @x, the type in that field in the entry for the type of x
      %       will be used (unless it's 0, in which case a new TT entry will be
      %       created).
      %
      %
      %  MISSING
      %
      %    - procedure and function declarations may be nested within other procs/funcs!
      %      They are allowed to see locals within those parent scopes.
      %      Pass a hidden parameter to nested methods, to follow up to parent scopes as needed.
      %      Need a level counter at each scope, and uplevels count on reference to local/param.
      %      
      %    - Consider non-ISO extensions.  e.g. see "Units" e.g. from Turbo Pascal wikipedia page.
      %      Dynamic arrays.  Objects.  But, perhaps stick to my old goal, standard Pascal.
      %
      %    - variable initialization.
      %      The code should execute on entry to the scope.  I probably need multiple tcode streams,
      %      because there may be nested methods between the variables being initialized
      %      and the block statement of the scope.
      %
      %  PASCAL DOCS
      %      Here's some handy language material:
      %      https://www.freepascal.org/docs-html/ref/ref.html
      %      https://www.freepascal.org/docs-html/prog/prog.html
      %      https://en.wikipedia.org/wiki/Turbo_Pascal
      %      https://en.wikipedia.org/wiki/Pascal_(programming_language)#Standards
      %      http://www.standardpascaline.org/
      %
      
   2: input:
   2:    pIdent
   2:    pIntLit
   2:    pStrLit
   2:    pAssign       ':='
   2:    pSemiColon    ';'
   2:    pEqual        '='
   2:    pNotEqual     '<>'
   2:    pLess         '<'
   2:    pGreater      '>'
   2:    pLessEqual    '<='
   2:    pGreaterEqual '>='
   2:    pColon        ':'
   2:    pComma        ','
   2:    pLParen       '('
   2:    pRParen       ')'
   2:    pLSquare      '['
   2:    pRSquare      ']'
   2:    pCarat        '^'
   2:    pAt           '@'
   2:    pDot          '.'
   2:    pDotDot       '..'
   2:    pTimes        '*'
   2:    pDivide       '/'
   2:    pPlus         '+'
   2:    pMinus        '-'
   2:    pEof
   2:    pInvalid
      
      %  keywords  (built-in types 'integer', 'byte', 'char', etc, are not keywords,
      %             type constructors 'array', 'record', 'set' are keywords,
      %             pseudo-procedures 'writeln', 'readln' are keywords)
      %
      %             forward/external/name/cdecl appear in method modifiers, in fpc grammar.
      %             I'm making them keywords to simplify parsing, but could reconsider.
      
   2:    pProgram
   2:    pProcedure
   2:    pFunction
   2:    pConst
   2:    pType
   2:    pVar
   2:    pBegin
   2:    pEnd
   2:    pArray
   2:    pRecord
   2:    pSet
   2:    pOf
   2:    pIf
   2:    pThen
   2:    pElse
   2:    pFor
   2:    pTo
   2:    pDownto
   2:    pDo
   2:    pWhile
   2:    pRepeat
   2:    pUntil
   2:    pContinue
   2:    pBreak
   2:    pAnd
   2:    pOr
   2:    pNot
   2:    pWriteln
   2:    pWrite
   2:    pReadln
   2:    pRead
   2:    pForward
   2:    pExternal
   2:    pName
   2:    pCdecl
   2:    ;
      
      
   2: output:
      
      %  Instructions for a stack machine (all vars are 32-bit integers)
      
   2:    tPushGlobalI      % <ptr> - push int value read from ptr
   2:    tPushGlobalB      % <ptr> - push byte value read from ptr
   2:    tPushGlobalP      % <ptr> - push ptr value read from ptr
   2:    tPushLocalI       % <offset> - push int value read from local var
   2:    tPushLocalB       % <offset> - push byte value read from local var
   2:    tPushLocalP       % <offset> - push ptr value read from local var
   2:    tPushParamI       % <offset> - push int value read from local var
   2:    tPushParamB       % <offset> - push byte value read from local var
   2:    tPushParamP       % <offset> - push ptr value read from local var
      
   2:    tPushConstI       % <int> - push int value on stack (NOTE, used for BOOLEAN too)
   2:    tPushAddrGlobal   % <offset> - push ptr to global var (same as tPushConstP)
   2:    tPushAddrLocal    % <offset> - push ptr to local var
   2:    tPushAddrParam    % <offset> - push ptr to formal param (used by method to see its param)
   2:    tPushAddrActual   % <offset> - push ptr to actual param, in actuals space (used by caller)
   2:    tFetchI           % pop ptr from stack, and push int value it points to
   2:    tFetchB           %    "      "      "     "     byte  "   "    "
   2:    tFetchP           %    "      "      "     "     ptr   "   "    "   
   2:    tAssignI          % assign int value on top of stack to addr under it (pop both)
   2:    tAssignB          %   "    byte   "    "   "  "   "    "    "   "   "
   2:    tAssignP          %   "    ptr    "    "   "  "   "    "    "   "   "
   2:    tCopy             % <#bytes> - copy bytes.  tos=src, 2nd=dest (pop 2)
   2:    tIncI             % increment int value on top of expr stack
   2:    tDecI             % decrement int value on top of expr stack
   2:    tMultI            % multiply top two integers (replacing with result)
   2:    tDivI
   2:    tAddPI            % add ptr (2nd value) and int (top value), resulting in a ptr
   2:    tAddI
   2:    tSubI
   2:    tNegI             % top entry *= -1
   2:    tNot              % negate top boolean
   2:    tEqualI           % top two entries equal? (pop 2, push 1) (true=1)
   2:    tNotEqualI        %    NOTE, these all work for booleans too
   2:    tGreaterI         % 2nd entry greater than top entry? (pop 2, push answer)
   2:    tLessI  
   2:    tGreaterEqualI
   2:    tLessEqualI
   2:    tEqualP           % two two pointer values equal? (pop 2, push 1) (true=1)
   2:    tNotEqualP
   2:    tAllocActuals     % <#bytes> - make space on call stack for actual params (adjusting call stack sp)
   2:    tAllocActualsCdecl  % <#bytes> - starting a call to a cdecl method.  tcode still describes my own calling convention.
   2:    tFreeActuals      % <#bytes> - discard space on call stack allocated by tAllocActuals
   2:    tCall             % <label#>
   2:    tCallCdecl        % <label#> - call a method using native (C) calling convention. Only supported for extern labels.
   2:    tReturn
   2:    tEnter            % <#bytes> - start a stack frame on the call stack, reserving #bytes of local variable space
   2:    tJump             % <label#>
   2:    tJumpTrue         % <label#>  (pops top of stack, jumps if true)
   2:    tJumpFalse        % <label#>  (pops top of stack, jumps if false)
   2:    tLabel            % <label#> - define label# at the current address
   2:    tLabelAlias       % <label#> <aliasToLabel#> - defines label to be an alias of another label
   2:    tLabelExtern      % <label#> <offsetToStrLit> - defines label to mean an extern symbol, whose name is in global data
   2:    tWriteI           % for writeln : write integer on tos, pop
   2:    tWriteBool        %  "     "    : write TRUE/FALSE, pop
   2:    tWriteStr         %  "     "    : write string whose addr is on tos, pop
   2:    tWriteP           %  "     "    : write ptr var whose addr is on tos, pop
   2:    tWriteCR          %  "     "    : write cr
      
      %  Other:
      
   2:    tSpace            % emit a hole, to be patched later
   2:    ;
      
   2: error:
   2:    eBadStatement
   2:    eNotConst
   2:    eNotType
   2:    eNotOrdinalType
   2:    eNotVar
   2:    eNotIntVar
   2:    eNotValue
   2:    eNotInteger
   2:    eNotBoolean
   2:    eNotPointer
   2:    eNotArray
   2:    eNotRecord
   2:    eNotRecordField
   2:    eTooManySubscripts
   2:    eTypeMismatch
   2:    eMissingParameter
   2:    eNotImplemented
   2:    eNotAllowed
   2:    eNotInALoop
   2:    eRecordEmpty
   2:    eNotCurrentFunction
   2:    eAlreadyDefined
   2:    eOnlyOneVarCanBeInitialized
   2:    ;
      
   2: include 'pascal_schema.ssl'
      
      % Generated automatically by schema
      
   2: type node_type:
   2: 	nINVALID
   2: 	Object
   2: 	nScope
   2: 	nDeclaration
   2: 	nIdent
   2: 	nProgram
   2: 	nMethod
   2: 	nProc
   2: 	nFunc
   2: 	nConst
   2: 	nTypeDecl
   2: 	nVar
   2: 	nGlobalVar
   2: 	nLocalVar
   2: 	nRecordField
   2: 	nParam
   2: 	nType
   2: 	nFileType
   2: 	nIntegerType
   2: 	nBooleanType
   2: 	nBooleanCFType
   2: 	nCharType
   2: 	nStringType
   2: 	nPointerType
   2: 	nArrayType
   2: 	nSubrangeType
   2: 	nRecordType
   2: 	nEnumType
   2: 	nSetType
   2: 	;
      
   2: type node_attribute:
   2: 	qINVALID
   2: 	qDecls
   2: 	qSize
   2: 	qAllocDown
   2: 	qInitCode
   2: 	qIdent
   2: 	qType
   2: 	qValue
   2: 	qMainRoutineScope
   2: 	qParams
   2: 	qChildScope
   2: 	qBodyDefined
   2: 	qExternal
   2: 	qExternalName
   2: 	qCdecl
   2: 	qCalled
   2: 	qOldParams
   2: 	qOldType
   2: 	qResultOffset
   2: 	qInOut
   2: 	qPointerType
   2: 	qBaseType
   2: 	qIndexType
   2: 	qLow
   2: 	qHigh
   2: 	qScope
   2: 	;
      
      
   2: type Node:     % A pointer to a node in the schema database (symbol database)
   2:    Null = 0
   2:    ;
      
   2: type NodeIter:   % An iterator over nodes in a list, in the schema database
   2:    NullIter = 0
   2:    ;
      
   2: type NodeVec:  % A pointer to a vector of Node.  See mechanism node_vec_mech
   2:    NullVec = 0
   2:    ;
      
   2: type boolean:
   2:    false    = 0
   2:    true     = 1;
      
   2: type kind:           % kind of identifier
   2:    kUndefined        % not yet added to symbol table
   2:    kProgram
   2:    kProc
   2:    kFunc
   2:    kConst
   2:    kType
   2:    kVar;
      
      % intrinsic types & type constructs
      
   2: type typ:
   2:    tyNone     = 0    % in ptrTyp field of TT, means no ptr to type defined
   2:    tyInteger
   2:    tyBoolean
   2:    tyChar
   2:    tyString
   2:    tyFile            % tyInteger..tyFile are scalars (types on their own)
   2:    tyPointer         % following are type constructor classes...
   2:    tyArray           %   (they are not type#'s)
   2:    tyRecord
   2:    tyParams          % like record; a collection of proc/func params
   2:    tySet;
      
   2: type Label:
   2:    labelNull = 0;
      
      % An output code stream.
   2: type Code:
   2:    codeNull = 0
   2:    codeDefault = 1
   2:    ;
      
      % A string
   2: type String:
   2:    stringNull = 0
   2:    ;
      
      
      % Some general schema node operations.
      % node_type and node_attribute are defined in generated file pascal_schema.ssl included above.
      %
   2: mechanism node_mech:
   2:     oNodeNew (node_type) >> Node         % create new node
   2:     oNodeSet (Node, node_attribute, Node)   % set Node attribute of node
   2:     oNodeSetString (Node, node_attribute, String)
   2:     oNodeSetInt (Node, node_attribute, int) % set int attribute of node
   2:     oNodeSetBoolean (Node, node_attribute, boolean)
   2:     oNodeSetKind (Node, node_attribute, kind) % set attribute of node  *** MIGHT NOT NEED
   2:     oNodeSetLabel( Node, node_attribute, Label )  % set Label attribute of node
   2:     oNodeSetCode( Node, node_attribute, Code )    % set Code attribute of node
   2:     oNodeGet (Node, node_attribute) >> Node    % get Node attribute of node
   2:     oNodeGetString (Node, node_attribute) >> String
   2:     oNodeGetInt (Node, node_attribute) >> int  % get int attribute of node
   2:     oNodeGetBoolean (Node, node_attribute) >> boolean  % get int attribute of node
   2:     oNodeGetLabel (Node, node_attribute) >> Label      % get Label attribute of node
   2:     oNodeGetCode (Node, node_attribute) >> Code        % get code stream attribute of node
   2:     oNodeNull (Node) >> boolean          % is node null?
   2:     oNodeGetIter (Node, node_attribute) >> NodeIter   % get an iterator over nodes in a List attribute
   2:     oNodeIterValue (NodeIter) >> Node             % the node that iter is referring to (NodeNull if no more nodes)
   2:     oNodeIterNext (inout NodeIter)                 % advance iterator through list
   2:     oNodeType (Node) >> node_type        % return node type of node
   2:     oNodeEqual (Node, Node) >> boolean   % compare two nodes for equality
                                               % (i.e. same node, not just same contents)
   2:     ;
      
      
      % Manipulate a temporary vector of Node
      %
   2: mechanism node_vec_mech:
   2:     oNodeVecNew >> NodeVec
   2:     oNodeVecDelete( NodeVec nv )
   2:     oNodeVecAppend( NodeVec nv, Node n )
   2:     oNodeVecSize( NodeVec nv ) >> int                % how many elements
   2:     oNodeVecElement( NodeVec nv, int idx ) >> Node   % element at index idx (0..size-1)
   2:     ;
      
      
      
   2: mechanism emit_mech:
   2:     oEmitInt( int )              % emit int into the generated code
   2:     oEmitLabel( Label )
   2:     oEmitCode( Code )            % append a code stream to the current code stream
   2:     Here >> int                  % current address in the generated code
                                       %   (only usable in the default code stream)
   2:     oPatch( int addr, int val )  % patch an int into address in the generated code
                                       %   (only usable in the default code stream)
   2:     ;
      
   2: mechanism math:
   2:     inc (inout int)
   2:     dec (inout int)
   2:     negate (int) >> int
   2:     subtract( int x, int y ) >> int     % x - y
   2:     multiply( int x, int y ) >> int     % x * y
   2:     equal( int x, int y ) >> boolean
   2:     equal_zero (int) >> boolean
   2:     equal_string( String, String ) >> boolean
   2:     equal_node_type (node_type, node_type) >> boolean     % Want equal_<type> for every type
   2:     equal_label( Label, Label ) >> boolean
   2:     equal_code( Code, Code ) >> boolean
   2:     oMININT >> int    % the minimum 32-bit integer.  necessary because ssl literal ints are currently (silently) short (!)
   2:     ;
      
   2: mechanism more_builtins:      % These should be built-in SSL operations
   2:     TOKEN_VALUE >> int        % value of just accepted token, e.g. IntLit token
   2:     LAST_ID >> int            % id number of last accepted identifier
   2:     ID_STRING( int id ) >> String       % text name of identifier with given id
   2:     CURRENT_STRLIT >> String            % text value of just-accepted string literal
   2:     ;
      
   2: mechanism scope_mech:
   2:     oScopeBegin                          % create a new scope. Subsequent declarations will go here.
   2:     oScopeEnter( Node scope )            % enter an existing scope.
   2:     oScopeEnd                            % end current scope. Subsequent declarations will go to previous scope.
   2:     oScopeCurrent >> Node                % returns current scope
   2:     oScopeDeclare( Node decl )           % add declaration to current scope.
   2:     oScopeDeclareAlloc( Node decl )      % add declaration to current scope, and allocate space according to its type
   2:     oScopeAllocType( Node theType ) >> int   % allocate space for type in current scope, and return its address
   2:     oScopeFind >> Node                   % find declaration of last accepted identifier.  Returns Null if not found.
   2:     oScopeFindRequire >> Node            % find declaration of last accepted identifier.  Error if not found.
   2:     oScopeFindInCurrentScope >> Node     % find declaration of last accepted identifier, only within the current scope.  Null if not found.
   2:     ;
      
   2: mechanism type_mech:
   2:     oTypeAdd( Node node )     % add the given nType to the type table
   2:     ;
      
   2: mechanism type_stack_mech:
   2:     oTypeSPush( Node node )
   2:     oTypeSPop
   2:     oTypeSTop >> Node
   2:     oTypeSNodeType >> node_type          % node_type of the node on top of type stack, skipping subranges
   2:     ;
      
      
   2: mechanism id_mech:
          % adds a predefined id to the scanner's id table, and returns the id code
   2:     oIdAdd_File >> int
   2:     oIdAdd_Integer >> int
   2:     oIdAdd_Boolean >> int
   2:     oIdAdd_Char >> int
   2:     oIdAdd_String >> int
   2:     oIdAdd_True >> int
   2:     oIdAdd_False >> int
   2:     ;
      
      
      
   2: mechanism label_mech:
   2:    oLabelNew >> Label
   2:    ;
      
   2: mechanism code_mech:
   2:    oCodeNew >> Code         % create a new empty code stream
   2:    oCodePush( Code )        % change the current output code stream to the given one
   2:    oCodePop                 % restore the current code stream to the previous one
   2:    ;
      
      
   2: mechanism count :
   2:    oCountPush(int)          % start a new counter, with initial value
   2:    oCountInc
   2:    oCountDec
   2:    oCountIsZero >> boolean
   2:    oCountPop;
      
      
   2: mechanism value :              % value stack, to calc. const expr's
   2:    oValuePush(int)             % push an explicit int lit
   2:    oValueNegate                % negate top value
   2:    oValueTop >> int            % get top value on value stack
   2:    oValuePop;
      
   2: mechanism string :
   2:    oStringAllocLit( String ) >> int      % alloc global space for strlit, return address
   2:    ;
      
      % track labels for the loop we're in, if any
   2: mechanism loop_mech:
   2:    oLoopPush( Label continueLabel, Label breakLabel )
   2:    oLoopContinueLabel >> Label
   2:    oLoopBreakLabel >> Label
   2:    oLoopPop
   2:    ;
      
      % for hacky debugging
   2: mechanism msg_mech:
   2:    oMsg( int num )             % print message "oMsg <num>"
   2:    oMsgTrace( int num )        % print message "oMsg <num>" followed by ssl traceback
   2:    oMsgNode( Node node )       % print node
   2:    oMsgNodeVec( NodeVec vec )  % print node vec
   2:    ;
      
      
   2: rules
      
      % ----------------------------- Global Variables ----------------------------
      
   2: Node    globalScope            % global nScope
      
      % built-in nTypes
   2: Node    FileType
   2: Node    IntegerType
   2: Node    BooleanType
   2: Node    BooleanCFType
   2: Node    CharType
   2: Node    StringType
      
      % -------------------------- Forward Declarations -------------------------
      
   2: Block( node_type varNodeType, Label labelForBody );
   2: BlockDecls( node_type varNodeType );
   2: BlockStmt( Label labelForBody, Node varScope );
   2: VarDecl( node_type varNodeType );
   2: newType( node_type nt, int size ) >> Node;
   2: newIdent( node_type nt, kind k, int id ) >> Node;
   2: EmitValue( Node decl );
   2: TypeRef( out Node theType );
   2: PointerTypeTo( Node theType ) >> Node;
   2: OrdinalLow( Node theType ) >> int;
   2: AssignStmt( Node decl );
   2: BooleanExprControlFlow( out Label falseLabel );
   2: ExprAllowCF( out Label falseLabel );
   2: BoolExprAllowCF( out Label falseLabel );
   2: BoolTermAllowCF( out Label falseLabel );
   2: BoolFactorAllowCF( out Label falseLabel );
   2: ArithExprAllowCF( out Label falseLabel );
   2: TermAllowCF( out Label falseLabel );
   2: FactorAllowCF( out Label falseLabel );
   2: PrimaryAllowCF( out Label falseLabel );
      
      
      
   2: VarExpr( Node decl );
   2: LValueVar( Node decl );
   2: IncVar( Node decl );
   2: DecVar( Node decl );
      
   2: CFToVal( inout Label falseLabel );
   2: ValToCF( out Label falseLabel );
      
      % ----------------------------- Declarations ----------------------------
      
   2: Program:
   4:    Node t
      
   4:    oScopeBegin
   5:    globalScope = oScopeCurrent
      
  10:    @installBuiltIns
      
         % Start by calling the main program routine.
      
         % This dummy call to main needs to look like a normal method itself,
         % so jit can align the stack properly.  So we need .tEnter,
         % and .tAllocActuals / .tFreeActuals.
  12:    .tEnter  oEmitInt( 0 )
  20:    Label mainLabel = oLabelNew
      
  25:    .tAllocActuals  oEmitInt( 0 )
  33:    .tCall  oEmitLabel( mainLabel )
  41:    .tFreeActuals  oEmitInt( 0 )
  49:    .tReturn
      
  51:    pProgram
  53:    pIdent
      
  55:    Node progDecl = @newIdent( nProgram, kProgram, LAST_ID )
  71:    oScopeDeclare( progDecl )
      
  77:    [
  77:       | '(' :
  79:          pIdent      % input, output files
      
  81:          t = @newIdent( nVar, kVar, LAST_ID )
  97:          oNodeSet( t, qType, FileType )
 109:          oScopeDeclareAlloc( t )
      
 115:          ','
 117:          pIdent
      
 119:          t = @newIdent( nVar, kVar, LAST_ID )
 135:          oNodeSet( t, qType, FileType )
 147:          oScopeDeclareAlloc( t )
      
 153:          ')'
 155:       | * :
 160:    ]
 160:    ';'
      
 162:    @BlockDecls( nGlobalVar )
      
         % a new scope just for temporaries in the main routine
 169:    Node varScope = oScopeCurrent
 174:    oScopeBegin
 175:    oNodeSetBoolean( oScopeCurrent, qAllocDown, true )
 186:    oNodeSet( progDecl, qMainRoutineScope, oScopeCurrent )
      
         % The block statement includes a stack frame, and enter/return,
         % even for the main routine.
         % That will be necessary for temporaries allocated in the main routine.
 197:    @BlockStmt( mainLabel, varScope )
      
 207:    oScopeEnd   % main routine scope
      
 208:    '.'
 210:    oScopeEnd   % global scope
 212:    ;
      
      
 212: Block( node_type varNodeType, Label labelForBody ):
 214:    @BlockDecls( varNodeType )
 221:    @BlockStmt( labelForBody, oScopeCurrent )
 231:    ;
      
      
 231: BlockDecls( node_type varNodeType ):
 233:    {[
 233:       | pConst :     @ConstDecl
 237:       | pType :      @TypeDecl
 241:       | pVar :       @VarDecl( varNodeType )
 250:       | pProcedure : @ProcDecl
 254:       | pFunction :  @FuncDecl
 258:       | * :          >
 273:    ]}
 275:    @CheckForUndefinedMethods
 278:    ;
      
      
      % were there any procedures or functions declared in this scope
      % that were never defined?
 278: CheckForUndefinedMethods:
         % TO DO
         % Note: disregard methods marked external
 281:    ;
      
      
      
      % Given the scope of vars in this block.
      % Usually it's the current scope, but it's a bit different for the main statement.
      %
 281: BlockStmt( Label labelForBody, Node varScope ):
 283:    .tLabel  oEmitLabel( labelForBody )
      
         % Proc, func, and main routine all start with tEnter
         % to create a stack frame.  This will be used for temporaries
         % (and local vars in the case of proc, func).
      
 291:    int patchLS
 291:    .tEnter  patchLS = Here  .tSpace
      
         % insert any code for initialization of this scope's variables
 300:    Code initCode = oNodeGetCode( varScope, qInitCode )
 313:    oEmitCode( initCode )
 319:    oNodeSetCode( oScopeCurrent, qInitCode, codeNull )
      
 330:    @Statement
 332:    .tReturn
      
 334:    int localSpace = oNodeGetInt( oScopeCurrent, qSize )
 346:    oPatch( patchLS, localSpace )
 356:    ;
      
      
      % modifers that may appear on a proc/function declaration.
      %
 356: MethodModifiers( Node decl ):
 358:    {[
 358:       | pCdecl :
 360:          oNodeSetBoolean( decl, qCdecl, true )
 372:          ';'
      
 374:       | * : >
 381:    ]}
 384:    ;
      
      
      % We need an initCode code stream for the current scope.
      % Create it if not present yet.  Return it.
      % (This will be used for variable initialization.)
      %
 384: GetOrCreateInitCode >> Code:
 386:    Code initCode = oNodeGetCode( oScopeCurrent, qInitCode )
 398:    [ equal_code( initCode, codeNull )
 408:       | true :
 409:          initCode = oCodeNew
 414:          oNodeSetCode( oScopeCurrent, qInitCode, initCode )
 425:       | * :
 430:    ]
 430:    >> initCode;
      
      
      % external method resides in an external object file
      % (or in my system, the built-in runtime library).
      % The method has a label, as usual, which callers will use.
      % But we define that label with .tLabelExtern rather than .tLabel.
      %
      % Note, I'll hold off on issuing the .tLabelExtern until we see that
      % the external method is actually called.  Otherwise we'd fill each output file
      % with all the external method names in my included libraries, which seems dumb.
      %
      % Note this is fpc syntax.  I'm not sure about other Pascals.
      %
 434: ExternalDecl( Node decl ):
 436:    oNodeSetBoolean( decl, qExternal, true )
 448:    [
 448:       | pStrLit :
               % that was the optional library name containing the method.
               % TO DO: I'm currently ignoring this.
 450:          [
 450:             | pName :
 452:                pStrLit
                     % that was the optional method name defined in that library,
                     % which might differ from the Pascal name.
 454:                oNodeSetString( decl, qExternalName, CURRENT_STRLIT )
 465:             | * :
 470:          ]
 470:       | * :
 475:    ]
 476:    ;
      
      
 476: ProcDecl:
 478:    pIdent
      
         % If we already have a forward declaration, we'll modify that decl
         % instead of creating a second symbol table entry.
         % (Alternatively could delete or hide the old entry.)
 480:    boolean redeclaring = false
 486:    Node decl = oScopeFindInCurrentScope
      
 491:    [ oNodeNull( decl )
 498:       | true :
               % first declaration
 499:          decl = @newIdent( nProc, kProc, LAST_ID )
 515:          oNodeSetLabel( decl, qValue, oLabelNew )
      
 526:       | false :
               % we already have a declaration.
               % Keep it, and its label.
 528:          redeclaring = true
 534:          [ oNodeGetBoolean( decl, qBodyDefined )
 544:             | true : #eAlreadyDefined
 547:             | * :
 552:          ]
 552:          [ oNodeGetBoolean( decl, qExternal )
 562:             | true : #eAlreadyDefined
 565:             | * :
 570:          ]
 570:          [ oNodeType( decl )
 577:             | nProc :
 578:             | * : #eAlreadyDefined   % wrong kind
 585:          ]
               % Move the existing param scope aside, so we can check that the
               % new one is consistent.  And, the body will want to see the new one
               % since the names might differ.
               % TO DO: If qOldParams already set, we have multiple forward decls,
               % which I believe is supposed to be an error.
 585:          oNodeSet( decl, qOldParams, oNodeGet( decl, qParams ) )
 604:          oNodeSet( decl, qParams, Null )
 616:    ]
      
 624:    oScopeBegin
 625:    Node paramScope = oScopeCurrent
      
 630:    @FormalArgDecl
 632:    oNodeSet( decl, qParams, paramScope )
 644:    oScopeEnd
 645:    ';'
      
 647:    [ redeclaring
 650:       | false : oScopeDeclare( decl )
 657:       | true :  % TO DO: check that qParams is consistent with qOldParams
 659:    ]
      
 667:    @MethodModifiers( decl )
      
         % Body may be a statement, "forward", "external".
         % Note, this syntax is based on FPC, and I'm not sure if other Pascals are similar.
         % FPC says that forward, external, cdecl, name, etc are not reserved words -
         % I think this means the user may declare other things with those names, but if so the
         % original meaning is lost.  I'll make them keywords for simplicity, for now
         % (just not too happy about "name").
      
 674:    [
 674:       | pForward :
               % Nothing to do.  We simply won't set qBodyDefined.
      
 676:       | pExternal : @ExternalDecl( decl )
      
 685:       | * :
               % Body statement
      
               % Enter the params scope again, so params are visible in body.
               % TO DO: Perhaps I could mark the scope read-only at this point.
 692:          oScopeEnter( paramScope )
      
               % Start scope for declarations within the proc
 698:          oScopeBegin
 699:          oNodeSetBoolean( oScopeCurrent, qAllocDown, true )
 710:          oNodeSet( decl, qChildScope, oScopeCurrent )
      
 721:          Label label = oNodeGetLabel( decl, qValue )
 734:          @Block( nLocalVar, label )
 744:          oNodeSetBoolean( decl, qBodyDefined, true )
 756:          oScopeEnd
      
 757:          oScopeEnd  % paramScope
 758:    ]
 758:    ';';
      
      
 761: FuncDecl:
 763:    pIdent
      
         % If we already have a forward declaration, we'll modify that decl
         % instead of creating a second symbol table entry.
         % (Alternatively could delete or hide the old entry.)
 765:    boolean redeclaring = false
 771:    Node decl = oScopeFindInCurrentScope
      
 776:    [ oNodeNull( decl )
 783:       | true :
               % first declaration
 784:          decl = @newIdent( nFunc, kFunc, LAST_ID )
 800:          oNodeSetLabel( decl, qValue, oLabelNew )
      
 811:       | false :
               % we already have a declaration.
               % Keep it, and its label.
 813:          redeclaring = true
 819:          [ oNodeGetBoolean( decl, qBodyDefined )
 829:             | true : #eAlreadyDefined
 832:             | * :
 837:          ]
 837:          [ oNodeType( decl )
 844:             | nFunc :
 845:             | * : #eAlreadyDefined   % wrong kind
 852:          ]
               % Move the existing param scope and return value aside,
               % so we can check that the new one is consistent.
               % And, the body will want to see the new one since the names might differ.
               % TO DO: If qOldParams already set, we have multiple forward decls,
               % which I believe is supposed to be an error.
 852:          oNodeSet( decl, qOldParams, oNodeGet( decl, qParams ) )
 871:          oNodeSet( decl, qParams, Null )
 883:          oNodeSet( decl, qOldType, oNodeGet( decl, qType ) )
 902:          oNodeSet( decl, qType, Null )
 914:    ]
      
 922:    oScopeBegin
 923:    Node paramScope = oScopeCurrent
      
 928:    @FormalArgDecl
 930:    oNodeSet( decl, qParams, paramScope )
      
 942:    ':'
      
 944:    Node theType
 944:    @TypeRef( theType )
 951:    oNodeSet( decl, qType, theType )
      
         % The function's param space gets an additional pointer,
         % which will point to a temporary in the caller's scope.
         % This pointer is essentially a VAR param, but I won't create an nParam for it.
      
 963:    Node ptrType = @PointerTypeTo( theType )
 974:    oNodeSetInt( decl, qResultOffset, oScopeAllocType( ptrType ) )
 990:    oScopeEnd
 991:    ';'
      
 993:    [ redeclaring
 996:       | false : oScopeDeclare( decl )
1003:       | true :  % TO DO: check that qParams is consistent with qOldParams
                      % and qType is consistent with qOldType
1005:    ]
      
1013:    @MethodModifiers( decl )
      
         % Body may be a statement, "forward", "external".
1020:    [
1020:       | pForward :
               % Nothing to do.  We simply won't set qBodyDefined.
      
1022:       | pExternal : @ExternalDecl( decl )
      
1031:       | * :
               % Body statement
      
               % Enter the params scope again, so params are visible in body.
               % TO DO: Perhaps I could mark the scope read-only at this point.
1038:          oScopeEnter( paramScope )
      
1044:          oScopeBegin
1045:          oNodeSetBoolean( oScopeCurrent, qAllocDown, true )
1056:          oNodeSet( decl, qChildScope, oScopeCurrent )
      
1067:          Label label = oNodeGetLabel( decl, qValue )
1080:          @Block( nLocalVar, label )
1090:          oNodeSetBoolean( decl, qBodyDefined, true )
1102:          oScopeEnd
      
1103:          oScopeEnd  % paramScope
1104:    ]
1104:    ';';
      
      
1107: FormalArgDecl:
1109:    [
1109:       | '(' :
1111:          {
1111:             NodeVec decls = oNodeVecNew
1116:             Node decl
1116:             boolean isInOut = false
      
1122:             [
1122:                | pVar : isInOut = true
1130:                | * :
1135:             ]
      
1135:             {  pIdent
      
1137:                decl = @newIdent( nParam, kVar, LAST_ID )
1153:                oNodeSetBoolean( decl, qInOut, isInOut )
1165:                oNodeVecAppend( decls, decl )
      
1174:                [
1174:                   | ':' : >
1178:                   | ',' :
1180:                ]
1188:             }
      
1190:             Node theType
1190:             @TypeRef( theType )
      
                  % VAR param is declared with its given type, but allocated as a pointer.
1197:             Node allocType
1197:             [ isInOut
1200:                | true :   allocType = @PointerTypeTo( theType )
1212:                | * :      allocType = theType
1223:             ]
      
1223:             int i = 0
1229:             {[ equal( i, oNodeVecSize( decls ) )
1243:                | false :
1244:                   decl = oNodeVecElement( decls, i )
      
1257:                   oNodeSet( decl, qType, theType )
1269:                   oScopeDeclare( decl )
1275:                   oNodeSetInt( decl, qValue, oScopeAllocType( allocType ) )
1291:                   inc( i )
1297:                | * :
1302:                   >
1304:             ]}
      
1306:             oNodeVecDelete( decls )
      
1312:             [
1312:                | ')' : >
1316:                | ';' :
1318:             ]
1326:          }
1328:       | * :
1333:    ];
      
1334: ConstDecl:
1336:    {[
1336:       | pIdent :
1338:          Node decl = @newIdent( nConst, kConst, LAST_ID )
1354:          '='
      
1356:          @ConstExpr
               % TO DO: currently ConstExpr leaves int result on oValue stack
1358:          int val = oValueTop
1363:          oValuePop
1364:          oNodeSetInt( decl, qValue, val )
      
               % TO DO: different types.  Currently assumes int!
1376:          oNodeSet( decl, qType, IntegerType )
      
1388:          oScopeDeclare( decl )
1394:          ';'
1396:       | * :
1401:          >
1403:    ]};
      
1406: TypeDecl:
1408:    {[
1408:       | pIdent :
1410:          Node decl = @newIdent( nTypeDecl, kType, LAST_ID )
1426:          '='
1428:          Node theType
1428:          @TypeRef( theType )
1435:          oNodeSet( decl, qType, theType )
1447:          oScopeDeclare( decl )
1453:          ';'
1455:       | * :
1460:          >
1462:    ]};
      
1465: VarDecl( node_type varNodeType ):
1467:    {[
1467:       | pIdent :
1469:          NodeVec decls = oNodeVecNew
1474:          Node decl
1474:          {
1474:             decl = @newIdent( varNodeType, kVar, LAST_ID )
1490:             oNodeVecAppend( decls, decl )
1499:             [
1499:                | ',' :
1501:                   pIdent
1503:                | * :
1508:                   >
1510:             ]
1510:          }
1512:          ':'
1514:          Node theType
1514:          @TypeRef( theType )
      
1521:          int i = 0
1527:          {[ equal( i, oNodeVecSize( decls ) )
1541:             | false :
1542:                decl = oNodeVecElement( decls, i )
1555:                oNodeSet( decl, qType, theType )
1567:                oScopeDeclareAlloc( decl )
1573:                inc( i )
1579:             | * :
1584:               >
1586:          ]}
      
               % optional initialization
1588:          [
1588:             | '=' :
1590:                [ oNodeVecSize( decls )
1597:                   | 1 :
1598:                   | * :  #eOnlyOneVarCanBeInitialized
1605:                ]
      
                     % we need an initCode stream for this scope
1605:                Code initCode = @GetOrCreateInitCode
1611:                oCodePush( initCode )
                     % generate assignment in initCode stream
1617:                @LValueVar( decl )
1624:                @Expr
1626:                @MatchTypes
1628:                @Assign
1630:                oCodePop
                   
1631:             | * :
1636:          ]
      
1636:          oNodeVecDelete( decls )
1642:          ';'
1644:       | * :
1649:          >
1651:    ]};
      
      
      % Parse a type reference, returning the nType.
      % This will add types to the type table, as needed.
      %
      % Style question - at the moment I think callers look clearer if we use
      % an out param here, rather than a return value.
      %
1654: TypeRef( out Node resultType ):
1656:    [
1656:       | pIdent :           % previously named type (including intrinsics)
1658:          Node decl = oScopeFindRequire
1663:          [ oNodeType( decl )
1670:            | nTypeDecl :
1671:                resultType = oNodeGet( decl, qType )
1684:            | * :
1689:                #eNotType
1691:                resultType = IntegerType
1697:          ]
         
1697:       | pArray :
1699:          '['
      
               % A multi-dimensional array is represented as a chain
               %    array [subrange1] of array [subrange2] of elementType
      
               % First, we build a vector of nArray's, each with one subrange as its index type,
               % but without setting the "of" type or size.
      
1701:          NodeVec dimensions = oNodeVecNew
      
1706:          {
                  % to do: probably should use general subrange parsing, incl minimal size value
                  %   In fact, supposed to parse ordinal_type here.  all ordinal types have a static low, high.
                  %   Not necessary to be a subrange.
      
1706:             Node subrange = oNodeNew( nSubrangeType )
                  % TO DO: currently assuming subrange of integer
1716:             oNodeSet( subrange, qBaseType, IntegerType )
      
                  % TO DO: currently ConstExpr leaves int result on oValue stack
1728:             @ConstExpr
1730:             oNodeSetInt( subrange, qLow, oValueTop )
1741:             oValuePop
1742:             '..'
1744:             @ConstExpr
1746:             oNodeSetInt( subrange, qHigh, oValueTop )
1757:             oValuePop
1758:             oNodeSetInt( subrange, qSize, 4 )   % maybe don't need
      
1770:             oTypeAdd( subrange )
      
1776:             Node a = oNodeNew( nArrayType )
1786:             oNodeSet( a, qIndexType, subrange )
      
1798:             oNodeVecAppend( dimensions, a )
                  % I'll hold off on adding 'a' to the type table since not fully formed yet
      
1807:             [
1807:                | ']' : >
1811:                | ',' :
1813:             ]
1821:          }
      
1823:          pOf
1825:          Node baseType
1825:          @TypeRef( baseType )
      
               % Work backwards through the dimensions,
               % hooking up the 'of' type and calculating the size.
               % At each iteration, baseType is the 'of' type.
      
1832:          int dim = oNodeVecSize( dimensions )
      
1842:          {
1842:              dec(dim)
      
1848:              Node a = oNodeVecElement( dimensions, dim )
      
1861:              oNodeSet( a, qBaseType, baseType )
1873:              Node subrange = oNodeGet( a, qIndexType )
1886:              int width = subtract( oNodeGetInt( subrange, qHigh ), oNodeGetInt( subrange, qLow ) )
1913:              inc( width )
1919:              oNodeSetInt( a, qSize, multiply( width, oNodeGetInt( baseType, qSize ) ) )
      
1945:              oTypeAdd( a )
1951:              baseType = a
      
1957:              [ equal_zero(dim)
1964:                  | true:  >
1967:                  | *:
1972:              ]
1972:          }
      
1974:          resultType = oNodeVecElement( dimensions, 0 )
1987:          oNodeVecDelete( dimensions )
      
1993:       | '^' :
1995:          Node theType
1995:          @TypeRef( theType )
2002:          resultType = @PointerTypeTo( theType )
      
2013:       | pRecord :
2015:          resultType = oNodeNew( nRecordType )
2025:          oScopeBegin
      
2026:          @VarDecl( nRecordField )
      
2033:          int size = oNodeGetInt( oScopeCurrent, qSize )
               % to do: padding
2045:          [ equal_zero( size )
2052:             | true : #eRecordEmpty
2055:             | * :
2060:          ]
      
2060:          pEnd
      
2062:          oNodeSet( resultType, qScope, oScopeCurrent )
2073:          oNodeSetInt( resultType, qSize, size )
2085:          oScopeEnd
2086:          oTypeAdd( resultType )
      
      
            % *** TO DO: following type constructors are not implemented *** 
            % *** TO DO: also missing declaration of enum type
2092:       | pSet :
2094:          pOf
2096:          Node theType
2096:          @TypeRef( theType )
2103:       | * :       % this works for cases except where expr starts with an id
2116:          @ConstExpr '..' @ConstExpr
2122:    ];
      
      
      % --------------------------- Const Expressions --------------------------
      
      % Constant expressions: currently, only literal integers or previously
      % named constant integers are supported, possibly with a negation.
      % Constant expressions are evaluated at compile time.
      
2123: ConstExpr:
2125:    [
2125:       | pIntLit :
2127:          oValuePush( TOKEN_VALUE )
2132:       | pIdent :
2134:          Node decl = oScopeFindRequire
2139:          [ oNodeType( decl )
2146:             | nConst :
2147:                oValuePush( oNodeGetInt( decl, qValue ) )
2160:             | * :
2165:                #eNotConst
2167:                oValuePush( 0 )
2173:          ]
2173:       | pMinus :
2175:          @ConstExpr
2177:          oValueNegate
2178:    ];
      
      
      
      % ------------------------------ Expressions -----------------------------
      
      % There are two wrappers leading into expression parsing:
      %   Expr()
      %   BooleanExprControlFlow( out Label falseLabel )
      %
      % Expr always produces a value on the runtime expr stack,
      % and pushes its type on the type stack.
      %
      % BooleanExprControlFlow always generates control-flow code.
      % It does not push a value on the runtime expr stack.
      % It does not push a type on the type stack.
      % The control flow code ends up at Here if the expr is true,
      % and jumps to falseLabel if the expr is false.
      % This rule allocates falseLabel, and passes it back.
      % The caller will need to define its location.
      %
      % The internal methods of expr parsing may produce a mix of
      % values and control flow, depending on the operators seen.
      % We don't always do one or the other, hoping to be efficient for
      % cases like   "func_call( bool_var1, bool_var2 )"
      % as well as  "if bool_expr1 or bool_expr2 then ...".
      % If a subexpression rule produces control flow, it will allocate a
      % falseLabel and pass it back up.  And it will push the
      % result type as BooleanCFType, to distinguish from BooleanType
      % which corresponds with a boolean value on the expr stack.
      % 
      % Note that my expression parsing is broken into more levels than
      % grammars describe for Pascal precedence levels.  This follows my
      % original parser implementation.  I think my rationale was that
      % operators from the levels that I split up couldn't have been
      % mixed anyway, since they require different data types
      % (e.g. boolean vs int/real).  And splitting them up simplified
      % my code.  But, I should revisit this.
      %
      
      
      % Public entry point:
      %
      % Parse an expression, leaving a value on the runtime expr stack
      % and its type on the type stack.
      %
      % This rule does not export control flow (though it may generate
      % control flow internally for subexpressions).
      %
2189: Expr:
2191:    Label falseLabel = labelNull
      
2197:    @ExprAllowCF( falseLabel )
2204:    @CFToVal( falseLabel );
      
      
      % Public entry point:
      %
      % Parse a Boolean expression, producing control flow code rather than a value.
      % Does not leave a value on the runtime expr stack.
      % Does not leave a type on the type stack.
      %
      % If the expression is true, the code will fall through to the end (Here).
      % If the expression is false, the code will jump to the given falseLabel,
      % which this rule will allocate but not define the location for.
      % The caller must do so.
      %
2212: BooleanExprControlFlow( out Label falseLabel ):
2214:    @ExprAllowCF( falseLabel )
2221:    [ oTypeSNodeType
2223:       | nBooleanCFType :
2224:       | nBooleanType :
               % convert value to control flow
2226:          falseLabel = oLabelNew
2231:          .tJumpFalse  oEmitLabel( falseLabel )
2239:       | * :
2246:          #eNotBoolean
2248:    ]
2248:    oTypeSPop;
      
      
      % If the current expr result is control flow, convert it to a value.
      % falseLabel is the label that had been used by the control flow.
      % On return it will be set to labelNull.
      %
2250: CFToVal( inout Label falseLabel ):
2252:    [ oTypeSNodeType
2254:       | nBooleanCFType :
2255:          Label doneLabel = oLabelNew
2260:          .tPushConstI  oEmitInt( 1 )
2268:          .tJump  oEmitLabel( doneLabel )
2276:          .tLabel  oEmitLabel( falseLabel )
2284:          .tPushConstI  oEmitInt( 0 )
2292:          .tLabel  oEmitLabel( doneLabel )
2300:          oTypeSPop
2301:          oTypeSPush( BooleanType )
2307:          falseLabel = labelNull
2313:       | * :
2318:    ];
      
      
      % If the current expr result is boolean value, convert it to control flow.
      % falseLabel will be allocated by this rule and passed back.
      % The caller must define its location.
      %
2319: ValToCF( out Label falseLabel ):
2321:    [ oTypeSNodeType
2323:       | nBooleanType :
2324:          falseLabel = oLabelNew
2329:          .tJumpFalse  oEmitLabel( falseLabel )
2337:          oTypeSPop
2338:          oTypeSPush( BooleanCFType )
2344:       | * :
2349:    ];
      
      
      % Parse an expression.  It may produce a value on the expr stack,
      % or control flow, depending on what's seen in the expression.
      % Leaves the expression type on the type stack.
      %
      % If the expression produces control flow, the expression type will be
      % nBooleanCFType.  In this case, a true value falls through to Here,
      % and a false value jumps to falseLabel.  This rule will allocate falseLabel
      % and return it, but will not define its location; the caller must do so.
      %
      % If the expression produces a value, the value will be left on the
      % expression stack, and the type will be some type other than nBooleanCFType.
      % In this case, falseLabel is ignored.
      %
2350: ExprAllowCF( out Label falseLabel ):
2352:    @BoolExprAllowCF( falseLabel )
2359:    {[
2359:       | '=' :
2361:          @CFToVal( falseLabel )
2368:          @BoolExprAllowCF( falseLabel )
2375:          @CFToVal( falseLabel )
2382:          @MatchTypes
2384:          [ oTypeSNodeType
2386:             | nIntegerType, nBooleanType :  .tEqualI
2389:             | nPointerType :                .tEqualP
2393:             | nCharType, nStringType :      #eNotImplemented
2397:             | * :                           #eNotAllowed
2412:          ]
2412:          oTypeSPop
2413:          oTypeSPush( BooleanType )
      
2419:       | '<>' :
2421:          @CFToVal( falseLabel )
2428:          @BoolExprAllowCF( falseLabel )
2435:          @CFToVal( falseLabel )
2442:          @MatchTypes
2444:          [ oTypeSNodeType
2446:             | nIntegerType, nBooleanType :  .tNotEqualI
2449:             | nPointerType :                .tNotEqualP
2453:             | nCharType, nStringType :      #eNotImplemented
2457:             | * :                           #eNotAllowed
2472:          ]
2472:          oTypeSPop
2473:          oTypeSPush( BooleanType )
      
2479:       | '<' :
2481:          @CFToVal( falseLabel )
2488:          @BoolExprAllowCF( falseLabel )
2495:          @CFToVal( falseLabel )
2502:          @MatchTypes
2504:          [ oTypeSNodeType
2506:             | nIntegerType, nBooleanType :  .tLessI
2509:             | nCharType, nStringType :      #eNotImplemented
2513:             | * :                           #eNotAllowed
2526:          ]
2526:          oTypeSPop
2527:          oTypeSPush( BooleanType )
      
2533:       | '>' :
2535:          @CFToVal( falseLabel )
2542:          @BoolExprAllowCF( falseLabel )
2549:          @CFToVal( falseLabel )
2556:          @MatchTypes
2558:          [ oTypeSNodeType
2560:             | nIntegerType, nBooleanType :  .tGreaterI
2563:             | nCharType, nStringType :      #eNotImplemented
2567:             | * :                           #eNotAllowed
2580:          ]
2580:          oTypeSPop
2581:          oTypeSPush( BooleanType )
      
2587:       | '<=' :
2589:          @CFToVal( falseLabel )
2596:          @BoolExprAllowCF( falseLabel )
2603:          @CFToVal( falseLabel )
2610:          @MatchTypes
2612:          [ oTypeSNodeType
2614:             | nIntegerType, nBooleanType :  .tLessEqualI
2617:             | nCharType, nStringType :      #eNotImplemented
2621:             | * :                           #eNotAllowed
2634:          ]
2634:          oTypeSPop
2635:          oTypeSPush( BooleanType )
      
2641:       | '>=' :
2643:          @CFToVal( falseLabel )
2650:          @BoolExprAllowCF( falseLabel )
2657:          @CFToVal( falseLabel )
2664:          @MatchTypes
2666:          [ oTypeSNodeType
2668:             | nIntegerType, nBooleanType :  .tGreaterEqualI
2671:             | nCharType, nStringType :      #eNotImplemented
2675:             | * :                           #eNotAllowed
2688:          ]
2688:          oTypeSPop
2689:          oTypeSPush( BooleanType )
      
2695:       | * :
2710:          >
2712:    ]};
      
      
2715: BoolExprAllowCF( out Label falseLabel ):
2717:    Label trueLabel = labelNull
      
2723:    @BoolTermAllowCF( falseLabel )
2730:    {[
2730:       | pOr :
2732:          [ oTypeSNodeType
2734:             | nBooleanCFType :
                     % We are true here. Jump ahead to done
2735:                [ equal_label( trueLabel, labelNull )
2745:                   | true :  trueLabel = oLabelNew
2751:                   | * :
2756:                ]
2756:                .tJump  oEmitLabel( trueLabel )
2764:             | nBooleanType :
2766:                @ValToCF( falseLabel )
                     % We are true here. Jump ahead to done
2773:                [ equal_label( trueLabel, labelNull )
2783:                   | true :  trueLabel = oLabelNew
2789:                   | * :
2794:                ]
2794:                .tJump  oEmitLabel( trueLabel )
2802:             | * : #eNotBoolean
2811:          ]
2811:          oTypeSPop
      
               % false in previous term will jump here, to try this alternative term
2812:          .tLabel  oEmitLabel( falseLabel )
      
               % we'll get a new falseLabel for this term
2820:          falseLabel = labelNull
2826:          @BoolTermAllowCF( falseLabel )
      
2833:          [ oTypeSNodeType
2835:             | nBooleanCFType :
2836:             | nBooleanType :
2838:                @ValToCF( falseLabel )
2845:             | * : #eNotBoolean
2854:          ]
      
2854:          oTypeSPop
2855:          oTypeSPush( BooleanCFType )
      
2861:       | * :
2866:          >
2868:    ]}
      
         % any short-circuit trues jump here to the end
2870:    [ equal_label( trueLabel, labelNull )
2880:       | false :
2881:          .tLabel  oEmitLabel( trueLabel )
2889:       | * :
2894:    ]
2895:    ;
      
      
2895: BoolTermAllowCF( out Label falseLabel ):
2897:    Label overallFalseLabel = labelNull
      
2903:    @BoolFactorAllowCF( falseLabel )
2910:    {[
2910:       | pAnd :
2912:          [ oTypeSNodeType
2914:             | nBooleanCFType :
2915:             | nBooleanType :
2917:                @ValToCF( falseLabel )
2924:             | * :
2931:                #eNotBoolean
2933:          ]
2933:          oTypeSPop
      
               % We're going to have a different falseLabel for each term,
               % because we let each rule allocate its own (rather than accepting labels passed in).
               % And in this case we want them all to go to the same place,
               % to be determined by the caller.
               %
               % I'll allow for label aliases.  This will be more optimal than generating
               % multiple private false-handling code segments, that the true path would have to
               % jump around.  That would be hard to eliminate afterwards.
      
2934:          [ equal_label( overallFalseLabel, labelNull )
2944:             | true :
2945:                overallFalseLabel = oLabelNew
2950:                .tLabelAlias  oEmitLabel( falseLabel )  oEmitLabel( overallFalseLabel )
2964:                falseLabel = overallFalseLabel
2970:             | * :
2975:          ]
      
2975:          Label factorFalseLabel = labelNull
2981:          @BoolFactorAllowCF( factorFalseLabel )
      
2988:          [ oTypeSNodeType
2990:             | nBooleanCFType :
2991:             | nBooleanType :
2993:                @ValToCF( factorFalseLabel )
3000:             | * : #eNotBoolean
3009:          ]
3009:         .tLabelAlias  oEmitLabel( factorFalseLabel )  oEmitLabel( overallFalseLabel )
      
3023:       | * :
3028:          >
3030:    ]};
      
3033: BoolFactorAllowCF( out Label falseLabel ):
3035:    [
3035:       | pNot :
3037:          Label factorFalseLabel = labelNull
      
3043:          @BoolFactorAllowCF( factorFalseLabel )
3050:          [ oTypeSNodeType
3052:             | nBooleanCFType :
                     % We have control flow, and are sitting at the point that has value false.
3053:                falseLabel = oLabelNew
3058:                .tJump  oEmitLabel( falseLabel )
                     % The true path jumps here
3066:                .tLabel  oEmitLabel( factorFalseLabel )
      
3074:             | nBooleanType :
                     % I have a value.  I'll leave it as a value, rather than create control flow.
                     % See how this goes.
3076:                .tNot
      
3078:             | * : #eNotBoolean
3087:          ]
      
3087:       | * :
3092:          @ArithExprAllowCF( falseLabel )
3099:    ];
      
3100: ArithExprAllowCF( out Label falseLabel ):
3102:    @TermAllowCF( falseLabel )
3109:    {[
3109:       | pPlus :
3111:          @RequireIntPop
3113:          @TermAllowCF( falseLabel )  % actually not allowing CF, will be caught by type check
3120:          @RequireInt
3122:          .tAddI
3124:       | pMinus :
3126:          @RequireIntPop
3128:          @TermAllowCF( falseLabel )
3135:          @RequireInt
3137:          .tSubI
3139:       | * :
3146:          >
3148:    ]};
      
3151: TermAllowCF( out Label falseLabel ):
3153:    @FactorAllowCF( falseLabel )
3160:    {[
3160:       | pTimes :
3162:          @RequireIntPop
3164:          @FactorAllowCF( falseLabel )  % actually not allowing CF, will be caught by type check
3171:          @RequireInt
3173:          .tMultI
3175:       | pDivide :
3177:          @RequireIntPop
3179:          @FactorAllowCF( falseLabel )
3186:          @RequireInt
3188:          .tDivI
3190:       | * :
3197:          >
3199:    ]};
      
3202: FactorAllowCF( out Label falseLabel ):
3204:    [
3204:       | pPlus :
3206:          @PrimaryAllowCF( falseLabel )  % actually not allowing CF, will be caught by type check
3213:          @RequireInt
3215:       | pMinus :
3217:          @PrimaryAllowCF( falseLabel )
3224:          @RequireInt
3226:          .tNegI
3228:       | * :
3235:          @PrimaryAllowCF( falseLabel )
3242:    ];
      
3243: PrimaryAllowCF( out Label falseLabel ):
3245:    [
3245:       | pIntLit :
3247:          .tPushConstI  oEmitInt( TOKEN_VALUE )
3254:          oTypeSPush( IntegerType )
      
3260:       | '(' :
3262:          @ExprAllowCF( falseLabel )
3269:          ')'
      
3271:       | pStrLit :
3273:          int addr = oStringAllocLit( CURRENT_STRLIT )     % store in global data
3282:          .tPushAddrGlobal oEmitInt( addr )
               % TO DO: do we need to create a type with the literal's length?
3290:          oTypeSPush( StringType )
      
3296:       | pIdent :
3298:          Node decl = oScopeFindRequire
3303:          Node theType
      
3303:          [ oNodeType( decl )
3310:             | nFunc :
      
3311:                @Call( decl )
      
3318:             | nConst :
3320:                theType = oNodeGet( decl, qType )
3333:                oTypeSPush( theType )
3339:                [ oTypeSNodeType
3341:                   | nIntegerType, nBooleanType :
3342:                      .tPushConstI @EmitValue( decl )
3351:                   | * :
3358:                      #eNotImplemented
3360:                ]
      
3360:             | nGlobalVar, nLocalVar, nParam :
3362:                @VarExpr( decl )
      
3369:             | * :
3382:                #eNotValue
3384:                oTypeSPush( IntegerType )
3390:          ]
      
3390:       | '@' :        % @var -- pointer to var
3392:          pIdent
      
3394:          Node decl = oScopeFindRequire
3399:          Node theType
      
3399:          @LValueVar( decl )
      
               % The above leaves the pointed-to type on type stack.
               % Replace with ptr-to-<type>.
3406:          theType = oTypeSTop
3411:          oTypeSPop
3412:          Node ptrType = @PointerTypeTo( theType )
3423:          oTypeSPush( ptrType )
      
3429:       | * :
3442:          #eNotValue
3444:          oTypeSPush( IntegerType )
3450:    ];
      
      
      % Parse a variable expression, given the declaration of the
      % just-accepted identifier.
      % Leaves the value on the expression stack, and type on the type stack.
      %
3451: VarExpr( Node decl ):
3453:    Node theType = oNodeGet( decl, qType )
3466:    oTypeSPush( theType )
3472:    [ oTypeSNodeType
3474:       | nIntegerType :
3475:          [ oNodeType( decl )
3482:             | nGlobalVar :   .tPushGlobalI @EmitValue( decl )
3492:             | nLocalVar :    .tPushLocalI @EmitValue( decl )
3503:             | nParam :
3505:                [ oNodeGetBoolean( decl, qInOut )
3515:                   | true :    % VAR param points to the var.  Auto dereference.
3516:                               .tPushParamP @EmitValue( decl )
3525:                               .tFetchI
3527:                   | * :       .tPushParamI @EmitValue( decl )
3541:                ]
3541:          ]
      
3551:       | nBooleanType :
3553:          [ oNodeType( decl )
3560:             | nGlobalVar :   .tPushGlobalB @EmitValue( decl )
3570:             | nLocalVar :    .tPushLocalB @EmitValue( decl )
3581:             | nParam :
3583:                [ oNodeGetBoolean( decl, qInOut )
3593:                   | true :    % VAR param points to the var.  Auto derefernce.
3594:                               .tPushParamP @EmitValue( decl )
3603:                               .tFetchB
3605:                   | * :       .tPushParamB @EmitValue( decl )
3619:                ]
3619:          ]
      
3629:       | nCharType, nStringType, nFileType :
3631:          #eNotImplemented
      
3633:       | nPointerType :
3635:          [ oNodeType( decl )
3642:             | nGlobalVar :   .tPushGlobalP @EmitValue( decl )
3652:             | nLocalVar :    .tPushLocalP @EmitValue( decl )
3663:             | nParam :
3665:                [ oNodeGetBoolean( decl, qInOut )
3675:                   | true :    % VAR param points to the var.  Auto derefernce.
3676:                               .tPushParamP @EmitValue( decl )
3685:                               .tFetchP
3687:                   | * :       .tPushParamP @EmitValue( decl )
3701:                ]
3701:          ]
3711:          [
3711:             | '^' :             % dereferenced
3713:                oTypeSPop
3714:                oTypeSPush( oNodeGet( theType, qBaseType ) )
3727:                @LValueIndexes
3729:                @FetchVar
3731:             | * :               % just ptr value alone
3736:          ]
      
3736:       | * :
               % compound type
               % first, push addr of start of var
3751:          [ oNodeType( decl )
3758:             | nGlobalVar :   .tPushAddrGlobal @EmitValue( decl )
3768:             | nLocalVar :    .tPushAddrLocal @EmitValue( decl )
3779:             | nParam :
3781:                [ oNodeGetBoolean( decl, qInOut )
3791:                   | true :    % VAR param points to the var.  Auto derefernce.
3792:                               .tPushParamP @EmitValue( decl )
3801:                   | * :       .tPushAddrParam @EmitValue( decl )
3815:                ]
3815:          ]
               % modify addr for subscripts, field references, etc
3825:          @LValueIndexes
               % get final value
3827:          @FetchVar
3829:    ];
      
      
      % Addr of start of var is on expr stack; type is on type stack.
      % Replace expr stack with value of var.
      % (In the case of compound vars, this remains as the addr of the var).
      
3830: FetchVar:
3832:    [ oTypeSNodeType
3834:       | nIntegerType :   .tFetchI
3837:       | nBooleanType :   .tFetchB
3841:       | nCharType, nStringType, nFileType : #eNotImplemented
3845:       | nPointerType :   .tFetchP
3849:       | * :              % compound type; leave as addr
3864:    ];
      
      
      % Addr of start of var is already on run stack, and type is on type stack.
      % Read subscripts, record fields, etc, to get final addr on run stack, and final type
      % on type stack.
      
3865: LValueIndexes:
3867:    {[
3867:       | '[' :       @ArraySubscripts
3871:       | '.' :       @RecordFieldRef
3875:       | '^' :       @PointerDeref
3879:       | * :         >
3890:    ]};
      
3893: ArraySubscripts:
3895:    [ oTypeSNodeType
3897:       | nArrayType :
3898:       | * :       #eNotArray
3905:    ]
3905:    {
3905:       [ oTypeSNodeType
3907:          | nArrayType :
3908:          | * :    #eTooManySubscripts
3915:       ]
      
            % low subscript of this dimension
3915:       int low = @OrdinalLow( oNodeGet( oTypeSTop, qIndexType ) )
      
            % replace type stack with next dimension, or OF type
3932:       Node baseType
3932:       baseType = oNodeGet( oTypeSTop, qBaseType )
3944:       oTypeSPop
3945:       oTypeSPush( baseType )
      
3951:       @Expr
3953:       @RequireIntPop
            % adjust for low subscript
3955:       [ equal_zero( low )
3962:          | false :
3963:             .tPushConstI oEmitInt( low ) .tSubI
3973:          | * :
3978:       ]
      
            % multiply by element size
3978:       int size = oNodeGetInt( baseType, qSize )
3991:       [ equal( size, 1 )
4001:          | false :
4002:             .tPushConstI oEmitInt( size ) .tMultI
4012:          | * :
4017:       ]
      
            % update start address
4017:       .tAddPI
4019:       [
4019:          | ']' :  >
4023:          | ',' :
4025:       ]
4033:    };
      
      
4036: RecordFieldRef:
4038:    [ oTypeSNodeType
4040:       | nRecordType :
4041:       | * :    #eNotRecord
4048:    ]
4048:    oScopeEnter( oNodeGet( oTypeSTop, qScope ) )
4060:    pIdent
4062:    Node field = oScopeFindRequire
         % oScopeFind searches all open scopes, so make sure we found nRecordField
         % which could only be seen in the local scope we entered above.
4067:    [ oNodeType( field )
4074:       | nRecordField :
4075:       | * :   #eNotRecordField
4082:    ]
4082:    oScopeEnd
4083:    int offset = oNodeGetInt( field, qValue )
4096:    [ equal_zero( offset )
4103:       | false :
4104:          .tPushConstI oEmitInt( offset ) .tAddPI
4114:       | * :
4119:    ]
      
         % replace the type on the type stack, with the field type
4119:    oTypeSPop
4120:    oTypeSPush( oNodeGet( field, qType ) )
4134:    ;
      
      
      % ptr deref on left side, i.e. BEFORE addr of ptr var is on stack,
      %                              AFTER addr of thing pointed to is on stack
4134: PointerDeref:
4136:    [ oTypeSNodeType
4138:       | nPointerType :
4139:       | * :       #eNotPointer
4146:    ]
4146:    .tFetchP           % now addr on stack is addr of what we're pointing to
      
4148:    Node theType = oTypeSTop
4153:    oTypeSPop
4154:    oTypeSPush( oNodeGet( theType, qBaseType ) )
4168:    ;
      
      
      % The expr stack contains a value whose type is on top of the type stack.
      % Generate code to coerce the value to the type under it in the type stack
      % (pop the type stack, leaving only the desired type).
      % This is used for assignment.
      %
4168: CoerceType:
         % TO DO: not implemented yet.  For now I require exact type match.
4170:    @MatchTypes
4173:    ;
      
      
      % Called on first use of an extern method
      %
4173: DefineExternLabel( Node method ):
         % The extern name might be given explicitly, otherwise the pascal method name.
4175:    int strAddr
4175:    String externalName = oNodeGetString( method, qExternalName )
4188:    [ equal_string( externalName, stringNull )
4198:       | true :
4199:          strAddr = oStringAllocLit( ID_STRING( oNodeGetInt( method, qIdent ) ) )
4220:       | false :
4222:          strAddr = oStringAllocLit( externalName )
4232:    ]
4240:    .tLabelExtern  @EmitValue( method )  oEmitInt( strAddr )
4256:    ;
      
      
      % Parse a call, given an nProc or nFunc for the just-accepted identifier.
      % If a func, this will also generate the code to push the return value on the expr stack,
      % and push the return type on the type stack.
      %
4256: Call( Node method ):
      
         % Prior to first call, issue extern label for a called method.
         % I don't want to issue .tLabelExtern for unused methods, that seems inefficient.
4258:    [ oNodeGetBoolean( method, qExternal )
4268:       | true :
4269:          [ oNodeGetBoolean( method, qCalled )
4279:             | false :
                     % define the extern label on first use
4280:                @DefineExternLabel( method )
4287:             | * :
4292:          ]
4292:      | * :
4297:    ]
4297:    oNodeSetBoolean( method, qCalled, true )
      
         % If the method has a cdecl modifier, the back end will need to use the native
         % calling convention, instead of my own.  But, the convention varies by platform,
         % so the front end won't assume what it needs.  I'll still generate the normal tcode
         % that copies values into actuals space on the stack.
         % However, to help the back end, I will at least use a different instruction for the
         % allocation of the actuals space, and for the actual call.
         %
         % p.s. I only support cdecl on external methods, because I don't have a way
         % to let my own Pascal methods read params passed in with the cdecl calling convention.
         %
4309:    boolean cdecl = oNodeGetBoolean( method, qCdecl )
      
         % If this is a function, we will allocate a temporary
         % in the current scope, to hold the result value.
         % And pass a pointer to that temporary as an extra parameter.
4322:    Node resultType
4322:    int tempOffset
      
4322:    boolean isFunc = equal_node_type( oNodeType( method ), nFunc )
      
4339:    [ isFunc
4342:       | true :
4343:          resultType = oNodeGet( method, qType )
4356:          tempOffset = oScopeAllocType( resultType )
               % TO DO: we could manage temp allocation, so temp space can be reused
               %        by different code branches.
4366:       | * :
4371:    ]
         
      
4371:    Node paramScope = oNodeGet( method, qParams )
4384:    int actualsSize = oNodeGetInt( paramScope, qSize )
4397:    [ cdecl
4400:       | true : .tAllocActualsCdecl  oEmitInt( actualsSize )
4409:       | false :  .tAllocActuals  oEmitInt( actualsSize )
4419:    ]
      
4427:    NodeIter paramIter = oNodeGetIter( paramScope, qDecls )
4440:    Node param = oNodeIterValue( paramIter )
4450:    [
4450:       | '(' :
            
4452:          {
4452:             [ oNodeNull( param )
4459:                | true : >
4462:                | * :
4467:             ]
      
4467:             int offset = oNodeGetInt( param, qValue )
      
                  % Assign actual value to spot in actuals space
4480:             .tPushAddrActual oEmitInt( offset )
4488:             oTypeSPush( oNodeGet( param, qType ) )
      
4501:             [ oNodeGetBoolean( param, qInOut )
4511:                | true :   % A VAR param.
                                % The actual is a pointer to the value.
                                % The type on the type stack (pushed above) is for the pointed-to value.
      
4512:                           @LValueExpr
                                % Addr of the referenced variable is on the expr stack,
                                % type of the variable is on the type stack.
      
                                % Match types more exactly. It's not sufficient to be assign compatible
                                % since the method will be assigning to the actual using the param type.
                                % Maybe something like type contents must match, incl subrange bounds.
4514:                           @MatchTypes
      
4516:                           .tAssignP
      
4518:                | false :  @Expr
4522:                           @CoerceType
                                
                                % Assign to offset in actuals space
      
4524:                           [ oTypeSNodeType
4526:                              | nIntegerType :            .tAssignI
4529:                              | nBooleanType :            .tAssignB
4533:                              | nCharType, nStringType, nFileType :   #eNotImplemented
4537:                              | nPointerType :            .tAssignP
4541:                              | * :
                                       % compound types: copy value into actuals space
4556:                                  int size = oNodeGetInt( oTypeSTop, qSize )
4568:                                  .tCopy  oEmitInt( size )    % multi-word copy
4576:                           ]
4576:             ]
4584:             oTypeSPop
      
4585:             oNodeIterNext( paramIter )
4591:             param = oNodeIterValue( paramIter )
4601:             [ oNodeNull( param )
4608:                | true :  >
4611:                | false :
4613:             ]
      
4621:             ','
4623:          }
      
4625:          ')'
      
4627:       | * :
4632:    ]
      
4632:    [ oNodeNull( param )
4639:       | false :    #eMissingParameter
4642:       | * :
4647:    ]
      
4647:    [ isFunc
4650:       | true :
               % Pass result temp as an additional VAR parameter.
4651:          .tPushAddrActual oEmitInt( oNodeGetInt( method, qResultOffset ) )
4666:          .tPushAddrLocal  oEmitInt( tempOffset )
4674:          .tAssignP
4676:       | * :
4681:    ]
      
4681:    [ cdecl
4684:       | true :
4685:          .tCallCdecl  @EmitValue( method )
4694:       | false :
4696:          .tCall   @EmitValue( method )
4705:    ]
      
4713:    [ isFunc
4716:       | true :
               % push return value from temp
4717:          oTypeSPush( resultType )
      
4723:          [ oTypeSNodeType
4725:             | nIntegerType :   .tPushLocalI  oEmitInt( tempOffset )
4734:             | nBooleanType :   .tPushLocalB  oEmitInt( tempOffset )
4744:             | nCharType, nStringType, nFileType : #eNotImplemented
4748:             | nPointerType :   .tPushLocalP  oEmitInt( tempOffset )
4758:             | * :              % compound type: push address
4773:                                .tPushAddrLocal  oEmitInt( tempOffset )
4781:          ]
4781:       | * :
4786:    ]
         
4786:    .tFreeActuals  oEmitInt( actualsSize )
4795:    ;
      
      
      % ------------------------------ Statements -----------------------------
      
4795: Statement:
4797:    [
4797:       | pWriteln :     @WritelnStmt
4801:       | pWrite :       @WriteStmt
4805:       | pReadln :      @ReadlnStmt
4809:       | pRead :        @ReadStmt
4813:       | pIf :          @IfStmt
4817:       | pWhile :       @WhileStmt
4821:       | pFor :         @ForStmt
4825:       | pRepeat :      @RepeatStmt
4829:       | pBreak :       @BreakStmt
4833:       | pContinue :    @ContinueStmt
4837:       | pBegin :       @BeginStmt
4841:       | pIdent :       @AssignOrCallStmt
4845:       | * :            % null statement : don't accept any tokens
4872:    ];
      
      
4873: AssignOrCallStmt:
4875:    Node decl = oScopeFindRequire
4880:    [ oNodeType( decl )
4887:       | nProc :                           @Call( decl )
4895:       | nGlobalVar, nLocalVar, nParam :   @AssignStmt( decl )
4904:       | nFunc :                           @AssignResultStmt( decl )
4913:       | * :                               #eBadStatement
4928:    ];
      
      
      % Given decl, the just-accepted first identifier on the left hand side.
      %
4929: AssignStmt( Node decl ):
      
4931:    @LValueVar( decl )
4938:    ':=' 
4940:    @Expr
4942:    @MatchTypes
4944:    @Assign
4947:    ;
      
      
      % Performs a raw assignment.
      % Given lvalue 2nd on stack, and expr value top of stack,
      % and type of both of these on the type stack,
      % perform the assignment and pop the type off the type stack.
      %
4947: Assign:
4949:    [ oTypeSNodeType
4951:       | nIntegerType :            .tAssignI
4954:       | nBooleanType :            .tAssignB
4958:       | nCharType, nStringType, nFileType :   #eNotImplemented
      
            % compound var assigns; addrs of src, dest on stack
4962:       | nPointerType :            .tAssignP
4966:       | * :
4981:           int size = oNodeGetInt( oTypeSTop, qSize )
4993:           .tCopy  oEmitInt( size )    % multi-word copy
5001:    ]
5001:    oTypeSPop
5003:    ;
      
      % Given nFunc for the just-accepted identifier on the left hand side.
      % Parse an assignment that represents assignment of the function result.
      %
5003: AssignResultStmt( Node funcDecl ):
         % Only allowed to assign the result of the immediately enclosing function, I think.
5005:    [ oNodeEqual( oNodeGet( funcDecl, qChildScope ), oScopeCurrent )
5021:       | false :   #eNotCurrentFunction
5024:       | * :
5029:    ]
      
         % Result value is stored in the caller's space, via a hidden VAR parameter.
5029:    .tPushParamP  oEmitInt( oNodeGetInt( funcDecl, qResultOffset ) )
5044:    oTypeSPush( oNodeGet( funcDecl, qType ) )
      
5057:    ':='
5059:    @Expr
5061:    @MatchTypes
5063:    [ oTypeSNodeType
5065:       | nIntegerType :            .tAssignI
5068:       | nBooleanType :            .tAssignB
5072:       | nCharType, nStringType, nFileType :   #eNotImplemented
      
            % compound var assigns; addrs of src, dest on stack
5076:       | nPointerType :            .tAssignP
5080:       | * :
5095:           int size = oNodeGetInt( oTypeSTop, qSize )
5107:           .tCopy  oEmitInt( size )    % multi-word copy
5115:    ]
5115:    oTypeSPop
5117:    ;
      
      
      
      % Parse an lvalue expression, from scratch.
      % This is an expression that may appear on the left side of an assignment.
      % Leaves the address of the value on the expr stack,
      % and the type of the value at that address on the type stack.
      %
5117: LValueExpr:
         % At the moment, all lvalue expressions start with a variable name.
         % I think there can also be typecasts, not supported yet.  Check standard syntax.
5119:    pIdent
5121:    Node decl = oScopeFindRequire
5126:    [ oNodeType( decl )
5133:       | nGlobalVar, nLocalVar, nParam :
5134:       | * :  #eNotVar
5145:    ]
5145:    @LValueVar( decl )
5153:    ;
      
      
      % Parse an lvalue expression (e.g. left side of an assign statement)
      % that starts with the just-accepted identifier indicated by the given decl.
      % Leaves the lvalue address on the expression stack,
      % and the type of the value at that address on the type stack.
      %
5153: LValueVar( Node decl ):
5155:    [ oNodeType( decl )
5162:       | nGlobalVar :   .tPushAddrGlobal @EmitValue( decl )
5172:       | nLocalVar :    .tPushAddrLocal @EmitValue( decl )
5183:       | nParam :
5185:          [ oNodeGetBoolean( decl, qInOut )
5195:             | true :   % VAR param points to variable.  No dereference.
5196:                        .tPushParamP @EmitValue( decl )
5205:             | * :      .tPushAddrParam @EmitValue( decl )
5219:          ]
5219:       | * :            #eNotVar
5230:    ]
      
5230:    oTypeSPush( oNodeGet( decl, qType ) )
5243:    @LValueIndexes        % handle subscripts, if any
5246:    ;
      
      
5246: IncVar( Node decl ):
5248:    @LValueVar( decl )
5255:    @RequireIntPop
5257:    @VarExpr( decl )
5264:    oTypeSPop
5265:    .tIncI
5267:    .tAssignI;
      
5270: DecVar( Node decl ):
5272:    @LValueVar( decl )
5279:    @RequireIntPop
5281:    @VarExpr( decl )
5288:    oTypeSPop
5289:    .tDecI
5291:    .tAssignI;
      
      
5294: IfStmt:
5296:    Label falseLabel = labelNull
      
5302:    @BooleanExprControlFlow( falseLabel )
5309:    pThen
5311:    @Statement
5313:    [
5313:       | pElse :
5315:          Label doneLabel = oLabelNew
      
5320:          .tJump  oEmitLabel( doneLabel )
5328:          .tLabel oEmitLabel( falseLabel )
5336:          @Statement
5338:          .tLabel oEmitLabel( doneLabel )
      
5346:       | * :
5351:          .tLabel oEmitLabel( falseLabel )
5359:    ];
      
      
5360: ForStmt:
5362:    pIdent
      
5364:    Node decl = oScopeFindRequire
         % TO DO: disallow use of a compound variable field.
         %        Could do that by disallowing use of LValueIndexes,
         %        or by double-checking the decl's qType here.
5369:    @LValueVar( decl )
5376:    @RequireIntPop
      
5378:    ':='
      
5380:    @Expr
5382:    @RequireIntPop
5384:    .tAssignI
      
5386:    Label breakLabel = oLabelNew
      
5391:    Label checkLabel = oLabelNew
5396:    .tJump  oEmitLabel( checkLabel )
      
5404:    Label continueLabel = oLabelNew
5409:    .tLabel  oEmitLabel( continueLabel )
5417:    [
5417:       | pTo :
5419:          @IncVar( decl )
5426:          .tLabel  oEmitLabel( checkLabel )
5434:          @VarExpr( decl )  oTypeSPop
5442:          @Expr
5444:          @RequireIntPop
5446:          .tGreaterI
5448:          .tJumpTrue  oEmitLabel( breakLabel )
5456:       | pDownto :
5458:          @DecVar( decl )
5465:          .tLabel  oEmitLabel( checkLabel )
5473:          @VarExpr( decl )  oTypeSPop
5481:          @Expr
5483:          @RequireIntPop
5485:          .tLessI
5487:          .tJumpTrue  oEmitLabel( breakLabel )
5495:    ]
5503:    oLoopPush( continueLabel, breakLabel )
5512:    pDo
5514:    @Statement
5516:    .tJump  oEmitLabel( continueLabel )
5524:    .tLabel  oEmitLabel( breakLabel )
5532:    oLoopPop;
      
      
5534: RepeatStmt:
5536:    Label continueLabel = oLabelNew
5541:    .tLabel  oEmitLabel( continueLabel )
      
5549:    Label breakLabel = oLabelNew
      
5554:    oLoopPush( continueLabel, breakLabel )
5563:    @Statement
5565:    {[
5565:       | ';' :
5567:          @Statement
5569:       | pUntil :
5571:          Label falseLabel
5571:          @BooleanExprControlFlow( falseLabel )
5578:          .tLabelAlias  oEmitLabel( falseLabel )  oEmitLabel( continueLabel )
5592:          >
5594:    ]}
5604:    .tLabel  oEmitLabel( breakLabel )
5612:    oLoopPop;
      
      
5614: WhileStmt:
5616:    Label continueLabel = oLabelNew
5621:    .tLabel  oEmitLabel( continueLabel )
      
5629:    Label breakLabel
5629:    @BooleanExprControlFlow( breakLabel )
      
5636:    oLoopPush( continueLabel, breakLabel )
5645:    pDo
5647:    @Statement
5649:    .tJump  oEmitLabel( continueLabel )
5657:    .tLabel  oEmitLabel( breakLabel )
5665:    oLoopPop;
      
      
5667: ContinueStmt:                     % NOTE, for repeat..until, skips test (??)
5669:    [ equal_label( oLoopContinueLabel, labelNull )
5678:       | true :
5679:          #eNotInALoop
5681:       | false :
5683:          .tJump  oEmitLabel( oLoopContinueLabel )
5690:    ];
      
      
5699: BreakStmt:
5701:    [ equal_label( oLoopBreakLabel, labelNull )
5710:       | true :
5711:          #eNotInALoop
5713:       | false :
5715:          .tJump  oEmitLabel( oLoopBreakLabel )
5722:    ];
      
      
5731: BeginStmt:
5733:    @Statement
5735:    {[
5735:       | ';' :   @Statement
5739:       | pEnd :  >
5743:    ]};
      
      
5754: WritelnStmt:
5756:    @WriteStmt
5758:    .tWriteCR;
      
      
5761: WriteStmt:
5763:    [
5763:       | '(' :
5765:          {
5765:             @Expr
5767:             [ oTypeSNodeType
5769:                | nIntegerType :             .tWriteI
5772:                | nBooleanType :             .tWriteBool
5776:                | nStringType :              .tWriteStr
5780:                | nCharType, nFileType :     #eNotImplemented
5784:                | nPointerType :             .tWriteP
5788:                | * :                        #eNotAllowed
5805:             ]
5805:             oTypeSPop
5806:             [
5806:                | ')' : >
5810:                | ',' :
5812:             ]
5820:          }
5822:       | * :
5827:    ];
      
      
5828: ReadlnStmt:      % ***
         % TO DO
5831:    ;
      
5831: ReadStmt:
         % TO DO
5834:    ;
      
      % -------------------------------- Utilities -------------------------------
      
      
      % Require that the top two types on the type stack are matching (ignoring subranges).
      % Pop one of them, leaving only one.
      %
5834: MatchTypes:
5836:    node_type nt = oTypeSNodeType
5841:    oTypeSPop
5842:    [ equal_node_type( nt, oTypeSNodeType )
5851:       | false :
5852:          #eTypeMismatch
5854:       | * :
5859:    ];
      
      
      % Require that the top type on the type stack is integer (ignoring subranges).
      % Pop it.
      %
5860: RequireIntPop:
5862:    [ oTypeSNodeType
5864:       | nIntegerType :
5865:       | * :          #eNotInteger
5872:    ]
5872:    oTypeSPop;
      
5874: RequireInt:
5876:    [ oTypeSNodeType
5878:       | nIntegerType :
5879:       | * :          #eNotInteger
5886:    ];
      
5887: RequireBoolPop:
5889:    [ oTypeSNodeType
5891:       | nBooleanType :
5892:       | * :          #eNotBoolean
5899:    ]
5899:    oTypeSPop;
      
5901: RequireBool:
5903:    [ oTypeSNodeType
5905:       | nBooleanType :
5906:       | * :          #eNotBoolean
5913:    ];
      
      
      % Create and return a new nType of the given node_type, adding it to the type table.
      %
5914: newType( node_type nt, int size ) >> Node:
5916:   Node node = oNodeNew( nt )
5926:   oNodeSetInt( node, qSize, size )
5938:   oTypeAdd( node )
5944:   >> node
5948:   ;
      
      
      % Create and return a new nIdent of the given node_type, with the given ident id.
      % Does not add it to any scope.
      %
5948: newIdent( node_type nt, kind k, int id ) >> Node:
5950:   Node t = oNodeNew( nt )
5960:   oNodeSetInt( t, qIdent, id )
5972:   >> t
5976:   ;
      
      
      % Return an nType representing a pointer to the given type.
      % (Creates a new type if necessary.)
      %
5976: PointerTypeTo( Node theType ) >> Node:
5978:    Node ptrType = oNodeGet( theType, qPointerType )
5991:    [ oNodeNull( ptrType )
5998:       | true :
5999:          ptrType = oNodeNew( nPointerType )
6009:          oNodeSet( ptrType, qBaseType, theType )
6021:          oNodeSetInt( ptrType, qSize, 8 )
6033:          oTypeAdd( ptrType )
6039:          oNodeSet( theType, qPointerType, ptrType )
6051:       | * :
6056:    ]
6056:    >> ptrType;
      
      
      % Return the low value of an ordinal type
      %
6060: OrdinalLow( Node theType ) >> int:
6062:    [ oNodeType( theType )
6069:       | nIntegerType :  >> oMININT    % NOTE ssl literals are limited to 16 bit at the moment, though values are 32 bit ok. So need a mechanism.
6072:       | nBooleanType :  >> 0
6077:       | nCharType :     >> 0
6082:       | nSubrangeType : >> oNodeGetInt( theType, qLow )
6094:       | * :             #eNotOrdinalType
6107:                         >> 0
6110:    ];
      
      
      
      % Emit the value in a declaration.
      % For a constant integer, this is the constant value.
      % For a global variable, this is the global address.
      % For a local variable, this is the local address relative to the call stack frame.
      %
6111: EmitValue( Node decl ):
6113:     oEmitInt( oNodeGetInt( decl, qValue ));
      
      
6127: installBuiltIns:
      
         % install built-in types
6129:    FileType = @newType( nFileType, 4 )
6143:    IntegerType = @newType( nIntegerType, 4 )
6157:    BooleanType = @newType( nBooleanType, 1 )
6171:    BooleanCFType = @newType( nBooleanCFType, 1 )
6185:    CharType = @newType( nCharType, 1 )
6199:    StringType = @newType( nStringType, 256 )    % string with default length 256
      
         % Declare those type identifiers.
         % SSL doesn't support strings, so need help from operations e.g. oIdAdd_File
      
6213:    Node t
      
6213:    t = @newIdent( nTypeDecl, kType, oIdAdd_File )
6229:    oNodeSet( t, qType, FileType )
6241:    oScopeDeclare( t )
      
6247:    t = @newIdent( nTypeDecl, kType, oIdAdd_Integer )
6263:    oNodeSet( t, qType, IntegerType )
6275:    oScopeDeclare( t )
      
6281:    t = @newIdent( nTypeDecl, kType, oIdAdd_Boolean )
6297:    oNodeSet( t, qType, BooleanType )
6309:    oScopeDeclare( t )
      
6315:    t = @newIdent( nTypeDecl, kType, oIdAdd_Char )
6331:    oNodeSet( t, qType, CharType )
6343:    oScopeDeclare( t )
      
6349:    t = @newIdent( nTypeDecl, kType, oIdAdd_String )
6365:    oNodeSet( t, qType, StringType )
6377:    oScopeDeclare( t )
      
         % Built-in constants
      
6383:    t = @newIdent( nConst, kConst, oIdAdd_True )
6399:    oNodeSet( t, qType, BooleanType )
6411:    oNodeSetInt( t, qValue, 1 )
6423:    oScopeDeclare( t )
      
6429:    t = @newIdent( nConst, kConst, oIdAdd_False )
6445:    oNodeSet( t, qType, BooleanType )
6457:    oNodeSetInt( t, qValue, 0 )
6469:    oScopeDeclare( t )
      
6476:    ;
      
6476: end
      
6476: 

Generated code:

   0: oGlobalSpace 8
   2: oLocalSpace 4
   4: oScopeBegin
   5: oGetAddrGlobal 1
   7: oPushResult
   8: oScopeCurrent
   9: oAssign
  10: oCall 6127
  12: oEmit 44
  14: oSetResult 0
  16: oPushResult
  17: oEmitInt
  18: oPop 1
  20: oGetAddrLocal 2
  22: oPushResult
  23: oLabelNew
  24: oAssign
  25: oEmit 38
  27: oSetResult 0
  29: oPushResult
  30: oEmitInt
  31: oPop 1
  33: oEmit 41
  35: oGetLocal 2
  37: oPushResult
  38: oEmitLabel
  39: oPop 1
  41: oEmit 40
  43: oSetResult 0
  45: oPushResult
  46: oEmitInt
  47: oPop 1
  49: oEmit 43
  51: oInput 27
  53: oInput 0
  55: oGetAddrLocal 3
  57: oPushResult
  58: oSetResult 5
  60: oPushResult
  61: oSetResult 1
  63: oPushResult
  64: LAST_ID
  65: oPushResult
  66: oCall 5948
  68: oPop 3
  70: oAssign
  71: oGetLocal 3
  73: oPushResult
  74: oScopeDeclare
  75: oPop 1
  77: oInputChoice 157
  79: oInput 0
  81: oGetAddrLocal 1
  83: oPushResult
  84: oSetResult 11
  86: oPushResult
  87: oSetResult 6
  89: oPushResult
  90: LAST_ID
  91: oPushResult
  92: oCall 5948
  94: oPop 3
  96: oAssign
  97: oGetLocal 1
  99: oPushResult
 100: oSetResult 6
 102: oPushResult
 103: oGetGlobal 2
 105: oPushResult
 106: oNodeSet
 107: oPop 3
 109: oGetLocal 1
 111: oPushResult
 112: oScopeDeclareAlloc
 113: oPop 1
 115: oInput 12
 117: oInput 0
 119: oGetAddrLocal 1
 121: oPushResult
 122: oSetResult 11
 124: oPushResult
 125: oSetResult 6
 127: oPushResult
 128: LAST_ID
 129: oPushResult
 130: oCall 5948
 132: oPop 3
 134: oAssign
 135: oGetLocal 1
 137: oPushResult
 138: oSetResult 6
 140: oPushResult
 141: oGetGlobal 2
 143: oPushResult
 144: oNodeSet
 145: oPop 3
 147: oGetLocal 1
 149: oPushResult
 150: oScopeDeclareAlloc
 151: oPop 1
 153: oInput 14
 155: oJumpForward 160
 157: Choice Lookup Table
          13     79
 160: oInput 4
 162: oSetResult 12
 164: oPushResult
 165: oCall 231
 167: oPop 1
 169: oGetAddrLocal 4
 171: oPushResult
 172: oScopeCurrent
 173: oAssign
 174: oScopeBegin
 175: oScopeCurrent
 176: oPushResult
 177: oSetResult 3
 179: oPushResult
 180: oSetResult 1
 182: oPushResult
 183: oNodeSetBoolean
 184: oPop 3
 186: oGetLocal 3
 188: oPushResult
 189: oSetResult 8
 191: oPushResult
 192: oScopeCurrent
 193: oPushResult
 194: oNodeSet
 195: oPop 3
 197: oGetLocal 2
 199: oPushResult
 200: oGetLocal 4
 202: oPushResult
 203: oCall 281
 205: oPop 2
 207: oScopeEnd
 208: oInput 19
 210: oScopeEnd
 211: oReturn
 212: oLocalSpace 0
 214: oGetParam 2
 216: oPushResult
 217: oCall 231
 219: oPop 1
 221: oGetParam 1
 223: oPushResult
 224: oScopeCurrent
 225: oPushResult
 226: oCall 281
 228: oPop 2
 230: oReturn
 231: oLocalSpace 0
 233: oInputChoice 260
 235: oCall 1334
 237: oJumpForward 273
 239: oCall 1406
 241: oJumpForward 273
 243: oGetParam 1
 245: oPushResult
 246: oCall 1465
 248: oPop 1
 250: oJumpForward 273
 252: oCall 476
 254: oJumpForward 273
 256: oCall 761
 258: oJumpForward 273
 260: Choice Lookup Table
          29    256
          28    252
          32    243
          31    239
          30    235
 271: oJumpForward 275
 273: oJumpBack 233
 275: oCall 278
 277: oReturn
 278: oLocalSpace 0
 280: oReturn
 281: oLocalSpace 3
 283: oEmit 48
 285: oGetParam 2
 287: oPushResult
 288: oEmitLabel
 289: oPop 1
 291: oEmit 44
 293: oGetAddrLocal 1
 295: oPushResult
 296: Here
 297: oAssign
 298: oEmit 56
 300: oGetAddrLocal 2
 302: oPushResult
 303: oGetParam 1
 305: oPushResult
 306: oSetResult 4
 308: oPushResult
 309: oNodeGetCode
 310: oPop 2
 312: oAssign
 313: oGetLocal 2
 315: oPushResult
 316: oEmitCode
 317: oPop 1
 319: oScopeCurrent
 320: oPushResult
 321: oSetResult 4
 323: oPushResult
 324: oSetResult 0
 326: oPushResult
 327: oNodeSetCode
 328: oPop 3
 330: oCall 4795
 332: oEmit 43
 334: oGetAddrLocal 3
 336: oPushResult
 337: oScopeCurrent
 338: oPushResult
 339: oSetResult 2
 341: oPushResult
 342: oNodeGetInt
 343: oPop 2
 345: oAssign
 346: oGetLocal 1
 348: oPushResult
 349: oGetLocal 3
 351: oPushResult
 352: oPatch
 353: oPop 2
 355: oReturn
 356: oLocalSpace 0
 358: oInputChoice 376
 360: oGetParam 1
 362: oPushResult
 363: oSetResult 14
 365: oPushResult
 366: oSetResult 1
 368: oPushResult
 369: oNodeSetBoolean
 370: oPop 3
 372: oInput 4
 374: oJumpForward 381
 376: Choice Lookup Table
          61    360
 379: oJumpForward 383
 381: oJumpBack 358
 383: oReturn
 384: oLocalSpace 1
 386: oGetAddrLocal 1
 388: oPushResult
 389: oScopeCurrent
 390: oPushResult
 391: oSetResult 4
 393: oPushResult
 394: oNodeGetCode
 395: oPop 2
 397: oAssign
 398: oGetLocal 1
 400: oPushResult
 401: oSetResult 0
 403: oPushResult
 404: equal_code
 405: oPop 2
 407: oChoice 427
 409: oGetAddrLocal 1
 411: oPushResult
 412: oCodeNew
 413: oAssign
 414: oScopeCurrent
 415: oPushResult
 416: oSetResult 4
 418: oPushResult
 419: oGetLocal 1
 421: oPushResult
 422: oNodeSetCode
 423: oPop 3
 425: oJumpForward 430
 427: Choice Lookup Table
           1    409
 430: oGetLocal 1
 432: oReturn
 433: oReturn
 434: oLocalSpace 0
 436: oGetParam 1
 438: oPushResult
 439: oSetResult 12
 441: oPushResult
 442: oSetResult 1
 444: oPushResult
 445: oNodeSetBoolean
 446: oPop 3
 448: oInputChoice 472
 450: oInputChoice 467
 452: oInput 2
 454: oGetParam 1
 456: oPushResult
 457: oSetResult 13
 459: oPushResult
 460: CURRENT_STRLIT
 461: oPushResult
 462: oNodeSetString
 463: oPop 3
 465: oJumpForward 470
 467: Choice Lookup Table
          60    452
 470: oJumpForward 475
 472: Choice Lookup Table
           2    450
 475: oReturn
 476: oLocalSpace 4
 478: oInput 0
 480: oGetAddrLocal 1
 482: oPushResult
 483: oSetResult 0
 485: oAssign
 486: oGetAddrLocal 2
 488: oPushResult
 489: oScopeFindInCurrentScope
 490: oAssign
 491: oGetLocal 2
 493: oPushResult
 494: oNodeNull
 495: oPop 1
 497: oChoice 618
 499: oGetAddrLocal 2
 501: oPushResult
 502: oSetResult 7
 504: oPushResult
 505: oSetResult 2
 507: oPushResult
 508: LAST_ID
 509: oPushResult
 510: oCall 5948
 512: oPop 3
 514: oAssign
 515: oGetLocal 2
 517: oPushResult
 518: oSetResult 7
 520: oPushResult
 521: oLabelNew
 522: oPushResult
 523: oNodeSetLabel
 524: oPop 3
 526: oJumpForward 624
 528: oGetAddrLocal 1
 530: oPushResult
 531: oSetResult 1
 533: oAssign
 534: oGetLocal 2
 536: oPushResult
 537: oSetResult 11
 539: oPushResult
 540: oNodeGetBoolean
 541: oPop 2
 543: oChoice 549
 545: oError 21
 547: oJumpForward 552
 549: Choice Lookup Table
           1    545
 552: oGetLocal 2
 554: oPushResult
 555: oSetResult 12
 557: oPushResult
 558: oNodeGetBoolean
 559: oPop 2
 561: oChoice 567
 563: oError 21
 565: oJumpForward 570
 567: Choice Lookup Table
           1    563
 570: oGetLocal 2
 572: oPushResult
 573: oNodeType
 574: oPop 1
 576: oChoice 580
 578: oJumpForward 585
 580: Choice Lookup Table
           7    578
 583: oError 21
 585: oGetLocal 2
 587: oPushResult
 588: oSetResult 16
 590: oPushResult
 591: oGetLocal 2
 593: oPushResult
 594: oSetResult 9
 596: oPushResult
 597: oNodeGet
 598: oPop 2
 600: oPushResult
 601: oNodeSet
 602: oPop 3
 604: oGetLocal 2
 606: oPushResult
 607: oSetResult 9
 609: oPushResult
 610: oSetResult 0
 612: oPushResult
 613: oNodeSet
 614: oPop 3
 616: oJumpForward 624
 618: Choice Lookup Table
           0    528
           1    499
 623: oEndChoice
 624: oScopeBegin
 625: oGetAddrLocal 3
 627: oPushResult
 628: oScopeCurrent
 629: oAssign
 630: oCall 1107
 632: oGetLocal 2
 634: oPushResult
 635: oSetResult 9
 637: oPushResult
 638: oGetLocal 3
 640: oPushResult
 641: oNodeSet
 642: oPop 3
 644: oScopeEnd
 645: oInput 4
 647: oGetLocal 1
 649: oChoice 661
 651: oGetLocal 2
 653: oPushResult
 654: oScopeDeclare
 655: oPop 1
 657: oJumpForward 667
 659: oJumpForward 667
 661: Choice Lookup Table
           1    659
           0    651
 666: oEndChoice
 667: oGetLocal 2
 669: oPushResult
 670: oCall 356
 672: oPop 1
 674: oInputChoice 687
 676: oJumpForward 758
 678: oGetLocal 2
 680: oPushResult
 681: oCall 434
 683: oPop 1
 685: oJumpForward 758
 687: Choice Lookup Table
          59    678
          58    676
 692: oGetLocal 3
 694: oPushResult
 695: oScopeEnter
 696: oPop 1
 698: oScopeBegin
 699: oScopeCurrent
 700: oPushResult
 701: oSetResult 3
 703: oPushResult
 704: oSetResult 1
 706: oPushResult
 707: oNodeSetBoolean
 708: oPop 3
 710: oGetLocal 2
 712: oPushResult
 713: oSetResult 10
 715: oPushResult
 716: oScopeCurrent
 717: oPushResult
 718: oNodeSet
 719: oPop 3
 721: oGetAddrLocal 4
 723: oPushResult
 724: oGetLocal 2
 726: oPushResult
 727: oSetResult 7
 729: oPushResult
 730: oNodeGetLabel
 731: oPop 2
 733: oAssign
 734: oSetResult 13
 736: oPushResult
 737: oGetLocal 4
 739: oPushResult
 740: oCall 212
 742: oPop 2
 744: oGetLocal 2
 746: oPushResult
 747: oSetResult 11
 749: oPushResult
 750: oSetResult 1
 752: oPushResult
 753: oNodeSetBoolean
 754: oPop 3
 756: oScopeEnd
 757: oScopeEnd
 758: oInput 4
 760: oReturn
 761: oLocalSpace 6
 763: oInput 0
 765: oGetAddrLocal 1
 767: oPushResult
 768: oSetResult 0
 770: oAssign
 771: oGetAddrLocal 2
 773: oPushResult
 774: oScopeFindInCurrentScope
 775: oAssign
 776: oGetLocal 2
 778: oPushResult
 779: oNodeNull
 780: oPop 1
 782: oChoice 916
 784: oGetAddrLocal 2
 786: oPushResult
 787: oSetResult 8
 789: oPushResult
 790: oSetResult 3
 792: oPushResult
 793: LAST_ID
 794: oPushResult
 795: oCall 5948
 797: oPop 3
 799: oAssign
 800: oGetLocal 2
 802: oPushResult
 803: oSetResult 7
 805: oPushResult
 806: oLabelNew
 807: oPushResult
 808: oNodeSetLabel
 809: oPop 3
 811: oJumpForward 922
 813: oGetAddrLocal 1
 815: oPushResult
 816: oSetResult 1
 818: oAssign
 819: oGetLocal 2
 821: oPushResult
 822: oSetResult 11
 824: oPushResult
 825: oNodeGetBoolean
 826: oPop 2
 828: oChoice 834
 830: oError 21
 832: oJumpForward 837
 834: Choice Lookup Table
           1    830
 837: oGetLocal 2
 839: oPushResult
 840: oNodeType
 841: oPop 1
 843: oChoice 847
 845: oJumpForward 852
 847: Choice Lookup Table
           8    845
 850: oError 21
 852: oGetLocal 2
 854: oPushResult
 855: oSetResult 16
 857: oPushResult
 858: oGetLocal 2
 860: oPushResult
 861: oSetResult 9
 863: oPushResult
 864: oNodeGet
 865: oPop 2
 867: oPushResult
 868: oNodeSet
 869: oPop 3
 871: oGetLocal 2
 873: oPushResult
 874: oSetResult 9
 876: oPushResult
 877: oSetResult 0
 879: oPushResult
 880: oNodeSet
 881: oPop 3
 883: oGetLocal 2
 885: oPushResult
 886: oSetResult 17
 888: oPushResult
 889: oGetLocal 2
 891: oPushResult
 892: oSetResult 6
 894: oPushResult
 895: oNodeGet
 896: oPop 2
 898: oPushResult
 899: oNodeSet
 900: oPop 3
 902: oGetLocal 2
 904: oPushResult
 905: oSetResult 6
 907: oPushResult
 908: oSetResult 0
 910: oPushResult
 911: oNodeSet
 912: oPop 3
 914: oJumpForward 922
 916: Choice Lookup Table
           0    813
           1    784
 921: oEndChoice
 922: oScopeBegin
 923: oGetAddrLocal 3
 925: oPushResult
 926: oScopeCurrent
 927: oAssign
 928: oCall 1107
 930: oGetLocal 2
 932: oPushResult
 933: oSetResult 9
 935: oPushResult
 936: oGetLocal 3
 938: oPushResult
 939: oNodeSet
 940: oPop 3
 942: oInput 11
 944: oGetAddrLocal 4
 946: oPushResult
 947: oCall 1654
 949: oPop 1
 951: oGetLocal 2
 953: oPushResult
 954: oSetResult 6
 956: oPushResult
 957: oGetLocal 4
 959: oPushResult
 960: oNodeSet
 961: oPop 3
 963: oGetAddrLocal 5
 965: oPushResult
 966: oGetLocal 4
 968: oPushResult
 969: oCall 5976
 971: oPop 1
 973: oAssign
 974: oGetLocal 2
 976: oPushResult
 977: oSetResult 18
 979: oPushResult
 980: oGetLocal 5
 982: oPushResult
 983: oScopeAllocType
 984: oPop 1
 986: oPushResult
 987: oNodeSetInt
 988: oPop 3
 990: oScopeEnd
 991: oInput 4
 993: oGetLocal 1
 995: oChoice 1007
 997: oGetLocal 2
 999: oPushResult
1000: oScopeDeclare
1001: oPop 1
1003: oJumpForward 1013
1005: oJumpForward 1013
1007: Choice Lookup Table
           1   1005
           0    997
1012: oEndChoice
1013: oGetLocal 2
1015: oPushResult
1016: oCall 356
1018: oPop 1
1020: oInputChoice 1033
1022: oJumpForward 1104
1024: oGetLocal 2
1026: oPushResult
1027: oCall 434
1029: oPop 1
1031: oJumpForward 1104
1033: Choice Lookup Table
          59   1024
          58   1022
1038: oGetLocal 3
1040: oPushResult
1041: oScopeEnter
1042: oPop 1
1044: oScopeBegin
1045: oScopeCurrent
1046: oPushResult
1047: oSetResult 3
1049: oPushResult
1050: oSetResult 1
1052: oPushResult
1053: oNodeSetBoolean
1054: oPop 3
1056: oGetLocal 2
1058: oPushResult
1059: oSetResult 10
1061: oPushResult
1062: oScopeCurrent
1063: oPushResult
1064: oNodeSet
1065: oPop 3
1067: oGetAddrLocal 6
1069: oPushResult
1070: oGetLocal 2
1072: oPushResult
1073: oSetResult 7
1075: oPushResult
1076: oNodeGetLabel
1077: oPop 2
1079: oAssign
1080: oSetResult 13
1082: oPushResult
1083: oGetLocal 6
1085: oPushResult
1086: oCall 212
1088: oPop 2
1090: oGetLocal 2
1092: oPushResult
1093: oSetResult 11
1095: oPushResult
1096: oSetResult 1
1098: oPushResult
1099: oNodeSetBoolean
1100: oPop 3
1102: oScopeEnd
1103: oScopeEnd
1104: oInput 4
1106: oReturn
1107: oLocalSpace 6
1109: oInputChoice 1330
1111: oGetAddrLocal 1
1113: oPushResult
1114: oNodeVecNew
1115: oAssign
1116: oGetAddrLocal 3
1118: oPushResult
1119: oSetResult 0
1121: oAssign
1122: oInputChoice 1132
1124: oGetAddrLocal 3
1126: oPushResult
1127: oSetResult 1
1129: oAssign
1130: oJumpForward 1135
1132: Choice Lookup Table
          32   1124
1135: oInput 0
1137: oGetAddrLocal 2
1139: oPushResult
1140: oSetResult 15
1142: oPushResult
1143: oSetResult 6
1145: oPushResult
1146: LAST_ID
1147: oPushResult
1148: oCall 5948
1150: oPop 3
1152: oAssign
1153: oGetLocal 2
1155: oPushResult
1156: oSetResult 19
1158: oPushResult
1159: oGetLocal 3
1161: oPushResult
1162: oNodeSetBoolean
1163: oPop 3
1165: oGetLocal 1
1167: oPushResult
1168: oGetLocal 2
1170: oPushResult
1171: oNodeVecAppend
1172: oPop 2
1174: oInputChoice 1182
1176: oJumpForward 1190
1178: oJumpForward 1188
1180: oJumpForward 1188
1182: Choice Lookup Table
          12   1180
          11   1176
1187: oEndChoice
1188: oJumpBack 1135
1190: oGetAddrLocal 4
1192: oPushResult
1193: oCall 1654
1195: oPop 1
1197: oGetLocal 3
1199: oChoice 1214
1201: oGetAddrLocal 5
1203: oPushResult
1204: oGetLocal 4
1206: oPushResult
1207: oCall 5976
1209: oPop 1
1211: oAssign
1212: oJumpForward 1223
1214: Choice Lookup Table
           1   1201
1217: oGetAddrLocal 5
1219: oPushResult
1220: oGetLocal 4
1222: oAssign
1223: oGetAddrLocal 6
1225: oPushResult
1226: oSetResult 0
1228: oAssign
1229: oGetLocal 6
1231: oPushResult
1232: oGetLocal 1
1234: oPushResult
1235: oNodeVecSize
1236: oPop 1
1238: oPushResult
1239: equal
1240: oPop 2
1242: oChoice 1299
1244: oGetAddrLocal 2
1246: oPushResult
1247: oGetLocal 1
1249: oPushResult
1250: oGetLocal 6
1252: oPushResult
1253: oNodeVecElement
1254: oPop 2
1256: oAssign
1257: oGetLocal 2
1259: oPushResult
1260: oSetResult 6
1262: oPushResult
1263: oGetLocal 4
1265: oPushResult
1266: oNodeSet
1267: oPop 3
1269: oGetLocal 2
1271: oPushResult
1272: oScopeDeclare
1273: oPop 1
1275: oGetLocal 2
1277: oPushResult
1278: oSetResult 7
1280: oPushResult
1281: oGetLocal 5
1283: oPushResult
1284: oScopeAllocType
1285: oPop 1
1287: oPushResult
1288: oNodeSetInt
1289: oPop 3
1291: oGetAddrLocal 6
1293: oPushResult
1294: inc
1295: oPop 1
1297: oJumpForward 1304
1299: Choice Lookup Table
           0   1244
1302: oJumpForward 1306
1304: oJumpBack 1229
1306: oGetLocal 1
1308: oPushResult
1309: oNodeVecDelete
1310: oPop 1
1312: oInputChoice 1320
1314: oJumpForward 1328
1316: oJumpForward 1326
1318: oJumpForward 1326
1320: Choice Lookup Table
           4   1318
          14   1314
1325: oEndChoice
1326: oJumpBack 1111
1328: oJumpForward 1333
1330: Choice Lookup Table
          13   1111
1333: oReturn
1334: oLocalSpace 2
1336: oInputChoice 1398
1338: oGetAddrLocal 1
1340: oPushResult
1341: oSetResult 9
1343: oPushResult
1344: oSetResult 4
1346: oPushResult
1347: LAST_ID
1348: oPushResult
1349: oCall 5948
1351: oPop 3
1353: oAssign
1354: oInput 5
1356: oCall 2123
1358: oGetAddrLocal 2
1360: oPushResult
1361: oValueTop
1362: oAssign
1363: oValuePop
1364: oGetLocal 1
1366: oPushResult
1367: oSetResult 7
1369: oPushResult
1370: oGetLocal 2
1372: oPushResult
1373: oNodeSetInt
1374: oPop 3
1376: oGetLocal 1
1378: oPushResult
1379: oSetResult 6
1381: oPushResult
1382: oGetGlobal 3
1384: oPushResult
1385: oNodeSet
1386: oPop 3
1388: oGetLocal 1
1390: oPushResult
1391: oScopeDeclare
1392: oPop 1
1394: oInput 4
1396: oJumpForward 1403
1398: Choice Lookup Table
           0   1338
1401: oJumpForward 1405
1403: oJumpBack 1336
1405: oReturn
1406: oLocalSpace 2
1408: oInputChoice 1457
1410: oGetAddrLocal 1
1412: oPushResult
1413: oSetResult 10
1415: oPushResult
1416: oSetResult 5
1418: oPushResult
1419: LAST_ID
1420: oPushResult
1421: oCall 5948
1423: oPop 3
1425: oAssign
1426: oInput 5
1428: oGetAddrLocal 2
1430: oPushResult
1431: oCall 1654
1433: oPop 1
1435: oGetLocal 1
1437: oPushResult
1438: oSetResult 6
1440: oPushResult
1441: oGetLocal 2
1443: oPushResult
1444: oNodeSet
1445: oPop 3
1447: oGetLocal 1
1449: oPushResult
1450: oScopeDeclare
1451: oPop 1
1453: oInput 4
1455: oJumpForward 1462
1457: Choice Lookup Table
           0   1410
1460: oJumpForward 1464
1462: oJumpBack 1408
1464: oReturn
1465: oLocalSpace 5
1467: oInputChoice 1646
1469: oGetAddrLocal 1
1471: oPushResult
1472: oNodeVecNew
1473: oAssign
1474: oGetAddrLocal 2
1476: oPushResult
1477: oGetParam 1
1479: oPushResult
1480: oSetResult 6
1482: oPushResult
1483: LAST_ID
1484: oPushResult
1485: oCall 5948
1487: oPop 3
1489: oAssign
1490: oGetLocal 1
1492: oPushResult
1493: oGetLocal 2
1495: oPushResult
1496: oNodeVecAppend
1497: oPop 2
1499: oInputChoice 1505
1501: oInput 0
1503: oJumpForward 1510
1505: Choice Lookup Table
          12   1501
1508: oJumpForward 1512
1510: oJumpBack 1474
1512: oInput 11
1514: oGetAddrLocal 3
1516: oPushResult
1517: oCall 1654
1519: oPop 1
1521: oGetAddrLocal 4
1523: oPushResult
1524: oSetResult 0
1526: oAssign
1527: oGetLocal 4
1529: oPushResult
1530: oGetLocal 1
1532: oPushResult
1533: oNodeVecSize
1534: oPop 1
1536: oPushResult
1537: equal
1538: oPop 2
1540: oChoice 1581
1542: oGetAddrLocal 2
1544: oPushResult
1545: oGetLocal 1
1547: oPushResult
1548: oGetLocal 4
1550: oPushResult
1551: oNodeVecElement
1552: oPop 2
1554: oAssign
1555: oGetLocal 2
1557: oPushResult
1558: oSetResult 6
1560: oPushResult
1561: oGetLocal 3
1563: oPushResult
1564: oNodeSet
1565: oPop 3
1567: oGetLocal 2
1569: oPushResult
1570: oScopeDeclareAlloc
1571: oPop 1
1573: oGetAddrLocal 4
1575: oPushResult
1576: inc
1577: oPop 1
1579: oJumpForward 1586
1581: Choice Lookup Table
           0   1542
1584: oJumpForward 1588
1586: oJumpBack 1527
1588: oInputChoice 1633
1590: oGetLocal 1
1592: oPushResult
1593: oNodeVecSize
1594: oPop 1
1596: oChoice 1600
1598: oJumpForward 1605
1600: Choice Lookup Table
           1   1598
1603: oError 22
1605: oGetAddrLocal 5
1607: oPushResult
1608: oCall 384
1610: oAssign
1611: oGetLocal 5
1613: oPushResult
1614: oCodePush
1615: oPop 1
1617: oGetLocal 2
1619: oPushResult
1620: oCall 5153
1622: oPop 1
1624: oCall 2189
1626: oCall 5834
1628: oCall 4947
1630: oCodePop
1631: oJumpForward 1636
1633: Choice Lookup Table
           5   1590
1636: oGetLocal 1
1638: oPushResult
1639: oNodeVecDelete
1640: oPop 1
1642: oInput 4
1644: oJumpForward 1651
1646: Choice Lookup Table
           0   1469
1649: oJumpForward 1653
1651: oJumpBack 1467
1653: oReturn
1654: oLocalSpace 12
1656: oInputChoice 2105
1658: oGetAddrLocal 1
1660: oPushResult
1661: oScopeFindRequire
1662: oAssign
1663: oGetLocal 1
1665: oPushResult
1666: oNodeType
1667: oPop 1
1669: oChoice 1686
1671: oGetParam 1
1673: oPushResult
1674: oGetLocal 1
1676: oPushResult
1677: oSetResult 6
1679: oPushResult
1680: oNodeGet
1681: oPop 2
1683: oAssign
1684: oJumpForward 1697
1686: Choice Lookup Table
          10   1671
1689: oError 2
1691: oGetParam 1
1693: oPushResult
1694: oGetGlobal 3
1696: oAssign
1697: oJumpForward 2122
1699: oInput 15
1701: oGetAddrLocal 2
1703: oPushResult
1704: oNodeVecNew
1705: oAssign
1706: oGetAddrLocal 3
1708: oPushResult
1709: oSetResult 25
1711: oPushResult
1712: oNodeNew
1713: oPop 1
1715: oAssign
1716: oGetLocal 3
1718: oPushResult
1719: oSetResult 21
1721: oPushResult
1722: oGetGlobal 3
1724: oPushResult
1725: oNodeSet
1726: oPop 3
1728: oCall 2123
1730: oGetLocal 3
1732: oPushResult
1733: oSetResult 23
1735: oPushResult
1736: oValueTop
1737: oPushResult
1738: oNodeSetInt
1739: oPop 3
1741: oValuePop
1742: oInput 20
1744: oCall 2123
1746: oGetLocal 3
1748: oPushResult
1749: oSetResult 24
1751: oPushResult
1752: oValueTop
1753: oPushResult
1754: oNodeSetInt
1755: oPop 3
1757: oValuePop
1758: oGetLocal 3
1760: oPushResult
1761: oSetResult 2
1763: oPushResult
1764: oSetResult 4
1766: oPushResult
1767: oNodeSetInt
1768: oPop 3
1770: oGetLocal 3
1772: oPushResult
1773: oTypeAdd
1774: oPop 1
1776: oGetAddrLocal 4
1778: oPushResult
1779: oSetResult 24
1781: oPushResult
1782: oNodeNew
1783: oPop 1
1785: oAssign
1786: oGetLocal 4
1788: oPushResult
1789: oSetResult 22
1791: oPushResult
1792: oGetLocal 3
1794: oPushResult
1795: oNodeSet
1796: oPop 3
1798: oGetLocal 2
1800: oPushResult
1801: oGetLocal 4
1803: oPushResult
1804: oNodeVecAppend
1805: oPop 2
1807: oInputChoice 1815
1809: oJumpForward 1823
1811: oJumpForward 1821
1813: oJumpForward 1821
1815: Choice Lookup Table
          12   1813
          16   1809
1820: oEndChoice
1821: oJumpBack 1706
1823: oInput 38
1825: oGetAddrLocal 5
1827: oPushResult
1828: oCall 1654
1830: oPop 1
1832: oGetAddrLocal 6
1834: oPushResult
1835: oGetLocal 2
1837: oPushResult
1838: oNodeVecSize
1839: oPop 1
1841: oAssign
1842: oGetAddrLocal 6
1844: oPushResult
1845: dec
1846: oPop 1
1848: oGetAddrLocal 7
1850: oPushResult
1851: oGetLocal 2
1853: oPushResult
1854: oGetLocal 6
1856: oPushResult
1857: oNodeVecElement
1858: oPop 2
1860: oAssign
1861: oGetLocal 7
1863: oPushResult
1864: oSetResult 21
1866: oPushResult
1867: oGetLocal 5
1869: oPushResult
1870: oNodeSet
1871: oPop 3
1873: oGetAddrLocal 8
1875: oPushResult
1876: oGetLocal 7
1878: oPushResult
1879: oSetResult 22
1881: oPushResult
1882: oNodeGet
1883: oPop 2
1885: oAssign
1886: oGetAddrLocal 9
1888: oPushResult
1889: oGetLocal 8
1891: oPushResult
1892: oSetResult 24
1894: oPushResult
1895: oNodeGetInt
1896: oPop 2
1898: oPushResult
1899: oGetLocal 8
1901: oPushResult
1902: oSetResult 23
1904: oPushResult
1905: oNodeGetInt
1906: oPop 2
1908: oPushResult
1909: subtract
1910: oPop 2
1912: oAssign
1913: oGetAddrLocal 9
1915: oPushResult
1916: inc
1917: oPop 1
1919: oGetLocal 7
1921: oPushResult
1922: oSetResult 2
1924: oPushResult
1925: oGetLocal 9
1927: oPushResult
1928: oGetLocal 5
1930: oPushResult
1931: oSetResult 2
1933: oPushResult
1934: oNodeGetInt
1935: oPop 2
1937: oPushResult
1938: multiply
1939: oPop 2
1941: oPushResult
1942: oNodeSetInt
1943: oPop 3
1945: oGetLocal 7
1947: oPushResult
1948: oTypeAdd
1949: oPop 1
1951: oGetAddrLocal 5
1953: oPushResult
1954: oGetLocal 7
1956: oAssign
1957: oGetLocal 6
1959: oPushResult
1960: equal_zero
1961: oPop 1
1963: oChoice 1969
1965: oJumpForward 1974
1967: oJumpForward 1972
1969: Choice Lookup Table
           1   1965
1972: oJumpBack 1842
1974: oGetParam 1
1976: oPushResult
1977: oGetLocal 2
1979: oPushResult
1980: oSetResult 0
1982: oPushResult
1983: oNodeVecElement
1984: oPop 2
1986: oAssign
1987: oGetLocal 2
1989: oPushResult
1990: oNodeVecDelete
1991: oPop 1
1993: oJumpForward 2122
1995: oGetAddrLocal 10
1997: oPushResult
1998: oCall 1654
2000: oPop 1
2002: oGetParam 1
2004: oPushResult
2005: oGetLocal 10
2007: oPushResult
2008: oCall 5976
2010: oPop 1
2012: oAssign
2013: oJumpForward 2122
2015: oGetParam 1
2017: oPushResult
2018: oSetResult 26
2020: oPushResult
2021: oNodeNew
2022: oPop 1
2024: oAssign
2025: oScopeBegin
2026: oSetResult 14
2028: oPushResult
2029: oCall 1465
2031: oPop 1
2033: oGetAddrLocal 11
2035: oPushResult
2036: oScopeCurrent
2037: oPushResult
2038: oSetResult 2
2040: oPushResult
2041: oNodeGetInt
2042: oPop 2
2044: oAssign
2045: oGetLocal 11
2047: oPushResult
2048: equal_zero
2049: oPop 1
2051: oChoice 2057
2053: oError 19
2055: oJumpForward 2060
2057: Choice Lookup Table
           1   2053
2060: oInput 34
2062: oGetFromParam 1
2064: oPushResult
2065: oSetResult 25
2067: oPushResult
2068: oScopeCurrent
2069: oPushResult
2070: oNodeSet
2071: oPop 3
2073: oGetFromParam 1
2075: oPushResult
2076: oSetResult 2
2078: oPushResult
2079: oGetLocal 11
2081: oPushResult
2082: oNodeSetInt
2083: oPop 3
2085: oScopeEnd
2086: oGetFromParam 1
2088: oPushResult
2089: oTypeAdd
2090: oPop 1
2092: oJumpForward 2122
2094: oInput 38
2096: oGetAddrLocal 12
2098: oPushResult
2099: oCall 1654
2101: oPop 1
2103: oJumpForward 2122
2105: Choice Lookup Table
          37   2094
          36   2015
          17   1995
          35   1699
           0   1658
2116: oCall 2123
2118: oInput 20
2120: oCall 2123
2122: oReturn
2123: oLocalSpace 1
2125: oInputChoice 2180
2127: TOKEN_VALUE
2128: oPushResult
2129: oValuePush
2130: oPop 1
2132: oJumpForward 2188
2134: oGetAddrLocal 1
2136: oPushResult
2137: oScopeFindRequire
2138: oAssign
2139: oGetLocal 1
2141: oPushResult
2142: oNodeType
2143: oPop 1
2145: oChoice 2162
2147: oGetLocal 1
2149: oPushResult
2150: oSetResult 7
2152: oPushResult
2153: oNodeGetInt
2154: oPop 2
2156: oPushResult
2157: oValuePush
2158: oPop 1
2160: oJumpForward 2173
2162: Choice Lookup Table
           9   2147
2165: oError 1
2167: oSetResult 0
2169: oPushResult
2170: oValuePush
2171: oPop 1
2173: oJumpForward 2188
2175: oCall 2123
2177: oValueNegate
2178: oJumpForward 2188
2180: Choice Lookup Table
          24   2175
           0   2134
           1   2127
2187: oEndChoice
2188: oReturn
2189: oLocalSpace 1
2191: oGetAddrLocal 1
2193: oPushResult
2194: oSetResult 0
2196: oAssign
2197: oGetAddrLocal 1
2199: oPushResult
2200: oCall 2350
2202: oPop 1
2204: oGetAddrLocal 1
2206: oPushResult
2207: oCall 2250
2209: oPop 1
2211: oReturn
2212: oLocalSpace 0
2214: oGetParam 1
2216: oPushResult
2217: oCall 2350
2219: oPop 1
2221: oTypeSNodeType
2222: oChoice 2241
2224: oJumpForward 2248
2226: oGetParam 1
2228: oPushResult
2229: oLabelNew
2230: oAssign
2231: oEmit 47
2233: oGetFromParam 1
2235: oPushResult
2236: oEmitLabel
2237: oPop 1
2239: oJumpForward 2248
2241: Choice Lookup Table
          19   2226
          20   2224
2246: oError 8
2248: oTypeSPop
2249: oReturn
2250: oLocalSpace 1
2252: oTypeSNodeType
2253: oChoice 2315
2255: oGetAddrLocal 1
2257: oPushResult
2258: oLabelNew
2259: oAssign
2260: oEmit 9
2262: oSetResult 1
2264: oPushResult
2265: oEmitInt
2266: oPop 1
2268: oEmit 45
2270: oGetLocal 1
2272: oPushResult
2273: oEmitLabel
2274: oPop 1
2276: oEmit 48
2278: oGetFromParam 1
2280: oPushResult
2281: oEmitLabel
2282: oPop 1
2284: oEmit 9
2286: oSetResult 0
2288: oPushResult
2289: oEmitInt
2290: oPop 1
2292: oEmit 48
2294: oGetLocal 1
2296: oPushResult
2297: oEmitLabel
2298: oPop 1
2300: oTypeSPop
2301: oGetGlobal 4
2303: oPushResult
2304: oTypeSPush
2305: oPop 1
2307: oGetParam 1
2309: oPushResult
2310: oSetResult 0
2312: oAssign
2313: oJumpForward 2318
2315: Choice Lookup Table
          20   2255
2318: oReturn
2319: oLocalSpace 0
2321: oTypeSNodeType
2322: oChoice 2346
2324: oGetParam 1
2326: oPushResult
2327: oLabelNew
2328: oAssign
2329: oEmit 47
2331: oGetFromParam 1
2333: oPushResult
2334: oEmitLabel
2335: oPop 1
2337: oTypeSPop
2338: oGetGlobal 5
2340: oPushResult
2341: oTypeSPush
2342: oPop 1
2344: oJumpForward 2349
2346: Choice Lookup Table
          19   2324
2349: oReturn
2350: oLocalSpace 0
2352: oGetParam 1
2354: oPushResult
2355: oCall 2715
2357: oPop 1
2359: oInputChoice 2697
2361: oGetParam 1
2363: oPushResult
2364: oCall 2250
2366: oPop 1
2368: oGetParam 1
2370: oPushResult
2371: oCall 2715
2373: oPop 1
2375: oGetParam 1
2377: oPushResult
2378: oCall 2250
2380: oPop 1
2382: oCall 5834
2384: oTypeSNodeType
2385: oChoice 2399
2387: oEmit 30
2389: oJumpForward 2412
2391: oEmit 36
2393: oJumpForward 2412
2395: oError 16
2397: oJumpForward 2412
2399: Choice Lookup Table
          22   2395
          21   2395
          23   2391
          19   2387
          18   2387
2410: oError 17
2412: oTypeSPop
2413: oGetGlobal 4
2415: oPushResult
2416: oTypeSPush
2417: oPop 1
2419: oJumpForward 2712
2421: oGetParam 1
2423: oPushResult
2424: oCall 2250
2426: oPop 1
2428: oGetParam 1
2430: oPushResult
2431: oCall 2715
2433: oPop 1
2435: oGetParam 1
2437: oPushResult
2438: oCall 2250
2440: oPop 1
2442: oCall 5834
2444: oTypeSNodeType
2445: oChoice 2459
2447: oEmit 31
2449: oJumpForward 2472
2451: oEmit 37
2453: oJumpForward 2472
2455: oError 16
2457: oJumpForward 2472
2459: Choice Lookup Table
          22   2455
          21   2455
          23   2451
          19   2447
          18   2447
2470: oError 17
2472: oTypeSPop
2473: oGetGlobal 4
2475: oPushResult
2476: oTypeSPush
2477: oPop 1
2479: oJumpForward 2712
2481: oGetParam 1
2483: oPushResult
2484: oCall 2250
2486: oPop 1
2488: oGetParam 1
2490: oPushResult
2491: oCall 2715
2493: oPop 1
2495: oGetParam 1
2497: oPushResult
2498: oCall 2250
2500: oPop 1
2502: oCall 5834
2504: oTypeSNodeType
2505: oChoice 2515
2507: oEmit 33
2509: oJumpForward 2526
2511: oError 16
2513: oJumpForward 2526
2515: Choice Lookup Table
          22   2511
          21   2511
          19   2507
          18   2507
2524: oError 17
2526: oTypeSPop
2527: oGetGlobal 4
2529: oPushResult
2530: oTypeSPush
2531: oPop 1
2533: oJumpForward 2712
2535: oGetParam 1
2537: oPushResult
2538: oCall 2250
2540: oPop 1
2542: oGetParam 1
2544: oPushResult
2545: oCall 2715
2547: oPop 1
2549: oGetParam 1
2551: oPushResult
2552: oCall 2250
2554: oPop 1
2556: oCall 5834
2558: oTypeSNodeType
2559: oChoice 2569
2561: oEmit 32
2563: oJumpForward 2580
2565: oError 16
2567: oJumpForward 2580
2569: Choice Lookup Table
          22   2565
          21   2565
          19   2561
          18   2561
2578: oError 17
2580: oTypeSPop
2581: oGetGlobal 4
2583: oPushResult
2584: oTypeSPush
2585: oPop 1
2587: oJumpForward 2712
2589: oGetParam 1
2591: oPushResult
2592: oCall 2250
2594: oPop 1
2596: oGetParam 1
2598: oPushResult
2599: oCall 2715
2601: oPop 1
2603: oGetParam 1
2605: oPushResult
2606: oCall 2250
2608: oPop 1
2610: oCall 5834
2612: oTypeSNodeType
2613: oChoice 2623
2615: oEmit 35
2617: oJumpForward 2634
2619: oError 16
2621: oJumpForward 2634
2623: Choice Lookup Table
          22   2619
          21   2619
          19   2615
          18   2615
2632: oError 17
2634: oTypeSPop
2635: oGetGlobal 4
2637: oPushResult
2638: oTypeSPush
2639: oPop 1
2641: oJumpForward 2712
2643: oGetParam 1
2645: oPushResult
2646: oCall 2250
2648: oPop 1
2650: oGetParam 1
2652: oPushResult
2653: oCall 2715
2655: oPop 1
2657: oGetParam 1
2659: oPushResult
2660: oCall 2250
2662: oPop 1
2664: oCall 5834
2666: oTypeSNodeType
2667: oChoice 2677
2669: oEmit 34
2671: oJumpForward 2688
2673: oError 16
2675: oJumpForward 2688
2677: Choice Lookup Table
          22   2673
          21   2673
          19   2669
          18   2669
2686: oError 17
2688: oTypeSPop
2689: oGetGlobal 4
2691: oPushResult
2692: oTypeSPush
2693: oPop 1
2695: oJumpForward 2712
2697: Choice Lookup Table
          10   2643
           9   2589
           8   2535
           7   2481
           6   2421
           5   2361
2710: oJumpForward 2714
2712: oJumpBack 2359
2714: oReturn
2715: oLocalSpace 1
2717: oGetAddrLocal 1
2719: oPushResult
2720: oSetResult 0
2722: oAssign
2723: oGetParam 1
2725: oPushResult
2726: oCall 2895
2728: oPop 1
2730: oInputChoice 2863
2732: oTypeSNodeType
2733: oChoice 2804
2735: oGetLocal 1
2737: oPushResult
2738: oSetResult 0
2740: oPushResult
2741: equal_label
2742: oPop 2
2744: oChoice 2753
2746: oGetAddrLocal 1
2748: oPushResult
2749: oLabelNew
2750: oAssign
2751: oJumpForward 2756
2753: Choice Lookup Table
           1   2746
2756: oEmit 45
2758: oGetLocal 1
2760: oPushResult
2761: oEmitLabel
2762: oPop 1
2764: oJumpForward 2811
2766: oGetParam 1
2768: oPushResult
2769: oCall 2319
2771: oPop 1
2773: oGetLocal 1
2775: oPushResult
2776: oSetResult 0
2778: oPushResult
2779: equal_label
2780: oPop 2
2782: oChoice 2791
2784: oGetAddrLocal 1
2786: oPushResult
2787: oLabelNew
2788: oAssign
2789: oJumpForward 2794
2791: Choice Lookup Table
           1   2784
2794: oEmit 45
2796: oGetLocal 1
2798: oPushResult
2799: oEmitLabel
2800: oPop 1
2802: oJumpForward 2811
2804: Choice Lookup Table
          19   2766
          20   2735
2809: oError 8
2811: oTypeSPop
2812: oEmit 48
2814: oGetFromParam 1
2816: oPushResult
2817: oEmitLabel
2818: oPop 1
2820: oGetParam 1
2822: oPushResult
2823: oSetResult 0
2825: oAssign
2826: oGetParam 1
2828: oPushResult
2829: oCall 2895
2831: oPop 1
2833: oTypeSNodeType
2834: oChoice 2847
2836: oJumpForward 2854
2838: oGetParam 1
2840: oPushResult
2841: oCall 2319
2843: oPop 1
2845: oJumpForward 2854
2847: Choice Lookup Table
          19   2838
          20   2836
2852: oError 8
2854: oTypeSPop
2855: oGetGlobal 5
2857: oPushResult
2858: oTypeSPush
2859: oPop 1
2861: oJumpForward 2868
2863: Choice Lookup Table
          52   2732
2866: oJumpForward 2870
2868: oJumpBack 2730
2870: oGetLocal 1
2872: oPushResult
2873: oSetResult 0
2875: oPushResult
2876: equal_label
2877: oPop 2
2879: oChoice 2891
2881: oEmit 48
2883: oGetLocal 1
2885: oPushResult
2886: oEmitLabel
2887: oPop 1
2889: oJumpForward 2894
2891: Choice Lookup Table
           0   2881
2894: oReturn
2895: oLocalSpace 2
2897: oGetAddrLocal 1
2899: oPushResult
2900: oSetResult 0
2902: oAssign
2903: oGetParam 1
2905: oPushResult
2906: oCall 3033
2908: oPop 1
2910: oInputChoice 3025
2912: oTypeSNodeType
2913: oChoice 2926
2915: oJumpForward 2933
2917: oGetParam 1
2919: oPushResult
2920: oCall 2319
2922: oPop 1
2924: oJumpForward 2933
2926: Choice Lookup Table
          19   2917
          20   2915
2931: oError 8
2933: oTypeSPop
2934: oGetLocal 1
2936: oPushResult
2937: oSetResult 0
2939: oPushResult
2940: equal_label
2941: oPop 2
2943: oChoice 2972
2945: oGetAddrLocal 1
2947: oPushResult
2948: oLabelNew
2949: oAssign
2950: oEmit 49
2952: oGetFromParam 1
2954: oPushResult
2955: oEmitLabel
2956: oPop 1
2958: oGetLocal 1
2960: oPushResult
2961: oEmitLabel
2962: oPop 1
2964: oGetParam 1
2966: oPushResult
2967: oGetLocal 1
2969: oAssign
2970: oJumpForward 2975
2972: Choice Lookup Table
           1   2945
2975: oGetAddrLocal 2
2977: oPushResult
2978: oSetResult 0
2980: oAssign
2981: oGetAddrLocal 2
2983: oPushResult
2984: oCall 3033
2986: oPop 1
2988: oTypeSNodeType
2989: oChoice 3002
2991: oJumpForward 3009
2993: oGetAddrLocal 2
2995: oPushResult
2996: oCall 2319
2998: oPop 1
3000: oJumpForward 3009
3002: Choice Lookup Table
          19   2993
          20   2991
3007: oError 8
3009: oEmit 49
3011: oGetLocal 2
3013: oPushResult
3014: oEmitLabel
3015: oPop 1
3017: oGetLocal 1
3019: oPushResult
3020: oEmitLabel
3021: oPop 1
3023: oJumpForward 3030
3025: Choice Lookup Table
          51   2912
3028: oJumpForward 3032
3030: oJumpBack 2910
3032: oReturn
3033: oLocalSpace 1
3035: oInputChoice 3089
3037: oGetAddrLocal 1
3039: oPushResult
3040: oSetResult 0
3042: oAssign
3043: oGetAddrLocal 1
3045: oPushResult
3046: oCall 3033
3048: oPop 1
3050: oTypeSNodeType
3051: oChoice 3080
3053: oGetParam 1
3055: oPushResult
3056: oLabelNew
3057: oAssign
3058: oEmit 45
3060: oGetFromParam 1
3062: oPushResult
3063: oEmitLabel
3064: oPop 1
3066: oEmit 48
3068: oGetLocal 1
3070: oPushResult
3071: oEmitLabel
3072: oPop 1
3074: oJumpForward 3087
3076: oEmit 29
3078: oJumpForward 3087
3080: Choice Lookup Table
          19   3076
          20   3053
3085: oError 8
3087: oJumpForward 3099
3089: Choice Lookup Table
          53   3037
3092: oGetParam 1
3094: oPushResult
3095: oCall 3100
3097: oPop 1
3099: oReturn
3100: oLocalSpace 0
3102: oGetParam 1
3104: oPushResult
3105: oCall 3151
3107: oPop 1
3109: oInputChoice 3141
3111: oCall 5860
3113: oGetParam 1
3115: oPushResult
3116: oCall 3151
3118: oPop 1
3120: oCall 5874
3122: oEmit 26
3124: oJumpForward 3148
3126: oCall 5860
3128: oGetParam 1
3130: oPushResult
3131: oCall 3151
3133: oPop 1
3135: oCall 5874
3137: oEmit 27
3139: oJumpForward 3148
3141: Choice Lookup Table
          24   3126
          23   3111
3146: oJumpForward 3150
3148: oJumpBack 3109
3150: oReturn
3151: oLocalSpace 0
3153: oGetParam 1
3155: oPushResult
3156: oCall 3202
3158: oPop 1
3160: oInputChoice 3192
3162: oCall 5860
3164: oGetParam 1
3166: oPushResult
3167: oCall 3202
3169: oPop 1
3171: oCall 5874
3173: oEmit 23
3175: oJumpForward 3199
3177: oCall 5860
3179: oGetParam 1
3181: oPushResult
3182: oCall 3202
3184: oPop 1
3186: oCall 5874
3188: oEmit 24
3190: oJumpForward 3199
3192: Choice Lookup Table
          22   3177
          21   3162
3197: oJumpForward 3201
3199: oJumpBack 3160
3201: oReturn
3202: oLocalSpace 0
3204: oInputChoice 3230
3206: oGetParam 1
3208: oPushResult
3209: oCall 3243
3211: oPop 1
3213: oCall 5874
3215: oJumpForward 3242
3217: oGetParam 1
3219: oPushResult
3220: oCall 3243
3222: oPop 1
3224: oCall 5874
3226: oEmit 28
3228: oJumpForward 3242
3230: Choice Lookup Table
          24   3217
          23   3206
3235: oGetParam 1
3237: oPushResult
3238: oCall 3243
3240: oPop 1
3242: oReturn
3243: oLocalSpace 6
3245: oInputChoice 3431
3247: oEmit 9
3249: TOKEN_VALUE
3250: oPushResult
3251: oEmitInt
3252: oPop 1
3254: oGetGlobal 3
3256: oPushResult
3257: oTypeSPush
3258: oPop 1
3260: oJumpForward 3450
3262: oGetParam 1
3264: oPushResult
3265: oCall 2350
3267: oPop 1
3269: oInput 14
3271: oJumpForward 3450
3273: oGetAddrLocal 1
3275: oPushResult
3276: CURRENT_STRLIT
3277: oPushResult
3278: oStringAllocLit
3279: oPop 1
3281: oAssign
3282: oEmit 10
3284: oGetLocal 1
3286: oPushResult
3287: oEmitInt
3288: oPop 1
3290: oGetGlobal 7
3292: oPushResult
3293: oTypeSPush
3294: oPop 1
3296: oJumpForward 3450
3298: oGetAddrLocal 2
3300: oPushResult
3301: oScopeFindRequire
3302: oAssign
3303: oGetLocal 2
3305: oPushResult
3306: oNodeType
3307: oPop 1
3309: oChoice 3371
3311: oGetLocal 2
3313: oPushResult
3314: oCall 4256
3316: oPop 1
3318: oJumpForward 3390
3320: oGetAddrLocal 3
3322: oPushResult
3323: oGetLocal 2
3325: oPushResult
3326: oSetResult 6
3328: oPushResult
3329: oNodeGet
3330: oPop 2
3332: oAssign
3333: oGetLocal 3
3335: oPushResult
3336: oTypeSPush
3337: oPop 1
3339: oTypeSNodeType
3340: oChoice 3353
3342: oEmit 9
3344: oGetLocal 2
3346: oPushResult
3347: oCall 6111
3349: oPop 1
3351: oJumpForward 3360
3353: Choice Lookup Table
          19   3342
          18   3342
3358: oError 16
3360: oJumpForward 3390
3362: oGetLocal 2
3364: oPushResult
3365: oCall 3451
3367: oPop 1
3369: oJumpForward 3390
3371: Choice Lookup Table
          15   3362
          13   3362
          12   3362
           9   3320
           8   3311
3382: oError 6
3384: oGetGlobal 3
3386: oPushResult
3387: oTypeSPush
3388: oPop 1
3390: oJumpForward 3450
3392: oInput 0
3394: oGetAddrLocal 4
3396: oPushResult
3397: oScopeFindRequire
3398: oAssign
3399: oGetLocal 4
3401: oPushResult
3402: oCall 5153
3404: oPop 1
3406: oGetAddrLocal 5
3408: oPushResult
3409: oTypeSTop
3410: oAssign
3411: oTypeSPop
3412: oGetAddrLocal 6
3414: oPushResult
3415: oGetLocal 5
3417: oPushResult
3418: oCall 5976
3420: oPop 1
3422: oAssign
3423: oGetLocal 6
3425: oPushResult
3426: oTypeSPush
3427: oPop 1
3429: oJumpForward 3450
3431: Choice Lookup Table
          18   3392
           0   3298
           2   3273
          13   3262
           1   3247
3442: oError 6
3444: oGetGlobal 3
3446: oPushResult
3447: oTypeSPush
3448: oPop 1
3450: oReturn
3451: oLocalSpace 1
3453: oGetAddrLocal 1
3455: oPushResult
3456: oGetParam 1
3458: oPushResult
3459: oSetResult 6
3461: oPushResult
3462: oNodeGet
3463: oPop 2
3465: oAssign
3466: oGetLocal 1
3468: oPushResult
3469: oTypeSPush
3470: oPop 1
3472: oTypeSNodeType
3473: oChoice 3738
3475: oGetParam 1
3477: oPushResult
3478: oNodeType
3479: oPop 1
3481: oChoice 3543
3483: oEmit 0
3485: oGetParam 1
3487: oPushResult
3488: oCall 6111
3490: oPop 1
3492: oJumpForward 3551
3494: oEmit 3
3496: oGetParam 1
3498: oPushResult
3499: oCall 6111
3501: oPop 1
3503: oJumpForward 3551
3505: oGetParam 1
3507: oPushResult
3508: oSetResult 19
3510: oPushResult
3511: oNodeGetBoolean
3512: oPop 2
3514: oChoice 3529
3516: oEmit 8
3518: oGetParam 1
3520: oPushResult
3521: oCall 6111
3523: oPop 1
3525: oEmit 14
3527: oJumpForward 3541
3529: Choice Lookup Table
           1   3516
3532: oEmit 6
3534: oGetParam 1
3536: oPushResult
3537: oCall 6111
3539: oPop 1
3541: oJumpForward 3551
3543: Choice Lookup Table
          15   3505
          13   3494
          12   3483
3550: oEndChoice
3551: oJumpForward 3829
3553: oGetParam 1
3555: oPushResult
3556: oNodeType
3557: oPop 1
3559: oChoice 3621
3561: oEmit 1
3563: oGetParam 1
3565: oPushResult
3566: oCall 6111
3568: oPop 1
3570: oJumpForward 3629
3572: oEmit 4
3574: oGetParam 1
3576: oPushResult
3577: oCall 6111
3579: oPop 1
3581: oJumpForward 3629
3583: oGetParam 1
3585: oPushResult
3586: oSetResult 19
3588: oPushResult
3589: oNodeGetBoolean
3590: oPop 2
3592: oChoice 3607
3594: oEmit 8
3596: oGetParam 1
3598: oPushResult
3599: oCall 6111
3601: oPop 1
3603: oEmit 15
3605: oJumpForward 3619
3607: Choice Lookup Table
           1   3594
3610: oEmit 7
3612: oGetParam 1
3614: oPushResult
3615: oCall 6111
3617: oPop 1
3619: oJumpForward 3629
3621: Choice Lookup Table
          15   3583
          13   3572
          12   3561
3628: oEndChoice
3629: oJumpForward 3829
3631: oError 16
3633: oJumpForward 3829
3635: oGetParam 1
3637: oPushResult
3638: oNodeType
3639: oPop 1
3641: oChoice 3703
3643: oEmit 2
3645: oGetParam 1
3647: oPushResult
3648: oCall 6111
3650: oPop 1
3652: oJumpForward 3711
3654: oEmit 5
3656: oGetParam 1
3658: oPushResult
3659: oCall 6111
3661: oPop 1
3663: oJumpForward 3711
3665: oGetParam 1
3667: oPushResult
3668: oSetResult 19
3670: oPushResult
3671: oNodeGetBoolean
3672: oPop 2
3674: oChoice 3689
3676: oEmit 8
3678: oGetParam 1
3680: oPushResult
3681: oCall 6111
3683: oPop 1
3685: oEmit 16
3687: oJumpForward 3701
3689: Choice Lookup Table
           1   3676
3692: oEmit 8
3694: oGetParam 1
3696: oPushResult
3697: oCall 6111
3699: oPop 1
3701: oJumpForward 3711
3703: Choice Lookup Table
          15   3665
          13   3654
          12   3643
3710: oEndChoice
3711: oInputChoice 3733
3713: oTypeSPop
3714: oGetLocal 1
3716: oPushResult
3717: oSetResult 21
3719: oPushResult
3720: oNodeGet
3721: oPop 2
3723: oPushResult
3724: oTypeSPush
3725: oPop 1
3727: oCall 3865
3729: oCall 3830
3731: oJumpForward 3736
3733: Choice Lookup Table
          17   3713
3736: oJumpForward 3829
3738: Choice Lookup Table
          23   3635
          17   3631
          22   3631
          21   3631
          19   3553
          18   3475
3751: oGetParam 1
3753: oPushResult
3754: oNodeType
3755: oPop 1
3757: oChoice 3817
3759: oEmit 10
3761: oGetParam 1
3763: oPushResult
3764: oCall 6111
3766: oPop 1
3768: oJumpForward 3825
3770: oEmit 11
3772: oGetParam 1
3774: oPushResult
3775: oCall 6111
3777: oPop 1
3779: oJumpForward 3825
3781: oGetParam 1
3783: oPushResult
3784: oSetResult 19
3786: oPushResult
3787: oNodeGetBoolean
3788: oPop 2
3790: oChoice 3803
3792: oEmit 8
3794: oGetParam 1
3796: oPushResult
3797: oCall 6111
3799: oPop 1
3801: oJumpForward 3815
3803: Choice Lookup Table
           1   3792
3806: oEmit 12
3808: oGetParam 1
3810: oPushResult
3811: oCall 6111
3813: oPop 1
3815: oJumpForward 3825
3817: Choice Lookup Table
          15   3781
          13   3770
          12   3759
3824: oEndChoice
3825: oCall 3865
3827: oCall 3830
3829: oReturn
3830: oLocalSpace 0
3832: oTypeSNodeType
3833: oChoice 3851
3835: oEmit 14
3837: oJumpForward 3864
3839: oEmit 15
3841: oJumpForward 3864
3843: oError 16
3845: oJumpForward 3864
3847: oEmit 16
3849: oJumpForward 3864
3851: Choice Lookup Table
          23   3847
          17   3843
          22   3843
          21   3843
          19   3839
          18   3835
3864: oReturn
3865: oLocalSpace 0
3867: oInputChoice 3881
3869: oCall 3893
3871: oJumpForward 3890
3873: oCall 4036
3875: oJumpForward 3890
3877: oCall 4134
3879: oJumpForward 3890
3881: Choice Lookup Table
          17   3877
          19   3873
          15   3869
3888: oJumpForward 3892
3890: oJumpBack 3867
3892: oReturn
3893: oLocalSpace 3
3895: oTypeSNodeType
3896: oChoice 3900
3898: oJumpForward 3905
3900: Choice Lookup Table
          24   3898
3903: oError 10
3905: oTypeSNodeType
3906: oChoice 3910
3908: oJumpForward 3915
3910: Choice Lookup Table
          24   3908
3913: oError 13
3915: oGetAddrLocal 1
3917: oPushResult
3918: oTypeSTop
3919: oPushResult
3920: oSetResult 22
3922: oPushResult
3923: oNodeGet
3924: oPop 2
3926: oPushResult
3927: oCall 6060
3929: oPop 1
3931: oAssign
3932: oGetAddrLocal 2
3934: oPushResult
3935: oTypeSTop
3936: oPushResult
3937: oSetResult 21
3939: oPushResult
3940: oNodeGet
3941: oPop 2
3943: oAssign
3944: oTypeSPop
3945: oGetLocal 2
3947: oPushResult
3948: oTypeSPush
3949: oPop 1
3951: oCall 2189
3953: oCall 5860
3955: oGetLocal 1
3957: oPushResult
3958: equal_zero
3959: oPop 1
3961: oChoice 3975
3963: oEmit 9
3965: oGetLocal 1
3967: oPushResult
3968: oEmitInt
3969: oPop 1
3971: oEmit 27
3973: oJumpForward 3978
3975: Choice Lookup Table
           0   3963
3978: oGetAddrLocal 3
3980: oPushResult
3981: oGetLocal 2
3983: oPushResult
3984: oSetResult 2
3986: oPushResult
3987: oNodeGetInt
3988: oPop 2
3990: oAssign
3991: oGetLocal 3
3993: oPushResult
3994: oSetResult 1
3996: oPushResult
3997: equal
3998: oPop 2
4000: oChoice 4014
4002: oEmit 9
4004: oGetLocal 3
4006: oPushResult
4007: oEmitInt
4008: oPop 1
4010: oEmit 23
4012: oJumpForward 4017
4014: Choice Lookup Table
           0   4002
4017: oEmit 25
4019: oInputChoice 4027
4021: oJumpForward 4035
4023: oJumpForward 4033
4025: oJumpForward 4033
4027: Choice Lookup Table
          12   4025
          16   4021
4032: oEndChoice
4033: oJumpBack 3905
4035: oReturn
4036: oLocalSpace 2
4038: oTypeSNodeType
4039: oChoice 4043
4041: oJumpForward 4048
4043: Choice Lookup Table
          26   4041
4046: oError 11
4048: oTypeSTop
4049: oPushResult
4050: oSetResult 25
4052: oPushResult
4053: oNodeGet
4054: oPop 2
4056: oPushResult
4057: oScopeEnter
4058: oPop 1
4060: oInput 0
4062: oGetAddrLocal 1
4064: oPushResult
4065: oScopeFindRequire
4066: oAssign
4067: oGetLocal 1
4069: oPushResult
4070: oNodeType
4071: oPop 1
4073: oChoice 4077
4075: oJumpForward 4082
4077: Choice Lookup Table
          14   4075
4080: oError 12
4082: oScopeEnd
4083: oGetAddrLocal 2
4085: oPushResult
4086: oGetLocal 1
4088: oPushResult
4089: oSetResult 7
4091: oPushResult
4092: oNodeGetInt
4093: oPop 2
4095: oAssign
4096: oGetLocal 2
4098: oPushResult
4099: equal_zero
4100: oPop 1
4102: oChoice 4116
4104: oEmit 9
4106: oGetLocal 2
4108: oPushResult
4109: oEmitInt
4110: oPop 1
4112: oEmit 25
4114: oJumpForward 4119
4116: Choice Lookup Table
           0   4104
4119: oTypeSPop
4120: oGetLocal 1
4122: oPushResult
4123: oSetResult 6
4125: oPushResult
4126: oNodeGet
4127: oPop 2
4129: oPushResult
4130: oTypeSPush
4131: oPop 1
4133: oReturn
4134: oLocalSpace 1
4136: oTypeSNodeType
4137: oChoice 4141
4139: oJumpForward 4146
4141: Choice Lookup Table
          23   4139
4144: oError 9
4146: oEmit 16
4148: oGetAddrLocal 1
4150: oPushResult
4151: oTypeSTop
4152: oAssign
4153: oTypeSPop
4154: oGetLocal 1
4156: oPushResult
4157: oSetResult 21
4159: oPushResult
4160: oNodeGet
4161: oPop 2
4163: oPushResult
4164: oTypeSPush
4165: oPop 1
4167: oReturn
4168: oLocalSpace 0
4170: oCall 5834
4172: oReturn
4173: oLocalSpace 2
4175: oGetAddrLocal 2
4177: oPushResult
4178: oGetParam 1
4180: oPushResult
4181: oSetResult 13
4183: oPushResult
4184: oNodeGetString
4185: oPop 2
4187: oAssign
4188: oGetLocal 2
4190: oPushResult
4191: oSetResult 0
4193: oPushResult
4194: equal_string
4195: oPop 2
4197: oChoice 4234
4199: oGetAddrLocal 1
4201: oPushResult
4202: oGetParam 1
4204: oPushResult
4205: oSetResult 5
4207: oPushResult
4208: oNodeGetInt
4209: oPop 2
4211: oPushResult
4212: ID_STRING
4213: oPop 1
4215: oPushResult
4216: oStringAllocLit
4217: oPop 1
4219: oAssign
4220: oJumpForward 4240
4222: oGetAddrLocal 1
4224: oPushResult
4225: oGetLocal 2
4227: oPushResult
4228: oStringAllocLit
4229: oPop 1
4231: oAssign
4232: oJumpForward 4240
4234: Choice Lookup Table
           0   4222
           1   4199
4239: oEndChoice
4240: oEmit 50
4242: oGetParam 1
4244: oPushResult
4245: oCall 6111
4247: oPop 1
4249: oGetLocal 1
4251: oPushResult
4252: oEmitInt
4253: oPop 1
4255: oReturn
4256: oLocalSpace 10
4258: oGetParam 1
4260: oPushResult
4261: oSetResult 12
4263: oPushResult
4264: oNodeGetBoolean
4265: oPop 2
4267: oChoice 4294
4269: oGetParam 1
4271: oPushResult
4272: oSetResult 15
4274: oPushResult
4275: oNodeGetBoolean
4276: oPop 2
4278: oChoice 4289
4280: oGetParam 1
4282: oPushResult
4283: oCall 4173
4285: oPop 1
4287: oJumpForward 4292
4289: Choice Lookup Table
           0   4280
4292: oJumpForward 4297
4294: Choice Lookup Table
           1   4269
4297: oGetParam 1
4299: oPushResult
4300: oSetResult 15
4302: oPushResult
4303: oSetResult 1
4305: oPushResult
4306: oNodeSetBoolean
4307: oPop 3
4309: oGetAddrLocal 1
4311: oPushResult
4312: oGetParam 1
4314: oPushResult
4315: oSetResult 14
4317: oPushResult
4318: oNodeGetBoolean
4319: oPop 2
4321: oAssign
4322: oGetAddrLocal 4
4324: oPushResult
4325: oGetParam 1
4327: oPushResult
4328: oNodeType
4329: oPop 1
4331: oPushResult
4332: oSetResult 8
4334: oPushResult
4335: equal_node_type
4336: oPop 2
4338: oAssign
4339: oGetLocal 4
4341: oChoice 4368
4343: oGetAddrLocal 2
4345: oPushResult
4346: oGetParam 1
4348: oPushResult
4349: oSetResult 6
4351: oPushResult
4352: oNodeGet
4353: oPop 2
4355: oAssign
4356: oGetAddrLocal 3
4358: oPushResult
4359: oGetLocal 2
4361: oPushResult
4362: oScopeAllocType
4363: oPop 1
4365: oAssign
4366: oJumpForward 4371
4368: Choice Lookup Table
           1   4343
4371: oGetAddrLocal 5
4373: oPushResult
4374: oGetParam 1
4376: oPushResult
4377: oSetResult 9
4379: oPushResult
4380: oNodeGet
4381: oPop 2
4383: oAssign
4384: oGetAddrLocal 6
4386: oPushResult
4387: oGetLocal 5
4389: oPushResult
4390: oSetResult 2
4392: oPushResult
4393: oNodeGetInt
4394: oPop 2
4396: oAssign
4397: oGetLocal 1
4399: oChoice 4421
4401: oEmit 39
4403: oGetLocal 6
4405: oPushResult
4406: oEmitInt
4407: oPop 1
4409: oJumpForward 4427
4411: oEmit 38
4413: oGetLocal 6
4415: oPushResult
4416: oEmitInt
4417: oPop 1
4419: oJumpForward 4427
4421: Choice Lookup Table
           0   4411
           1   4401
4426: oEndChoice
4427: oGetAddrLocal 7
4429: oPushResult
4430: oGetLocal 5
4432: oPushResult
4433: oSetResult 1
4435: oPushResult
4436: oNodeGetIter
4437: oPop 2
4439: oAssign
4440: oGetAddrLocal 8
4442: oPushResult
4443: oGetLocal 7
4445: oPushResult
4446: oNodeIterValue
4447: oPop 1
4449: oAssign
4450: oInputChoice 4629
4452: oGetLocal 8
4454: oPushResult
4455: oNodeNull
4456: oPop 1
4458: oChoice 4464
4460: oJumpForward 4625
4462: oJumpForward 4467
4464: Choice Lookup Table
           1   4460
4467: oGetAddrLocal 9
4469: oPushResult
4470: oGetLocal 8
4472: oPushResult
4473: oSetResult 7
4475: oPushResult
4476: oNodeGetInt
4477: oPop 2
4479: oAssign
4480: oEmit 13
4482: oGetLocal 9
4484: oPushResult
4485: oEmitInt
4486: oPop 1
4488: oGetLocal 8
4490: oPushResult
4491: oSetResult 6
4493: oPushResult
4494: oNodeGet
4495: oPop 2
4497: oPushResult
4498: oTypeSPush
4499: oPop 1
4501: oGetLocal 8
4503: oPushResult
4504: oSetResult 19
4506: oPushResult
4507: oNodeGetBoolean
4508: oPop 2
4510: oChoice 4578
4512: oCall 5117
4514: oCall 5834
4516: oEmit 19
4518: oJumpForward 4584
4520: oCall 2189
4522: oCall 4168
4524: oTypeSNodeType
4525: oChoice 4543
4527: oEmit 17
4529: oJumpForward 4576
4531: oEmit 18
4533: oJumpForward 4576
4535: oError 16
4537: oJumpForward 4576
4539: oEmit 19
4541: oJumpForward 4576
4543: Choice Lookup Table
          23   4539
          17   4535
          22   4535
          21   4535
          19   4531
          18   4527
4556: oGetAddrLocal 10
4558: oPushResult
4559: oTypeSTop
4560: oPushResult
4561: oSetResult 2
4563: oPushResult
4564: oNodeGetInt
4565: oPop 2
4567: oAssign
4568: oEmit 20
4570: oGetLocal 10
4572: oPushResult
4573: oEmitInt
4574: oPop 1
4576: oJumpForward 4584
4578: Choice Lookup Table
           0   4520
           1   4512
4583: oEndChoice
4584: oTypeSPop
4585: oGetAddrLocal 7
4587: oPushResult
4588: oNodeIterNext
4589: oPop 1
4591: oGetAddrLocal 8
4593: oPushResult
4594: oGetLocal 7
4596: oPushResult
4597: oNodeIterValue
4598: oPop 1
4600: oAssign
4601: oGetLocal 8
4603: oPushResult
4604: oNodeNull
4605: oPop 1
4607: oChoice 4615
4609: oJumpForward 4625
4611: oJumpForward 4621
4613: oJumpForward 4621
4615: Choice Lookup Table
           0   4613
           1   4609
4620: oEndChoice
4621: oInput 12
4623: oJumpBack 4452
4625: oInput 14
4627: oJumpForward 4632
4629: Choice Lookup Table
          13   4452
4632: oGetLocal 8
4634: oPushResult
4635: oNodeNull
4636: oPop 1
4638: oChoice 4644
4640: oError 15
4642: oJumpForward 4647
4644: Choice Lookup Table
           0   4640
4647: oGetLocal 4
4649: oChoice 4678
4651: oEmit 13
4653: oGetParam 1
4655: oPushResult
4656: oSetResult 18
4658: oPushResult
4659: oNodeGetInt
4660: oPop 2
4662: oPushResult
4663: oEmitInt
4664: oPop 1
4666: oEmit 11
4668: oGetLocal 3
4670: oPushResult
4671: oEmitInt
4672: oPop 1
4674: oEmit 19
4676: oJumpForward 4681
4678: Choice Lookup Table
           1   4651
4681: oGetLocal 1
4683: oChoice 4707
4685: oEmit 42
4687: oGetParam 1
4689: oPushResult
4690: oCall 6111
4692: oPop 1
4694: oJumpForward 4713
4696: oEmit 41
4698: oGetParam 1
4700: oPushResult
4701: oCall 6111
4703: oPop 1
4705: oJumpForward 4713
4707: Choice Lookup Table
           0   4696
           1   4685
4712: oEndChoice
4713: oGetLocal 4
4715: oChoice 4783
4717: oGetLocal 2
4719: oPushResult
4720: oTypeSPush
4721: oPop 1
4723: oTypeSNodeType
4724: oChoice 4760
4726: oEmit 3
4728: oGetLocal 3
4730: oPushResult
4731: oEmitInt
4732: oPop 1
4734: oJumpForward 4781
4736: oEmit 4
4738: oGetLocal 3
4740: oPushResult
4741: oEmitInt
4742: oPop 1
4744: oJumpForward 4781
4746: oError 16
4748: oJumpForward 4781
4750: oEmit 5
4752: oGetLocal 3
4754: oPushResult
4755: oEmitInt
4756: oPop 1
4758: oJumpForward 4781
4760: Choice Lookup Table
          23   4750
          17   4746
          22   4746
          21   4746
          19   4736
          18   4726
4773: oEmit 11
4775: oGetLocal 3
4777: oPushResult
4778: oEmitInt
4779: oPop 1
4781: oJumpForward 4786
4783: Choice Lookup Table
           1   4717
4786: oEmit 40
4788: oGetLocal 6
4790: oPushResult
4791: oEmitInt
4792: oPop 1
4794: oReturn
4795: oLocalSpace 0
4797: oInputChoice 4847
4799: oCall 5754
4801: oJumpForward 4872
4803: oCall 5761
4805: oJumpForward 4872
4807: oCall 5828
4809: oJumpForward 4872
4811: oCall 5831
4813: oJumpForward 4872
4815: oCall 5294
4817: oJumpForward 4872
4819: oCall 5614
4821: oJumpForward 4872
4823: oCall 5360
4825: oJumpForward 4872
4827: oCall 5534
4829: oJumpForward 4872
4831: oCall 5699
4833: oJumpForward 4872
4835: oCall 5667
4837: oJumpForward 4872
4839: oCall 5731
4841: oJumpForward 4872
4843: oCall 4873
4845: oJumpForward 4872
4847: Choice Lookup Table
           0   4843
          33   4839
          49   4835
          50   4831
          47   4827
          42   4823
          46   4819
          39   4815
          57   4811
          56   4807
          55   4803
          54   4799
4872: oReturn
4873: oLocalSpace 1
4875: oGetAddrLocal 1
4877: oPushResult
4878: oScopeFindRequire
4879: oAssign
4880: oGetLocal 1
4882: oPushResult
4883: oNodeType
4884: oPop 1
4886: oChoice 4915
4888: oGetLocal 1
4890: oPushResult
4891: oCall 4256
4893: oPop 1
4895: oJumpForward 4928
4897: oGetLocal 1
4899: oPushResult
4900: oCall 4929
4902: oPop 1
4904: oJumpForward 4928
4906: oGetLocal 1
4908: oPushResult
4909: oCall 5003
4911: oPop 1
4913: oJumpForward 4928
4915: Choice Lookup Table
           8   4906
          15   4897
          13   4897
          12   4897
           7   4888
4926: oError 0
4928: oReturn
4929: oLocalSpace 0
4931: oGetParam 1
4933: oPushResult
4934: oCall 5153
4936: oPop 1
4938: oInput 3
4940: oCall 2189
4942: oCall 5834
4944: oCall 4947
4946: oReturn
4947: oLocalSpace 1
4949: oTypeSNodeType
4950: oChoice 4968
4952: oEmit 17
4954: oJumpForward 5001
4956: oEmit 18
4958: oJumpForward 5001
4960: oError 16
4962: oJumpForward 5001
4964: oEmit 19
4966: oJumpForward 5001
4968: Choice Lookup Table
          23   4964
          17   4960
          22   4960
          21   4960
          19   4956
          18   4952
4981: oGetAddrLocal 1
4983: oPushResult
4984: oTypeSTop
4985: oPushResult
4986: oSetResult 2
4988: oPushResult
4989: oNodeGetInt
4990: oPop 2
4992: oAssign
4993: oEmit 20
4995: oGetLocal 1
4997: oPushResult
4998: oEmitInt
4999: oPop 1
5001: oTypeSPop
5002: oReturn
5003: oLocalSpace 1
5005: oGetParam 1
5007: oPushResult
5008: oSetResult 10
5010: oPushResult
5011: oNodeGet
5012: oPop 2
5014: oPushResult
5015: oScopeCurrent
5016: oPushResult
5017: oNodeEqual
5018: oPop 2
5020: oChoice 5026
5022: oError 20
5024: oJumpForward 5029
5026: Choice Lookup Table
           0   5022
5029: oEmit 8
5031: oGetParam 1
5033: oPushResult
5034: oSetResult 18
5036: oPushResult
5037: oNodeGetInt
5038: oPop 2
5040: oPushResult
5041: oEmitInt
5042: oPop 1
5044: oGetParam 1
5046: oPushResult
5047: oSetResult 6
5049: oPushResult
5050: oNodeGet
5051: oPop 2
5053: oPushResult
5054: oTypeSPush
5055: oPop 1
5057: oInput 3
5059: oCall 2189
5061: oCall 5834
5063: oTypeSNodeType
5064: oChoice 5082
5066: oEmit 17
5068: oJumpForward 5115
5070: oEmit 18
5072: oJumpForward 5115
5074: oError 16
5076: oJumpForward 5115
5078: oEmit 19
5080: oJumpForward 5115
5082: Choice Lookup Table
          23   5078
          17   5074
          22   5074
          21   5074
          19   5070
          18   5066
5095: oGetAddrLocal 1
5097: oPushResult
5098: oTypeSTop
5099: oPushResult
5100: oSetResult 2
5102: oPushResult
5103: oNodeGetInt
5104: oPop 2
5106: oAssign
5107: oEmit 20
5109: oGetLocal 1
5111: oPushResult
5112: oEmitInt
5113: oPop 1
5115: oTypeSPop
5116: oReturn
5117: oLocalSpace 1
5119: oInput 0
5121: oGetAddrLocal 1
5123: oPushResult
5124: oScopeFindRequire
5125: oAssign
5126: oGetLocal 1
5128: oPushResult
5129: oNodeType
5130: oPop 1
5132: oChoice 5136
5134: oJumpForward 5145
5136: Choice Lookup Table
          15   5134
          13   5134
          12   5134
5143: oError 4
5145: oGetLocal 1
5147: oPushResult
5148: oCall 5153
5150: oPop 1
5152: oReturn
5153: oLocalSpace 0
5155: oGetParam 1
5157: oPushResult
5158: oNodeType
5159: oPop 1
5161: oChoice 5221
5163: oEmit 10
5165: oGetParam 1
5167: oPushResult
5168: oCall 6111
5170: oPop 1
5172: oJumpForward 5230
5174: oEmit 11
5176: oGetParam 1
5178: oPushResult
5179: oCall 6111
5181: oPop 1
5183: oJumpForward 5230
5185: oGetParam 1
5187: oPushResult
5188: oSetResult 19
5190: oPushResult
5191: oNodeGetBoolean
5192: oPop 2
5194: oChoice 5207
5196: oEmit 8
5198: oGetParam 1
5200: oPushResult
5201: oCall 6111
5203: oPop 1
5205: oJumpForward 5219
5207: Choice Lookup Table
           1   5196
5210: oEmit 12
5212: oGetParam 1
5214: oPushResult
5215: oCall 6111
5217: oPop 1
5219: oJumpForward 5230
5221: Choice Lookup Table
          15   5185
          13   5174
          12   5163
5228: oError 4
5230: oGetParam 1
5232: oPushResult
5233: oSetResult 6
5235: oPushResult
5236: oNodeGet
5237: oPop 2
5239: oPushResult
5240: oTypeSPush
5241: oPop 1
5243: oCall 3865
5245: oReturn
5246: oLocalSpace 0
5248: oGetParam 1
5250: oPushResult
5251: oCall 5153
5253: oPop 1
5255: oCall 5860
5257: oGetParam 1
5259: oPushResult
5260: oCall 3451
5262: oPop 1
5264: oTypeSPop
5265: oEmit 21
5267: oEmit 17
5269: oReturn
5270: oLocalSpace 0
5272: oGetParam 1
5274: oPushResult
5275: oCall 5153
5277: oPop 1
5279: oCall 5860
5281: oGetParam 1
5283: oPushResult
5284: oCall 3451
5286: oPop 1
5288: oTypeSPop
5289: oEmit 22
5291: oEmit 17
5293: oReturn
5294: oLocalSpace 2
5296: oGetAddrLocal 1
5298: oPushResult
5299: oSetResult 0
5301: oAssign
5302: oGetAddrLocal 1
5304: oPushResult
5305: oCall 2212
5307: oPop 1
5309: oInput 40
5311: oCall 4795
5313: oInputChoice 5348
5315: oGetAddrLocal 2
5317: oPushResult
5318: oLabelNew
5319: oAssign
5320: oEmit 45
5322: oGetLocal 2
5324: oPushResult
5325: oEmitLabel
5326: oPop 1
5328: oEmit 48
5330: oGetLocal 1
5332: oPushResult
5333: oEmitLabel
5334: oPop 1
5336: oCall 4795
5338: oEmit 48
5340: oGetLocal 2
5342: oPushResult
5343: oEmitLabel
5344: oPop 1
5346: oJumpForward 5359
5348: Choice Lookup Table
          41   5315
5351: oEmit 48
5353: oGetLocal 1
5355: oPushResult
5356: oEmitLabel
5357: oPop 1
5359: oReturn
5360: oLocalSpace 4
5362: oInput 0
5364: oGetAddrLocal 1
5366: oPushResult
5367: oScopeFindRequire
5368: oAssign
5369: oGetLocal 1
5371: oPushResult
5372: oCall 5153
5374: oPop 1
5376: oCall 5860
5378: oInput 3
5380: oCall 2189
5382: oCall 5860
5384: oEmit 17
5386: oGetAddrLocal 2
5388: oPushResult
5389: oLabelNew
5390: oAssign
5391: oGetAddrLocal 3
5393: oPushResult
5394: oLabelNew
5395: oAssign
5396: oEmit 45
5398: oGetLocal 3
5400: oPushResult
5401: oEmitLabel
5402: oPop 1
5404: oGetAddrLocal 4
5406: oPushResult
5407: oLabelNew
5408: oAssign
5409: oEmit 48
5411: oGetLocal 4
5413: oPushResult
5414: oEmitLabel
5415: oPop 1
5417: oInputChoice 5497
5419: oGetLocal 1
5421: oPushResult
5422: oCall 5246
5424: oPop 1
5426: oEmit 48
5428: oGetLocal 3
5430: oPushResult
5431: oEmitLabel
5432: oPop 1
5434: oGetLocal 1
5436: oPushResult
5437: oCall 3451
5439: oPop 1
5441: oTypeSPop
5442: oCall 2189
5444: oCall 5860
5446: oEmit 32
5448: oEmit 46
5450: oGetLocal 2
5452: oPushResult
5453: oEmitLabel
5454: oPop 1
5456: oJumpForward 5503
5458: oGetLocal 1
5460: oPushResult
5461: oCall 5270
5463: oPop 1
5465: oEmit 48
5467: oGetLocal 3
5469: oPushResult
5470: oEmitLabel
5471: oPop 1
5473: oGetLocal 1
5475: oPushResult
5476: oCall 3451
5478: oPop 1
5480: oTypeSPop
5481: oCall 2189
5483: oCall 5860
5485: oEmit 33
5487: oEmit 46
5489: oGetLocal 2
5491: oPushResult
5492: oEmitLabel
5493: oPop 1
5495: oJumpForward 5503
5497: Choice Lookup Table
          44   5458
          43   5419
5502: oEndChoice
5503: oGetLocal 4
5505: oPushResult
5506: oGetLocal 2
5508: oPushResult
5509: oLoopPush
5510: oPop 2
5512: oInput 45
5514: oCall 4795
5516: oEmit 45
5518: oGetLocal 4
5520: oPushResult
5521: oEmitLabel
5522: oPop 1
5524: oEmit 48
5526: oGetLocal 2
5528: oPushResult
5529: oEmitLabel
5530: oPop 1
5532: oLoopPop
5533: oReturn
5534: oLocalSpace 3
5536: oGetAddrLocal 1
5538: oPushResult
5539: oLabelNew
5540: oAssign
5541: oEmit 48
5543: oGetLocal 1
5545: oPushResult
5546: oEmitLabel
5547: oPop 1
5549: oGetAddrLocal 2
5551: oPushResult
5552: oLabelNew
5553: oAssign
5554: oGetLocal 1
5556: oPushResult
5557: oGetLocal 2
5559: oPushResult
5560: oLoopPush
5561: oPop 2
5563: oCall 4795
5565: oInputChoice 5596
5567: oCall 4795
5569: oJumpForward 5602
5571: oGetAddrLocal 3
5573: oPushResult
5574: oCall 2212
5576: oPop 1
5578: oEmit 49
5580: oGetLocal 3
5582: oPushResult
5583: oEmitLabel
5584: oPop 1
5586: oGetLocal 1
5588: oPushResult
5589: oEmitLabel
5590: oPop 1
5592: oJumpForward 5604
5594: oJumpForward 5602
5596: Choice Lookup Table
          48   5571
           4   5567
5601: oEndChoice
5602: oJumpBack 5565
5604: oEmit 48
5606: oGetLocal 2
5608: oPushResult
5609: oEmitLabel
5610: oPop 1
5612: oLoopPop
5613: oReturn
5614: oLocalSpace 2
5616: oGetAddrLocal 1
5618: oPushResult
5619: oLabelNew
5620: oAssign
5621: oEmit 48
5623: oGetLocal 1
5625: oPushResult
5626: oEmitLabel
5627: oPop 1
5629: oGetAddrLocal 2
5631: oPushResult
5632: oCall 2212
5634: oPop 1
5636: oGetLocal 1
5638: oPushResult
5639: oGetLocal 2
5641: oPushResult
5642: oLoopPush
5643: oPop 2
5645: oInput 45
5647: oCall 4795
5649: oEmit 45
5651: oGetLocal 1
5653: oPushResult
5654: oEmitLabel
5655: oPop 1
5657: oEmit 48
5659: oGetLocal 2
5661: oPushResult
5662: oEmitLabel
5663: oPop 1
5665: oLoopPop
5666: oReturn
5667: oLocalSpace 0
5669: oLoopContinueLabel
5670: oPushResult
5671: oSetResult 0
5673: oPushResult
5674: equal_label
5675: oPop 2
5677: oChoice 5692
5679: oError 18
5681: oJumpForward 5698
5683: oEmit 45
5685: oLoopContinueLabel
5686: oPushResult
5687: oEmitLabel
5688: oPop 1
5690: oJumpForward 5698
5692: Choice Lookup Table
           0   5683
           1   5679
5697: oEndChoice
5698: oReturn
5699: oLocalSpace 0
5701: oLoopBreakLabel
5702: oPushResult
5703: oSetResult 0
5705: oPushResult
5706: equal_label
5707: oPop 2
5709: oChoice 5724
5711: oError 18
5713: oJumpForward 5730
5715: oEmit 45
5717: oLoopBreakLabel
5718: oPushResult
5719: oEmitLabel
5720: oPop 1
5722: oJumpForward 5730
5724: Choice Lookup Table
           0   5715
           1   5711
5729: oEndChoice
5730: oReturn
5731: oLocalSpace 0
5733: oCall 4795
5735: oInputChoice 5745
5737: oCall 4795
5739: oJumpForward 5751
5741: oJumpForward 5753
5743: oJumpForward 5751
5745: Choice Lookup Table
          34   5741
           4   5737
5750: oEndChoice
5751: oJumpBack 5735
5753: oReturn
5754: oLocalSpace 0
5756: oCall 5761
5758: oEmit 55
5760: oReturn
5761: oLocalSpace 0
5763: oInputChoice 5824
5765: oCall 2189
5767: oTypeSNodeType
5768: oChoice 5790
5770: oEmit 51
5772: oJumpForward 5805
5774: oEmit 52
5776: oJumpForward 5805
5778: oEmit 53
5780: oJumpForward 5805
5782: oError 16
5784: oJumpForward 5805
5786: oEmit 54
5788: oJumpForward 5805
5790: Choice Lookup Table
          23   5786
          17   5782
          21   5782
          22   5778
          19   5774
          18   5770
5803: oError 17
5805: oTypeSPop
5806: oInputChoice 5814
5808: oJumpForward 5822
5810: oJumpForward 5820
5812: oJumpForward 5820
5814: Choice Lookup Table
          12   5812
          14   5808
5819: oEndChoice
5820: oJumpBack 5765
5822: oJumpForward 5827
5824: Choice Lookup Table
          13   5765
5827: oReturn
5828: oLocalSpace 0
5830: oReturn
5831: oLocalSpace 0
5833: oReturn
5834: oLocalSpace 1
5836: oGetAddrLocal 1
5838: oPushResult
5839: oTypeSNodeType
5840: oAssign
5841: oTypeSPop
5842: oGetLocal 1
5844: oPushResult
5845: oTypeSNodeType
5846: oPushResult
5847: equal_node_type
5848: oPop 2
5850: oChoice 5856
5852: oError 14
5854: oJumpForward 5859
5856: Choice Lookup Table
           0   5852
5859: oReturn
5860: oLocalSpace 0
5862: oTypeSNodeType
5863: oChoice 5867
5865: oJumpForward 5872
5867: Choice Lookup Table
          18   5865
5870: oError 7
5872: oTypeSPop
5873: oReturn
5874: oLocalSpace 0
5876: oTypeSNodeType
5877: oChoice 5881
5879: oJumpForward 5886
5881: Choice Lookup Table
          18   5879
5884: oError 7
5886: oReturn
5887: oLocalSpace 0
5889: oTypeSNodeType
5890: oChoice 5894
5892: oJumpForward 5899
5894: Choice Lookup Table
          19   5892
5897: oError 8
5899: oTypeSPop
5900: oReturn
5901: oLocalSpace 0
5903: oTypeSNodeType
5904: oChoice 5908
5906: oJumpForward 5913
5908: Choice Lookup Table
          19   5906
5911: oError 8
5913: oReturn
5914: oLocalSpace 1
5916: oGetAddrLocal 1
5918: oPushResult
5919: oGetParam 2
5921: oPushResult
5922: oNodeNew
5923: oPop 1
5925: oAssign
5926: oGetLocal 1
5928: oPushResult
5929: oSetResult 2
5931: oPushResult
5932: oGetParam 1
5934: oPushResult
5935: oNodeSetInt
5936: oPop 3
5938: oGetLocal 1
5940: oPushResult
5941: oTypeAdd
5942: oPop 1
5944: oGetLocal 1
5946: oReturn
5947: oReturn
5948: oLocalSpace 1
5950: oGetAddrLocal 1
5952: oPushResult
5953: oGetParam 3
5955: oPushResult
5956: oNodeNew
5957: oPop 1
5959: oAssign
5960: oGetLocal 1
5962: oPushResult
5963: oSetResult 5
5965: oPushResult
5966: oGetParam 1
5968: oPushResult
5969: oNodeSetInt
5970: oPop 3
5972: oGetLocal 1
5974: oReturn
5975: oReturn
5976: oLocalSpace 1
5978: oGetAddrLocal 1
5980: oPushResult
5981: oGetParam 1
5983: oPushResult
5984: oSetResult 20
5986: oPushResult
5987: oNodeGet
5988: oPop 2
5990: oAssign
5991: oGetLocal 1
5993: oPushResult
5994: oNodeNull
5995: oPop 1
5997: oChoice 6053
5999: oGetAddrLocal 1
6001: oPushResult
6002: oSetResult 23
6004: oPushResult
6005: oNodeNew
6006: oPop 1
6008: oAssign
6009: oGetLocal 1
6011: oPushResult
6012: oSetResult 21
6014: oPushResult
6015: oGetParam 1
6017: oPushResult
6018: oNodeSet
6019: oPop 3
6021: oGetLocal 1
6023: oPushResult
6024: oSetResult 2
6026: oPushResult
6027: oSetResult 8
6029: oPushResult
6030: oNodeSetInt
6031: oPop 3
6033: oGetLocal 1
6035: oPushResult
6036: oTypeAdd
6037: oPop 1
6039: oGetParam 1
6041: oPushResult
6042: oSetResult 20
6044: oPushResult
6045: oGetLocal 1
6047: oPushResult
6048: oNodeSet
6049: oPop 3
6051: oJumpForward 6056
6053: Choice Lookup Table
           1   5999
6056: oGetLocal 1
6058: oReturn
6059: oReturn
6060: oLocalSpace 0
6062: oGetParam 1
6064: oPushResult
6065: oNodeType
6066: oPop 1
6068: oChoice 6096
6070: oMININT
6071: oReturn
6072: oJumpForward 6110
6074: oSetResult 0
6076: oReturn
6077: oJumpForward 6110
6079: oSetResult 0
6081: oReturn
6082: oJumpForward 6110
6084: oGetParam 1
6086: oPushResult
6087: oSetResult 23
6089: oPushResult
6090: oNodeGetInt
6091: oPop 2
6093: oReturn
6094: oJumpForward 6110
6096: Choice Lookup Table
          25   6084
          21   6079
          19   6074
          18   6070
6105: oError 3
6107: oSetResult 0
6109: oReturn
6110: oReturn
6111: oLocalSpace 0
6113: oGetParam 1
6115: oPushResult
6116: oSetResult 7
6118: oPushResult
6119: oNodeGetInt
6120: oPop 2
6122: oPushResult
6123: oEmitInt
6124: oPop 1
6126: oReturn
6127: oLocalSpace 1
6129: oGetAddrGlobal 2
6131: oPushResult
6132: oSetResult 17
6134: oPushResult
6135: oSetResult 4
6137: oPushResult
6138: oCall 5914
6140: oPop 2
6142: oAssign
6143: oGetAddrGlobal 3
6145: oPushResult
6146: oSetResult 18
6148: oPushResult
6149: oSetResult 4
6151: oPushResult
6152: oCall 5914
6154: oPop 2
6156: oAssign
6157: oGetAddrGlobal 4
6159: oPushResult
6160: oSetResult 19
6162: oPushResult
6163: oSetResult 1
6165: oPushResult
6166: oCall 5914
6168: oPop 2
6170: oAssign
6171: oGetAddrGlobal 5
6173: oPushResult
6174: oSetResult 20
6176: oPushResult
6177: oSetResult 1
6179: oPushResult
6180: oCall 5914
6182: oPop 2
6184: oAssign
6185: oGetAddrGlobal 6
6187: oPushResult
6188: oSetResult 21
6190: oPushResult
6191: oSetResult 1
6193: oPushResult
6194: oCall 5914
6196: oPop 2
6198: oAssign
6199: oGetAddrGlobal 7
6201: oPushResult
6202: oSetResult 22
6204: oPushResult
6205: oSetResult 256
6207: oPushResult
6208: oCall 5914
6210: oPop 2
6212: oAssign
6213: oGetAddrLocal 1
6215: oPushResult
6216: oSetResult 10
6218: oPushResult
6219: oSetResult 5
6221: oPushResult
6222: oIdAdd_File
6223: oPushResult
6224: oCall 5948
6226: oPop 3
6228: oAssign
6229: oGetLocal 1
6231: oPushResult
6232: oSetResult 6
6234: oPushResult
6235: oGetGlobal 2
6237: oPushResult
6238: oNodeSet
6239: oPop 3
6241: oGetLocal 1
6243: oPushResult
6244: oScopeDeclare
6245: oPop 1
6247: oGetAddrLocal 1
6249: oPushResult
6250: oSetResult 10
6252: oPushResult
6253: oSetResult 5
6255: oPushResult
6256: oIdAdd_Integer
6257: oPushResult
6258: oCall 5948
6260: oPop 3
6262: oAssign
6263: oGetLocal 1
6265: oPushResult
6266: oSetResult 6
6268: oPushResult
6269: oGetGlobal 3
6271: oPushResult
6272: oNodeSet
6273: oPop 3
6275: oGetLocal 1
6277: oPushResult
6278: oScopeDeclare
6279: oPop 1
6281: oGetAddrLocal 1
6283: oPushResult
6284: oSetResult 10
6286: oPushResult
6287: oSetResult 5
6289: oPushResult
6290: oIdAdd_Boolean
6291: oPushResult
6292: oCall 5948
6294: oPop 3
6296: oAssign
6297: oGetLocal 1
6299: oPushResult
6300: oSetResult 6
6302: oPushResult
6303: oGetGlobal 4
6305: oPushResult
6306: oNodeSet
6307: oPop 3
6309: oGetLocal 1
6311: oPushResult
6312: oScopeDeclare
6313: oPop 1
6315: oGetAddrLocal 1
6317: oPushResult
6318: oSetResult 10
6320: oPushResult
6321: oSetResult 5
6323: oPushResult
6324: oIdAdd_Char
6325: oPushResult
6326: oCall 5948
6328: oPop 3
6330: oAssign
6331: oGetLocal 1
6333: oPushResult
6334: oSetResult 6
6336: oPushResult
6337: oGetGlobal 6
6339: oPushResult
6340: oNodeSet
6341: oPop 3
6343: oGetLocal 1
6345: oPushResult
6346: oScopeDeclare
6347: oPop 1
6349: oGetAddrLocal 1
6351: oPushResult
6352: oSetResult 10
6354: oPushResult
6355: oSetResult 5
6357: oPushResult
6358: oIdAdd_String
6359: oPushResult
6360: oCall 5948
6362: oPop 3
6364: oAssign
6365: oGetLocal 1
6367: oPushResult
6368: oSetResult 6
6370: oPushResult
6371: oGetGlobal 7
6373: oPushResult
6374: oNodeSet
6375: oPop 3
6377: oGetLocal 1
6379: oPushResult
6380: oScopeDeclare
6381: oPop 1
6383: oGetAddrLocal 1
6385: oPushResult
6386: oSetResult 9
6388: oPushResult
6389: oSetResult 4
6391: oPushResult
6392: oIdAdd_True
6393: oPushResult
6394: oCall 5948
6396: oPop 3
6398: oAssign
6399: oGetLocal 1
6401: oPushResult
6402: oSetResult 6
6404: oPushResult
6405: oGetGlobal 4
6407: oPushResult
6408: oNodeSet
6409: oPop 3
6411: oGetLocal 1
6413: oPushResult
6414: oSetResult 7
6416: oPushResult
6417: oSetResult 1
6419: oPushResult
6420: oNodeSetInt
6421: oPop 3
6423: oGetLocal 1
6425: oPushResult
6426: oScopeDeclare
6427: oPop 1
6429: oGetAddrLocal 1
6431: oPushResult
6432: oSetResult 9
6434: oPushResult
6435: oSetResult 4
6437: oPushResult
6438: oIdAdd_False
6439: oPushResult
6440: oCall 5948
6442: oPop 3
6444: oAssign
6445: oGetLocal 1
6447: oPushResult
6448: oSetResult 6
6450: oPushResult
6451: oGetGlobal 4
6453: oPushResult
6454: oNodeSet
6455: oPop 3
6457: oGetLocal 1
6459: oPushResult
6460: oSetResult 7
6462: oPushResult
6463: oSetResult 0
6465: oPushResult
6466: oNodeSetInt
6467: oPop 3
6469: oGetLocal 1
6471: oPushResult
6472: oScopeDeclare
6473: oPop 1
6475: oReturn
