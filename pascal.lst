   2: title: 'Pascal Compiler 1.1.5 -- Jan 01 ''90';
         
      %
      %  Pascal.ssl
      %
      %  Pascal Compiler for the Amiga, by Steve Rice.
      %
      %  HISTORY
      %    11Sep89   First version, framework of parser.
      %    18Sep89   Added some semantic mechanisms.
      %    21Sep89   Added simple type references; expressions generate code.
      %    22Sep89   Allocate variable addresses as they're declared.
      %    24Sep89   Added arrays, pointers.
      %    27Sep89   Added for statement.
      %    23Oct89   Fixed for statement, so CYCLE goes to next step.
      %    01Jan90   Added string literals
      %    09Sep22   I have returned.  Migrate symbol table to schema, to ease development.
      %
      %  NOTES
      %    1) During a loop, the top counter counts the number of 'exit'
      %       statements to be patched.
      %    2) During a loop, the top entry in the patchLoop stack is the addr
      %       of the start of the loop (used by 'cycle' to repeat the loop).
      %    3) The 'value' of a var symbol is its allocated address.
      %    4) References to vars of intrinsic types, and pointer types,
      %       pushes the value of the var on the expr stack.  Referenecs to
      %       vars of compound types (arrays, records...) pushes the address
      %       on the expr stack.
      %    5) Just as there is only one type table entry for a given (named) type,
      %       there is only one type table entry for a pointer to a named type.
      %       When a pointer type is declared, a field in the TT entry of the
      %       type pointed to will be set to indicate the TT entry of the pointer
      %       to that type (0 means none defined yet).  When evaluating the
      %       expression ^x, the type in that field in the entry for the type of x
      %       will be used (unless it's 0, in which case a new TT entry will be
      %       created).
      %
      %
      %  MISSING
      %
      %    - Functions. 
      %      Caller allocates a temporary variable for the result.
      %      The params contain an extra hidden VAR parameter, i.e. passing in the temporary by reference.
      %      After the call, the caller pushes a reference to the temporary on the expression stack.
      %      (This would push a scalar value, or the addr of the temporary if a compound type.)
      %
      %    - VAR parameters need work, on caller side and reference side (lhs and rhs).
      %
      %    - Forward declaration of proceudres and functions.
      %      Only one forward declaration should be allowed.
      %      I will overwrite the nMethod info with the final addr and param names when the true body is seen.
      %      If a call is made to a foward declared method, add the forward decl node & Here to patch table.
      % 
      %    - procedure and function declarations may be nested within other procs/funcs!
      %      They are allowed to see locals within those parent scopes.
      %      Pass a hidden parameter to nested methods, to follow up to parent scopes as needed.
      %      Need a level counter at each scope, and uplevels count on reference to local/param.
      %      
      %    - Consider non-ISO extensions.  e.g. see "Units" e.g. from Turbo Pascal wikipedia page.
      %      Dynamic arrays.  Objects.  But, perhaps stick to my old goal, standard Pascal.
      %
      %    - x86 code generation.
      %
      %
      %  PASCAL DOCS
      %      Here's some handy language material:
      %      https://www.freepascal.org/docs-html/ref/ref.html
      %      https://www.freepascal.org/docs-html/prog/prog.html
      %      https://en.wikipedia.org/wiki/Turbo_Pascal
      %      https://en.wikipedia.org/wiki/Pascal_(programming_language)#Standards
      %
      
   2: input:
   2:    pIdent
   2:    pIntLit
   2:    pStrLit
   2:    pAssign       ':='
   2:    pSemiColon    ';'
   2:    pEqual        '='
   2:    pNotEqual     '<>'
   2:    pLess         '<'
   2:    pGreater      '>'
   2:    pLessEqual    '<='
   2:    pGreaterEqual '>='
   2:    pColon        ':'
   2:    pComma        ','
   2:    pLParen       '('
   2:    pRParen       ')'
   2:    pLSquare      '['
   2:    pRSquare      ']'
   2:    pCarat        '^'
   2:    pDot          '.'
   2:    pDotDot       '..'
   2:    pTimes        '*'
   2:    pDivide       '/'
   2:    pPlus         '+'
   2:    pMinus        '-'
   2:    pEof
   2:    pInvalid
      
      %  keywords  (built-in types 'integer', 'char', etc, are not keywords,
      %             type constructors 'array', 'record', 'set' are keywords,
      %             pseudo-procedures 'writeln', 'readln' are keywords)
      
   2:    pProgram
   2:    pProcedure
   2:    pFunction
   2:    pConst
   2:    pType
   2:    pVar
   2:    pBegin
   2:    pEnd
   2:    pArray
   2:    pRecord
   2:    pSet
   2:    pOf
   2:    pIf
   2:    pThen
   2:    pElse
   2:    pFor
   2:    pTo
   2:    pDownto
   2:    pDo
   2:    pWhile
   2:    pRepeat
   2:    pUntil
   2:    pCycle
   2:    pExit
   2:    pReturn
   2:    pAnd
   2:    pOr
   2:    pNot
   2:    pWriteln
   2:    pWrite
   2:    pReadln
   2:    pRead;
      
      
   2: output:
      
      %  Instructions for a stack machine (all vars are 32-bit integers)
      
   2:    tPushGlobalI      % <ptr> - push int value read from ptr
   2:    tPushGlobalB      % <ptr> - push byte value read from ptr
   2:    tPushGlobalP      % <ptr> - push ptr value read from ptr
   2:    tPushLocalI       % <offset> - push int value read from local var
   2:    tPushLocalB       % <offset> - push byte value read from local var
   2:    tPushLocalP       % <offset> - push ptr value read from local var
   2:    tPushParamI       % <offset> - push int value read from local var
   2:    tPushParamB       % <offset> - push byte value read from local var
   2:    tPushParamP       % <offset> - push ptr value read from local var
      
   2:    tPushConstI       % <int> - push int value on stack (NOTE, used for BOOLEAN too)
   2:    tPushConstP       % <ptr> - push constant ptr value
   2:    tPushAddrGlobal   % <offset> - push ptr to global var (same as tPushConstP)
   2:    tPushAddrLocal    % <offset> - push ptr to local var
   2:    tPushAddrParam    % <offset> - push ptr to formal param (used by method to see its param)
   2:    tPushAddrActual   % <offset> - push ptr to actual param, in actuals space (used by caller)
   2:    tFetchI           % pop ptr from stack, and push int value it points to
   2:    tFetchB           %    "      "      "     "     byte  "   "    "
   2:    tFetchP           %    "      "      "     "     ptr   "   "    "   
   2:    tAssignI          % assign int value on top of stack to addr under it (pop both)
   2:    tAssignB          %   "    byte   "    "   "  "   "    "    "   "   "
   2:    tAssignP          %   "    ptr    "    "   "  "   "    "    "   "   "
   2:    tCopy             % #words follows.  tos=src, 2nd=dest (pop 2)
   2:    tIncGlobalI       % <ptr> - increment int value pointed to by ptr
   2:    tDecGlobalI       % <ptr> - decrement int value pointed to by ptr
   2:    tMultI            % multiply top two integers (replacing with result)
   2:    tDivI
   2:    tAddI  
   2:    tSubI
   2:    tNegI             % top entry *= -1
   2:    tNot              % negate top boolean
   2:    tAnd              % boolean AND of top 2 (pop 2, push 1)
   2:    tOr               % boolean OR or top 2 (pop 2, push 1)
   2:    tEqualI           % top two entries equal? (pop 2, push 1) (true=1)
   2:    tNotEqualI        %    NOTE, these all work for booleans too
   2:    tGreaterI         % 2nd entry greater than top entry? (pop 2, push answer)
   2:    tLessI  
   2:    tGreaterEqualI
   2:    tLessEqualI
   2:    tEqualP           % two two pointer values equal? (pop 2, push 1) (true=1)
   2:    tNotEqualP
   2:    tAllocActuals     % <#bytes> - make space on call stack for actual params (adjusting call stack sp)
   2:    tFreeActuals      % <#bytes> - discard space on call stack allocated by tAllocActuals
   2:    tCall             % addr follows
   2:    tReturn
   2:    tEnter            % <#bytes> - start a stack frame on the call stack, reserving #bytes of local variable space
   2:    tJump             % addr follows
   2:    tJumpTrue         % addr follows  (pops top of stack, jumps if true)
   2:    tJumpFalse        % addr follows  (pops top of stack, jumps if false)
   2:    tWriteI           % for writeln : write integer on tos, pop
   2:    tWriteBool        %  "     "    : write TRUE/FALSE, pop
   2:    tWriteStr         %  "     "    : write string whose addr is on tos, pop
   2:    tWriteP           %  "     "    : write ptr var whose addr is on tos, pop
   2:    tWriteCR          %  "     "    : write cr
      
      %  Other:
      
   2:    tSpace            % emit a hole, to be patched later
   2:    ;
      
   2: error:
   2:    eBadStatement
   2:    eNotConst
   2:    eNotType
   2:    eNotOrdinalType
   2:    eNotVar
   2:    eNotIntVar
   2:    eNotValue
   2:    eNotInteger
   2:    eNotBoolean
   2:    eNotPointer
   2:    eNotArray
   2:    eNotRecord
   2:    eNotRecordField
   2:    eTooManySubscripts
   2:    eTypeMismatch
   2:    eMissingParameter
   2:    eNotImplemented
   2:    eNotAllowed
   2:    eNotInALoop
   2:    eRecordEmpty
   2:    eNotCurrentFunction
   2:    ;
      
   2: include 'pascal_schema.ssl'
      
      % Generated automatically by schema
      
   2: type node_type:
   2: 	nINVALID
   2: 	Object
   2: 	nScope
   2: 	nDeclaration
   2: 	nIdent
   2: 	nProgram
   2: 	nMethod
   2: 	nProc
   2: 	nFunc
   2: 	nConst
   2: 	nTypeDecl
   2: 	nVar
   2: 	nGlobalVar
   2: 	nLocalVar
   2: 	nRecordField
   2: 	nParam
   2: 	nType
   2: 	nFileType
   2: 	nIntegerType
   2: 	nBooleanType
   2: 	nCharType
   2: 	nStringType
   2: 	nPointerType
   2: 	nArrayType
   2: 	nSubrangeType
   2: 	nRecordType
   2: 	nEnumType
   2: 	nSetType
   2: 	;
      
   2: type node_attribute:
   2: 	qINVALID
   2: 	qDecls
   2: 	qSize
   2: 	qAllocDown
   2: 	qIdent
   2: 	qKind
   2: 	qType
   2: 	qParamType
   2: 	qValue
   2: 	qParams
   2: 	qChildScope
   2: 	qAddrDefined
   2: 	qResultOffset
   2: 	qInOut
   2: 	qPointerType
   2: 	qBaseType
   2: 	qIndexType
   2: 	qLow
   2: 	qHigh
   2: 	qScope
   2: 	;
      
      
   2: type Node:     % A pointer to a node in the schema database (symbol database)
   2:     Null = 0
   2:     ;
      
   2: type NodeVec:  % A pointer to a vector of Node.  See mechanism node_vec_mech
   2:     NullVec = 0
   2:     ;
      
   2: type boolean:
   2:    false    = 0
   2:    true     = 1;
      
   2: type kind:           % kind of identifier
   2:    kUndefined        % not yet added to symbol table
   2:    kProgram
   2:    kProc
   2:    kFunc
   2:    kConst
   2:    kType
   2:    kVar;
      
      % intrinsic types & type constructs
      
   2: type typ:
   2:    tyNone     = 0    % in ptrTyp field of TT, means no ptr to type defined
   2:    tyInteger
   2:    tyBoolean
   2:    tyChar
   2:    tyString
   2:    tyFile            % tyInteger..tyFile are scalars (types on their own)
   2:    tyPointer         % following are type constructor classes...
   2:    tyArray           %   (they are not type#'s)
   2:    tyRecord
   2:    tyParams          % like record; a collection of proc/func params
   2:    tySet;
      
      
      % Some general schema node operations.
      % node_type and node_attribute are defined in generated file pascal_schema.ssl included above.
      %
   2: mechanism node_mech:
   2:     oNodeNew (node_type) >> Node         % create new node
   2:     oNodeSet (Node, node_attribute, Node)   % set Node attribute of node
   2:     oNodeSetInt (Node, node_attribute, int) % set int attribute of node
   2:     oNodeSetBoolean (Node, node_attribute, boolean)
   2:     oNodeSetKind (Node, node_attribute, kind) % set attribute of node  *** MIGHT NOT NEED
   2:     oNodeGet (Node, node_attribute) >> Node    % get Node attribute of node
   2:     oNodeGetInt (Node, node_attribute) >> int  % get int attribute of node
   2:     oNodeGetBoolean (Node, node_attribute) >> boolean  % get int attribute of node
   2:     oNodeNull (Node) >> boolean          % is node null?
   2:     oNodeNext (inout Node)               % advance Node to next in list
   2:     oNodeType (Node) >> node_type        % return node type of node
   2:     oNodeEqual (Node, Node) >> boolean   % compare two nodes for equality
                                               % (i.e. same node, not just same contents)
   2:     ;
      
      
      % Manipulate a temporary vector of Node
      %
   2: mechanism node_vec_mech:
   2:     oNodeVecNew >> NodeVec
   2:     oNodeVecDelete( NodeVec nv )
   2:     oNodeVecAppend( NodeVec nv, Node n )
   2:     oNodeVecSize( NodeVec nv ) >> int                % how many elements
   2:     oNodeVecElement( NodeVec nv, int idx ) >> Node   % element at index idx (0..size-1)
   2:     ;
      
      
   2: mechanism emit_mech:
   2:     oEmitInt( int )              % emit int into the generated code
   2:     Here >> int                  % current address in the generated code
   2:     oPatch( int addr, int val )  % patch an int into address in the generated code
   2:     ;
      
   2: mechanism math:
   2:     inc (inout int)
   2:     dec (inout int)
   2:     negate (int) >> int
   2:     subtract( int x, int y ) >> int     % x - y
   2:     multiply( int x, int y ) >> int     % x * y
   2:     equal( int x, int y ) >> boolean
   2:     equal_zero (int) >> boolean
   2:     equal_node_type (node_type, node_type) >> boolean     % Want equal_<type> for every type
   2:     ;
      
   2: mechanism more_builtins:      % These should be built-in SSL operations
   2:     TOKEN_VALUE >> int        % value of just accepted token, e.g. IntLit token
   2:     LAST_ID >> int            % id number of last accepted identifier
   2:     ;
      
   2: mechanism scope_mech:
   2:     oScopeBegin                          % create a new scope. Subsequent declarations will go here.
   2:     oScopeEnter( Node scope )            % enter an existing scope.
   2:     oScopeEnd                            % end current scope. Subsequent declarations will go to previous scope.
   2:     oScopeCurrent >> Node                % returns current scope
   2:     oScopeDeclare( Node decl )           % add declaration to current scope.
   2:     oScopeDeclareAlloc( Node decl )      % add declaration to current scope, and allocate space according to its type
   2:     oScopeAllocType( Node theType ) >> int   % allocate space for type in current scope, and return its address
   2:     oScopeFind >> Node                   % find declaration of last accepted identifier.  Returns Null if not found.
   2:     oScopeFindRequire >> Node            % find declaration of last accepted identifier.  Error if not found.
   2:     ;
      
      
   2: mechanism type_mech:
   2:     oTypeAdd( Node node )     % add the given nType to the type table
   2:     ;
      
   2: mechanism type_stack_mech:
   2:     oTypeSPush( Node node )
   2:     oTypeSPop
   2:     oTypeSTop >> Node
   2:     oTypeSNodeType >> node_type          % node_type of the node on top of type stack, skipping subranges
   2:     ;
      
      
   2: mechanism id_mech:
          % adds a predefined id to the scanner's id table, and returns the id code
   2:     oIdAdd_File >> int
   2:     oIdAdd_Integer >> int
   2:     oIdAdd_Boolean >> int
   2:     oIdAdd_Char >> int
   2:     oIdAdd_String >> int
   2:     oIdAdd_True >> int
   2:     oIdAdd_False >> int
   2:     ;
      
      
   2: mechanism count :
   2:    oCountPush(int)          % start a new counter, with initial value
   2:    oCountInc
   2:    oCountDec
   2:    oCountIsZero >> boolean
   2:    oCountPop;
      
      
   2: mechanism value :              % value stack, to calc. const expr's
   2:    oValuePush(int)             % push an explicit int lit
   2:    oValueNegate                % negate top value
   2:    oValueTop >> int            % get top value on value stack
   2:    oValuePop;
      
   2: mechanism string :
   2:    oStringAllocLit;            % alloc data space for strlit, push address
                                     %   on value stack
      
   2: type patchStack:
   2:    patchLoop                   % addr of start of loop (repeat, while, for)
   2:    patchExit                   % addrs where jumps out of loop are
                                     %   (use count mechanism to count how many)
   2:    patchIf;                    % addr of jump around code in 'if' statement
      
   2: mechanism patch:               % note, creates absolute-address jumps
   2:    oPatchPushHere(patchStack)  % put current address on a patch stack
   2:    oPatchAnyEntries(patchStack) >> boolean     % anything in patch stack?
   2:    oPatchSwap(patchStack)      % swap top two entries
   2:    oPatchDup(patchStack)       % duplicate the top entry
   2:    oPatchPopFwd(patchStack)    % store here at x (x=top of stack), pop stack
   2:    oPatchPopBack(patchStack);  % emit x (so advance 'here'), pop stack
      
   2: rules
      
      % ----------------------------- Global Variables ----------------------------
      
   2: Node    globalScope            % global nScope
      
      % built-in nTypes
   2: Node    FileType
   2: Node    IntegerType
   2: Node    BooleanType
   2: Node    CharType
   2: Node    StringType
      
      % -------------------------- Forward Declarations -------------------------
      
   2: Block( node_type varNodeType, out int addr );
   2: VarDecl( node_type varNodeType );
   2: newType( node_type nt, int size ) >> Node;
   2: newIdent( node_type nt, kind k, int id ) >> Node;
   2: EmitValue( Node decl );
   2: TypeRef( out Node theType );
   2: PointerTypeTo( Node theType ) >> Node;
   2: OrdinalLow( Node theType ) >> int;
   2: AssignStmt( Node decl );
   2: VarExpr( Node decl );
   2: LValueVar( Node decl );
      
      
      % ----------------------------- Declarations ----------------------------
      
   2: Program:
   4:    Node t
      
   4:    oScopeBegin
   5:    globalScope = oScopeCurrent
      
  10:    @installBuiltIns
      
         % Start by jumping to the main program statement
  12:    int patchJumpMain
  12:    .tJump 
  14:    patchJumpMain = Here
  19:    .tSpace
      
  21:    pProgram
  23:    pIdent
      
  25:    t = @newIdent( nProgram, kProgram, LAST_ID )
  41:    oScopeDeclare( t )
      
  47:    [
  47:       | '(' :
  49:          pIdent      % input, output files
      
  51:          t = @newIdent( nVar, kVar, LAST_ID )
  67:          oNodeSet( t, qType, FileType )
  79:          oScopeDeclareAlloc( t )
      
  85:          ','
  87:          pIdent
      
  89:          t = @newIdent( nVar, kVar, LAST_ID )
 105:          oNodeSet( t, qType, FileType )
 117:          oScopeDeclareAlloc( t )
      
 123:          ')'
 125:       | * :
 130:    ]
 130:    ';'
      
 132:    int addr
 132:    @Block( nGlobalVar, addr )    % not including punctuation after body's 'end'
 142:    oPatch( patchJumpMain, addr )
      
 151:    '.'
 153:    oScopeEnd
 155:    ;
      
      
      % Returns the addr of the block's statements.
      % This might differ from the Here on entry to this rule,
      % due to method declarations in the block.
      %
 155: Block( node_type varNodeType, out int addr ):
 157:    {[
 157:       | pConst :     @ConstDecl
 161:       | pType :      @TypeDecl
 165:       | pVar :       @VarDecl( varNodeType )
 174:       | pProcedure : @ProcDecl
 178:       | pFunction :  @FuncDecl
 182:       | * :          >
 197:    ]}
 199:    addr = Here
      
         % proc/func body begins with tEnter
 204:    int patchLS
 204:    [ equal_node_type( varNodeType, nLocalVar )
 214:       | true :       .tEnter  patchLS = Here  .tSpace
 224:       | * :
 229:    ]
      
 229:    @Statement
 231:    .tReturn
      
 233:    [ equal_node_type( varNodeType, nLocalVar )
 243:       | true :
 244:          int localSpace
 244:          localSpace = oNodeGetInt( oScopeCurrent, qSize )
 256:          oPatch( patchLS, localSpace )
 265:       | * :
 270:    ];
      
      
 271: ProcDecl:
 273:    Node decl
      
 273:    pIdent
 275:    decl = @newIdent( nProc, kProc, LAST_ID )
      
 291:    oScopeBegin
 292:    Node paramScope
 292:    paramScope = oScopeCurrent
      
 297:    @FormalArgDecl
 299:    oNodeSet( decl, qParams, paramScope )
 311:    oScopeEnd
      
 312:    oScopeDeclare( decl )
 318:    ';'
      
         % Enter the params scope again, so params are visible in body.
         % TO DO: Perhaps I could mark the scope read-only at this point.
 320:    oScopeEnter( paramScope )
      
         % Start scope for declarations within the proc
 326:    oScopeBegin
 327:    oNodeSetBoolean( oScopeCurrent, qAllocDown, true )
 338:    oNodeSet( decl, qChildScope, oScopeCurrent )
      
 349:    int addr
 349:    @Block( nLocalVar, addr )
 359:    oNodeSetInt( decl, qValue, addr )
 371:    oNodeSetBoolean( decl, qAddrDefined, true )
 383:    oScopeEnd
      
 384:    oScopeEnd  % paramScope
 385:    ';';
      
 388: FuncDecl:
 390:    Node decl
 390:    Node theType
      
 390:    pIdent
 392:    decl = @newIdent( nFunc, kFunc, LAST_ID )
      
 408:    oScopeBegin
 409:    Node paramScope
 409:    paramScope = oScopeCurrent
      
 414:    @FormalArgDecl
 416:    oNodeSet( decl, qParams, paramScope )
      
 428:    ':'
      
 430:    @TypeRef( theType )
 437:    oNodeSet( decl, qType, theType )
      
         % The function's param space gets an additional pointer,
         % which will point to a temporary in the caller's scope.
         % This pointer is essentially a VAR param, but I won't create an nParam for it.
      
 449:    Node ptrType
 449:    ptrType = @PointerTypeTo( theType )
 460:    oNodeSetInt( decl, qResultOffset, oScopeAllocType( ptrType ) )
      
 476:    ';'
      
 478:    oScopeEnd
 479:    oScopeDeclare( decl )
      
         % Enter the params scope again, so params are visible in body.
         % TO DO: Perhaps I could mark the scope read-only at this point.
 485:    oScopeEnter( paramScope )
      
 491:    oScopeBegin
 492:    oNodeSetBoolean( oScopeCurrent, qAllocDown, true )
 503:    oNodeSet( decl, qChildScope, oScopeCurrent )
      
 514:    int addr
 514:    @Block( nLocalVar, addr )
 524:    oNodeSetInt( decl, qValue, addr )
 536:    oNodeSetBoolean( decl, qAddrDefined, true )
 548:    oScopeEnd
      
 549:    oScopeEnd  % paramScope
 550:    ';';
      
      
 553: FormalArgDecl:
 555:    [
 555:       | '(' :
 557:          {
 557:             NodeVec decls
 557:             decls = oNodeVecNew
 562:             Node decl
 562:             boolean isInOut
 562:             isInOut = false
      
 568:             [
 568:                | pVar : isInOut = true
 576:                | * :
 581:             ]
      
 581:             {  pIdent
      
 583:                decl = @newIdent( nParam, kVar, LAST_ID )
 599:                oNodeSetBoolean( decl, qInOut, isInOut )
 611:                oNodeVecAppend( decls, decl )
      
 620:                [
 620:                   | ':' : >
 624:                   | ',' :
 626:                ]
 634:             }
      
 636:             Node theType
 636:             @TypeRef( theType )
      
                  % VAR param is declared with its given type, but allocated as a pointer.
 643:             Node allocType
 643:             [ isInOut
 646:                | true :   allocType = @PointerTypeTo( theType )
 658:                | * :      allocType = theType
 669:             ]
      
 669:             int i
 669:             i = 0
 675:             {[ equal( i, oNodeVecSize( decls ) )
 689:                | false :
 690:                   decl = oNodeVecElement( decls, i )
      
 703:                   oNodeSet( decl, qType, theType )
 715:                   oScopeDeclare( decl )
 721:                   oNodeSetInt( decl, qValue, oScopeAllocType( allocType ) )
 737:                   inc( i )
 743:                | * :
 748:                   >
 750:             ]}
      
 752:             oNodeVecDelete( decls )
      
 758:             [
 758:                | ')' : >
 762:                | ';' :
 764:             ]
 772:          }
 774:       | * :
 779:    ];
      
 780: ConstDecl:
 782:    {[
 782:       | pIdent :
 784:          Node decl
 784:          decl = @newIdent( nConst, kConst, LAST_ID )
 800:          '='
      
 802:          @ConstExpr
               % TO DO: currently ConstExpr leaves int result on oValue stack
 804:          int val
 804:          val = oValueTop
 809:          oValuePop
 810:          oNodeSetInt( decl, qValue, val )
      
               % TO DO: different types.  Currently assumes int!
 822:          oNodeSet( decl, qType, IntegerType )
      
 834:          oScopeDeclare( decl )
 840:          ';'
 842:       | * :
 847:          >
 849:    ]};
      
 852: TypeDecl:
 854:    {[
 854:       | pIdent :
 856:          Node decl
 856:          decl = @newIdent( nTypeDecl, kType, LAST_ID )
 872:          '='
 874:          Node theType
 874:          @TypeRef( theType )
 881:          oNodeSet( decl, qType, theType )
 893:          oScopeDeclare( decl )
 899:          ';'
 901:       | * :
 906:          >
 908:    ]};
      
 911: VarDecl( node_type varNodeType ):
 913:    {[
 913:       | pIdent :
 915:          NodeVec decls
 915:          decls = oNodeVecNew
 920:          Node decl
 920:          {
 920:             decl = @newIdent( varNodeType, kVar, LAST_ID )
 936:             oNodeVecAppend( decls, decl )
 945:             [
 945:                | ',' :
 947:                   pIdent
 949:                | * :
 954:                   >
 956:             ]
 956:          }
 958:          ':'
 960:          Node theType
 960:          @TypeRef( theType )
      
 967:          int i
 967:          i = 0
 973:          {[ equal( i, oNodeVecSize( decls ) )
 987:            | false :
 988:              decl = oNodeVecElement( decls, i )
1001:              oNodeSet( decl, qType, theType )
1013:              oScopeDeclareAlloc( decl )
1019:              inc( i )
1025:             | * :
1030:               >
1032:          ]}
      
1034:          oNodeVecDelete( decls )
1040:          ';'
1042:       | * :
1047:          >
1049:    ]};
      
      
      % Parse a type reference, returning the nType.
      % This will add types to the type table, as needed.
      %
      % Style question - at the moment I think callers look clearer if we use
      % an out param here, rather than a return value.
      %
1052: TypeRef( out Node resultType ):
1054:    [
1054:       | pIdent :           % previously named type (including intrinsics)
1056:          Node decl
1056:          decl = oScopeFindRequire
1061:          [ oNodeType( decl )
1068:            | nTypeDecl :
1069:                resultType = oNodeGet( decl, qType )
1082:            | * :
1087:                #eNotType
1089:                resultType = IntegerType
1095:          ]
         
1095:       | pArray :
1097:          '['
      
               % A multi-dimensional array is represented as a chain
               %    array [subrange1] of array [subrange2] of elementType
      
               % First, we build a vector of nArray's, each with one subrange as its index type,
               % but without setting the "of" type or size.
      
1099:          NodeVec dimensions
1099:          dimensions = oNodeVecNew
      
1104:          {
                  % to do: probably should use general subrange parsing, incl minimal size value
                  %   In fact, supposed to parse ordinal_type here.  all ordinal types have a static low, high.
                  %   Not necessary to be a subrange.
      
1104:             Node subrange
1104:             subrange = oNodeNew( nSubrangeType )
                  % TO DO: currently assuming subrange of integer
1114:             oNodeSet( subrange, qBaseType, IntegerType )
      
                  % TO DO: currently ConstExpr leaves int result on oValue stack
1126:             @ConstExpr
1128:             oNodeSetInt( subrange, qLow, oValueTop )
1139:             oValuePop
1140:             '..'
1142:             @ConstExpr
1144:             oNodeSetInt( subrange, qHigh, oValueTop )
1155:             oValuePop
1156:             oNodeSetInt( subrange, qSize, 4 )   % maybe don't need
      
1168:             oTypeAdd( subrange )
      
1174:             Node a
1174:             a = oNodeNew( nArrayType )
1184:             oNodeSet( a, qIndexType, subrange )
      
1196:             oNodeVecAppend( dimensions, a )
                  % I'll hold off on adding 'a' to the type table since not fully formed yet
      
1205:             [
1205:                | ']' : >
1209:                | ',' :
1211:             ]
1219:          }
1221:          pOf
1223:          Node baseType
1223:          @TypeRef( baseType )
      
               % Work backwards through the dimensions,
               % hooking up the 'of' type and calculating the size.
               % At each iteration, baseType is the 'of' type.
      
1230:          int dim
1230:          dim = oNodeVecSize( dimensions )
1240:          {
1240:              dec(dim)
      
1246:              Node a
1246:              a = oNodeVecElement( dimensions, dim )
1259:              oNodeSet( a, qBaseType, baseType )
1271:              Node subrange
1271:              subrange = oNodeGet( a, qIndexType )
1284:              int width
1284:              width = subtract( oNodeGetInt( subrange, qHigh ), oNodeGetInt( subrange, qLow ) )
1311:              inc( width )
1317:              oNodeSetInt( a, qSize, multiply( width, oNodeGetInt( baseType, qSize ) ) )
      
1343:              oTypeAdd( a )
1349:              baseType = a
      
1355:              [ equal_zero(dim)
1362:                  | true:  >
1365:                  | *:
1370:              ]
1370:          }
      
1372:          resultType = oNodeVecElement( dimensions, 0 )
1385:          oNodeVecDelete( dimensions )
      
1391:       | '^' :
1393:          Node theType
1393:          @TypeRef( theType )
1400:          resultType = @PointerTypeTo( theType )
      
1411:       | pRecord :
1413:          resultType = oNodeNew( nRecordType )
1423:          oScopeBegin
      
1424:          @VarDecl( nRecordField )
      
1431:          int size
1431:          size = oNodeGetInt( oScopeCurrent, qSize )
               % to do: padding
1443:          [ equal_zero( size )
1450:             | true : #eRecordEmpty
1453:             | * :
1458:          ]
      
1458:          pEnd
      
1460:          oNodeSet( resultType, qScope, oScopeCurrent )
1471:          oNodeSetInt( resultType, qSize, size )
1483:          oScopeEnd
1484:          oTypeAdd( resultType )
      
      
            % *** TO DO: following type constructors are not implemented *** 
            % *** TO DO: also missing declaration of enum type
1490:       | pSet :
1492:          pOf
1494:          Node theType
1494:          @TypeRef( theType )
1501:       | * :       % this works for cases except where expr starts with an id
1514:          @ConstExpr '..' @ConstExpr
1520:    ];
      
      
      % ------------------------------ Expressions -----------------------------
      
      % Constant expressions: currently, only literal integers or previously
      % named constant integers are supported, possibly with a negation.
      % Constant expressions are evaluated at compile time.
      
1521: ConstExpr:
1523:    [
1523:       | pIntLit :
1525:          oValuePush( TOKEN_VALUE )
1530:       | pIdent :
1532:          Node decl
1532:          decl = oScopeFindRequire
1537:          [ oNodeType( decl )
1544:             | nConst :
1545:                oValuePush( oNodeGetInt( decl, qValue ) )
1558:             | * :
1563:                #eNotConst
1565:                oValuePush( 0 )
1571:          ]
1571:       | pMinus :
1573:          @ConstExpr
1575:          oValueNegate
1576:    ];
      
      %
      % General run-time expressions
      % The type stack tracks the type of the expression.
      %
      
1587: Expr:
1589:    @BoolExpr
1591:    {[
1591:       | '=' :
1593:          @BoolExpr
1595:          @MatchTypes
1597:          [ oTypeSNodeType
1599:             | nIntegerType, nBooleanType :  .tEqualI
1602:             | nPointerType :                .tEqualP
1606:             | nCharType, nStringType :      #eNotImplemented
1610:             | * :                           #eNotAllowed
1625:          ]
1625:          oTypeSPop
1626:          oTypeSPush( BooleanType )
      
1632:       | '<>' :
1634:          @BoolExpr
1636:          @MatchTypes
1638:          [ oTypeSNodeType
1640:             | nIntegerType, nBooleanType :  .tNotEqualI
1643:             | nPointerType :                .tNotEqualP
1647:             | nCharType, nStringType :      #eNotImplemented
1651:             | * :                           #eNotAllowed
1666:          ]
1666:          oTypeSPop
1667:          oTypeSPush( BooleanType )
      
1673:       | '<' :
1675:          @BoolExpr
1677:          @MatchTypes
1679:          [ oTypeSNodeType
1681:             | nIntegerType, nBooleanType :  .tLessI
1684:             | nCharType, nStringType :      #eNotImplemented
1688:             | * :                           #eNotAllowed
1701:          ]
1701:          oTypeSPop
1702:          oTypeSPush( BooleanType )
      
1708:       | '>' :
1710:          @BoolExpr
1712:          @MatchTypes
1714:          [ oTypeSNodeType
1716:             | nIntegerType, nBooleanType :  .tGreaterI
1719:             | nCharType, nStringType :      #eNotImplemented
1723:             | * :                           #eNotAllowed
1736:          ]
1736:          oTypeSPop
1737:          oTypeSPush( BooleanType )
      
1743:       | '<=' :
1745:          @BoolExpr
1747:          @MatchTypes
1749:          [ oTypeSNodeType
1751:             | nIntegerType, nBooleanType :  .tLessEqualI
1754:             | nCharType, nStringType :      #eNotImplemented
1758:             | * :                           #eNotAllowed
1771:          ]
1771:          oTypeSPop
1772:          oTypeSPush( BooleanType )
      
1778:       | '>=' :
1780:          @BoolExpr
1782:          @MatchTypes
1784:          [ oTypeSNodeType
1786:             | nIntegerType, nBooleanType :  .tGreaterEqualI
1789:             | nCharType, nStringType :      #eNotImplemented
1793:             | * :                           #eNotAllowed
1806:          ]
1806:          oTypeSPop
1807:          oTypeSPush( BooleanType )
      
1813:       | * :
1828:          >
1830:    ]};
      
1833: BoolExpr:
1835:    @BoolTerm
1837:    {[
1837:       | pOr :
1839:          @RequireBoolPop
1841:          @BoolTerm
1843:          @RequireBool
1845:          .tOr
1847:       | * :
1852:          >
1854:    ]};
      
1857: BoolTerm:
1859:    @BoolFactor
1861:    {[
1861:       | pAnd :
1863:          @RequireBoolPop
1865:          @BoolFactor
1867:          @RequireBool
1869:          .tAnd
1871:       | * :
1876:          >
1878:    ]};
      
1881: BoolFactor:
1883:    [
1883:       | pNot :
1885:          @ArithExpr
1887:          @RequireBool
1889:          .tNot
1891:       | * :
1896:          @ArithExpr
1898:    ];
      
1899: ArithExpr:
1901:    @Term
1903:    {[
1903:       | pPlus :
1905:          @RequireIntPop
1907:          @Term
1909:          @RequireInt
1911:          .tAddI
1913:       | pMinus :
1915:          @RequireIntPop
1917:          @Term
1919:          @RequireInt
1921:          .tSubI
1923:       | * :
1930:          >
1932:    ]};
      
1935: Term:
1937:    @Factor
1939:    {[
1939:       | pTimes :
1941:          @RequireIntPop
1943:          @Factor
1945:          @RequireInt
1947:          .tMultI
1949:       | pDivide :
1951:          @RequireIntPop
1953:          @Factor
1955:          @RequireInt
1957:          .tDivI
1959:       | * :
1966:          >
1968:    ]};
      
1971: Factor:
1973:    [
1973:       | pPlus :
1975:          @Primary
1977:          @RequireInt
1979:       | pMinus :
1981:          @Primary
1983:          @RequireInt
1985:          .tNegI
1987:       | * :
1994:          @Primary
1996:    ];
      
1997: Primary:
1999:    [
1999:       | pIntLit :
2001:          .tPushConstI  oEmitInt( TOKEN_VALUE )
2008:          oTypeSPush( IntegerType )
      
2014:       | '(' :
2016:          @Expr
2018:          ')'
      
2020:       | pStrLit :
2022:          oStringAllocLit     % store, put addr on value stack
2023:          .tPushConstP oEmitInt( oValueTop )  oValuePop
               % TO DO: do we need to create a type with the literal's length?
2031:          oTypeSPush( StringType )
      
2037:       | pIdent :
2039:          Node decl
2039:          Node theType
2039:          decl = oScopeFindRequire
      
2044:          [ oNodeType( decl )
2051:             | nFunc :
      
2052:                @Call( decl )
      
2059:             | nConst :
2061:                theType = oNodeGet( decl, qType )
2074:                oTypeSPush( theType )
2080:                [ oTypeSNodeType
2082:                   | nIntegerType, nBooleanType :
2083:                      .tPushConstI @EmitValue( decl )
2092:                   | * :
2099:                      #eNotImplemented
2101:                ]
      
2101:             | nGlobalVar, nLocalVar, nParam :
2103:                @VarExpr( decl )
      
2110:             | * :
2123:                #eNotValue
2125:                oTypeSPush( IntegerType )
2131:          ]
      
2131:       | '^' :        % ^var
2133:          pIdent
      
2135:          Node decl
2135:          Node theType
2135:          decl = oScopeFindRequire
      
2140:          @LValueVar( decl )
      
               % The above leaves the pointed-to type on type stack.
               % Replace with ptr-to-<type>.
2147:          theType = oTypeSTop
2152:          oTypeSPop
2153:          Node ptrType
2153:          ptrType = @PointerTypeTo( theType )
2164:          oTypeSPush( ptrType )
      
2170:       | * :
2183:          #eNotValue
2185:          oTypeSPush( IntegerType )
2191:    ];
      
      
      % Parse a variable expression, given the declaration of the
      % just-accepted identifier.
      % Leaves the value on the expression stack, and type on the type stack.
      %
2192: VarExpr( Node decl ):
2194:    Node theType
2194:    theType = oNodeGet( decl, qType )
2207:    oTypeSPush( theType )
2213:    [ oTypeSNodeType
2215:       | nIntegerType :
2216:          [ oNodeType( decl )
2223:             | nGlobalVar :   .tPushGlobalI @EmitValue( decl )
2233:             | nLocalVar :    .tPushLocalI @EmitValue( decl )
2244:             | nParam :
2246:                [ oNodeGetBoolean( decl, qInOut )
2256:                   | true :    % VAR param points to the var.  Auto dereference.
2257:                               .tPushParamP @EmitValue( decl )
2266:                               .tFetchI
2268:                   | * :       .tPushParamI @EmitValue( decl )
2282:                ]
2282:          ]
      
2292:       | nBooleanType :
2294:          [ oNodeType( decl )
2301:             | nGlobalVar :   .tPushGlobalB @EmitValue( decl )
2311:             | nLocalVar :    .tPushLocalB @EmitValue( decl )
2322:             | nParam :
2324:                [ oNodeGetBoolean( decl, qInOut )
2334:                   | true :    % VAR param points to the var.  Auto derefernce.
2335:                               .tPushParamP @EmitValue( decl )
2344:                               .tFetchB
2346:                   | * :       .tPushParamB @EmitValue( decl )
2360:                ]
2360:          ]
      
2370:       | nCharType, nStringType, nFileType :
2372:          #eNotImplemented
      
2374:       | nPointerType :
2376:          [ oNodeType( decl )
2383:             | nGlobalVar :   .tPushGlobalP @EmitValue( decl )
2393:             | nLocalVar :    .tPushLocalP @EmitValue( decl )
2404:             | nParam :
2406:                [ oNodeGetBoolean( decl, qInOut )
2416:                   | true :    % VAR param points to the var.  Auto derefernce.
2417:                               .tPushParamP @EmitValue( decl )
2426:                               .tFetchP
2428:                   | * :       .tPushParamP @EmitValue( decl )
2442:                ]
2442:          ]
2452:          [
2452:             | '^' :             % dereferenced
2454:                oTypeSPop
2455:                oTypeSPush( oNodeGet( theType, qBaseType ) )
2468:                @LValueIndexes
2470:                @FetchVar
2472:             | * :               % just ptr value alone
2477:          ]
      
2477:       | * :
               % compound type
               % first, push addr of start of var
2492:          [ oNodeType( decl )
2499:             | nGlobalVar :   .tPushAddrGlobal @EmitValue( decl )
2509:             | nLocalVar :    .tPushAddrLocal @EmitValue( decl )
2520:             | nParam :
2522:                [ oNodeGetBoolean( decl, qInOut )
2532:                   | true :    % VAR param points to the var.  Auto derefernce.
2533:                               .tPushParamP @EmitValue( decl )
2542:                   | * :       .tPushAddrParam @EmitValue( decl )
2556:                ]
2556:          ]
               % modify addr for subscripts, field references, etc
2566:          @LValueIndexes
               % get final value
2568:          @FetchVar
2570:    ];
      
      
      % Addr of start of var is on expr stack; type is on type stack.
      % Replace expr stack with value of var.
      % (In the case of compound vars, this remains as the addr of the var).
      
2571: FetchVar:
2573:    [ oTypeSNodeType
2575:       | nIntegerType :   .tFetchI
2578:       | nBooleanType :   .tFetchB
2582:       | nCharType, nStringType, nFileType : #eNotImplemented
2586:       | nPointerType :   .tFetchP
2590:       | * :              % compound type; leave as addr
2605:    ];
      
      
      % Addr of start of var is already on run stack, and type is on type stack.
      % Read subscripts, record fields, etc, to get final addr on run stack, and final type
      % on type stack.
      
2606: LValueIndexes:
2608:    {[
2608:       | '[' :       @ArraySubscripts
2612:       | '.' :       @RecordFieldRef
2616:       | '^' :       @PointerDeref
2620:       | * :         >
2631:    ]};
      
2634: ArraySubscripts:
2636:    [ oTypeSNodeType
2638:       | nArrayType :
2639:       | * :       #eNotArray
2646:    ]
2646:    {
2646:       [ oTypeSNodeType
2648:          | nArrayType :
2649:          | * :    #eTooManySubscripts
2656:       ]
      
            % low subscript of this dimension
2656:       int low
2656:       low = @OrdinalLow( oNodeGet( oTypeSTop, qIndexType ) )
      
            % replace type stack with next dimension, or OF type
2673:       Node baseType
2673:       baseType = oNodeGet( oTypeSTop, qBaseType )
2685:       oTypeSPop
2686:       oTypeSPush( baseType )
      
2692:       @Expr
2694:       @RequireIntPop
            % adjust for low subscript
2696:       [ equal_zero( low )
2703:          | false :
2704:             .tPushConstI oEmitInt( low ) .tSubI
2714:          | * :
2719:       ]
      
            % multiply by element size
2719:       int size
2719:       size = oNodeGetInt( baseType, qSize )
2732:       [ equal( size, 1 )
2742:          | false :
2743:             .tPushConstI oEmitInt( size ) .tMultI
2753:          | * :
2758:       ]
      
            % update start address
2758:       .tAddI
2760:       [
2760:          | ']' :  >
2764:          | ',' :
2766:       ]
2774:    };
      
      
2777: RecordFieldRef:
2779:    [ oTypeSNodeType
2781:       | nRecordType :
2782:       | * :    #eNotRecord
2789:    ]
2789:    oScopeEnter( oNodeGet( oTypeSTop, qScope ) )
2801:    pIdent
2803:    Node field
2803:    field = oScopeFindRequire
         % oScopeFind searches all open scopes, so make sure we found nRecordField
         % which could only be seen in the local scope we entered above.
2808:    [ oNodeType( field )
2815:       | nRecordField :
2816:       | * :   #eNotRecordField
2823:    ]
2823:    oScopeEnd
2824:    int offset
2824:    offset = oNodeGetInt( field, qValue )
2837:    [ equal_zero( offset )
2844:       | false :
2845:          .tPushConstI oEmitInt( offset ) .tAddI
2855:       | * :
2860:    ]
      
         % replace the type on the type stack, with the field type
2860:    oTypeSPop
2861:    oTypeSPush( oNodeGet( field, qType ) )
2875:    ;
      
      
      % ptr deref on left side, i.e. BEFORE addr of ptr var is on stack,
      %                              AFTER addr of thing pointed to is on stack
2875: PointerDeref:
2877:    [ oTypeSNodeType
2879:       | nPointerType :
2880:       | * :       #eNotPointer
2887:    ]
2887:    .tFetchP           % now addr on stack is addr of what we're pointing to
      
2889:    Node theType
2889:    theType = oTypeSTop
2894:    oTypeSPop
2895:    oTypeSPush( oNodeGet( theType, qBaseType ) )
2909:    ;
      
      
      % The expr stack contains a value whose type is on top of the type stack.
      % Generate code to coerce the value to the type under it in the type stack
      % (pop the type stack, leaving only the desired type).
      % This is used for assignment.
      %
2909: CoerceType:
         % TO DO: not implemented yet.  For now I require exact type match.
2911:    @MatchTypes
2914:    ;
      
      
      % Parse a call, given an nProc or nFunc for the just-accepted identifier.
      % If a func, this will also generate the code to push the return value on the expr stack,
      % and push the return type on the type stack.
      %
2914: Call( Node method ):
      
         % If this is a function, we will allocate a temporary
         % in the current scope, to hold the result value.
         % And pass a pointer to that temporary as an extra parameter.
2916:    boolean isFunc
2916:    Node resultType
2916:    int tempOffset
2916:    boolean tempIsGlobal
      
2916:    isFunc = equal_node_type( oNodeType( method ), nFunc )
      
2933:    [ isFunc
2936:       | true :
2937:          resultType = oNodeGet( method, qType )
2950:          tempOffset = oScopeAllocType( resultType )
2960:          tempIsGlobal = oNodeEqual( oScopeCurrent, globalScope )
      
               % TO DO: we could manage temp allocation, so temp space can be reused
               %        by different code branches.
               % Note, the current scope can be global scope, if function is called from
               % the main code.  We need to know if the temp is global or local
               % to reference the allocated offset.  TO DO: could be cleaner.  Maybe I should
               % create a local stack frame for the main method too.
      
2972:       | * :
2977:    ]
         
      
2977:    Node paramScope
2977:    paramScope = oNodeGet( method, qParams )
2990:    int actualsSize
2990:    actualsSize = oNodeGetInt( paramScope, qSize )
3003:    .tAllocActuals  oEmitInt( actualsSize )
      
3011:    Node param
3011:    param = oNodeGet( paramScope, qDecls )
3024:    [
3024:       | '(' :
            
3026:          {
3026:             [ oNodeNull( param )
3033:                | true : >
3036:                | * :
3041:             ]
      
3041:             int offset
3041:             offset = oNodeGetInt( param, qValue )
      
                  % Assign actual value to spot in actuals space
3054:             .tPushAddrActual oEmitInt( offset )
3062:             oTypeSPush( oNodeGet( param, qType ) )
      
3075:             [ oNodeGetBoolean( param, qInOut )
3085:                | true :   % A VAR param.
                                % The actual is a pointer to the value.
                                % The type on the type stack (pushed above) is for the pointed-to value.
      
3086:                           @LValueExpr
                                % Addr of the referenced variable is on the expr stack,
                                % type of the variable is on the type stack.
      
                                % Match types more exactly. It's not sufficient to be assign compatible
                                % since the method will be assigning to the actual using the param type.
                                % Maybe something like type contents must match, incl subrange bounds.
3088:                           @MatchTypes
      
3090:                           .tAssignP
      
3092:                | false :  @Expr
3096:                           @CoerceType
                                
                                % Assign to offset in actuals space
      
3098:                           [ oTypeSNodeType
3100:                              | nIntegerType :            .tAssignI
3103:                              | nBooleanType :            .tAssignB
3107:                              | nCharType, nStringType, nFileType :   #eNotImplemented
3111:                              | nPointerType :            .tAssignP
3115:                              | * :
                                       % compound types: copy value into actuals space
3130:                                  int size
3130:                                  size = oNodeGetInt( oTypeSTop, qSize )
3142:                                  .tCopy  oEmitInt( size )    % multi-word copy
3150:                           ]
3150:             ]
3158:             oTypeSPop
      
3159:             oNodeNext( param )
3165:             [ oNodeNull( param )
3172:                | true :  >
3175:                | false :
3177:             ]
      
3185:             ','
3187:          }
      
3189:          ')'
      
3191:       | * :
3196:    ]
      
3196:    [ oNodeNull( param )
3203:       | false :    #eMissingParameter
3206:       | * :
3211:    ]
      
3211:    [ isFunc
3214:       | true :
               % Pass result temp as an additional VAR parameter.
               % Allow for the result temp to be in global scope or local scope.
3215:          .tPushAddrActual oEmitInt( oNodeGetInt( method, qResultOffset ) )
3230:          [ tempIsGlobal
3233:             | true :   .tPushAddrGlobal  oEmitInt( tempOffset )
3242:             | * :      .tPushAddrLocal   oEmitInt( tempOffset )
3255:          ]
3255:          .tAssignP
3257:       | * :
3262:    ]
      
3262:    .tCall   @EmitValue( method )
      
3271:    [ isFunc
3274:       | true :
               % push return value from temp
3275:          oTypeSPush( resultType )
3281:          [ tempIsGlobal
3284:             | true :   .tPushAddrGlobal  oEmitInt( tempOffset )
3293:             | * :      .tPushAddrLocal   oEmitInt( tempOffset )
3306:          ]
3306:          @FetchVar
3308:       | * :
3313:    ]
         
3313:    .tFreeActuals  oEmitInt( actualsSize )
3322:    ;
      
      
      % ------------------------------ Statements -----------------------------
      
3322: Statement:
3324:    [
3324:       | pWriteln :     @WritelnStmt
3328:       | pWrite :       @WriteStmt
3332:       | pReadln :      @ReadlnStmt
3336:       | pRead :        @ReadStmt
3340:       | pIf :          @IfStmt
3344:       | pWhile :       @WhileStmt
3348:       | pFor :         @ForStmt
3352:       | pRepeat :      @RepeatStmt
3356:       | pExit :        @ExitStmt
3360:       | pCycle :       @CycleStmt
3364:       | pBegin :       @BeginStmt
3368:       | pIdent :       @AssignOrCallStmt
3372:       | * :            % null statement : don't accept any tokens
3399:    ];
      
      
3400: AssignOrCallStmt:
3402:    Node decl
3402:    decl = oScopeFindRequire
3407:    [ oNodeType( decl )
3414:       | nProc :                           @Call( decl )
3422:       | nGlobalVar, nLocalVar, nParam :   @AssignStmt( decl )
3431:       | nFunc :                           @AssignResultStmt( decl )
3440:       | * :                               #eBadStatement
3455:    ];
      
      
      % Given decl, the just-accepted first identifier on the left hand side.
      %
3456: AssignStmt( Node decl ):
      
3458:    @LValueVar( decl )
      
3465:    ':=' 
3467:    @Expr
3469:    @MatchTypes
3471:    [ oTypeSNodeType
3473:       | nIntegerType :            .tAssignI
3476:       | nBooleanType :            .tAssignB
3480:       | nCharType, nStringType, nFileType :   #eNotImplemented
      
            % compound var assigns; addrs of src, dest on stack
3484:       | nPointerType :            .tAssignP
3488:       | * :
3503:           int size
3503:           size = oNodeGetInt( oTypeSTop, qSize )
3515:           .tCopy  oEmitInt( size )    % multi-word copy
3523:    ]
3523:    oTypeSPop
3525:    ;
      
      
      % Given nFunc for the just-accepted identifier on the left hand side.
      % Parse an assignment that represents assignment of the function result.
      %
3525: AssignResultStmt( Node funcDecl ):
         % Only allowed to assign the result of the immediately enclosing function, I think.
3527:    [ oNodeEqual( oNodeGet( funcDecl, qChildScope ), oScopeCurrent )
3543:       | false :   #eNotCurrentFunction
3546:       | * :
3551:    ]
      
         % Result value is stored in the caller's space, via a hidden VAR parameter.
3551:    .tPushParamP  oEmitInt( oNodeGetInt( funcDecl, qResultOffset ) )
3566:    oTypeSPush( oNodeGet( funcDecl, qType ) )
      
3579:    ':='
3581:    @Expr
3583:    @MatchTypes
3585:    [ oTypeSNodeType
3587:       | nIntegerType :            .tAssignI
3590:       | nBooleanType :            .tAssignB
3594:       | nCharType, nStringType, nFileType :   #eNotImplemented
      
            % compound var assigns; addrs of src, dest on stack
3598:       | nPointerType :            .tAssignP
3602:       | * :
3617:           int size
3617:           size = oNodeGetInt( oTypeSTop, qSize )
3629:           .tCopy  oEmitInt( size )    % multi-word copy
3637:    ]
3637:    oTypeSPop
3639:    ;
      
      
      
      % Parse an lvalue expression, from scratch.
      % This is an expression that may appear on the left side of an assignment.
      % Leaves the address of the value on the expr stack,
      % and the type of the value at that address on the type stack.
      %
3639: LValueExpr:
         % At the moment, all lvalue expressions start with a variable name.
         % I think there can also be typecasts, not supported yet.  Check standard syntax.
3641:    pIdent
3643:    Node decl
3643:    decl = oScopeFindRequire
3648:    [ oNodeType( decl )
3655:       | nGlobalVar, nLocalVar, nParam :
3656:       | * :  #eNotVar
3667:    ]
3667:    @LValueVar( decl )
3675:    ;
      
      
      % Parse an lvalue expression (e.g. left side of an assign statement)
      % that stars with the just-accepted identifier indicated by the given decl.
      % Leaves the lvalue address on the expression stack,
      % and the type of the value at that address on the type stack.
      %
3675: LValueVar( Node decl ):
3677:    [ oNodeType( decl )
3684:       | nGlobalVar :   .tPushAddrGlobal @EmitValue( decl )
3694:       | nLocalVar :    .tPushAddrLocal @EmitValue( decl )
3705:       | nParam :
3707:          [ oNodeGetBoolean( decl, qInOut )
3717:             | true :   % VAR param points to variable.  No dereference.
3718:                        .tPushParamP @EmitValue( decl )
3727:             | * :      .tPushAddrParam @EmitValue( decl )
3741:          ]
3741:       | * :            #eNotVar
3752:    ]
      
3752:    oTypeSPush( oNodeGet( decl, qType ) )
3765:    @LValueIndexes        % handle subscripts, if any
3768:    ;
      
      
3768: IfStmt:
3770:    @Expr
3772:    @RequireBoolPop
3774:    pThen
3776:    .tJumpFalse
3778:    oPatchPushHere(patchIf)
3784:    .tSpace
3786:    @Statement
3788:    [
3788:       | pElse :
3790:          .tJump
3792:          oPatchPushHere(patchIf)
3798:          .tSpace
3800:          oPatchSwap(patchIf)
3806:          oPatchPopFwd(patchIf)
3812:          @Statement
3814:       | * :
3819:    ]
3819:    oPatchPopFwd(patchIf);
      
3826: ForStmt:
3828:    pIdent
      
3830:    Node decl
3830:    decl = oScopeFindRequire
3835:    [ oNodeType( decl )
3842:       | nGlobalVar :
3843:       | nLocalVar :    #eNotImplemented
3847:       | nParam :       #eNotImplemented
3851:       | * :            #eNotIntVar
3862:    ]
3862:    oTypeSPush( oNodeGet( decl, qType ) )
3875:    @RequireIntPop
3877:    .tPushConstP  @EmitValue( decl )
      
3886:    ':='
      
3888:    @Expr
3890:    @RequireIntPop
3892:    .tAssignI
      
3894:    .tJump oPatchPushHere(patchLoop) .tSpace
3904:    oPatchPushHere(patchLoop)
3910:    oPatchSwap(patchLoop)
3916:    [
3916:       | pTo :
3918:          .tIncGlobalI @EmitValue( decl )
3927:          oPatchPopFwd(patchLoop)
3933:          .tPushGlobalI @EmitValue( decl )
3942:          @Expr
3944:          @RequireIntPop
3946:          .tGreaterI
3948:          .tJumpTrue oPatchPushHere(patchLoop) .tSpace
3958:          oPatchSwap(patchLoop)
3964:       | pDownto :
3966:          .tDecGlobalI @EmitValue( decl )
3975:          oPatchPopFwd(patchLoop)
3981:          .tPushGlobalI @EmitValue( decl )
3990:          @Expr
3992:          @RequireIntPop
3994:          .tLessI
3996:          .tJumpTrue oPatchPushHere(patchLoop) .tSpace
4006:          oPatchSwap(patchLoop)
4012:    ]
4020:    oCountPush(0)          % count 'exit' patches
4026:    pDo
4028:    @Statement
4030:    .tJump oPatchPopBack(patchLoop)
4038:    oPatchPopFwd(patchLoop)
4044:    @PatchExitsPop;
      
4047: RepeatStmt:
4049:    oPatchPushHere(patchLoop) % start of loop
4055:    oCountPush(0)          % count the 'exit' patches
4061:    @Statement
4063:    {[
4063:       | ';' :
4065:          @Statement
4067:       | pUntil :
4069:          @Expr
4071:          @RequireBoolPop
4073:          .tJumpFalse
4075:          oPatchPopBack(patchLoop)
4081:          @PatchExitsPop
4083:          >
4085:    ]};
      
4096: WhileStmt:
4098:    oPatchPushHere(patchLoop)    % start of loop
4104:    oCountPush(0)
4110:    @Expr
4112:    @RequireBoolPop
4114:    pDo
4116:    .tJumpFalse
4118:    oPatchPushHere(patchLoop)    % jump out
4124:    .tSpace
4126:    oPatchSwap(patchLoop)        % start on top
4132:    @Statement
4134:    .tJump
4136:    oPatchPopBack(patchLoop)
4142:    oPatchPopFwd(patchLoop)
4148:    @PatchExitsPop;
      
4151: CycleStmt:                     % NOTE, for repeat..until, skips test (??)
4153:    [ oPatchAnyEntries(patchLoop)
4160:       | true :
4161:          .tJump
4163:          oPatchDup(patchLoop)  % addr of start
4169:          oPatchPopBack(patchLoop)
4175:       | * :
4180:          #eNotInALoop
4182:    ];
      
4183: ExitStmt:
4185:    [ oPatchAnyEntries(patchLoop)
4192:       | true :
4193:          .tJump
4195:          oPatchPushHere(patchExit)
4201:          .tSpace
4203:          oCountInc
4204:       | * :
4209:          #eNotInALoop
4211:    ];
      
4212: BeginStmt:
4214:    @Statement
4216:    {[
4216:       | ';' :   @Statement
4220:       | pEnd :  >
4224:    ]};
      
4235: WritelnStmt:
4237:    @WriteStmt
4239:    .tWriteCR;
      
4242: WriteStmt:
4244:    [
4244:       | '(' :
4246:          {
4246:             @Expr
4248:             [ oTypeSNodeType
4250:                | nIntegerType :             .tWriteI
4253:                | nBooleanType :             .tWriteBool
4257:                | nStringType :              .tWriteStr
4261:                | nCharType, nFileType :     #eNotImplemented
4265:                | nPointerType :             .tWriteP
4269:                | * :                        #eNotAllowed
4286:             ]
4286:             oTypeSPop
4287:             [
4287:                | ')' : >
4291:                | ',' :
4293:             ]
4301:          }
4303:       | * :
4308:    ];
      
      
4309: ReadlnStmt:      % ***
4312:    ;
4312: ReadStmt:
4315:    ;
      
      % -------------------------------- Utilities -------------------------------
      
4315: PatchExitsPop:
4317:    {[ oCountIsZero
4319:       | false : oPatchPopFwd(patchExit)
4326:                 oCountDec
4327:       | * :     >
4334:    ]}
4336:    oCountPop;
      
      
      % Require that the top two types on the type stack are matching (ignoring subranges).
      % Pop one of them, leaving only one.
      %
4338: MatchTypes:
4340:    node_type nt
4340:    nt = oTypeSNodeType
4345:    oTypeSPop
4346:    [ equal_node_type( nt, oTypeSNodeType )
4355:       | false :
4356:          #eTypeMismatch
4358:       | * :
4363:    ];
      
      
      % Require that the top type on the type stack is integer (ignoring subranges).
      % Pop it.
      %
4364: RequireIntPop:
4366:    [ oTypeSNodeType
4368:       | nIntegerType :
4369:       | * :          #eNotInteger
4376:    ]
4376:    oTypeSPop;
      
4378: RequireInt:
4380:    [ oTypeSNodeType
4382:       | nIntegerType :
4383:       | * :          #eNotInteger
4390:    ];
      
4391: RequireBoolPop:
4393:    [ oTypeSNodeType
4395:       | nBooleanType :
4396:       | * :          #eNotBoolean
4403:    ]
4403:    oTypeSPop;
      
4405: RequireBool:
4407:    [ oTypeSNodeType
4409:       | nBooleanType :
4410:       | * :          #eNotBoolean
4417:    ];
      
      
      % Create and return a new nType of the given node_type, adding it to the type table.
      %
4418: newType( node_type nt, int size ) >> Node:
4420:   Node node
4420:   node = oNodeNew( nt )
4430:   oNodeSetInt( node, qSize, size )
4442:   oTypeAdd( node )
4448:   >> node
4452:   ;
      
      
      % Create and return a new nIdent of the given node_type, with the given ident id.
      % Does not add it to any scope.
      %
4452: newIdent( node_type nt, kind k, int id ) >> Node:
4454:   Node t
4454:   t = oNodeNew( nt )
4464:   oNodeSetKind( t, qKind, k )   % deprecated attribute
4476:   oNodeSetInt( t, qIdent, id )
4488:   >> t
4492:   ;
      
      
      % Return an nType representing a pointer to the given type.
      % (Creates a new type if necessary.)
      %
4492: PointerTypeTo( Node theType ) >> Node:
4494:    Node ptrType
4494:    ptrType = oNodeGet( theType, qPointerType )
4507:    [ oNodeNull( ptrType )
4514:       | true :
4515:          ptrType = oNodeNew( nPointerType )
4525:          oNodeSet( ptrType, qBaseType, theType )
4537:          oNodeSetInt( ptrType, qSize, 8 )
4549:          oTypeAdd( ptrType )
4555:          oNodeSet( theType, qPointerType, ptrType )
4567:       | * :
4572:    ]
4572:    >> ptrType;
      
      
      % Return the low value of an ordinal type
      %
4576: OrdinalLow( Node theType ) >> int:
4578:    [ oNodeType( theType )
4585:       | nIntegerType :  >> -2147483648
4589:       | nBooleanType :  >> 0
4594:       | nCharType :     >> 0
4599:       | nSubrangeType : >> oNodeGetInt( theType, qLow )
4611:       | * :             #eNotOrdinalType
4624:                         >> 0
4627:    ];
      
      
      
      % Emit the value in a declaration.
      % For a constant integer, this is the constant value.
      % For a global variable, this is the global address.
      % For a local variable, this is the local address relative to the call stack frame.
      %
4628: EmitValue( Node decl ):
4630:     oEmitInt( oNodeGetInt( decl, qValue ));
      
      
4644: installBuiltIns:
      
         % install built-in types
4646:    FileType = @newType( nFileType, 4 )
4660:    IntegerType = @newType( nIntegerType, 4 )
4674:    BooleanType = @newType( nBooleanType, 1 )
4688:    CharType = @newType( nCharType, 1 )
4702:    StringType = @newType( nStringType, 256 )    % string with default length 256
      
         % Declare those type identifiers.
         % SSL doesn't support strings, so need help from operations e.g. oIdAdd_File
      
4716:    Node t
      
4716:    t = @newIdent( nTypeDecl, kType, oIdAdd_File )
4732:    oNodeSet( t, qType, FileType )
4744:    oScopeDeclare( t )
      
4750:    t = @newIdent( nTypeDecl, kType, oIdAdd_Integer )
4766:    oNodeSet( t, qType, IntegerType )
4778:    oScopeDeclare( t )
      
4784:    t = @newIdent( nTypeDecl, kType, oIdAdd_Boolean )
4800:    oNodeSet( t, qType, BooleanType )
4812:    oScopeDeclare( t )
      
4818:    t = @newIdent( nTypeDecl, kType, oIdAdd_Char )
4834:    oNodeSet( t, qType, CharType )
4846:    oScopeDeclare( t )
      
4852:    t = @newIdent( nTypeDecl, kType, oIdAdd_String )
4868:    oNodeSet( t, qType, StringType )
4880:    oScopeDeclare( t )
      
         % Built-in constants
      
4886:    t = @newIdent( nConst, kConst, oIdAdd_True )
4902:    oNodeSet( t, qType, BooleanType )
4914:    oNodeSetInt( t, qValue, 1 )
4926:    oScopeDeclare( t )
      
4932:    t = @newIdent( nConst, kConst, oIdAdd_False )
4948:    oNodeSet( t, qType, BooleanType )
4960:    oNodeSetInt( t, qValue, 0 )
4972:    oScopeDeclare( t )
      
4979:    ;
      
4979: end
      
4979: 

Generated code:

   0: oGlobalSpace 7
   2: oLocalSpace 3
   4: oScopeBegin
   5: oGetAddrGlobal 1
   7: oPushResult
   8: oScopeCurrent
   9: oAssign
  10: oCall 4644
  12: oEmit 45
  14: oGetAddrLocal 2
  16: oPushResult
  17: Here
  18: oAssign
  19: oEmit 53
  21: oInput 26
  23: oInput 0
  25: oGetAddrLocal 1
  27: oPushResult
  28: oSetResult 5
  30: oPushResult
  31: oSetResult 1
  33: oPushResult
  34: LAST_ID
  35: oPushResult
  36: oCall 4452
  38: oPop 3
  40: oAssign
  41: oGetLocal 1
  43: oPushResult
  44: oScopeDeclare
  45: oPop 1
  47: oInputChoice 127
  49: oInput 0
  51: oGetAddrLocal 1
  53: oPushResult
  54: oSetResult 11
  56: oPushResult
  57: oSetResult 6
  59: oPushResult
  60: LAST_ID
  61: oPushResult
  62: oCall 4452
  64: oPop 3
  66: oAssign
  67: oGetLocal 1
  69: oPushResult
  70: oSetResult 6
  72: oPushResult
  73: oGetGlobal 2
  75: oPushResult
  76: oNodeSet
  77: oPop 3
  79: oGetLocal 1
  81: oPushResult
  82: oScopeDeclareAlloc
  83: oPop 1
  85: oInput 12
  87: oInput 0
  89: oGetAddrLocal 1
  91: oPushResult
  92: oSetResult 11
  94: oPushResult
  95: oSetResult 6
  97: oPushResult
  98: LAST_ID
  99: oPushResult
 100: oCall 4452
 102: oPop 3
 104: oAssign
 105: oGetLocal 1
 107: oPushResult
 108: oSetResult 6
 110: oPushResult
 111: oGetGlobal 2
 113: oPushResult
 114: oNodeSet
 115: oPop 3
 117: oGetLocal 1
 119: oPushResult
 120: oScopeDeclareAlloc
 121: oPop 1
 123: oInput 14
 125: oJumpForward 130
 127: Choice Lookup Table
          13     49
 130: oInput 4
 132: oSetResult 12
 134: oPushResult
 135: oGetAddrLocal 3
 137: oPushResult
 138: oCall 155
 140: oPop 2
 142: oGetLocal 2
 144: oPushResult
 145: oGetLocal 3
 147: oPushResult
 148: oPatch
 149: oPop 2
 151: oInput 18
 153: oScopeEnd
 154: oReturn
 155: oLocalSpace 2
 157: oInputChoice 184
 159: oCall 780
 161: oJumpForward 197
 163: oCall 852
 165: oJumpForward 197
 167: oGetParam 2
 169: oPushResult
 170: oCall 911
 172: oPop 1
 174: oJumpForward 197
 176: oCall 271
 178: oJumpForward 197
 180: oCall 388
 182: oJumpForward 197
 184: Choice Lookup Table
          28    180
          27    176
          31    167
          30    163
          29    159
 195: oJumpForward 199
 197: oJumpBack 157
 199: oGetParam 1
 201: oPushResult
 202: Here
 203: oAssign
 204: oGetParam 2
 206: oPushResult
 207: oSetResult 13
 209: oPushResult
 210: equal_node_type
 211: oPop 2
 213: oChoice 226
 215: oEmit 44
 217: oGetAddrLocal 1
 219: oPushResult
 220: Here
 221: oAssign
 222: oEmit 53
 224: oJumpForward 229
 226: Choice Lookup Table
           1    215
 229: oCall 3322
 231: oEmit 43
 233: oGetParam 2
 235: oPushResult
 236: oSetResult 13
 238: oPushResult
 239: equal_node_type
 240: oPop 2
 242: oChoice 267
 244: oGetAddrLocal 2
 246: oPushResult
 247: oScopeCurrent
 248: oPushResult
 249: oSetResult 2
 251: oPushResult
 252: oNodeGetInt
 253: oPop 2
 255: oAssign
 256: oGetLocal 1
 258: oPushResult
 259: oGetLocal 2
 261: oPushResult
 262: oPatch
 263: oPop 2
 265: oJumpForward 270
 267: Choice Lookup Table
           1    244
 270: oReturn
 271: oLocalSpace 3
 273: oInput 0
 275: oGetAddrLocal 1
 277: oPushResult
 278: oSetResult 7
 280: oPushResult
 281: oSetResult 2
 283: oPushResult
 284: LAST_ID
 285: oPushResult
 286: oCall 4452
 288: oPop 3
 290: oAssign
 291: oScopeBegin
 292: oGetAddrLocal 2
 294: oPushResult
 295: oScopeCurrent
 296: oAssign
 297: oCall 553
 299: oGetLocal 1
 301: oPushResult
 302: oSetResult 9
 304: oPushResult
 305: oGetLocal 2
 307: oPushResult
 308: oNodeSet
 309: oPop 3
 311: oScopeEnd
 312: oGetLocal 1
 314: oPushResult
 315: oScopeDeclare
 316: oPop 1
 318: oInput 4
 320: oGetLocal 2
 322: oPushResult
 323: oScopeEnter
 324: oPop 1
 326: oScopeBegin
 327: oScopeCurrent
 328: oPushResult
 329: oSetResult 3
 331: oPushResult
 332: oSetResult 1
 334: oPushResult
 335: oNodeSetBoolean
 336: oPop 3
 338: oGetLocal 1
 340: oPushResult
 341: oSetResult 10
 343: oPushResult
 344: oScopeCurrent
 345: oPushResult
 346: oNodeSet
 347: oPop 3
 349: oSetResult 13
 351: oPushResult
 352: oGetAddrLocal 3
 354: oPushResult
 355: oCall 155
 357: oPop 2
 359: oGetLocal 1
 361: oPushResult
 362: oSetResult 8
 364: oPushResult
 365: oGetLocal 3
 367: oPushResult
 368: oNodeSetInt
 369: oPop 3
 371: oGetLocal 1
 373: oPushResult
 374: oSetResult 11
 376: oPushResult
 377: oSetResult 1
 379: oPushResult
 380: oNodeSetBoolean
 381: oPop 3
 383: oScopeEnd
 384: oScopeEnd
 385: oInput 4
 387: oReturn
 388: oLocalSpace 5
 390: oInput 0
 392: oGetAddrLocal 1
 394: oPushResult
 395: oSetResult 8
 397: oPushResult
 398: oSetResult 3
 400: oPushResult
 401: LAST_ID
 402: oPushResult
 403: oCall 4452
 405: oPop 3
 407: oAssign
 408: oScopeBegin
 409: oGetAddrLocal 3
 411: oPushResult
 412: oScopeCurrent
 413: oAssign
 414: oCall 553
 416: oGetLocal 1
 418: oPushResult
 419: oSetResult 9
 421: oPushResult
 422: oGetLocal 3
 424: oPushResult
 425: oNodeSet
 426: oPop 3
 428: oInput 11
 430: oGetAddrLocal 2
 432: oPushResult
 433: oCall 1052
 435: oPop 1
 437: oGetLocal 1
 439: oPushResult
 440: oSetResult 6
 442: oPushResult
 443: oGetLocal 2
 445: oPushResult
 446: oNodeSet
 447: oPop 3
 449: oGetAddrLocal 4
 451: oPushResult
 452: oGetLocal 2
 454: oPushResult
 455: oCall 4492
 457: oPop 1
 459: oAssign
 460: oGetLocal 1
 462: oPushResult
 463: oSetResult 12
 465: oPushResult
 466: oGetLocal 4
 468: oPushResult
 469: oScopeAllocType
 470: oPop 1
 472: oPushResult
 473: oNodeSetInt
 474: oPop 3
 476: oInput 4
 478: oScopeEnd
 479: oGetLocal 1
 481: oPushResult
 482: oScopeDeclare
 483: oPop 1
 485: oGetLocal 3
 487: oPushResult
 488: oScopeEnter
 489: oPop 1
 491: oScopeBegin
 492: oScopeCurrent
 493: oPushResult
 494: oSetResult 3
 496: oPushResult
 497: oSetResult 1
 499: oPushResult
 500: oNodeSetBoolean
 501: oPop 3
 503: oGetLocal 1
 505: oPushResult
 506: oSetResult 10
 508: oPushResult
 509: oScopeCurrent
 510: oPushResult
 511: oNodeSet
 512: oPop 3
 514: oSetResult 13
 516: oPushResult
 517: oGetAddrLocal 5
 519: oPushResult
 520: oCall 155
 522: oPop 2
 524: oGetLocal 1
 526: oPushResult
 527: oSetResult 8
 529: oPushResult
 530: oGetLocal 5
 532: oPushResult
 533: oNodeSetInt
 534: oPop 3
 536: oGetLocal 1
 538: oPushResult
 539: oSetResult 11
 541: oPushResult
 542: oSetResult 1
 544: oPushResult
 545: oNodeSetBoolean
 546: oPop 3
 548: oScopeEnd
 549: oScopeEnd
 550: oInput 4
 552: oReturn
 553: oLocalSpace 6
 555: oInputChoice 776
 557: oGetAddrLocal 1
 559: oPushResult
 560: oNodeVecNew
 561: oAssign
 562: oGetAddrLocal 3
 564: oPushResult
 565: oSetResult 0
 567: oAssign
 568: oInputChoice 578
 570: oGetAddrLocal 3
 572: oPushResult
 573: oSetResult 1
 575: oAssign
 576: oJumpForward 581
 578: Choice Lookup Table
          31    570
 581: oInput 0
 583: oGetAddrLocal 2
 585: oPushResult
 586: oSetResult 15
 588: oPushResult
 589: oSetResult 6
 591: oPushResult
 592: LAST_ID
 593: oPushResult
 594: oCall 4452
 596: oPop 3
 598: oAssign
 599: oGetLocal 2
 601: oPushResult
 602: oSetResult 13
 604: oPushResult
 605: oGetLocal 3
 607: oPushResult
 608: oNodeSetBoolean
 609: oPop 3
 611: oGetLocal 1
 613: oPushResult
 614: oGetLocal 2
 616: oPushResult
 617: oNodeVecAppend
 618: oPop 2
 620: oInputChoice 628
 622: oJumpForward 636
 624: oJumpForward 634
 626: oJumpForward 634
 628: Choice Lookup Table
          12    626
          11    622
 633: oEndChoice
 634: oJumpBack 581
 636: oGetAddrLocal 4
 638: oPushResult
 639: oCall 1052
 641: oPop 1
 643: oGetLocal 3
 645: oChoice 660
 647: oGetAddrLocal 5
 649: oPushResult
 650: oGetLocal 4
 652: oPushResult
 653: oCall 4492
 655: oPop 1
 657: oAssign
 658: oJumpForward 669
 660: Choice Lookup Table
           1    647
 663: oGetAddrLocal 5
 665: oPushResult
 666: oGetLocal 4
 668: oAssign
 669: oGetAddrLocal 6
 671: oPushResult
 672: oSetResult 0
 674: oAssign
 675: oGetLocal 6
 677: oPushResult
 678: oGetLocal 1
 680: oPushResult
 681: oNodeVecSize
 682: oPop 1
 684: oPushResult
 685: equal
 686: oPop 2
 688: oChoice 745
 690: oGetAddrLocal 2
 692: oPushResult
 693: oGetLocal 1
 695: oPushResult
 696: oGetLocal 6
 698: oPushResult
 699: oNodeVecElement
 700: oPop 2
 702: oAssign
 703: oGetLocal 2
 705: oPushResult
 706: oSetResult 6
 708: oPushResult
 709: oGetLocal 4
 711: oPushResult
 712: oNodeSet
 713: oPop 3
 715: oGetLocal 2
 717: oPushResult
 718: oScopeDeclare
 719: oPop 1
 721: oGetLocal 2
 723: oPushResult
 724: oSetResult 8
 726: oPushResult
 727: oGetLocal 5
 729: oPushResult
 730: oScopeAllocType
 731: oPop 1
 733: oPushResult
 734: oNodeSetInt
 735: oPop 3
 737: oGetAddrLocal 6
 739: oPushResult
 740: inc
 741: oPop 1
 743: oJumpForward 750
 745: Choice Lookup Table
           0    690
 748: oJumpForward 752
 750: oJumpBack 675
 752: oGetLocal 1
 754: oPushResult
 755: oNodeVecDelete
 756: oPop 1
 758: oInputChoice 766
 760: oJumpForward 774
 762: oJumpForward 772
 764: oJumpForward 772
 766: Choice Lookup Table
           4    764
          14    760
 771: oEndChoice
 772: oJumpBack 557
 774: oJumpForward 779
 776: Choice Lookup Table
          13    557
 779: oReturn
 780: oLocalSpace 2
 782: oInputChoice 844
 784: oGetAddrLocal 1
 786: oPushResult
 787: oSetResult 9
 789: oPushResult
 790: oSetResult 4
 792: oPushResult
 793: LAST_ID
 794: oPushResult
 795: oCall 4452
 797: oPop 3
 799: oAssign
 800: oInput 5
 802: oCall 1521
 804: oGetAddrLocal 2
 806: oPushResult
 807: oValueTop
 808: oAssign
 809: oValuePop
 810: oGetLocal 1
 812: oPushResult
 813: oSetResult 8
 815: oPushResult
 816: oGetLocal 2
 818: oPushResult
 819: oNodeSetInt
 820: oPop 3
 822: oGetLocal 1
 824: oPushResult
 825: oSetResult 6
 827: oPushResult
 828: oGetGlobal 3
 830: oPushResult
 831: oNodeSet
 832: oPop 3
 834: oGetLocal 1
 836: oPushResult
 837: oScopeDeclare
 838: oPop 1
 840: oInput 4
 842: oJumpForward 849
 844: Choice Lookup Table
           0    784
 847: oJumpForward 851
 849: oJumpBack 782
 851: oReturn
 852: oLocalSpace 2
 854: oInputChoice 903
 856: oGetAddrLocal 1
 858: oPushResult
 859: oSetResult 10
 861: oPushResult
 862: oSetResult 5
 864: oPushResult
 865: LAST_ID
 866: oPushResult
 867: oCall 4452
 869: oPop 3
 871: oAssign
 872: oInput 5
 874: oGetAddrLocal 2
 876: oPushResult
 877: oCall 1052
 879: oPop 1
 881: oGetLocal 1
 883: oPushResult
 884: oSetResult 6
 886: oPushResult
 887: oGetLocal 2
 889: oPushResult
 890: oNodeSet
 891: oPop 3
 893: oGetLocal 1
 895: oPushResult
 896: oScopeDeclare
 897: oPop 1
 899: oInput 4
 901: oJumpForward 908
 903: Choice Lookup Table
           0    856
 906: oJumpForward 910
 908: oJumpBack 854
 910: oReturn
 911: oLocalSpace 4
 913: oInputChoice 1044
 915: oGetAddrLocal 1
 917: oPushResult
 918: oNodeVecNew
 919: oAssign
 920: oGetAddrLocal 2
 922: oPushResult
 923: oGetParam 1
 925: oPushResult
 926: oSetResult 6
 928: oPushResult
 929: LAST_ID
 930: oPushResult
 931: oCall 4452
 933: oPop 3
 935: oAssign
 936: oGetLocal 1
 938: oPushResult
 939: oGetLocal 2
 941: oPushResult
 942: oNodeVecAppend
 943: oPop 2
 945: oInputChoice 951
 947: oInput 0
 949: oJumpForward 956
 951: Choice Lookup Table
          12    947
 954: oJumpForward 958
 956: oJumpBack 920
 958: oInput 11
 960: oGetAddrLocal 3
 962: oPushResult
 963: oCall 1052
 965: oPop 1
 967: oGetAddrLocal 4
 969: oPushResult
 970: oSetResult 0
 972: oAssign
 973: oGetLocal 4
 975: oPushResult
 976: oGetLocal 1
 978: oPushResult
 979: oNodeVecSize
 980: oPop 1
 982: oPushResult
 983: equal
 984: oPop 2
 986: oChoice 1027
 988: oGetAddrLocal 2
 990: oPushResult
 991: oGetLocal 1
 993: oPushResult
 994: oGetLocal 4
 996: oPushResult
 997: oNodeVecElement
 998: oPop 2
1000: oAssign
1001: oGetLocal 2
1003: oPushResult
1004: oSetResult 6
1006: oPushResult
1007: oGetLocal 3
1009: oPushResult
1010: oNodeSet
1011: oPop 3
1013: oGetLocal 2
1015: oPushResult
1016: oScopeDeclareAlloc
1017: oPop 1
1019: oGetAddrLocal 4
1021: oPushResult
1022: inc
1023: oPop 1
1025: oJumpForward 1032
1027: Choice Lookup Table
           0    988
1030: oJumpForward 1034
1032: oJumpBack 973
1034: oGetLocal 1
1036: oPushResult
1037: oNodeVecDelete
1038: oPop 1
1040: oInput 4
1042: oJumpForward 1049
1044: Choice Lookup Table
           0    915
1047: oJumpForward 1051
1049: oJumpBack 913
1051: oReturn
1052: oLocalSpace 12
1054: oInputChoice 1503
1056: oGetAddrLocal 1
1058: oPushResult
1059: oScopeFindRequire
1060: oAssign
1061: oGetLocal 1
1063: oPushResult
1064: oNodeType
1065: oPop 1
1067: oChoice 1084
1069: oGetParam 1
1071: oPushResult
1072: oGetLocal 1
1074: oPushResult
1075: oSetResult 6
1077: oPushResult
1078: oNodeGet
1079: oPop 2
1081: oAssign
1082: oJumpForward 1095
1084: Choice Lookup Table
          10   1069
1087: oError 2
1089: oGetParam 1
1091: oPushResult
1092: oGetGlobal 3
1094: oAssign
1095: oJumpForward 1520
1097: oInput 15
1099: oGetAddrLocal 2
1101: oPushResult
1102: oNodeVecNew
1103: oAssign
1104: oGetAddrLocal 3
1106: oPushResult
1107: oSetResult 24
1109: oPushResult
1110: oNodeNew
1111: oPop 1
1113: oAssign
1114: oGetLocal 3
1116: oPushResult
1117: oSetResult 15
1119: oPushResult
1120: oGetGlobal 3
1122: oPushResult
1123: oNodeSet
1124: oPop 3
1126: oCall 1521
1128: oGetLocal 3
1130: oPushResult
1131: oSetResult 17
1133: oPushResult
1134: oValueTop
1135: oPushResult
1136: oNodeSetInt
1137: oPop 3
1139: oValuePop
1140: oInput 19
1142: oCall 1521
1144: oGetLocal 3
1146: oPushResult
1147: oSetResult 18
1149: oPushResult
1150: oValueTop
1151: oPushResult
1152: oNodeSetInt
1153: oPop 3
1155: oValuePop
1156: oGetLocal 3
1158: oPushResult
1159: oSetResult 2
1161: oPushResult
1162: oSetResult 4
1164: oPushResult
1165: oNodeSetInt
1166: oPop 3
1168: oGetLocal 3
1170: oPushResult
1171: oTypeAdd
1172: oPop 1
1174: oGetAddrLocal 4
1176: oPushResult
1177: oSetResult 23
1179: oPushResult
1180: oNodeNew
1181: oPop 1
1183: oAssign
1184: oGetLocal 4
1186: oPushResult
1187: oSetResult 16
1189: oPushResult
1190: oGetLocal 3
1192: oPushResult
1193: oNodeSet
1194: oPop 3
1196: oGetLocal 2
1198: oPushResult
1199: oGetLocal 4
1201: oPushResult
1202: oNodeVecAppend
1203: oPop 2
1205: oInputChoice 1213
1207: oJumpForward 1221
1209: oJumpForward 1219
1211: oJumpForward 1219
1213: Choice Lookup Table
          12   1211
          16   1207
1218: oEndChoice
1219: oJumpBack 1104
1221: oInput 37
1223: oGetAddrLocal 5
1225: oPushResult
1226: oCall 1052
1228: oPop 1
1230: oGetAddrLocal 6
1232: oPushResult
1233: oGetLocal 2
1235: oPushResult
1236: oNodeVecSize
1237: oPop 1
1239: oAssign
1240: oGetAddrLocal 6
1242: oPushResult
1243: dec
1244: oPop 1
1246: oGetAddrLocal 4
1248: oPushResult
1249: oGetLocal 2
1251: oPushResult
1252: oGetLocal 6
1254: oPushResult
1255: oNodeVecElement
1256: oPop 2
1258: oAssign
1259: oGetLocal 4
1261: oPushResult
1262: oSetResult 15
1264: oPushResult
1265: oGetLocal 5
1267: oPushResult
1268: oNodeSet
1269: oPop 3
1271: oGetAddrLocal 3
1273: oPushResult
1274: oGetLocal 4
1276: oPushResult
1277: oSetResult 16
1279: oPushResult
1280: oNodeGet
1281: oPop 2
1283: oAssign
1284: oGetAddrLocal 9
1286: oPushResult
1287: oGetLocal 3
1289: oPushResult
1290: oSetResult 18
1292: oPushResult
1293: oNodeGetInt
1294: oPop 2
1296: oPushResult
1297: oGetLocal 3
1299: oPushResult
1300: oSetResult 17
1302: oPushResult
1303: oNodeGetInt
1304: oPop 2
1306: oPushResult
1307: subtract
1308: oPop 2
1310: oAssign
1311: oGetAddrLocal 9
1313: oPushResult
1314: inc
1315: oPop 1
1317: oGetLocal 4
1319: oPushResult
1320: oSetResult 2
1322: oPushResult
1323: oGetLocal 9
1325: oPushResult
1326: oGetLocal 5
1328: oPushResult
1329: oSetResult 2
1331: oPushResult
1332: oNodeGetInt
1333: oPop 2
1335: oPushResult
1336: multiply
1337: oPop 2
1339: oPushResult
1340: oNodeSetInt
1341: oPop 3
1343: oGetLocal 4
1345: oPushResult
1346: oTypeAdd
1347: oPop 1
1349: oGetAddrLocal 5
1351: oPushResult
1352: oGetLocal 4
1354: oAssign
1355: oGetLocal 6
1357: oPushResult
1358: equal_zero
1359: oPop 1
1361: oChoice 1367
1363: oJumpForward 1372
1365: oJumpForward 1370
1367: Choice Lookup Table
           1   1363
1370: oJumpBack 1240
1372: oGetParam 1
1374: oPushResult
1375: oGetLocal 2
1377: oPushResult
1378: oSetResult 0
1380: oPushResult
1381: oNodeVecElement
1382: oPop 2
1384: oAssign
1385: oGetLocal 2
1387: oPushResult
1388: oNodeVecDelete
1389: oPop 1
1391: oJumpForward 1520
1393: oGetAddrLocal 10
1395: oPushResult
1396: oCall 1052
1398: oPop 1
1400: oGetParam 1
1402: oPushResult
1403: oGetLocal 10
1405: oPushResult
1406: oCall 4492
1408: oPop 1
1410: oAssign
1411: oJumpForward 1520
1413: oGetParam 1
1415: oPushResult
1416: oSetResult 25
1418: oPushResult
1419: oNodeNew
1420: oPop 1
1422: oAssign
1423: oScopeBegin
1424: oSetResult 14
1426: oPushResult
1427: oCall 911
1429: oPop 1
1431: oGetAddrLocal 11
1433: oPushResult
1434: oScopeCurrent
1435: oPushResult
1436: oSetResult 2
1438: oPushResult
1439: oNodeGetInt
1440: oPop 2
1442: oAssign
1443: oGetLocal 11
1445: oPushResult
1446: equal_zero
1447: oPop 1
1449: oChoice 1455
1451: oError 19
1453: oJumpForward 1458
1455: Choice Lookup Table
           1   1451
1458: oInput 33
1460: oGetFromParam 1
1462: oPushResult
1463: oSetResult 19
1465: oPushResult
1466: oScopeCurrent
1467: oPushResult
1468: oNodeSet
1469: oPop 3
1471: oGetFromParam 1
1473: oPushResult
1474: oSetResult 2
1476: oPushResult
1477: oGetLocal 11
1479: oPushResult
1480: oNodeSetInt
1481: oPop 3
1483: oScopeEnd
1484: oGetFromParam 1
1486: oPushResult
1487: oTypeAdd
1488: oPop 1
1490: oJumpForward 1520
1492: oInput 37
1494: oGetAddrLocal 10
1496: oPushResult
1497: oCall 1052
1499: oPop 1
1501: oJumpForward 1520
1503: Choice Lookup Table
          36   1492
          35   1413
          17   1393
          34   1097
           0   1056
1514: oCall 1521
1516: oInput 19
1518: oCall 1521
1520: oReturn
1521: oLocalSpace 1
1523: oInputChoice 1578
1525: TOKEN_VALUE
1526: oPushResult
1527: oValuePush
1528: oPop 1
1530: oJumpForward 1586
1532: oGetAddrLocal 1
1534: oPushResult
1535: oScopeFindRequire
1536: oAssign
1537: oGetLocal 1
1539: oPushResult
1540: oNodeType
1541: oPop 1
1543: oChoice 1560
1545: oGetLocal 1
1547: oPushResult
1548: oSetResult 8
1550: oPushResult
1551: oNodeGetInt
1552: oPop 2
1554: oPushResult
1555: oValuePush
1556: oPop 1
1558: oJumpForward 1571
1560: Choice Lookup Table
           9   1545
1563: oError 1
1565: oSetResult 0
1567: oPushResult
1568: oValuePush
1569: oPop 1
1571: oJumpForward 1586
1573: oCall 1521
1575: oValueNegate
1576: oJumpForward 1586
1578: Choice Lookup Table
          23   1573
           0   1532
           1   1525
1585: oEndChoice
1586: oReturn
1587: oLocalSpace 0
1589: oCall 1833
1591: oInputChoice 1815
1593: oCall 1833
1595: oCall 4338
1597: oTypeSNodeType
1598: oChoice 1612
1600: oEmit 32
1602: oJumpForward 1625
1604: oEmit 38
1606: oJumpForward 1625
1608: oError 16
1610: oJumpForward 1625
1612: Choice Lookup Table
          21   1608
          20   1608
          22   1604
          19   1600
          18   1600
1623: oError 17
1625: oTypeSPop
1626: oGetGlobal 4
1628: oPushResult
1629: oTypeSPush
1630: oPop 1
1632: oJumpForward 1830
1634: oCall 1833
1636: oCall 4338
1638: oTypeSNodeType
1639: oChoice 1653
1641: oEmit 33
1643: oJumpForward 1666
1645: oEmit 39
1647: oJumpForward 1666
1649: oError 16
1651: oJumpForward 1666
1653: Choice Lookup Table
          21   1649
          20   1649
          22   1645
          19   1641
          18   1641
1664: oError 17
1666: oTypeSPop
1667: oGetGlobal 4
1669: oPushResult
1670: oTypeSPush
1671: oPop 1
1673: oJumpForward 1830
1675: oCall 1833
1677: oCall 4338
1679: oTypeSNodeType
1680: oChoice 1690
1682: oEmit 35
1684: oJumpForward 1701
1686: oError 16
1688: oJumpForward 1701
1690: Choice Lookup Table
          21   1686
          20   1686
          19   1682
          18   1682
1699: oError 17
1701: oTypeSPop
1702: oGetGlobal 4
1704: oPushResult
1705: oTypeSPush
1706: oPop 1
1708: oJumpForward 1830
1710: oCall 1833
1712: oCall 4338
1714: oTypeSNodeType
1715: oChoice 1725
1717: oEmit 34
1719: oJumpForward 1736
1721: oError 16
1723: oJumpForward 1736
1725: Choice Lookup Table
          21   1721
          20   1721
          19   1717
          18   1717
1734: oError 17
1736: oTypeSPop
1737: oGetGlobal 4
1739: oPushResult
1740: oTypeSPush
1741: oPop 1
1743: oJumpForward 1830
1745: oCall 1833
1747: oCall 4338
1749: oTypeSNodeType
1750: oChoice 1760
1752: oEmit 37
1754: oJumpForward 1771
1756: oError 16
1758: oJumpForward 1771
1760: Choice Lookup Table
          21   1756
          20   1756
          19   1752
          18   1752
1769: oError 17
1771: oTypeSPop
1772: oGetGlobal 4
1774: oPushResult
1775: oTypeSPush
1776: oPop 1
1778: oJumpForward 1830
1780: oCall 1833
1782: oCall 4338
1784: oTypeSNodeType
1785: oChoice 1795
1787: oEmit 36
1789: oJumpForward 1806
1791: oError 16
1793: oJumpForward 1806
1795: Choice Lookup Table
          21   1791
          20   1791
          19   1787
          18   1787
1804: oError 17
1806: oTypeSPop
1807: oGetGlobal 4
1809: oPushResult
1810: oTypeSPush
1811: oPop 1
1813: oJumpForward 1830
1815: Choice Lookup Table
          10   1780
           9   1745
           8   1710
           7   1675
           6   1634
           5   1593
1828: oJumpForward 1832
1830: oJumpBack 1591
1832: oReturn
1833: oLocalSpace 0
1835: oCall 1857
1837: oInputChoice 1849
1839: oCall 4391
1841: oCall 1857
1843: oCall 4405
1845: oEmit 31
1847: oJumpForward 1854
1849: Choice Lookup Table
          52   1839
1852: oJumpForward 1856
1854: oJumpBack 1837
1856: oReturn
1857: oLocalSpace 0
1859: oCall 1881
1861: oInputChoice 1873
1863: oCall 4391
1865: oCall 1881
1867: oCall 4405
1869: oEmit 30
1871: oJumpForward 1878
1873: Choice Lookup Table
          51   1863
1876: oJumpForward 1880
1878: oJumpBack 1861
1880: oReturn
1881: oLocalSpace 0
1883: oInputChoice 1893
1885: oCall 1899
1887: oCall 4405
1889: oEmit 29
1891: oJumpForward 1898
1893: Choice Lookup Table
          53   1885
1896: oCall 1899
1898: oReturn
1899: oLocalSpace 0
1901: oCall 1935
1903: oInputChoice 1925
1905: oCall 4364
1907: oCall 1935
1909: oCall 4378
1911: oEmit 26
1913: oJumpForward 1932
1915: oCall 4364
1917: oCall 1935
1919: oCall 4378
1921: oEmit 27
1923: oJumpForward 1932
1925: Choice Lookup Table
          23   1915
          22   1905
1930: oJumpForward 1934
1932: oJumpBack 1903
1934: oReturn
1935: oLocalSpace 0
1937: oCall 1971
1939: oInputChoice 1961
1941: oCall 4364
1943: oCall 1971
1945: oCall 4378
1947: oEmit 24
1949: oJumpForward 1968
1951: oCall 4364
1953: oCall 1971
1955: oCall 4378
1957: oEmit 25
1959: oJumpForward 1968
1961: Choice Lookup Table
          21   1951
          20   1941
1966: oJumpForward 1970
1968: oJumpBack 1939
1970: oReturn
1971: oLocalSpace 0
1973: oInputChoice 1989
1975: oCall 1997
1977: oCall 4378
1979: oJumpForward 1996
1981: oCall 1997
1983: oCall 4378
1985: oEmit 28
1987: oJumpForward 1996
1989: Choice Lookup Table
          23   1981
          22   1975
1994: oCall 1997
1996: oReturn
1997: oLocalSpace 5
1999: oInputChoice 2172
2001: oEmit 9
2003: TOKEN_VALUE
2004: oPushResult
2005: oEmitInt
2006: oPop 1
2008: oGetGlobal 3
2010: oPushResult
2011: oTypeSPush
2012: oPop 1
2014: oJumpForward 2191
2016: oCall 1587
2018: oInput 14
2020: oJumpForward 2191
2022: oStringAllocLit
2023: oEmit 10
2025: oValueTop
2026: oPushResult
2027: oEmitInt
2028: oPop 1
2030: oValuePop
2031: oGetGlobal 6
2033: oPushResult
2034: oTypeSPush
2035: oPop 1
2037: oJumpForward 2191
2039: oGetAddrLocal 1
2041: oPushResult
2042: oScopeFindRequire
2043: oAssign
2044: oGetLocal 1
2046: oPushResult
2047: oNodeType
2048: oPop 1
2050: oChoice 2112
2052: oGetLocal 1
2054: oPushResult
2055: oCall 2914
2057: oPop 1
2059: oJumpForward 2131
2061: oGetAddrLocal 2
2063: oPushResult
2064: oGetLocal 1
2066: oPushResult
2067: oSetResult 6
2069: oPushResult
2070: oNodeGet
2071: oPop 2
2073: oAssign
2074: oGetLocal 2
2076: oPushResult
2077: oTypeSPush
2078: oPop 1
2080: oTypeSNodeType
2081: oChoice 2094
2083: oEmit 9
2085: oGetLocal 1
2087: oPushResult
2088: oCall 4628
2090: oPop 1
2092: oJumpForward 2101
2094: Choice Lookup Table
          19   2083
          18   2083
2099: oError 16
2101: oJumpForward 2131
2103: oGetLocal 1
2105: oPushResult
2106: oCall 2192
2108: oPop 1
2110: oJumpForward 2131
2112: Choice Lookup Table
          15   2103
          13   2103
          12   2103
           9   2061
           8   2052
2123: oError 6
2125: oGetGlobal 3
2127: oPushResult
2128: oTypeSPush
2129: oPop 1
2131: oJumpForward 2191
2133: oInput 0
2135: oGetAddrLocal 1
2137: oPushResult
2138: oScopeFindRequire
2139: oAssign
2140: oGetLocal 1
2142: oPushResult
2143: oCall 3675
2145: oPop 1
2147: oGetAddrLocal 2
2149: oPushResult
2150: oTypeSTop
2151: oAssign
2152: oTypeSPop
2153: oGetAddrLocal 5
2155: oPushResult
2156: oGetLocal 2
2158: oPushResult
2159: oCall 4492
2161: oPop 1
2163: oAssign
2164: oGetLocal 5
2166: oPushResult
2167: oTypeSPush
2168: oPop 1
2170: oJumpForward 2191
2172: Choice Lookup Table
          17   2133
           0   2039
           2   2022
          13   2016
           1   2001
2183: oError 6
2185: oGetGlobal 3
2187: oPushResult
2188: oTypeSPush
2189: oPop 1
2191: oReturn
2192: oLocalSpace 1
2194: oGetAddrLocal 1
2196: oPushResult
2197: oGetParam 1
2199: oPushResult
2200: oSetResult 6
2202: oPushResult
2203: oNodeGet
2204: oPop 2
2206: oAssign
2207: oGetLocal 1
2209: oPushResult
2210: oTypeSPush
2211: oPop 1
2213: oTypeSNodeType
2214: oChoice 2479
2216: oGetParam 1
2218: oPushResult
2219: oNodeType
2220: oPop 1
2222: oChoice 2284
2224: oEmit 0
2226: oGetParam 1
2228: oPushResult
2229: oCall 4628
2231: oPop 1
2233: oJumpForward 2292
2235: oEmit 3
2237: oGetParam 1
2239: oPushResult
2240: oCall 4628
2242: oPop 1
2244: oJumpForward 2292
2246: oGetParam 1
2248: oPushResult
2249: oSetResult 13
2251: oPushResult
2252: oNodeGetBoolean
2253: oPop 2
2255: oChoice 2270
2257: oEmit 8
2259: oGetParam 1
2261: oPushResult
2262: oCall 4628
2264: oPop 1
2266: oEmit 15
2268: oJumpForward 2282
2270: Choice Lookup Table
           1   2257
2273: oEmit 6
2275: oGetParam 1
2277: oPushResult
2278: oCall 4628
2280: oPop 1
2282: oJumpForward 2292
2284: Choice Lookup Table
          15   2246
          13   2235
          12   2224
2291: oEndChoice
2292: oJumpForward 2570
2294: oGetParam 1
2296: oPushResult
2297: oNodeType
2298: oPop 1
2300: oChoice 2362
2302: oEmit 1
2304: oGetParam 1
2306: oPushResult
2307: oCall 4628
2309: oPop 1
2311: oJumpForward 2370
2313: oEmit 4
2315: oGetParam 1
2317: oPushResult
2318: oCall 4628
2320: oPop 1
2322: oJumpForward 2370
2324: oGetParam 1
2326: oPushResult
2327: oSetResult 13
2329: oPushResult
2330: oNodeGetBoolean
2331: oPop 2
2333: oChoice 2348
2335: oEmit 8
2337: oGetParam 1
2339: oPushResult
2340: oCall 4628
2342: oPop 1
2344: oEmit 16
2346: oJumpForward 2360
2348: Choice Lookup Table
           1   2335
2351: oEmit 7
2353: oGetParam 1
2355: oPushResult
2356: oCall 4628
2358: oPop 1
2360: oJumpForward 2370
2362: Choice Lookup Table
          15   2324
          13   2313
          12   2302
2369: oEndChoice
2370: oJumpForward 2570
2372: oError 16
2374: oJumpForward 2570
2376: oGetParam 1
2378: oPushResult
2379: oNodeType
2380: oPop 1
2382: oChoice 2444
2384: oEmit 2
2386: oGetParam 1
2388: oPushResult
2389: oCall 4628
2391: oPop 1
2393: oJumpForward 2452
2395: oEmit 5
2397: oGetParam 1
2399: oPushResult
2400: oCall 4628
2402: oPop 1
2404: oJumpForward 2452
2406: oGetParam 1
2408: oPushResult
2409: oSetResult 13
2411: oPushResult
2412: oNodeGetBoolean
2413: oPop 2
2415: oChoice 2430
2417: oEmit 8
2419: oGetParam 1
2421: oPushResult
2422: oCall 4628
2424: oPop 1
2426: oEmit 17
2428: oJumpForward 2442
2430: Choice Lookup Table
           1   2417
2433: oEmit 8
2435: oGetParam 1
2437: oPushResult
2438: oCall 4628
2440: oPop 1
2442: oJumpForward 2452
2444: Choice Lookup Table
          15   2406
          13   2395
          12   2384
2451: oEndChoice
2452: oInputChoice 2474
2454: oTypeSPop
2455: oGetLocal 1
2457: oPushResult
2458: oSetResult 15
2460: oPushResult
2461: oNodeGet
2462: oPop 2
2464: oPushResult
2465: oTypeSPush
2466: oPop 1
2468: oCall 2606
2470: oCall 2571
2472: oJumpForward 2477
2474: Choice Lookup Table
          17   2454
2477: oJumpForward 2570
2479: Choice Lookup Table
          22   2376
          17   2372
          21   2372
          20   2372
          19   2294
          18   2216
2492: oGetParam 1
2494: oPushResult
2495: oNodeType
2496: oPop 1
2498: oChoice 2558
2500: oEmit 11
2502: oGetParam 1
2504: oPushResult
2505: oCall 4628
2507: oPop 1
2509: oJumpForward 2566
2511: oEmit 12
2513: oGetParam 1
2515: oPushResult
2516: oCall 4628
2518: oPop 1
2520: oJumpForward 2566
2522: oGetParam 1
2524: oPushResult
2525: oSetResult 13
2527: oPushResult
2528: oNodeGetBoolean
2529: oPop 2
2531: oChoice 2544
2533: oEmit 8
2535: oGetParam 1
2537: oPushResult
2538: oCall 4628
2540: oPop 1
2542: oJumpForward 2556
2544: Choice Lookup Table
           1   2533
2547: oEmit 13
2549: oGetParam 1
2551: oPushResult
2552: oCall 4628
2554: oPop 1
2556: oJumpForward 2566
2558: Choice Lookup Table
          15   2522
          13   2511
          12   2500
2565: oEndChoice
2566: oCall 2606
2568: oCall 2571
2570: oReturn
2571: oLocalSpace 0
2573: oTypeSNodeType
2574: oChoice 2592
2576: oEmit 15
2578: oJumpForward 2605
2580: oEmit 16
2582: oJumpForward 2605
2584: oError 16
2586: oJumpForward 2605
2588: oEmit 17
2590: oJumpForward 2605
2592: Choice Lookup Table
          22   2588
          17   2584
          21   2584
          20   2584
          19   2580
          18   2576
2605: oReturn
2606: oLocalSpace 0
2608: oInputChoice 2622
2610: oCall 2634
2612: oJumpForward 2631
2614: oCall 2777
2616: oJumpForward 2631
2618: oCall 2875
2620: oJumpForward 2631
2622: Choice Lookup Table
          17   2618
          18   2614
          15   2610
2629: oJumpForward 2633
2631: oJumpBack 2608
2633: oReturn
2634: oLocalSpace 3
2636: oTypeSNodeType
2637: oChoice 2641
2639: oJumpForward 2646
2641: Choice Lookup Table
          23   2639
2644: oError 10
2646: oTypeSNodeType
2647: oChoice 2651
2649: oJumpForward 2656
2651: Choice Lookup Table
          23   2649
2654: oError 13
2656: oGetAddrLocal 1
2658: oPushResult
2659: oTypeSTop
2660: oPushResult
2661: oSetResult 16
2663: oPushResult
2664: oNodeGet
2665: oPop 2
2667: oPushResult
2668: oCall 4576
2670: oPop 1
2672: oAssign
2673: oGetAddrLocal 2
2675: oPushResult
2676: oTypeSTop
2677: oPushResult
2678: oSetResult 15
2680: oPushResult
2681: oNodeGet
2682: oPop 2
2684: oAssign
2685: oTypeSPop
2686: oGetLocal 2
2688: oPushResult
2689: oTypeSPush
2690: oPop 1
2692: oCall 1587
2694: oCall 4364
2696: oGetLocal 1
2698: oPushResult
2699: equal_zero
2700: oPop 1
2702: oChoice 2716
2704: oEmit 9
2706: oGetLocal 1
2708: oPushResult
2709: oEmitInt
2710: oPop 1
2712: oEmit 27
2714: oJumpForward 2719
2716: Choice Lookup Table
           0   2704
2719: oGetAddrLocal 3
2721: oPushResult
2722: oGetLocal 2
2724: oPushResult
2725: oSetResult 2
2727: oPushResult
2728: oNodeGetInt
2729: oPop 2
2731: oAssign
2732: oGetLocal 3
2734: oPushResult
2735: oSetResult 1
2737: oPushResult
2738: equal
2739: oPop 2
2741: oChoice 2755
2743: oEmit 9
2745: oGetLocal 3
2747: oPushResult
2748: oEmitInt
2749: oPop 1
2751: oEmit 24
2753: oJumpForward 2758
2755: Choice Lookup Table
           0   2743
2758: oEmit 26
2760: oInputChoice 2768
2762: oJumpForward 2776
2764: oJumpForward 2774
2766: oJumpForward 2774
2768: Choice Lookup Table
          12   2766
          16   2762
2773: oEndChoice
2774: oJumpBack 2646
2776: oReturn
2777: oLocalSpace 2
2779: oTypeSNodeType
2780: oChoice 2784
2782: oJumpForward 2789
2784: Choice Lookup Table
          25   2782
2787: oError 11
2789: oTypeSTop
2790: oPushResult
2791: oSetResult 19
2793: oPushResult
2794: oNodeGet
2795: oPop 2
2797: oPushResult
2798: oScopeEnter
2799: oPop 1
2801: oInput 0
2803: oGetAddrLocal 1
2805: oPushResult
2806: oScopeFindRequire
2807: oAssign
2808: oGetLocal 1
2810: oPushResult
2811: oNodeType
2812: oPop 1
2814: oChoice 2818
2816: oJumpForward 2823
2818: Choice Lookup Table
          14   2816
2821: oError 12
2823: oScopeEnd
2824: oGetAddrLocal 2
2826: oPushResult
2827: oGetLocal 1
2829: oPushResult
2830: oSetResult 8
2832: oPushResult
2833: oNodeGetInt
2834: oPop 2
2836: oAssign
2837: oGetLocal 2
2839: oPushResult
2840: equal_zero
2841: oPop 1
2843: oChoice 2857
2845: oEmit 9
2847: oGetLocal 2
2849: oPushResult
2850: oEmitInt
2851: oPop 1
2853: oEmit 26
2855: oJumpForward 2860
2857: Choice Lookup Table
           0   2845
2860: oTypeSPop
2861: oGetLocal 1
2863: oPushResult
2864: oSetResult 6
2866: oPushResult
2867: oNodeGet
2868: oPop 2
2870: oPushResult
2871: oTypeSPush
2872: oPop 1
2874: oReturn
2875: oLocalSpace 1
2877: oTypeSNodeType
2878: oChoice 2882
2880: oJumpForward 2887
2882: Choice Lookup Table
          22   2880
2885: oError 9
2887: oEmit 17
2889: oGetAddrLocal 1
2891: oPushResult
2892: oTypeSTop
2893: oAssign
2894: oTypeSPop
2895: oGetLocal 1
2897: oPushResult
2898: oSetResult 15
2900: oPushResult
2901: oNodeGet
2902: oPop 2
2904: oPushResult
2905: oTypeSPush
2906: oPop 1
2908: oReturn
2909: oLocalSpace 0
2911: oCall 4338
2913: oReturn
2914: oLocalSpace 9
2916: oGetAddrLocal 1
2918: oPushResult
2919: oGetParam 1
2921: oPushResult
2922: oNodeType
2923: oPop 1
2925: oPushResult
2926: oSetResult 8
2928: oPushResult
2929: equal_node_type
2930: oPop 2
2932: oAssign
2933: oGetLocal 1
2935: oChoice 2974
2937: oGetAddrLocal 2
2939: oPushResult
2940: oGetParam 1
2942: oPushResult
2943: oSetResult 6
2945: oPushResult
2946: oNodeGet
2947: oPop 2
2949: oAssign
2950: oGetAddrLocal 3
2952: oPushResult
2953: oGetLocal 2
2955: oPushResult
2956: oScopeAllocType
2957: oPop 1
2959: oAssign
2960: oGetAddrLocal 4
2962: oPushResult
2963: oScopeCurrent
2964: oPushResult
2965: oGetGlobal 1
2967: oPushResult
2968: oNodeEqual
2969: oPop 2
2971: oAssign
2972: oJumpForward 2977
2974: Choice Lookup Table
           1   2937
2977: oGetAddrLocal 5
2979: oPushResult
2980: oGetParam 1
2982: oPushResult
2983: oSetResult 9
2985: oPushResult
2986: oNodeGet
2987: oPop 2
2989: oAssign
2990: oGetAddrLocal 6
2992: oPushResult
2993: oGetLocal 5
2995: oPushResult
2996: oSetResult 2
2998: oPushResult
2999: oNodeGetInt
3000: oPop 2
3002: oAssign
3003: oEmit 40
3005: oGetLocal 6
3007: oPushResult
3008: oEmitInt
3009: oPop 1
3011: oGetAddrLocal 7
3013: oPushResult
3014: oGetLocal 5
3016: oPushResult
3017: oSetResult 1
3019: oPushResult
3020: oNodeGet
3021: oPop 2
3023: oAssign
3024: oInputChoice 3193
3026: oGetLocal 7
3028: oPushResult
3029: oNodeNull
3030: oPop 1
3032: oChoice 3038
3034: oJumpForward 3189
3036: oJumpForward 3041
3038: Choice Lookup Table
           1   3034
3041: oGetAddrLocal 8
3043: oPushResult
3044: oGetLocal 7
3046: oPushResult
3047: oSetResult 8
3049: oPushResult
3050: oNodeGetInt
3051: oPop 2
3053: oAssign
3054: oEmit 14
3056: oGetLocal 8
3058: oPushResult
3059: oEmitInt
3060: oPop 1
3062: oGetLocal 7
3064: oPushResult
3065: oSetResult 6
3067: oPushResult
3068: oNodeGet
3069: oPop 2
3071: oPushResult
3072: oTypeSPush
3073: oPop 1
3075: oGetLocal 7
3077: oPushResult
3078: oSetResult 13
3080: oPushResult
3081: oNodeGetBoolean
3082: oPop 2
3084: oChoice 3152
3086: oCall 3639
3088: oCall 4338
3090: oEmit 20
3092: oJumpForward 3158
3094: oCall 1587
3096: oCall 2909
3098: oTypeSNodeType
3099: oChoice 3117
3101: oEmit 18
3103: oJumpForward 3150
3105: oEmit 19
3107: oJumpForward 3150
3109: oError 16
3111: oJumpForward 3150
3113: oEmit 20
3115: oJumpForward 3150
3117: Choice Lookup Table
          22   3113
          17   3109
          21   3109
          20   3109
          19   3105
          18   3101
3130: oGetAddrLocal 9
3132: oPushResult
3133: oTypeSTop
3134: oPushResult
3135: oSetResult 2
3137: oPushResult
3138: oNodeGetInt
3139: oPop 2
3141: oAssign
3142: oEmit 21
3144: oGetLocal 9
3146: oPushResult
3147: oEmitInt
3148: oPop 1
3150: oJumpForward 3158
3152: Choice Lookup Table
           0   3094
           1   3086
3157: oEndChoice
3158: oTypeSPop
3159: oGetAddrLocal 7
3161: oPushResult
3162: oNodeNext
3163: oPop 1
3165: oGetLocal 7
3167: oPushResult
3168: oNodeNull
3169: oPop 1
3171: oChoice 3179
3173: oJumpForward 3189
3175: oJumpForward 3185
3177: oJumpForward 3185
3179: Choice Lookup Table
           0   3177
           1   3173
3184: oEndChoice
3185: oInput 12
3187: oJumpBack 3026
3189: oInput 14
3191: oJumpForward 3196
3193: Choice Lookup Table
          13   3026
3196: oGetLocal 7
3198: oPushResult
3199: oNodeNull
3200: oPop 1
3202: oChoice 3208
3204: oError 15
3206: oJumpForward 3211
3208: Choice Lookup Table
           0   3204
3211: oGetLocal 1
3213: oChoice 3259
3215: oEmit 14
3217: oGetParam 1
3219: oPushResult
3220: oSetResult 12
3222: oPushResult
3223: oNodeGetInt
3224: oPop 2
3226: oPushResult
3227: oEmitInt
3228: oPop 1
3230: oGetLocal 4
3232: oChoice 3244
3234: oEmit 11
3236: oGetLocal 3
3238: oPushResult
3239: oEmitInt
3240: oPop 1
3242: oJumpForward 3255
3244: Choice Lookup Table
           1   3234
3247: oEmit 12
3249: oGetLocal 3
3251: oPushResult
3252: oEmitInt
3253: oPop 1
3255: oEmit 20
3257: oJumpForward 3262
3259: Choice Lookup Table
           1   3215
3262: oEmit 42
3264: oGetParam 1
3266: oPushResult
3267: oCall 4628
3269: oPop 1
3271: oGetLocal 1
3273: oChoice 3310
3275: oGetLocal 2
3277: oPushResult
3278: oTypeSPush
3279: oPop 1
3281: oGetLocal 4
3283: oChoice 3295
3285: oEmit 11
3287: oGetLocal 3
3289: oPushResult
3290: oEmitInt
3291: oPop 1
3293: oJumpForward 3306
3295: Choice Lookup Table
           1   3285
3298: oEmit 12
3300: oGetLocal 3
3302: oPushResult
3303: oEmitInt
3304: oPop 1
3306: oCall 2571
3308: oJumpForward 3313
3310: Choice Lookup Table
           1   3275
3313: oEmit 41
3315: oGetLocal 6
3317: oPushResult
3318: oEmitInt
3319: oPop 1
3321: oReturn
3322: oLocalSpace 0
3324: oInputChoice 3374
3326: oCall 4235
3328: oJumpForward 3399
3330: oCall 4242
3332: oJumpForward 3399
3334: oCall 4309
3336: oJumpForward 3399
3338: oCall 4312
3340: oJumpForward 3399
3342: oCall 3768
3344: oJumpForward 3399
3346: oCall 4096
3348: oJumpForward 3399
3350: oCall 3826
3352: oJumpForward 3399
3354: oCall 4047
3356: oJumpForward 3399
3358: oCall 4183
3360: oJumpForward 3399
3362: oCall 4151
3364: oJumpForward 3399
3366: oCall 4212
3368: oJumpForward 3399
3370: oCall 3400
3372: oJumpForward 3399
3374: Choice Lookup Table
           0   3370
          32   3366
          48   3362
          49   3358
          46   3354
          41   3350
          45   3346
          38   3342
          57   3338
          56   3334
          55   3330
          54   3326
3399: oReturn
3400: oLocalSpace 1
3402: oGetAddrLocal 1
3404: oPushResult
3405: oScopeFindRequire
3406: oAssign
3407: oGetLocal 1
3409: oPushResult
3410: oNodeType
3411: oPop 1
3413: oChoice 3442
3415: oGetLocal 1
3417: oPushResult
3418: oCall 2914
3420: oPop 1
3422: oJumpForward 3455
3424: oGetLocal 1
3426: oPushResult
3427: oCall 3456
3429: oPop 1
3431: oJumpForward 3455
3433: oGetLocal 1
3435: oPushResult
3436: oCall 3525
3438: oPop 1
3440: oJumpForward 3455
3442: Choice Lookup Table
           8   3433
          15   3424
          13   3424
          12   3424
           7   3415
3453: oError 0
3455: oReturn
3456: oLocalSpace 1
3458: oGetParam 1
3460: oPushResult
3461: oCall 3675
3463: oPop 1
3465: oInput 3
3467: oCall 1587
3469: oCall 4338
3471: oTypeSNodeType
3472: oChoice 3490
3474: oEmit 18
3476: oJumpForward 3523
3478: oEmit 19
3480: oJumpForward 3523
3482: oError 16
3484: oJumpForward 3523
3486: oEmit 20
3488: oJumpForward 3523
3490: Choice Lookup Table
          22   3486
          17   3482
          21   3482
          20   3482
          19   3478
          18   3474
3503: oGetAddrLocal 1
3505: oPushResult
3506: oTypeSTop
3507: oPushResult
3508: oSetResult 2
3510: oPushResult
3511: oNodeGetInt
3512: oPop 2
3514: oAssign
3515: oEmit 21
3517: oGetLocal 1
3519: oPushResult
3520: oEmitInt
3521: oPop 1
3523: oTypeSPop
3524: oReturn
3525: oLocalSpace 1
3527: oGetParam 1
3529: oPushResult
3530: oSetResult 10
3532: oPushResult
3533: oNodeGet
3534: oPop 2
3536: oPushResult
3537: oScopeCurrent
3538: oPushResult
3539: oNodeEqual
3540: oPop 2
3542: oChoice 3548
3544: oError 20
3546: oJumpForward 3551
3548: Choice Lookup Table
           0   3544
3551: oEmit 8
3553: oGetParam 1
3555: oPushResult
3556: oSetResult 12
3558: oPushResult
3559: oNodeGetInt
3560: oPop 2
3562: oPushResult
3563: oEmitInt
3564: oPop 1
3566: oGetParam 1
3568: oPushResult
3569: oSetResult 6
3571: oPushResult
3572: oNodeGet
3573: oPop 2
3575: oPushResult
3576: oTypeSPush
3577: oPop 1
3579: oInput 3
3581: oCall 1587
3583: oCall 4338
3585: oTypeSNodeType
3586: oChoice 3604
3588: oEmit 18
3590: oJumpForward 3637
3592: oEmit 19
3594: oJumpForward 3637
3596: oError 16
3598: oJumpForward 3637
3600: oEmit 20
3602: oJumpForward 3637
3604: Choice Lookup Table
          22   3600
          17   3596
          21   3596
          20   3596
          19   3592
          18   3588
3617: oGetAddrLocal 1
3619: oPushResult
3620: oTypeSTop
3621: oPushResult
3622: oSetResult 2
3624: oPushResult
3625: oNodeGetInt
3626: oPop 2
3628: oAssign
3629: oEmit 21
3631: oGetLocal 1
3633: oPushResult
3634: oEmitInt
3635: oPop 1
3637: oTypeSPop
3638: oReturn
3639: oLocalSpace 1
3641: oInput 0
3643: oGetAddrLocal 1
3645: oPushResult
3646: oScopeFindRequire
3647: oAssign
3648: oGetLocal 1
3650: oPushResult
3651: oNodeType
3652: oPop 1
3654: oChoice 3658
3656: oJumpForward 3667
3658: Choice Lookup Table
          15   3656
          13   3656
          12   3656
3665: oError 4
3667: oGetLocal 1
3669: oPushResult
3670: oCall 3675
3672: oPop 1
3674: oReturn
3675: oLocalSpace 0
3677: oGetParam 1
3679: oPushResult
3680: oNodeType
3681: oPop 1
3683: oChoice 3743
3685: oEmit 11
3687: oGetParam 1
3689: oPushResult
3690: oCall 4628
3692: oPop 1
3694: oJumpForward 3752
3696: oEmit 12
3698: oGetParam 1
3700: oPushResult
3701: oCall 4628
3703: oPop 1
3705: oJumpForward 3752
3707: oGetParam 1
3709: oPushResult
3710: oSetResult 13
3712: oPushResult
3713: oNodeGetBoolean
3714: oPop 2
3716: oChoice 3729
3718: oEmit 8
3720: oGetParam 1
3722: oPushResult
3723: oCall 4628
3725: oPop 1
3727: oJumpForward 3741
3729: Choice Lookup Table
           1   3718
3732: oEmit 13
3734: oGetParam 1
3736: oPushResult
3737: oCall 4628
3739: oPop 1
3741: oJumpForward 3752
3743: Choice Lookup Table
          15   3707
          13   3696
          12   3685
3750: oError 4
3752: oGetParam 1
3754: oPushResult
3755: oSetResult 6
3757: oPushResult
3758: oNodeGet
3759: oPop 2
3761: oPushResult
3762: oTypeSPush
3763: oPop 1
3765: oCall 2606
3767: oReturn
3768: oLocalSpace 0
3770: oCall 1587
3772: oCall 4391
3774: oInput 39
3776: oEmit 47
3778: oSetResult 2
3780: oPushResult
3781: oPatchPushHere
3782: oPop 1
3784: oEmit 53
3786: oCall 3322
3788: oInputChoice 3816
3790: oEmit 45
3792: oSetResult 2
3794: oPushResult
3795: oPatchPushHere
3796: oPop 1
3798: oEmit 53
3800: oSetResult 2
3802: oPushResult
3803: oPatchSwap
3804: oPop 1
3806: oSetResult 2
3808: oPushResult
3809: oPatchPopFwd
3810: oPop 1
3812: oCall 3322
3814: oJumpForward 3819
3816: Choice Lookup Table
          40   3790
3819: oSetResult 2
3821: oPushResult
3822: oPatchPopFwd
3823: oPop 1
3825: oReturn
3826: oLocalSpace 1
3828: oInput 0
3830: oGetAddrLocal 1
3832: oPushResult
3833: oScopeFindRequire
3834: oAssign
3835: oGetLocal 1
3837: oPushResult
3838: oNodeType
3839: oPop 1
3841: oChoice 3853
3843: oJumpForward 3862
3845: oError 16
3847: oJumpForward 3862
3849: oError 16
3851: oJumpForward 3862
3853: Choice Lookup Table
          15   3849
          13   3845
          12   3843
3860: oError 5
3862: oGetLocal 1
3864: oPushResult
3865: oSetResult 6
3867: oPushResult
3868: oNodeGet
3869: oPop 2
3871: oPushResult
3872: oTypeSPush
3873: oPop 1
3875: oCall 4364
3877: oEmit 10
3879: oGetLocal 1
3881: oPushResult
3882: oCall 4628
3884: oPop 1
3886: oInput 3
3888: oCall 1587
3890: oCall 4364
3892: oEmit 18
3894: oEmit 45
3896: oSetResult 0
3898: oPushResult
3899: oPatchPushHere
3900: oPop 1
3902: oEmit 53
3904: oSetResult 0
3906: oPushResult
3907: oPatchPushHere
3908: oPop 1
3910: oSetResult 0
3912: oPushResult
3913: oPatchSwap
3914: oPop 1
3916: oInputChoice 4014
3918: oEmit 22
3920: oGetLocal 1
3922: oPushResult
3923: oCall 4628
3925: oPop 1
3927: oSetResult 0
3929: oPushResult
3930: oPatchPopFwd
3931: oPop 1
3933: oEmit 0
3935: oGetLocal 1
3937: oPushResult
3938: oCall 4628
3940: oPop 1
3942: oCall 1587
3944: oCall 4364
3946: oEmit 34
3948: oEmit 46
3950: oSetResult 0
3952: oPushResult
3953: oPatchPushHere
3954: oPop 1
3956: oEmit 53
3958: oSetResult 0
3960: oPushResult
3961: oPatchSwap
3962: oPop 1
3964: oJumpForward 4020
3966: oEmit 23
3968: oGetLocal 1
3970: oPushResult
3971: oCall 4628
3973: oPop 1
3975: oSetResult 0
3977: oPushResult
3978: oPatchPopFwd
3979: oPop 1
3981: oEmit 0
3983: oGetLocal 1
3985: oPushResult
3986: oCall 4628
3988: oPop 1
3990: oCall 1587
3992: oCall 4364
3994: oEmit 35
3996: oEmit 46
3998: oSetResult 0
4000: oPushResult
4001: oPatchPushHere
4002: oPop 1
4004: oEmit 53
4006: oSetResult 0
4008: oPushResult
4009: oPatchSwap
4010: oPop 1
4012: oJumpForward 4020
4014: Choice Lookup Table
          43   3966
          42   3918
4019: oEndChoice
4020: oSetResult 0
4022: oPushResult
4023: oCountPush
4024: oPop 1
4026: oInput 44
4028: oCall 3322
4030: oEmit 45
4032: oSetResult 0
4034: oPushResult
4035: oPatchPopBack
4036: oPop 1
4038: oSetResult 0
4040: oPushResult
4041: oPatchPopFwd
4042: oPop 1
4044: oCall 4315
4046: oReturn
4047: oLocalSpace 0
4049: oSetResult 0
4051: oPushResult
4052: oPatchPushHere
4053: oPop 1
4055: oSetResult 0
4057: oPushResult
4058: oCountPush
4059: oPop 1
4061: oCall 3322
4063: oInputChoice 4087
4065: oCall 3322
4067: oJumpForward 4093
4069: oCall 1587
4071: oCall 4391
4073: oEmit 47
4075: oSetResult 0
4077: oPushResult
4078: oPatchPopBack
4079: oPop 1
4081: oCall 4315
4083: oJumpForward 4095
4085: oJumpForward 4093
4087: Choice Lookup Table
          47   4069
           4   4065
4092: oEndChoice
4093: oJumpBack 4063
4095: oReturn
4096: oLocalSpace 0
4098: oSetResult 0
4100: oPushResult
4101: oPatchPushHere
4102: oPop 1
4104: oSetResult 0
4106: oPushResult
4107: oCountPush
4108: oPop 1
4110: oCall 1587
4112: oCall 4391
4114: oInput 44
4116: oEmit 47
4118: oSetResult 0
4120: oPushResult
4121: oPatchPushHere
4122: oPop 1
4124: oEmit 53
4126: oSetResult 0
4128: oPushResult
4129: oPatchSwap
4130: oPop 1
4132: oCall 3322
4134: oEmit 45
4136: oSetResult 0
4138: oPushResult
4139: oPatchPopBack
4140: oPop 1
4142: oSetResult 0
4144: oPushResult
4145: oPatchPopFwd
4146: oPop 1
4148: oCall 4315
4150: oReturn
4151: oLocalSpace 0
4153: oSetResult 0
4155: oPushResult
4156: oPatchAnyEntries
4157: oPop 1
4159: oChoice 4177
4161: oEmit 45
4163: oSetResult 0
4165: oPushResult
4166: oPatchDup
4167: oPop 1
4169: oSetResult 0
4171: oPushResult
4172: oPatchPopBack
4173: oPop 1
4175: oJumpForward 4182
4177: Choice Lookup Table
           1   4161
4180: oError 18
4182: oReturn
4183: oLocalSpace 0
4185: oSetResult 0
4187: oPushResult
4188: oPatchAnyEntries
4189: oPop 1
4191: oChoice 4206
4193: oEmit 45
4195: oSetResult 1
4197: oPushResult
4198: oPatchPushHere
4199: oPop 1
4201: oEmit 53
4203: oCountInc
4204: oJumpForward 4211
4206: Choice Lookup Table
           1   4193
4209: oError 18
4211: oReturn
4212: oLocalSpace 0
4214: oCall 3322
4216: oInputChoice 4226
4218: oCall 3322
4220: oJumpForward 4232
4222: oJumpForward 4234
4224: oJumpForward 4232
4226: Choice Lookup Table
          33   4222
           4   4218
4231: oEndChoice
4232: oJumpBack 4216
4234: oReturn
4235: oLocalSpace 0
4237: oCall 4242
4239: oEmit 52
4241: oReturn
4242: oLocalSpace 0
4244: oInputChoice 4305
4246: oCall 1587
4248: oTypeSNodeType
4249: oChoice 4271
4251: oEmit 48
4253: oJumpForward 4286
4255: oEmit 49
4257: oJumpForward 4286
4259: oEmit 50
4261: oJumpForward 4286
4263: oError 16
4265: oJumpForward 4286
4267: oEmit 51
4269: oJumpForward 4286
4271: Choice Lookup Table
          22   4267
          17   4263
          20   4263
          21   4259
          19   4255
          18   4251
4284: oError 17
4286: oTypeSPop
4287: oInputChoice 4295
4289: oJumpForward 4303
4291: oJumpForward 4301
4293: oJumpForward 4301
4295: Choice Lookup Table
          12   4293
          14   4289
4300: oEndChoice
4301: oJumpBack 4246
4303: oJumpForward 4308
4305: Choice Lookup Table
          13   4246
4308: oReturn
4309: oLocalSpace 0
4311: oReturn
4312: oLocalSpace 0
4314: oReturn
4315: oLocalSpace 0
4317: oCountIsZero
4318: oChoice 4329
4320: oSetResult 1
4322: oPushResult
4323: oPatchPopFwd
4324: oPop 1
4326: oCountDec
4327: oJumpForward 4334
4329: Choice Lookup Table
           0   4320
4332: oJumpForward 4336
4334: oJumpBack 4317
4336: oCountPop
4337: oReturn
4338: oLocalSpace 1
4340: oGetAddrLocal 1
4342: oPushResult
4343: oTypeSNodeType
4344: oAssign
4345: oTypeSPop
4346: oGetLocal 1
4348: oPushResult
4349: oTypeSNodeType
4350: oPushResult
4351: equal_node_type
4352: oPop 2
4354: oChoice 4360
4356: oError 14
4358: oJumpForward 4363
4360: Choice Lookup Table
           0   4356
4363: oReturn
4364: oLocalSpace 0
4366: oTypeSNodeType
4367: oChoice 4371
4369: oJumpForward 4376
4371: Choice Lookup Table
          18   4369
4374: oError 7
4376: oTypeSPop
4377: oReturn
4378: oLocalSpace 0
4380: oTypeSNodeType
4381: oChoice 4385
4383: oJumpForward 4390
4385: Choice Lookup Table
          18   4383
4388: oError 7
4390: oReturn
4391: oLocalSpace 0
4393: oTypeSNodeType
4394: oChoice 4398
4396: oJumpForward 4403
4398: Choice Lookup Table
          19   4396
4401: oError 8
4403: oTypeSPop
4404: oReturn
4405: oLocalSpace 0
4407: oTypeSNodeType
4408: oChoice 4412
4410: oJumpForward 4417
4412: Choice Lookup Table
          19   4410
4415: oError 8
4417: oReturn
4418: oLocalSpace 1
4420: oGetAddrLocal 1
4422: oPushResult
4423: oGetParam 2
4425: oPushResult
4426: oNodeNew
4427: oPop 1
4429: oAssign
4430: oGetLocal 1
4432: oPushResult
4433: oSetResult 2
4435: oPushResult
4436: oGetParam 1
4438: oPushResult
4439: oNodeSetInt
4440: oPop 3
4442: oGetLocal 1
4444: oPushResult
4445: oTypeAdd
4446: oPop 1
4448: oGetLocal 1
4450: oReturn
4451: oReturn
4452: oLocalSpace 1
4454: oGetAddrLocal 1
4456: oPushResult
4457: oGetParam 3
4459: oPushResult
4460: oNodeNew
4461: oPop 1
4463: oAssign
4464: oGetLocal 1
4466: oPushResult
4467: oSetResult 5
4469: oPushResult
4470: oGetParam 2
4472: oPushResult
4473: oNodeSetKind
4474: oPop 3
4476: oGetLocal 1
4478: oPushResult
4479: oSetResult 4
4481: oPushResult
4482: oGetParam 1
4484: oPushResult
4485: oNodeSetInt
4486: oPop 3
4488: oGetLocal 1
4490: oReturn
4491: oReturn
4492: oLocalSpace 1
4494: oGetAddrLocal 1
4496: oPushResult
4497: oGetParam 1
4499: oPushResult
4500: oSetResult 14
4502: oPushResult
4503: oNodeGet
4504: oPop 2
4506: oAssign
4507: oGetLocal 1
4509: oPushResult
4510: oNodeNull
4511: oPop 1
4513: oChoice 4569
4515: oGetAddrLocal 1
4517: oPushResult
4518: oSetResult 22
4520: oPushResult
4521: oNodeNew
4522: oPop 1
4524: oAssign
4525: oGetLocal 1
4527: oPushResult
4528: oSetResult 15
4530: oPushResult
4531: oGetParam 1
4533: oPushResult
4534: oNodeSet
4535: oPop 3
4537: oGetLocal 1
4539: oPushResult
4540: oSetResult 2
4542: oPushResult
4543: oSetResult 8
4545: oPushResult
4546: oNodeSetInt
4547: oPop 3
4549: oGetLocal 1
4551: oPushResult
4552: oTypeAdd
4553: oPop 1
4555: oGetParam 1
4557: oPushResult
4558: oSetResult 14
4560: oPushResult
4561: oGetLocal 1
4563: oPushResult
4564: oNodeSet
4565: oPop 3
4567: oJumpForward 4572
4569: Choice Lookup Table
           1   4515
4572: oGetLocal 1
4574: oReturn
4575: oReturn
4576: oLocalSpace 0
4578: oGetParam 1
4580: oPushResult
4581: oNodeType
4582: oPop 1
4584: oChoice 4613
4586: oSetResult 0
4588: oReturn
4589: oJumpForward 4627
4591: oSetResult 0
4593: oReturn
4594: oJumpForward 4627
4596: oSetResult 0
4598: oReturn
4599: oJumpForward 4627
4601: oGetParam 1
4603: oPushResult
4604: oSetResult 17
4606: oPushResult
4607: oNodeGetInt
4608: oPop 2
4610: oReturn
4611: oJumpForward 4627
4613: Choice Lookup Table
          24   4601
          20   4596
          19   4591
          18   4586
4622: oError 3
4624: oSetResult 0
4626: oReturn
4627: oReturn
4628: oLocalSpace 0
4630: oGetParam 1
4632: oPushResult
4633: oSetResult 8
4635: oPushResult
4636: oNodeGetInt
4637: oPop 2
4639: oPushResult
4640: oEmitInt
4641: oPop 1
4643: oReturn
4644: oLocalSpace 1
4646: oGetAddrGlobal 2
4648: oPushResult
4649: oSetResult 17
4651: oPushResult
4652: oSetResult 4
4654: oPushResult
4655: oCall 4418
4657: oPop 2
4659: oAssign
4660: oGetAddrGlobal 3
4662: oPushResult
4663: oSetResult 18
4665: oPushResult
4666: oSetResult 4
4668: oPushResult
4669: oCall 4418
4671: oPop 2
4673: oAssign
4674: oGetAddrGlobal 4
4676: oPushResult
4677: oSetResult 19
4679: oPushResult
4680: oSetResult 1
4682: oPushResult
4683: oCall 4418
4685: oPop 2
4687: oAssign
4688: oGetAddrGlobal 5
4690: oPushResult
4691: oSetResult 20
4693: oPushResult
4694: oSetResult 1
4696: oPushResult
4697: oCall 4418
4699: oPop 2
4701: oAssign
4702: oGetAddrGlobal 6
4704: oPushResult
4705: oSetResult 21
4707: oPushResult
4708: oSetResult 256
4710: oPushResult
4711: oCall 4418
4713: oPop 2
4715: oAssign
4716: oGetAddrLocal 1
4718: oPushResult
4719: oSetResult 10
4721: oPushResult
4722: oSetResult 5
4724: oPushResult
4725: oIdAdd_File
4726: oPushResult
4727: oCall 4452
4729: oPop 3
4731: oAssign
4732: oGetLocal 1
4734: oPushResult
4735: oSetResult 6
4737: oPushResult
4738: oGetGlobal 2
4740: oPushResult
4741: oNodeSet
4742: oPop 3
4744: oGetLocal 1
4746: oPushResult
4747: oScopeDeclare
4748: oPop 1
4750: oGetAddrLocal 1
4752: oPushResult
4753: oSetResult 10
4755: oPushResult
4756: oSetResult 5
4758: oPushResult
4759: oIdAdd_Integer
4760: oPushResult
4761: oCall 4452
4763: oPop 3
4765: oAssign
4766: oGetLocal 1
4768: oPushResult
4769: oSetResult 6
4771: oPushResult
4772: oGetGlobal 3
4774: oPushResult
4775: oNodeSet
4776: oPop 3
4778: oGetLocal 1
4780: oPushResult
4781: oScopeDeclare
4782: oPop 1
4784: oGetAddrLocal 1
4786: oPushResult
4787: oSetResult 10
4789: oPushResult
4790: oSetResult 5
4792: oPushResult
4793: oIdAdd_Boolean
4794: oPushResult
4795: oCall 4452
4797: oPop 3
4799: oAssign
4800: oGetLocal 1
4802: oPushResult
4803: oSetResult 6
4805: oPushResult
4806: oGetGlobal 4
4808: oPushResult
4809: oNodeSet
4810: oPop 3
4812: oGetLocal 1
4814: oPushResult
4815: oScopeDeclare
4816: oPop 1
4818: oGetAddrLocal 1
4820: oPushResult
4821: oSetResult 10
4823: oPushResult
4824: oSetResult 5
4826: oPushResult
4827: oIdAdd_Char
4828: oPushResult
4829: oCall 4452
4831: oPop 3
4833: oAssign
4834: oGetLocal 1
4836: oPushResult
4837: oSetResult 6
4839: oPushResult
4840: oGetGlobal 5
4842: oPushResult
4843: oNodeSet
4844: oPop 3
4846: oGetLocal 1
4848: oPushResult
4849: oScopeDeclare
4850: oPop 1
4852: oGetAddrLocal 1
4854: oPushResult
4855: oSetResult 10
4857: oPushResult
4858: oSetResult 5
4860: oPushResult
4861: oIdAdd_String
4862: oPushResult
4863: oCall 4452
4865: oPop 3
4867: oAssign
4868: oGetLocal 1
4870: oPushResult
4871: oSetResult 6
4873: oPushResult
4874: oGetGlobal 6
4876: oPushResult
4877: oNodeSet
4878: oPop 3
4880: oGetLocal 1
4882: oPushResult
4883: oScopeDeclare
4884: oPop 1
4886: oGetAddrLocal 1
4888: oPushResult
4889: oSetResult 9
4891: oPushResult
4892: oSetResult 4
4894: oPushResult
4895: oIdAdd_True
4896: oPushResult
4897: oCall 4452
4899: oPop 3
4901: oAssign
4902: oGetLocal 1
4904: oPushResult
4905: oSetResult 6
4907: oPushResult
4908: oGetGlobal 4
4910: oPushResult
4911: oNodeSet
4912: oPop 3
4914: oGetLocal 1
4916: oPushResult
4917: oSetResult 8
4919: oPushResult
4920: oSetResult 1
4922: oPushResult
4923: oNodeSetInt
4924: oPop 3
4926: oGetLocal 1
4928: oPushResult
4929: oScopeDeclare
4930: oPop 1
4932: oGetAddrLocal 1
4934: oPushResult
4935: oSetResult 9
4937: oPushResult
4938: oSetResult 4
4940: oPushResult
4941: oIdAdd_False
4942: oPushResult
4943: oCall 4452
4945: oPop 3
4947: oAssign
4948: oGetLocal 1
4950: oPushResult
4951: oSetResult 6
4953: oPushResult
4954: oGetGlobal 4
4956: oPushResult
4957: oNodeSet
4958: oPop 3
4960: oGetLocal 1
4962: oPushResult
4963: oSetResult 8
4965: oPushResult
4966: oSetResult 0
4968: oPushResult
4969: oNodeSetInt
4970: oPop 3
4972: oGetLocal 1
4974: oPushResult
4975: oScopeDeclare
4976: oPop 1
4978: oReturn
