   2: title: 'Pascal Compiler 1.1.5 -- Jan 01 ''90';
         
      %
      %  Pascal.ssl
      %
      %  Pascal Compiler for the Amiga, by Steve Rice.
      %
      %  HISTORY
      %    11Sep89   First version, framework of parser.
      %    18Sep89   Added some semantic mechanisms.
      %    21Sep89   Added simple type references; expressions generate code.
      %    22Sep89   Allocate variable addresses as they're declared.
      %    24Sep89   Added arrays, pointers.
      %    27Sep89   Added for statement.
      %    23Oct89   Fixed for statement, so CYCLE goes to next step.
      %    01Jan90   Added string literals
      %    09Sep22   I have returned.  Migrate symbol table to schema, to ease development.
      %    01Oct22   Language: Switch from cycle/exit (Mac Pascal extension) to continue/break (Borland).
      %
      %  NOTES
      %    -  The 'value' of a var symbol is its allocated address.
      %    -  References to vars of intrinsic types, and pointer types,
      %       pushes the value of the var on the expr stack.  Referenecs to
      %       vars of compound types (arrays, records...) pushes the address
      %       on the expr stack.
      %    -  Just as there is only one type table entry for a given (named) type,
      %       there is only one type table entry for a pointer to a named type.
      %       When a pointer type is declared, a field in the TT entry of the
      %       type pointed to will be set to indicate the TT entry of the pointer
      %       to that type (0 means none defined yet).  When evaluating the
      %       expression @x, the type in that field in the entry for the type of x
      %       will be used (unless it's 0, in which case a new TT entry will be
      %       created).
      %
      %
      %  MISSING
      %
      %    - Consider non-ISO extensions.  e.g. 
      %      Dynamic arrays.  Objects.  But, perhaps stick to my old goal, standard Pascal.
      %
      %  PASCAL DOCS
      %      Here's some handy language material:
      %      https://www.freepascal.org/docs-html/ref/ref.html
      %      https://www.freepascal.org/docs-html/prog/prog.html
      %      https://en.wikipedia.org/wiki/Turbo_Pascal
      %      https://en.wikipedia.org/wiki/Pascal_(programming_language)#Standards
      %      http://www.standardpascaline.org/
      %
      
   2: input:
   2:    pIdent
   2:    pIntLit
   2:    pDoubleLit
   2:    pStrLit
   2:    pCharLit
   2:    pAssign       ':='
   2:    pSemiColon    ';'
   2:    pEqual        '='
   2:    pNotEqual     '<>'
   2:    pLess         '<'
   2:    pGreater      '>'
   2:    pLessEqual    '<='
   2:    pGreaterEqual '>='
   2:    pColon        ':'
   2:    pComma        ','
   2:    pLParen       '('
   2:    pRParen       ')'
   2:    pLSquare      '['
   2:    pRSquare      ']'
   2:    pCarat        '^'
   2:    pAt           '@'
   2:    pDot          '.'
   2:    pDotDot       '..'
   2:    pTimes        '*'
   2:    pDivide       '/'
   2:    pPlus         '+'
   2:    pMinus        '-'
   2:    pEof
   2:    pInvalid
      
      %  keywords  (built-in types 'integer', 'byte', 'char', etc, are not keywords,
      %             type constructors 'array', 'record', 'set' are keywords,
      %             pseudo-procedures 'writeln', 'readln' are keywords)
      %
      %             forward/external/name/cdecl appear in method modifiers, in fpc grammar.
      %             I'm making them keywords to simplify parsing, but could reconsider.
      
   2:    pProgram
   2:    pProcedure
   2:    pFunction
   2:    pConst
   2:    pType
   2:    pVar
   2:    pLabel
   2:    pBegin
   2:    pEnd
   2:    pArray
   2:    pRecord
   2:    pSet
   2:    pOf
   2:    pIf
   2:    pThen
   2:    pElse
   2:    pFor
   2:    pTo
   2:    pDownto
   2:    pDo
   2:    pWhile
   2:    pRepeat
   2:    pUntil
   2:    pContinue
   2:    pBreak
   2:    pCase
   2:    pOtherwise
   2:    pGoto
   2:    pAnd
   2:    pOr
   2:    pNot
   2:    pUses
   2:    pUnit
   2:    pInterface
   2:    pImplementation
   2:    pInitialization
   2:    pFinalization
   2:    pWriteln
   2:    pWrite
   2:    pReadln
   2:    pRead
      
   2:    pForward
   2:    pExternal
   2:    pName
   2:    pCdecl
   2:    ;
      
      
   2: output:
      
      %  Instructions for a stack machine (all vars are 32-bit integers)
      
   2:    tPushGlobalI      % <ptr> - push int value read from ptr
   2:    tPushGlobalB      % <ptr> - push byte value read from ptr
   2:    tPushGlobalP      % <ptr> - push ptr value read from ptr
   2:    tPushLocalI       % <offset> - push int value read from local var in current scope
   2:    tPushLocalB       % <offset> - push byte value read from local var in current scope
   2:    tPushLocalP       % <offset> - push ptr value read from local var in current scope
   2:    tPushParamI       % <offset> - push int value read from param in current scope
   2:    tPushParamB       % <offset> - push byte value read from param in current scope
   2:    tPushParamP       % <offset> - push ptr value read from param in current scope
   2:    tPushUpLocalI     % <uplevels> <offset> - push int value read from local var in a parent static scope
   2:    tPushUpLocalB     % <uplevels> <offset> - push byte value read from local var in a parent static scope
   2:    tPushUpLocalP     % <uplevels> <offset> - push ptr value read from local var in a parent static scope
   2:    tPushUpParamI     % <uplevels> <offset> - push int value read from param in a parent static scope
   2:    tPushUpParamB     % <uplevels> <offset> - push byte value read from param in a parent static scope
   2:    tPushUpParamP     % <uplevels> <offset> - push ptr value read from param in a parent static scope
   2:    tPushConstI       % <int> - push int value on stack (NOTE, used for BOOLEAN too)
   2:    tPushConstD       % <double> - push double value on stack
   2:    tPushAddrGlobal   % <offset> - push ptr to global var
   2:    tPushAddrLocal    % <offset> - push ptr to local var
   2:    tPushAddrParam    % <offset> - push ptr to formal param (used by method to see its param)
   2:    tPushAddrActual   % <offset> - push ptr to actual param, in actuals space (used by caller)
   2:    tPushAddrUpLocal  % <uplevels> <offset> - push ptr to local var in a parent static scope
   2:    tPushAddrUpParam  % <uplevels> <offset> - push ptr to formal param in a parent static scope
   2:    tSwap             % swap the top two entries on the stack
   2:    tFetchI           % pop ptr from stack, and push int value it points to
   2:    tFetchB           %    "      "      "     "     byte  "   "    "
   2:    tFetchP           %    "      "      "     "     ptr   "   "    "   
   2:    tAssignI          % assign int value on top of stack to addr under it (pop both)
   2:    tAssignB          %   "    byte   "    "   "  "   "    "    "   "   "
   2:    tAssignP          %   "    ptr    "    "   "  "   "    "    "   "   "
   2:    tAssignD          %   "    double "    "   "  "   "    "    "   "   "
   2:    tCopy             % <#bytes> - copy bytes.  tos=src, 2nd=dest (pop 2)
   2:    tCastBtoI         % zero-extend uint8_t to int32_t
   2:    tCastItoB         % truncate int32_t to uint8_t
   2:    tIncI             % increment int value on top of expr stack
   2:    tDecI             % decrement int value on top of expr stack
   2:    tMultI            % multiply top two integers (replacing with result)
   2:    tDivI
   2:    tAddPI            % add ptr (2nd value) and int (top value), resulting in a ptr
   2:    tAddI
   2:    tSubP
   2:    tSubPI
   2:    tSubI
   2:    tNegI             % top entry *= -1
   2:    tNot              % negate top boolean
   2:    tEqualB
   2:    tNotEqualB
   2:    tGreaterB         % B is uint8_t, so these are unsigned comparisons
   2:    tLessB
   2:    tGreaterEqualB
   2:    tLessEqualB
   2:    tEqualI           % top two entries equal? (pop 2, push 1) (true=1)
   2:    tNotEqualI        %    NOTE, these all work for booleans too, but I'm moving to tEqualB etc for those
   2:    tGreaterI         % 2nd entry greater than top entry? (pop 2, push answer)
   2:    tLessI  
   2:    tGreaterEqualI
   2:    tLessEqualI
   2:    tEqualP           % two two pointer values equal? (pop 2, push 1) (true=1)
   2:    tNotEqualP
   2:    tGreaterP
   2:    tLessP
   2:    tGreaterEqualP
   2:    tLessEqualP
   2:    tAllocActuals     % <#bytes> - make space on call stack for actual params (adjusting call stack sp)
   2:    tAllocActualsCdecl  % <#bytes> - starting a call to a cdecl method.  tcode still describes my own calling convention.
   2:    tFreeActuals      % <#bytes> - discard space on call stack allocated by tAllocActuals
   2:    tCall             % <label#>
   2:    tCallCdecl        % <label#> - call a method using native (C) calling convention. Only supported for extern labels.
   2:    tReturn
   2:    tEnter            % <#bytes> - start a stack frame on the call stack, reserving #bytes of local variable space
   2:    tJump             % <label#>
   2:    tJumpTrue         % <label#>  (pops top of stack, jumps if true)
   2:    tJumpFalse        % <label#>  (pops top of stack, jumps if false)
   2:    tJumpCaseB        % <label#>  pops uint8_t, jumps to case indicated by table at label (consisting of tCase, tCaseRange, tCaseEnd)
   2:    tJumpCaseI        % <label#>  pops integer, jumps to case indicated by table at label
   2:    tJumpCaseS        % <label#>  pops pointer to ShortString, jumps to case indicated by table at label
   2:    tCase             % <int> <label#>  - case table entry: if match int, goto label.  For tJumpCaseS, int is offset into global data.
   2:    tCaseRange        % <lowint> <highint> <label#>  - case table entry: if lowint <= value <= highint, goto label.  For tJumpCaseS, offsets into global.
   2:    tCaseEnd          % <label#> - end of case table.  Label points to no-match code (otherwise clause or end of statement).
   2:    tLabel            % <label#> - define label# at the current address
   2:    tLabelAlias       % <label#> <aliasToLabel#> - defines label to be an alias of another label
   2:    tLabelExtern      % <label#> <offsetToStrLit> - defines label to mean an extern symbol, whose name is in global data
   2:    tWriteI           % for writeln : write integer on tos, pop
   2:    tWriteBool        %  "     "    : write TRUE/FALSE, pop
   2:    tWriteChar        %  "     "    : write char, pop
   2:    tWriteShortStr    %  "     "    : write ShortString whose addr is on tos, pop
   2:    tWritePChar       %  "     "    : write a null-terminated string whose addr is on tos, pop
   2:    tWriteP           %  "     "    : write ptr var whose addr is on tos, pop
   2:    tWriteEnum        %  "     "    : write enum name.  Name table on tos, value under it, pop both
   2:    tWriteD           %  "     "    : write double-precision floating point value on tos, pop
   2:    tWriteCR          %  "     "    : write cr
   2:    tReadI            % for readln : pointer to integer on tos.  Assign read value to it, and pop
   2:    tReadChar         %  "     "   : pointer to char on tos.  Asign read value to it, and pop
   2:    tReadShortStr     % <capacity>  "     "   : pointer to ShortString on tos, and given max capacity.  Assign read value to it, and pop
   2:    tReadCR           %  "     "   : read the end-of-line.  Will accept any platform's eoln sequence.
   2:    tFile             % <file#> - pascal source file id, for debugging.  I haven't decided yet how I will communicate the corresponding filename.
   2:    tLine             % <line#> - pascal source line number, for debugging
      
      %  Other:
      
   2:    tSpace            % emit a hole, to be patched later
   2:    ;
      
   2: error:
   2:    eBadStatement
   2:    eNotConst
   2:    eNotType
   2:    eNotOrdinalType
   2:    eNotVar
   2:    eNotIntVar
   2:    eNotValue
   2:    eNotInteger
   2:    eNotBoolean
   2:    eNotPointer
   2:    eNotArray
   2:    eNotRecord
   2:    eNotRecordField
   2:    eTooManySubscripts
   2:    eTypeMismatch
   2:    eMissingParameter
   2:    eNotImplemented
   2:    eNotAllowed
   2:    eNotInALoop
   2:    eRecordEmpty
   2:    eNotCurrentFunction
   2:    eAlreadyDefined
   2:    eOnlyOneVarCanBeInitialized
   2:    eExternalMethodCannotBeNested
   2:    eCantFindUnitFile
   2:    eInternalScopeMismatch
   2:    eEnumValueNotAscending
   2:    eUsedButNotDefined
   2:    eCantUsePredSuccOnEnumWithValueGaps
   2:    eCantDereference
   2:    eSizeMismatch
   2:    eTypeNameNotAllowedHere
   2:    ;
      
   2: include 'pascal_schema.ssl'
      
      % Generated automatically by schema
      
   2: type node_type:
   2: 	nINVALID
   2: 	Object
   2: 	nWorkspace
   2: 	nModule
   2: 	nProgram
   2: 	nUnit
   2: 	nUnitImpl
   2: 	nScope
   2: 	nDeclaration
   2: 	nIdent
   2: 	nUnitRef
   2: 	nMethod
   2: 	nProc
   2: 	nFunc
   2: 	nBuiltInFunc
   2: 	nBuiltInProc
   2: 	nConst
   2: 	nEnumValue
   2: 	nConstStr
   2: 	nTypeDecl
   2: 	nVar
   2: 	nGlobalVar
   2: 	nLocalVar
   2: 	nRecordField
   2: 	nParam
   2: 	nTypedConst
   2: 	nLabel
   2: 	nType
   2: 	nFileType
   2: 	nByteType
   2: 	nIntegerType
   2: 	nSingleType
   2: 	nDoubleType
   2: 	nBooleanType
   2: 	nBooleanFlowType
   2: 	nCharType
   2: 	nPointerType
   2: 	nUniversalPointerType
   2: 	nArrayType
   2: 	nSubrangeType
   2: 	nRecordType
   2: 	nStrLitType
   2: 	nShortStringType
   2: 	nEnumType
   2: 	nSetType
   2: 	;
      
   2: type node_attribute:
   2: 	qINVALID
   2: 	qUnits
   2: 	qProgram
   2: 	qGlobalSize
   2: 	qIdent
   2: 	qUsedUnits
   2: 	qChildScope
   2: 	qMainRoutineScope
   2: 	qImpl
   2: 	qPublicScope
   2: 	qPrivateScope
   2: 	qInitLabel
   2: 	qFinalLabel
   2: 	qInitRoutineScope
   2: 	qLevel
   2: 	qDecls
   2: 	qExtends
   2: 	qSize
   2: 	qAllocMode
   2: 	qInitCode
   2: 	qParentScope
   2: 	qType
   2: 	qValue
   2: 	qParams
   2: 	qBodyDefined
   2: 	qExternal
   2: 	qExternalName
   2: 	qCdecl
   2: 	qUsed
   2: 	qOldParams
   2: 	qOldType
   2: 	qResultOffset
   2: 	qNameOffset
   2: 	qValueStr
   2: 	qInOut
   2: 	qDefined
   2: 	qPointerType
   2: 	qBaseType
   2: 	qIndexType
   2: 	qLow
   2: 	qHigh
   2: 	qScope
   2: 	qCapacity
   2: 	qNameTable
   2: 	qHasGap
   2: 	;
      
      
   2: type Node:     % A pointer to a node in the schema database (symbol database)
   2:    Null = 0
   2:    ;
      
   2: type NodeIter:   % An iterator over nodes in a list, in the schema database
   2:    NullIter = 0
   2:    ;
      
   2: type NodeVec:  % A pointer to a vector of Node.  See mechanism node_vec_mech
   2:    NullVec = 0
   2:    ;
      
   2: type boolean:
   2:    false    = 0
   2:    true     = 1;
      
   2: type double:
   2:    doubleZero = 0
   2:    ;
      
   2: type Label:
   2:    labelNull = 0;
      
      % An output code stream.
   2: type Code:
   2:    codeNull = 0
   2:    codeDefault = 1
   2:    ;
      
      % A string
   2: type String:
   2:    stringNull = 0
   2:    ;
      
      % allocation modes for oScopeBegin
   2: type AllocMode:
   2:    allocGlobal = 0  % allocate from global data
   2:    allocDown        % allocate down the stack
   2:    allocUp          % allocate up the stack
   2:    ;
      
      % Some general schema node operations.
      % node_type and node_attribute are defined in generated file pascal_schema.ssl included above.
      %
   2: mechanism node_mech:
   2:     oNodeNew (node_type) >> Node         % create new node
   2:     oNodeSet (Node, node_attribute, Node)   % set Node attribute of node
   2:     oNodeSetString (Node, node_attribute, String)
   2:     oNodeSetInt (Node, node_attribute, int) % set int attribute of node
   2:     oNodeSetBoolean (Node, node_attribute, boolean)
   2:     oNodeSetLabel( Node, node_attribute, Label )  % set Label attribute of node
   2:     oNodeSetCode( Node, node_attribute, Code )    % set Code attribute of node
   2:     oNodeAddLast( Node, node_attribute, Node value )  % append to a List attribute of node
   2:     oNodeGet (Node, node_attribute) >> Node    % get Node attribute of node
   2:     oNodeGetString (Node, node_attribute) >> String
   2:     oNodeGetInt (Node, node_attribute) >> int  % get int attribute of node
   2:     oNodeGetBoolean (Node, node_attribute) >> boolean  % get int attribute of node
   2:     oNodeGetLabel (Node, node_attribute) >> Label      % get Label attribute of node
   2:     oNodeGetCode (Node, node_attribute) >> Code        % get code stream attribute of node
   2:     oNodeNull (Node) >> boolean          % is node null?
   2:     oNodeFind (Node, node_attribute listAttr, node_attribute valueAttr, int value) >> Node  % find node with value in list
   2:     oNodeGetIter (Node, node_attribute) >> NodeIter   % get an iterator over nodes in a List attribute
   2:     oNodeGetIterLast (Node, node_attribute) >> NodeIter  % get an iterator over nodes in a List, starting at last
   2:     oNodeIterValue (NodeIter) >> Node             % the node that iter is referring to (NodeNull if no more nodes)
   2:     oNodeIterNext (inout NodeIter)                % advance iterator through list
   2:     oNodeIterPrev (inout NodeIter)                % advance iterator backwards through list
   2:     oNodeType (Node) >> node_type        % return node type of node
   2:     oNodeEqual (Node, Node) >> boolean   % compare two nodes for equality
                                               % (i.e. same node, not just same contents)
   2:     ;
      
      
      % Manipulate a temporary vector of Node
      %
   2: mechanism node_vec_mech:
   2:     oNodeVecNew >> NodeVec
   2:     oNodeVecDelete( NodeVec nv )
   2:     oNodeVecAppend( NodeVec nv, Node n )
   2:     oNodeVecSize( NodeVec nv ) >> int                % how many elements
   2:     oNodeVecElement( NodeVec nv, int idx ) >> Node   % element at index idx (0..size-1)
   2:     ;
      
      
      
   2: mechanism emit_mech:
   2:     oEmitInt( int )              % emit int into the generated code
   2:     oEmitDouble( double )        % emit double into the generated code
   2:     oEmitLabel( Label )
   2:     oEmitCode( Code )            % append a code stream to the current code stream
   2:     Here >> int                  % current address in the generated code
                                       %   (only usable in the default code stream)
   2:     oPatch( int addr, int val )  % patch an int into address in the generated code
                                       %   (only usable in the default code stream)
   2:     ;
      
   2: mechanism math:
   2:     inc (inout int)
   2:     dec (inout int)
   2:     negate (int) >> int
   2:     add( int x, int y ) >> int
   2:     subtract( int x, int y ) >> int     % x - y
   2:     multiply( int x, int y ) >> int     % x * y
   2:     equal( int x, int y ) >> boolean
   2:     equal_zero (int) >> boolean
   2:     equal_node( Node, Node ) >> boolean
   2:     equal_string( String, String ) >> boolean
   2:     equal_node_type (node_type, node_type) >> boolean     % Want equal_<type> for every type
   2:     equal_label( Label, Label ) >> boolean
   2:     equal_code( Code, Code ) >> boolean
   2:     greater( int x, int y ) >> boolean
   2:     oMININT >> int    % the minimum 32-bit integer.
   2:     oMAXINT >> int    % the maximum 32-bit integer.
   2:     ;
      
   2: mechanism more_builtins:      % These should be built-in SSL operations
   2:     TOKEN_VALUE >> int        % value of just accepted token, e.g. IntLit token
   2:     TOKEN_VALUE_DOUBLE >> double
   2:     LAST_ID >> int            % id number of last accepted identifier
   2:     ID_STRING( int id ) >> String       % text name of identifier with given id
   2:     CURRENT_STRLIT >> String            % text value of just-accepted string literal
   2:     UNACCEPT_TOKEN            % Unaccept the last accepted token.  The next input, inputchoice will see it again.
   2:     ;
      
   2: mechanism workspace_mech:
   2:     oWorkspaceNew >> Node
   2:     ;
      
   2: mechanism scope_mech:
   2:     oScopeBegin( int level, AllocMode )  % create a new scope. Subsequent declarations will go here.
                                               %  level = static scope depth (0 = globals)
   2:     oScopeEnter( Node scope )            % enter an existing scope.
   2:     oScopeEnd                            % end current scope. Subsequent declarations will go to previous scope.
   2:     oScopeCurrent >> Node                % returns current scope
   2:     oScopeDeclare( Node decl )           % add declaration to current scope.
   2:     oScopeDeclareAlloc( Node decl )      % add declaration to current scope, and allocate space according to its type
   2:     oScopeAllocType( Node theType ) >> int   % allocate space for type in current scope, and return its address
   2:     oScopeAlloc( int size, int align ) >> int % allocate bytes, with given alignment in bytes 
   2:     oScopeFind >> Node                   % find declaration of last accepted identifier.  Returns Null if not found.
   2:     oScopeFindRequire >> Node            % find declaration of last accepted identifier.  Error if not found.
   2:     oScopeFindInCurrentScope >> Node     % find declaration of last accepted identifier, only within the current scope.  Null if not found.
   2:     oScopeFindRequireInScope( Node scope ) >> Node  % find decl of last accepted identifier, only within the given scope.  Error it not found.
   2:     ;
      
   2: mechanism type_mech:
   2:     oTypeAdd( Node node )     % add the given nType to the type table
   2:     ;
      
   2: mechanism type_stack_mech:
   2:     oTypeSPush( Node node )
   2:     oTypeSPop
   2:     oTypeSTop >> Node
   2:     oTypeSNodeType >> node_type          % node_type of the node on top of type stack, skipping subranges
   2:     ;
      
      
   2: mechanism id_mech:
          % gets/adds a predefined id to the scanner's id table, and returns the id code
   2:     oId_mysystem >> int
   2:     oId_ShortStringAppendShortString >> int
   2:     oId_ShortStringAppendChar >> int
   2:     oId_ShortStringCmp >> int
   2:     oId_File >> int
   2:     oId_Integer >> int
   2:     oId_Boolean >> int
   2:     oId_Char >> int
   2:     oId_Byte >> int
   2:     oId_Single >> int
   2:     oId_Double >> int
   2:     oId_Pointer >> int
   2:     oId_ShortString >> int
   2:     oId_True >> int
   2:     oId_False >> int
   2:     oId_Nil >> int
   2:     oId_Ord >> int
   2:     oId_Chr >> int
   2:     oId_Pred >> int
   2:     oId_Succ >> int
   2:     oId_Sizeof >> int
   2:     oChangeIntLitToLabelIdent    % change current token from pIntLit to pIdent "_label_<intlit>"
   2:     ;
      
      
      
   2: mechanism label_mech:
   2:    oLabelNew >> Label
   2:    ;
      
   2: mechanism code_mech:
   2:    oCodeNew >> Code         % create a new empty code stream
   2:    oCodePush( Code )        % change the current output code stream to the given one
   2:    oCodePop                 % restore the current code stream to the previous one
   2:    oCodeDiscard( Code )     % discard the given code stream
   2:    ;
      
   2: mechanism include_mech:
   2:    oIncludeUnitFile( int id ) >> boolean  % search for <unit>.pas and include it.
                                                % returns false if can't find.
   2:    oIncludeEnd              % stop including the current file
   2:    ;
      
      
   2: mechanism count :
   2:    oCountPush(int)          % start a new counter, with initial value
   2:    oCountInc
   2:    oCountDec
   2:    oCountIsZero >> boolean
   2:    oCountPop;
      
      
   2: mechanism value :              % value stack, to calc. const expr's
   2:    oValuePush(int)             % push an explicit int lit
   2:    oValuePushString(String)    % push string onto value stack
   2:    oValueTop >> int            % get top value on value stack
   2:    oValueTopString >> String
   2:    oValueSwap                  % swap top two
   2:    oValuePop
   2:    oValueCharToString          % convert top value from char to string
   2:    oValueNegate                % negate top numeric value
   2:    oValueEqual
   2:    oValueNotEqual
   2:    oValueLess
   2:    oValueGreater
   2:    oValueLessEqual
   2:    oValueGreaterEqual
   2:    oValueOr                    % boolean or
   2:    oValueAnd
   2:    oValueNot                   % boolean not
   2:    oValueAdd
   2:    oValueSub
   2:    oValueMult
   2:    oValueDiv
   2:    oValueStringCmp             % compare top two strings. replace with negative, 0, or positive
   2:    oValueStringConcat
   2:    ;
      
   2: mechanism string :
   2:    oStringAllocLit( String ) >> int      % alloc global space for strlit, return address
   2:    oStringAllocShortStringLit( String ) >> int  % alloc global space for ShortString, return address
   2:    ;
      
      % track labels for the loop we're in, if any
   2: mechanism loop_mech:
   2:    oLoopPush( Label continueLabel, Label breakLabel )
   2:    oLoopContinueLabel >> Label
   2:    oLoopBreakLabel >> Label
   2:    oLoopPop
   2:    ;
      
      % for hacky debugging
   2: mechanism msg_mech:
   2:    oMsg( int num )             % print message "oMsg <num>"
   2:    oMsgTrace( int num )        % print message "oMsg <num>" followed by ssl traceback
   2:    oMsgNode( Node node )       % print node
   2:    oMsgNodeLong( Node node )   % print node with more detail
   2:    oMsgNodeVec( NodeVec vec )  % print node vec
   2:    ;
      
      
   2: rules
      
      % ----------------------------- Global Variables ----------------------------
      
   2: Node    workspace              % root of database
   2: Node    globalScope            % scope for globals in the current module
   2: Node    initScope              % scope for temporaries global var init,
                                     % and program main stmt / unit initialization stmts
      
   2: int     mysystemId               % id of identifier "mysystem"
      
      % built-in nTypes
   2: Node    FileType
   2: Node    IntegerType
   2: Node    BooleanType
   2: Node    BooleanFlowType
   2: Node    CharType
   2: Node    PCharType
   2: Node    ByteType
   2: Node    SingleType
   2: Node    DoubleType
   2: Node    UniversalPointerType
   2: Node    StrLitType
   2: Node    ShortStringType
      
      % nBuiltInFunc
   2: Node    BuiltIn_Ord
   2: Node    BuiltIn_Chr
   2: Node    BuiltIn_Pred
   2: Node    BuiltIn_Succ
   2: Node    BuiltIn_Sizeof
      
      % Declarations in unit mysystem that the compiler may refer to directly.
      
   2: Node    System_ShortStringAppendShortString
   2: Node    System_ShortStringAppendChar
   2: Node    System_ShortStringCmp
      
      
      % Expr has a corner case flag, needed for sizeof()
   2: boolean flagExprAllowTypeName
      
      
      % -------------------------- Forward Declarations -------------------------
      
   2: Block( node_type varNodeType, Label labelForBody );
   2: BlockDecls( node_type varNodeType );
   2: BlockStmt( Label labelForBody, Node varScope, boolean isMain );
   2: VarDecl( node_type varNodeType );
   2: newType( node_type nt, int size ) >> Node;
   2: newIdent( node_type nt, int id ) >> Node;
   2: EmitValue( Node decl );
   2: TypeRef( out Node theType );
   2: EnumTypeRef( out Node resultType );
   2: PointerTypeTo( Node theType ) >> Node;
   2: OrdinalLow( Node theType ) >> int;
   2: OrdinalHigh( Node theType ) >> int;
   2: AssignStmt( Node decl );
   2: BooleanExprControlFlow( out Label falseLabel );
   2: ExprAllowFlow( out Label falseLabel );
   2: BoolExprAllowFlow( out Label falseLabel );
   2: BoolTermAllowFlow( out Label falseLabel );
   2: BoolFactorAllowFlow( out Label falseLabel );
   2: ArithExprAllowFlow( out Label falseLabel );
   2: TermAllowFlow( out Label falseLabel );
   2: FactorAllowFlow( out Label falseLabel );
   2: PrimaryAllowFlow( out Label falseLabel );
      
   2: VarExpr( Node decl );
   2: LValueFromDecl( Node decl, boolean writeable );
   2: LValueVar( Node decl, boolean writeable );
   2: IncVar( Node decl );
   2: DecVar( Node decl );
      
   2: FlowToVal( inout Label falseLabel );
   2: ValToFlow( out Label falseLabel );
   2: MoveIntoTempShortString >> int;
      
   2: DeclLevel( Node decl ) >> int;
   2: DeclUpLevels( Node decl ) >> int;
      
      % ----------------------------- Start ----------------------------
      
   2: MainRule:
   4:    @Program
   7:    ;
      
   7: include 'pascal_unit.ssl'
      
      %
      %  Pascal Compiler
      %
      
      % ------------------------------ Units -----------------------------
      
      
      % The uses clause is a list of units required by the user program or unit.
      % We will find and compile the named units (unless already loaded).
      % We do not make the unit interface visible to the user, the caller will do so later.
   7: UsesClause( Node user ):
   9:    {
   9:       pIdent
  11:       @Uses( LAST_ID, user )
  20:       [
  20:          | ',' :
  22:          | * :  >
  29:       ]
  29:    }   
  31:    ';'
  34:    ;
      
      
      % Process an implicit "uses mysystem" in every module, except in the mysystem unit itself.
      % (I'm calling the unit mysystem rather than system, so fpc doesn't use it to replace its own system unit.)
      %
  34: UsesMySystem( Node user ):
  36:    [ equal( oNodeGetInt( user, qIdent ), mysystemId )
  53:       | true :  >>
  55:       | * :
  60:    ]
  60:    @Uses( mysystemId, user )
  71:    ;
      
      
      % After processing the mysystem unit interface, grab certain declarations from it
      % that the compiler may want to refer to later.
      %
  71: FindSelectSystemDecls( Node unit ):
  73:    [ equal( oNodeGetInt( unit, qIdent ), mysystemId )
  90:       | true :
  91:          System_ShortStringAppendShortString = oNodeFind( oScopeCurrent, qDecls, qIdent, oId_ShortStringAppendShortString )
 108:          System_ShortStringAppendChar = oNodeFind( oScopeCurrent, qDecls, qIdent, oId_ShortStringAppendChar )
 125:          System_ShortStringCmp = oNodeFind( oScopeCurrent, qDecls, qIdent, oId_ShortStringCmp )
 142:       | * :
 147:    ]
 148:    ;
      
      
      % The given user module uses a unit with the given id,
      % which may or may not have been loaded already.
      %
 148: Uses( int id, Node user ):
 150:    Node unit = @FindOrCompileUnit( id )
 161:    [ equal_node( unit, Null )
 171:       | false :
 172:          oNodeAddLast( user, qUsedUnits, unit )
      
               % Put a declaration in the current scope, naming the unit and pointing to it.
               % This is to allow references to  <unit>.<identifier_in_unit>
 184:          Node unitRef = oNodeNew( nUnitRef )
 194:          oNodeSetInt( unitRef, qIdent, oNodeGetInt( unit, qIdent ) )
 213:          oNodeSet( unitRef, qPublicScope, oNodeGet( unit, qPublicScope ) )
 232:          oScopeDeclare( unitRef )
 238:       | * :
 243:    ];
      
      
      % If the given decl is for an nUnitRef, the program is using syntax <unit>.<identifier>
      % Parse the rest of that to find the intended decl.
      %
 244: ResolveUnitRef( inout Node decl ):
 246:    [ oNodeType( decl )
 253:       | nUnitRef :
 254:          Node scope = oNodeGet( decl, qPublicScope )
 267:          '.'
 269:          pIdent
 271:          decl = oScopeFindRequireInScope( scope )
 281:       | * :
 286:    ];
      
      
 287: EnterUsedUnits( Node user ):
         % Make the used units' public scopes directly visible.
         % This is done after the units are all compiled, so they don't interfere with each other incorrectly.
         % Units later in the list have priority.
 289:    NodeIter unitIt = oNodeGetIter( user, qUsedUnits )
 302:    {
 302:       Node unit = oNodeIterValue( unitIt )
 312:       [ oNodeNull( unit )
 319:          | false :
 320:             oScopeEnter( oNodeGet( unit, qPublicScope ) )
 333:          | * :
 338:             >
 340:       ]
 340:       oNodeIterNext( unitIt )
 346:    }
 349:    ;
      
 349: EndUsedUnits( Node user ):
         % Leave the units' public scopes, so no longer visible.
 351:    NodeIter unitIt = oNodeGetIterLast( user, qUsedUnits )
 364:    {
 364:       Node unit = oNodeIterValue( unitIt )
 374:       [ oNodeNull( unit )
 381:          | false :
                  % Consistency check.  Make sure our scope enter / end have lined up correctly.
 382:             [ oNodeEqual( oScopeCurrent, oNodeGet( unit, qPublicScope ) )
 398:                | true :
 399:                | false :  #eInternalScopeMismatch
 403:             ]
 411:             oScopeEnd
 412:          | * :
 417:             >
 419:       ]
 419:       oNodeIterPrev( unitIt )
 425:    }
 428:    ;
      
      
 428: FindOrCompileUnit( int id ) >> Node:
         % We might have this unit loaded already
 430:    Node unit = oNodeFind( workspace, qUnits, qIdent, id )
 449:    [ equal_node( unit, Null )
 459:       | false :  >> unit
 463:       | * :
 468:    ]
      
         % If not, search for the source file on disk
 468:    boolean ok = oIncludeUnitFile( id )
 478:    [ ok
 481:       | false :  #eCantFindUnitFile  >> Null
 487:       | * :
 492:    ]
      
         % compile it, adding it into the workspace
         % then return it.
 492:    unit = @Unit
      
         % TO DO: ensure we are at pEof
         % end the include
 498:    oIncludeEnd
 499:    >> unit;
      
      
      
 503: Unit >> Node:
 505:    pUnit
 507:    pIdent
 509:    Node unit = oNodeNew( nUnit )
 519:    oNodeSetInt( unit, qIdent, LAST_ID )
 530:    Node unitImpl = oNodeNew( nUnitImpl )
 540:    oNodeSetInt( unitImpl, qIdent, LAST_ID )
 551:    oNodeSet( unit, qImpl, unitImpl )
 563:    ';'
      
         % mandatory sections
      
 565:    pInterface
 567:    @UsesMySystem( unit )
 574:    [
 574:       | pUses :   @UsesClause( unit )
 583:       | * :
 588:    ]
 588:    @EnterUsedUnits( unit )
      
 595:    oScopeBegin( 0, allocGlobal )
 604:    oNodeSet( unit, qPublicScope, oScopeCurrent )
 615:    globalScope = oScopeCurrent
      
         % A scope for temporaries needed by variable initialization
 620:    oScopeBegin( 0, allocDown )
 629:    initScope = oScopeCurrent
 634:    oNodeSet( unit, qInitRoutineScope, initScope )
 646:    oScopeEnd
      
 647:    @UnitInterface( unit )
 654:    oScopeEnd  % interface scope
      
 655:    pImplementation
 657:    @UsesMySystem( unitImpl )
 664:    [
 664:       | pUses :   @UsesClause( unitImpl )
 673:       | * :
 678:    ]
 678:    @EnterUsedUnits( unitImpl )
         % re-enter interface scope after impl's uses.  interface still has priority.
 685:    oScopeEnter( oNodeGet( unit, qPublicScope ) )
         
 698:    oScopeBegin( 0, allocGlobal )
 707:    oNodeSet( unit, qPrivateScope, oScopeCurrent )
 718:    oNodeSet( oScopeCurrent, qExtends, oNodeGet( unit, qPublicScope ) )
 736:    globalScope = oScopeCurrent
 741:    @UnitImplementation( unit )
      
 748:    [
 748:       | pInitialization :  @UnitInitialization( unit, true )   % init routine with statements from init section
 760:       | * :                @UnitInitialization( unit, false )  % implicit init routine
 775:    ]
 775:    [
 775:       | pFinalization :  @UnitFinalization( unit, true )
 787:       | * :              @UnitFinalization( unit, false )   % implicit final routine, may be handy later
 802:    ]
 802:    pEnd  '.'
      
 806:    oScopeEnd  % impl scope
 807:    oScopeEnd  % interface scope
 808:    @EndUsedUnits( unitImpl )  % used units scopes
 815:    @EndUsedUnits( unit )
 822:    oNodeAddLast( workspace, qUnits, unit )
 834:    >> unit;
      
      
 838: UnitInterface( Node unit ):
 840:    {[
 840:       | pConst :     @ConstDecl
 844:       | pType :      @TypeDecl
 848:       | pVar :       @VarDecl( nGlobalVar )
            % label declaration not allowed in interface
      
 857:       | pProcedure :
 859:          Node decl = @ProcHeaderDecl
               % despite syntax diagrams, fpc does allow external clause on methods in unit interface,
               % even though this clause is an alternative for the body statement.
 865:          [
 865:             | pExternal :
 867:                @ExternalDecl( decl )
 874:                ';'
 876:             | * :
 881:          ]
      
 881:       | pFunction :
 883:          Node decl = @FuncHeaderDecl
 889:          [
 889:             | pExternal :
 891:                @ExternalDecl( decl )
 898:                ';'
 900:             | * :
 905:          ]
      
 905:       | * :          >
 920:    ]}
 922:    @FindSelectSystemDecls( unit )
 930:    ;
      
 930: UnitImplementation( Node unit ):
 932:    @BlockDecls( nGlobalVar )
 940:    ;
      
      
 940: UnitInitialization( Node unit, boolean hasStmts ):
 942:    Label label = oLabelNew
 947:    .tLabel  oEmitLabel( label )
 955:    oNodeSetLabel( unit, qInitLabel, label )
      
 967:    int patchLS
 967:    .tEnter  patchLS = Here  .tSpace
      
         % insert any code for initialization of this unit's variables.
         
 976:    Node scope
 976:    Code initCode
      
 976:    scope = oNodeGet( unit, qPublicScope )
 989:    initCode = oNodeGetCode( scope, qInitCode )
1002:    oEmitCode( initCode )
1008:    oNodeSetCode( scope, qInitCode, codeNull )
      
1020:    scope = oNodeGet( unit, qPrivateScope )
1033:    initCode = oNodeGetCode( scope, qInitCode )
1046:    oEmitCode( initCode )
1052:    oNodeSetCode( scope, qInitCode, codeNull )
      
1064:    oScopeEnter( oNodeGet( unit, qInitRoutineScope ) )
      
1077:    [ hasStmts
1080:       | true :     
1081:          @Statement
1083:          {[
1083:             | ';' :  @Statement
1087:             | * :    >
1094:          ]}
1096:       | * :
1101:    ]
      
1101:    .tReturn
      
1103:    int localSpace = oNodeGetInt( oScopeCurrent, qSize )
1115:    oPatch( patchLS, localSpace )
1124:    oScopeEnd   % init routine scope, for temporaries
1126:    ;
      
      
1126: UnitFinalization( Node unit, boolean hasStmts ):
1128:    Label label = oLabelNew
1133:    .tLabel  oEmitLabel( label )
1141:    oNodeSetLabel( unit, qFinalLabel, label )
      
1153:    int patchLS
1153:    .tEnter  patchLS = Here  .tSpace
      
         % final routine scope, for temporaries
1162:    oScopeBegin( 0, allocDown )
      
1171:    [ hasStmts
1174:       | true :     
1175:          @Statement
1177:          {[
1177:             | ';' :  @Statement
1181:             | * :    >
1188:          ]}
1190:       | * :
1195:    ]
      
1195:    .tReturn
      
1197:    int localSpace = oNodeGetInt( oScopeCurrent, qSize )
1209:    oPatch( patchLS, localSpace )
1218:    oScopeEnd   % final routine scope, for temporaries
1220:    ;
      
      
1220: InitializeUnits:
         % call init routine of each loaded unit, in the order they were loaded
         % (used directly or indirectly by the main program).
1222:    NodeIter it = oNodeGetIter( workspace, qUnits )
1235:    {
1235:       Node unit = oNodeIterValue( it )
1245:       [ oNodeNull( unit )
1252:          | true :  >
1255:          | false :
1257:             .tAllocActuals  oEmitInt( 0 )  % not sure I need this. maybe for stack alignment.
1265:             .tCall  oEmitLabel( oNodeGetLabel( unit, qInitLabel ) )
1280:             .tFreeActuals  oEmitInt( 0 )
1288:             oNodeIterNext( it )
1294:       ]
1302:    };
      
      
1305: FinalizeUnits:
1307:    NodeIter it = oNodeGetIterLast( workspace, qUnits )
1320:    {
1320:       Node unit = oNodeIterValue( it )
1330:       [ oNodeNull( unit )
1337:          | true :  >
1340:          | false :
1342:             .tAllocActuals  oEmitInt( 0 )  % not sure I need this. maybe for stack alignment.
1350:             .tCall  oEmitLabel( oNodeGetLabel( unit, qFinalLabel ) )
1365:             .tFreeActuals  oEmitInt( 0 )
1373:             oNodeIterPrev( it )
1379:       ]
1387:    };
      
1390: include 'pascal_decl.ssl'
      %
      % Pascal Compiler
      %
      
      % ----------------------------- Declarations ----------------------------
      
      
      
      % modifers that may appear on a proc/function declaration.
      %
1390: MethodModifiers( Node decl ):
1392:    {[
1392:       | pCdecl :
1394:          oNodeSetBoolean( decl, qCdecl, true )
1406:          ';'
      
1408:       | * : >
1415:    ]}
1418:    ;
      
      
      % external method resides in an external object file
      % (or in my system, the built-in runtime library).
      % The method has a label, as usual, which callers will use.
      % But we define that label with .tLabelExtern rather than .tLabel.
      %
      % Note this is fpc syntax.  I'm not sure about other Pascals.
      %
1418: ExternalDecl( Node decl ):
1420:    [ equal_zero( @DeclLevel( decl ) )
1432:       | false :  #eExternalMethodCannotBeNested
1435:       | * :
1440:    ]
1440:    oNodeSetBoolean( decl, qExternal, true )
1452:    [
1452:       | pStrLit :
               % that was the optional library name containing the method.
               % TO DO: I'm currently ignoring this.
1454:          [
1454:             | pName :
1456:                pStrLit
                     % that was the optional method name defined in that library,
                     % which might differ from the Pascal name.
1458:                oNodeSetString( decl, qExternalName, CURRENT_STRLIT )
1469:             | * :
1474:          ]
1474:       | * :
1479:    ]
1479:    @DefineExternLabel( decl )
1487:    ;
      
      
1487: ProcHeaderDecl >> Node:
1489:    pIdent
      
         % If we already have a forward declaration, we'll modify that decl
         % instead of creating a second symbol table entry.
         % (Alternatively could delete or hide the old entry.)
1491:    boolean redeclaring = false
1497:    Node decl = oScopeFindInCurrentScope
      
1502:    [ oNodeNull( decl )
1509:       | true :
               % first declaration
1510:          decl = @newIdent( nProc, LAST_ID )
1523:          oNodeSetLabel( decl, qValue, oLabelNew )
      
1534:       | false :
               % we already have a declaration.
               % Keep it, and its label.
1536:          redeclaring = true
1542:          [ oNodeGetBoolean( decl, qBodyDefined )
1552:             | true : #eAlreadyDefined
1555:             | * :
1560:          ]
1560:          [ oNodeGetBoolean( decl, qExternal )
1570:             | true : #eAlreadyDefined
1573:             | * :
1578:          ]
1578:          [ oNodeType( decl )
1585:             | nProc :
1586:             | * : #eAlreadyDefined   % wrong kind
1593:          ]
               % Move the existing param scope aside, so we can check that the
               % new one is consistent.  And, the body will want to see the new one
               % since the names might differ.
               % TO DO: If qOldParams already set, we have multiple forward decls,
               % which I believe is supposed to be an error.
1593:          oNodeSet( decl, qOldParams, oNodeGet( decl, qParams ) )
1612:          oNodeSet( decl, qParams, Null )
1624:    ]
      
1632:    int level = @ScopeLevel
1638:    boolean nested = greater( level, 0 )
1651:    inc( level )
1657:    oScopeBegin( level, allocUp )
1666:    Node paramScope = oScopeCurrent
      
         % A nested method has a hidden first param for the parent static scope.
         % This won't appear in the param decls list, just reserve space for it.
         % It's first so the static chain is always at a fixed offset from the frame pointer.
1671:    [ nested
1674:       | true :
1675:          int offset = oScopeAllocType( @PointerTypeTo( IntegerType ) )   % arbitrary ptr type
1690:       | * :
1695:    ]
      
1695:    @FormalArgDecl
1697:    oNodeSet( decl, qParams, paramScope )
1709:    oScopeEnd
1710:    ';'
      
1712:    [ redeclaring
1715:       | false : oScopeDeclare( decl )
1722:       | true :  % TO DO: check that qParams is consistent with qOldParams
1724:    ]
      
1732:    @MethodModifiers( decl )
1739:    >> decl;
      
      
1743: ProcDecl:
1745:    Node decl = @ProcHeaderDecl
      
         % Body may be a statement, "forward", "external".
         % Note, this syntax is based on FPC, and I'm not sure if other Pascals are similar.
         % FPC says that forward, external, cdecl, name, etc are not reserved words -
         % I think this means the user may declare other things with those names, but if so the
         % original meaning is lost.  I'll make them keywords for simplicity, for now
         % (just not too happy about "name").
      
1751:    [
1751:       | pForward :
               % Nothing to do.  We simply won't set qBodyDefined.
      
1753:       | pExternal : @ExternalDecl( decl )
      
1762:       | * :
               % Body statement
      
               % Enter the params scope again, so params are visible in body.
               % TO DO: Perhaps I could mark the scope read-only at this point.
1769:          Node paramScope = oNodeGet( decl, qParams )
1782:          oScopeEnter( paramScope )
      
               % Start scope for declarations within the proc
1788:          int level = oNodeGetInt( paramScope, qLevel )
1801:          oScopeBegin( level, allocDown )
1810:          oNodeSet( decl, qChildScope, oScopeCurrent )
      
1821:          Label label = oNodeGetLabel( decl, qValue )
1834:          @Block( nLocalVar, label )
1844:          oNodeSetBoolean( decl, qBodyDefined, true )
1856:          oScopeEnd
      
1857:          oScopeEnd  % paramScope
1858:    ]
1858:    ';';
      
      
      
1861: FuncHeaderDecl >> Node:
1863:    pIdent
      
         % If we already have a forward declaration, we'll modify that decl
         % instead of creating a second symbol table entry.
         % (Alternatively could delete or hide the old entry.)
1865:    boolean redeclaring = false
1871:    Node decl = oScopeFindInCurrentScope
      
1876:    [ oNodeNull( decl )
1883:       | true :
               % first declaration
1884:          decl = @newIdent( nFunc, LAST_ID )
1897:          oNodeSetLabel( decl, qValue, oLabelNew )
      
1908:       | false :
               % we already have a declaration.
               % Keep it, and its label.
1910:          redeclaring = true
1916:          [ oNodeGetBoolean( decl, qBodyDefined )
1926:             | true : #eAlreadyDefined
1929:             | * :
1934:          ]
1934:          [ oNodeType( decl )
1941:             | nFunc :
1942:             | * : #eAlreadyDefined   % wrong kind
1949:          ]
               % Move the existing param scope and return value aside,
               % so we can check that the new one is consistent.
               % And, the body will want to see the new one since the names might differ.
               % TO DO: If qOldParams already set, we have multiple forward decls,
               % which I believe is supposed to be an error.
1949:          oNodeSet( decl, qOldParams, oNodeGet( decl, qParams ) )
1968:          oNodeSet( decl, qParams, Null )
1980:          oNodeSet( decl, qOldType, oNodeGet( decl, qType ) )
1999:          oNodeSet( decl, qType, Null )
2011:    ]
      
2019:    int level = @ScopeLevel
2025:    boolean nested = greater( level, 0 )
2038:    inc( level )
2044:    oScopeBegin( level, allocUp )
2053:    Node paramScope = oScopeCurrent
      
         % A nested method has a hidden first param for the parent static scope.
         % This won't appear in the param decls list, just reserve space for it.
         % It's first so the static chain is always at a fixed offset from the frame pointer.
2058:    [ nested
2061:       | true :
2062:          int offset = oScopeAllocType( @PointerTypeTo( IntegerType ) )   % arbitrary ptr type
2077:       | * :
2082:    ]
      
2082:    @FormalArgDecl
2084:    oNodeSet( decl, qParams, paramScope )
      
2096:    ':'
      
2098:    Node theType
2098:    @TypeRef( theType )
2105:    oNodeSet( decl, qType, theType )
      
         % The function's param space gets an additional pointer,
         % which will point to a temporary in the caller's scope.
         % This pointer is essentially a VAR param, but I won't create an nParam for it.
      
2117:    Node ptrType = @PointerTypeTo( theType )
2128:    oNodeSetInt( decl, qResultOffset, oScopeAllocType( ptrType ) )
2144:    oScopeEnd
2145:    ';'
      
2147:    [ redeclaring
2150:       | false : oScopeDeclare( decl )
2157:       | true :  % TO DO: check that qParams is consistent with qOldParams
                      % and qType is consistent with qOldType
2159:    ]
      
2167:    @MethodModifiers( decl )
      
2174:    >> decl;
      
      
2178: FuncDecl:
2180:    Node decl = @FuncHeaderDecl
      
         % Body may be a statement, "forward", "external".
2186:    [
2186:       | pForward :
               % Nothing to do.  We simply won't set qBodyDefined.
      
2188:       | pExternal : @ExternalDecl( decl )
      
2197:       | * :
               % Body statement
      
               % Enter the params scope again, so params are visible in body.
               % TO DO: Perhaps I could mark the scope read-only at this point.
2204:          Node paramScope = oNodeGet( decl, qParams )
2217:          oScopeEnter( paramScope )
      
               % Start scope for declarations within the func
2223:          int level = oNodeGetInt( paramScope, qLevel )
2236:          oScopeBegin( level, allocDown )
2245:          oNodeSet( decl, qChildScope, oScopeCurrent )
      
2256:          Label label = oNodeGetLabel( decl, qValue )
2269:          @Block( nLocalVar, label )
2279:          oNodeSetBoolean( decl, qBodyDefined, true )
2291:          oScopeEnd
      
2292:          oScopeEnd  % paramScope
2293:    ]
2293:    ';';
      
      
2296: FormalArgDecl:
2298:    [
2298:       | '(' :
2300:          {
2300:             NodeVec decls = oNodeVecNew
2305:             Node decl
2305:             boolean isInOut = false
      
2311:             [
2311:                | pVar : isInOut = true
2319:                | * :
2324:             ]
      
2324:             {  pIdent
      
2326:                decl = @newIdent( nParam, LAST_ID )
2339:                oNodeSetBoolean( decl, qInOut, isInOut )
2351:                oNodeVecAppend( decls, decl )
      
2360:                [
2360:                   | ':' : >
2364:                   | ',' :
2366:                ]
2374:             }
      
2376:             Node theType
2376:             @TypeRef( theType )
      
                  % VAR param is declared with its given type, but allocated as a pointer.
2383:             Node allocType
2383:             [ isInOut
2386:                | true :   allocType = @PointerTypeTo( theType )
2398:                | * :      allocType = theType
2409:             ]
      
2409:             int i = 0
2415:             {[ equal( i, oNodeVecSize( decls ) )
2429:                | false :
2430:                   decl = oNodeVecElement( decls, i )
      
2443:                   oNodeSet( decl, qType, theType )
2455:                   oScopeDeclare( decl )
2461:                   oNodeSetInt( decl, qValue, oScopeAllocType( allocType ) )
2477:                   inc( i )
2483:                | * :
2488:                   >
2490:             ]}
      
2492:             oNodeVecDelete( decls )
      
2498:             [
2498:                | ')' : >
2502:                | ';' :
2504:             ]
2512:          }
2514:       | * :
2519:    ];
      
      
2520: ConstDecl:
2522:    {[
2522:       | pIdent :
2524:          [
2524:             | ':' :
2526:                @TypedConstDecl
2528:             | * :
2533:                @TrueConstDecl
2535:          ]
2535:       | * :
2540:          >
2542:    ]};
      
      
      % Parse a true constant declaration (as opposed to a typed const declaration).
      % The "true constant" terminology comes from Delphi docs.  It refers to a const that is
      % evaluated at compile time, rather than at program startup time.
      %
      % We've just accepted the identifier.
      %
2545: TrueConstDecl:
2547:    int id = LAST_ID
2552:    '='
      
2554:    @ConstExpr
      
2556:    Node decl
2556:    [ oTypeSNodeType
2558:       | nBooleanType, nByteType, nCharType, nIntegerType, nEnumType,
2559:         nPointerType, nUniversalPointerType :
2559:          decl = @newIdent( nConst, id )
2573:          oNodeSetInt( decl, qValue, oValueTop )
2584:       | nStrLitType :
2586:          decl = @newIdent( nConstStr, id )
2600:          oNodeSetString( decl, qValueStr, oValueTopString )
2611:       | * :  #eNotAllowed
2632:    ]
2632:    oValuePop
2633:    oNodeSet( decl, qType, oTypeSTop )
2644:    oTypeSPop
2645:    oScopeDeclare( decl )
2651:    ';'
2654:    ;
      
      
      % Parse a typed const declaration.
      % We've just accepted the identifier and ':'
      %
2654: TypedConstDecl:
2656:    Node decl = @newIdent( nTypedConst, LAST_ID )
      
2669:    Node theType
2669:    @TypeRef( theType )
2676:    oNodeSet( decl, qType, theType )
      
         % Array and record consts are allocated in global memory,
         % with global offset stored as decl value.
         % Scalar consts are not allocated in memory, and their value is
         % stored directly as the decl value, as I do with "true constants".
         %
         % TO DO: I probably should store scalar consts in memory too, in case somebody
         % wants to get a pointer to them.  And anyway, typed constants can't be used in
         % constant expressions, so less need to store value in decl node.
      
         % TO DO: skip subranges, similar to oTypeSNodeType.
2688:    [ oNodeType( theType )
2695:       | nBooleanType, nByteType, nCharType, nIntegerType, nEnumType,
2696:         nPointerType, nUniversalPointerType :
               % Parse expression and store value in decl
2696:          '='
      
2698:          oTypeSPush( theType )
2704:          @ConstExpr
2706:          @ConstCoerceType
      
2708:          oNodeSetInt( decl, qValue, oValueTop )
2719:          oValuePop
2720:          oTypeSPop
2721:          oScopeDeclare( decl )
2727:          ';'
      
2729:       | nShortStringType, nFileType :
2731:          #eNotImplemented
      
2733:       | nArrayType, nRecordType :
               % Allocate global space, store address in decl.
               % Push into global scope init code stream (since we'll be issuing code
               % rather than creating static data, at the moment).
               % Parse expression and store in global memory.
2735:          oScopeEnter( globalScope )
2741:          int addr = oScopeAllocType( theType )
2751:          oScopeEnd
2752:          oCodePush( @GetOrCreateInitCode( globalScope ) )
2763:          oNodeSetInt( decl, qValue, addr )
2775:          '='
2777:          @TypedConstInit( theType, addr )
2787:          oCodePop
2788:          oScopeDeclare( decl )
2794:          ';'
2796:    ]
2823:    ;
      
      
      % Parse the initial value of a constant that's being stored in global memory.
      % (An array or record constant, and recursively all its elements.)
      % Given the type, and the address in global memory for the const value.
      % The caller has already pushed into the global init code stream.
      %
2823: TypedConstInit( Node theType, int addr ):
      
         % TO DO: skip subranges, similar to oTypeSNodeTYpe
2825:    [ oNodeType( theType )
2832:       | nArrayType :
2833:          Node baseType = oNodeGet( theType, qBaseType )
2846:          Node indexType = oNodeGet( theType, qIndexType )
2859:          int low = @OrdinalLow( indexType )
2870:          int high = @OrdinalHigh( indexType )
2881:          int elementSize = oNodeGetInt( baseType, qSize )
      
2894:          '('
               % Loop over elements
2896:          int i = low
2902:          {
2902:             @TypedConstInit( baseType, addr )
2912:             [ equal( i, high )
2922:                | true : >
2925:                | false :
2927:             ]
2935:             ','
2937:             addr = add( addr, elementSize )
2950:             inc( i )
2956:          }
2958:          ')'
      
2960:       | nRecordType :
2962:          '('
2964:          Node fieldScope = oNodeGet( theType, qScope )
               % Loop over zero or more named fields.  It's not necessary to name them all.
               % fpc says the names that are given should be in order, but I'm not requiring that.
               % Since this is global memory, uninitialized fields will be left as 0.
2977:          {
2977:             [
2977:                | pIdent :
2979:                | * :  >
2986:             ]
2986:             Node field = oScopeFindRequireInScope( fieldScope )
2996:             ':'
2998:             Node fieldType = oNodeGet( field, qType )
3011:             int fieldAddr = add( addr, oNodeGetInt( field, qValue ) )
3031:             @TypedConstInit( fieldType, fieldAddr )
3041:             [
3041:                | ';' :
3043:                | * :  >
3050:             ]
3050:          }
3052:          ')'
      
3054:       | nBooleanType, nByteType, nCharType:
3056:          .tPushAddrGlobal  oEmitInt( addr )
3064:          oTypeSPush( theType )
3070:          @ConstExpr
3072:          @ConstCoerceType
3074:          .tPushConstI  oEmitInt( oValueTop )
3081:          oValuePop
3082:          oTypeSPop
3083:          .tAssignB
      
3085:       | nIntegerType, nEnumType:
3087:          .tPushAddrGlobal  oEmitInt( addr )
3095:          oTypeSPush( theType )
3101:          @ConstExpr
3103:          @ConstCoerceType
3105:          .tPushConstI  oEmitInt( oValueTop )
3112:          oValuePop
3113:          oTypeSPop
3114:          .tAssignI
      
3116:       | nDoubleType:
3118:          #eNotImplemented
      
3120:       | nPointerType, nUniversalPointerType :
3122:          .tPushAddrGlobal  oEmitInt( addr )
3130:          oTypeSPush( theType )
3136:          @ConstExpr
3138:          @ConstCoerceType
3140:          .tPushConstI  oEmitInt( oValueTop )   % only allowing ptr constant Nil so don't need tPushConstP or link redirection
3147:          oValuePop
3148:          oTypeSPop
3149:          .tAssignP
      
3151:       | nShortStringType, nFileType :
3153:          #eNotImplemented
3155:    ]
3184:    ;
      
      
3184: TypeDecl:
3186:    {[
3186:       | pIdent :
3188:          Node decl = @newIdent( nTypeDecl, LAST_ID )
3201:          '='
3203:          Node theType
3203:          @TypeRef( theType )
3210:          oNodeSet( decl, qType, theType )
3222:          oScopeDeclare( decl )
3228:          ';'
3230:       | * :
3235:          >
3237:    ]};
      
3240: VarDecl( node_type varNodeType ):
3242:    {[
3242:       | pIdent :
3244:          NodeVec decls = oNodeVecNew
3249:          Node decl
3249:          {
3249:             decl = @newIdent( varNodeType, LAST_ID )
3262:             oNodeVecAppend( decls, decl )
3271:             [
3271:                | ',' :
3273:                   pIdent
3275:                | * :
3280:                   >
3282:             ]
3282:          }
3284:          ':'
3286:          Node theType
3286:          @TypeRef( theType )
      
3293:          int i = 0
3299:          {[ equal( i, oNodeVecSize( decls ) )
3313:             | false :
3314:                decl = oNodeVecElement( decls, i )
3327:                oNodeSet( decl, qType, theType )
3339:                oScopeDeclareAlloc( decl )
3345:                inc( i )
3351:             | * :
3356:               >
3358:          ]}
      
               % optional initialization
3360:          [
3360:             | '=' :
3362:                [ oNodeVecSize( decls )
3369:                   | 1 :
3370:                   | * :  #eOnlyOneVarCanBeInitialized
3377:                ]
      
                     % we need an initCode stream for this scope
3377:                Code initCode = @GetOrCreateInitCode( oScopeCurrent )
3387:                oCodePush( initCode )
      
                     % currently the global level has two scopes:
                     % the one for declarations e.g. vars and methods,
                     % and a second one for temporaries needed by the main block stmt.
                     % During evaluation of the init expr, we need to be in the 2nd scope
                     % in case the expression requires temporaries
                     % (so the temporaries get allocated in the right scope).
                     % TO DO: Maybe I should make the global scope the special case, instead.
3393:                boolean changedScope = false
3399:                [ equal_zero( @ScopeLevel )
3406:                   | true : oScopeEnter( initScope )
3413:                            changedScope = true
3419:                   | * :
3424:                ]
                     % generate assignment in initCode stream
3424:                @LValueVar( decl, true )
3434:                @Expr
3436:                @CoerceType
3438:                @Assign
3440:                [ changedScope
3443:                   | true : oScopeEnd
3445:                   | * :
3450:                ]
3450:                oCodePop
                   
3451:             | * :
3456:          ]
      
3456:          oNodeVecDelete( decls )
3462:          ';'
3464:       | * :
3469:          >
3471:    ]};
      
      
      % Parse a list of label declarations.
      % We'll create a tcode label at declaration time, for each user label.
      % If the user label is an integer, we'll record it as _label_<int> in the decl.
      %
3474: LabelDecl:
3476:    {
3476:       Node decl
3476:       [
3476:          | pIdent :
3478:          | pIntLit :
                  % Replace token with identifier "_label_<intlit>"
3480:             oChangeIntLitToLabelIdent
3481:       ]
3489:       decl = @newIdent( nLabel, LAST_ID )
            % TO DO: ensure not already declared in this scope.
            %        Or maybe that can be part of oScopeDeclare.
3502:       Label label = oLabelNew
3507:       oNodeSetLabel( decl, qValue, label )
3519:       oScopeDeclare( decl )
3525:       [
3525:          | ',' :
3527:          | * :
3532:             >
3534:       ]
3534:    }
3536:    ';'
3539:    ;
3539: include 'pascal_constexpr.ssl'
      %
      % Pascal Compiler
      %
      
      % --------------------------- Const Expressions --------------------------
      
      
      % Constant expressions are evaluated at compile time.
      % They are limited to constant literals, declared constants (not including TypedConstants!)
      % and a small selection of built-in functions. 
      %
      % The value of a constant expression is left on the Value Stack.
      % The type is left on the Type Stack.
      
3539: ConstExpr:
3541:    @ConstBoolExpr
3543:    {[
3543:       | '=' :
3545:          @ConstBoolTerm
3547:          @ConstMatchTypes
3549:          [ oTypeSNodeType
3551:             | nStrLitType :   oValueStringCmp  oValuePush( 0 )  oValueEqual
3560:             | * :             oValueEqual
3566:          ]
3566:          oTypeSPop  oTypeSPush( BooleanType )
3573:       | '<>' :
3575:          @ConstBoolExpr
3577:          @ConstMatchTypes
3579:          [ oTypeSNodeType
3581:             | nStrLitType :   oValueStringCmp  oValuePush( 0 )  oValueNotEqual
3590:             | * :             oValueNotEqual
3596:          ]
3596:          oTypeSPop  oTypeSPush( BooleanType )
3603:       | '<' :
3605:          @ConstBoolExpr
3607:          @ConstMatchTypes
3609:          [ oTypeSNodeType
3611:             | nStrLitType :   oValueStringCmp  oValuePush( 0 )  oValueLess
3620:             | * :             oValueLess
3626:          ]
3626:          oTypeSPop  oTypeSPush( BooleanType )
3633:       | '>' :
3635:          @ConstBoolExpr
3637:          @ConstMatchTypes
3639:          [ oTypeSNodeType
3641:             | nStrLitType :   oValueStringCmp  oValuePush( 0 )  oValueGreater
3650:             | * :             oValueGreater
3656:          ]
3656:          oTypeSPop  oTypeSPush( BooleanType )
3663:       | '<=' :
3665:          @ConstBoolExpr
3667:          @ConstMatchTypes
3669:          [ oTypeSNodeType
3671:             | nStrLitType :   oValueStringCmp  oValuePush( 0 )  oValueLessEqual
3680:             | * :             oValueLessEqual
3686:          ]
3686:          oTypeSPop  oTypeSPush( BooleanType )
3693:       | '>=' :
3695:          @ConstBoolExpr
3697:          @ConstMatchTypes
3699:          [ oTypeSNodeType
3701:             | nStrLitType :   oValueStringCmp  oValuePush( 0 )  oValueGreaterEqual
3710:             | * :             oValueGreaterEqual
3716:          ]
3716:          oTypeSPop  oTypeSPush( BooleanType )
3723:       | * :  >
3740:    ]};
      
      
      % Same as ConstExpr, but allow a typename as a primary.
      % This is for use within sizeof().
      % The value produced by that primary is bogus, but doesn't matter.
      %
3743: ConstExprAllowTypeName:
3745:    boolean oldAllowTypeName = flagExprAllowTypeName
3751:    flagExprAllowTypeName = true
3757:    @ConstExpr
3759:    flagExprAllowTypeName = oldAllowTypeName
3766:    ;
      
      
3766: ConstBoolExpr:
3768:    @ConstBoolTerm
3770:    {[
3770:       | pOr :
3772:          @ConstRequireBool
3774:          @ConstBoolTerm
3776:          @ConstRequireBoolPop
3778:          oValueOr
3779:       | * :  >
3786:    ]};
      
      
3789: ConstBoolTerm:
3791:    @ConstBoolFactor
3793:    {[
3793:       | pAnd :
3795:          @ConstRequireBool
3797:          @ConstBoolFactor
3799:          @ConstRequireBoolPop
3801:          oValueAnd
3802:       | * :  >
3809:    ]};
      
      
3812: ConstBoolFactor:
3814:    [
3814:       | pNot :
3816:          @ConstBoolFactor
3818:          @ConstRequireBool
3820:          oValueNot
3821:       | * :
3826:          @ConstArithExpr
3828:    ];
      
      
3829: ConstArithExpr:
3831:    @ConstTerm
3833:    {[
3833:       | '+' :
3835:          @ConstTerm
3837:          @ConstMatchTypes
3839:          [ oTypeSNodeType
3841:             | nStrLitType :   oValueStringConcat
3843:             | * :             oValueAdd
3849:          ]
3849:       | '-' :
3851:          @ConstTerm
3853:          @ConstMatchTypes
3855:          [ oTypeSNodeType
3857:             | nStrLitType :   #eNotAllowed
3860:             | * :             oValueSub
3866:          ]
3866:       | * :  >
3875:    ]};
      
      
3878: ConstTerm:
3880:    @ConstFactor
3882:    {[
3882:       | pTimes :
3884:          @ConstFactor
3886:          @ConstMatchTypes
3888:          [ oTypeSNodeType
3890:             | nStrLitType :   #eNotAllowed
3893:             | * :             oValueMult
3899:          ]
3899:       | pDivide :
3901:          @ConstFactor
3903:          @ConstMatchTypes
3905:          [ oTypeSNodeType
3907:             | nStrLitType :   #eNotAllowed
3910:             | * :             oValueDiv
3916:          ]
3916:       | * :  >
3925:    ]};
      
      
3928: ConstFactor:
3930:    [
3930:       | pPlus :
3932:          @ConstPrimary
3934:       | pMinus :
3936:          @ConstPrimary
3938:          oValueNegate
3939:       | * :
3946:          @ConstPrimary
3948:    ];
      
      
3949: ConstPrimary:
3951:    [
3951:       | pIntLit :
3953:          oValuePush( TOKEN_VALUE )
3958:          oTypeSPush( IntegerType )
3964:       | pCharLit :
3966:          oValuePush( TOKEN_VALUE )
3971:          oTypeSPush( CharType )
3977:       | pStrLit :
3979:          oValuePushString( CURRENT_STRLIT )
3984:          oTypeSPush( StrLitType )
3990:       | '(' :
3992:          @ConstExpr
3994:          ')'
3996:       | pIdent :
3998:          Node decl = oScopeFindRequire
4003:          @ResolveUnitRef( decl )
4010:          [ oNodeType( decl )
4017:             | nBuiltInFunc :
4018:                @ConstBuiltInFunc( decl )
4025:             | nConst :
4027:                oValuePush( oNodeGetInt( decl, qValue ) )
4040:                oTypeSPush( oNodeGet( decl, qType ) )
4053:             | nConstStr :
4055:                oValuePushString( oNodeGetString( decl, qValueStr ) )
4068:                oTypeSPush( oNodeGet( decl, qType ) )
4081:             | nEnumValue :
4083:                oValuePush( oNodeGetInt( decl, qValue ) )
4096:                oTypeSPush( oNodeGet( decl, qType ) )
4109:             | nTypeDecl :
                     % A type cast, or a typename primary when within sizeof()
4111:                oTypeSPush( oNodeGet( decl, qType ) )
4124:                [
4124:                   | '(' :
                           % Type cast
4126:                      @ConstExpr
4128:                      ')'
4130:                      @ConstCastType
                           % Constexprs are not compound types or dereferenceable pointers (I believe)
                           % so no need to check for additional suffixes here as we do in PrimaryAllowCF
4132:                   | * :
                           % Not a type cast
                           % A raw typename is only allowed in expressions within sizeof
4137:                      [ flagExprAllowTypeName
4140:                         | true :
                                 % The value we produce is bogus.  Only the type stack matters.
4141:                            oValuePush( 0 )
4147:                         | * :   #eTypeNameNotAllowedHere
4154:                      ]
4154:                ]
      
4154:             | * :
4167:                #eNotConst
4169:                oValuePush( 0 )
4175:                oTypeSPush( IntegerType )
4181:          ]
4181:       | '@' :
4183:          #eNotImplemented
4185:          oValuePush( 0 )
4191:          oTypeSPush( UniversalPointerType )
4197:       | * :
4212:          #eNotConst
4214:          oValuePush( 0 )
4220:          oTypeSPush( IntegerType )
4226:    ];
      
4227: ConstRequireBoolPop:
4229:    [ oTypeSNodeType
4231:       | nBooleanType :
4232:       | * :          #eNotBoolean
4239:    ]
4239:    oTypeSPop;
      
      
4241: ConstRequireBool:
4243:    [ oTypeSNodeType
4245:       | nBooleanType :
4246:       | * :          #eNotBoolean
4253:    ];
      
      
      % Require that the top two types on the type stack are matching (ignoring subranges).
      % Pop one of them, leaving only one.
      % The types refer to constant values on the Value Stack,
      % so any implicit conversion would occur there, not in code.
      %
      % Some implicit conversion is allowed for either of the types.
      % See also ConstCoerceType where only the top type may change.
      %
4254: ConstMatchTypes:
4256:    node_type nt = oTypeSNodeType
4261:    oTypeSPop
4262:    [ equal_node_type( nt, oTypeSNodeType )
4271:       | false :
               % Some implicit conversion is allowed even here
4272:          [ oTypeSNodeType
4274:             | nPointerType :
4275:                [ nt
4278:                   | nUniversalPointerType :  >>
4280:                   | * :
4285:                ]
4285:             | nUniversalPointerType :
4287:                [ nt
4290:                   | nPointerType :  >>
4292:                   | * :
4297:                ]
4297:             | nStrLitType :
4299:                [ nt
4302:                   | nCharType :
4303:                      oValueCharToString
4304:                      >>
4305:                   | * :
4310:                ]
4310:             | nCharType :
4312:                [ nt
4315:                   | nStrLitType :
4316:                      oValueSwap
4317:                      oValueCharToString
4318:                      oValueSwap
4319:                      oTypeSPop
4320:                      oTypeSPush( StrLitType )
4326:                      >>
4327:                   | * :
4332:                ]
4332:             | * :
4343:          ]
4343:          #eTypeMismatch
4345:       | * :
4350:    ];
      
      
      % Given a constant value on the value stack, its type on the type stack,
      % and the desired type under it on the type stack.
      % Perform any necessary implicit conversions so the value is the desired type.
      % Pop the top type, leaving only the desired type.
      %
4351: ConstCoerceType:
4353:    node_type nt = oTypeSNodeType
4358:    oTypeSPop
4359:    [ equal_node_type( nt, oTypeSNodeType )
4368:       | false :
               % Can we implicitly convert the value to the desired type?
4369:          [ oTypeSNodeType
4371:             | nIntegerType :
4372:                [ nt
4375:                   | nByteType :  >>
4377:                   | * :
4382:                ]
4382:             | nByteType :
4384:                [ nt
4387:                   | nIntegerType :  >>
4389:                   | * :
4394:                ]
4394:             | nPointerType :
4396:                [ nt
4399:                   | nUniversalPointerType :  >>
4401:                   | * :
4406:                ]
4406:             | nUniversalPointerType :
4408:                [ nt
4411:                   | nPointerType :  >>
4413:                   | * :
4418:                ]
4418:             | nStrLitType :
4420:                [ nt
4423:                   | nCharType :
4424:                      oValueCharToString
4425:                      >>
4426:                   | * :
4431:                ]
4431:             | nShortStringType :
4433:                [ nt
4436:                   | nStrLitType :  >>
4438:                   | nCharType :
4440:                      oValueCharToString
4441:                      >>
4442:                   | * :
4449:                ]
4449:             | * :
4464:          ]
4464:          #eTypeMismatch
4466:       | * :
4471:    ];
      
      
      % Given a constant value on the value stack, its type on the type stack,
      % and the desired type under it on the type stack.
      % Perform any necessary conversions so the value is cast to the desired type.
      % Pop the top type, leaving only the desired type.
      %
      % This is stronger than ConstCoerceType, since it isn't limited to implicit conversions.
      % There are still going to be limits on what is allowed though.
      %
4472: ConstCastType:
4474:    node_type nt = oTypeSNodeType
4479:    oTypeSPop
4480:    [ equal_node_type( nt, oTypeSNodeType )
4489:       | false :
               % Can we cast the value to the desired type?
4490:          [ oTypeSNodeType
4492:             | nIntegerType, nEnumType :
4493:                [ nt
4496:                   | nByteType, nCharType, nBooleanType :  >>
4498:                   | nIntegerType, nEnumType :  >>
4501:                   | * :
4514:                ]
4514:             | nByteType, nCharType, nBooleanType :
4516:                [ nt
4519:                   | nByteType, nCharType, nBooleanType :  >>
4521:                   | nIntegerType, nEnumType :  >>
4524:                   | * :
4537:                ]
4537:             | nPointerType :
4539:                [ nt
4542:                   | nUniversalPointerType :  >>
4544:                   | * :
4549:                ]
4549:             | nUniversalPointerType :
4551:                [ nt
4554:                   | nPointerType :  >>
4556:                   | * :
4561:                ]
4561:             | nStrLitType :
4563:                [ nt
4566:                   | nCharType :
4567:                      oValueCharToString
4568:                      >>
4569:                   | * :
4574:                ]
4574:             | nShortStringType :
4576:                [ nt
4579:                   | nStrLitType :  >>
4581:                   | nCharType :
4583:                      oValueCharToString
4584:                      >>
4585:                   | * :
4592:                ]
4592:             | * :
4613:          ]
4613:          #eTypeMismatch
4615:       | * :
4620:    ];
      
      
      % These are the methods that Pascal allows in a constant expression:
      %   Abs( x: integer_or_real ) : integer_or_real
      %   Round( x: real ) : integer
      %   Trunc( x: real ) : integer
      %   Chr( x: integer ) : char
      %   Ord( x: ordinal ) : integer
      %   Length( s: string ) : integer
      %   Pred( x: ordinal ) : ordinal
      %   Succ( x: ordinal ) : ordinal
      %   SizeOf( var, expr, or typename ) : integer
      %   Odd( x: integer ) : boolean  - true if the argument is odd
      %
4621: ConstBuiltInFunc( Node method ):
      
         % Ord(x)
4623:    [ oNodeEqual( method, BuiltIn_Ord )
4633:       | true :
4634:          '('
4636:          @ConstExpr
4638:          ')'
4640:          [ oTypeSNodeType
4642:             | nIntegerType, nEnumType :
4643:             | nBooleanType, nByteType, nCharType :
4645:             | * :  #eTypeMismatch
4660:          ]
4660:          oTypeSPop
4661:          oTypeSPush( IntegerType )
4667:          ')'
4669:          >>
4670:       | * :
4675:    ]
      
         % Chr(x)
4675:    [ oNodeEqual( method, BuiltIn_Chr )
4685:       | true :
4686:          '('
4688:          @ConstExpr
4690:          ')'
4692:          [ oTypeSNodeType
4694:             | nIntegerType :
4695:             | nByteType :
4697:             | * :  #eTypeMismatch
4706:          ]
4706:          oTypeSPop
4707:          oTypeSPush( CharType )
4713:          ')'
4715:          >>
4716:       | * :
4721:    ]
      
         % Pred(x)
4721:    [ oNodeEqual( method, BuiltIn_Pred )
4731:       | true :
4732:          '('
4734:          @ConstExpr
4736:          [ oTypeSNodeType
4738:             | nEnumType :
4739:                [ oNodeGetBoolean( oTypeSTop, qHasGap )
4748:                   | true :   #eCantUsePredSuccOnEnumWithValueGaps
4751:                   | * :
4756:                ]
4756:             | * :  #eTypeMismatch
4763:          ]
4763:          oValuePush( 1 )  oValueSub
4770:          ')'
4772:          >>
4773:       | * :
4778:    ]
      
         % Succ(x)
4778:    [ oNodeEqual( method, BuiltIn_Succ )
4788:       | true :
4789:          '('
4791:          @ConstExpr
4793:          [ oTypeSNodeType
4795:             | nEnumType :
4796:                [ oNodeGetBoolean( oTypeSTop, qHasGap )
4805:                   | true :   #eCantUsePredSuccOnEnumWithValueGaps
4808:                   | * :
4813:                ]
4813:             | * :  #eTypeMismatch
4820:          ]
4820:          oValuePush( 1 )  oValueAdd
4827:          ')'
4829:          >>
4830:       | * :
4835:    ]
      
         % Sizeof(x)
4835:    [ oNodeEqual( method, BuiltIn_Sizeof )
4845:       | true :
4846:          '('
               % Parse expression but only for its type.
               % And, allow use of typename as a primary in the expression.
4848:          @ConstExprAllowTypeName
4850:          oValuePop
4851:          Node theType = oTypeSTop
4856:          oTypeSPop
4857:          oValuePush( oNodeGetInt( theType, qSize ) )
4870:          oTypeSPush( IntegerType )
4876:          ')'
4878:          >>
4879:       | * :
4884:    ]
      
4884:    #eNotImplemented
4887:    ;
      
      
4887: include 'pascal_expr.ssl'
      %
      % Pascal Compiler
      %
      
      
      % ------------------------------ Expressions -----------------------------
      
      
      % There are two wrappers leading into expression parsing:
      %   Expr()
      %   BooleanExprControlFlow( out Label falseLabel )
      %
      % Expr always produces a value on the runtime expr stack,
      % and pushes its type on the type stack.
      %
      % BooleanExprControlFlow always generates control-flow code.
      % It does not push a value on the runtime expr stack.
      % It does not push a type on the type stack.
      % The control flow code ends up at Here if the expr is true,
      % and jumps to falseLabel if the expr is false.
      % This rule allocates falseLabel, and passes it back.
      % The caller will need to define its location.
      %
      % The internal methods of expr parsing may produce a mix of
      % values and control flow, depending on the operators seen.
      % We don't always do one or the other, hoping to be efficient for
      % cases like   "func_call( bool_var1, bool_var2 )"
      % as well as  "if bool_expr1 or bool_expr2 then ...".
      % If a subexpression rule produces control flow, it will allocate a
      % falseLabel and pass it back up.  And it will push the
      % result type as BooleanFlowType, to distinguish from BooleanType
      % which corresponds with a boolean value on the expr stack.
      % 
      % Note that my expression parsing is broken into more levels than
      % grammars describe for Pascal precedence levels.  This follows my
      % original parser implementation.  I think my rationale was that
      % operators from the levels that I split up couldn't have been
      % mixed anyway, since they require different data types
      % (e.g. boolean vs int/real).  And splitting them up simplified
      % my code.  But, I should revisit this.
      %
      
      
      % Public entry point:
      %
      % Parse an expression, leaving a value on the runtime expr stack
      % and its type on the type stack.
      %
      % This rule does not export control flow (though it may generate
      % control flow internally for subexpressions).
      %
4887: Expr:
4889:    Label falseLabel = labelNull
      
4895:    @ExprAllowFlow( falseLabel )
4902:    @FlowToVal( falseLabel );
      
      
      % Public entry point:
      %
      % Parse an expression, just like Expr,
      % but also allows type names as Primary elements of the expression.
      % This is for use by sizeof().
      % The value produced by that primary is bogus, but this is ok because the
      % caller (sizeof) is going to discard all generated code for the expression.
      % It's only interested in the type produced by the expression.
      %
4910: ExprAllowTypeName:
4912:    boolean oldAllowTypeName = flagExprAllowTypeName
4918:    flagExprAllowTypeName = true
4924:    @Expr
4926:    flagExprAllowTypeName = oldAllowTypeName
4933:    ;
      
      
      % Public entry point:
      %
      % Parse a Boolean expression, producing control flow code rather than a value.
      % Does not leave a value on the runtime expr stack.
      % Does not leave a type on the type stack.
      %
      % If the expression is true, the code will fall through to the end (Here).
      % If the expression is false, the code will jump to the given falseLabel,
      % which this rule will allocate but not define the location for.
      % The caller must do so.
      %
4933: BooleanExprControlFlow( out Label falseLabel ):
4935:    @ExprAllowFlow( falseLabel )
4942:    [ oTypeSNodeType
4944:       | nBooleanFlowType :
4945:       | nBooleanType :
               % convert value to control flow
4947:          falseLabel = oLabelNew
4952:          .tJumpFalse  oEmitLabel( falseLabel )
4960:       | * :
4967:          #eNotBoolean
4969:    ]
4969:    oTypeSPop;
      
      
      % If the current expr result is control flow, convert it to a value.
      % falseLabel is the label that had been used by the control flow.
      % On return it will be set to labelNull.
      %
4971: FlowToVal( inout Label falseLabel ):
4973:    [ oTypeSNodeType
4975:       | nBooleanFlowType :
4976:          Label doneLabel = oLabelNew
4981:          .tPushConstI  oEmitInt( 1 )
4989:          .tJump  oEmitLabel( doneLabel )
4997:          .tLabel  oEmitLabel( falseLabel )
5005:          .tPushConstI  oEmitInt( 0 )
5013:          .tLabel  oEmitLabel( doneLabel )
5021:          oTypeSPop
5022:          oTypeSPush( BooleanType )
5028:          falseLabel = labelNull
5034:       | * :
5039:    ];
      
      
      % If the current expr result is boolean value, convert it to control flow.
      % falseLabel will be allocated by this rule and passed back.
      % The caller must define its location.
      %
5040: ValToFlow( out Label falseLabel ):
5042:    [ oTypeSNodeType
5044:       | nBooleanType :
5045:          falseLabel = oLabelNew
5050:          .tJumpFalse  oEmitLabel( falseLabel )
5058:          oTypeSPop
5059:          oTypeSPush( BooleanFlowType )
5065:       | * :
5070:    ];
      
      
      % Parse an expression.  It may produce a value on the expr stack,
      % or control flow, depending on what's seen in the expression.
      % Leaves the expression type on the type stack.
      %
      % If the expression produces control flow, the expression type will be
      % nBooleanFlowType.  In this case, a true value falls through to Here,
      % and a false value jumps to falseLabel.  This rule will allocate falseLabel
      % and return it, but will not define its location; the caller must do so.
      %
      % If the expression produces a value, the value will be left on the
      % expression stack, and the type will be some type other than nBooleanFlowType.
      % In this case, falseLabel is ignored.
      %
5071: ExprAllowFlow( out Label falseLabel ):
5073:    @BoolExprAllowFlow( falseLabel )
5080:    {[
5080:       | '=' :
5082:          @FlowToVal( falseLabel )
5089:          @PromoteToIntOptional
5091:          @BoolExprAllowFlow( falseLabel )
5098:          @FlowToVal( falseLabel )
5105:          @PromoteToIntOptional
5107:          @MatchTypes
5109:          [ oTypeSNodeType
5111:             | nBooleanType, nCharType :     .tEqualB
5114:             | nIntegerType, nEnumType :     .tEqualI
5118:             | nPointerType, nUniversalPointerType :    .tEqualP
5122:             | nShortStringType, nStrLitType :
5124:                @ShortStringCmp  .tPushConstI  oEmitInt( 0 )  .tEqualI
5136:             | * :                           #eNotAllowed
5157:          ]
5157:          oTypeSPop
5158:          oTypeSPush( BooleanType )
      
5164:       | '<>' :
5166:          @FlowToVal( falseLabel )
5173:          @PromoteToIntOptional
5175:          @BoolExprAllowFlow( falseLabel )
5182:          @FlowToVal( falseLabel )
5189:          @PromoteToIntOptional
5191:          @MatchTypes
5193:          [ oTypeSNodeType
5195:             | nBooleanType, nCharType :     .tNotEqualB
5198:             | nIntegerType, nEnumType :     .tNotEqualI
5202:             | nPointerType, nUniversalPointerType :    .tNotEqualP
5206:             | nShortStringType, nStrLitType :
5208:                @ShortStringCmp  .tPushConstI  oEmitInt( 0 )  .tNotEqualI
5220:             | * :                           #eNotAllowed
5241:          ]
5241:          oTypeSPop
5242:          oTypeSPush( BooleanType )
      
5248:       | '<' :
5250:          @FlowToVal( falseLabel )
5257:          @PromoteToIntOptional
5259:          @BoolExprAllowFlow( falseLabel )
5266:          @FlowToVal( falseLabel )
5273:          @PromoteToIntOptional
5275:          @MatchTypes
5277:          [ oTypeSNodeType
5279:             | nBooleanType, nCharType :     .tLessB
5282:             | nIntegerType, nEnumType :     .tLessI
5286:             | nPointerType, nUniversalPointerType :   .tLessP
5290:             | nShortStringType, nStrLitType :
5292:                @ShortStringCmp  .tPushConstI  oEmitInt( 0 )  .tLessI
5304:             | * :                           #eNotAllowed
5325:          ]
5325:          oTypeSPop
5326:          oTypeSPush( BooleanType )
      
5332:       | '>' :
5334:          @FlowToVal( falseLabel )
5341:          @PromoteToIntOptional
5343:          @BoolExprAllowFlow( falseLabel )
5350:          @FlowToVal( falseLabel )
5357:          @PromoteToIntOptional
5359:          @MatchTypes
5361:          [ oTypeSNodeType
5363:             | nBooleanType, nCharType :     .tGreaterB
5366:             | nIntegerType, nEnumType :     .tGreaterI
5370:             | nPointerType, nUniversalPointerType :   .tGreaterP
5374:             | nShortStringType, nStrLitType :
5376:                @ShortStringCmp  .tPushConstI  oEmitInt( 0 )  .tGreaterI
5388:             | * :                           #eNotAllowed
5409:          ]
5409:          oTypeSPop
5410:          oTypeSPush( BooleanType )
      
5416:       | '<=' :
5418:          @FlowToVal( falseLabel )
5425:          @PromoteToIntOptional
5427:          @BoolExprAllowFlow( falseLabel )
5434:          @FlowToVal( falseLabel )
5441:          @PromoteToIntOptional
5443:          @MatchTypes
5445:          [ oTypeSNodeType
5447:             | nBooleanType, nCharType :     .tLessEqualB
5450:             | nIntegerType, nEnumType :     .tLessEqualI
5454:             | nPointerType, nUniversalPointerType :   .tLessEqualP
5458:             | nShortStringType, nStrLitType :
5460:                @ShortStringCmp  .tPushConstI  oEmitInt( 0 )  .tLessEqualI
5472:             | * :                           #eNotAllowed
5493:          ]
5493:          oTypeSPop
5494:          oTypeSPush( BooleanType )
      
5500:       | '>=' :
5502:          @FlowToVal( falseLabel )
5509:          @PromoteToIntOptional
5511:          @BoolExprAllowFlow( falseLabel )
5518:          @FlowToVal( falseLabel )
5525:          @PromoteToIntOptional
5527:          @MatchTypes
5529:          [ oTypeSNodeType
5531:             | nBooleanType, nCharType :     .tGreaterEqualB
5534:             | nIntegerType, nEnumType :     .tGreaterEqualI
5538:             | nPointerType, nUniversalPointerType :   .tGreaterEqualP
5542:             | nShortStringType, nStrLitType :
5544:                @ShortStringCmp  .tPushConstI  oEmitInt( 0 )  .tGreaterEqualI
5556:             | * :                           #eNotAllowed
5577:          ]
5577:          oTypeSPop
5578:          oTypeSPush( BooleanType )
      
5584:       | * :
5599:          >
5601:    ]};
      
      
5604: BoolExprAllowFlow( out Label falseLabel ):
5606:    Label trueLabel = labelNull
      
5612:    @BoolTermAllowFlow( falseLabel )
5619:    {[
5619:       | pOr :
5621:          [ oTypeSNodeType
5623:             | nBooleanFlowType :
                     % We are true here. Jump ahead to done
5624:                [ equal_label( trueLabel, labelNull )
5634:                   | true :  trueLabel = oLabelNew
5640:                   | * :
5645:                ]
5645:                .tJump  oEmitLabel( trueLabel )
5653:             | nBooleanType :
5655:                @ValToFlow( falseLabel )
                     % We are true here. Jump ahead to done
5662:                [ equal_label( trueLabel, labelNull )
5672:                   | true :  trueLabel = oLabelNew
5678:                   | * :
5683:                ]
5683:                .tJump  oEmitLabel( trueLabel )
5691:             | * : #eNotBoolean
5700:          ]
5700:          oTypeSPop
      
               % false in previous term will jump here, to try this alternative term
5701:          .tLabel  oEmitLabel( falseLabel )
      
               % we'll get a new falseLabel for this term
5709:          falseLabel = labelNull
5715:          @BoolTermAllowFlow( falseLabel )
      
5722:          [ oTypeSNodeType
5724:             | nBooleanFlowType :
5725:             | nBooleanType :
5727:                @ValToFlow( falseLabel )
5734:             | * : #eNotBoolean
5743:          ]
      
5743:          oTypeSPop
5744:          oTypeSPush( BooleanFlowType )
      
5750:       | * :
5755:          >
5757:    ]}
      
         % any short-circuit trues jump here to the end
5759:    [ equal_label( trueLabel, labelNull )
5769:       | false :
5770:          .tLabel  oEmitLabel( trueLabel )
5778:       | * :
5783:    ]
5784:    ;
      
      
5784: BoolTermAllowFlow( out Label falseLabel ):
5786:    Label overallFalseLabel = labelNull
      
5792:    @BoolFactorAllowFlow( falseLabel )
5799:    {[
5799:       | pAnd :
5801:          [ oTypeSNodeType
5803:             | nBooleanFlowType :
5804:             | nBooleanType :
5806:                @ValToFlow( falseLabel )
5813:             | * :
5820:                #eNotBoolean
5822:          ]
5822:          oTypeSPop
      
               % We're going to have a different falseLabel for each term,
               % because we let each rule allocate its own (rather than accepting labels passed in).
               % And in this case we want them all to go to the same place,
               % to be determined by the caller.
               %
               % I'll allow for label aliases.  This will be more optimal than generating
               % multiple private false-handling code segments, that the true path would have to
               % jump around.  That would be hard to eliminate afterwards.
      
5823:          [ equal_label( overallFalseLabel, labelNull )
5833:             | true :
5834:                overallFalseLabel = oLabelNew
5839:                .tLabelAlias  oEmitLabel( falseLabel )  oEmitLabel( overallFalseLabel )
5853:                falseLabel = overallFalseLabel
5859:             | * :
5864:          ]
      
5864:          Label factorFalseLabel = labelNull
5870:          @BoolFactorAllowFlow( factorFalseLabel )
      
5877:          [ oTypeSNodeType
5879:             | nBooleanFlowType :
5880:             | nBooleanType :
5882:                @ValToFlow( factorFalseLabel )
5889:             | * : #eNotBoolean
5898:          ]
5898:         .tLabelAlias  oEmitLabel( factorFalseLabel )  oEmitLabel( overallFalseLabel )
      
5912:       | * :
5917:          >
5919:    ]};
      
      
5922: BoolFactorAllowFlow( out Label falseLabel ):
5924:    [
5924:       | pNot :
5926:          Label factorFalseLabel = labelNull
      
5932:          @BoolFactorAllowFlow( factorFalseLabel )
5939:          [ oTypeSNodeType
5941:             | nBooleanFlowType :
                     % We have control flow, and are sitting at the point that has value false.
5942:                falseLabel = oLabelNew
5947:                .tJump  oEmitLabel( falseLabel )
                     % The true path jumps here
5955:                .tLabel  oEmitLabel( factorFalseLabel )
      
5963:             | nBooleanType :
                     % I have a value.  I'll leave it as a value, rather than create control flow.
                     % See how this goes.
5965:                .tNot
      
5967:             | * : #eNotBoolean
5976:          ]
      
5976:       | * :
5981:          @ArithExprAllowFlow( falseLabel )
5988:    ];
      
      
5989: ArithExprAllowFlow( out Label falseLabel ):
5991:    boolean first = true
5997:    int tempStrOffset
      
5997:    @TermAllowFlow( falseLabel )
6004:    {[
6004:       | '+' :
6006:          [ oTypeSNodeType
6008:             | nIntegerType, nByteType :
6009:                @PromoteToIntPop
6011:                @TermAllowFlow( falseLabel )  % actually not allowing CF, will be caught by type check
      
6018:                [ oTypeSNodeType
6020:                   | nPointerType, nUniversalPointerType :
                           % int + ptr
6021:                      .tSwap
                           % leave only the ptr type on the type stack (int was already popped above)
6023:                      @PointerAddition
6025:                   | * :
6032:                      @PromoteToInt
6034:                      .tAddI
6036:                ]
      
6036:             | nShortStringType, nStrLitType, nCharType :
                     % String concatenation
6038:                [ first
6041:                   | true :  % move into a temp string, so subsequent term(s) can further modify it.
6042:                             tempStrOffset = @MoveIntoTempShortString
6048:                             first = false
6054:                   | * :
6059:                ]
6059:                @TermAllowFlow( falseLabel )  % actually not allowing CF, will be caught by type check
6066:                [ oTypeSNodeType
6068:                   | nShortStringType, nStrLitType :
6069:                      @ShortStringAppendShortString
                           % Have to re-push the temp string.
                           % If we ever have .tDup then the append method could do it and we wouldn't need this
6071:                      .tPushAddrLocal  oEmitInt( tempStrOffset )
6079:                      oTypeSPush( ShortStringType )
6085:                   | nCharType :
6087:                      @ShortStringAppendChar
                           % Have to re-push the temp string.
                           % If we ever have .tDup then the append method could do it and we wouldn't need this
6089:                      .tPushAddrLocal  oEmitInt( tempStrOffset )
6097:                      oTypeSPush( ShortStringType )
6103:                   | * :
6112:                      #eTypeMismatch
6114:                      oTypeSPop
6115:                ]
      
6115:             | nPointerType, nUniversalPointerType :
6117:                @TermAllowFlow( falseLabel )   % actually not allowing CF
6124:                @PromoteToIntPop
6126:                @PointerAddition
      
6128:             | * :
6145:                #eNotAllowed
6147:          ]
      
6147:       | '-' :
6149:          [ oTypeSNodeType
6151:             | nIntegerType, nByteType :
6152:                @PromoteToIntPop
6154:                @TermAllowFlow( falseLabel )
6161:                @PromoteToInt
6163:                .tSubI
      
6165:             | nPointerType, nUniversalPointerType :
6167:                @TermAllowFlow( falseLabel )
6174:                [ oTypeSNodeType
6176:                   | nIntegerType, nByteType :
6177:                      @PromoteToIntPop
6179:                      @PointerSubInt
6181:                   | nPointerType, nUniversalPointerType :
6183:                      @MatchTypes
6185:                      @PointerSubPointer
6187:                   | * :
6198:                      #eNotAllowed
6200:                ]
      
6200:             | * :  #eNotAllowed
      
6213:          ]
6213:       | * :
6220:          >
6222:    ]};
      
      
6225: TermAllowFlow( out Label falseLabel ):
6227:    @FactorAllowFlow( falseLabel )
6234:    {[
6234:       | pTimes :
6236:          @PromoteToIntPop
6238:          @FactorAllowFlow( falseLabel )  % actually not allowing CF, will be caught by type check
6245:          @PromoteToInt
6247:          .tMultI
6249:       | pDivide :
6251:          @PromoteToIntPop
6253:          @FactorAllowFlow( falseLabel )
6260:          @PromoteToInt
6262:          .tDivI
6264:       | * :
6271:          >
6273:    ]};
      
      
6276: FactorAllowFlow( out Label falseLabel ):
6278:    [
6278:       | pPlus :
6280:          @PrimaryAllowFlow( falseLabel )  % actually not allowing CF, will be caught by type check
               % TO DO: unary +/- is supposed to leave expression type as-is.
6287:          @PromoteToInt
6289:       | pMinus :
6291:          @PrimaryAllowFlow( falseLabel )
               % TO DO: unary +/- is supposed to leave expression type as-is.
6298:          @PromoteToInt
6300:          .tNegI
6302:       | * :
6309:          @PrimaryAllowFlow( falseLabel )
6316:    ];
      
      
6317: PrimaryAllowFlow( out Label falseLabel ):
6319:    [
6319:       | pIntLit :
6321:          .tPushConstI  oEmitInt( TOKEN_VALUE )
6328:          oTypeSPush( IntegerType )
      
6334:       | pCharLit :
6336:          .tPushConstI  oEmitInt( TOKEN_VALUE )
6343:          oTypeSPush( CharType )
      
6349:       | pDoubleLit :
6351:          .tPushConstD  oEmitDouble( TOKEN_VALUE_DOUBLE )
6358:          oTypeSPush( DoubleType )
      
6364:       | '(' :
6366:          @ExprAllowFlow( falseLabel )
6373:          ')'
      
6375:       | pStrLit :
6377:          int addr = oStringAllocShortStringLit( CURRENT_STRLIT )     % store in global data
6386:          .tPushAddrGlobal oEmitInt( addr )
               % TO DO: consider defining a ShortString type with the exact capacity used.
               % But, I don't think it should matter here, since nobody should be assigning to this string.
6394:          oTypeSPush( StrLitType )
               % This seems unlikely, but the strlit may be followed by
               % array indexing.  Handle this the same way we would with a variable expression (see VarExpr)
               % First, advance the pointer by index if any
6400:          @LValueIndexes
               % get final value of dereferencing, if any
6402:          @FetchVar
      
6404:       | pIdent :
6406:          Node decl = oScopeFindRequire
6411:          @ResolveUnitRef( decl )
6418:          Node theType
      
6418:          [ oNodeType( decl )
6425:             | nFunc :
6426:                @Call( decl )
      
6433:             | nBuiltInFunc :
6435:                @CallBuiltInFunc( decl )
      
6442:             | nConst, nEnumValue :
6444:                theType = oNodeGet( decl, qType )
6457:                oTypeSPush( theType )
6463:                [ oTypeSNodeType
6465:                   | nIntegerType, nEnumType, nBooleanType, nCharType, nByteType :
6466:                      .tPushConstI @EmitValue( decl )
6475:                   | nPointerType, nUniversalPointerType :
                           % We have one pointer const, Nil.  It's pushed as I.
                           % Sign-extending I to P won't hurt since it's 0.
6477:                      .tPushConstI @EmitValue( decl )
6486:                   | * :
6503:                      #eNotImplemented
6505:                ]
      
6505:             | nConstStr :
                     % This is a non-typed const defined as a strlit.
                     % So far, the value is held in the compiler's symbol table.
                     % Referencing the constant in the code will work the same as directly giving a strlit.
                     % (See pStrLit above).  We store the strlit in global memory, and set expr type to StrLitType.
      
                     % Storage in global memory only happens the first time the const is referenced.
                     % The global offset is stored in qValue.
6507:                int addr = oNodeGetInt( decl, qValue )
6520:                [ equal_zero( addr )
6527:                   | true :
6528:                      addr = oStringAllocShortStringLit( oNodeGetString( decl, qValueStr ) )
6545:                      oNodeSetInt( decl, qValue, addr )
6557:                   | * :
6562:                ]
6562:                .tPushAddrGlobal oEmitInt( addr )
6570:                oTypeSPush( StrLitType )
                     % This seems unlikely, but the strlit may be followed by
                     % array indexing.  Handle this the same way we would with a variable expression (see VarExpr)
                     % First, advance the pointer by index if any
6576:                @LValueIndexes
                     % get final value of dereferencing, if any
6578:                @FetchVar
      
6580:             | nGlobalVar, nLocalVar, nParam, nTypedConst :
6582:                @VarExpr( decl )
      
6589:             | nTypeDecl :
                     % A type name.
                     % This is normally a type cast.
                     % Or, if Expr is running within sizeof(), we do also allow type names as primaries.
6591:                oTypeSPush( oNodeGet( decl, qType ) )
6604:                [
6604:                   | '(' : 
                           % Type cast
6606:                      @Expr
6608:                      ')'
6610:                      @CastType
      
                           % The expression can be further modified after the typecast.
                           % This is taken from VarExpr.  Try to consolidate.
      
6612:                      [ oTypeSNodeType
6614:                         | nPointerType, nUniversalPointerType :
6615:                            [
6615:                               | '^' :             % dereferenced
6617:                                  oTypeSPop
6618:                                  oTypeSPush( oNodeGet( theType, qBaseType ) )
6631:                                  @LValueIndexes
6633:                                  @FetchVar
6635:                               | '[' :             % dereferencing pointer like an array [0..] of baseType
6637:                                  @PointerArraySubscript
                                       % modify addr for any subsequent subscripts, field references, etc
6639:                                  @LValueIndexes
6641:                                  @FetchVar
6643:                               | * :               % just ptr value alone
6650:                            ]
      
6650:                         | nArrayType, nRecordType, nShortStringType :
                                 % So far we would have the addr of the compound value.
                                 % Modify addr for subscripts, field references, etc
6652:                            @LValueIndexes
                                 % get final value, if no longer compound
6654:                            @FetchVar
      
6656:                         | *:
6669:                      ]
      
6669:                   | * :
                           % Not a type cast
                           % A raw typename is only allowed in expressions within sizeof
6674:                      [ flagExprAllowTypeName
6677:                         | true :
                                 % The value we produce is bogus.  The caller will discard all code.
                                 % Only the type stack matters.
6678:                            .tPushConstI  oEmitInt( 0 )
6686:                         | * :    #eTypeNameNotAllowedHere
6693:                      ]
6693:                ]
      
6693:             | * :
6716:                #eNotValue
6718:                oTypeSPush( IntegerType )
6724:          ]
      
6724:       | '@' :        % @var -- pointer to var
6726:          pIdent
      
6728:          Node decl = oScopeFindRequire
6733:          @ResolveUnitRef( decl )
6740:          Node theType
      
               % writeable is false because we're not on the left hand side of an assignment,
               % or passing into a var parameter.  So it's ok to take the address of a typed const.
6740:          @LValueFromDecl( decl, false )
      
               % The above leaves the pointed-to type on type stack.
               % Replace with ptr-to-<type>.
6750:          theType = oTypeSTop
6755:          oTypeSPop
6756:          Node ptrType = @PointerTypeTo( theType )
6767:          oTypeSPush( ptrType )
      
6773:       | * :
6790:          #eNotValue
6792:          oTypeSPush( IntegerType )
6798:    ];
      
      
      % Parse a variable expression, given the declaration of the
      % just-accepted identifier.
      % Leaves the value on the expression stack, and type on the type stack.
      %
6799: VarExpr( Node decl ):
6801:    Node theType = oNodeGet( decl, qType )
         % how many levels up the static scope? Will ignore for globals.
6814:    int uplevels = @DeclUpLevels( decl )
      
6825:    oTypeSPush( theType )
6831:    [ oTypeSNodeType
6833:       | nIntegerType, nEnumType :
6834:          [ oNodeType( decl )
6841:             | nGlobalVar, nTypedConst :   .tPushGlobalI  @EmitValue( decl )
6851:             | nLocalVar :
6853:                [ equal_zero( uplevels )
6860:                   | true :  .tPushLocalI  @EmitValue( decl )
6870:                   | * :     .tPushUpLocalI  oEmitInt( uplevels )  @EmitValue( decl )
6890:                ]
6890:             | nParam :
6892:                [ oNodeGetBoolean( decl, qInOut )
6902:                   | true :    % VAR param points to the var.  Auto dereference.
6903:                      [ equal_zero( uplevels )
6910:                         | true :  .tPushParamP  @EmitValue( decl )
6920:                         | * :     .tPushUpParamP  oEmitInt( uplevels )  @EmitValue( decl )
6940:                      ]
6940:                      .tFetchI
6942:                   | * :
6947:                      [ equal_zero( uplevels )
6954:                         | true :  .tPushParamI  @EmitValue( decl )
6964:                         | * :     .tPushUpParamI  oEmitInt( uplevels )  @EmitValue( decl )
6984:                      ]
6984:                ]
6984:          ]
      
6996:       | nBooleanType, nByteType, nCharType :
6998:          [ oNodeType( decl )
7005:             | nGlobalVar, nTypedConst :   .tPushGlobalB  @EmitValue( decl )
7015:             | nLocalVar :
7017:                [ equal_zero( uplevels )
7024:                   | true :  .tPushLocalB  @EmitValue( decl )
7034:                   | * :     .tPushUpLocalB  oEmitInt( uplevels )  @EmitValue( decl )
7054:                ]
7054:             | nParam :
7056:                [ oNodeGetBoolean( decl, qInOut )
7066:                   | true :    % VAR param points to the var.  Auto dereference.
7067:                      [ equal_zero( uplevels )
7074:                         | true :  .tPushParamP  @EmitValue( decl )
7084:                         | * :     .tPushUpParamP  oEmitInt( uplevels )  @EmitValue( decl )
7104:                      ]
7104:                      .tFetchB
7106:                   | * :
7111:                      [ equal_zero( uplevels )
7118:                         | true :  .tPushParamB  @EmitValue( decl )
7128:                         | * :     .tPushUpParamB  oEmitInt( uplevels )  @EmitValue( decl )
7148:                      ]
7148:                ]
7148:          ]
      
7160:       | nFileType :
7162:          #eNotImplemented
      
7164:       | nPointerType, nUniversalPointerType, nDoubleType :
               % Note we're using this code for reading double vars too, because P is the correct size
7166:          [ oNodeType( decl )
7173:             | nGlobalVar, nTypedConst :   .tPushGlobalP @EmitValue( decl )
7183:             | nLocalVar :
7185:                [ equal_zero( uplevels )
7192:                   | true :  .tPushLocalP  @EmitValue( decl )
7202:                   | * :     .tPushUpLocalP  oEmitInt( uplevels )  @EmitValue( decl )
7222:                ]
7222:             | nParam :
7224:                [ oNodeGetBoolean( decl, qInOut )
7234:                   | true :    % VAR param points to the var.  Auto dereference.
7235:                      [ equal_zero( uplevels )
7242:                         | true :  .tPushParamP  @EmitValue( decl )
7252:                         | * :     .tPushUpParamP  oEmitInt( uplevels )  @EmitValue( decl )
7272:                      ]
7272:                      .tFetchP
7274:                   | * :
7279:                      [ equal_zero( uplevels )
7286:                         | true :  .tPushParamP  @EmitValue( decl )
7296:                         | * :     .tPushUpParamP  oEmitInt( uplevels )  @EmitValue( decl )
7316:                      ]
7316:                ]               
7316:          ]
7328:          [
7328:             | '^' :             % dereferenced
7330:                oTypeSPop
7331:                oTypeSPush( oNodeGet( theType, qBaseType ) )
7344:                @LValueIndexes
7346:                @FetchVar
7348:             | '[' :             % dereferencing pointer like an array [0..] of baseType
7350:                @PointerArraySubscript
                     % modify addr for any subsequent subscripts, field references, etc
7352:                @LValueIndexes
7354:                @FetchVar
7356:             | * :               % just ptr value alone
7363:          ]
      
7363:       | nArrayType, nRecordType, nShortStringType :
               % compound type
               % first, push addr of start of var
7365:          [ oNodeType( decl )
7372:             | nGlobalVar, nTypedConst :   .tPushAddrGlobal @EmitValue( decl )
7382:             | nLocalVar :
7384:                [ equal_zero( uplevels )
7391:                   | true :  .tPushAddrLocal  @EmitValue( decl )
7401:                   | * :     .tPushAddrUpLocal  oEmitInt( uplevels )  @EmitValue( decl )
7421:                ]
7421:             | nParam :
7423:                [ oNodeGetBoolean( decl, qInOut )
7433:                   | true :    % VAR param points to the var.  Auto dereference.
7434:                      [ equal_zero( uplevels )
7441:                         | true :  .tPushParamP  @EmitValue( decl )
7451:                         | * :     .tPushUpParamP  oEmitInt( uplevels )  @EmitValue( decl )
7471:                      ]
7471:                   | * :
7476:                      [ equal_zero( uplevels )
7483:                         | true :  .tPushAddrParam  @EmitValue( decl )
7493:                         | * :     .tPushAddrUpParam  oEmitInt( uplevels )  @EmitValue( decl )
7513:                      ]
7513:                ]
7513:          ]
               % modify addr for subscripts, field references, etc
7525:          @LValueIndexes
               % get final value
7527:          @FetchVar
7529:    ];
      
      
      % Addr of start of var is on expr stack; type is on type stack.
      % Replace expr stack with value of var.
      % (In the case of compound vars, this remains as the addr of the var).
      
7558: FetchVar:
7560:    [ oTypeSNodeType
7562:       | nIntegerType, nEnumType :  .tFetchI
7565:       | nBooleanType, nByteType, nCharType :  .tFetchB
7569:       | nFileType :   #eNotImplemented
7573:       | nPointerType :             .tFetchP
7577:       | nUniversalPointerType :    #eCantDereference
7581:       | nArrayType, nRecordType, nStrLitType, nShortStringType :  % compound type; leave as addr
7583:    ];
      
      
      % Addr of start of var is already on run stack, and type is on type stack.
      % Read subscripts, record fields, etc, to get final addr on run stack, and final type
      % on type stack.
      
7612: LValueIndexes:
7614:    {[
7614:       | '[' :
7616:          [ oTypeSNodeType
7618:             | nArrayType :    @ArraySubscripts
7621:             | nPointerType :  @PointerArraySubscript
7625:             | nStrLitType, nShortStringType :  @ShortStringArraySubscript
7629:             | * :             #eNotArray
7642:          ]
7642:       | '.' :       @RecordFieldRef
7646:       | '^' :       @PointerDeref   % TO DO: I suspect I don't have logic right here
                                          % about precondition and using .tFetchP
                                          % Ideally this should take over for the ^ in VarExpr too.
7650:       | * :         >
7661:    ]};
      
      
7664: ArraySubscripts:
7666:    [ oTypeSNodeType
7668:       | nArrayType :
7669:       | * :       #eNotArray
7676:    ]
7676:    {
7676:       [ oTypeSNodeType
7678:          | nArrayType :
7679:          | * :    #eTooManySubscripts
7686:       ]
      
            % low subscript of this dimension
7686:       int low = @OrdinalLow( oNodeGet( oTypeSTop, qIndexType ) )
      
            % replace type stack with next dimension, or OF type
7703:       Node baseType
7703:       baseType = oNodeGet( oTypeSTop, qBaseType )
7715:       oTypeSPop
7716:       oTypeSPush( baseType )
      
7722:       @Expr
7724:       @RequireIntPop
            % adjust for low subscript
7726:       [ equal_zero( low )
7733:          | false :
7734:             .tPushConstI oEmitInt( low ) .tSubI
7744:          | * :
7749:       ]
      
            % multiply by element size
7749:       int size = oNodeGetInt( baseType, qSize )
7762:       [ equal( size, 1 )
7772:          | false :
7773:             .tPushConstI oEmitInt( size ) .tMultI
7783:          | * :
7788:       ]
      
            % update start address
7788:       .tAddPI
7790:       [
7790:          | ']' :  >
7794:          | ',' :
7796:       ]
7804:    };
      
      
      % pointer[index] - similar to array[index] where index counts from 0.
      % On entry, the pointer value is on the stack, and pointer type is on the type stack.
      % We've already accepted the '['.
      % On exit, the address of the pointed-to element is on the stack,
      % and the element type is on the type stack.
      %
7807: PointerArraySubscript:
7809:    [ oTypeSNodeType
7811:       | nPointerType :
7812:       | * :    #eCantDereference
7819:    ]
         % replace type stack with base type
7819:    Node baseType = oNodeGet( oTypeSTop, qBaseType )
7831:    oTypeSPop
7832:    oTypeSPush( baseType )
         
7838:    @Expr
7840:    @RequireIntPop
         % multiply by element size
7842:    int size = oNodeGetInt( baseType, qSize )
7855:    [ equal( size, 1 )
7865:       | false :
7866:          .tPushConstI  oEmitInt( size )  .tMultI
7876:       | * :
7881:    ]
         % update start address
7881:    .tAddPI
7883:    ']';
      
      
      % Specialization of array indexing for ShortString.
      % We treat the starting index as 0 so that str[1] sees the first string char,
      % past the length byte.
      %
7886: ShortStringArraySubscript:
7888:    [ oTypeSNodeType
7890:       | nStrLitType, nShortStringType :
7891:       | * :    #eCantDereference
7900:    ]
7900:    oTypeSPop
7901:    oTypeSPush( CharType )
7907:    @Expr
7909:    @RequireIntPop
7911:    .tAddPI
7913:    ']';
      
      
7916: RecordFieldRef:
7918:    [ oTypeSNodeType
7920:       | nRecordType :
7921:       | * :    #eNotRecord
7928:    ]
7928:    oScopeEnter( oNodeGet( oTypeSTop, qScope ) )
7940:    pIdent
7942:    Node field = oScopeFindRequire
         % oScopeFind searches all open scopes, so make sure we found nRecordField
         % which could only be seen in the local scope we entered above.
7947:    [ oNodeType( field )
7954:       | nRecordField :
7955:       | * :   #eNotRecordField
7962:    ]
7962:    oScopeEnd
7963:    int offset = oNodeGetInt( field, qValue )
7976:    [ equal_zero( offset )
7983:       | false :
7984:          .tPushConstI oEmitInt( offset ) .tAddPI
7994:       | * :
7999:    ]
      
         % replace the type on the type stack, with the field type
7999:    oTypeSPop
8000:    oTypeSPush( oNodeGet( field, qType ) )
8014:    ;
      
      
      % On entry, expr stack has ptr, and integer index above it.
      % The type stack has just the pointer type.
      % Pop those, and push the ptr advanced to that index
      % (scaled by the pointed-to element size).
      % Leaves the pointer type on the type stack.
      %
8014: PointerAddition:
8016:    Node elementType = oNodeGet( oTypeSTop, qBaseType )
8028:    int elementSize = oNodeGetInt( elementType, qSize )
8041:    [ equal( elementSize, 1 )
8051:       | false :
8052:          .tPushConstI  oEmitInt( elementSize )
8060:          .tMultI
8062:       | * :
8067:    ]
8067:    .tAddPI
8070:    ;
      
      
      % On entry, expr stack has ptr, and integer above it.
      % The type stack has just the pointer type.
      % Pop those, and push the ptr decremented by that integer
      % (scaled by the pointed-to element size).
      % Leaves the pointer type on the type stack.
      %
8070: PointerSubInt:
8072:    Node elementType = oNodeGet( oTypeSTop, qBaseType )
8084:    int elementSize = oNodeGetInt( elementType, qSize )
8097:    [ equal( elementSize, 1 )
8107:       | false :
8108:          .tPushConstI  oEmitInt( elementSize )
8116:          .tMultI
8118:       | * :
8123:    ]
8123:    .tSubPI
8126:    ;
      
      
      % On entry, expr stack has two pointers, P1 and P2 above it.
      % The type stack has the type of P1.  (The type of P2 was already matched to P1.)
      % Replace the pointers on the expression stack with P1 - P2, scaled by the
      % pointed-to element size.  Type stack switched to integer.
      % 
8126: PointerSubPointer:
8128:    .tSubP
8130:    Node elementType = oNodeGet( oTypeSTop, qBaseType )
8142:    int elementSize = oNodeGetInt( elementType, qSize )
8155:    [ equal( elementSize, 1 )
8165:       | false :
8166:          .tPushConstI  oEmitInt( elementSize )
8174:          .tDivI
8176:       | * :
8181:    ]
8181:    oTypeSPop
8182:    oTypeSPush( IntegerType )
8189:    ;
      
      % ptr deref on left side, i.e. BEFORE addr of ptr var is on stack,
      %                              AFTER addr of thing pointed to is on stack
8189: PointerDeref:
8191:    [ oTypeSNodeType
8193:       | nPointerType :
8194:       | nUniversalPointerType :   #eCantDereference
8198:       | * :       #eNotPointer
8207:    ]
8207:    .tFetchP           % now addr on stack is addr of what we're pointing to
      
8209:    Node theType = oTypeSTop
8214:    oTypeSPop
8215:    oTypeSPush( oNodeGet( theType, qBaseType ) )
8229:    ;
      
      
      % The expr stack contains a value whose type is on top of the type stack.
      % Generate code to coerce the value to the type under it in the type stack
      % (pop the type stack, leaving only the desired type).
      % This is used for assignment.
      %
8229: CoerceType:
8231:    node_type nt = oTypeSNodeType
8236:    Node given = oTypeSTop
8241:    oTypeSPop
8242:    [ equal_node_type( nt, oTypeSNodeType )
8251:       | false :
               % Can we implicitly convert the value to the desired type?
8252:          [ oTypeSNodeType
8254:             | nIntegerType :
8255:                [ nt
8258:                   | nByteType :   .tCastBtoI  >>
8262:                   | * :
8267:                ]
8267:             | nByteType :
8269:                [ nt
8272:                   | nIntegerType :   .tCastItoB  >>
8276:                   | * :
8281:                ]
8281:             | nPointerType :
8283:                [ nt
8286:                   | nUniversalPointerType :  >>
8288:                   | nStrLitType :
8290:                      [ equal_node( oTypeSTop, PCharType )
8299:                         | true :
                                 % PChar := 'strlit' i.e. point at strlit[1]
8300:                            .tPushConstI  oEmitInt(1)  .tAddPI  >>
8311:                         | * :
8316:                      ]
8316:                   | * :
8323:                ]
8323:             | nUniversalPointerType :
8325:                [ nt
8328:                   | nPointerType :  >>
8330:                   | * :
8335:                ]
8335:             | nShortStringType :
8337:                [ nt
8340:                   | nStrLitType :  >>
8342:                   | nCharType :
                           % Store char as a temp ShortString.
8344:                      oTypeSPush( CharType )
8350:                      int tempOffset = @MoveIntoTempShortString
8356:                      oTypeSPop
8357:                      >>
8358:                   | * :
8365:                ]
8365:             | * :
8378:          ]
8378:          #eTypeMismatch
8380:       | * :
8385:    ];
      
      
      % The expr stack contains a value whose type is on top of the type stack.
      % Generate code to cast the value to the type under it in the type stack
      % (pop the type stack, leaving only the desired type).
      %
      % This is stronger than CoerceType, since it isn't limited to implicit conversions.
      % There are still going to be limits on what is allowed though.
      %
8386: CastType:
8388:    node_type nt = oTypeSNodeType
8393:    oTypeSPop
8394:    [ equal_node_type( nt, oTypeSNodeType )
8403:       | false :
               % Can we cast the value to the desired type?
8404:          [ oTypeSNodeType
8406:             | nIntegerType, nEnumType :
8407:                [ nt
8410:                   | nByteType, nCharType, nBooleanType :   .tCastBtoI  >>
8414:                   | nIntegerType, nEnumType :   >>
8417:                   | * :
8430:                ]
8430:             | nByteType, nCharType, nBooleanType :
8432:                [ nt
8435:                   | nByteType, nCharType, nBooleanType :   >>
8437:                   | nIntegerType, nEnumType :   .tCastItoB  >>
8442:                   | * :
8455:                ]
8455:             | nPointerType :
8457:                [ nt
8460:                   | nUniversalPointerType :  >>
8462:                   | nStrLitType :
8464:                      [ equal_node( oTypeSTop, PCharType )
8473:                         | true :
                                 % PChar := 'strlit' i.e. point at strlit[1]
8474:                            .tPushConstI  oEmitInt(1)  .tAddPI  >>
8485:                         | * :
8490:                      ]
8490:                   | * :
8497:                ]
8497:             | nUniversalPointerType :
8499:                [ nt
8502:                   | nPointerType :  >>
8504:                   | * :
8509:                ]
8509:             | nShortStringType :
8511:                [ nt
8514:                   | nStrLitType :  >>
8516:                   | nCharType :
                           % Store char as a temp ShortString.
8518:                      oTypeSPush( CharType )
8524:                      int tempOffset = @MoveIntoTempShortString
8530:                      oTypeSPop
8531:                      >>
8532:                   | * :
8539:                ]
8539:             | * :
8558:          ]
8558:          #eTypeMismatch
8560:       | * :
8565:    ];
      
      
      
      % Require that the top two types on the type stack are matching (ignoring subranges).
      % Pop one of them, leaving only one.
      %
8566: MatchTypes:
8568:    node_type nt = oTypeSNodeType
8573:    oTypeSPop
8574:    [ equal_node_type( nt, oTypeSNodeType )
8583:       | false :
               % Some implicit conversion is allowed even here
8584:          [ oTypeSNodeType
8586:             | nPointerType :
8587:                [ nt
8590:                   | nUniversalPointerType :  >>
8592:                   | * :
8597:                ]
8597:             | nUniversalPointerType :
8599:                [ nt
8602:                   | nPointerType :  >>
8604:                   | * :
8609:                ]
8609:             | * :
8616:          ]
8616:          #eTypeMismatch
8618:       | * :
8623:    ];
      
      
      % Require that the top type on the type stack is integer (ignoring subranges).
      % Pop it.
      %
8624: RequireIntPop:
8626:    [ oTypeSNodeType
8628:       | nIntegerType :
8629:       | * :          #eNotInteger
8636:    ]
8636:    oTypeSPop;
      
8638: RequireInt:
8640:    [ oTypeSNodeType
8642:       | nIntegerType :
8643:       | * :          #eNotInteger
8650:    ];
      
      
      % Convert the top value to integer (if it isn't already).
      % It must be implicitly convertable to integer.
      % Pop the type stack.
      %
8651: PromoteToIntPop:
8653:    [ oTypeSNodeType
8655:       | nIntegerType :
8656:       | nByteType :        .tCastBtoI
8660:       | * :                #eNotInteger
8669:    ]
8669:    oTypeSPop;
      
      % Convert the top value to integer (if it isn't already).
      % It must be implicitly convertable to integer.
      % Leave integer on the type stack.
      %
8671: PromoteToInt:
8673:    [ oTypeSNodeType
8675:       | nIntegerType :
8676:       | nByteType :        .tCastBtoI
8680:                            oTypeSPop
8681:                            oTypeSPush( IntegerType )
8687:       | * :                #eNotInteger
8696:    ];
      
      
      % If the top value is implicitly convertable to integer, do so.
      % Otherwise leave it as-is.
      %
8697: PromoteToIntOptional:
8699:    [ oTypeSNodeType
8701:       | nByteType :        .tCastBtoI
8704:                            oTypeSPop
8705:                            oTypeSPush( IntegerType )
8711:       | * :
8716:    ];
      
      
8717: RequireBoolPop:
8719:    [ oTypeSNodeType
8721:       | nBooleanType :
8722:       | * :          #eNotBoolean
8729:    ]
8729:    oTypeSPop;
      
8731: RequireBool:
8733:    [ oTypeSNodeType
8735:       | nBooleanType :
8736:       | * :          #eNotBoolean
8743:    ];
      
      
8744: include 'pascal_stmt.ssl'
      %
      % Pascal Compiler
      %
      
      
      % ------------------------------ Statements -----------------------------
      
8744: Statement:
8746:    [
8746:       | pWriteln :     @WritelnStmt
8750:       | pWrite :       @WriteStmt
8754:       | pReadln :      @ReadlnStmt
8758:       | pRead :        @ReadStmt
8762:       | pIf :          @IfStmt
8766:       | pWhile :       @WhileStmt
8770:       | pFor :         @ForStmt
8774:       | pRepeat :      @RepeatStmt
8778:       | pBreak :       @BreakStmt
8782:       | pContinue :    @ContinueStmt
8786:       | pBegin :       @BeginStmt
8790:       | pIdent :       @LabelOrAssignOrCallStmt
8794:       | pCase :        @CaseStmt
8798:       | pGoto :        @GotoStmt
8802:       | pIntLit :      % should be an integer label
8804:                        oChangeIntLitToLabelIdent
8805:                        @LabelOrAssignOrCallStmt
8807:       | * :            % null statement : don't accept any tokens
8840:    ];
      
      
8841: LabelOrAssignOrCallStmt:
8843:    Node decl = oScopeFindRequire
8848:    @ResolveUnitRef( decl )
8855:    [ oNodeType( decl )
8862:       | nLabel :                          @LabelDefinition( decl )
8870:                                           @Statement
8872:       | nProc :                           @Call( decl )
8881:       | nGlobalVar, nLocalVar, nParam, nTypeDecl :
8883:                                           @AssignStmt( decl )
8890:       | nFunc :                           @AssignResultStmt( decl )
8899:       | * :                               #eBadStatement
8918:    ];
      
      
      % Parse a "label:" prefix in front of a statement.
      %
8919: LabelDefinition( Node decl ):
8921:    [ oNodeGetBoolean( decl, qDefined )
8931:       | true :  #eAlreadyDefined
8934:       | * :
8939:    ]
8939:    .tLabel  oEmitLabel( oNodeGetLabel( decl, qValue ) )
8954:    oNodeSetBoolean( decl, qDefined, true )
8966:    ':'
8969:    ;
      
      
      % Given decl, the just-accepted first identifier on the left hand side.
      %
8969: AssignStmt( Node decl ):
8971:    @LValueFromDecl( decl, true )
8981:    ':=' 
8983:    @Expr
8985:    @CoerceType
8987:    @Assign
8990:    ;
      
      
      % Performs a raw assignment.
      % Given lvalue 2nd on stack, and expr value top of stack (already coerced to the lvalue type),
      % and type of both of these on the type stack,
      % perform the assignment and pop the type off the type stack.
      %
8990: Assign:
8992:    [ oTypeSNodeType
8994:       | nIntegerType, nEnumType :  .tAssignI
8997:       | nBooleanType, nByteType, nCharType :  .tAssignB
9001:       | nDoubleType :  .tAssignD
9005:       | nFileType :   #eNotImplemented
9009:       | nPointerType, nUniversalPointerType :  .tAssignP
            % compound var assigns; addrs of src, dest on stack
9013:       | nArrayType, nRecordType, nShortStringType :
                % TO DO: for ShortString, allow destination to be smaller capacity,
                % and truncate the copied value/length.
9015:           int size = oNodeGetInt( oTypeSTop, qSize )
9027:           .tCopy  oEmitInt( size )    % multi-word copy
9035:    ]
9063:    oTypeSPop
9065:    ;
      
      % Given nFunc for the just-accepted identifier on the left hand side.
      % Parse an assignment that represents assignment of the function result.
      %
9065: AssignResultStmt( Node funcDecl ):
         % Only allowed to assign the result of the immediately enclosing function, I think.
9067:    [ oNodeEqual( oNodeGet( funcDecl, qChildScope ), oScopeCurrent )
9083:       | false :   #eNotCurrentFunction
9086:       | * :
9091:    ]
      
         % Result value is stored in the caller's space, via a hidden VAR parameter.
9091:    .tPushParamP  oEmitInt( oNodeGetInt( funcDecl, qResultOffset ) )
9106:    oTypeSPush( oNodeGet( funcDecl, qType ) )
      
9119:    ':='
9121:    @Expr
9123:    @CoerceType
9125:    [ oTypeSNodeType
9127:       | nIntegerType, nEnumType : .tAssignI
9130:       | nBooleanType, nByteType, nCharType :  .tAssignB
9134:       | nDoubleType :  .tAssignD
9138:       | nFileType :   #eNotImplemented
9142:       | nPointerType, nUniversalPointerType :  .tAssignP
            % compound var assigns; addrs of src, dest on stack
9146:       | nArrayType, nRecordType, nShortStringType :
9148:           int size = oNodeGetInt( oTypeSTop, qSize )
9160:           .tCopy  oEmitInt( size )    % multi-word copy
9168:    ]
9196:    oTypeSPop
9198:    ;
      
      
      
      % Parse an lvalue expression, from scratch.
      % This is an expression that may appear on the left side of an assignment.
      % Leaves the address of the value on the expr stack,
      % and the type of the value at that address on the type stack.
      % If writeable is false, the expression won't be written to, so may access a
      % typed const.
      %
9198: LValueExpr( boolean writeable ):
         % Al lvalue expressions start with a variable name,
         % or a type name (for an lvalue typecast).
9200:    pIdent
9202:    Node decl = oScopeFindRequire
9207:    @ResolveUnitRef( decl )
9214:    @LValueFromDecl( decl, writeable )
9225:    ;
      
      
      % Parse an lvalue expression, starting with the decl of the just accepted identifier.
      % Leaves the address of the value on the expr stack,
      % and the type of the value at that address on the type stack.
      % If writeable is false, the expression won't be written to, so may access a
      % typed const.
      %
9225: LValueFromDecl( Node decl, boolean writeable ):
9227:    [ oNodeType( decl )
9234:       | nGlobalVar, nLocalVar, nParam, nTypedConst :
9235:          @LValueVar( decl, writeable )
      
9245:       | nTypeDecl :
               % lvalue typecast
               % This is only allowed if the provided lvalue we're casting from has the same size.
               % No conversion code occurs, it's just a different interpretation of the same bits.
9247:          oTypeSPush( oNodeGet( decl, qType ) )
9260:          '('
9262:          @LValueExpr( writeable )
9269:          ')'
9271:          @LValueCastType
               % There can be further modifications of the lvalue after the cast.
               % This is taken from LValueVar.  Try to consolidate.
9273:          [ oTypeSNodeType
9275:             | nPointerType :
9276:                [
9276:                   | '[' :
                           % dereference the pointer var first
9278:                      .tFetchP
9280:                      @PointerArraySubscript
9282:                   | * :
9287:                ]
9287:             | * :
9292:          ]
               % additional subscripts, if any
9292:          @LValueIndexes
       
9294:       | * :  #eNotVar
9309:    ]
9310:    ;
      
      
      % An lvalue is on the expression stack.
      % The type of the lvalue is on the type stack.
      % The desired type is under it on the type stack.
      % Perform an lvalue cast to the desired type, leaving just that type.
      %
      % An lvalue cast is allowed only if the data size is the same.
      % No conversion code occurs, it's just a different interpretation of the same bits.
      %
9310: LValueCastType:
9312:    node_type nt = oTypeSNodeType
9317:    oTypeSPop
9318:    [ equal_node_type( nt, oTypeSNodeType )
9327:       | false :
               % Can we cast the value to the desired type?
9328:          [ oTypeSNodeType
9330:             | nIntegerType, nEnumType :
9331:                [ nt
9334:                   | nByteType, nCharType, nBooleanType :  #eSizeMismatch  >>
9338:                   | nIntegerType, nEnumType :   >>
9341:                   | * :
9354:                ]
9354:             | nByteType, nCharType, nBooleanType :
9356:                [ nt
9359:                   | nByteType, nCharType, nBooleanType :   >>
9361:                   | nIntegerType, nEnumType :  #eSizeMismatch  >>
9366:                   | * :
9379:                ]
9379:             | nPointerType :
9381:                [ nt
9384:                   | nUniversalPointerType :  >>
9386:                   | * :
9391:                ]
9391:             | nUniversalPointerType :
9393:                [ nt
9396:                   | nPointerType :  >>
9398:                   | * :
9403:                ]
9403:             | nShortStringType :
9405:                [ nt
9408:                   | nStrLitType :  >>
9410:                   | * :
9415:                ]
9415:             | * :
9434:          ]
9434:          #eTypeMismatch
9436:       | * :
9441:    ];
      
      
      
      % Parse an lvalue expression (e.g. left side of an assign statement)
      % that starts with the just-accepted identifier indicated by the given decl.
      % Leaves the lvalue address on the expression stack,
      % and the type of the value at that address on the type stack.
      %
9442: LValueVar( Node decl, boolean writeable ):
9444:    [ oNodeType( decl )
9451:       | nGlobalVar :   .tPushAddrGlobal @EmitValue( decl )
9461:       | nLocalVar :    .tPushAddrLocal @EmitValue( decl )
9472:       | nParam :
9474:          [ oNodeGetBoolean( decl, qInOut )
9484:             | true :   % VAR param points to variable.  No dereference.
9485:                        .tPushParamP @EmitValue( decl )
9494:             | * :      .tPushAddrParam @EmitValue( decl )
9508:          ]
9508:       | nTypedConst :
9510:          [ writeable
9513:             | false :  .tPushAddrGlobal @EmitValue( decl )                       
9523:             | * :      #eNotVar
9530:          ]
9530:       | * :            #eNotVar
9543:    ]
      
9543:    oTypeSPush( oNodeGet( decl, qType ) )
      
         % handle subscripts, if any.
         % There is one case that I'm not fitting into the pattern nicely, so need to
         % check for specially here:  if lvalue var is a pointer variable, and is
         % followed by [index], we need to dereference the pointer variable before applying
         % the index.  This is different from handling of [index] on an rvalue expression.
         % Right now I have LValueIndexes working for both lvalue and rvalue (composite types)
         % so can't easily add this behavior in there.
         % TO DO: probably I need separate rules LValueIndexes and RValueIndexes.
         %    This might also explain my confusion about handling of deref operator in LValueIndexes vs rvalue expr,
         %    and having separate rules might clear that up better.
      
9556:    [ oTypeSNodeType
9558:       | nPointerType :
9559:          [
9559:             | '[' :
                     % dereference the pointer var first
9561:                .tFetchP
9563:                @PointerArraySubscript
9565:             | * :
9570:          ]
9570:       | * :
9575:    ]
         % additional subscripts, if any
9575:    @LValueIndexes
9578:    ;
      
      
9578: IncVar( Node decl ):
9580:    @LValueVar( decl, true )
9590:    @RequireIntPop
9592:    @VarExpr( decl )
9599:    oTypeSPop
9600:    .tIncI
9602:    .tAssignI;
      
9605: DecVar( Node decl ):
9607:    @LValueVar( decl, true )
9617:    @RequireIntPop
9619:    @VarExpr( decl )
9626:    oTypeSPop
9627:    .tDecI
9629:    .tAssignI;
      
      
9632: IfStmt:
9634:    Label falseLabel = labelNull
      
9640:    @BooleanExprControlFlow( falseLabel )
9647:    pThen
9649:    @Statement
9651:    [
9651:       | pElse :
9653:          Label doneLabel = oLabelNew
      
9658:          .tJump  oEmitLabel( doneLabel )
9666:          .tLabel oEmitLabel( falseLabel )
9674:          @Statement
9676:          .tLabel oEmitLabel( doneLabel )
      
9684:       | * :
9689:          .tLabel oEmitLabel( falseLabel )
9697:    ];
      
      
9698: ForStmt:
9700:    pIdent
      
9702:    Node decl = oScopeFindRequire
         % TO DO: disallow use of a compound variable field.
         %        Could do that by disallowing use of LValueIndexes,
         %        or by double-checking the decl's qType here.
         % TO DO: I think I read somewhere that the variable must be in current scope.
9707:    @LValueVar( decl, true )
9717:    @RequireIntPop
      
9719:    ':='
      
9721:    @Expr
9723:    @RequireIntPop
9725:    .tAssignI
      
9727:    Label breakLabel = oLabelNew
      
9732:    Label checkLabel = oLabelNew
9737:    .tJump  oEmitLabel( checkLabel )
      
9745:    Label continueLabel = oLabelNew
9750:    .tLabel  oEmitLabel( continueLabel )
9758:    [
9758:       | pTo :
9760:          @IncVar( decl )
9767:          .tLabel  oEmitLabel( checkLabel )
9775:          @VarExpr( decl )  oTypeSPop
9783:          @Expr
9785:          @RequireIntPop
9787:          .tGreaterI
9789:          .tJumpTrue  oEmitLabel( breakLabel )
9797:       | pDownto :
9799:          @DecVar( decl )
9806:          .tLabel  oEmitLabel( checkLabel )
9814:          @VarExpr( decl )  oTypeSPop
9822:          @Expr
9824:          @RequireIntPop
9826:          .tLessI
9828:          .tJumpTrue  oEmitLabel( breakLabel )
9836:    ]
9844:    oLoopPush( continueLabel, breakLabel )
9853:    pDo
9855:    @Statement
9857:    .tJump  oEmitLabel( continueLabel )
9865:    .tLabel  oEmitLabel( breakLabel )
9873:    oLoopPop;
      
      
9875: RepeatStmt:
9877:    Label continueLabel = oLabelNew
9882:    .tLabel  oEmitLabel( continueLabel )
      
9890:    Label breakLabel = oLabelNew
      
9895:    oLoopPush( continueLabel, breakLabel )
9904:    @Statement
9906:    {[
9906:       | ';' :
9908:          @Statement
9910:       | pUntil :
9912:          Label falseLabel
9912:          @BooleanExprControlFlow( falseLabel )
9919:          .tLabelAlias  oEmitLabel( falseLabel )  oEmitLabel( continueLabel )
9933:          >
9935:    ]}
9945:    .tLabel  oEmitLabel( breakLabel )
9953:    oLoopPop;
      
      
9955: WhileStmt:
9957:    Label continueLabel = oLabelNew
9962:    .tLabel  oEmitLabel( continueLabel )
      
9970:    Label breakLabel
9970:    @BooleanExprControlFlow( breakLabel )
      
9977:    oLoopPush( continueLabel, breakLabel )
9986:    pDo
9988:    @Statement
9990:    .tJump  oEmitLabel( continueLabel )
9998:    .tLabel  oEmitLabel( breakLabel )
10006:    oLoopPop;
      
      
10008: ContinueStmt:                     % NOTE, for repeat..until, skips test (??)
10010:    [ equal_label( oLoopContinueLabel, labelNull )
10019:       | true :
10020:          #eNotInALoop
10022:       | false :
10024:          .tJump  oEmitLabel( oLoopContinueLabel )
10031:    ];
      
      
10040: BreakStmt:
10042:    [ equal_label( oLoopBreakLabel, labelNull )
10051:       | true :
10052:          #eNotInALoop
10054:       | false :
10056:          .tJump  oEmitLabel( oLoopBreakLabel )
10063:    ];
      
      
10072: CaseStmt:
10074:    Code tableCode = oCodeNew
10079:    Label tableLabel = oLabelNew
10084:    Label doneLabel = oLabelNew
10089:    Label otherwiseLabel = doneLabel
10095:    boolean isString = false
      
10101:    @Expr
         % Leave the expr type on the type stack throughout case statement
10103:    [ oTypeSNodeType
10105:       | nBooleanType, nByteType, nCharType :   .tJumpCaseB  oEmitLabel( tableLabel )
10114:       | nIntegerType, nEnumType :              .tJumpCaseI  oEmitLabel( tableLabel )
10124:       | nShortStringType, nStrLitType :        isString = true
10132:                                                .tJumpCaseS  oEmitLabel( tableLabel )
10140:       | * :     #eNotAllowed
10159:    ]
10159:    pOf
      
10161:    {
10161:       [
10161:          | pOtherwise, pElse :
10163:             otherwiseLabel = oLabelNew
10168:             .tLabel  oEmitLabel( otherwiseLabel )
      
                  % A bit tricky:
                  % The otherwise clause allows multiple statements (unlike other cases).
                  % ';' might be separating statements in the otherwise clause,
                  % or might be an optional trailing ; after the last statement.
                  % I have to watch for End to know when the statements stop.
                  % (Note, the otherwise clause is the last part of the case statement.)
10176:             {[
10176:                | pEnd :  >
10180:                | * :
10185:                   @Statement
10187:                   [
10187:                      | ';' :
10189:                      | * :   pEnd  >
10198:                   ]
10198:             ]}
10200:             >
      
10202:          | pEnd :
                  % Reached end with no otherwise clause
10204:             >
      
10206:          | * :
10215:             Label caseLabel = oLabelNew
10220:             oCodePush( tableCode )
10226:             {
10226:                @ConstExpr
10228:                @ConstCoerceType
10230:                int val
10230:                [ isString
10233:                   | true :    val = oStringAllocShortStringLit( oValueTopString )
10243:                   | false :   val = oValueTop
10250:                ]
10258:                oValuePop
10259:                [
10259:                   | '..' :  @ConstExpr
10263:                             @ConstCoerceType
10265:                             int highval
10265:                             [ isString
10268:                                | true :   highval = oStringAllocShortStringLit( oValueTopString )
10278:                                | false :  highval = oValueTop
10285:                             ]
10293:                             oValuePop
10294:                             .tCaseRange  oEmitInt( val )  oEmitInt( highval )  oEmitLabel( caseLabel )
10314:                   | * :     .tCase  oEmitInt( val )  oEmitLabel( caseLabel )
10333:                ]
10333:                [
10333:                   | ',' :
10335:                   | * :  >
10342:                ]
10342:             }
10344:             oCodePop
10345:             ':'
10347:             .tLabel  oEmitLabel( caseLabel )
10355:             @Statement
10357:             .tJump  oEmitLabel( doneLabel )
                  % Swallow optional trailing ';'
10365:             [
10365:                | ';' :
10367:                | * :
10372:             ]
                  
10372:       ]
         
10372:    }
      
10374:    .tLabel  oEmitLabel( tableLabel )
10382:    oEmitCode( tableCode )
10388:    .tCaseEnd  oEmitLabel( otherwiseLabel )
10396:    .tLabel  oEmitLabel( doneLabel )
10404:    oTypeSPop
10406:    ;
      
      
10406: GotoStmt:
10408:    [
10408:       | pIdent :
10410:       | pIntLit :
               % Replace token with identifier "_label_<intlit>"
10412:          oChangeIntLitToLabelIdent
10413:    ]
      
         % Some pascals have rules about where you can jump (to a sibling statement or
         % higher level statement in the block, but not into a lower lower level statement.)
         % fpc just says "jumping into a nested statement can have strange effects."
         % I'm going to follow that and not prohibit any goto, as long as it's in the same block.
      
         % Label must be declared in the same block (same scope) it is used.
         % Some pascals allow non-local goto, but we do not.
         % That would require more tracking of dynamic scope, to unwind stack.
         % Note: in main program statement, this relies on the temporaries scope extending
         %  the main scope (where a label declaration would occur).
10421:    Node decl = oScopeFindRequireInScope( oScopeCurrent )
10430:    oNodeSetBoolean( decl, qUsed, true )
10442:    .tJump  oEmitLabel( oNodeGetLabel( decl, qValue ) )
10458:    ;
      
      
10458: BeginStmt:
10460:    @Statement
10462:    {[
10462:       | ';' :   @Statement
10466:       | pEnd :  >
10470:    ]};
      
      
10481: WritelnStmt:
10483:    @WriteStmt
10485:    .tWriteCR;
      
      
10488: WriteStmt:
10490:    [
10490:       | '(' :
10492:          {
10492:             @Expr
10494:             [ oTypeSNodeType
10496:                | nIntegerType :             .tWriteI
10499:                | nBooleanType :             .tWriteBool
10503:                | nByteType :                .tCastBtoI  .tWriteI
10509:                | nCharType :                .tWriteChar
10513:                | nDoubleType :              .tWriteD
10517:                | nShortStringType, nStrLitType :   .tWriteShortStr
10521:                | nFileType :                #eNotImplemented
10525:                | nEnumType :
                        % write name via table lookup
10527:                   .tPushAddrGlobal  oEmitInt( oNodeGetInt( oTypeSTop, qNameTable ) )
10541:                   .tWriteEnum
10543:                | nPointerType :
10545:                   [ equal_node( oTypeSTop, PCharType )
10554:                      | true :               .tWritePChar
10557:                      | * :                  .tWriteP
10564:                   ]
10564:                | nUniversalPointerType :    .tWriteP
10568:                | * :                        #eNotAllowed
10595:             ]
10595:             oTypeSPop
10596:             [
10596:                | ')' : >
10600:                | ',' :
10602:             ]
10610:          }
10612:       | * :
10617:    ];
      
      
10618: ReadlnStmt:
10620:    @ReadStmt
10622:    .tReadCR;
      
      
10625: ReadStmt:
10627:    [
10627:       | '(' :
10629:          {
10629:             @LValueExpr( true )
10636:             [ oTypeSNodeType
10638:                | nIntegerType :      .tReadI
10641:                | nCharType :         .tReadChar
10645:                | nShortStringType :  
10647:                    int capacity = subtract( oNodeGetInt( oTypeSTop, qSize ), 1 )
10666:                    .tReadShortStr  oEmitInt( capacity )
10674:                | * :                 #eNotAllowed
10685:             ]
10685:             oTypeSPop
10686:             [
10686:                | ')' : >
10690:                | ',' :
10692:             ]
10700:          }
10702:       | * :
10707:    ];
10708: include 'pascal_str.ssl'
      %
      % Pascal Compiler
      %
      
      % ------------------------------ String Operations -----------------------------
      
      
      % Given a ShortString, StrLit, or Char on the expression stack
      % (and type on the type stack).  Move the value into a new temporary ShortString.
      % Leave that temp string and type on the stacks.
      % Also returns the offset of the temp string.
      %
10708: MoveIntoTempShortString >> int:
10710:    int tempOffset = oScopeAllocType( ShortStringType )
         % copy the value
10720:    [ oTypeSNodeType
10722:       | nShortStringType, nStrLitType :
10723:          .tPushAddrLocal  oEmitInt( tempOffset )
               % put temp addr under value addr
10731:          .tSwap
               % TO DO: we could just copy length + 1, but tCopy takes a fixed #bytes
10733:          .tCopy  oEmitInt( oNodeGetInt( ShortStringType, qSize ) )
10748:       | nCharType :
               % temp[0] = 1
10750:          .tPushAddrLocal  oEmitInt( tempOffset )
10758:          .tPushConstI  oEmitInt( 1 )
10766:          .tAssignB
               % temp[1] = value
10768:          .tPushAddrLocal  oEmitInt( add( tempOffset, 1 ) )
10783:          .tSwap
10785:          .tAssignB
10787:       | * :   #eTypeMismatch
10798:    ]
10798:    oTypeSPop
         % Leave the temp ShortString on the expr stack and type stack
10799:    .tPushAddrLocal  oEmitInt( tempOffset )
10807:    oTypeSPush( ShortStringType )
10813:    >> tempOffset;
      
      
      % Top of expr stack / type stack is ShortString B.
      % Under it is ShortString A.
      % Change A to append the contents of B to it (truncating if necessary).
      % Removes both A and B from the expr stack / type stack.
      %
10817: ShortStringAppendShortString:
         % TO DO: ideally I would do this directly with tcode.  But I think I need some more
         % enhancements for that to work well.   Meanwhile, generate a call to a method.
         % For the moment, I'll implement the method in Pascal, in the mysystem unit.
10819:    .tAllocActuals  oEmitInt( 16 )
10827:    .tPushAddrActual  oEmitInt( 8 )  .tSwap  .tAssignP
10839:    .tPushAddrActual  oEmitInt( 0 )  .tSwap  .tAssignP
10851:    .tCall   @EmitValue( System_ShortStringAppendShortString )
         % TO DO: Ideally I would leave A on the expr stack / type stack.
         %  But I can't really do that without dup, which I hesitate to add.
         %  I'll have the caller push A again themselves.
10860:    .tFreeActuals  oEmitInt( 16 )
10868:    oTypeSPop
10869:    oTypeSPop
10871:    ;
      
      % Top of expr stack / type stack is Char B.
      % Under it is ShortString A.
      % Change A to append char B to it (truncating if necessary).
      % Removes both A and B from the expr stack / type stack.
      %
10871: ShortStringAppendChar:
         % Note at the moment I don't align params
10873:    .tAllocActuals  oEmitInt( 12 )
10881:    .tPushAddrActual  oEmitInt( 8 )  .tSwap  .tAssignB
10893:    .tPushAddrActual  oEmitInt( 0 )  .tSwap  .tAssignP
10905:    .tCall  @EmitValue( System_ShortStringAppendChar )
10914:    .tFreeActuals  oEmitInt( 12 )
10922:    oTypeSPop
10923:    oTypeSPop
10925:    ;
      
      % Expr stack has ShortString A, and ShortString B above it.
      % Type stack has just the type of ShortString A.
      % Replaces the expr stack with the integer value of string comparison:
      % -1 if A < B,  0 if A = B,  1 if A > B
      % Leaves Integer on the type stack.
      %
      % TO DO: kind of annoying that we need to hardcode the fact that the called method is cdecl extern.
      %   It would be nicer if that was noted only in the label.
      %   Alternatively, use a utility method in SSL to generate the appropriate call,
      %   given the method decl.
      %
10925: ShortStringCmp:
10927:    .tAllocActualsCdecl  oEmitInt( 24 )
10935:    .tPushAddrActual  oEmitInt( 8 )  .tSwap  .tAssignP
10947:    .tPushAddrActual  oEmitInt( 0 )  .tSwap  .tAssignP
10959:    int tempOffset = oScopeAllocType( IntegerType )
10969:    .tPushAddrActual  oEmitInt( 16 )  .tPushAddrLocal  oEmitInt( tempOffset )  .tAssignP
10987:    .tCallCdecl  @EmitValue( System_ShortStringCmp )
10996:    .tPushLocalI  oEmitInt( tempOffset )
11004:    .tFreeActuals  oEmitInt( 24 )
11012:    oTypeSPop
11013:    oTypeSPush( IntegerType )
11020:    ;
11020: include 'pascal_call.ssl'
      %
      % Pascal Compiler
      %
      
      % ------------------------------ Method Calls -----------------------------
      
      
      % Parse a call, given an nProc or nFunc for the just-accepted identifier.
      % If a func, this will also generate the code to push the return value on the expr stack,
      % and push the return type on the type stack.
      %
11020: Call( Node method ):
11022:    oNodeSetBoolean( method, qUsed, true )
      
         % If the method has a cdecl modifier, the back end will need to use the native
         % calling convention, instead of my own.  But, the convention varies by platform,
         % so the front end won't assume what it needs.  I'll still generate the normal tcode
         % that copies values into actuals space on the stack.
         % However, to help the back end, I will at least use a different instruction for the
         % allocation of the actuals space, and for the actual call.
         %
         % p.s. I only support cdecl on external methods, because I don't have a way
         % to let my own Pascal methods read params passed in with the cdecl calling convention.
         %
11034:    boolean cdecl = oNodeGetBoolean( method, qCdecl )
      
         % If this is a function, we will allocate a temporary
         % in the current scope, to hold the result value.
         % And pass a pointer to that temporary as an extra parameter.
11047:    Node resultType
11047:    int tempOffset
      
11047:    boolean isFunc = equal_node_type( oNodeType( method ), nFunc )
      
11064:    [ isFunc
11067:       | true :
11068:          resultType = oNodeGet( method, qType )
11081:          tempOffset = oScopeAllocType( resultType )
               % TO DO: we could manage temp allocation, so temp space can be reused
               %        by different code branches.
11091:       | * :
11096:    ]
         
      
11096:    Node paramScope = oNodeGet( method, qParams )
11109:    int actualsSize = oNodeGetInt( paramScope, qSize )
11122:    [ cdecl
11125:       | true : .tAllocActualsCdecl  oEmitInt( actualsSize )
11134:       | false :  .tAllocActuals  oEmitInt( actualsSize )
11144:    ]
      
         % If method is nested, it takes a hidden first parameter:
         % a pointer to the frame of the static scope in which the method is declared.
         % The location of a scope's frame is equivalent to offset 0 in the scope's locals space
         % (since local offsets are relative to the scope's frame pointer).
         %
         % The nested method may be in a higher scope (upLevels > 1),
         % or a sibling of the method we're in (upLevels = 1),
         % or an immediate child of the current method (upLevels = 0).
         %
         % To understand the upLevels computation, remember that a method's declaration
         % and its contents (variables, nested functions, and body statement)
         % are in two different scopes.
      
11152:    [ greater( @DeclLevel( method ), 0 )
11167:       | true :
11168:          .tPushAddrActual  oEmitInt( 0 )    % hidden param is at param offset 0
11176:          .tPushAddrUpLocal  oEmitInt( @DeclUpLevels( method ) )  oEmitInt( 0 )
11195:          .tAssignP
11197:       | * :
11202:    ]
      
      
11202:    NodeIter paramIter = oNodeGetIter( paramScope, qDecls )
11215:    Node param = oNodeIterValue( paramIter )
11225:    [
11225:       | '(' :
            
11227:          {
11227:             [ oNodeNull( param )
11234:                | true : >
11237:                | * :
11242:             ]
      
11242:             int offset = oNodeGetInt( param, qValue )
      
                  % Assign actual value to spot in actuals space
11255:             .tPushAddrActual oEmitInt( offset )
11263:             oTypeSPush( oNodeGet( param, qType ) )
      
11276:             [ oNodeGetBoolean( param, qInOut )
11286:                | true :   % A VAR param.
                                % The actual is a pointer to the value.
                                % The type on the type stack (pushed above) is for the pointed-to value.
      
11287:                           @LValueExpr( true )
                                % Addr of the referenced variable is on the expr stack,
                                % type of the variable is on the type stack.
      
                                % Match types more exactly. It's not sufficient to be assign compatible
                                % since the method will be assigning to the actual using the param type.
                                % Maybe something like type contents must match, incl subrange bounds.
11294:                           @MatchTypes
      
11296:                           .tAssignP
      
11298:                | false :  @Expr
11302:                           @CoerceType
                                
                                % Assign to offset in actuals space
      
11304:                           [ oTypeSNodeType
11306:                              | nIntegerType, nEnumType : .tAssignI
11309:                              | nBooleanType, nByteType, nCharType :  .tAssignB
11313:                              | nDoubleType :  .tAssignD
11317:                              | nFileType :   #eNotImplemented
11321:                              | nPointerType, nUniversalPointerType :  .tAssignP
11325:                              | nArrayType, nRecordType, nShortStringType :
                                       % compound types: copy value into actuals space
11327:                                  int size = oNodeGetInt( oTypeSTop, qSize )
11339:                                  .tCopy  oEmitInt( size )    % multi-word copy
11347:                           ]
11375:             ]
11383:             oTypeSPop
      
11384:             oNodeIterNext( paramIter )
11390:             param = oNodeIterValue( paramIter )
11400:             [ oNodeNull( param )
11407:                | true :  >
11410:                | false :
11412:             ]
      
11420:             ','
11422:          }
      
11424:          ')'
      
11426:       | * :
11431:    ]
      
11431:    [ oNodeNull( param )
11438:       | false :    #eMissingParameter
11441:       | * :
11446:    ]
      
11446:    [ isFunc
11449:       | true :
               % Pass result temp as an additional VAR parameter.
11450:          .tPushAddrActual oEmitInt( oNodeGetInt( method, qResultOffset ) )
11465:          .tPushAddrLocal  oEmitInt( tempOffset )
11473:          .tAssignP
11475:       | * :
11480:    ]
      
11480:    [ cdecl
11483:       | true :
11484:          .tCallCdecl  @EmitValue( method )
11493:       | false :
11495:          .tCall   @EmitValue( method )
11504:    ]
      
11512:    [ isFunc
11515:       | true :
               % push return value from temp
11516:          oTypeSPush( resultType )
      
11522:          [ oTypeSNodeType
11524:             | nIntegerType, nEnumType :   .tPushLocalI  oEmitInt( tempOffset )
11533:             | nBooleanType, nByteType, nCharType :   .tPushLocalB  oEmitInt( tempOffset )
11543:             | nFileType :  #eNotImplemented
11547:             | nPointerType, nUniversalPointerType :   .tPushLocalP  oEmitInt( tempOffset )
11557:             | nArrayType, nRecordType, nShortStringType :   % compound type: push address
11559:                                .tPushAddrLocal  oEmitInt( tempOffset )
11567:          ]
11593:       | * :
11598:    ]
         
11598:    .tFreeActuals  oEmitInt( actualsSize )
11607:    ;
      
      
      
      % Called on first use of an extern method
      %
11607: DefineExternLabel( Node method ):
         % The extern name might be given explicitly, otherwise the pascal method name.
11609:    int strAddr
11609:    String externalName = oNodeGetString( method, qExternalName )
11622:    [ equal_string( externalName, stringNull )
11632:       | true :
11633:          strAddr = oStringAllocLit( ID_STRING( oNodeGetInt( method, qIdent ) ) )
11654:       | false :
11656:          strAddr = oStringAllocLit( externalName )
11666:    ]
11674:    .tLabelExtern  @EmitValue( method )  oEmitInt( strAddr )
11690:    ;
      
      
      
      % Parse a call to a built-in function, identified by the just-accepted identifier.
      % This will also generate the code to push the return value on the expr stack,
      % and push the return type on the type stack.
      %
11690: CallBuiltInFunc( Node method ):
      
         % Ord(x)
11692:    [ oNodeEqual( method, BuiltIn_Ord )
11702:       | true :
               % parameter is any scalar type (including boolean, enum, char)
               % result is integer
11703:          '('
11705:          @Expr
11707:          [ oTypeSNodeType
11709:             | nIntegerType, nEnumType :
11710:             | nBooleanType, nByteType, nCharType :  .tCastBtoI
11714:             | * :  #eTypeMismatch
11729:          ]
11729:          oTypeSPop
11730:          oTypeSPush( IntegerType )
11736:          ')'
11738:          >>
11739:       | * :
11744:    ]
      
         % Chr(x)
11744:    [ oNodeEqual( method, BuiltIn_Chr )
11754:       | true :
               % parameter is integer
               % result is char
11755:          '('
11757:          @Expr
11759:          [ oTypeSNodeType
11761:             | nIntegerType :    .tCastItoB
11764:             | nByteType :
11766:             | * :  #eTypeMismatch
11775:          ]
11775:          oTypeSPop
11776:          oTypeSPush( CharType )
11782:          ')'
11784:          >>
11785:       | * :
11790:    ]
      
         % Pred(x)
11790:    [ oNodeEqual( method, BuiltIn_Pred )
11800:       | true :
               % parameter is any enum type, as long as it has values 0..N-1
               % result is the same enum type
11801:          '('
11803:          @Expr
11805:          [ oTypeSNodeType
11807:             | nEnumType :
                     % TO DO: does this skip past type aliases?
                     % TO DO: what if using pred/succ on a subrange type?
11808:                [ oNodeGetBoolean( oTypeSTop, qHasGap )
11817:                   | true :   #eCantUsePredSuccOnEnumWithValueGaps
11820:                   | * :
11825:                ]
11825:             | * :  #eTypeMismatch
11832:          ]
11832:          .tDecI
11834:          ')'
11836:          >>
11837:       | * :
11842:    ]
      
         % Succ(x)
11842:    [ oNodeEqual( method, BuiltIn_Succ )
11852:       | true :
               % parameter is any enum type, as long as it has values 0..N-1
               % result is the same enum type
11853:          '('
11855:          @Expr
11857:          [ oTypeSNodeType
11859:             | nEnumType :
                     % TO DO: does this skip past type aliases?
                     % TO DO: what if using pred/succ on a subrange type?
11860:                [ oNodeGetBoolean( oTypeSTop, qHasGap )
11869:                   | true :   #eCantUsePredSuccOnEnumWithValueGaps
11872:                   | * :
11877:                ]
11877:             | * :  #eTypeMismatch
11884:          ]
11884:          .tIncI
11886:          ')'
11888:          >>
11889:       | * :
11894:    ]
      
         % Sizeof(x)
11894:    [ oNodeEqual( method, BuiltIn_Sizeof )
11904:       | true :
               % parameter is a type name (cannot be a general type description),
               % or an expression (which is not evaluated).
               %
               % My initial thought was to look at the first token to see if it's a type name,
               % and if not, unaccept it and run @Expr  (with the code stream set to a dummy stream).
               % But that's not completely sufficient.
               % First, the typename might be   unit.name  so unaccepting one token wouldn't be good enough.
               % Also, an expression can start with a typename e.g.  integer(1+2) * 3
               %
               % So, instead of looking for a type name at this level, and going to Expr if not,
               % I'll just go into Expr.  But I'll turn on an option to accept type names in Primary.
               % Since we're discarding the code anyway, I'll have that primary push a bogus value
               % on the expr stack.  The main thing is just to get the type right.
               
11905:          '('
               % Parse expression but don't evaluate its code (so no side effects occur).
               % I'll accomplish that by sending the code to a temp stream that I discard.
11907:          Code dummyCode = oCodeNew
11912:          oCodePush( dummyCode )
11918:          @ExprAllowTypeName
11920:          oCodePop
11921:          oCodeDiscard( dummyCode )
11927:          Node theType = oTypeSTop
11932:          oTypeSPop
11933:          .tPushConstI  oEmitInt( oNodeGetInt( theType, qSize ) )
11948:          oTypeSPush( IntegerType )
11954:          ')'
11956:          >>
      
11957:       | * :
11962:    ]
      
11962:    #eNotImplemented
11965:    ;
      
11965: include 'pascal_type.ssl'
      %
      % Pascal Compiler
      %
      
      % ------------------------------ Types -----------------------------
      
      
      % Create and return a new nType of the given node_type, adding it to the type table.
      %
11965: newType( node_type nt, int size ) >> Node:
11967:   Node node = oNodeNew( nt )
11977:   oNodeSetInt( node, qSize, size )
11989:   oTypeAdd( node )
11995:   >> node
11999:   ;
      
      
      % Parse a type reference, returning the nType.
      % This will add types to the type table, as needed.
      %
      % Style question - at the moment I think callers look clearer if we use
      % an out param here, rather than a return value.
      %
11999: TypeRef( out Node resultType ):
12001:    [
12001:       | pIdent :           % previously named type (including intrinsics)
12003:          Node decl = oScopeFindRequire
12008:          @ResolveUnitRef( decl )
12015:          [ oNodeType( decl )
12022:             | nTypeDecl :
12023:                resultType = oNodeGet( decl, qType )
12036:             | * :
12041:                #eNotType
12043:                resultType = IntegerType
12049:          ]
         
12049:       | pArray :
12051:          '['
      
               % A multi-dimensional array is represented as a chain
               %    array [subrange1] of array [subrange2] of elementType
      
               % First, we build a vector of nArray's, each with one subrange as its index type,
               % but without setting the "of" type or size.
      
12053:          NodeVec dimensions = oNodeVecNew
      
12058:          {
                  % to do: probably should use general subrange parsing, incl minimal size value
                  %   In fact, supposed to parse ordinal_type here.  all ordinal types have a static low, high.
                  %   Not necessary to be a subrange.
      
12058:             Node subrange = oNodeNew( nSubrangeType )
      
12068:             @ConstExpr
12070:             oNodeSetInt( subrange, qLow, oValueTop )
12081:             oValuePop
12082:             '..'
12084:             @ConstExpr
12086:             oNodeSetInt( subrange, qHigh, oValueTop )
12097:             oValuePop
      
12098:             @ConstMatchTypes
12100:             oNodeSet( subrange, qBaseType, oTypeSTop )
12111:             oNodeSetInt( subrange, qSize, oNodeGetInt( oTypeSTop, qSize ) )
12129:             oTypeSPop
12130:             oTypeAdd( subrange )
      
12136:             Node a = oNodeNew( nArrayType )
12146:             oNodeSet( a, qIndexType, subrange )
      
12158:             oNodeVecAppend( dimensions, a )
                  % I'll hold off on adding 'a' to the type table since not fully formed yet
      
12167:             [
12167:                | ']' : >
12171:                | ',' :
12173:             ]
12181:          }
      
12183:          pOf
12185:          Node baseType
12185:          @TypeRef( baseType )
      
               % Work backwards through the dimensions,
               % hooking up the 'of' type and calculating the size.
               % At each iteration, baseType is the 'of' type.
      
12192:          int dim = oNodeVecSize( dimensions )
      
12202:          {
12202:              dec(dim)
      
12208:              Node a = oNodeVecElement( dimensions, dim )
      
12221:              oNodeSet( a, qBaseType, baseType )
12233:              Node subrange = oNodeGet( a, qIndexType )
12246:              int width = subtract( oNodeGetInt( subrange, qHigh ), oNodeGetInt( subrange, qLow ) )
12273:              inc( width )
12279:              oNodeSetInt( a, qSize, multiply( width, oNodeGetInt( baseType, qSize ) ) )
      
12305:              oTypeAdd( a )
12311:              baseType = a
      
12317:              [ equal_zero(dim)
12324:                  | true:  >
12327:                  | *:
12332:              ]
12332:          }
      
12334:          resultType = oNodeVecElement( dimensions, 0 )
12347:          oNodeVecDelete( dimensions )
      
12353:       | '^' :
12355:          Node theType
12355:          @TypeRef( theType )
12362:          resultType = @PointerTypeTo( theType )
      
12373:       | pRecord :
12375:          resultType = oNodeNew( nRecordType )
12385:          oScopeBegin( -1, allocUp )    % level is meaningless here
      
12394:          @VarDecl( nRecordField )
      
12401:          int size = oNodeGetInt( oScopeCurrent, qSize )
               % to do: padding
12413:          [ equal_zero( size )
12420:             | true : #eRecordEmpty
12423:             | * :
12428:          ]
      
12428:          pEnd
      
12430:          oNodeSet( resultType, qScope, oScopeCurrent )
12441:          oNodeSetInt( resultType, qSize, size )
12453:          oScopeEnd
12454:          oTypeAdd( resultType )
      
      
12460:       | '(' :
               % An enum type declaration.
12462:          @EnumTypeRef( resultType )
      
      
            % *** TO DO: following type constructors are not implemented *** 
12469:       | pSet :
12471:          pOf
12473:          Node theType
12473:          @TypeRef( theType )
12480:          #eNotImplemented
12482:       | * :       % this works for cases except where expr starts with an id
12497:          @ConstExpr '..' @ConstExpr
12503:          @ConstMatchTypes
12505:          #eNotImplemented
12507:    ];
      
      
      % Parse an enum type.
      % We've already accepted the '('
      % Returns the new type.
      %
12508: EnumTypeRef( out Node resultType ):
      
12510:    resultType = oNodeNew( nEnumType )
12520:    int value = 0
12526:    int numValues = 0
12532:    boolean first = true
      
         % We'll declare the enum values in two scopes: the current scope, and a scope nested in the enum type.
         % That will let programs use either <val> or <enumType>.<val>
12538:    Node outerScope = oScopeCurrent
12543:    oScopeBegin( -1, allocUp )   % level is meaningless, and we won't use allocate
      
12552:    {
            % TO DO: assert that name not already seen in this scope, i.e. this enum.
            %  And possibly not in the outerScope either, since that probably wouldn't count as shadowing.
            %  It might be in some other higher/used scope.
12552:       pIdent
12554:       Node decl = @newIdent( nEnumValue, LAST_ID )
12567:       Node decl2 = @newIdent( nEnumValue, LAST_ID )
12580:       oNodeSet( decl, qType, resultType )
12592:       oNodeSet( decl2, qType, resultType )
      
            % build up name table, for i/o
12604:       int nameOffset = oStringAllocLit( ID_STRING( LAST_ID ) )
12617:       oNodeSetInt( decl, qNameOffset, nameOffset )
12629:       oNodeSetInt( decl2, qNameOffset, nameOffset )
12641:       [
12641:          | '=', ':=' :
12643:             oTypeSPush( IntegerType )
12649:             @ConstExpr
12651:             @ConstCoerceType
12653:             oTypeSPop
                  % value must be ascending
                  % this obviously doesn't apply to the first value
12654:             [ equal_zero( numValues )
12661:                | false :
12662:                   [ greater( oValueTop, value )
12671:                      | false :   #eEnumValueNotAscending
12674:                      | * :
12679:                   ]
12679:                | * :
12684:             ]
12684:             [ equal( value, oValueTop )
12693:                | false :
                        % The values differ from 0..N-1.  pred/succ may not be used with this type.
12694:                   oNodeSetBoolean( resultType, qHasGap, true )
12706:                | * :
12711:             ]
12711:             value = oValueTop
12716:             oValuePop
12717:          | * :
12724:       ]
12724:       oNodeSetInt( decl, qValue, value )
12736:       oNodeSetInt( decl2, qValue, value )
12748:       oScopeDeclare( decl )
      
12754:       oScopeEnter( outerScope )
12760:       oScopeDeclare( decl2 )
12766:       oScopeEnd
      
12767:       inc( value )
12773:       inc( numValues )
12779:       [
12779:          | ',' :
12781:          | * :    >
12788:       ]
12788:    }
12790:    ')'
      
12792:    oNodeSet( resultType, qScope, oScopeCurrent )
12803:    oNodeSetInt( resultType, qSize, 4 )   % always integer sized
12815:    oScopeEnd
      
         % Finish creation of the name table
         %    struct {
         %      int    value;
         %      int    padding;
         %      char*  name;
         %    } table[ numValues + 1 ];
         %  final entry will have name == nullptr
         %
         % I'll need to generate init code, to store pointers in global data,
         % since I don't have a relocation mechanism for static data at the moment.
12816:    oCodePush( @GetOrCreateInitCode( globalScope ) )
12827:    oScopeEnter( globalScope )
12833:    int size = multiply( add( numValues, 1 ), 16 )
12853:    int addr = oScopeAlloc( size, 8 )
12866:    oScopeEnd
12867:    oNodeSetInt( resultType, qNameTable, addr )
         % loop over enum values
12879:    NodeIter it = oNodeGetIter( oNodeGet( resultType, qScope ), qDecls )
12899:    {
12899:       Node enumValue = oNodeIterValue( it )
12909:       [ oNodeNull( enumValue )
12916:          | true :  >
12919:          | * :
12924:       ]
12924:       .tPushAddrGlobal  oEmitInt( addr )
12932:       .tPushConstI  oEmitInt( oNodeGetInt( enumValue, qValue ) )
12947:       .tAssignI
12949:       addr = add( addr, 8 )
12962:       .tPushAddrGlobal  oEmitInt( addr )
12970:       .tPushAddrGlobal  oEmitInt( oNodeGetInt( enumValue, qNameOffset ) )
12985:       .tAssignP
12987:       addr = add( addr, 8 )
13000:       oNodeIterNext( it )
13006:    }
         % final table entry
13008:    .tPushAddrGlobal  oEmitInt( addr )
13016:    .tPushConstI  oEmitInt( 0 )
13024:    .tAssignI
13026:    addr = add( addr, 8 )
13039:    .tPushAddrGlobal  oEmitInt( addr )
13047:    .tPushConstI  oEmitInt( 0 )
13055:    .tAssignP
13057:    addr = add( addr, 8 )
13070:    oCodePop
      
13071:    oTypeAdd( resultType )
13078:    ;
      
      
      
      % Return an nType representing a pointer to the given type.
      % (Creates a new type if necessary.)
      %
13078: PointerTypeTo( Node theType ) >> Node:
13080:    Node ptrType = oNodeGet( theType, qPointerType )
13093:    [ oNodeNull( ptrType )
13100:       | true :
13101:          ptrType = oNodeNew( nPointerType )
13111:          oNodeSet( ptrType, qBaseType, theType )
13123:          oNodeSetInt( ptrType, qSize, 8 )
13135:          oTypeAdd( ptrType )
13141:          oNodeSet( theType, qPointerType, ptrType )
13153:       | * :
13158:    ]
13158:    >> ptrType;
      
      
      
      % Return the low value of an ordinal type
      %
13162: OrdinalLow( Node theType ) >> int:
13164:    [ oNodeType( theType )
13171:       | nIntegerType :  >> oMININT
13174:       | nBooleanType :  >> 0
13179:       | nCharType :     >> 0
13184:       | nEnumType :
13186:          Node enumScope = oNodeGet( theType, qScope )
13199:          Node first = oNodeIterValue( oNodeGetIter( enumScope, qDecls ) )
13216:          >> oNodeGetInt( first, qValue )
13226:       | nSubrangeType : >> oNodeGetInt( theType, qLow )
13238:       | * :             #eNotOrdinalType
13253:                         >> 0
13256:    ];
      
      
      % Return the high value of an ordinal type
      %
13257: OrdinalHigh( Node theType ) >> int:
13259:    [ oNodeType( theType )
13266:       | nIntegerType :  >> oMAXINT
13269:       | nBooleanType :  >> 1
13274:       | nCharType :     >> 255
13279:       | nEnumType :
13281:          Node enumScope = oNodeGet( theType, qScope )
13294:          Node last = oNodeIterValue( oNodeGetIterLast( enumScope, qDecls ) )
13311:          >> oNodeGetInt( last, qValue )
13321:       | nSubrangeType : >> oNodeGetInt( theType, qHigh )
13333:       | * :             #eNotOrdinalType
13348:                         >> 0
13351:    ];
      
      
      
13352: Program:
13354:    Node t
      
13354:    workspace = oWorkspaceNew
      
         % root scope is used for builtins e.g. Integer,
         % and is a parent to any used units, and the program's own global scope.
13359:    oScopeBegin( 0, allocGlobal )
13368:    Node rootScope = oScopeCurrent
      
13373:    @installBuiltIns
      
         % Start by calling the main program routine.
      
         % This dummy call to main needs to look like a normal method itself,
         % so jit can align the stack properly.  So we need .tEnter,
         % and .tAllocActuals / .tFreeActuals.
13375:    .tEnter  oEmitInt( 0 )
13383:    Label mainLabel = oLabelNew
      
13388:    .tAllocActuals  oEmitInt( 0 )
13396:    .tCall  oEmitLabel( mainLabel )
13404:    .tFreeActuals  oEmitInt( 0 )
13412:    .tReturn
      
13414:    pProgram
13416:    pIdent
      
13418:    Node program = oNodeNew( nProgram )
13428:    oNodeSetInt( program, qIdent, LAST_ID )
13439:    oNodeSet( workspace, qProgram, program )
      
      
13451:    [
13451:       | '(' :
13453:          pIdent      % input, output files
      
13455:          t = @newIdent( nVar, LAST_ID )
13468:          oNodeSet( t, qType, FileType )
13480:          oScopeDeclareAlloc( t )
               % TO DO: I shouldn't declare the files in root scope.
               %        Should save them for program's global scope.
      
13486:          ','
13488:          pIdent
      
13490:          t = @newIdent( nVar, LAST_ID )
13503:          oNodeSet( t, qType, FileType )
13515:          oScopeDeclareAlloc( t )
      
13521:          ')'
13523:       | * :
13528:    ]
13528:    ';'
      
13530:    @UsesMySystem( program )
         % The uses clause may only appear once, immediately after the program declaration.
13537:    [
13537:       | pUses :  @UsesClause( program )
13546:       | * :
13551:    ]
13551:    @EnterUsedUnits( program )
      
         % Global scope for the program, below any used units.
13558:    oScopeBegin( 0, allocGlobal )
13567:    globalScope = oScopeCurrent
      
         % A new scope just for temporaries in the main routine
         % Create it up front, in case it's needed by variable initialization exprs.
         % But we won't stay in it here.
         % Note we say it extends the global scope, so that during main statement evaluation
         % any user labels declared in the global scope are considered to be part of the current scope.
13572:    oScopeBegin( 0, allocDown )
13581:    oNodeSet( oScopeCurrent, qExtends, globalScope )
13592:    initScope = oScopeCurrent
13597:    oNodeSet( program, qMainRoutineScope, initScope )
13609:    oScopeEnd
      
13610:    @BlockDecls( nGlobalVar )
      
      
13617:    oScopeEnter( initScope )
      
         % The block statement includes a stack frame, and enter/return,
         % even for the main routine.
         % That will be necessary for temporaries allocated in the main routine.
      
         % isMain means we'll generate calls to the unit init/final methods in here too.
         % Alternatively we could do that in a higher level method that calls main.
13623:    boolean isMain = true
13629:    @BlockStmt( mainLabel, globalScope, isMain )
      
13642:    oScopeEnd   % main routine scope
      
13643:    '.'
13645:    @CheckForUndefinedLabels
13647:    oScopeEnd   % global scope
13648:    @EndUsedUnits( program )   % used units scopes
13656:    ;
      
      
      
      
13656: Block( node_type varNodeType, Label labelForBody ):
13658:    @BlockDecls( varNodeType )
13665:    @BlockStmt( labelForBody, oScopeCurrent, false )
13677:    @CheckForUndefinedLabels
13680:    ;
      
      
13680: BlockDecls( node_type varNodeType ):
13682:    {[
13682:       | pConst :     @ConstDecl
13686:       | pType :      @TypeDecl
13690:       | pVar :       @VarDecl( varNodeType )
13699:       | pLabel :     @LabelDecl
13703:       | pProcedure : @ProcDecl
13707:       | pFunction :  @FuncDecl
13711:       | * :          >
13728:    ]}
13730:    @CheckForUndefinedMethods
13733:    ;
      
      
      % were there any procedures or functions declared in this scope
      % that were never defined?
13733: CheckForUndefinedMethods:
         % TO DO
         % Note: disregard methods marked external
13736:    ;
      
      % were there any labels declared in the current scope, and used,
      % but never defined (as the prefix of a stement)?
      %
13736: CheckForUndefinedLabels:
13738:    NodeIter it = oNodeGetIter( oScopeCurrent, qDecls )
13750:    {
13750:       Node decl = oNodeIterValue( it )
13760:       [ oNodeNull( decl )
13767:          | false :
13768:          | * :  >
13775:       ]
13775:       [ oNodeType( decl )
13782:          | nLabel :
13783:             [ oNodeGetBoolean( decl, qDefined )
13793:                | false :
13794:                   [ oNodeGetBoolean( decl, qUsed )
13804:                      | true :    #eUsedButNotDefined  % TO DO: give the decl in the message
13807:                      | * :
13812:                   ]
13812:                | * :
13817:             ]
13817:          | * :
13822:       ]
13822:       oNodeIterNext( it )
13828:    }
13831:    ;
      
      
      % Given the scope of vars in this block.
      % Usually it's the current scope, but it's a bit different for the main statement.
      %
13831: BlockStmt( Label labelForBody, Node varScope, boolean isMain ):
13833:    .tLabel  oEmitLabel( labelForBody )
      
         % Proc, func, and main routine all start with tEnter
         % to create a stack frame.  This will be used for temporaries
         % (and local vars in the case of proc, func).
      
13841:    int patchLS
13841:    .tEnter  patchLS = Here  .tSpace
      
         % If we're generating the program main method,
         % add in calls to the loaded units' initialization and finalization.
13850:    [ isMain
13853:       | true :  @InitializeUnits
13856:       | * :
13861:    ]
      
         % insert any code for initialization of this scope's variables
13861:    Code initCode = oNodeGetCode( varScope, qInitCode )
13874:    oEmitCode( initCode )
13880:    oNodeSetCode( varScope, qInitCode, codeNull )
      
13892:    @Statement
      
13894:    [ isMain
13897:       | true :  @FinalizeUnits
13900:       | * :
13905:    ]
      
13905:    .tReturn
      
13907:    int localSpace = oNodeGetInt( oScopeCurrent, qSize )
13919:    oPatch( patchLS, localSpace )
13929:    ;
      
      
      % We need an initCode code stream for the given scope.
      % Create it if not present yet.  Return it.
      % (This will be used for variable initialization.)
      %
13929: GetOrCreateInitCode( Node scope ) >> Code:
13931:    Code initCode = oNodeGetCode( scope, qInitCode )
13944:    [ equal_code( initCode, codeNull )
13954:       | true :
13955:          initCode = oCodeNew
13960:          oNodeSetCode( scope, qInitCode, initCode )
13972:       | * :
13977:    ]
13977:    >> initCode;
      
      
      
      
      
      % -------------------------------- Utilities -------------------------------
      
      % Return the static scope level of the current scope
      %
13981: ScopeLevel >> int:
13983:    >> oNodeGetInt( oScopeCurrent, qLevel );
      
      % Return the static scope level of the given declaration
      %
13993: DeclLevel( Node decl ) >> int:
13995:    >> oNodeGetInt( oNodeGet( decl, qParentScope ), qLevel );
         
      
      % How many levels higher is the given declaration from the current scope?
      %
14013: DeclUpLevels( Node decl ) >> int:
14015:    >> subtract( @ScopeLevel, @DeclLevel( decl ) );
      
      
      
      
      % Create and return a new nIdent of the given node_type, with the given ident id.
      % Does not add it to any scope.
      %
14031: newIdent( node_type nt, int id ) >> Node:
14033:   Node t = oNodeNew( nt )
14043:   oNodeSetInt( t, qIdent, id )
14055:   >> t
14059:   ;
      
      
      % Emit the value in a declaration.
      % For a constant integer, this is the constant value.
      % For a global variable, this is the global address.
      % For a local variable, this is the local address relative to the call stack frame.
      %
14059: EmitValue( Node decl ):
14061:     oEmitInt( oNodeGetInt( decl, qValue ));
      
      
14075: DeclareBuiltInFunc( int id ) >> Node:
14077:    Node decl = @newIdent( nBuiltInFunc, id )
14091:    oScopeDeclare( decl )
14097:    >> decl;
      
      
14101: installBuiltIns:
      
         % initialize some other globals too
14103:    flagExprAllowTypeName = false
      
         % "mysystem" is the name of a unit that will be available everywhere.
         % Add its name to the id table so we can easily spot the name later.
14109:    mysystemId = oId_mysystem
      
         % install built-in types
14114:    FileType = @newType( nFileType, 4 )
14128:    IntegerType = @newType( nIntegerType, 4 )
14142:    BooleanType = @newType( nBooleanType, 1 )
14156:    BooleanFlowType = @newType( nBooleanFlowType, 1 )
14170:    CharType = @newType( nCharType, 1 )
14184:    PCharType = @PointerTypeTo( CharType )
14195:    ByteType = @newType( nByteType, 1 )
14209:    SingleType = @newType( nSingleType, 4 )
14223:    DoubleType = @newType( nDoubleType, 8 )
         % Universal pointer says base type Byte, but this is only for the sake of
         % pointer arithmetic.  It doesn't matter otherwise, because this type cannot be dereferened.
14237:    UniversalPointerType = @newType( nUniversalPointerType, 8 )
14251:    oNodeSet( UniversalPointerType, qBaseType, ByteType )
         % StrLitType is stored with both a length byte and null termination, so it can be assigned to
         % both a ShortString and a PChar.  StrLits longer than 255 characters appear truncated when
         % referenced as a ShortString, but not when referenced as a PChar.
14263:    StrLitType = @newType( nStrLitType, 256 )
         % ShortString is the original Pascal string type: an array of characters, not null-terminated,
         % with the first byte recording the current length.
         % The default ShortString type has capacity for 255 characters.  The user may define
         % additional ShortString types with smaller capacities.
         % The first character can be accessed as myString[1].
14277:    ShortStringType = @newType( nShortStringType, 256 )
14291:    oNodeSetInt( ShortStringType, qCapacity, 255 )
      
         % Declare those type identifiers.
         % SSL doesn't support strings, so need help from operations e.g. oId_File
      
14303:    Node t
      
14303:    t = @newIdent( nTypeDecl, oId_File )
14316:    oNodeSet( t, qType, FileType )
14328:    oScopeDeclare( t )
      
14334:    t = @newIdent( nTypeDecl, oId_Integer )
14347:    oNodeSet( t, qType, IntegerType )
14359:    oScopeDeclare( t )
      
14365:    t = @newIdent( nTypeDecl, oId_Boolean )
14378:    oNodeSet( t, qType, BooleanType )
14390:    oScopeDeclare( t )
      
14396:    t = @newIdent( nTypeDecl, oId_Char )
14409:    oNodeSet( t, qType, CharType )
14421:    oScopeDeclare( t )
      
14427:    t = @newIdent( nTypeDecl, oId_Byte )
14440:    oNodeSet( t, qType, ByteType )
14452:    oScopeDeclare( t )
      
14458:    t = @newIdent( nTypeDecl, oId_Single )
14471:    oNodeSet( t, qType, SingleType )
14483:    oScopeDeclare( t )
      
14489:    t = @newIdent( nTypeDecl, oId_Double )
14502:    oNodeSet( t, qType, DoubleType )
14514:    oScopeDeclare( t )
      
14520:    t = @newIdent( nTypeDecl, oId_Pointer )
14533:    oNodeSet( t, qType, UniversalPointerType )
14545:    oScopeDeclare( t )
      
14551:    t = @newIdent( nTypeDecl, oId_ShortString )
14564:    oNodeSet( t, qType, ShortStringType )
14576:    oScopeDeclare( t )
      
         % Built-in constants
      
14582:    t = @newIdent( nConst, oId_True )
14595:    oNodeSet( t, qType, BooleanType )
14607:    oNodeSetInt( t, qValue, 1 )
14619:    oScopeDeclare( t )
      
14625:    t = @newIdent( nConst, oId_False )
14638:    oNodeSet( t, qType, BooleanType )
14650:    oNodeSetInt( t, qValue, 0 )
14662:    oScopeDeclare( t )
      
14668:    t = @newIdent( nConst, oId_Nil )
14681:    oNodeSet( t, qType, UniversalPointerType )
14693:    oNodeSetInt( t, qValue, 0 )
14705:    oScopeDeclare( t )
      
         % Built-in methods
         % These aren't declared like normal methods, because they may have
         % special rules for parameter types (e.g. any scalar type).
         % Calls to these methods will be handled specially by the compiler.
      
14711:    BuiltIn_Ord = @DeclareBuiltInFunc( oId_Ord )
14721:    BuiltIn_Chr = @DeclareBuiltInFunc( oId_Chr )
14731:    BuiltIn_Pred = @DeclareBuiltInFunc( oId_Pred )
14741:    BuiltIn_Succ = @DeclareBuiltInFunc( oId_Succ )
14751:    BuiltIn_Sizeof = @DeclareBuiltInFunc( oId_Sizeof )
14762:    ;
      
14762: end
      
14762: 

Generated code:

   0: oGlobalSpace 26
   2: oLocalSpace 0
   4: oCall 13352
   6: oReturn
   7: oLocalSpace 0
   9: oInput 0
  11: LAST_ID
  12: oPushResult
  13: oGetParam 1
  15: oPushResult
  16: oCall 148
  18: oPop 2
  20: oInputChoice 24
  22: oJumpForward 29
  24: Choice Lookup Table
          14     22
  27: oJumpForward 31
  29: oJumpBack 9
  31: oInput 6
  33: oReturn
  34: oLocalSpace 0
  36: oGetParam 1
  38: oPushResult
  39: oSetResult 4
  41: oPushResult
  42: oNodeGetInt
  43: oPop 2
  45: oPushResult
  46: oGetGlobal 4
  48: oPushResult
  49: equal
  50: oPop 2
  52: oChoice 57
  54: oReturn
  55: oJumpForward 60
  57: Choice Lookup Table
           1     54
  60: oGetGlobal 4
  62: oPushResult
  63: oGetParam 1
  65: oPushResult
  66: oCall 148
  68: oPop 2
  70: oReturn
  71: oLocalSpace 0
  73: oGetParam 1
  75: oPushResult
  76: oSetResult 4
  78: oPushResult
  79: oNodeGetInt
  80: oPop 2
  82: oPushResult
  83: oGetGlobal 4
  85: oPushResult
  86: equal
  87: oPop 2
  89: oChoice 144
  91: oGetAddrGlobal 22
  93: oPushResult
  94: oScopeCurrent
  95: oPushResult
  96: oSetResult 15
  98: oPushResult
  99: oSetResult 4
 101: oPushResult
 102: oId_ShortStringAppendShortString
 103: oPushResult
 104: oNodeFind
 105: oPop 4
 107: oAssign
 108: oGetAddrGlobal 23
 110: oPushResult
 111: oScopeCurrent
 112: oPushResult
 113: oSetResult 15
 115: oPushResult
 116: oSetResult 4
 118: oPushResult
 119: oId_ShortStringAppendChar
 120: oPushResult
 121: oNodeFind
 122: oPop 4
 124: oAssign
 125: oGetAddrGlobal 24
 127: oPushResult
 128: oScopeCurrent
 129: oPushResult
 130: oSetResult 15
 132: oPushResult
 133: oSetResult 4
 135: oPushResult
 136: oId_ShortStringCmp
 137: oPushResult
 138: oNodeFind
 139: oPop 4
 141: oAssign
 142: oJumpForward 147
 144: Choice Lookup Table
           1     91
 147: oReturn
 148: oLocalSpace 2
 150: oGetAddrLocal 1
 152: oPushResult
 153: oGetParam 2
 155: oPushResult
 156: oCall 428
 158: oPop 1
 160: oAssign
 161: oGetLocal 1
 163: oPushResult
 164: oSetResult 0
 166: oPushResult
 167: equal_node
 168: oPop 2
 170: oChoice 240
 172: oGetParam 1
 174: oPushResult
 175: oSetResult 5
 177: oPushResult
 178: oGetLocal 1
 180: oPushResult
 181: oNodeAddLast
 182: oPop 3
 184: oGetAddrLocal 2
 186: oPushResult
 187: oSetResult 10
 189: oPushResult
 190: oNodeNew
 191: oPop 1
 193: oAssign
 194: oGetLocal 2
 196: oPushResult
 197: oSetResult 4
 199: oPushResult
 200: oGetLocal 1
 202: oPushResult
 203: oSetResult 4
 205: oPushResult
 206: oNodeGetInt
 207: oPop 2
 209: oPushResult
 210: oNodeSetInt
 211: oPop 3
 213: oGetLocal 2
 215: oPushResult
 216: oSetResult 9
 218: oPushResult
 219: oGetLocal 1
 221: oPushResult
 222: oSetResult 9
 224: oPushResult
 225: oNodeGet
 226: oPop 2
 228: oPushResult
 229: oNodeSet
 230: oPop 3
 232: oGetLocal 2
 234: oPushResult
 235: oScopeDeclare
 236: oPop 1
 238: oJumpForward 243
 240: Choice Lookup Table
           0    172
 243: oReturn
 244: oLocalSpace 1
 246: oGetFromParam 1
 248: oPushResult
 249: oNodeType
 250: oPop 1
 252: oChoice 283
 254: oGetAddrLocal 1
 256: oPushResult
 257: oGetFromParam 1
 259: oPushResult
 260: oSetResult 9
 262: oPushResult
 263: oNodeGet
 264: oPop 2
 266: oAssign
 267: oInput 21
 269: oInput 0
 271: oGetParam 1
 273: oPushResult
 274: oGetLocal 1
 276: oPushResult
 277: oScopeFindRequireInScope
 278: oPop 1
 280: oAssign
 281: oJumpForward 286
 283: Choice Lookup Table
          10    254
 286: oReturn
 287: oLocalSpace 2
 289: oGetAddrLocal 1
 291: oPushResult
 292: oGetParam 1
 294: oPushResult
 295: oSetResult 5
 297: oPushResult
 298: oNodeGetIter
 299: oPop 2
 301: oAssign
 302: oGetAddrLocal 2
 304: oPushResult
 305: oGetLocal 1
 307: oPushResult
 308: oNodeIterValue
 309: oPop 1
 311: oAssign
 312: oGetLocal 2
 314: oPushResult
 315: oNodeNull
 316: oPop 1
 318: oChoice 335
 320: oGetLocal 2
 322: oPushResult
 323: oSetResult 9
 325: oPushResult
 326: oNodeGet
 327: oPop 2
 329: oPushResult
 330: oScopeEnter
 331: oPop 1
 333: oJumpForward 340
 335: Choice Lookup Table
           0    320
 338: oJumpForward 348
 340: oGetAddrLocal 1
 342: oPushResult
 343: oNodeIterNext
 344: oPop 1
 346: oJumpBack 302
 348: oReturn
 349: oLocalSpace 2
 351: oGetAddrLocal 1
 353: oPushResult
 354: oGetParam 1
 356: oPushResult
 357: oSetResult 5
 359: oPushResult
 360: oNodeGetIterLast
 361: oPop 2
 363: oAssign
 364: oGetAddrLocal 2
 366: oPushResult
 367: oGetLocal 1
 369: oPushResult
 370: oNodeIterValue
 371: oPop 1
 373: oAssign
 374: oGetLocal 2
 376: oPushResult
 377: oNodeNull
 378: oPop 1
 380: oChoice 414
 382: oScopeCurrent
 383: oPushResult
 384: oGetLocal 2
 386: oPushResult
 387: oSetResult 9
 389: oPushResult
 390: oNodeGet
 391: oPop 2
 393: oPushResult
 394: oNodeEqual
 395: oPop 2
 397: oChoice 405
 399: oJumpForward 411
 401: oError 25
 403: oJumpForward 411
 405: Choice Lookup Table
           0    401
           1    399
 410: oEndChoice
 411: oScopeEnd
 412: oJumpForward 419
 414: Choice Lookup Table
           0    382
 417: oJumpForward 427
 419: oGetAddrLocal 1
 421: oPushResult
 422: oNodeIterPrev
 423: oPop 1
 425: oJumpBack 364
 427: oReturn
 428: oLocalSpace 2
 430: oGetAddrLocal 1
 432: oPushResult
 433: oGetGlobal 1
 435: oPushResult
 436: oSetResult 1
 438: oPushResult
 439: oSetResult 4
 441: oPushResult
 442: oGetParam 1
 444: oPushResult
 445: oNodeFind
 446: oPop 4
 448: oAssign
 449: oGetLocal 1
 451: oPushResult
 452: oSetResult 0
 454: oPushResult
 455: equal_node
 456: oPop 2
 458: oChoice 465
 460: oGetLocal 1
 462: oReturn
 463: oJumpForward 468
 465: Choice Lookup Table
           0    460
 468: oGetAddrLocal 2
 470: oPushResult
 471: oGetParam 1
 473: oPushResult
 474: oIncludeUnitFile
 475: oPop 1
 477: oAssign
 478: oGetLocal 2
 480: oChoice 489
 482: oError 24
 484: oSetResult 0
 486: oReturn
 487: oJumpForward 492
 489: Choice Lookup Table
           0    482
 492: oGetAddrLocal 1
 494: oPushResult
 495: oCall 503
 497: oAssign
 498: oIncludeEnd
 499: oGetLocal 1
 501: oReturn
 502: oReturn
 503: oLocalSpace 2
 505: oInput 61
 507: oInput 0
 509: oGetAddrLocal 1
 511: oPushResult
 512: oSetResult 5
 514: oPushResult
 515: oNodeNew
 516: oPop 1
 518: oAssign
 519: oGetLocal 1
 521: oPushResult
 522: oSetResult 4
 524: oPushResult
 525: LAST_ID
 526: oPushResult
 527: oNodeSetInt
 528: oPop 3
 530: oGetAddrLocal 2
 532: oPushResult
 533: oSetResult 6
 535: oPushResult
 536: oNodeNew
 537: oPop 1
 539: oAssign
 540: oGetLocal 2
 542: oPushResult
 543: oSetResult 4
 545: oPushResult
 546: LAST_ID
 547: oPushResult
 548: oNodeSetInt
 549: oPop 3
 551: oGetLocal 1
 553: oPushResult
 554: oSetResult 8
 556: oPushResult
 557: oGetLocal 2
 559: oPushResult
 560: oNodeSet
 561: oPop 3
 563: oInput 6
 565: oInput 62
 567: oGetLocal 1
 569: oPushResult
 570: oCall 34
 572: oPop 1
 574: oInputChoice 585
 576: oGetLocal 1
 578: oPushResult
 579: oCall 7
 581: oPop 1
 583: oJumpForward 588
 585: Choice Lookup Table
          60    576
 588: oGetLocal 1
 590: oPushResult
 591: oCall 287
 593: oPop 1
 595: oSetResult 0
 597: oPushResult
 598: oSetResult 0
 600: oPushResult
 601: oScopeBegin
 602: oPop 2
 604: oGetLocal 1
 606: oPushResult
 607: oSetResult 9
 609: oPushResult
 610: oScopeCurrent
 611: oPushResult
 612: oNodeSet
 613: oPop 3
 615: oGetAddrGlobal 2
 617: oPushResult
 618: oScopeCurrent
 619: oAssign
 620: oSetResult 0
 622: oPushResult
 623: oSetResult 1
 625: oPushResult
 626: oScopeBegin
 627: oPop 2
 629: oGetAddrGlobal 3
 631: oPushResult
 632: oScopeCurrent
 633: oAssign
 634: oGetLocal 1
 636: oPushResult
 637: oSetResult 13
 639: oPushResult
 640: oGetGlobal 3
 642: oPushResult
 643: oNodeSet
 644: oPop 3
 646: oScopeEnd
 647: oGetLocal 1
 649: oPushResult
 650: oCall 838
 652: oPop 1
 654: oScopeEnd
 655: oInput 63
 657: oGetLocal 2
 659: oPushResult
 660: oCall 34
 662: oPop 1
 664: oInputChoice 675
 666: oGetLocal 2
 668: oPushResult
 669: oCall 7
 671: oPop 1
 673: oJumpForward 678
 675: Choice Lookup Table
          60    666
 678: oGetLocal 2
 680: oPushResult
 681: oCall 287
 683: oPop 1
 685: oGetLocal 1
 687: oPushResult
 688: oSetResult 9
 690: oPushResult
 691: oNodeGet
 692: oPop 2
 694: oPushResult
 695: oScopeEnter
 696: oPop 1
 698: oSetResult 0
 700: oPushResult
 701: oSetResult 0
 703: oPushResult
 704: oScopeBegin
 705: oPop 2
 707: oGetLocal 1
 709: oPushResult
 710: oSetResult 10
 712: oPushResult
 713: oScopeCurrent
 714: oPushResult
 715: oNodeSet
 716: oPop 3
 718: oScopeCurrent
 719: oPushResult
 720: oSetResult 16
 722: oPushResult
 723: oGetLocal 1
 725: oPushResult
 726: oSetResult 9
 728: oPushResult
 729: oNodeGet
 730: oPop 2
 732: oPushResult
 733: oNodeSet
 734: oPop 3
 736: oGetAddrGlobal 2
 738: oPushResult
 739: oScopeCurrent
 740: oAssign
 741: oGetLocal 1
 743: oPushResult
 744: oCall 930
 746: oPop 1
 748: oInputChoice 762
 750: oGetLocal 1
 752: oPushResult
 753: oSetResult 1
 755: oPushResult
 756: oCall 940
 758: oPop 2
 760: oJumpForward 775
 762: Choice Lookup Table
          64    750
 765: oGetLocal 1
 767: oPushResult
 768: oSetResult 0
 770: oPushResult
 771: oCall 940
 773: oPop 2
 775: oInputChoice 789
 777: oGetLocal 1
 779: oPushResult
 780: oSetResult 1
 782: oPushResult
 783: oCall 1126
 785: oPop 2
 787: oJumpForward 802
 789: Choice Lookup Table
          65    777
 792: oGetLocal 1
 794: oPushResult
 795: oSetResult 0
 797: oPushResult
 798: oCall 1126
 800: oPop 2
 802: oInput 37
 804: oInput 21
 806: oScopeEnd
 807: oScopeEnd
 808: oGetLocal 2
 810: oPushResult
 811: oCall 349
 813: oPop 1
 815: oGetLocal 1
 817: oPushResult
 818: oCall 349
 820: oPop 1
 822: oGetGlobal 1
 824: oPushResult
 825: oSetResult 1
 827: oPushResult
 828: oGetLocal 1
 830: oPushResult
 831: oNodeAddLast
 832: oPop 3
 834: oGetLocal 1
 836: oReturn
 837: oReturn
 838: oLocalSpace 2
 840: oInputChoice 907
 842: oCall 2520
 844: oJumpForward 920
 846: oCall 3184
 848: oJumpForward 920
 850: oSetResult 21
 852: oPushResult
 853: oCall 3240
 855: oPop 1
 857: oJumpForward 920
 859: oGetAddrLocal 1
 861: oPushResult
 862: oCall 1487
 864: oAssign
 865: oInputChoice 878
 867: oGetLocal 1
 869: oPushResult
 870: oCall 1418
 872: oPop 1
 874: oInput 6
 876: oJumpForward 881
 878: Choice Lookup Table
          71    867
 881: oJumpForward 920
 883: oGetAddrLocal 2
 885: oPushResult
 886: oCall 1861
 888: oAssign
 889: oInputChoice 902
 891: oGetLocal 2
 893: oPushResult
 894: oCall 1418
 896: oPop 1
 898: oInput 6
 900: oJumpForward 905
 902: Choice Lookup Table
          71    891
 905: oJumpForward 920
 907: Choice Lookup Table
          31    883
          30    859
          34    850
          33    846
          32    842
 918: oJumpForward 922
 920: oJumpBack 840
 922: oGetParam 1
 924: oPushResult
 925: oCall 71
 927: oPop 1
 929: oReturn
 930: oLocalSpace 0
 932: oSetResult 21
 934: oPushResult
 935: oCall 13680
 937: oPop 1
 939: oReturn
 940: oLocalSpace 5
 942: oGetAddrLocal 1
 944: oPushResult
 945: oLabelNew
 946: oAssign
 947: oEmit 79
 949: oGetLocal 1
 951: oPushResult
 952: oEmitLabel
 953: oPop 1
 955: oGetParam 2
 957: oPushResult
 958: oSetResult 11
 960: oPushResult
 961: oGetLocal 1
 963: oPushResult
 964: oNodeSetLabel
 965: oPop 3
 967: oEmit 69
 969: oGetAddrLocal 2
 971: oPushResult
 972: Here
 973: oAssign
 974: oEmit 97
 976: oGetAddrLocal 3
 978: oPushResult
 979: oGetParam 2
 981: oPushResult
 982: oSetResult 9
 984: oPushResult
 985: oNodeGet
 986: oPop 2
 988: oAssign
 989: oGetAddrLocal 4
 991: oPushResult
 992: oGetLocal 3
 994: oPushResult
 995: oSetResult 19
 997: oPushResult
 998: oNodeGetCode
 999: oPop 2
1001: oAssign
1002: oGetLocal 4
1004: oPushResult
1005: oEmitCode
1006: oPop 1
1008: oGetLocal 3
1010: oPushResult
1011: oSetResult 19
1013: oPushResult
1014: oSetResult 0
1016: oPushResult
1017: oNodeSetCode
1018: oPop 3
1020: oGetAddrLocal 3
1022: oPushResult
1023: oGetParam 2
1025: oPushResult
1026: oSetResult 10
1028: oPushResult
1029: oNodeGet
1030: oPop 2
1032: oAssign
1033: oGetAddrLocal 4
1035: oPushResult
1036: oGetLocal 3
1038: oPushResult
1039: oSetResult 19
1041: oPushResult
1042: oNodeGetCode
1043: oPop 2
1045: oAssign
1046: oGetLocal 4
1048: oPushResult
1049: oEmitCode
1050: oPop 1
1052: oGetLocal 3
1054: oPushResult
1055: oSetResult 19
1057: oPushResult
1058: oSetResult 0
1060: oPushResult
1061: oNodeSetCode
1062: oPop 3
1064: oGetParam 2
1066: oPushResult
1067: oSetResult 13
1069: oPushResult
1070: oNodeGet
1071: oPop 2
1073: oPushResult
1074: oScopeEnter
1075: oPop 1
1077: oGetParam 1
1079: oChoice 1098
1081: oCall 8744
1083: oInputChoice 1089
1085: oCall 8744
1087: oJumpForward 1094
1089: Choice Lookup Table
           6   1085
1092: oJumpForward 1096
1094: oJumpBack 1083
1096: oJumpForward 1101
1098: Choice Lookup Table
           1   1081
1101: oEmit 68
1103: oGetAddrLocal 5
1105: oPushResult
1106: oScopeCurrent
1107: oPushResult
1108: oSetResult 17
1110: oPushResult
1111: oNodeGetInt
1112: oPop 2
1114: oAssign
1115: oGetLocal 2
1117: oPushResult
1118: oGetLocal 5
1120: oPushResult
1121: oPatch
1122: oPop 2
1124: oScopeEnd
1125: oReturn
1126: oLocalSpace 3
1128: oGetAddrLocal 1
1130: oPushResult
1131: oLabelNew
1132: oAssign
1133: oEmit 79
1135: oGetLocal 1
1137: oPushResult
1138: oEmitLabel
1139: oPop 1
1141: oGetParam 2
1143: oPushResult
1144: oSetResult 12
1146: oPushResult
1147: oGetLocal 1
1149: oPushResult
1150: oNodeSetLabel
1151: oPop 3
1153: oEmit 69
1155: oGetAddrLocal 2
1157: oPushResult
1158: Here
1159: oAssign
1160: oEmit 97
1162: oSetResult 0
1164: oPushResult
1165: oSetResult 1
1167: oPushResult
1168: oScopeBegin
1169: oPop 2
1171: oGetParam 1
1173: oChoice 1192
1175: oCall 8744
1177: oInputChoice 1183
1179: oCall 8744
1181: oJumpForward 1188
1183: Choice Lookup Table
           6   1179
1186: oJumpForward 1190
1188: oJumpBack 1177
1190: oJumpForward 1195
1192: Choice Lookup Table
           1   1175
1195: oEmit 68
1197: oGetAddrLocal 3
1199: oPushResult
1200: oScopeCurrent
1201: oPushResult
1202: oSetResult 17
1204: oPushResult
1205: oNodeGetInt
1206: oPop 2
1208: oAssign
1209: oGetLocal 2
1211: oPushResult
1212: oGetLocal 3
1214: oPushResult
1215: oPatch
1216: oPop 2
1218: oScopeEnd
1219: oReturn
1220: oLocalSpace 2
1222: oGetAddrLocal 1
1224: oPushResult
1225: oGetGlobal 1
1227: oPushResult
1228: oSetResult 1
1230: oPushResult
1231: oNodeGetIter
1232: oPop 2
1234: oAssign
1235: oGetAddrLocal 2
1237: oPushResult
1238: oGetLocal 1
1240: oPushResult
1241: oNodeIterValue
1242: oPop 1
1244: oAssign
1245: oGetLocal 2
1247: oPushResult
1248: oNodeNull
1249: oPop 1
1251: oChoice 1296
1253: oJumpForward 1304
1255: oJumpForward 1302
1257: oEmit 63
1259: oSetResult 0
1261: oPushResult
1262: oEmitInt
1263: oPop 1
1265: oEmit 66
1267: oGetLocal 2
1269: oPushResult
1270: oSetResult 11
1272: oPushResult
1273: oNodeGetLabel
1274: oPop 2
1276: oPushResult
1277: oEmitLabel
1278: oPop 1
1280: oEmit 65
1282: oSetResult 0
1284: oPushResult
1285: oEmitInt
1286: oPop 1
1288: oGetAddrLocal 1
1290: oPushResult
1291: oNodeIterNext
1292: oPop 1
1294: oJumpForward 1302
1296: Choice Lookup Table
           0   1257
           1   1253
1301: oEndChoice
1302: oJumpBack 1235
1304: oReturn
1305: oLocalSpace 2
1307: oGetAddrLocal 1
1309: oPushResult
1310: oGetGlobal 1
1312: oPushResult
1313: oSetResult 1
1315: oPushResult
1316: oNodeGetIterLast
1317: oPop 2
1319: oAssign
1320: oGetAddrLocal 2
1322: oPushResult
1323: oGetLocal 1
1325: oPushResult
1326: oNodeIterValue
1327: oPop 1
1329: oAssign
1330: oGetLocal 2
1332: oPushResult
1333: oNodeNull
1334: oPop 1
1336: oChoice 1381
1338: oJumpForward 1389
1340: oJumpForward 1387
1342: oEmit 63
1344: oSetResult 0
1346: oPushResult
1347: oEmitInt
1348: oPop 1
1350: oEmit 66
1352: oGetLocal 2
1354: oPushResult
1355: oSetResult 12
1357: oPushResult
1358: oNodeGetLabel
1359: oPop 2
1361: oPushResult
1362: oEmitLabel
1363: oPop 1
1365: oEmit 65
1367: oSetResult 0
1369: oPushResult
1370: oEmitInt
1371: oPop 1
1373: oGetAddrLocal 1
1375: oPushResult
1376: oNodeIterPrev
1377: oPop 1
1379: oJumpForward 1387
1381: Choice Lookup Table
           0   1342
           1   1338
1386: oEndChoice
1387: oJumpBack 1320
1389: oReturn
1390: oLocalSpace 0
1392: oInputChoice 1410
1394: oGetParam 1
1396: oPushResult
1397: oSetResult 27
1399: oPushResult
1400: oSetResult 1
1402: oPushResult
1403: oNodeSetBoolean
1404: oPop 3
1406: oInput 6
1408: oJumpForward 1415
1410: Choice Lookup Table
          73   1394
1413: oJumpForward 1417
1415: oJumpBack 1392
1417: oReturn
1418: oLocalSpace 0
1420: oGetParam 1
1422: oPushResult
1423: oCall 13993
1425: oPop 1
1427: oPushResult
1428: equal_zero
1429: oPop 1
1431: oChoice 1437
1433: oError 23
1435: oJumpForward 1440
1437: Choice Lookup Table
           0   1433
1440: oGetParam 1
1442: oPushResult
1443: oSetResult 25
1445: oPushResult
1446: oSetResult 1
1448: oPushResult
1449: oNodeSetBoolean
1450: oPop 3
1452: oInputChoice 1476
1454: oInputChoice 1471
1456: oInput 3
1458: oGetParam 1
1460: oPushResult
1461: oSetResult 26
1463: oPushResult
1464: CURRENT_STRLIT
1465: oPushResult
1466: oNodeSetString
1467: oPop 3
1469: oJumpForward 1474
1471: Choice Lookup Table
          72   1456
1474: oJumpForward 1479
1476: Choice Lookup Table
           3   1454
1479: oGetParam 1
1481: oPushResult
1482: oCall 11607
1484: oPop 1
1486: oReturn
1487: oLocalSpace 6
1489: oInput 0
1491: oGetAddrLocal 1
1493: oPushResult
1494: oSetResult 0
1496: oAssign
1497: oGetAddrLocal 2
1499: oPushResult
1500: oScopeFindInCurrentScope
1501: oAssign
1502: oGetLocal 2
1504: oPushResult
1505: oNodeNull
1506: oPop 1
1508: oChoice 1626
1510: oGetAddrLocal 2
1512: oPushResult
1513: oSetResult 12
1515: oPushResult
1516: LAST_ID
1517: oPushResult
1518: oCall 14031
1520: oPop 2
1522: oAssign
1523: oGetLocal 2
1525: oPushResult
1526: oSetResult 22
1528: oPushResult
1529: oLabelNew
1530: oPushResult
1531: oNodeSetLabel
1532: oPop 3
1534: oJumpForward 1632
1536: oGetAddrLocal 1
1538: oPushResult
1539: oSetResult 1
1541: oAssign
1542: oGetLocal 2
1544: oPushResult
1545: oSetResult 24
1547: oPushResult
1548: oNodeGetBoolean
1549: oPop 2
1551: oChoice 1557
1553: oError 21
1555: oJumpForward 1560
1557: Choice Lookup Table
           1   1553
1560: oGetLocal 2
1562: oPushResult
1563: oSetResult 25
1565: oPushResult
1566: oNodeGetBoolean
1567: oPop 2
1569: oChoice 1575
1571: oError 21
1573: oJumpForward 1578
1575: Choice Lookup Table
           1   1571
1578: oGetLocal 2
1580: oPushResult
1581: oNodeType
1582: oPop 1
1584: oChoice 1588
1586: oJumpForward 1593
1588: Choice Lookup Table
          12   1586
1591: oError 21
1593: oGetLocal 2
1595: oPushResult
1596: oSetResult 29
1598: oPushResult
1599: oGetLocal 2
1601: oPushResult
1602: oSetResult 23
1604: oPushResult
1605: oNodeGet
1606: oPop 2
1608: oPushResult
1609: oNodeSet
1610: oPop 3
1612: oGetLocal 2
1614: oPushResult
1615: oSetResult 23
1617: oPushResult
1618: oSetResult 0
1620: oPushResult
1621: oNodeSet
1622: oPop 3
1624: oJumpForward 1632
1626: Choice Lookup Table
           0   1536
           1   1510
1631: oEndChoice
1632: oGetAddrLocal 3
1634: oPushResult
1635: oCall 13981
1637: oAssign
1638: oGetAddrLocal 4
1640: oPushResult
1641: oGetLocal 3
1643: oPushResult
1644: oSetResult 0
1646: oPushResult
1647: greater
1648: oPop 2
1650: oAssign
1651: oGetAddrLocal 3
1653: oPushResult
1654: inc
1655: oPop 1
1657: oGetLocal 3
1659: oPushResult
1660: oSetResult 2
1662: oPushResult
1663: oScopeBegin
1664: oPop 2
1666: oGetAddrLocal 5
1668: oPushResult
1669: oScopeCurrent
1670: oAssign
1671: oGetLocal 4
1673: oChoice 1692
1675: oGetAddrLocal 6
1677: oPushResult
1678: oGetGlobal 6
1680: oPushResult
1681: oCall 13078
1683: oPop 1
1685: oPushResult
1686: oScopeAllocType
1687: oPop 1
1689: oAssign
1690: oJumpForward 1695
1692: Choice Lookup Table
           1   1675
1695: oCall 2296
1697: oGetLocal 2
1699: oPushResult
1700: oSetResult 23
1702: oPushResult
1703: oGetLocal 5
1705: oPushResult
1706: oNodeSet
1707: oPop 3
1709: oScopeEnd
1710: oInput 6
1712: oGetLocal 1
1714: oChoice 1726
1716: oGetLocal 2
1718: oPushResult
1719: oScopeDeclare
1720: oPop 1
1722: oJumpForward 1732
1724: oJumpForward 1732
1726: Choice Lookup Table
           1   1724
           0   1716
1731: oEndChoice
1732: oGetLocal 2
1734: oPushResult
1735: oCall 1390
1737: oPop 1
1739: oGetLocal 2
1741: oReturn
1742: oReturn
1743: oLocalSpace 4
1745: oGetAddrLocal 1
1747: oPushResult
1748: oCall 1487
1750: oAssign
1751: oInputChoice 1764
1753: oJumpForward 1858
1755: oGetLocal 1
1757: oPushResult
1758: oCall 1418
1760: oPop 1
1762: oJumpForward 1858
1764: Choice Lookup Table
          71   1755
          70   1753
1769: oGetAddrLocal 2
1771: oPushResult
1772: oGetLocal 1
1774: oPushResult
1775: oSetResult 23
1777: oPushResult
1778: oNodeGet
1779: oPop 2
1781: oAssign
1782: oGetLocal 2
1784: oPushResult
1785: oScopeEnter
1786: oPop 1
1788: oGetAddrLocal 3
1790: oPushResult
1791: oGetLocal 2
1793: oPushResult
1794: oSetResult 14
1796: oPushResult
1797: oNodeGetInt
1798: oPop 2
1800: oAssign
1801: oGetLocal 3
1803: oPushResult
1804: oSetResult 1
1806: oPushResult
1807: oScopeBegin
1808: oPop 2
1810: oGetLocal 1
1812: oPushResult
1813: oSetResult 6
1815: oPushResult
1816: oScopeCurrent
1817: oPushResult
1818: oNodeSet
1819: oPop 3
1821: oGetAddrLocal 4
1823: oPushResult
1824: oGetLocal 1
1826: oPushResult
1827: oSetResult 22
1829: oPushResult
1830: oNodeGetLabel
1831: oPop 2
1833: oAssign
1834: oSetResult 22
1836: oPushResult
1837: oGetLocal 4
1839: oPushResult
1840: oCall 13656
1842: oPop 2
1844: oGetLocal 1
1846: oPushResult
1847: oSetResult 24
1849: oPushResult
1850: oSetResult 1
1852: oPushResult
1853: oNodeSetBoolean
1854: oPop 3
1856: oScopeEnd
1857: oScopeEnd
1858: oInput 6
1860: oReturn
1861: oLocalSpace 8
1863: oInput 0
1865: oGetAddrLocal 1
1867: oPushResult
1868: oSetResult 0
1870: oAssign
1871: oGetAddrLocal 2
1873: oPushResult
1874: oScopeFindInCurrentScope
1875: oAssign
1876: oGetLocal 2
1878: oPushResult
1879: oNodeNull
1880: oPop 1
1882: oChoice 2013
1884: oGetAddrLocal 2
1886: oPushResult
1887: oSetResult 13
1889: oPushResult
1890: LAST_ID
1891: oPushResult
1892: oCall 14031
1894: oPop 2
1896: oAssign
1897: oGetLocal 2
1899: oPushResult
1900: oSetResult 22
1902: oPushResult
1903: oLabelNew
1904: oPushResult
1905: oNodeSetLabel
1906: oPop 3
1908: oJumpForward 2019
1910: oGetAddrLocal 1
1912: oPushResult
1913: oSetResult 1
1915: oAssign
1916: oGetLocal 2
1918: oPushResult
1919: oSetResult 24
1921: oPushResult
1922: oNodeGetBoolean
1923: oPop 2
1925: oChoice 1931
1927: oError 21
1929: oJumpForward 1934
1931: Choice Lookup Table
           1   1927
1934: oGetLocal 2
1936: oPushResult
1937: oNodeType
1938: oPop 1
1940: oChoice 1944
1942: oJumpForward 1949
1944: Choice Lookup Table
          13   1942
1947: oError 21
1949: oGetLocal 2
1951: oPushResult
1952: oSetResult 29
1954: oPushResult
1955: oGetLocal 2
1957: oPushResult
1958: oSetResult 23
1960: oPushResult
1961: oNodeGet
1962: oPop 2
1964: oPushResult
1965: oNodeSet
1966: oPop 3
1968: oGetLocal 2
1970: oPushResult
1971: oSetResult 23
1973: oPushResult
1974: oSetResult 0
1976: oPushResult
1977: oNodeSet
1978: oPop 3
1980: oGetLocal 2
1982: oPushResult
1983: oSetResult 30
1985: oPushResult
1986: oGetLocal 2
1988: oPushResult
1989: oSetResult 21
1991: oPushResult
1992: oNodeGet
1993: oPop 2
1995: oPushResult
1996: oNodeSet
1997: oPop 3
1999: oGetLocal 2
2001: oPushResult
2002: oSetResult 21
2004: oPushResult
2005: oSetResult 0
2007: oPushResult
2008: oNodeSet
2009: oPop 3
2011: oJumpForward 2019
2013: Choice Lookup Table
           0   1910
           1   1884
2018: oEndChoice
2019: oGetAddrLocal 3
2021: oPushResult
2022: oCall 13981
2024: oAssign
2025: oGetAddrLocal 4
2027: oPushResult
2028: oGetLocal 3
2030: oPushResult
2031: oSetResult 0
2033: oPushResult
2034: greater
2035: oPop 2
2037: oAssign
2038: oGetAddrLocal 3
2040: oPushResult
2041: inc
2042: oPop 1
2044: oGetLocal 3
2046: oPushResult
2047: oSetResult 2
2049: oPushResult
2050: oScopeBegin
2051: oPop 2
2053: oGetAddrLocal 5
2055: oPushResult
2056: oScopeCurrent
2057: oAssign
2058: oGetLocal 4
2060: oChoice 2079
2062: oGetAddrLocal 6
2064: oPushResult
2065: oGetGlobal 6
2067: oPushResult
2068: oCall 13078
2070: oPop 1
2072: oPushResult
2073: oScopeAllocType
2074: oPop 1
2076: oAssign
2077: oJumpForward 2082
2079: Choice Lookup Table
           1   2062
2082: oCall 2296
2084: oGetLocal 2
2086: oPushResult
2087: oSetResult 23
2089: oPushResult
2090: oGetLocal 5
2092: oPushResult
2093: oNodeSet
2094: oPop 3
2096: oInput 13
2098: oGetAddrLocal 7
2100: oPushResult
2101: oCall 11999
2103: oPop 1
2105: oGetLocal 2
2107: oPushResult
2108: oSetResult 21
2110: oPushResult
2111: oGetLocal 7
2113: oPushResult
2114: oNodeSet
2115: oPop 3
2117: oGetAddrLocal 8
2119: oPushResult
2120: oGetLocal 7
2122: oPushResult
2123: oCall 13078
2125: oPop 1
2127: oAssign
2128: oGetLocal 2
2130: oPushResult
2131: oSetResult 31
2133: oPushResult
2134: oGetLocal 8
2136: oPushResult
2137: oScopeAllocType
2138: oPop 1
2140: oPushResult
2141: oNodeSetInt
2142: oPop 3
2144: oScopeEnd
2145: oInput 6
2147: oGetLocal 1
2149: oChoice 2161
2151: oGetLocal 2
2153: oPushResult
2154: oScopeDeclare
2155: oPop 1
2157: oJumpForward 2167
2159: oJumpForward 2167
2161: Choice Lookup Table
           1   2159
           0   2151
2166: oEndChoice
2167: oGetLocal 2
2169: oPushResult
2170: oCall 1390
2172: oPop 1
2174: oGetLocal 2
2176: oReturn
2177: oReturn
2178: oLocalSpace 4
2180: oGetAddrLocal 1
2182: oPushResult
2183: oCall 1861
2185: oAssign
2186: oInputChoice 2199
2188: oJumpForward 2293
2190: oGetLocal 1
2192: oPushResult
2193: oCall 1418
2195: oPop 1
2197: oJumpForward 2293
2199: Choice Lookup Table
          71   2190
          70   2188
2204: oGetAddrLocal 2
2206: oPushResult
2207: oGetLocal 1
2209: oPushResult
2210: oSetResult 23
2212: oPushResult
2213: oNodeGet
2214: oPop 2
2216: oAssign
2217: oGetLocal 2
2219: oPushResult
2220: oScopeEnter
2221: oPop 1
2223: oGetAddrLocal 3
2225: oPushResult
2226: oGetLocal 2
2228: oPushResult
2229: oSetResult 14
2231: oPushResult
2232: oNodeGetInt
2233: oPop 2
2235: oAssign
2236: oGetLocal 3
2238: oPushResult
2239: oSetResult 1
2241: oPushResult
2242: oScopeBegin
2243: oPop 2
2245: oGetLocal 1
2247: oPushResult
2248: oSetResult 6
2250: oPushResult
2251: oScopeCurrent
2252: oPushResult
2253: oNodeSet
2254: oPop 3
2256: oGetAddrLocal 4
2258: oPushResult
2259: oGetLocal 1
2261: oPushResult
2262: oSetResult 22
2264: oPushResult
2265: oNodeGetLabel
2266: oPop 2
2268: oAssign
2269: oSetResult 22
2271: oPushResult
2272: oGetLocal 4
2274: oPushResult
2275: oCall 13656
2277: oPop 2
2279: oGetLocal 1
2281: oPushResult
2282: oSetResult 24
2284: oPushResult
2285: oSetResult 1
2287: oPushResult
2288: oNodeSetBoolean
2289: oPop 3
2291: oScopeEnd
2292: oScopeEnd
2293: oInput 6
2295: oReturn
2296: oLocalSpace 6
2298: oInputChoice 2516
2300: oGetAddrLocal 1
2302: oPushResult
2303: oNodeVecNew
2304: oAssign
2305: oGetAddrLocal 3
2307: oPushResult
2308: oSetResult 0
2310: oAssign
2311: oInputChoice 2321
2313: oGetAddrLocal 3
2315: oPushResult
2316: oSetResult 1
2318: oAssign
2319: oJumpForward 2324
2321: Choice Lookup Table
          34   2313
2324: oInput 0
2326: oGetAddrLocal 2
2328: oPushResult
2329: oSetResult 24
2331: oPushResult
2332: LAST_ID
2333: oPushResult
2334: oCall 14031
2336: oPop 2
2338: oAssign
2339: oGetLocal 2
2341: oPushResult
2342: oSetResult 34
2344: oPushResult
2345: oGetLocal 3
2347: oPushResult
2348: oNodeSetBoolean
2349: oPop 3
2351: oGetLocal 1
2353: oPushResult
2354: oGetLocal 2
2356: oPushResult
2357: oNodeVecAppend
2358: oPop 2
2360: oInputChoice 2368
2362: oJumpForward 2376
2364: oJumpForward 2374
2366: oJumpForward 2374
2368: Choice Lookup Table
          14   2366
          13   2362
2373: oEndChoice
2374: oJumpBack 2324
2376: oGetAddrLocal 4
2378: oPushResult
2379: oCall 11999
2381: oPop 1
2383: oGetLocal 3
2385: oChoice 2400
2387: oGetAddrLocal 5
2389: oPushResult
2390: oGetLocal 4
2392: oPushResult
2393: oCall 13078
2395: oPop 1
2397: oAssign
2398: oJumpForward 2409
2400: Choice Lookup Table
           1   2387
2403: oGetAddrLocal 5
2405: oPushResult
2406: oGetLocal 4
2408: oAssign
2409: oGetAddrLocal 6
2411: oPushResult
2412: oSetResult 0
2414: oAssign
2415: oGetLocal 6
2417: oPushResult
2418: oGetLocal 1
2420: oPushResult
2421: oNodeVecSize
2422: oPop 1
2424: oPushResult
2425: equal
2426: oPop 2
2428: oChoice 2485
2430: oGetAddrLocal 2
2432: oPushResult
2433: oGetLocal 1
2435: oPushResult
2436: oGetLocal 6
2438: oPushResult
2439: oNodeVecElement
2440: oPop 2
2442: oAssign
2443: oGetLocal 2
2445: oPushResult
2446: oSetResult 21
2448: oPushResult
2449: oGetLocal 4
2451: oPushResult
2452: oNodeSet
2453: oPop 3
2455: oGetLocal 2
2457: oPushResult
2458: oScopeDeclare
2459: oPop 1
2461: oGetLocal 2
2463: oPushResult
2464: oSetResult 22
2466: oPushResult
2467: oGetLocal 5
2469: oPushResult
2470: oScopeAllocType
2471: oPop 1
2473: oPushResult
2474: oNodeSetInt
2475: oPop 3
2477: oGetAddrLocal 6
2479: oPushResult
2480: inc
2481: oPop 1
2483: oJumpForward 2490
2485: Choice Lookup Table
           0   2430
2488: oJumpForward 2492
2490: oJumpBack 2415
2492: oGetLocal 1
2494: oPushResult
2495: oNodeVecDelete
2496: oPop 1
2498: oInputChoice 2506
2500: oJumpForward 2514
2502: oJumpForward 2512
2504: oJumpForward 2512
2506: Choice Lookup Table
           6   2504
          16   2500
2511: oEndChoice
2512: oJumpBack 2300
2514: oJumpForward 2519
2516: Choice Lookup Table
          15   2300
2519: oReturn
2520: oLocalSpace 0
2522: oInputChoice 2537
2524: oInputChoice 2530
2526: oCall 2654
2528: oJumpForward 2535
2530: Choice Lookup Table
          13   2526
2533: oCall 2545
2535: oJumpForward 2542
2537: Choice Lookup Table
           0   2524
2540: oJumpForward 2544
2542: oJumpBack 2522
2544: oReturn
2545: oLocalSpace 2
2547: oGetAddrLocal 1
2549: oPushResult
2550: LAST_ID
2551: oAssign
2552: oInput 7
2554: oCall 3539
2556: oTypeSNodeType
2557: oChoice 2613
2559: oGetAddrLocal 2
2561: oPushResult
2562: oSetResult 16
2564: oPushResult
2565: oGetLocal 1
2567: oPushResult
2568: oCall 14031
2570: oPop 2
2572: oAssign
2573: oGetLocal 2
2575: oPushResult
2576: oSetResult 22
2578: oPushResult
2579: oValueTop
2580: oPushResult
2581: oNodeSetInt
2582: oPop 3
2584: oJumpForward 2632
2586: oGetAddrLocal 2
2588: oPushResult
2589: oSetResult 18
2591: oPushResult
2592: oGetLocal 1
2594: oPushResult
2595: oCall 14031
2597: oPop 2
2599: oAssign
2600: oGetLocal 2
2602: oPushResult
2603: oSetResult 33
2605: oPushResult
2606: oValueTopString
2607: oPushResult
2608: oNodeSetString
2609: oPop 3
2611: oJumpForward 2632
2613: Choice Lookup Table
          41   2586
          37   2559
          36   2559
          43   2559
          30   2559
          35   2559
          29   2559
          33   2559
2630: oError 17
2632: oValuePop
2633: oGetLocal 2
2635: oPushResult
2636: oSetResult 21
2638: oPushResult
2639: oTypeSTop
2640: oPushResult
2641: oNodeSet
2642: oPop 3
2644: oTypeSPop
2645: oGetLocal 2
2647: oPushResult
2648: oScopeDeclare
2649: oPop 1
2651: oInput 6
2653: oReturn
2654: oLocalSpace 3
2656: oGetAddrLocal 1
2658: oPushResult
2659: oSetResult 25
2661: oPushResult
2662: LAST_ID
2663: oPushResult
2664: oCall 14031
2666: oPop 2
2668: oAssign
2669: oGetAddrLocal 2
2671: oPushResult
2672: oCall 11999
2674: oPop 1
2676: oGetLocal 1
2678: oPushResult
2679: oSetResult 21
2681: oPushResult
2682: oGetLocal 2
2684: oPushResult
2685: oNodeSet
2686: oPop 3
2688: oGetLocal 2
2690: oPushResult
2691: oNodeType
2692: oPop 1
2694: oChoice 2798
2696: oInput 7
2698: oGetLocal 2
2700: oPushResult
2701: oTypeSPush
2702: oPop 1
2704: oCall 3539
2706: oCall 4351
2708: oGetLocal 1
2710: oPushResult
2711: oSetResult 22
2713: oPushResult
2714: oValueTop
2715: oPushResult
2716: oNodeSetInt
2717: oPop 3
2719: oValuePop
2720: oTypeSPop
2721: oGetLocal 1
2723: oPushResult
2724: oScopeDeclare
2725: oPop 1
2727: oInput 6
2729: oJumpForward 2822
2731: oError 16
2733: oJumpForward 2822
2735: oGetGlobal 2
2737: oPushResult
2738: oScopeEnter
2739: oPop 1
2741: oGetAddrLocal 3
2743: oPushResult
2744: oGetLocal 2
2746: oPushResult
2747: oScopeAllocType
2748: oPop 1
2750: oAssign
2751: oScopeEnd
2752: oGetGlobal 2
2754: oPushResult
2755: oCall 13929
2757: oPop 1
2759: oPushResult
2760: oCodePush
2761: oPop 1
2763: oGetLocal 1
2765: oPushResult
2766: oSetResult 22
2768: oPushResult
2769: oGetLocal 3
2771: oPushResult
2772: oNodeSetInt
2773: oPop 3
2775: oInput 7
2777: oGetLocal 2
2779: oPushResult
2780: oGetLocal 3
2782: oPushResult
2783: oCall 2823
2785: oPop 2
2787: oCodePop
2788: oGetLocal 1
2790: oPushResult
2791: oScopeDeclare
2792: oPop 1
2794: oInput 6
2796: oJumpForward 2822
2798: Choice Lookup Table
          40   2735
          38   2735
          28   2731
          42   2731
          37   2696
          36   2696
          43   2696
          30   2696
          35   2696
          29   2696
          33   2696
2821: oEndChoice
2822: oReturn
2823: oLocalSpace 10
2825: oGetParam 2
2827: oPushResult
2828: oNodeType
2829: oPop 1
2831: oChoice 3157
2833: oGetAddrLocal 1
2835: oPushResult
2836: oGetParam 2
2838: oPushResult
2839: oSetResult 37
2841: oPushResult
2842: oNodeGet
2843: oPop 2
2845: oAssign
2846: oGetAddrLocal 2
2848: oPushResult
2849: oGetParam 2
2851: oPushResult
2852: oSetResult 38
2854: oPushResult
2855: oNodeGet
2856: oPop 2
2858: oAssign
2859: oGetAddrLocal 3
2861: oPushResult
2862: oGetLocal 2
2864: oPushResult
2865: oCall 13162
2867: oPop 1
2869: oAssign
2870: oGetAddrLocal 4
2872: oPushResult
2873: oGetLocal 2
2875: oPushResult
2876: oCall 13257
2878: oPop 1
2880: oAssign
2881: oGetAddrLocal 5
2883: oPushResult
2884: oGetLocal 1
2886: oPushResult
2887: oSetResult 17
2889: oPushResult
2890: oNodeGetInt
2891: oPop 2
2893: oAssign
2894: oInput 15
2896: oGetAddrLocal 6
2898: oPushResult
2899: oGetLocal 3
2901: oAssign
2902: oGetLocal 1
2904: oPushResult
2905: oGetParam 1
2907: oPushResult
2908: oCall 2823
2910: oPop 2
2912: oGetLocal 6
2914: oPushResult
2915: oGetLocal 4
2917: oPushResult
2918: equal
2919: oPop 2
2921: oChoice 2929
2923: oJumpForward 2958
2925: oJumpForward 2935
2927: oJumpForward 2935
2929: Choice Lookup Table
           0   2927
           1   2923
2934: oEndChoice
2935: oInput 14
2937: oGetAddrParam 1
2939: oPushResult
2940: oGetParam 1
2942: oPushResult
2943: oGetLocal 5
2945: oPushResult
2946: add
2947: oPop 2
2949: oAssign
2950: oGetAddrLocal 6
2952: oPushResult
2953: inc
2954: oPop 1
2956: oJumpBack 2902
2958: oInput 16
2960: oJumpForward 3183
2962: oInput 15
2964: oGetAddrLocal 7
2966: oPushResult
2967: oGetParam 2
2969: oPushResult
2970: oSetResult 41
2972: oPushResult
2973: oNodeGet
2974: oPop 2
2976: oAssign
2977: oInputChoice 2981
2979: oJumpForward 2986
2981: Choice Lookup Table
           0   2979
2984: oJumpForward 3052
2986: oGetAddrLocal 8
2988: oPushResult
2989: oGetLocal 7
2991: oPushResult
2992: oScopeFindRequireInScope
2993: oPop 1
2995: oAssign
2996: oInput 13
2998: oGetAddrLocal 9
3000: oPushResult
3001: oGetLocal 8
3003: oPushResult
3004: oSetResult 21
3006: oPushResult
3007: oNodeGet
3008: oPop 2
3010: oAssign
3011: oGetAddrLocal 10
3013: oPushResult
3014: oGetParam 1
3016: oPushResult
3017: oGetLocal 8
3019: oPushResult
3020: oSetResult 22
3022: oPushResult
3023: oNodeGetInt
3024: oPop 2
3026: oPushResult
3027: add
3028: oPop 2
3030: oAssign
3031: oGetLocal 9
3033: oPushResult
3034: oGetLocal 10
3036: oPushResult
3037: oCall 2823
3039: oPop 2
3041: oInputChoice 3045
3043: oJumpForward 3050
3045: Choice Lookup Table
           6   3043
3048: oJumpForward 3052
3050: oJumpBack 2977
3052: oInput 16
3054: oJumpForward 3183
3056: oEmit 17
3058: oGetParam 1
3060: oPushResult
3061: oEmitInt
3062: oPop 1
3064: oGetParam 2
3066: oPushResult
3067: oTypeSPush
3068: oPop 1
3070: oCall 3539
3072: oCall 4351
3074: oEmit 15
3076: oValueTop
3077: oPushResult
3078: oEmitInt
3079: oPop 1
3081: oValuePop
3082: oTypeSPop
3083: oEmit 28
3085: oJumpForward 3183
3087: oEmit 17
3089: oGetParam 1
3091: oPushResult
3092: oEmitInt
3093: oPop 1
3095: oGetParam 2
3097: oPushResult
3098: oTypeSPush
3099: oPop 1
3101: oCall 3539
3103: oCall 4351
3105: oEmit 15
3107: oValueTop
3108: oPushResult
3109: oEmitInt
3110: oPop 1
3112: oValuePop
3113: oTypeSPop
3114: oEmit 27
3116: oJumpForward 3183
3118: oError 16
3120: oJumpForward 3183
3122: oEmit 17
3124: oGetParam 1
3126: oPushResult
3127: oEmitInt
3128: oPop 1
3130: oGetParam 2
3132: oPushResult
3133: oTypeSPush
3134: oPop 1
3136: oCall 3539
3138: oCall 4351
3140: oEmit 15
3142: oValueTop
3143: oPushResult
3144: oEmitInt
3145: oPop 1
3147: oValuePop
3148: oTypeSPop
3149: oEmit 29
3151: oJumpForward 3183
3153: oError 16
3155: oJumpForward 3183
3157: Choice Lookup Table
          28   3153
          42   3153
          37   3122
          36   3122
          32   3118
          43   3087
          30   3087
          35   3056
          29   3056
          33   3056
          40   2962
          38   2833
3182: oEndChoice
3183: oReturn
3184: oLocalSpace 2
3186: oInputChoice 3232
3188: oGetAddrLocal 1
3190: oPushResult
3191: oSetResult 19
3193: oPushResult
3194: LAST_ID
3195: oPushResult
3196: oCall 14031
3198: oPop 2
3200: oAssign
3201: oInput 7
3203: oGetAddrLocal 2
3205: oPushResult
3206: oCall 11999
3208: oPop 1
3210: oGetLocal 1
3212: oPushResult
3213: oSetResult 21
3215: oPushResult
3216: oGetLocal 2
3218: oPushResult
3219: oNodeSet
3220: oPop 3
3222: oGetLocal 1
3224: oPushResult
3225: oScopeDeclare
3226: oPop 1
3228: oInput 6
3230: oJumpForward 3237
3232: Choice Lookup Table
           0   3188
3235: oJumpForward 3239
3237: oJumpBack 3186
3239: oReturn
3240: oLocalSpace 6
3242: oInputChoice 3466
3244: oGetAddrLocal 1
3246: oPushResult
3247: oNodeVecNew
3248: oAssign
3249: oGetAddrLocal 2
3251: oPushResult
3252: oGetParam 1
3254: oPushResult
3255: LAST_ID
3256: oPushResult
3257: oCall 14031
3259: oPop 2
3261: oAssign
3262: oGetLocal 1
3264: oPushResult
3265: oGetLocal 2
3267: oPushResult
3268: oNodeVecAppend
3269: oPop 2
3271: oInputChoice 3277
3273: oInput 0
3275: oJumpForward 3282
3277: Choice Lookup Table
          14   3273
3280: oJumpForward 3284
3282: oJumpBack 3249
3284: oInput 13
3286: oGetAddrLocal 3
3288: oPushResult
3289: oCall 11999
3291: oPop 1
3293: oGetAddrLocal 4
3295: oPushResult
3296: oSetResult 0
3298: oAssign
3299: oGetLocal 4
3301: oPushResult
3302: oGetLocal 1
3304: oPushResult
3305: oNodeVecSize
3306: oPop 1
3308: oPushResult
3309: equal
3310: oPop 2
3312: oChoice 3353
3314: oGetAddrLocal 2
3316: oPushResult
3317: oGetLocal 1
3319: oPushResult
3320: oGetLocal 4
3322: oPushResult
3323: oNodeVecElement
3324: oPop 2
3326: oAssign
3327: oGetLocal 2
3329: oPushResult
3330: oSetResult 21
3332: oPushResult
3333: oGetLocal 3
3335: oPushResult
3336: oNodeSet
3337: oPop 3
3339: oGetLocal 2
3341: oPushResult
3342: oScopeDeclareAlloc
3343: oPop 1
3345: oGetAddrLocal 4
3347: oPushResult
3348: inc
3349: oPop 1
3351: oJumpForward 3358
3353: Choice Lookup Table
           0   3314
3356: oJumpForward 3360
3358: oJumpBack 3299
3360: oInputChoice 3453
3362: oGetLocal 1
3364: oPushResult
3365: oNodeVecSize
3366: oPop 1
3368: oChoice 3372
3370: oJumpForward 3377
3372: Choice Lookup Table
           1   3370
3375: oError 22
3377: oGetAddrLocal 5
3379: oPushResult
3380: oScopeCurrent
3381: oPushResult
3382: oCall 13929
3384: oPop 1
3386: oAssign
3387: oGetLocal 5
3389: oPushResult
3390: oCodePush
3391: oPop 1
3393: oGetAddrLocal 6
3395: oPushResult
3396: oSetResult 0
3398: oAssign
3399: oCall 13981
3401: oPushResult
3402: equal_zero
3403: oPop 1
3405: oChoice 3421
3407: oGetGlobal 3
3409: oPushResult
3410: oScopeEnter
3411: oPop 1
3413: oGetAddrLocal 6
3415: oPushResult
3416: oSetResult 1
3418: oAssign
3419: oJumpForward 3424
3421: Choice Lookup Table
           1   3407
3424: oGetLocal 2
3426: oPushResult
3427: oSetResult 1
3429: oPushResult
3430: oCall 9442
3432: oPop 2
3434: oCall 4887
3436: oCall 8229
3438: oCall 8990
3440: oGetLocal 6
3442: oChoice 3447
3444: oScopeEnd
3445: oJumpForward 3450
3447: Choice Lookup Table
           1   3444
3450: oCodePop
3451: oJumpForward 3456
3453: Choice Lookup Table
           7   3362
3456: oGetLocal 1
3458: oPushResult
3459: oNodeVecDelete
3460: oPop 1
3462: oInput 6
3464: oJumpForward 3471
3466: Choice Lookup Table
           0   3244
3469: oJumpForward 3473
3471: oJumpBack 3242
3473: oReturn
3474: oLocalSpace 2
3476: oInputChoice 3483
3478: oJumpForward 3489
3480: oChangeIntLitToLabelIdent
3481: oJumpForward 3489
3483: Choice Lookup Table
           1   3480
           0   3478
3488: oEndChoice
3489: oGetAddrLocal 1
3491: oPushResult
3492: oSetResult 26
3494: oPushResult
3495: LAST_ID
3496: oPushResult
3497: oCall 14031
3499: oPop 2
3501: oAssign
3502: oGetAddrLocal 2
3504: oPushResult
3505: oLabelNew
3506: oAssign
3507: oGetLocal 1
3509: oPushResult
3510: oSetResult 22
3512: oPushResult
3513: oGetLocal 2
3515: oPushResult
3516: oNodeSetLabel
3517: oPop 3
3519: oGetLocal 1
3521: oPushResult
3522: oScopeDeclare
3523: oPop 1
3525: oInputChoice 3529
3527: oJumpForward 3534
3529: Choice Lookup Table
          14   3527
3532: oJumpForward 3536
3534: oJumpBack 3476
3536: oInput 6
3538: oReturn
3539: oLocalSpace 0
3541: oCall 3766
3543: oInputChoice 3725
3545: oCall 3789
3547: oCall 4254
3549: oTypeSNodeType
3550: oChoice 3562
3552: oValueStringCmp
3553: oSetResult 0
3555: oPushResult
3556: oValuePush
3557: oPop 1
3559: oValueEqual
3560: oJumpForward 3566
3562: Choice Lookup Table
          41   3552
3565: oValueEqual
3566: oTypeSPop
3567: oGetGlobal 7
3569: oPushResult
3570: oTypeSPush
3571: oPop 1
3573: oJumpForward 3740
3575: oCall 3766
3577: oCall 4254
3579: oTypeSNodeType
3580: oChoice 3592
3582: oValueStringCmp
3583: oSetResult 0
3585: oPushResult
3586: oValuePush
3587: oPop 1
3589: oValueNotEqual
3590: oJumpForward 3596
3592: Choice Lookup Table
          41   3582
3595: oValueNotEqual
3596: oTypeSPop
3597: oGetGlobal 7
3599: oPushResult
3600: oTypeSPush
3601: oPop 1
3603: oJumpForward 3740
3605: oCall 3766
3607: oCall 4254
3609: oTypeSNodeType
3610: oChoice 3622
3612: oValueStringCmp
3613: oSetResult 0
3615: oPushResult
3616: oValuePush
3617: oPop 1
3619: oValueLess
3620: oJumpForward 3626
3622: Choice Lookup Table
          41   3612
3625: oValueLess
3626: oTypeSPop
3627: oGetGlobal 7
3629: oPushResult
3630: oTypeSPush
3631: oPop 1
3633: oJumpForward 3740
3635: oCall 3766
3637: oCall 4254
3639: oTypeSNodeType
3640: oChoice 3652
3642: oValueStringCmp
3643: oSetResult 0
3645: oPushResult
3646: oValuePush
3647: oPop 1
3649: oValueGreater
3650: oJumpForward 3656
3652: Choice Lookup Table
          41   3642
3655: oValueGreater
3656: oTypeSPop
3657: oGetGlobal 7
3659: oPushResult
3660: oTypeSPush
3661: oPop 1
3663: oJumpForward 3740
3665: oCall 3766
3667: oCall 4254
3669: oTypeSNodeType
3670: oChoice 3682
3672: oValueStringCmp
3673: oSetResult 0
3675: oPushResult
3676: oValuePush
3677: oPop 1
3679: oValueLessEqual
3680: oJumpForward 3686
3682: Choice Lookup Table
          41   3672
3685: oValueLessEqual
3686: oTypeSPop
3687: oGetGlobal 7
3689: oPushResult
3690: oTypeSPush
3691: oPop 1
3693: oJumpForward 3740
3695: oCall 3766
3697: oCall 4254
3699: oTypeSNodeType
3700: oChoice 3712
3702: oValueStringCmp
3703: oSetResult 0
3705: oPushResult
3706: oValuePush
3707: oPop 1
3709: oValueGreaterEqual
3710: oJumpForward 3716
3712: Choice Lookup Table
          41   3702
3715: oValueGreaterEqual
3716: oTypeSPop
3717: oGetGlobal 7
3719: oPushResult
3720: oTypeSPush
3721: oPop 1
3723: oJumpForward 3740
3725: Choice Lookup Table
          12   3695
          11   3665
          10   3635
           9   3605
           8   3575
           7   3545
3738: oJumpForward 3742
3740: oJumpBack 3543
3742: oReturn
3743: oLocalSpace 1
3745: oGetAddrLocal 1
3747: oPushResult
3748: oGetGlobal 25
3750: oAssign
3751: oGetAddrGlobal 25
3753: oPushResult
3754: oSetResult 1
3756: oAssign
3757: oCall 3539
3759: oGetAddrGlobal 25
3761: oPushResult
3762: oGetLocal 1
3764: oAssign
3765: oReturn
3766: oLocalSpace 0
3768: oCall 3789
3770: oInputChoice 3781
3772: oCall 4241
3774: oCall 3789
3776: oCall 4227
3778: oValueOr
3779: oJumpForward 3786
3781: Choice Lookup Table
          58   3772
3784: oJumpForward 3788
3786: oJumpBack 3770
3788: oReturn
3789: oLocalSpace 0
3791: oCall 3812
3793: oInputChoice 3804
3795: oCall 4241
3797: oCall 3812
3799: oCall 4227
3801: oValueAnd
3802: oJumpForward 3809
3804: Choice Lookup Table
          57   3795
3807: oJumpForward 3811
3809: oJumpBack 3793
3811: oReturn
3812: oLocalSpace 0
3814: oInputChoice 3823
3816: oCall 3812
3818: oCall 4241
3820: oValueNot
3821: oJumpForward 3828
3823: Choice Lookup Table
          59   3816
3826: oCall 3829
3828: oReturn
3829: oLocalSpace 0
3831: oCall 3878
3833: oInputChoice 3868
3835: oCall 3878
3837: oCall 4254
3839: oTypeSNodeType
3840: oChoice 3845
3842: oValueStringConcat
3843: oJumpForward 3849
3845: Choice Lookup Table
          41   3842
3848: oValueAdd
3849: oJumpForward 3875
3851: oCall 3878
3853: oCall 4254
3855: oTypeSNodeType
3856: oChoice 3862
3858: oError 17
3860: oJumpForward 3866
3862: Choice Lookup Table
          41   3858
3865: oValueSub
3866: oJumpForward 3875
3868: Choice Lookup Table
          26   3851
          25   3835
3873: oJumpForward 3877
3875: oJumpBack 3833
3877: oReturn
3878: oLocalSpace 0
3880: oCall 3928
3882: oInputChoice 3918
3884: oCall 3928
3886: oCall 4254
3888: oTypeSNodeType
3889: oChoice 3895
3891: oError 17
3893: oJumpForward 3899
3895: Choice Lookup Table
          41   3891
3898: oValueMult
3899: oJumpForward 3925
3901: oCall 3928
3903: oCall 4254
3905: oTypeSNodeType
3906: oChoice 3912
3908: oError 17
3910: oJumpForward 3916
3912: Choice Lookup Table
          41   3908
3915: oValueDiv
3916: oJumpForward 3925
3918: Choice Lookup Table
          24   3901
          23   3884
3923: oJumpForward 3927
3925: oJumpBack 3882
3927: oReturn
3928: oLocalSpace 0
3930: oInputChoice 3941
3932: oCall 3949
3934: oJumpForward 3948
3936: oCall 3949
3938: oValueNegate
3939: oJumpForward 3948
3941: Choice Lookup Table
          26   3936
          25   3932
3946: oCall 3949
3948: oReturn
3949: oLocalSpace 1
3951: oInputChoice 4199
3953: TOKEN_VALUE
3954: oPushResult
3955: oValuePush
3956: oPop 1
3958: oGetGlobal 6
3960: oPushResult
3961: oTypeSPush
3962: oPop 1
3964: oJumpForward 4226
3966: TOKEN_VALUE
3967: oPushResult
3968: oValuePush
3969: oPop 1
3971: oGetGlobal 9
3973: oPushResult
3974: oTypeSPush
3975: oPop 1
3977: oJumpForward 4226
3979: CURRENT_STRLIT
3980: oPushResult
3981: oValuePushString
3982: oPop 1
3984: oGetGlobal 15
3986: oPushResult
3987: oTypeSPush
3988: oPop 1
3990: oJumpForward 4226
3992: oCall 3539
3994: oInput 16
3996: oJumpForward 4226
3998: oGetAddrLocal 1
4000: oPushResult
4001: oScopeFindRequire
4002: oAssign
4003: oGetAddrLocal 1
4005: oPushResult
4006: oCall 244
4008: oPop 1
4010: oGetLocal 1
4012: oPushResult
4013: oNodeType
4014: oPop 1
4016: oChoice 4156
4018: oGetLocal 1
4020: oPushResult
4021: oCall 4621
4023: oPop 1
4025: oJumpForward 4181
4027: oGetLocal 1
4029: oPushResult
4030: oSetResult 22
4032: oPushResult
4033: oNodeGetInt
4034: oPop 2
4036: oPushResult
4037: oValuePush
4038: oPop 1
4040: oGetLocal 1
4042: oPushResult
4043: oSetResult 21
4045: oPushResult
4046: oNodeGet
4047: oPop 2
4049: oPushResult
4050: oTypeSPush
4051: oPop 1
4053: oJumpForward 4181
4055: oGetLocal 1
4057: oPushResult
4058: oSetResult 33
4060: oPushResult
4061: oNodeGetString
4062: oPop 2
4064: oPushResult
4065: oValuePushString
4066: oPop 1
4068: oGetLocal 1
4070: oPushResult
4071: oSetResult 21
4073: oPushResult
4074: oNodeGet
4075: oPop 2
4077: oPushResult
4078: oTypeSPush
4079: oPop 1
4081: oJumpForward 4181
4083: oGetLocal 1
4085: oPushResult
4086: oSetResult 22
4088: oPushResult
4089: oNodeGetInt
4090: oPop 2
4092: oPushResult
4093: oValuePush
4094: oPop 1
4096: oGetLocal 1
4098: oPushResult
4099: oSetResult 21
4101: oPushResult
4102: oNodeGet
4103: oPop 2
4105: oPushResult
4106: oTypeSPush
4107: oPop 1
4109: oJumpForward 4181
4111: oGetLocal 1
4113: oPushResult
4114: oSetResult 21
4116: oPushResult
4117: oNodeGet
4118: oPop 2
4120: oPushResult
4121: oTypeSPush
4122: oPop 1
4124: oInputChoice 4134
4126: oCall 3539
4128: oInput 16
4130: oCall 4472
4132: oJumpForward 4154
4134: Choice Lookup Table
          15   4126
4137: oGetGlobal 25
4139: oChoice 4149
4141: oSetResult 0
4143: oPushResult
4144: oValuePush
4145: oPop 1
4147: oJumpForward 4154
4149: Choice Lookup Table
           1   4141
4152: oError 31
4154: oJumpForward 4181
4156: Choice Lookup Table
          19   4111
          17   4083
          18   4055
          16   4027
          14   4018
4167: oError 1
4169: oSetResult 0
4171: oPushResult
4172: oValuePush
4173: oPop 1
4175: oGetGlobal 6
4177: oPushResult
4178: oTypeSPush
4179: oPop 1
4181: oJumpForward 4226
4183: oError 16
4185: oSetResult 0
4187: oPushResult
4188: oValuePush
4189: oPop 1
4191: oGetGlobal 14
4193: oPushResult
4194: oTypeSPush
4195: oPop 1
4197: oJumpForward 4226
4199: Choice Lookup Table
          20   4183
           0   3998
          15   3992
           3   3979
           4   3966
           1   3953
4212: oError 1
4214: oSetResult 0
4216: oPushResult
4217: oValuePush
4218: oPop 1
4220: oGetGlobal 6
4222: oPushResult
4223: oTypeSPush
4224: oPop 1
4226: oReturn
4227: oLocalSpace 0
4229: oTypeSNodeType
4230: oChoice 4234
4232: oJumpForward 4239
4234: Choice Lookup Table
          33   4232
4237: oError 8
4239: oTypeSPop
4240: oReturn
4241: oLocalSpace 0
4243: oTypeSNodeType
4244: oChoice 4248
4246: oJumpForward 4253
4248: Choice Lookup Table
          33   4246
4251: oError 8
4253: oReturn
4254: oLocalSpace 1
4256: oGetAddrLocal 1
4258: oPushResult
4259: oTypeSNodeType
4260: oAssign
4261: oTypeSPop
4262: oGetLocal 1
4264: oPushResult
4265: oTypeSNodeType
4266: oPushResult
4267: equal_node_type
4268: oPop 2
4270: oChoice 4347
4272: oTypeSNodeType
4273: oChoice 4334
4275: oGetLocal 1
4277: oChoice 4282
4279: oReturn
4280: oJumpForward 4285
4282: Choice Lookup Table
          37   4279
4285: oJumpForward 4343
4287: oGetLocal 1
4289: oChoice 4294
4291: oReturn
4292: oJumpForward 4297
4294: Choice Lookup Table
          36   4291
4297: oJumpForward 4343
4299: oGetLocal 1
4301: oChoice 4307
4303: oValueCharToString
4304: oReturn
4305: oJumpForward 4310
4307: Choice Lookup Table
          35   4303
4310: oJumpForward 4343
4312: oGetLocal 1
4314: oChoice 4329
4316: oValueSwap
4317: oValueCharToString
4318: oValueSwap
4319: oTypeSPop
4320: oGetGlobal 15
4322: oPushResult
4323: oTypeSPush
4324: oPop 1
4326: oReturn
4327: oJumpForward 4332
4329: Choice Lookup Table
          41   4316
4332: oJumpForward 4343
4334: Choice Lookup Table
          35   4312
          41   4299
          37   4287
          36   4275
4343: oError 14
4345: oJumpForward 4350
4347: Choice Lookup Table
           0   4272
4350: oReturn
4351: oLocalSpace 1
4353: oGetAddrLocal 1
4355: oPushResult
4356: oTypeSNodeType
4357: oAssign
4358: oTypeSPop
4359: oGetLocal 1
4361: oPushResult
4362: oTypeSNodeType
4363: oPushResult
4364: equal_node_type
4365: oPop 2
4367: oChoice 4468
4369: oTypeSNodeType
4370: oChoice 4451
4372: oGetLocal 1
4374: oChoice 4379
4376: oReturn
4377: oJumpForward 4382
4379: Choice Lookup Table
          29   4376
4382: oJumpForward 4464
4384: oGetLocal 1
4386: oChoice 4391
4388: oReturn
4389: oJumpForward 4394
4391: Choice Lookup Table
          30   4388
4394: oJumpForward 4464
4396: oGetLocal 1
4398: oChoice 4403
4400: oReturn
4401: oJumpForward 4406
4403: Choice Lookup Table
          37   4400
4406: oJumpForward 4464
4408: oGetLocal 1
4410: oChoice 4415
4412: oReturn
4413: oJumpForward 4418
4415: Choice Lookup Table
          36   4412
4418: oJumpForward 4464
4420: oGetLocal 1
4422: oChoice 4428
4424: oValueCharToString
4425: oReturn
4426: oJumpForward 4431
4428: Choice Lookup Table
          35   4424
4431: oJumpForward 4464
4433: oGetLocal 1
4435: oChoice 4444
4437: oReturn
4438: oJumpForward 4449
4440: oValueCharToString
4441: oReturn
4442: oJumpForward 4449
4444: Choice Lookup Table
          35   4440
          41   4437
4449: oJumpForward 4464
4451: Choice Lookup Table
          42   4433
          41   4420
          37   4408
          36   4396
          29   4384
          30   4372
4464: oError 14
4466: oJumpForward 4471
4468: Choice Lookup Table
           0   4369
4471: oReturn
4472: oLocalSpace 1
4474: oGetAddrLocal 1
4476: oPushResult
4477: oTypeSNodeType
4478: oAssign
4479: oTypeSPop
4480: oGetLocal 1
4482: oPushResult
4483: oTypeSNodeType
4484: oPushResult
4485: equal_node_type
4486: oPop 2
4488: oChoice 4617
4490: oTypeSNodeType
4491: oChoice 4594
4493: oGetLocal 1
4495: oChoice 4503
4497: oReturn
4498: oJumpForward 4514
4500: oReturn
4501: oJumpForward 4514
4503: Choice Lookup Table
          43   4500
          30   4500
          33   4497
          35   4497
          29   4497
4514: oJumpForward 4613
4516: oGetLocal 1
4518: oChoice 4526
4520: oReturn
4521: oJumpForward 4537
4523: oReturn
4524: oJumpForward 4537
4526: Choice Lookup Table
          43   4523
          30   4523
          33   4520
          35   4520
          29   4520
4537: oJumpForward 4613
4539: oGetLocal 1
4541: oChoice 4546
4543: oReturn
4544: oJumpForward 4549
4546: Choice Lookup Table
          37   4543
4549: oJumpForward 4613
4551: oGetLocal 1
4553: oChoice 4558
4555: oReturn
4556: oJumpForward 4561
4558: Choice Lookup Table
          36   4555
4561: oJumpForward 4613
4563: oGetLocal 1
4565: oChoice 4571
4567: oValueCharToString
4568: oReturn
4569: oJumpForward 4574
4571: Choice Lookup Table
          35   4567
4574: oJumpForward 4613
4576: oGetLocal 1
4578: oChoice 4587
4580: oReturn
4581: oJumpForward 4592
4583: oValueCharToString
4584: oReturn
4585: oJumpForward 4592
4587: Choice Lookup Table
          35   4583
          41   4580
4592: oJumpForward 4613
4594: Choice Lookup Table
          42   4576
          41   4563
          37   4551
          36   4539
          33   4516
          35   4516
          29   4516
          43   4493
          30   4493
4613: oError 14
4615: oJumpForward 4620
4617: Choice Lookup Table
           0   4490
4620: oReturn
4621: oLocalSpace 1
4623: oGetParam 1
4625: oPushResult
4626: oGetGlobal 17
4628: oPushResult
4629: oNodeEqual
4630: oPop 2
4632: oChoice 4672
4634: oInput 15
4636: oCall 3539
4638: oInput 16
4640: oTypeSNodeType
4641: oChoice 4647
4643: oJumpForward 4660
4645: oJumpForward 4660
4647: Choice Lookup Table
          35   4645
          29   4645
          33   4645
          43   4643
          30   4643
4658: oError 14
4660: oTypeSPop
4661: oGetGlobal 6
4663: oPushResult
4664: oTypeSPush
4665: oPop 1
4667: oInput 16
4669: oReturn
4670: oJumpForward 4675
4672: Choice Lookup Table
           1   4634
4675: oGetParam 1
4677: oPushResult
4678: oGetGlobal 18
4680: oPushResult
4681: oNodeEqual
4682: oPop 2
4684: oChoice 4718
4686: oInput 15
4688: oCall 3539
4690: oInput 16
4692: oTypeSNodeType
4693: oChoice 4699
4695: oJumpForward 4706
4697: oJumpForward 4706
4699: Choice Lookup Table
          29   4697
          30   4695
4704: oError 14
4706: oTypeSPop
4707: oGetGlobal 9
4709: oPushResult
4710: oTypeSPush
4711: oPop 1
4713: oInput 16
4715: oReturn
4716: oJumpForward 4721
4718: Choice Lookup Table
           1   4686
4721: oGetParam 1
4723: oPushResult
4724: oGetGlobal 19
4726: oPushResult
4727: oNodeEqual
4728: oPop 2
4730: oChoice 4775
4732: oInput 15
4734: oCall 3539
4736: oTypeSNodeType
4737: oChoice 4758
4739: oTypeSTop
4740: oPushResult
4741: oSetResult 44
4743: oPushResult
4744: oNodeGetBoolean
4745: oPop 2
4747: oChoice 4753
4749: oError 28
4751: oJumpForward 4756
4753: Choice Lookup Table
           1   4749
4756: oJumpForward 4763
4758: Choice Lookup Table
          43   4739
4761: oError 14
4763: oSetResult 1
4765: oPushResult
4766: oValuePush
4767: oPop 1
4769: oValueSub
4770: oInput 16
4772: oReturn
4773: oJumpForward 4778
4775: Choice Lookup Table
           1   4732
4778: oGetParam 1
4780: oPushResult
4781: oGetGlobal 20
4783: oPushResult
4784: oNodeEqual
4785: oPop 2
4787: oChoice 4832
4789: oInput 15
4791: oCall 3539
4793: oTypeSNodeType
4794: oChoice 4815
4796: oTypeSTop
4797: oPushResult
4798: oSetResult 44
4800: oPushResult
4801: oNodeGetBoolean
4802: oPop 2
4804: oChoice 4810
4806: oError 28
4808: oJumpForward 4813
4810: Choice Lookup Table
           1   4806
4813: oJumpForward 4820
4815: Choice Lookup Table
          43   4796
4818: oError 14
4820: oSetResult 1
4822: oPushResult
4823: oValuePush
4824: oPop 1
4826: oValueAdd
4827: oInput 16
4829: oReturn
4830: oJumpForward 4835
4832: Choice Lookup Table
           1   4789
4835: oGetParam 1
4837: oPushResult
4838: oGetGlobal 21
4840: oPushResult
4841: oNodeEqual
4842: oPop 2
4844: oChoice 4881
4846: oInput 15
4848: oCall 3743
4850: oValuePop
4851: oGetAddrLocal 1
4853: oPushResult
4854: oTypeSTop
4855: oAssign
4856: oTypeSPop
4857: oGetLocal 1
4859: oPushResult
4860: oSetResult 17
4862: oPushResult
4863: oNodeGetInt
4864: oPop 2
4866: oPushResult
4867: oValuePush
4868: oPop 1
4870: oGetGlobal 6
4872: oPushResult
4873: oTypeSPush
4874: oPop 1
4876: oInput 16
4878: oReturn
4879: oJumpForward 4884
4881: Choice Lookup Table
           1   4846
4884: oError 16
4886: oReturn
4887: oLocalSpace 1
4889: oGetAddrLocal 1
4891: oPushResult
4892: oSetResult 0
4894: oAssign
4895: oGetAddrLocal 1
4897: oPushResult
4898: oCall 5071
4900: oPop 1
4902: oGetAddrLocal 1
4904: oPushResult
4905: oCall 4971
4907: oPop 1
4909: oReturn
4910: oLocalSpace 1
4912: oGetAddrLocal 1
4914: oPushResult
4915: oGetGlobal 25
4917: oAssign
4918: oGetAddrGlobal 25
4920: oPushResult
4921: oSetResult 1
4923: oAssign
4924: oCall 4887
4926: oGetAddrGlobal 25
4928: oPushResult
4929: oGetLocal 1
4931: oAssign
4932: oReturn
4933: oLocalSpace 0
4935: oGetParam 1
4937: oPushResult
4938: oCall 5071
4940: oPop 1
4942: oTypeSNodeType
4943: oChoice 4962
4945: oJumpForward 4969
4947: oGetParam 1
4949: oPushResult
4950: oLabelNew
4951: oAssign
4952: oEmit 72
4954: oGetFromParam 1
4956: oPushResult
4957: oEmitLabel
4958: oPop 1
4960: oJumpForward 4969
4962: Choice Lookup Table
          33   4947
          34   4945
4967: oError 8
4969: oTypeSPop
4970: oReturn
4971: oLocalSpace 1
4973: oTypeSNodeType
4974: oChoice 5036
4976: oGetAddrLocal 1
4978: oPushResult
4979: oLabelNew
4980: oAssign
4981: oEmit 15
4983: oSetResult 1
4985: oPushResult
4986: oEmitInt
4987: oPop 1
4989: oEmit 70
4991: oGetLocal 1
4993: oPushResult
4994: oEmitLabel
4995: oPop 1
4997: oEmit 79
4999: oGetFromParam 1
5001: oPushResult
5002: oEmitLabel
5003: oPop 1
5005: oEmit 15
5007: oSetResult 0
5009: oPushResult
5010: oEmitInt
5011: oPop 1
5013: oEmit 79
5015: oGetLocal 1
5017: oPushResult
5018: oEmitLabel
5019: oPop 1
5021: oTypeSPop
5022: oGetGlobal 7
5024: oPushResult
5025: oTypeSPush
5026: oPop 1
5028: oGetParam 1
5030: oPushResult
5031: oSetResult 0
5033: oAssign
5034: oJumpForward 5039
5036: Choice Lookup Table
          34   4976
5039: oReturn
5040: oLocalSpace 0
5042: oTypeSNodeType
5043: oChoice 5067
5045: oGetParam 1
5047: oPushResult
5048: oLabelNew
5049: oAssign
5050: oEmit 72
5052: oGetFromParam 1
5054: oPushResult
5055: oEmitLabel
5056: oPop 1
5058: oTypeSPop
5059: oGetGlobal 8
5061: oPushResult
5062: oTypeSPush
5063: oPop 1
5065: oJumpForward 5070
5067: Choice Lookup Table
          33   5045
5070: oReturn
5071: oLocalSpace 0
5073: oGetParam 1
5075: oPushResult
5076: oCall 5604
5078: oPop 1
5080: oInputChoice 5586
5082: oGetParam 1
5084: oPushResult
5085: oCall 4971
5087: oPop 1
5089: oCall 8697
5091: oGetParam 1
5093: oPushResult
5094: oCall 5604
5096: oPop 1
5098: oGetParam 1
5100: oPushResult
5101: oCall 4971
5103: oPop 1
5105: oCall 8697
5107: oCall 8566
5109: oTypeSNodeType
5110: oChoice 5138
5112: oEmit 45
5114: oJumpForward 5157
5116: oEmit 51
5118: oJumpForward 5157
5120: oEmit 57
5122: oJumpForward 5157
5124: oCall 10925
5126: oEmit 15
5128: oSetResult 0
5130: oPushResult
5131: oEmitInt
5132: oPop 1
5134: oEmit 51
5136: oJumpForward 5157
5138: Choice Lookup Table
          41   5124
          42   5124
          37   5120
          36   5120
          43   5116
          30   5116
          35   5112
          33   5112
5155: oError 17
5157: oTypeSPop
5158: oGetGlobal 7
5160: oPushResult
5161: oTypeSPush
5162: oPop 1
5164: oJumpForward 5601
5166: oGetParam 1
5168: oPushResult
5169: oCall 4971
5171: oPop 1
5173: oCall 8697
5175: oGetParam 1
5177: oPushResult
5178: oCall 5604
5180: oPop 1
5182: oGetParam 1
5184: oPushResult
5185: oCall 4971
5187: oPop 1
5189: oCall 8697
5191: oCall 8566
5193: oTypeSNodeType
5194: oChoice 5222
5196: oEmit 46
5198: oJumpForward 5241
5200: oEmit 52
5202: oJumpForward 5241
5204: oEmit 58
5206: oJumpForward 5241
5208: oCall 10925
5210: oEmit 15
5212: oSetResult 0
5214: oPushResult
5215: oEmitInt
5216: oPop 1
5218: oEmit 52
5220: oJumpForward 5241
5222: Choice Lookup Table
          41   5208
          42   5208
          37   5204
          36   5204
          43   5200
          30   5200
          35   5196
          33   5196
5239: oError 17
5241: oTypeSPop
5242: oGetGlobal 7
5244: oPushResult
5245: oTypeSPush
5246: oPop 1
5248: oJumpForward 5601
5250: oGetParam 1
5252: oPushResult
5253: oCall 4971
5255: oPop 1
5257: oCall 8697
5259: oGetParam 1
5261: oPushResult
5262: oCall 5604
5264: oPop 1
5266: oGetParam 1
5268: oPushResult
5269: oCall 4971
5271: oPop 1
5273: oCall 8697
5275: oCall 8566
5277: oTypeSNodeType
5278: oChoice 5306
5280: oEmit 48
5282: oJumpForward 5325
5284: oEmit 54
5286: oJumpForward 5325
5288: oEmit 60
5290: oJumpForward 5325
5292: oCall 10925
5294: oEmit 15
5296: oSetResult 0
5298: oPushResult
5299: oEmitInt
5300: oPop 1
5302: oEmit 54
5304: oJumpForward 5325
5306: Choice Lookup Table
          41   5292
          42   5292
          37   5288
          36   5288
          43   5284
          30   5284
          35   5280
          33   5280
5323: oError 17
5325: oTypeSPop
5326: oGetGlobal 7
5328: oPushResult
5329: oTypeSPush
5330: oPop 1
5332: oJumpForward 5601
5334: oGetParam 1
5336: oPushResult
5337: oCall 4971
5339: oPop 1
5341: oCall 8697
5343: oGetParam 1
5345: oPushResult
5346: oCall 5604
5348: oPop 1
5350: oGetParam 1
5352: oPushResult
5353: oCall 4971
5355: oPop 1
5357: oCall 8697
5359: oCall 8566
5361: oTypeSNodeType
5362: oChoice 5390
5364: oEmit 47
5366: oJumpForward 5409
5368: oEmit 53
5370: oJumpForward 5409
5372: oEmit 59
5374: oJumpForward 5409
5376: oCall 10925
5378: oEmit 15
5380: oSetResult 0
5382: oPushResult
5383: oEmitInt
5384: oPop 1
5386: oEmit 53
5388: oJumpForward 5409
5390: Choice Lookup Table
          41   5376
          42   5376
          37   5372
          36   5372
          43   5368
          30   5368
          35   5364
          33   5364
5407: oError 17
5409: oTypeSPop
5410: oGetGlobal 7
5412: oPushResult
5413: oTypeSPush
5414: oPop 1
5416: oJumpForward 5601
5418: oGetParam 1
5420: oPushResult
5421: oCall 4971
5423: oPop 1
5425: oCall 8697
5427: oGetParam 1
5429: oPushResult
5430: oCall 5604
5432: oPop 1
5434: oGetParam 1
5436: oPushResult
5437: oCall 4971
5439: oPop 1
5441: oCall 8697
5443: oCall 8566
5445: oTypeSNodeType
5446: oChoice 5474
5448: oEmit 50
5450: oJumpForward 5493
5452: oEmit 56
5454: oJumpForward 5493
5456: oEmit 62
5458: oJumpForward 5493
5460: oCall 10925
5462: oEmit 15
5464: oSetResult 0
5466: oPushResult
5467: oEmitInt
5468: oPop 1
5470: oEmit 56
5472: oJumpForward 5493
5474: Choice Lookup Table
          41   5460
          42   5460
          37   5456
          36   5456
          43   5452
          30   5452
          35   5448
          33   5448
5491: oError 17
5493: oTypeSPop
5494: oGetGlobal 7
5496: oPushResult
5497: oTypeSPush
5498: oPop 1
5500: oJumpForward 5601
5502: oGetParam 1
5504: oPushResult
5505: oCall 4971
5507: oPop 1
5509: oCall 8697
5511: oGetParam 1
5513: oPushResult
5514: oCall 5604
5516: oPop 1
5518: oGetParam 1
5520: oPushResult
5521: oCall 4971
5523: oPop 1
5525: oCall 8697
5527: oCall 8566
5529: oTypeSNodeType
5530: oChoice 5558
5532: oEmit 49
5534: oJumpForward 5577
5536: oEmit 55
5538: oJumpForward 5577
5540: oEmit 61
5542: oJumpForward 5577
5544: oCall 10925
5546: oEmit 15
5548: oSetResult 0
5550: oPushResult
5551: oEmitInt
5552: oPop 1
5554: oEmit 55
5556: oJumpForward 5577
5558: Choice Lookup Table
          41   5544
          42   5544
          37   5540
          36   5540
          43   5536
          30   5536
          35   5532
          33   5532
5575: oError 17
5577: oTypeSPop
5578: oGetGlobal 7
5580: oPushResult
5581: oTypeSPush
5582: oPop 1
5584: oJumpForward 5601
5586: Choice Lookup Table
          12   5502
          11   5418
          10   5334
           9   5250
           8   5166
           7   5082
5599: oJumpForward 5603
5601: oJumpBack 5080
5603: oReturn
5604: oLocalSpace 1
5606: oGetAddrLocal 1
5608: oPushResult
5609: oSetResult 0
5611: oAssign
5612: oGetParam 1
5614: oPushResult
5615: oCall 5784
5617: oPop 1
5619: oInputChoice 5752
5621: oTypeSNodeType
5622: oChoice 5693
5624: oGetLocal 1
5626: oPushResult
5627: oSetResult 0
5629: oPushResult
5630: equal_label
5631: oPop 2
5633: oChoice 5642
5635: oGetAddrLocal 1
5637: oPushResult
5638: oLabelNew
5639: oAssign
5640: oJumpForward 5645
5642: Choice Lookup Table
           1   5635
5645: oEmit 70
5647: oGetLocal 1
5649: oPushResult
5650: oEmitLabel
5651: oPop 1
5653: oJumpForward 5700
5655: oGetParam 1
5657: oPushResult
5658: oCall 5040
5660: oPop 1
5662: oGetLocal 1
5664: oPushResult
5665: oSetResult 0
5667: oPushResult
5668: equal_label
5669: oPop 2
5671: oChoice 5680
5673: oGetAddrLocal 1
5675: oPushResult
5676: oLabelNew
5677: oAssign
5678: oJumpForward 5683
5680: Choice Lookup Table
           1   5673
5683: oEmit 70
5685: oGetLocal 1
5687: oPushResult
5688: oEmitLabel
5689: oPop 1
5691: oJumpForward 5700
5693: Choice Lookup Table
          33   5655
          34   5624
5698: oError 8
5700: oTypeSPop
5701: oEmit 79
5703: oGetFromParam 1
5705: oPushResult
5706: oEmitLabel
5707: oPop 1
5709: oGetParam 1
5711: oPushResult
5712: oSetResult 0
5714: oAssign
5715: oGetParam 1
5717: oPushResult
5718: oCall 5784
5720: oPop 1
5722: oTypeSNodeType
5723: oChoice 5736
5725: oJumpForward 5743
5727: oGetParam 1
5729: oPushResult
5730: oCall 5040
5732: oPop 1
5734: oJumpForward 5743
5736: Choice Lookup Table
          33   5727
          34   5725
5741: oError 8
5743: oTypeSPop
5744: oGetGlobal 8
5746: oPushResult
5747: oTypeSPush
5748: oPop 1
5750: oJumpForward 5757
5752: Choice Lookup Table
          58   5621
5755: oJumpForward 5759
5757: oJumpBack 5619
5759: oGetLocal 1
5761: oPushResult
5762: oSetResult 0
5764: oPushResult
5765: equal_label
5766: oPop 2
5768: oChoice 5780
5770: oEmit 79
5772: oGetLocal 1
5774: oPushResult
5775: oEmitLabel
5776: oPop 1
5778: oJumpForward 5783
5780: Choice Lookup Table
           0   5770
5783: oReturn
5784: oLocalSpace 2
5786: oGetAddrLocal 1
5788: oPushResult
5789: oSetResult 0
5791: oAssign
5792: oGetParam 1
5794: oPushResult
5795: oCall 5922
5797: oPop 1
5799: oInputChoice 5914
5801: oTypeSNodeType
5802: oChoice 5815
5804: oJumpForward 5822
5806: oGetParam 1
5808: oPushResult
5809: oCall 5040
5811: oPop 1
5813: oJumpForward 5822
5815: Choice Lookup Table
          33   5806
          34   5804
5820: oError 8
5822: oTypeSPop
5823: oGetLocal 1
5825: oPushResult
5826: oSetResult 0
5828: oPushResult
5829: equal_label
5830: oPop 2
5832: oChoice 5861
5834: oGetAddrLocal 1
5836: oPushResult
5837: oLabelNew
5838: oAssign
5839: oEmit 80
5841: oGetFromParam 1
5843: oPushResult
5844: oEmitLabel
5845: oPop 1
5847: oGetLocal 1
5849: oPushResult
5850: oEmitLabel
5851: oPop 1
5853: oGetParam 1
5855: oPushResult
5856: oGetLocal 1
5858: oAssign
5859: oJumpForward 5864
5861: Choice Lookup Table
           1   5834
5864: oGetAddrLocal 2
5866: oPushResult
5867: oSetResult 0
5869: oAssign
5870: oGetAddrLocal 2
5872: oPushResult
5873: oCall 5922
5875: oPop 1
5877: oTypeSNodeType
5878: oChoice 5891
5880: oJumpForward 5898
5882: oGetAddrLocal 2
5884: oPushResult
5885: oCall 5040
5887: oPop 1
5889: oJumpForward 5898
5891: Choice Lookup Table
          33   5882
          34   5880
5896: oError 8
5898: oEmit 80
5900: oGetLocal 2
5902: oPushResult
5903: oEmitLabel
5904: oPop 1
5906: oGetLocal 1
5908: oPushResult
5909: oEmitLabel
5910: oPop 1
5912: oJumpForward 5919
5914: Choice Lookup Table
          57   5801
5917: oJumpForward 5921
5919: oJumpBack 5799
5921: oReturn
5922: oLocalSpace 1
5924: oInputChoice 5978
5926: oGetAddrLocal 1
5928: oPushResult
5929: oSetResult 0
5931: oAssign
5932: oGetAddrLocal 1
5934: oPushResult
5935: oCall 5922
5937: oPop 1
5939: oTypeSNodeType
5940: oChoice 5969
5942: oGetParam 1
5944: oPushResult
5945: oLabelNew
5946: oAssign
5947: oEmit 70
5949: oGetFromParam 1
5951: oPushResult
5952: oEmitLabel
5953: oPop 1
5955: oEmit 79
5957: oGetLocal 1
5959: oPushResult
5960: oEmitLabel
5961: oPop 1
5963: oJumpForward 5976
5965: oEmit 44
5967: oJumpForward 5976
5969: Choice Lookup Table
          33   5965
          34   5942
5974: oError 8
5976: oJumpForward 5988
5978: Choice Lookup Table
          59   5926
5981: oGetParam 1
5983: oPushResult
5984: oCall 5989
5986: oPop 1
5988: oReturn
5989: oLocalSpace 2
5991: oGetAddrLocal 1
5993: oPushResult
5994: oSetResult 1
5996: oAssign
5997: oGetParam 1
5999: oPushResult
6000: oCall 6225
6002: oPop 1
6004: oInputChoice 6215
6006: oTypeSNodeType
6007: oChoice 6130
6009: oCall 8651
6011: oGetParam 1
6013: oPushResult
6014: oCall 6225
6016: oPop 1
6018: oTypeSNodeType
6019: oChoice 6027
6021: oEmit 23
6023: oCall 8014
6025: oJumpForward 6036
6027: Choice Lookup Table
          37   6021
          36   6021
6032: oCall 8671
6034: oEmit 39
6036: oJumpForward 6147
6038: oGetLocal 1
6040: oChoice 6056
6042: oGetAddrLocal 2
6044: oPushResult
6045: oCall 10708
6047: oAssign
6048: oGetAddrLocal 1
6050: oPushResult
6051: oSetResult 0
6053: oAssign
6054: oJumpForward 6059
6056: Choice Lookup Table
           1   6042
6059: oGetParam 1
6061: oPushResult
6062: oCall 6225
6064: oPop 1
6066: oTypeSNodeType
6067: oChoice 6105
6069: oCall 10817
6071: oEmit 18
6073: oGetLocal 2
6075: oPushResult
6076: oEmitInt
6077: oPop 1
6079: oGetGlobal 16
6081: oPushResult
6082: oTypeSPush
6083: oPop 1
6085: oJumpForward 6115
6087: oCall 10871
6089: oEmit 18
6091: oGetLocal 2
6093: oPushResult
6094: oEmitInt
6095: oPop 1
6097: oGetGlobal 16
6099: oPushResult
6100: oTypeSPush
6101: oPop 1
6103: oJumpForward 6115
6105: Choice Lookup Table
          35   6087
          41   6069
          42   6069
6112: oError 14
6114: oTypeSPop
6115: oJumpForward 6147
6117: oGetParam 1
6119: oPushResult
6120: oCall 6225
6122: oPop 1
6124: oCall 8651
6126: oCall 8014
6128: oJumpForward 6147
6130: Choice Lookup Table
          37   6117
          36   6117
          35   6038
          41   6038
          42   6038
          29   6009
          30   6009
6145: oError 17
6147: oJumpForward 6222
6149: oTypeSNodeType
6150: oChoice 6202
6152: oCall 8651
6154: oGetParam 1
6156: oPushResult
6157: oCall 6225
6159: oPop 1
6161: oCall 8671
6163: oEmit 42
6165: oJumpForward 6213
6167: oGetParam 1
6169: oPushResult
6170: oCall 6225
6172: oPop 1
6174: oTypeSNodeType
6175: oChoice 6189
6177: oCall 8651
6179: oCall 8070
6181: oJumpForward 6200
6183: oCall 8566
6185: oCall 8126
6187: oJumpForward 6200
6189: Choice Lookup Table
          37   6183
          36   6183
          29   6177
          30   6177
6198: oError 17
6200: oJumpForward 6213
6202: Choice Lookup Table
          37   6167
          36   6167
          29   6152
          30   6152
6211: oError 17
6213: oJumpForward 6222
6215: Choice Lookup Table
          26   6149
          25   6006
6220: oJumpForward 6224
6222: oJumpBack 6004
6224: oReturn
6225: oLocalSpace 0
6227: oGetParam 1
6229: oPushResult
6230: oCall 6276
6232: oPop 1
6234: oInputChoice 6266
6236: oCall 8651
6238: oGetParam 1
6240: oPushResult
6241: oCall 6276
6243: oPop 1
6245: oCall 8671
6247: oEmit 36
6249: oJumpForward 6273
6251: oCall 8651
6253: oGetParam 1
6255: oPushResult
6256: oCall 6276
6258: oPop 1
6260: oCall 8671
6262: oEmit 37
6264: oJumpForward 6273
6266: Choice Lookup Table
          24   6251
          23   6236
6271: oJumpForward 6275
6273: oJumpBack 6234
6275: oReturn
6276: oLocalSpace 0
6278: oInputChoice 6304
6280: oGetParam 1
6282: oPushResult
6283: oCall 6317
6285: oPop 1
6287: oCall 8671
6289: oJumpForward 6316
6291: oGetParam 1
6293: oPushResult
6294: oCall 6317
6296: oPop 1
6298: oCall 8671
6300: oEmit 43
6302: oJumpForward 6316
6304: Choice Lookup Table
          26   6291
          25   6280
6309: oGetParam 1
6311: oPushResult
6312: oCall 6317
6314: oPop 1
6316: oReturn
6317: oLocalSpace 7
6319: oInputChoice 6775
6321: oEmit 15
6323: TOKEN_VALUE
6324: oPushResult
6325: oEmitInt
6326: oPop 1
6328: oGetGlobal 6
6330: oPushResult
6331: oTypeSPush
6332: oPop 1
6334: oJumpForward 6798
6336: oEmit 15
6338: TOKEN_VALUE
6339: oPushResult
6340: oEmitInt
6341: oPop 1
6343: oGetGlobal 9
6345: oPushResult
6346: oTypeSPush
6347: oPop 1
6349: oJumpForward 6798
6351: oEmit 16
6353: TOKEN_VALUE_DOUBLE
6354: oPushResult
6355: oEmitDouble
6356: oPop 1
6358: oGetGlobal 13
6360: oPushResult
6361: oTypeSPush
6362: oPop 1
6364: oJumpForward 6798
6366: oGetParam 1
6368: oPushResult
6369: oCall 5071
6371: oPop 1
6373: oInput 16
6375: oJumpForward 6798
6377: oGetAddrLocal 1
6379: oPushResult
6380: CURRENT_STRLIT
6381: oPushResult
6382: oStringAllocShortStringLit
6383: oPop 1
6385: oAssign
6386: oEmit 17
6388: oGetLocal 1
6390: oPushResult
6391: oEmitInt
6392: oPop 1
6394: oGetGlobal 15
6396: oPushResult
6397: oTypeSPush
6398: oPop 1
6400: oCall 7612
6402: oCall 7558
6404: oJumpForward 6798
6406: oGetAddrLocal 2
6408: oPushResult
6409: oScopeFindRequire
6410: oAssign
6411: oGetAddrLocal 2
6413: oPushResult
6414: oCall 244
6416: oPop 1
6418: oGetLocal 2
6420: oPushResult
6421: oNodeType
6422: oPop 1
6424: oChoice 6695
6426: oGetLocal 2
6428: oPushResult
6429: oCall 11020
6431: oPop 1
6433: oJumpForward 6724
6435: oGetLocal 2
6437: oPushResult
6438: oCall 11690
6440: oPop 1
6442: oJumpForward 6724
6444: oGetAddrLocal 3
6446: oPushResult
6447: oGetLocal 2
6449: oPushResult
6450: oSetResult 21
6452: oPushResult
6453: oNodeGet
6454: oPop 2
6456: oAssign
6457: oGetLocal 3
6459: oPushResult
6460: oTypeSPush
6461: oPop 1
6463: oTypeSNodeType
6464: oChoice 6488
6466: oEmit 15
6468: oGetLocal 2
6470: oPushResult
6471: oCall 14059
6473: oPop 1
6475: oJumpForward 6505
6477: oEmit 15
6479: oGetLocal 2
6481: oPushResult
6482: oCall 14059
6484: oPop 1
6486: oJumpForward 6505
6488: Choice Lookup Table
          37   6477
          36   6477
          29   6466
          35   6466
          33   6466
          43   6466
          30   6466
6503: oError 16
6505: oJumpForward 6724
6507: oGetAddrLocal 4
6509: oPushResult
6510: oGetLocal 2
6512: oPushResult
6513: oSetResult 22
6515: oPushResult
6516: oNodeGetInt
6517: oPop 2
6519: oAssign
6520: oGetLocal 4
6522: oPushResult
6523: equal_zero
6524: oPop 1
6526: oChoice 6559
6528: oGetAddrLocal 4
6530: oPushResult
6531: oGetLocal 2
6533: oPushResult
6534: oSetResult 33
6536: oPushResult
6537: oNodeGetString
6538: oPop 2
6540: oPushResult
6541: oStringAllocShortStringLit
6542: oPop 1
6544: oAssign
6545: oGetLocal 2
6547: oPushResult
6548: oSetResult 22
6550: oPushResult
6551: oGetLocal 4
6553: oPushResult
6554: oNodeSetInt
6555: oPop 3
6557: oJumpForward 6562
6559: Choice Lookup Table
           1   6528
6562: oEmit 17
6564: oGetLocal 4
6566: oPushResult
6567: oEmitInt
6568: oPop 1
6570: oGetGlobal 15
6572: oPushResult
6573: oTypeSPush
6574: oPop 1
6576: oCall 7612
6578: oCall 7558
6580: oJumpForward 6724
6582: oGetLocal 2
6584: oPushResult
6585: oCall 6799
6587: oPop 1
6589: oJumpForward 6724
6591: oGetLocal 2
6593: oPushResult
6594: oSetResult 21
6596: oPushResult
6597: oNodeGet
6598: oPop 2
6600: oPushResult
6601: oTypeSPush
6602: oPop 1
6604: oInputChoice 6671
6606: oCall 4887
6608: oInput 16
6610: oCall 8386
6612: oTypeSNodeType
6613: oChoice 6658
6615: oInputChoice 6645
6617: oTypeSPop
6618: oGetLocal 3
6620: oPushResult
6621: oSetResult 37
6623: oPushResult
6624: oNodeGet
6625: oPop 2
6627: oPushResult
6628: oTypeSPush
6629: oPop 1
6631: oCall 7612
6633: oCall 7558
6635: oJumpForward 6650
6637: oCall 7807
6639: oCall 7612
6641: oCall 7558
6643: oJumpForward 6650
6645: Choice Lookup Table
          17   6637
          19   6617
6650: oJumpForward 6669
6652: oCall 7612
6654: oCall 7558
6656: oJumpForward 6669
6658: Choice Lookup Table
          42   6652
          40   6652
          38   6652
          37   6615
          36   6615
6669: oJumpForward 6693
6671: Choice Lookup Table
          15   6606
6674: oGetGlobal 25
6676: oChoice 6688
6678: oEmit 15
6680: oSetResult 0
6682: oPushResult
6683: oEmitInt
6684: oPop 1
6686: oJumpForward 6693
6688: Choice Lookup Table
           1   6678
6691: oError 31
6693: oJumpForward 6724
6695: Choice Lookup Table
          19   6591
          25   6582
          24   6582
          22   6582
          21   6582
          18   6507
          17   6444
          16   6444
          14   6435
          13   6426
6716: oError 6
6718: oGetGlobal 6
6720: oPushResult
6721: oTypeSPush
6722: oPop 1
6724: oJumpForward 6798
6726: oInput 0
6728: oGetAddrLocal 5
6730: oPushResult
6731: oScopeFindRequire
6732: oAssign
6733: oGetAddrLocal 5
6735: oPushResult
6736: oCall 244
6738: oPop 1
6740: oGetLocal 5
6742: oPushResult
6743: oSetResult 0
6745: oPushResult
6746: oCall 9225
6748: oPop 2
6750: oGetAddrLocal 6
6752: oPushResult
6753: oTypeSTop
6754: oAssign
6755: oTypeSPop
6756: oGetAddrLocal 7
6758: oPushResult
6759: oGetLocal 6
6761: oPushResult
6762: oCall 13078
6764: oPop 1
6766: oAssign
6767: oGetLocal 7
6769: oPushResult
6770: oTypeSPush
6771: oPop 1
6773: oJumpForward 6798
6775: Choice Lookup Table
          20   6726
           0   6406
           3   6377
          15   6366
           2   6351
           4   6336
           1   6321
6790: oError 6
6792: oGetGlobal 6
6794: oPushResult
6795: oTypeSPush
6796: oPop 1
6798: oReturn
6799: oLocalSpace 2
6801: oGetAddrLocal 1
6803: oPushResult
6804: oGetParam 1
6806: oPushResult
6807: oSetResult 21
6809: oPushResult
6810: oNodeGet
6811: oPop 2
6813: oAssign
6814: oGetAddrLocal 2
6816: oPushResult
6817: oGetParam 1
6819: oPushResult
6820: oCall 14013
6822: oPop 1
6824: oAssign
6825: oGetLocal 1
6827: oPushResult
6828: oTypeSPush
6829: oPop 1
6831: oTypeSNodeType
6832: oChoice 7531
6834: oGetParam 1
6836: oPushResult
6837: oNodeType
6838: oPop 1
6840: oChoice 6986
6842: oEmit 0
6844: oGetParam 1
6846: oPushResult
6847: oCall 14059
6849: oPop 1
6851: oJumpForward 6996
6853: oGetLocal 2
6855: oPushResult
6856: equal_zero
6857: oPop 1
6859: oChoice 6872
6861: oEmit 3
6863: oGetParam 1
6865: oPushResult
6866: oCall 14059
6868: oPop 1
6870: oJumpForward 6890
6872: Choice Lookup Table
           1   6861
6875: oEmit 9
6877: oGetLocal 2
6879: oPushResult
6880: oEmitInt
6881: oPop 1
6883: oGetParam 1
6885: oPushResult
6886: oCall 14059
6888: oPop 1
6890: oJumpForward 6996
6892: oGetParam 1
6894: oPushResult
6895: oSetResult 34
6897: oPushResult
6898: oNodeGetBoolean
6899: oPop 2
6901: oChoice 6944
6903: oGetLocal 2
6905: oPushResult
6906: equal_zero
6907: oPop 1
6909: oChoice 6922
6911: oEmit 8
6913: oGetParam 1
6915: oPushResult
6916: oCall 14059
6918: oPop 1
6920: oJumpForward 6940
6922: Choice Lookup Table
           1   6911
6925: oEmit 14
6927: oGetLocal 2
6929: oPushResult
6930: oEmitInt
6931: oPop 1
6933: oGetParam 1
6935: oPushResult
6936: oCall 14059
6938: oPop 1
6940: oEmit 24
6942: oJumpForward 6984
6944: Choice Lookup Table
           1   6903
6947: oGetLocal 2
6949: oPushResult
6950: equal_zero
6951: oPop 1
6953: oChoice 6966
6955: oEmit 6
6957: oGetParam 1
6959: oPushResult
6960: oCall 14059
6962: oPop 1
6964: oJumpForward 6984
6966: Choice Lookup Table
           1   6955
6969: oEmit 12
6971: oGetLocal 2
6973: oPushResult
6974: oEmitInt
6975: oPop 1
6977: oGetParam 1
6979: oPushResult
6980: oCall 14059
6982: oPop 1
6984: oJumpForward 6996
6986: Choice Lookup Table
          24   6892
          22   6853
          25   6842
          21   6842
6995: oEndChoice
6996: oJumpForward 7557
6998: oGetParam 1
7000: oPushResult
7001: oNodeType
7002: oPop 1
7004: oChoice 7150
7006: oEmit 1
7008: oGetParam 1
7010: oPushResult
7011: oCall 14059
7013: oPop 1
7015: oJumpForward 7160
7017: oGetLocal 2
7019: oPushResult
7020: equal_zero
7021: oPop 1
7023: oChoice 7036
7025: oEmit 4
7027: oGetParam 1
7029: oPushResult
7030: oCall 14059
7032: oPop 1
7034: oJumpForward 7054
7036: Choice Lookup Table
           1   7025
7039: oEmit 10
7041: oGetLocal 2
7043: oPushResult
7044: oEmitInt
7045: oPop 1
7047: oGetParam 1
7049: oPushResult
7050: oCall 14059
7052: oPop 1
7054: oJumpForward 7160
7056: oGetParam 1
7058: oPushResult
7059: oSetResult 34
7061: oPushResult
7062: oNodeGetBoolean
7063: oPop 2
7065: oChoice 7108
7067: oGetLocal 2
7069: oPushResult
7070: equal_zero
7071: oPop 1
7073: oChoice 7086
7075: oEmit 8
7077: oGetParam 1
7079: oPushResult
7080: oCall 14059
7082: oPop 1
7084: oJumpForward 7104
7086: Choice Lookup Table
           1   7075
7089: oEmit 14
7091: oGetLocal 2
7093: oPushResult
7094: oEmitInt
7095: oPop 1
7097: oGetParam 1
7099: oPushResult
7100: oCall 14059
7102: oPop 1
7104: oEmit 25
7106: oJumpForward 7148
7108: Choice Lookup Table
           1   7067
7111: oGetLocal 2
7113: oPushResult
7114: equal_zero
7115: oPop 1
7117: oChoice 7130
7119: oEmit 7
7121: oGetParam 1
7123: oPushResult
7124: oCall 14059
7126: oPop 1
7128: oJumpForward 7148
7130: Choice Lookup Table
           1   7119
7133: oEmit 13
7135: oGetLocal 2
7137: oPushResult
7138: oEmitInt
7139: oPop 1
7141: oGetParam 1
7143: oPushResult
7144: oCall 14059
7146: oPop 1
7148: oJumpForward 7160
7150: Choice Lookup Table
          24   7056
          22   7017
          25   7006
          21   7006
7159: oEndChoice
7160: oJumpForward 7557
7162: oError 16
7164: oJumpForward 7557
7166: oGetParam 1
7168: oPushResult
7169: oNodeType
7170: oPop 1
7172: oChoice 7318
7174: oEmit 2
7176: oGetParam 1
7178: oPushResult
7179: oCall 14059
7181: oPop 1
7183: oJumpForward 7328
7185: oGetLocal 2
7187: oPushResult
7188: equal_zero
7189: oPop 1
7191: oChoice 7204
7193: oEmit 5
7195: oGetParam 1
7197: oPushResult
7198: oCall 14059
7200: oPop 1
7202: oJumpForward 7222
7204: Choice Lookup Table
           1   7193
7207: oEmit 11
7209: oGetLocal 2
7211: oPushResult
7212: oEmitInt
7213: oPop 1
7215: oGetParam 1
7217: oPushResult
7218: oCall 14059
7220: oPop 1
7222: oJumpForward 7328
7224: oGetParam 1
7226: oPushResult
7227: oSetResult 34
7229: oPushResult
7230: oNodeGetBoolean
7231: oPop 2
7233: oChoice 7276
7235: oGetLocal 2
7237: oPushResult
7238: equal_zero
7239: oPop 1
7241: oChoice 7254
7243: oEmit 8
7245: oGetParam 1
7247: oPushResult
7248: oCall 14059
7250: oPop 1
7252: oJumpForward 7272
7254: Choice Lookup Table
           1   7243
7257: oEmit 14
7259: oGetLocal 2
7261: oPushResult
7262: oEmitInt
7263: oPop 1
7265: oGetParam 1
7267: oPushResult
7268: oCall 14059
7270: oPop 1
7272: oEmit 26
7274: oJumpForward 7316
7276: Choice Lookup Table
           1   7235
7279: oGetLocal 2
7281: oPushResult
7282: equal_zero
7283: oPop 1
7285: oChoice 7298
7287: oEmit 8
7289: oGetParam 1
7291: oPushResult
7292: oCall 14059
7294: oPop 1
7296: oJumpForward 7316
7298: Choice Lookup Table
           1   7287
7301: oEmit 14
7303: oGetLocal 2
7305: oPushResult
7306: oEmitInt
7307: oPop 1
7309: oGetParam 1
7311: oPushResult
7312: oCall 14059
7314: oPop 1
7316: oJumpForward 7328
7318: Choice Lookup Table
          24   7224
          22   7185
          25   7174
          21   7174
7327: oEndChoice
7328: oInputChoice 7358
7330: oTypeSPop
7331: oGetLocal 1
7333: oPushResult
7334: oSetResult 37
7336: oPushResult
7337: oNodeGet
7338: oPop 2
7340: oPushResult
7341: oTypeSPush
7342: oPop 1
7344: oCall 7612
7346: oCall 7558
7348: oJumpForward 7363
7350: oCall 7807
7352: oCall 7612
7354: oCall 7558
7356: oJumpForward 7363
7358: Choice Lookup Table
          17   7350
          19   7330
7363: oJumpForward 7557
7365: oGetParam 1
7367: oPushResult
7368: oNodeType
7369: oPop 1
7371: oChoice 7515
7373: oEmit 17
7375: oGetParam 1
7377: oPushResult
7378: oCall 14059
7380: oPop 1
7382: oJumpForward 7525
7384: oGetLocal 2
7386: oPushResult
7387: equal_zero
7388: oPop 1
7390: oChoice 7403
7392: oEmit 18
7394: oGetParam 1
7396: oPushResult
7397: oCall 14059
7399: oPop 1
7401: oJumpForward 7421
7403: Choice Lookup Table
           1   7392
7406: oEmit 21
7408: oGetLocal 2
7410: oPushResult
7411: oEmitInt
7412: oPop 1
7414: oGetParam 1
7416: oPushResult
7417: oCall 14059
7419: oPop 1
7421: oJumpForward 7525
7423: oGetParam 1
7425: oPushResult
7426: oSetResult 34
7428: oPushResult
7429: oNodeGetBoolean
7430: oPop 2
7432: oChoice 7473
7434: oGetLocal 2
7436: oPushResult
7437: equal_zero
7438: oPop 1
7440: oChoice 7453
7442: oEmit 8
7444: oGetParam 1
7446: oPushResult
7447: oCall 14059
7449: oPop 1
7451: oJumpForward 7471
7453: Choice Lookup Table
           1   7442
7456: oEmit 14
7458: oGetLocal 2
7460: oPushResult
7461: oEmitInt
7462: oPop 1
7464: oGetParam 1
7466: oPushResult
7467: oCall 14059
7469: oPop 1
7471: oJumpForward 7513
7473: Choice Lookup Table
           1   7434
7476: oGetLocal 2
7478: oPushResult
7479: equal_zero
7480: oPop 1
7482: oChoice 7495
7484: oEmit 19
7486: oGetParam 1
7488: oPushResult
7489: oCall 14059
7491: oPop 1
7493: oJumpForward 7513
7495: Choice Lookup Table
           1   7484
7498: oEmit 22
7500: oGetLocal 2
7502: oPushResult
7503: oEmitInt
7504: oPop 1
7506: oGetParam 1
7508: oPushResult
7509: oCall 14059
7511: oPop 1
7513: oJumpForward 7525
7515: Choice Lookup Table
          24   7423
          22   7384
          25   7373
          21   7373
7524: oEndChoice
7525: oCall 7612
7527: oCall 7558
7529: oJumpForward 7557
7531: Choice Lookup Table
          42   7365
          40   7365
          38   7365
          32   7166
          37   7166
          36   7166
          28   7162
          35   6998
          29   6998
          33   6998
          43   6834
          30   6834
7556: oEndChoice
7557: oReturn
7558: oLocalSpace 0
7560: oTypeSNodeType
7561: oChoice 7585
7563: oEmit 24
7565: oJumpForward 7611
7567: oEmit 25
7569: oJumpForward 7611
7571: oError 16
7573: oJumpForward 7611
7575: oEmit 26
7577: oJumpForward 7611
7579: oError 29
7581: oJumpForward 7611
7583: oJumpForward 7611
7585: Choice Lookup Table
          42   7583
          41   7583
          40   7583
          38   7583
          37   7579
          36   7575
          28   7571
          35   7567
          29   7567
          33   7567
          43   7563
          30   7563
7610: oEndChoice
7611: oReturn
7612: oLocalSpace 0
7614: oInputChoice 7652
7616: oTypeSNodeType
7617: oChoice 7631
7619: oCall 7664
7621: oJumpForward 7642
7623: oCall 7807
7625: oJumpForward 7642
7627: oCall 7886
7629: oJumpForward 7642
7631: Choice Lookup Table
          42   7627
          41   7627
          36   7623
          38   7619
7640: oError 10
7642: oJumpForward 7661
7644: oCall 7916
7646: oJumpForward 7661
7648: oCall 8189
7650: oJumpForward 7661
7652: Choice Lookup Table
          19   7648
          21   7644
          17   7616
7659: oJumpForward 7663
7661: oJumpBack 7614
7663: oReturn
7664: oLocalSpace 3
7666: oTypeSNodeType
7667: oChoice 7671
7669: oJumpForward 7676
7671: Choice Lookup Table
          38   7669
7674: oError 10
7676: oTypeSNodeType
7677: oChoice 7681
7679: oJumpForward 7686
7681: Choice Lookup Table
          38   7679
7684: oError 13
7686: oGetAddrLocal 1
7688: oPushResult
7689: oTypeSTop
7690: oPushResult
7691: oSetResult 38
7693: oPushResult
7694: oNodeGet
7695: oPop 2
7697: oPushResult
7698: oCall 13162
7700: oPop 1
7702: oAssign
7703: oGetAddrLocal 2
7705: oPushResult
7706: oTypeSTop
7707: oPushResult
7708: oSetResult 37
7710: oPushResult
7711: oNodeGet
7712: oPop 2
7714: oAssign
7715: oTypeSPop
7716: oGetLocal 2
7718: oPushResult
7719: oTypeSPush
7720: oPop 1
7722: oCall 4887
7724: oCall 8624
7726: oGetLocal 1
7728: oPushResult
7729: equal_zero
7730: oPop 1
7732: oChoice 7746
7734: oEmit 15
7736: oGetLocal 1
7738: oPushResult
7739: oEmitInt
7740: oPop 1
7742: oEmit 42
7744: oJumpForward 7749
7746: Choice Lookup Table
           0   7734
7749: oGetAddrLocal 3
7751: oPushResult
7752: oGetLocal 2
7754: oPushResult
7755: oSetResult 17
7757: oPushResult
7758: oNodeGetInt
7759: oPop 2
7761: oAssign
7762: oGetLocal 3
7764: oPushResult
7765: oSetResult 1
7767: oPushResult
7768: equal
7769: oPop 2
7771: oChoice 7785
7773: oEmit 15
7775: oGetLocal 3
7777: oPushResult
7778: oEmitInt
7779: oPop 1
7781: oEmit 36
7783: oJumpForward 7788
7785: Choice Lookup Table
           0   7773
7788: oEmit 38
7790: oInputChoice 7798
7792: oJumpForward 7806
7794: oJumpForward 7804
7796: oJumpForward 7804
7798: Choice Lookup Table
          14   7796
          18   7792
7803: oEndChoice
7804: oJumpBack 7676
7806: oReturn
7807: oLocalSpace 2
7809: oTypeSNodeType
7810: oChoice 7814
7812: oJumpForward 7819
7814: Choice Lookup Table
          36   7812
7817: oError 29
7819: oGetAddrLocal 1
7821: oPushResult
7822: oTypeSTop
7823: oPushResult
7824: oSetResult 37
7826: oPushResult
7827: oNodeGet
7828: oPop 2
7830: oAssign
7831: oTypeSPop
7832: oGetLocal 1
7834: oPushResult
7835: oTypeSPush
7836: oPop 1
7838: oCall 4887
7840: oCall 8624
7842: oGetAddrLocal 2
7844: oPushResult
7845: oGetLocal 1
7847: oPushResult
7848: oSetResult 17
7850: oPushResult
7851: oNodeGetInt
7852: oPop 2
7854: oAssign
7855: oGetLocal 2
7857: oPushResult
7858: oSetResult 1
7860: oPushResult
7861: equal
7862: oPop 2
7864: oChoice 7878
7866: oEmit 15
7868: oGetLocal 2
7870: oPushResult
7871: oEmitInt
7872: oPop 1
7874: oEmit 36
7876: oJumpForward 7881
7878: Choice Lookup Table
           0   7866
7881: oEmit 38
7883: oInput 18
7885: oReturn
7886: oLocalSpace 0
7888: oTypeSNodeType
7889: oChoice 7893
7891: oJumpForward 7900
7893: Choice Lookup Table
          42   7891
          41   7891
7898: oError 29
7900: oTypeSPop
7901: oGetGlobal 9
7903: oPushResult
7904: oTypeSPush
7905: oPop 1
7907: oCall 4887
7909: oCall 8624
7911: oEmit 38
7913: oInput 18
7915: oReturn
7916: oLocalSpace 2
7918: oTypeSNodeType
7919: oChoice 7923
7921: oJumpForward 7928
7923: Choice Lookup Table
          40   7921
7926: oError 11
7928: oTypeSTop
7929: oPushResult
7930: oSetResult 41
7932: oPushResult
7933: oNodeGet
7934: oPop 2
7936: oPushResult
7937: oScopeEnter
7938: oPop 1
7940: oInput 0
7942: oGetAddrLocal 1
7944: oPushResult
7945: oScopeFindRequire
7946: oAssign
7947: oGetLocal 1
7949: oPushResult
7950: oNodeType
7951: oPop 1
7953: oChoice 7957
7955: oJumpForward 7962
7957: Choice Lookup Table
          23   7955
7960: oError 12
7962: oScopeEnd
7963: oGetAddrLocal 2
7965: oPushResult
7966: oGetLocal 1
7968: oPushResult
7969: oSetResult 22
7971: oPushResult
7972: oNodeGetInt
7973: oPop 2
7975: oAssign
7976: oGetLocal 2
7978: oPushResult
7979: equal_zero
7980: oPop 1
7982: oChoice 7996
7984: oEmit 15
7986: oGetLocal 2
7988: oPushResult
7989: oEmitInt
7990: oPop 1
7992: oEmit 38
7994: oJumpForward 7999
7996: Choice Lookup Table
           0   7984
7999: oTypeSPop
8000: oGetLocal 1
8002: oPushResult
8003: oSetResult 21
8005: oPushResult
8006: oNodeGet
8007: oPop 2
8009: oPushResult
8010: oTypeSPush
8011: oPop 1
8013: oReturn
8014: oLocalSpace 2
8016: oGetAddrLocal 1
8018: oPushResult
8019: oTypeSTop
8020: oPushResult
8021: oSetResult 37
8023: oPushResult
8024: oNodeGet
8025: oPop 2
8027: oAssign
8028: oGetAddrLocal 2
8030: oPushResult
8031: oGetLocal 1
8033: oPushResult
8034: oSetResult 17
8036: oPushResult
8037: oNodeGetInt
8038: oPop 2
8040: oAssign
8041: oGetLocal 2
8043: oPushResult
8044: oSetResult 1
8046: oPushResult
8047: equal
8048: oPop 2
8050: oChoice 8064
8052: oEmit 15
8054: oGetLocal 2
8056: oPushResult
8057: oEmitInt
8058: oPop 1
8060: oEmit 36
8062: oJumpForward 8067
8064: Choice Lookup Table
           0   8052
8067: oEmit 38
8069: oReturn
8070: oLocalSpace 2
8072: oGetAddrLocal 1
8074: oPushResult
8075: oTypeSTop
8076: oPushResult
8077: oSetResult 37
8079: oPushResult
8080: oNodeGet
8081: oPop 2
8083: oAssign
8084: oGetAddrLocal 2
8086: oPushResult
8087: oGetLocal 1
8089: oPushResult
8090: oSetResult 17
8092: oPushResult
8093: oNodeGetInt
8094: oPop 2
8096: oAssign
8097: oGetLocal 2
8099: oPushResult
8100: oSetResult 1
8102: oPushResult
8103: equal
8104: oPop 2
8106: oChoice 8120
8108: oEmit 15
8110: oGetLocal 2
8112: oPushResult
8113: oEmitInt
8114: oPop 1
8116: oEmit 36
8118: oJumpForward 8123
8120: Choice Lookup Table
           0   8108
8123: oEmit 41
8125: oReturn
8126: oLocalSpace 2
8128: oEmit 40
8130: oGetAddrLocal 1
8132: oPushResult
8133: oTypeSTop
8134: oPushResult
8135: oSetResult 37
8137: oPushResult
8138: oNodeGet
8139: oPop 2
8141: oAssign
8142: oGetAddrLocal 2
8144: oPushResult
8145: oGetLocal 1
8147: oPushResult
8148: oSetResult 17
8150: oPushResult
8151: oNodeGetInt
8152: oPop 2
8154: oAssign
8155: oGetLocal 2
8157: oPushResult
8158: oSetResult 1
8160: oPushResult
8161: equal
8162: oPop 2
8164: oChoice 8178
8166: oEmit 15
8168: oGetLocal 2
8170: oPushResult
8171: oEmitInt
8172: oPop 1
8174: oEmit 37
8176: oJumpForward 8181
8178: Choice Lookup Table
           0   8166
8181: oTypeSPop
8182: oGetGlobal 6
8184: oPushResult
8185: oTypeSPush
8186: oPop 1
8188: oReturn
8189: oLocalSpace 1
8191: oTypeSNodeType
8192: oChoice 8200
8194: oJumpForward 8207
8196: oError 29
8198: oJumpForward 8207
8200: Choice Lookup Table
          37   8196
          36   8194
8205: oError 9
8207: oEmit 26
8209: oGetAddrLocal 1
8211: oPushResult
8212: oTypeSTop
8213: oAssign
8214: oTypeSPop
8215: oGetLocal 1
8217: oPushResult
8218: oSetResult 37
8220: oPushResult
8221: oNodeGet
8222: oPop 2
8224: oPushResult
8225: oTypeSPush
8226: oPop 1
8228: oReturn
8229: oLocalSpace 3
8231: oGetAddrLocal 1
8233: oPushResult
8234: oTypeSNodeType
8235: oAssign
8236: oGetAddrLocal 2
8238: oPushResult
8239: oTypeSTop
8240: oAssign
8241: oTypeSPop
8242: oGetLocal 1
8244: oPushResult
8245: oTypeSNodeType
8246: oPushResult
8247: equal_node_type
8248: oPop 2
8250: oChoice 8382
8252: oTypeSNodeType
8253: oChoice 8367
8255: oGetLocal 1
8257: oChoice 8264
8259: oEmit 32
8261: oReturn
8262: oJumpForward 8267
8264: Choice Lookup Table
          29   8259
8267: oJumpForward 8378
8269: oGetLocal 1
8271: oChoice 8278
8273: oEmit 33
8275: oReturn
8276: oJumpForward 8281
8278: Choice Lookup Table
          30   8273
8281: oJumpForward 8378
8283: oGetLocal 1
8285: oChoice 8318
8287: oReturn
8288: oJumpForward 8323
8290: oTypeSTop
8291: oPushResult
8292: oGetGlobal 10
8294: oPushResult
8295: equal_node
8296: oPop 2
8298: oChoice 8313
8300: oEmit 15
8302: oSetResult 1
8304: oPushResult
8305: oEmitInt
8306: oPop 1
8308: oEmit 38
8310: oReturn
8311: oJumpForward 8316
8313: Choice Lookup Table
           1   8300
8316: oJumpForward 8323
8318: Choice Lookup Table
          41   8290
          37   8287
8323: oJumpForward 8378
8325: oGetLocal 1
8327: oChoice 8332
8329: oReturn
8330: oJumpForward 8335
8332: Choice Lookup Table
          36   8329
8335: oJumpForward 8378
8337: oGetLocal 1
8339: oChoice 8360
8341: oReturn
8342: oJumpForward 8365
8344: oGetGlobal 9
8346: oPushResult
8347: oTypeSPush
8348: oPop 1
8350: oGetAddrLocal 3
8352: oPushResult
8353: oCall 10708
8355: oAssign
8356: oTypeSPop
8357: oReturn
8358: oJumpForward 8365
8360: Choice Lookup Table
          35   8344
          41   8341
8365: oJumpForward 8378
8367: Choice Lookup Table
          42   8337
          37   8325
          36   8283
          29   8269
          30   8255
8378: oError 14
8380: oJumpForward 8385
8382: Choice Lookup Table
           0   8252
8385: oReturn
8386: oLocalSpace 2
8388: oGetAddrLocal 1
8390: oPushResult
8391: oTypeSNodeType
8392: oAssign
8393: oTypeSPop
8394: oGetLocal 1
8396: oPushResult
8397: oTypeSNodeType
8398: oPushResult
8399: equal_node_type
8400: oPop 2
8402: oChoice 8562
8404: oTypeSNodeType
8405: oChoice 8541
8407: oGetLocal 1
8409: oChoice 8419
8411: oEmit 32
8413: oReturn
8414: oJumpForward 8430
8416: oReturn
8417: oJumpForward 8430
8419: Choice Lookup Table
          43   8416
          30   8416
          33   8411
          35   8411
          29   8411
8430: oJumpForward 8558
8432: oGetLocal 1
8434: oChoice 8444
8436: oReturn
8437: oJumpForward 8455
8439: oEmit 33
8441: oReturn
8442: oJumpForward 8455
8444: Choice Lookup Table
          43   8439
          30   8439
          33   8436
          35   8436
          29   8436
8455: oJumpForward 8558
8457: oGetLocal 1
8459: oChoice 8492
8461: oReturn
8462: oJumpForward 8497
8464: oTypeSTop
8465: oPushResult
8466: oGetGlobal 10
8468: oPushResult
8469: equal_node
8470: oPop 2
8472: oChoice 8487
8474: oEmit 15
8476: oSetResult 1
8478: oPushResult
8479: oEmitInt
8480: oPop 1
8482: oEmit 38
8484: oReturn
8485: oJumpForward 8490
8487: Choice Lookup Table
           1   8474
8490: oJumpForward 8497
8492: Choice Lookup Table
          41   8464
          37   8461
8497: oJumpForward 8558
8499: oGetLocal 1
8501: oChoice 8506
8503: oReturn
8504: oJumpForward 8509
8506: Choice Lookup Table
          36   8503
8509: oJumpForward 8558
8511: oGetLocal 1
8513: oChoice 8534
8515: oReturn
8516: oJumpForward 8539
8518: oGetGlobal 9
8520: oPushResult
8521: oTypeSPush
8522: oPop 1
8524: oGetAddrLocal 2
8526: oPushResult
8527: oCall 10708
8529: oAssign
8530: oTypeSPop
8531: oReturn
8532: oJumpForward 8539
8534: Choice Lookup Table
          35   8518
          41   8515
8539: oJumpForward 8558
8541: Choice Lookup Table
          42   8511
          37   8499
          36   8457
          33   8432
          35   8432
          29   8432
          43   8407
          30   8407
8558: oError 14
8560: oJumpForward 8565
8562: Choice Lookup Table
           0   8404
8565: oReturn
8566: oLocalSpace 1
8568: oGetAddrLocal 1
8570: oPushResult
8571: oTypeSNodeType
8572: oAssign
8573: oTypeSPop
8574: oGetLocal 1
8576: oPushResult
8577: oTypeSNodeType
8578: oPushResult
8579: equal_node_type
8580: oPop 2
8582: oChoice 8620
8584: oTypeSNodeType
8585: oChoice 8611
8587: oGetLocal 1
8589: oChoice 8594
8591: oReturn
8592: oJumpForward 8597
8594: Choice Lookup Table
          37   8591
8597: oJumpForward 8616
8599: oGetLocal 1
8601: oChoice 8606
8603: oReturn
8604: oJumpForward 8609
8606: Choice Lookup Table
          36   8603
8609: oJumpForward 8616
8611: Choice Lookup Table
          37   8599
          36   8587
8616: oError 14
8618: oJumpForward 8623
8620: Choice Lookup Table
           0   8584
8623: oReturn
8624: oLocalSpace 0
8626: oTypeSNodeType
8627: oChoice 8631
8629: oJumpForward 8636
8631: Choice Lookup Table
          30   8629
8634: oError 7
8636: oTypeSPop
8637: oReturn
8638: oLocalSpace 0
8640: oTypeSNodeType
8641: oChoice 8645
8643: oJumpForward 8650
8645: Choice Lookup Table
          30   8643
8648: oError 7
8650: oReturn
8651: oLocalSpace 0
8653: oTypeSNodeType
8654: oChoice 8662
8656: oJumpForward 8669
8658: oEmit 32
8660: oJumpForward 8669
8662: Choice Lookup Table
          29   8658
          30   8656
8667: oError 7
8669: oTypeSPop
8670: oReturn
8671: oLocalSpace 0
8673: oTypeSNodeType
8674: oChoice 8689
8676: oJumpForward 8696
8678: oEmit 32
8680: oTypeSPop
8681: oGetGlobal 6
8683: oPushResult
8684: oTypeSPush
8685: oPop 1
8687: oJumpForward 8696
8689: Choice Lookup Table
          29   8678
          30   8676
8694: oError 7
8696: oReturn
8697: oLocalSpace 0
8699: oTypeSNodeType
8700: oChoice 8713
8702: oEmit 32
8704: oTypeSPop
8705: oGetGlobal 6
8707: oPushResult
8708: oTypeSPush
8709: oPop 1
8711: oJumpForward 8716
8713: Choice Lookup Table
          29   8702
8716: oReturn
8717: oLocalSpace 0
8719: oTypeSNodeType
8720: oChoice 8724
8722: oJumpForward 8729
8724: Choice Lookup Table
          33   8722
8727: oError 8
8729: oTypeSPop
8730: oReturn
8731: oLocalSpace 0
8733: oTypeSNodeType
8734: oChoice 8738
8736: oJumpForward 8743
8738: Choice Lookup Table
          33   8736
8741: oError 8
8743: oReturn
8744: oLocalSpace 0
8746: oInputChoice 8809
8748: oCall 10481
8750: oJumpForward 8840
8752: oCall 10488
8754: oJumpForward 8840
8756: oCall 10618
8758: oJumpForward 8840
8760: oCall 10625
8762: oJumpForward 8840
8764: oCall 9632
8766: oJumpForward 8840
8768: oCall 9955
8770: oJumpForward 8840
8772: oCall 9698
8774: oJumpForward 8840
8776: oCall 9875
8778: oJumpForward 8840
8780: oCall 10040
8782: oJumpForward 8840
8784: oCall 10008
8786: oJumpForward 8840
8788: oCall 10458
8790: oJumpForward 8840
8792: oCall 8841
8794: oJumpForward 8840
8796: oCall 10072
8798: oJumpForward 8840
8800: oCall 10406
8802: oJumpForward 8840
8804: oChangeIntLitToLabelIdent
8805: oCall 8841
8807: oJumpForward 8840
8809: Choice Lookup Table
           1   8804
          56   8800
          54   8796
           0   8792
          36   8788
          52   8784
          53   8780
          50   8776
          45   8772
          49   8768
          42   8764
          69   8760
          68   8756
          67   8752
          66   8748
8840: oReturn
8841: oLocalSpace 1
8843: oGetAddrLocal 1
8845: oPushResult
8846: oScopeFindRequire
8847: oAssign
8848: oGetAddrLocal 1
8850: oPushResult
8851: oCall 244
8853: oPop 1
8855: oGetLocal 1
8857: oPushResult
8858: oNodeType
8859: oPop 1
8861: oChoice 8901
8863: oGetLocal 1
8865: oPushResult
8866: oCall 8919
8868: oPop 1
8870: oCall 8744
8872: oJumpForward 8918
8874: oGetLocal 1
8876: oPushResult
8877: oCall 11020
8879: oPop 1
8881: oJumpForward 8918
8883: oGetLocal 1
8885: oPushResult
8886: oCall 8969
8888: oPop 1
8890: oJumpForward 8918
8892: oGetLocal 1
8894: oPushResult
8895: oCall 9065
8897: oPop 1
8899: oJumpForward 8918
8901: Choice Lookup Table
          13   8892
          19   8883
          24   8883
          22   8883
          21   8883
          12   8874
          26   8863
8916: oError 0
8918: oReturn
8919: oLocalSpace 0
8921: oGetParam 1
8923: oPushResult
8924: oSetResult 35
8926: oPushResult
8927: oNodeGetBoolean
8928: oPop 2
8930: oChoice 8936
8932: oError 21
8934: oJumpForward 8939
8936: Choice Lookup Table
           1   8932
8939: oEmit 79
8941: oGetParam 1
8943: oPushResult
8944: oSetResult 22
8946: oPushResult
8947: oNodeGetLabel
8948: oPop 2
8950: oPushResult
8951: oEmitLabel
8952: oPop 1
8954: oGetParam 1
8956: oPushResult
8957: oSetResult 35
8959: oPushResult
8960: oSetResult 1
8962: oPushResult
8963: oNodeSetBoolean
8964: oPop 3
8966: oInput 13
8968: oReturn
8969: oLocalSpace 0
8971: oGetParam 1
8973: oPushResult
8974: oSetResult 1
8976: oPushResult
8977: oCall 9225
8979: oPop 2
8981: oInput 5
8983: oCall 4887
8985: oCall 8229
8987: oCall 8990
8989: oReturn
8990: oLocalSpace 1
8992: oTypeSNodeType
8993: oChoice 9037
8995: oEmit 27
8997: oJumpForward 9063
8999: oEmit 28
9001: oJumpForward 9063
9003: oEmit 30
9005: oJumpForward 9063
9007: oError 16
9009: oJumpForward 9063
9011: oEmit 29
9013: oJumpForward 9063
9015: oGetAddrLocal 1
9017: oPushResult
9018: oTypeSTop
9019: oPushResult
9020: oSetResult 17
9022: oPushResult
9023: oNodeGetInt
9024: oPop 2
9026: oAssign
9027: oEmit 31
9029: oGetLocal 1
9031: oPushResult
9032: oEmitInt
9033: oPop 1
9035: oJumpForward 9063
9037: Choice Lookup Table
          42   9015
          40   9015
          38   9015
          37   9011
          36   9011
          28   9007
          32   9003
          35   8999
          29   8999
          33   8999
          43   8995
          30   8995
9062: oEndChoice
9063: oTypeSPop
9064: oReturn
9065: oLocalSpace 1
9067: oGetParam 1
9069: oPushResult
9070: oSetResult 6
9072: oPushResult
9073: oNodeGet
9074: oPop 2
9076: oPushResult
9077: oScopeCurrent
9078: oPushResult
9079: oNodeEqual
9080: oPop 2
9082: oChoice 9088
9084: oError 20
9086: oJumpForward 9091
9088: Choice Lookup Table
           0   9084
9091: oEmit 8
9093: oGetParam 1
9095: oPushResult
9096: oSetResult 31
9098: oPushResult
9099: oNodeGetInt
9100: oPop 2
9102: oPushResult
9103: oEmitInt
9104: oPop 1
9106: oGetParam 1
9108: oPushResult
9109: oSetResult 21
9111: oPushResult
9112: oNodeGet
9113: oPop 2
9115: oPushResult
9116: oTypeSPush
9117: oPop 1
9119: oInput 5
9121: oCall 4887
9123: oCall 8229
9125: oTypeSNodeType
9126: oChoice 9170
9128: oEmit 27
9130: oJumpForward 9196
9132: oEmit 28
9134: oJumpForward 9196
9136: oEmit 30
9138: oJumpForward 9196
9140: oError 16
9142: oJumpForward 9196
9144: oEmit 29
9146: oJumpForward 9196
9148: oGetAddrLocal 1
9150: oPushResult
9151: oTypeSTop
9152: oPushResult
9153: oSetResult 17
9155: oPushResult
9156: oNodeGetInt
9157: oPop 2
9159: oAssign
9160: oEmit 31
9162: oGetLocal 1
9164: oPushResult
9165: oEmitInt
9166: oPop 1
9168: oJumpForward 9196
9170: Choice Lookup Table
          42   9148
          40   9148
          38   9148
          37   9144
          36   9144
          28   9140
          32   9136
          35   9132
          29   9132
          33   9132
          43   9128
          30   9128
9195: oEndChoice
9196: oTypeSPop
9197: oReturn
9198: oLocalSpace 1
9200: oInput 0
9202: oGetAddrLocal 1
9204: oPushResult
9205: oScopeFindRequire
9206: oAssign
9207: oGetAddrLocal 1
9209: oPushResult
9210: oCall 244
9212: oPop 1
9214: oGetLocal 1
9216: oPushResult
9217: oGetParam 1
9219: oPushResult
9220: oCall 9225
9222: oPop 2
9224: oReturn
9225: oLocalSpace 0
9227: oGetParam 2
9229: oPushResult
9230: oNodeType
9231: oPop 1
9233: oChoice 9296
9235: oGetParam 2
9237: oPushResult
9238: oGetParam 1
9240: oPushResult
9241: oCall 9442
9243: oPop 2
9245: oJumpForward 9309
9247: oGetParam 2
9249: oPushResult
9250: oSetResult 21
9252: oPushResult
9253: oNodeGet
9254: oPop 2
9256: oPushResult
9257: oTypeSPush
9258: oPop 1
9260: oInput 15
9262: oGetParam 1
9264: oPushResult
9265: oCall 9198
9267: oPop 1
9269: oInput 16
9271: oCall 9310
9273: oTypeSNodeType
9274: oChoice 9289
9276: oInputChoice 9284
9278: oEmit 26
9280: oCall 7807
9282: oJumpForward 9287
9284: Choice Lookup Table
          17   9278
9287: oJumpForward 9292
9289: Choice Lookup Table
          36   9276
9292: oCall 7612
9294: oJumpForward 9309
9296: Choice Lookup Table
          19   9247
          25   9235
          24   9235
          22   9235
          21   9235
9307: oError 4
9309: oReturn
9310: oLocalSpace 1
9312: oGetAddrLocal 1
9314: oPushResult
9315: oTypeSNodeType
9316: oAssign
9317: oTypeSPop
9318: oGetLocal 1
9320: oPushResult
9321: oTypeSNodeType
9322: oPushResult
9323: equal_node_type
9324: oPop 2
9326: oChoice 9438
9328: oTypeSNodeType
9329: oChoice 9417
9331: oGetLocal 1
9333: oChoice 9343
9335: oError 30
9337: oReturn
9338: oJumpForward 9354
9340: oReturn
9341: oJumpForward 9354
9343: Choice Lookup Table
          43   9340
          30   9340
          33   9335
          35   9335
          29   9335
9354: oJumpForward 9434
9356: oGetLocal 1
9358: oChoice 9368
9360: oReturn
9361: oJumpForward 9379
9363: oError 30
9365: oReturn
9366: oJumpForward 9379
9368: Choice Lookup Table
          43   9363
          30   9363
          33   9360
          35   9360
          29   9360
9379: oJumpForward 9434
9381: oGetLocal 1
9383: oChoice 9388
9385: oReturn
9386: oJumpForward 9391
9388: Choice Lookup Table
          37   9385
9391: oJumpForward 9434
9393: oGetLocal 1
9395: oChoice 9400
9397: oReturn
9398: oJumpForward 9403
9400: Choice Lookup Table
          36   9397
9403: oJumpForward 9434
9405: oGetLocal 1
9407: oChoice 9412
9409: oReturn
9410: oJumpForward 9415
9412: Choice Lookup Table
          41   9409
9415: oJumpForward 9434
9417: Choice Lookup Table
          42   9405
          37   9393
          36   9381
          33   9356
          35   9356
          29   9356
          43   9331
          30   9331
9434: oError 14
9436: oJumpForward 9441
9438: Choice Lookup Table
           0   9328
9441: oReturn
9442: oLocalSpace 0
9444: oGetParam 2
9446: oPushResult
9447: oNodeType
9448: oPop 1
9450: oChoice 9532
9452: oEmit 17
9454: oGetParam 2
9456: oPushResult
9457: oCall 14059
9459: oPop 1
9461: oJumpForward 9543
9463: oEmit 18
9465: oGetParam 2
9467: oPushResult
9468: oCall 14059
9470: oPop 1
9472: oJumpForward 9543
9474: oGetParam 2
9476: oPushResult
9477: oSetResult 34
9479: oPushResult
9480: oNodeGetBoolean
9481: oPop 2
9483: oChoice 9496
9485: oEmit 8
9487: oGetParam 2
9489: oPushResult
9490: oCall 14059
9492: oPop 1
9494: oJumpForward 9508
9496: Choice Lookup Table
           1   9485
9499: oEmit 19
9501: oGetParam 2
9503: oPushResult
9504: oCall 14059
9506: oPop 1
9508: oJumpForward 9543
9510: oGetParam 1
9512: oChoice 9525
9514: oEmit 17
9516: oGetParam 2
9518: oPushResult
9519: oCall 14059
9521: oPop 1
9523: oJumpForward 9530
9525: Choice Lookup Table
           0   9514
9528: oError 4
9530: oJumpForward 9543
9532: Choice Lookup Table
          25   9510
          24   9474
          22   9463
          21   9452
9541: oError 4
9543: oGetParam 2
9545: oPushResult
9546: oSetResult 21
9548: oPushResult
9549: oNodeGet
9550: oPop 2
9552: oPushResult
9553: oTypeSPush
9554: oPop 1
9556: oTypeSNodeType
9557: oChoice 9572
9559: oInputChoice 9567
9561: oEmit 26
9563: oCall 7807
9565: oJumpForward 9570
9567: Choice Lookup Table
          17   9561
9570: oJumpForward 9575
9572: Choice Lookup Table
          36   9559
9575: oCall 7612
9577: oReturn
9578: oLocalSpace 0
9580: oGetParam 1
9582: oPushResult
9583: oSetResult 1
9585: oPushResult
9586: oCall 9442
9588: oPop 2
9590: oCall 8624
9592: oGetParam 1
9594: oPushResult
9595: oCall 6799
9597: oPop 1
9599: oTypeSPop
9600: oEmit 34
9602: oEmit 27
9604: oReturn
9605: oLocalSpace 0
9607: oGetParam 1
9609: oPushResult
9610: oSetResult 1
9612: oPushResult
9613: oCall 9442
9615: oPop 2
9617: oCall 8624
9619: oGetParam 1
9621: oPushResult
9622: oCall 6799
9624: oPop 1
9626: oTypeSPop
9627: oEmit 35
9629: oEmit 27
9631: oReturn
9632: oLocalSpace 2
9634: oGetAddrLocal 1
9636: oPushResult
9637: oSetResult 0
9639: oAssign
9640: oGetAddrLocal 1
9642: oPushResult
9643: oCall 4933
9645: oPop 1
9647: oInput 43
9649: oCall 8744
9651: oInputChoice 9686
9653: oGetAddrLocal 2
9655: oPushResult
9656: oLabelNew
9657: oAssign
9658: oEmit 70
9660: oGetLocal 2
9662: oPushResult
9663: oEmitLabel
9664: oPop 1
9666: oEmit 79
9668: oGetLocal 1
9670: oPushResult
9671: oEmitLabel
9672: oPop 1
9674: oCall 8744
9676: oEmit 79
9678: oGetLocal 2
9680: oPushResult
9681: oEmitLabel
9682: oPop 1
9684: oJumpForward 9697
9686: Choice Lookup Table
          44   9653
9689: oEmit 79
9691: oGetLocal 1
9693: oPushResult
9694: oEmitLabel
9695: oPop 1
9697: oReturn
9698: oLocalSpace 4
9700: oInput 0
9702: oGetAddrLocal 1
9704: oPushResult
9705: oScopeFindRequire
9706: oAssign
9707: oGetLocal 1
9709: oPushResult
9710: oSetResult 1
9712: oPushResult
9713: oCall 9442
9715: oPop 2
9717: oCall 8624
9719: oInput 5
9721: oCall 4887
9723: oCall 8624
9725: oEmit 27
9727: oGetAddrLocal 2
9729: oPushResult
9730: oLabelNew
9731: oAssign
9732: oGetAddrLocal 3
9734: oPushResult
9735: oLabelNew
9736: oAssign
9737: oEmit 70
9739: oGetLocal 3
9741: oPushResult
9742: oEmitLabel
9743: oPop 1
9745: oGetAddrLocal 4
9747: oPushResult
9748: oLabelNew
9749: oAssign
9750: oEmit 79
9752: oGetLocal 4
9754: oPushResult
9755: oEmitLabel
9756: oPop 1
9758: oInputChoice 9838
9760: oGetLocal 1
9762: oPushResult
9763: oCall 9578
9765: oPop 1
9767: oEmit 79
9769: oGetLocal 3
9771: oPushResult
9772: oEmitLabel
9773: oPop 1
9775: oGetLocal 1
9777: oPushResult
9778: oCall 6799
9780: oPop 1
9782: oTypeSPop
9783: oCall 4887
9785: oCall 8624
9787: oEmit 53
9789: oEmit 71
9791: oGetLocal 2
9793: oPushResult
9794: oEmitLabel
9795: oPop 1
9797: oJumpForward 9844
9799: oGetLocal 1
9801: oPushResult
9802: oCall 9605
9804: oPop 1
9806: oEmit 79
9808: oGetLocal 3
9810: oPushResult
9811: oEmitLabel
9812: oPop 1
9814: oGetLocal 1
9816: oPushResult
9817: oCall 6799
9819: oPop 1
9821: oTypeSPop
9822: oCall 4887
9824: oCall 8624
9826: oEmit 54
9828: oEmit 71
9830: oGetLocal 2
9832: oPushResult
9833: oEmitLabel
9834: oPop 1
9836: oJumpForward 9844
9838: Choice Lookup Table
          47   9799
          46   9760
9843: oEndChoice
9844: oGetLocal 4
9846: oPushResult
9847: oGetLocal 2
9849: oPushResult
9850: oLoopPush
9851: oPop 2
9853: oInput 48
9855: oCall 8744
9857: oEmit 70
9859: oGetLocal 4
9861: oPushResult
9862: oEmitLabel
9863: oPop 1
9865: oEmit 79
9867: oGetLocal 2
9869: oPushResult
9870: oEmitLabel
9871: oPop 1
9873: oLoopPop
9874: oReturn
9875: oLocalSpace 3
9877: oGetAddrLocal 1
9879: oPushResult
9880: oLabelNew
9881: oAssign
9882: oEmit 79
9884: oGetLocal 1
9886: oPushResult
9887: oEmitLabel
9888: oPop 1
9890: oGetAddrLocal 2
9892: oPushResult
9893: oLabelNew
9894: oAssign
9895: oGetLocal 1
9897: oPushResult
9898: oGetLocal 2
9900: oPushResult
9901: oLoopPush
9902: oPop 2
9904: oCall 8744
9906: oInputChoice 9937
9908: oCall 8744
9910: oJumpForward 9943
9912: oGetAddrLocal 3
9914: oPushResult
9915: oCall 4933
9917: oPop 1
9919: oEmit 80
9921: oGetLocal 3
9923: oPushResult
9924: oEmitLabel
9925: oPop 1
9927: oGetLocal 1
9929: oPushResult
9930: oEmitLabel
9931: oPop 1
9933: oJumpForward 9945
9935: oJumpForward 9943
9937: Choice Lookup Table
          51   9912
           6   9908
9942: oEndChoice
9943: oJumpBack 9906
9945: oEmit 79
9947: oGetLocal 2
9949: oPushResult
9950: oEmitLabel
9951: oPop 1
9953: oLoopPop
9954: oReturn
9955: oLocalSpace 2
9957: oGetAddrLocal 1
9959: oPushResult
9960: oLabelNew
9961: oAssign
9962: oEmit 79
9964: oGetLocal 1
9966: oPushResult
9967: oEmitLabel
9968: oPop 1
9970: oGetAddrLocal 2
9972: oPushResult
9973: oCall 4933
9975: oPop 1
9977: oGetLocal 1
9979: oPushResult
9980: oGetLocal 2
9982: oPushResult
9983: oLoopPush
9984: oPop 2
9986: oInput 48
9988: oCall 8744
9990: oEmit 70
9992: oGetLocal 1
9994: oPushResult
9995: oEmitLabel
9996: oPop 1
9998: oEmit 79
10000: oGetLocal 2
10002: oPushResult
10003: oEmitLabel
10004: oPop 1
10006: oLoopPop
10007: oReturn
10008: oLocalSpace 0
10010: oLoopContinueLabel
10011: oPushResult
10012: oSetResult 0
10014: oPushResult
10015: equal_label
10016: oPop 2
10018: oChoice 10033
10020: oError 18
10022: oJumpForward 10039
10024: oEmit 70
10026: oLoopContinueLabel
10027: oPushResult
10028: oEmitLabel
10029: oPop 1
10031: oJumpForward 10039
10033: Choice Lookup Table
           0   10024
           1   10020
10038: oEndChoice
10039: oReturn
10040: oLocalSpace 0
10042: oLoopBreakLabel
10043: oPushResult
10044: oSetResult 0
10046: oPushResult
10047: equal_label
10048: oPop 2
10050: oChoice 10065
10052: oError 18
10054: oJumpForward 10071
10056: oEmit 70
10058: oLoopBreakLabel
10059: oPushResult
10060: oEmitLabel
10061: oPop 1
10063: oJumpForward 10071
10065: Choice Lookup Table
           0   10056
           1   10052
10070: oEndChoice
10071: oReturn
10072: oLocalSpace 8
10074: oGetAddrLocal 1
10076: oPushResult
10077: oCodeNew
10078: oAssign
10079: oGetAddrLocal 2
10081: oPushResult
10082: oLabelNew
10083: oAssign
10084: oGetAddrLocal 3
10086: oPushResult
10087: oLabelNew
10088: oAssign
10089: oGetAddrLocal 4
10091: oPushResult
10092: oGetLocal 3
10094: oAssign
10095: oGetAddrLocal 5
10097: oPushResult
10098: oSetResult 0
10100: oAssign
10101: oCall 4887
10103: oTypeSNodeType
10104: oChoice 10142
10106: oEmit 73
10108: oGetLocal 2
10110: oPushResult
10111: oEmitLabel
10112: oPop 1
10114: oJumpForward 10159
10116: oEmit 74
10118: oGetLocal 2
10120: oPushResult
10121: oEmitLabel
10122: oPop 1
10124: oJumpForward 10159
10126: oGetAddrLocal 5
10128: oPushResult
10129: oSetResult 1
10131: oAssign
10132: oEmit 75
10134: oGetLocal 2
10136: oPushResult
10137: oEmitLabel
10138: oPop 1
10140: oJumpForward 10159
10142: Choice Lookup Table
          41   10126
          42   10126
          43   10116
          30   10116
          35   10106
          29   10106
          33   10106
10157: oError 17
10159: oInput 41
10161: oInputChoice 10208
10163: oGetAddrLocal 4
10165: oPushResult
10166: oLabelNew
10167: oAssign
10168: oEmit 79
10170: oGetLocal 4
10172: oPushResult
10173: oEmitLabel
10174: oPop 1
10176: oInputChoice 10182
10178: oJumpForward 10200
10180: oJumpForward 10198
10182: Choice Lookup Table
          37   10178
10185: oCall 8744
10187: oInputChoice 10191
10189: oJumpForward 10198
10191: Choice Lookup Table
           6   10189
10194: oInput 37
10196: oJumpForward 10200
10198: oJumpBack 10176
10200: oJumpForward 10374
10202: oJumpForward 10372
10204: oJumpForward 10374
10206: oJumpForward 10372
10208: Choice Lookup Table
          37   10204
          44   10163
          55   10163
10215: oGetAddrLocal 6
10217: oPushResult
10218: oLabelNew
10219: oAssign
10220: oGetLocal 1
10222: oPushResult
10223: oCodePush
10224: oPop 1
10226: oCall 3539
10228: oCall 4351
10230: oGetLocal 5
10232: oChoice 10252
10234: oGetAddrLocal 7
10236: oPushResult
10237: oValueTopString
10238: oPushResult
10239: oStringAllocShortStringLit
10240: oPop 1
10242: oAssign
10243: oJumpForward 10258
10245: oGetAddrLocal 7
10247: oPushResult
10248: oValueTop
10249: oAssign
10250: oJumpForward 10258
10252: Choice Lookup Table
           0   10245
           1   10234
10257: oEndChoice
10258: oValuePop
10259: oInputChoice 10316
10261: oCall 3539
10263: oCall 4351
10265: oGetLocal 5
10267: oChoice 10287
10269: oGetAddrLocal 8
10271: oPushResult
10272: oValueTopString
10273: oPushResult
10274: oStringAllocShortStringLit
10275: oPop 1
10277: oAssign
10278: oJumpForward 10293
10280: oGetAddrLocal 8
10282: oPushResult
10283: oValueTop
10284: oAssign
10285: oJumpForward 10293
10287: Choice Lookup Table
           0   10280
           1   10269
10292: oEndChoice
10293: oValuePop
10294: oEmit 77
10296: oGetLocal 7
10298: oPushResult
10299: oEmitInt
10300: oPop 1
10302: oGetLocal 8
10304: oPushResult
10305: oEmitInt
10306: oPop 1
10308: oGetLocal 6
10310: oPushResult
10311: oEmitLabel
10312: oPop 1
10314: oJumpForward 10333
10316: Choice Lookup Table
          22   10261
10319: oEmit 76
10321: oGetLocal 7
10323: oPushResult
10324: oEmitInt
10325: oPop 1
10327: oGetLocal 6
10329: oPushResult
10330: oEmitLabel
10331: oPop 1
10333: oInputChoice 10337
10335: oJumpForward 10342
10337: Choice Lookup Table
          14   10335
10340: oJumpForward 10344
10342: oJumpBack 10226
10344: oCodePop
10345: oInput 13
10347: oEmit 79
10349: oGetLocal 6
10351: oPushResult
10352: oEmitLabel
10353: oPop 1
10355: oCall 8744
10357: oEmit 70
10359: oGetLocal 3
10361: oPushResult
10362: oEmitLabel
10363: oPop 1
10365: oInputChoice 10369
10367: oJumpForward 10372
10369: Choice Lookup Table
           6   10367
10372: oJumpBack 10161
10374: oEmit 79
10376: oGetLocal 2
10378: oPushResult
10379: oEmitLabel
10380: oPop 1
10382: oGetLocal 1
10384: oPushResult
10385: oEmitCode
10386: oPop 1
10388: oEmit 78
10390: oGetLocal 4
10392: oPushResult
10393: oEmitLabel
10394: oPop 1
10396: oEmit 79
10398: oGetLocal 3
10400: oPushResult
10401: oEmitLabel
10402: oPop 1
10404: oTypeSPop
10405: oReturn
10406: oLocalSpace 1
10408: oInputChoice 10415
10410: oJumpForward 10421
10412: oChangeIntLitToLabelIdent
10413: oJumpForward 10421
10415: Choice Lookup Table
           1   10412
           0   10410
10420: oEndChoice
10421: oGetAddrLocal 1
10423: oPushResult
10424: oScopeCurrent
10425: oPushResult
10426: oScopeFindRequireInScope
10427: oPop 1
10429: oAssign
10430: oGetLocal 1
10432: oPushResult
10433: oSetResult 28
10435: oPushResult
10436: oSetResult 1
10438: oPushResult
10439: oNodeSetBoolean
10440: oPop 3
10442: oEmit 70
10444: oGetLocal 1
10446: oPushResult
10447: oSetResult 22
10449: oPushResult
10450: oNodeGetLabel
10451: oPop 2
10453: oPushResult
10454: oEmitLabel
10455: oPop 1
10457: oReturn
10458: oLocalSpace 0
10460: oCall 8744
10462: oInputChoice 10472
10464: oCall 8744
10466: oJumpForward 10478
10468: oJumpForward 10480
10470: oJumpForward 10478
10472: Choice Lookup Table
          37   10468
           6   10464
10477: oEndChoice
10478: oJumpBack 10462
10480: oReturn
10481: oLocalSpace 0
10483: oCall 10488
10485: oEmit 90
10487: oReturn
10488: oLocalSpace 0
10490: oInputChoice 10614
10492: oCall 4887
10494: oTypeSNodeType
10495: oChoice 10570
10497: oEmit 82
10499: oJumpForward 10595
10501: oEmit 83
10503: oJumpForward 10595
10505: oEmit 32
10507: oEmit 82
10509: oJumpForward 10595
10511: oEmit 84
10513: oJumpForward 10595
10515: oEmit 89
10517: oJumpForward 10595
10519: oEmit 85
10521: oJumpForward 10595
10523: oError 16
10525: oJumpForward 10595
10527: oEmit 17
10529: oTypeSTop
10530: oPushResult
10531: oSetResult 43
10533: oPushResult
10534: oNodeGetInt
10535: oPop 2
10537: oPushResult
10538: oEmitInt
10539: oPop 1
10541: oEmit 88
10543: oJumpForward 10595
10545: oTypeSTop
10546: oPushResult
10547: oGetGlobal 10
10549: oPushResult
10550: equal_node
10551: oPop 2
10553: oChoice 10559
10555: oEmit 86
10557: oJumpForward 10564
10559: Choice Lookup Table
           1   10555
10562: oEmit 87
10564: oJumpForward 10595
10566: oEmit 87
10568: oJumpForward 10595
10570: Choice Lookup Table
          37   10566
          36   10545
          43   10527
          28   10523
          41   10519
          42   10519
          32   10515
          35   10511
          29   10505
          33   10501
          30   10497
10593: oError 17
10595: oTypeSPop
10596: oInputChoice 10604
10598: oJumpForward 10612
10600: oJumpForward 10610
10602: oJumpForward 10610
10604: Choice Lookup Table
          14   10602
          16   10598
10609: oEndChoice
10610: oJumpBack 10492
10612: oJumpForward 10617
10614: Choice Lookup Table
          15   10492
10617: oReturn
10618: oLocalSpace 0
10620: oCall 10625
10622: oEmit 94
10624: oReturn
10625: oLocalSpace 1
10627: oInputChoice 10704
10629: oSetResult 1
10631: oPushResult
10632: oCall 9198
10634: oPop 1
10636: oTypeSNodeType
10637: oChoice 10676
10639: oEmit 91
10641: oJumpForward 10685
10643: oEmit 92
10645: oJumpForward 10685
10647: oGetAddrLocal 1
10649: oPushResult
10650: oTypeSTop
10651: oPushResult
10652: oSetResult 17
10654: oPushResult
10655: oNodeGetInt
10656: oPop 2
10658: oPushResult
10659: oSetResult 1
10661: oPushResult
10662: subtract
10663: oPop 2
10665: oAssign
10666: oEmit 93
10668: oGetLocal 1
10670: oPushResult
10671: oEmitInt
10672: oPop 1
10674: oJumpForward 10685
10676: Choice Lookup Table
          42   10647
          35   10643
          30   10639
10683: oError 17
10685: oTypeSPop
10686: oInputChoice 10694
10688: oJumpForward 10702
10690: oJumpForward 10700
10692: oJumpForward 10700
10694: Choice Lookup Table
          14   10692
          16   10688
10699: oEndChoice
10700: oJumpBack 10629
10702: oJumpForward 10707
10704: Choice Lookup Table
          15   10629
10707: oReturn
10708: oLocalSpace 1
10710: oGetAddrLocal 1
10712: oPushResult
10713: oGetGlobal 16
10715: oPushResult
10716: oScopeAllocType
10717: oPop 1
10719: oAssign
10720: oTypeSNodeType
10721: oChoice 10789
10723: oEmit 18
10725: oGetLocal 1
10727: oPushResult
10728: oEmitInt
10729: oPop 1
10731: oEmit 23
10733: oEmit 31
10735: oGetGlobal 16
10737: oPushResult
10738: oSetResult 17
10740: oPushResult
10741: oNodeGetInt
10742: oPop 2
10744: oPushResult
10745: oEmitInt
10746: oPop 1
10748: oJumpForward 10798
10750: oEmit 18
10752: oGetLocal 1
10754: oPushResult
10755: oEmitInt
10756: oPop 1
10758: oEmit 15
10760: oSetResult 1
10762: oPushResult
10763: oEmitInt
10764: oPop 1
10766: oEmit 28
10768: oEmit 18
10770: oGetLocal 1
10772: oPushResult
10773: oSetResult 1
10775: oPushResult
10776: add
10777: oPop 2
10779: oPushResult
10780: oEmitInt
10781: oPop 1
10783: oEmit 23
10785: oEmit 28
10787: oJumpForward 10798
10789: Choice Lookup Table
          35   10750
          41   10723
          42   10723
10796: oError 14
10798: oTypeSPop
10799: oEmit 18
10801: oGetLocal 1
10803: oPushResult
10804: oEmitInt
10805: oPop 1
10807: oGetGlobal 16
10809: oPushResult
10810: oTypeSPush
10811: oPop 1
10813: oGetLocal 1
10815: oReturn
10816: oReturn
10817: oLocalSpace 0
10819: oEmit 63
10821: oSetResult 16
10823: oPushResult
10824: oEmitInt
10825: oPop 1
10827: oEmit 20
10829: oSetResult 8
10831: oPushResult
10832: oEmitInt
10833: oPop 1
10835: oEmit 23
10837: oEmit 29
10839: oEmit 20
10841: oSetResult 0
10843: oPushResult
10844: oEmitInt
10845: oPop 1
10847: oEmit 23
10849: oEmit 29
10851: oEmit 66
10853: oGetGlobal 22
10855: oPushResult
10856: oCall 14059
10858: oPop 1
10860: oEmit 65
10862: oSetResult 16
10864: oPushResult
10865: oEmitInt
10866: oPop 1
10868: oTypeSPop
10869: oTypeSPop
10870: oReturn
10871: oLocalSpace 0
10873: oEmit 63
10875: oSetResult 12
10877: oPushResult
10878: oEmitInt
10879: oPop 1
10881: oEmit 20
10883: oSetResult 8
10885: oPushResult
10886: oEmitInt
10887: oPop 1
10889: oEmit 23
10891: oEmit 28
10893: oEmit 20
10895: oSetResult 0
10897: oPushResult
10898: oEmitInt
10899: oPop 1
10901: oEmit 23
10903: oEmit 29
10905: oEmit 66
10907: oGetGlobal 23
10909: oPushResult
10910: oCall 14059
10912: oPop 1
10914: oEmit 65
10916: oSetResult 12
10918: oPushResult
10919: oEmitInt
10920: oPop 1
10922: oTypeSPop
10923: oTypeSPop
10924: oReturn
10925: oLocalSpace 1
10927: oEmit 64
10929: oSetResult 24
10931: oPushResult
10932: oEmitInt
10933: oPop 1
10935: oEmit 20
10937: oSetResult 8
10939: oPushResult
10940: oEmitInt
10941: oPop 1
10943: oEmit 23
10945: oEmit 29
10947: oEmit 20
10949: oSetResult 0
10951: oPushResult
10952: oEmitInt
10953: oPop 1
10955: oEmit 23
10957: oEmit 29
10959: oGetAddrLocal 1
10961: oPushResult
10962: oGetGlobal 6
10964: oPushResult
10965: oScopeAllocType
10966: oPop 1
10968: oAssign
10969: oEmit 20
10971: oSetResult 16
10973: oPushResult
10974: oEmitInt
10975: oPop 1
10977: oEmit 18
10979: oGetLocal 1
10981: oPushResult
10982: oEmitInt
10983: oPop 1
10985: oEmit 29
10987: oEmit 67
10989: oGetGlobal 24
10991: oPushResult
10992: oCall 14059
10994: oPop 1
10996: oEmit 3
10998: oGetLocal 1
11000: oPushResult
11001: oEmitInt
11002: oPop 1
11004: oEmit 65
11006: oSetResult 24
11008: oPushResult
11009: oEmitInt
11010: oPop 1
11012: oTypeSPop
11013: oGetGlobal 6
11015: oPushResult
11016: oTypeSPush
11017: oPop 1
11019: oReturn
11020: oLocalSpace 10
11022: oGetParam 1
11024: oPushResult
11025: oSetResult 28
11027: oPushResult
11028: oSetResult 1
11030: oPushResult
11031: oNodeSetBoolean
11032: oPop 3
11034: oGetAddrLocal 1
11036: oPushResult
11037: oGetParam 1
11039: oPushResult
11040: oSetResult 27
11042: oPushResult
11043: oNodeGetBoolean
11044: oPop 2
11046: oAssign
11047: oGetAddrLocal 4
11049: oPushResult
11050: oGetParam 1
11052: oPushResult
11053: oNodeType
11054: oPop 1
11056: oPushResult
11057: oSetResult 13
11059: oPushResult
11060: equal_node_type
11061: oPop 2
11063: oAssign
11064: oGetLocal 4
11066: oChoice 11093
11068: oGetAddrLocal 2
11070: oPushResult
11071: oGetParam 1
11073: oPushResult
11074: oSetResult 21
11076: oPushResult
11077: oNodeGet
11078: oPop 2
11080: oAssign
11081: oGetAddrLocal 3
11083: oPushResult
11084: oGetLocal 2
11086: oPushResult
11087: oScopeAllocType
11088: oPop 1
11090: oAssign
11091: oJumpForward 11096
11093: Choice Lookup Table
           1   11068
11096: oGetAddrLocal 5
11098: oPushResult
11099: oGetParam 1
11101: oPushResult
11102: oSetResult 23
11104: oPushResult
11105: oNodeGet
11106: oPop 2
11108: oAssign
11109: oGetAddrLocal 6
11111: oPushResult
11112: oGetLocal 5
11114: oPushResult
11115: oSetResult 17
11117: oPushResult
11118: oNodeGetInt
11119: oPop 2
11121: oAssign
11122: oGetLocal 1
11124: oChoice 11146
11126: oEmit 64
11128: oGetLocal 6
11130: oPushResult
11131: oEmitInt
11132: oPop 1
11134: oJumpForward 11152
11136: oEmit 63
11138: oGetLocal 6
11140: oPushResult
11141: oEmitInt
11142: oPop 1
11144: oJumpForward 11152
11146: Choice Lookup Table
           0   11136
           1   11126
11151: oEndChoice
11152: oGetParam 1
11154: oPushResult
11155: oCall 13993
11157: oPop 1
11159: oPushResult
11160: oSetResult 0
11162: oPushResult
11163: greater
11164: oPop 2
11166: oChoice 11199
11168: oEmit 20
11170: oSetResult 0
11172: oPushResult
11173: oEmitInt
11174: oPop 1
11176: oEmit 21
11178: oGetParam 1
11180: oPushResult
11181: oCall 14013
11183: oPop 1
11185: oPushResult
11186: oEmitInt
11187: oPop 1
11189: oSetResult 0
11191: oPushResult
11192: oEmitInt
11193: oPop 1
11195: oEmit 29
11197: oJumpForward 11202
11199: Choice Lookup Table
           1   11168
11202: oGetAddrLocal 7
11204: oPushResult
11205: oGetLocal 5
11207: oPushResult
11208: oSetResult 15
11210: oPushResult
11211: oNodeGetIter
11212: oPop 2
11214: oAssign
11215: oGetAddrLocal 8
11217: oPushResult
11218: oGetLocal 7
11220: oPushResult
11221: oNodeIterValue
11222: oPop 1
11224: oAssign
11225: oInputChoice 11428
11227: oGetLocal 8
11229: oPushResult
11230: oNodeNull
11231: oPop 1
11233: oChoice 11239
11235: oJumpForward 11424
11237: oJumpForward 11242
11239: Choice Lookup Table
           1   11235
11242: oGetAddrLocal 9
11244: oPushResult
11245: oGetLocal 8
11247: oPushResult
11248: oSetResult 22
11250: oPushResult
11251: oNodeGetInt
11252: oPop 2
11254: oAssign
11255: oEmit 20
11257: oGetLocal 9
11259: oPushResult
11260: oEmitInt
11261: oPop 1
11263: oGetLocal 8
11265: oPushResult
11266: oSetResult 21
11268: oPushResult
11269: oNodeGet
11270: oPop 2
11272: oPushResult
11273: oTypeSPush
11274: oPop 1
11276: oGetLocal 8
11278: oPushResult
11279: oSetResult 34
11281: oPushResult
11282: oNodeGetBoolean
11283: oPop 2
11285: oChoice 11377
11287: oSetResult 1
11289: oPushResult
11290: oCall 9198
11292: oPop 1
11294: oCall 8566
11296: oEmit 29
11298: oJumpForward 11383
11300: oCall 4887
11302: oCall 8229
11304: oTypeSNodeType
11305: oChoice 11349
11307: oEmit 27
11309: oJumpForward 11375
11311: oEmit 28
11313: oJumpForward 11375
11315: oEmit 30
11317: oJumpForward 11375
11319: oError 16
11321: oJumpForward 11375
11323: oEmit 29
11325: oJumpForward 11375
11327: oGetAddrLocal 10
11329: oPushResult
11330: oTypeSTop
11331: oPushResult
11332: oSetResult 17
11334: oPushResult
11335: oNodeGetInt
11336: oPop 2
11338: oAssign
11339: oEmit 31
11341: oGetLocal 10
11343: oPushResult
11344: oEmitInt
11345: oPop 1
11347: oJumpForward 11375
11349: Choice Lookup Table
          42   11327
          40   11327
          38   11327
          37   11323
          36   11323
          28   11319
          32   11315
          35   11311
          29   11311
          33   11311
          43   11307
          30   11307
11374: oEndChoice
11375: oJumpForward 11383
11377: Choice Lookup Table
           0   11300
           1   11287
11382: oEndChoice
11383: oTypeSPop
11384: oGetAddrLocal 7
11386: oPushResult
11387: oNodeIterNext
11388: oPop 1
11390: oGetAddrLocal 8
11392: oPushResult
11393: oGetLocal 7
11395: oPushResult
11396: oNodeIterValue
11397: oPop 1
11399: oAssign
11400: oGetLocal 8
11402: oPushResult
11403: oNodeNull
11404: oPop 1
11406: oChoice 11414
11408: oJumpForward 11424
11410: oJumpForward 11420
11412: oJumpForward 11420
11414: Choice Lookup Table
           0   11412
           1   11408
11419: oEndChoice
11420: oInput 14
11422: oJumpBack 11227
11424: oInput 16
11426: oJumpForward 11431
11428: Choice Lookup Table
          15   11227
11431: oGetLocal 8
11433: oPushResult
11434: oNodeNull
11435: oPop 1
11437: oChoice 11443
11439: oError 15
11441: oJumpForward 11446
11443: Choice Lookup Table
           0   11439
11446: oGetLocal 4
11448: oChoice 11477
11450: oEmit 20
11452: oGetParam 1
11454: oPushResult
11455: oSetResult 31
11457: oPushResult
11458: oNodeGetInt
11459: oPop 2
11461: oPushResult
11462: oEmitInt
11463: oPop 1
11465: oEmit 18
11467: oGetLocal 3
11469: oPushResult
11470: oEmitInt
11471: oPop 1
11473: oEmit 29
11475: oJumpForward 11480
11477: Choice Lookup Table
           1   11450
11480: oGetLocal 1
11482: oChoice 11506
11484: oEmit 67
11486: oGetParam 1
11488: oPushResult
11489: oCall 14059
11491: oPop 1
11493: oJumpForward 11512
11495: oEmit 66
11497: oGetParam 1
11499: oPushResult
11500: oCall 14059
11502: oPop 1
11504: oJumpForward 11512
11506: Choice Lookup Table
           0   11495
           1   11484
11511: oEndChoice
11512: oGetLocal 4
11514: oChoice 11595
11516: oGetLocal 2
11518: oPushResult
11519: oTypeSPush
11520: oPop 1
11522: oTypeSNodeType
11523: oChoice 11569
11525: oEmit 3
11527: oGetLocal 3
11529: oPushResult
11530: oEmitInt
11531: oPop 1
11533: oJumpForward 11593
11535: oEmit 4
11537: oGetLocal 3
11539: oPushResult
11540: oEmitInt
11541: oPop 1
11543: oJumpForward 11593
11545: oError 16
11547: oJumpForward 11593
11549: oEmit 5
11551: oGetLocal 3
11553: oPushResult
11554: oEmitInt
11555: oPop 1
11557: oJumpForward 11593
11559: oEmit 18
11561: oGetLocal 3
11563: oPushResult
11564: oEmitInt
11565: oPop 1
11567: oJumpForward 11593
11569: Choice Lookup Table
          42   11559
          40   11559
          38   11559
          37   11549
          36   11549
          28   11545
          35   11535
          29   11535
          33   11535
          43   11525
          30   11525
11592: oEndChoice
11593: oJumpForward 11598
11595: Choice Lookup Table
           1   11516
11598: oEmit 65
11600: oGetLocal 6
11602: oPushResult
11603: oEmitInt
11604: oPop 1
11606: oReturn
11607: oLocalSpace 2
11609: oGetAddrLocal 2
11611: oPushResult
11612: oGetParam 1
11614: oPushResult
11615: oSetResult 26
11617: oPushResult
11618: oNodeGetString
11619: oPop 2
11621: oAssign
11622: oGetLocal 2
11624: oPushResult
11625: oSetResult 0
11627: oPushResult
11628: equal_string
11629: oPop 2
11631: oChoice 11668
11633: oGetAddrLocal 1
11635: oPushResult
11636: oGetParam 1
11638: oPushResult
11639: oSetResult 4
11641: oPushResult
11642: oNodeGetInt
11643: oPop 2
11645: oPushResult
11646: ID_STRING
11647: oPop 1
11649: oPushResult
11650: oStringAllocLit
11651: oPop 1
11653: oAssign
11654: oJumpForward 11674
11656: oGetAddrLocal 1
11658: oPushResult
11659: oGetLocal 2
11661: oPushResult
11662: oStringAllocLit
11663: oPop 1
11665: oAssign
11666: oJumpForward 11674
11668: Choice Lookup Table
           0   11656
           1   11633
11673: oEndChoice
11674: oEmit 81
11676: oGetParam 1
11678: oPushResult
11679: oCall 14059
11681: oPop 1
11683: oGetLocal 1
11685: oPushResult
11686: oEmitInt
11687: oPop 1
11689: oReturn
11690: oLocalSpace 2
11692: oGetParam 1
11694: oPushResult
11695: oGetGlobal 17
11697: oPushResult
11698: oNodeEqual
11699: oPop 2
11701: oChoice 11741
11703: oInput 15
11705: oCall 4887
11707: oTypeSNodeType
11708: oChoice 11716
11710: oJumpForward 11729
11712: oEmit 32
11714: oJumpForward 11729
11716: Choice Lookup Table
          35   11712
          29   11712
          33   11712
          43   11710
          30   11710
11727: oError 14
11729: oTypeSPop
11730: oGetGlobal 6
11732: oPushResult
11733: oTypeSPush
11734: oPop 1
11736: oInput 16
11738: oReturn
11739: oJumpForward 11744
11741: Choice Lookup Table
           1   11703
11744: oGetParam 1
11746: oPushResult
11747: oGetGlobal 18
11749: oPushResult
11750: oNodeEqual
11751: oPop 2
11753: oChoice 11787
11755: oInput 15
11757: oCall 4887
11759: oTypeSNodeType
11760: oChoice 11768
11762: oEmit 33
11764: oJumpForward 11775
11766: oJumpForward 11775
11768: Choice Lookup Table
          29   11766
          30   11762
11773: oError 14
11775: oTypeSPop
11776: oGetGlobal 9
11778: oPushResult
11779: oTypeSPush
11780: oPop 1
11782: oInput 16
11784: oReturn
11785: oJumpForward 11790
11787: Choice Lookup Table
           1   11755
11790: oGetParam 1
11792: oPushResult
11793: oGetGlobal 19
11795: oPushResult
11796: oNodeEqual
11797: oPop 2
11799: oChoice 11839
11801: oInput 15
11803: oCall 4887
11805: oTypeSNodeType
11806: oChoice 11827
11808: oTypeSTop
11809: oPushResult
11810: oSetResult 44
11812: oPushResult
11813: oNodeGetBoolean
11814: oPop 2
11816: oChoice 11822
11818: oError 28
11820: oJumpForward 11825
11822: Choice Lookup Table
           1   11818
11825: oJumpForward 11832
11827: Choice Lookup Table
          43   11808
11830: oError 14
11832: oEmit 35
11834: oInput 16
11836: oReturn
11837: oJumpForward 11842
11839: Choice Lookup Table
           1   11801
11842: oGetParam 1
11844: oPushResult
11845: oGetGlobal 20
11847: oPushResult
11848: oNodeEqual
11849: oPop 2
11851: oChoice 11891
11853: oInput 15
11855: oCall 4887
11857: oTypeSNodeType
11858: oChoice 11879
11860: oTypeSTop
11861: oPushResult
11862: oSetResult 44
11864: oPushResult
11865: oNodeGetBoolean
11866: oPop 2
11868: oChoice 11874
11870: oError 28
11872: oJumpForward 11877
11874: Choice Lookup Table
           1   11870
11877: oJumpForward 11884
11879: Choice Lookup Table
          43   11860
11882: oError 14
11884: oEmit 34
11886: oInput 16
11888: oReturn
11889: oJumpForward 11894
11891: Choice Lookup Table
           1   11853
11894: oGetParam 1
11896: oPushResult
11897: oGetGlobal 21
11899: oPushResult
11900: oNodeEqual
11901: oPop 2
11903: oChoice 11959
11905: oInput 15
11907: oGetAddrLocal 1
11909: oPushResult
11910: oCodeNew
11911: oAssign
11912: oGetLocal 1
11914: oPushResult
11915: oCodePush
11916: oPop 1
11918: oCall 4910
11920: oCodePop
11921: oGetLocal 1
11923: oPushResult
11924: oCodeDiscard
11925: oPop 1
11927: oGetAddrLocal 2
11929: oPushResult
11930: oTypeSTop
11931: oAssign
11932: oTypeSPop
11933: oEmit 15
11935: oGetLocal 2
11937: oPushResult
11938: oSetResult 17
11940: oPushResult
11941: oNodeGetInt
11942: oPop 2
11944: oPushResult
11945: oEmitInt
11946: oPop 1
11948: oGetGlobal 6
11950: oPushResult
11951: oTypeSPush
11952: oPop 1
11954: oInput 16
11956: oReturn
11957: oJumpForward 11962
11959: Choice Lookup Table
           1   11905
11962: oError 16
11964: oReturn
11965: oLocalSpace 1
11967: oGetAddrLocal 1
11969: oPushResult
11970: oGetParam 2
11972: oPushResult
11973: oNodeNew
11974: oPop 1
11976: oAssign
11977: oGetLocal 1
11979: oPushResult
11980: oSetResult 17
11982: oPushResult
11983: oGetParam 1
11985: oPushResult
11986: oNodeSetInt
11987: oPop 3
11989: oGetLocal 1
11991: oPushResult
11992: oTypeAdd
11993: oPop 1
11995: oGetLocal 1
11997: oReturn
11998: oReturn
11999: oLocalSpace 12
12001: oInputChoice 12484
12003: oGetAddrLocal 1
12005: oPushResult
12006: oScopeFindRequire
12007: oAssign
12008: oGetAddrLocal 1
12010: oPushResult
12011: oCall 244
12013: oPop 1
12015: oGetLocal 1
12017: oPushResult
12018: oNodeType
12019: oPop 1
12021: oChoice 12038
12023: oGetParam 1
12025: oPushResult
12026: oGetLocal 1
12028: oPushResult
12029: oSetResult 21
12031: oPushResult
12032: oNodeGet
12033: oPop 2
12035: oAssign
12036: oJumpForward 12049
12038: Choice Lookup Table
          19   12023
12041: oError 2
12043: oGetParam 1
12045: oPushResult
12046: oGetGlobal 6
12048: oAssign
12049: oJumpForward 12507
12051: oInput 17
12053: oGetAddrLocal 2
12055: oPushResult
12056: oNodeVecNew
12057: oAssign
12058: oGetAddrLocal 3
12060: oPushResult
12061: oSetResult 39
12063: oPushResult
12064: oNodeNew
12065: oPop 1
12067: oAssign
12068: oCall 3539
12070: oGetLocal 3
12072: oPushResult
12073: oSetResult 39
12075: oPushResult
12076: oValueTop
12077: oPushResult
12078: oNodeSetInt
12079: oPop 3
12081: oValuePop
12082: oInput 22
12084: oCall 3539
12086: oGetLocal 3
12088: oPushResult
12089: oSetResult 40
12091: oPushResult
12092: oValueTop
12093: oPushResult
12094: oNodeSetInt
12095: oPop 3
12097: oValuePop
12098: oCall 4254
12100: oGetLocal 3
12102: oPushResult
12103: oSetResult 37
12105: oPushResult
12106: oTypeSTop
12107: oPushResult
12108: oNodeSet
12109: oPop 3
12111: oGetLocal 3
12113: oPushResult
12114: oSetResult 17
12116: oPushResult
12117: oTypeSTop
12118: oPushResult
12119: oSetResult 17
12121: oPushResult
12122: oNodeGetInt
12123: oPop 2
12125: oPushResult
12126: oNodeSetInt
12127: oPop 3
12129: oTypeSPop
12130: oGetLocal 3
12132: oPushResult
12133: oTypeAdd
12134: oPop 1
12136: oGetAddrLocal 4
12138: oPushResult
12139: oSetResult 38
12141: oPushResult
12142: oNodeNew
12143: oPop 1
12145: oAssign
12146: oGetLocal 4
12148: oPushResult
12149: oSetResult 38
12151: oPushResult
12152: oGetLocal 3
12154: oPushResult
12155: oNodeSet
12156: oPop 3
12158: oGetLocal 2
12160: oPushResult
12161: oGetLocal 4
12163: oPushResult
12164: oNodeVecAppend
12165: oPop 2
12167: oInputChoice 12175
12169: oJumpForward 12183
12171: oJumpForward 12181
12173: oJumpForward 12181
12175: Choice Lookup Table
          14   12173
          18   12169
12180: oEndChoice
12181: oJumpBack 12058
12183: oInput 41
12185: oGetAddrLocal 5
12187: oPushResult
12188: oCall 11999
12190: oPop 1
12192: oGetAddrLocal 6
12194: oPushResult
12195: oGetLocal 2
12197: oPushResult
12198: oNodeVecSize
12199: oPop 1
12201: oAssign
12202: oGetAddrLocal 6
12204: oPushResult
12205: dec
12206: oPop 1
12208: oGetAddrLocal 7
12210: oPushResult
12211: oGetLocal 2
12213: oPushResult
12214: oGetLocal 6
12216: oPushResult
12217: oNodeVecElement
12218: oPop 2
12220: oAssign
12221: oGetLocal 7
12223: oPushResult
12224: oSetResult 37
12226: oPushResult
12227: oGetLocal 5
12229: oPushResult
12230: oNodeSet
12231: oPop 3
12233: oGetAddrLocal 8
12235: oPushResult
12236: oGetLocal 7
12238: oPushResult
12239: oSetResult 38
12241: oPushResult
12242: oNodeGet
12243: oPop 2
12245: oAssign
12246: oGetAddrLocal 9
12248: oPushResult
12249: oGetLocal 8
12251: oPushResult
12252: oSetResult 40
12254: oPushResult
12255: oNodeGetInt
12256: oPop 2
12258: oPushResult
12259: oGetLocal 8
12261: oPushResult
12262: oSetResult 39
12264: oPushResult
12265: oNodeGetInt
12266: oPop 2
12268: oPushResult
12269: subtract
12270: oPop 2
12272: oAssign
12273: oGetAddrLocal 9
12275: oPushResult
12276: inc
12277: oPop 1
12279: oGetLocal 7
12281: oPushResult
12282: oSetResult 17
12284: oPushResult
12285: oGetLocal 9
12287: oPushResult
12288: oGetLocal 5
12290: oPushResult
12291: oSetResult 17
12293: oPushResult
12294: oNodeGetInt
12295: oPop 2
12297: oPushResult
12298: multiply
12299: oPop 2
12301: oPushResult
12302: oNodeSetInt
12303: oPop 3
12305: oGetLocal 7
12307: oPushResult
12308: oTypeAdd
12309: oPop 1
12311: oGetAddrLocal 5
12313: oPushResult
12314: oGetLocal 7
12316: oAssign
12317: oGetLocal 6
12319: oPushResult
12320: equal_zero
12321: oPop 1
12323: oChoice 12329
12325: oJumpForward 12334
12327: oJumpForward 12332
12329: Choice Lookup Table
           1   12325
12332: oJumpBack 12202
12334: oGetParam 1
12336: oPushResult
12337: oGetLocal 2
12339: oPushResult
12340: oSetResult 0
12342: oPushResult
12343: oNodeVecElement
12344: oPop 2
12346: oAssign
12347: oGetLocal 2
12349: oPushResult
12350: oNodeVecDelete
12351: oPop 1
12353: oJumpForward 12507
12355: oGetAddrLocal 10
12357: oPushResult
12358: oCall 11999
12360: oPop 1
12362: oGetParam 1
12364: oPushResult
12365: oGetLocal 10
12367: oPushResult
12368: oCall 13078
12370: oPop 1
12372: oAssign
12373: oJumpForward 12507
12375: oGetParam 1
12377: oPushResult
12378: oSetResult 40
12380: oPushResult
12381: oNodeNew
12382: oPop 1
12384: oAssign
12385: oSetResult -1
12387: oPushResult
12388: oSetResult 2
12390: oPushResult
12391: oScopeBegin
12392: oPop 2
12394: oSetResult 23
12396: oPushResult
12397: oCall 3240
12399: oPop 1
12401: oGetAddrLocal 11
12403: oPushResult
12404: oScopeCurrent
12405: oPushResult
12406: oSetResult 17
12408: oPushResult
12409: oNodeGetInt
12410: oPop 2
12412: oAssign
12413: oGetLocal 11
12415: oPushResult
12416: equal_zero
12417: oPop 1
12419: oChoice 12425
12421: oError 19
12423: oJumpForward 12428
12425: Choice Lookup Table
           1   12421
12428: oInput 37
12430: oGetFromParam 1
12432: oPushResult
12433: oSetResult 41
12435: oPushResult
12436: oScopeCurrent
12437: oPushResult
12438: oNodeSet
12439: oPop 3
12441: oGetFromParam 1
12443: oPushResult
12444: oSetResult 17
12446: oPushResult
12447: oGetLocal 11
12449: oPushResult
12450: oNodeSetInt
12451: oPop 3
12453: oScopeEnd
12454: oGetFromParam 1
12456: oPushResult
12457: oTypeAdd
12458: oPop 1
12460: oJumpForward 12507
12462: oGetParam 1
12464: oPushResult
12465: oCall 12508
12467: oPop 1
12469: oJumpForward 12507
12471: oInput 41
12473: oGetAddrLocal 12
12475: oPushResult
12476: oCall 11999
12478: oPop 1
12480: oError 16
12482: oJumpForward 12507
12484: Choice Lookup Table
          40   12471
          15   12462
          39   12375
          19   12355
          38   12051
           0   12003
12497: oCall 3539
12499: oInput 22
12501: oCall 3539
12503: oCall 4254
12505: oError 16
12507: oReturn
12508: oLocalSpace 11
12510: oGetParam 1
12512: oPushResult
12513: oSetResult 43
12515: oPushResult
12516: oNodeNew
12517: oPop 1
12519: oAssign
12520: oGetAddrLocal 1
12522: oPushResult
12523: oSetResult 0
12525: oAssign
12526: oGetAddrLocal 2
12528: oPushResult
12529: oSetResult 0
12531: oAssign
12532: oGetAddrLocal 3
12534: oPushResult
12535: oSetResult 1
12537: oAssign
12538: oGetAddrLocal 4
12540: oPushResult
12541: oScopeCurrent
12542: oAssign
12543: oSetResult -1
12545: oPushResult
12546: oSetResult 2
12548: oPushResult
12549: oScopeBegin
12550: oPop 2
12552: oInput 0
12554: oGetAddrLocal 5
12556: oPushResult
12557: oSetResult 17
12559: oPushResult
12560: LAST_ID
12561: oPushResult
12562: oCall 14031
12564: oPop 2
12566: oAssign
12567: oGetAddrLocal 6
12569: oPushResult
12570: oSetResult 17
12572: oPushResult
12573: LAST_ID
12574: oPushResult
12575: oCall 14031
12577: oPop 2
12579: oAssign
12580: oGetLocal 5
12582: oPushResult
12583: oSetResult 21
12585: oPushResult
12586: oGetFromParam 1
12588: oPushResult
12589: oNodeSet
12590: oPop 3
12592: oGetLocal 6
12594: oPushResult
12595: oSetResult 21
12597: oPushResult
12598: oGetFromParam 1
12600: oPushResult
12601: oNodeSet
12602: oPop 3
12604: oGetAddrLocal 7
12606: oPushResult
12607: LAST_ID
12608: oPushResult
12609: ID_STRING
12610: oPop 1
12612: oPushResult
12613: oStringAllocLit
12614: oPop 1
12616: oAssign
12617: oGetLocal 5
12619: oPushResult
12620: oSetResult 32
12622: oPushResult
12623: oGetLocal 7
12625: oPushResult
12626: oNodeSetInt
12627: oPop 3
12629: oGetLocal 6
12631: oPushResult
12632: oSetResult 32
12634: oPushResult
12635: oGetLocal 7
12637: oPushResult
12638: oNodeSetInt
12639: oPop 3
12641: oInputChoice 12719
12643: oGetGlobal 6
12645: oPushResult
12646: oTypeSPush
12647: oPop 1
12649: oCall 3539
12651: oCall 4351
12653: oTypeSPop
12654: oGetLocal 2
12656: oPushResult
12657: equal_zero
12658: oPop 1
12660: oChoice 12681
12662: oValueTop
12663: oPushResult
12664: oGetLocal 1
12666: oPushResult
12667: greater
12668: oPop 2
12670: oChoice 12676
12672: oError 26
12674: oJumpForward 12679
12676: Choice Lookup Table
           0   12672
12679: oJumpForward 12684
12681: Choice Lookup Table
           0   12662
12684: oGetLocal 1
12686: oPushResult
12687: oValueTop
12688: oPushResult
12689: equal
12690: oPop 2
12692: oChoice 12708
12694: oGetFromParam 1
12696: oPushResult
12697: oSetResult 44
12699: oPushResult
12700: oSetResult 1
12702: oPushResult
12703: oNodeSetBoolean
12704: oPop 3
12706: oJumpForward 12711
12708: Choice Lookup Table
           0   12694
12711: oGetAddrLocal 1
12713: oPushResult
12714: oValueTop
12715: oAssign
12716: oValuePop
12717: oJumpForward 12724
12719: Choice Lookup Table
           5   12643
           7   12643
12724: oGetLocal 5
12726: oPushResult
12727: oSetResult 22
12729: oPushResult
12730: oGetLocal 1
12732: oPushResult
12733: oNodeSetInt
12734: oPop 3
12736: oGetLocal 6
12738: oPushResult
12739: oSetResult 22
12741: oPushResult
12742: oGetLocal 1
12744: oPushResult
12745: oNodeSetInt
12746: oPop 3
12748: oGetLocal 5
12750: oPushResult
12751: oScopeDeclare
12752: oPop 1
12754: oGetLocal 4
12756: oPushResult
12757: oScopeEnter
12758: oPop 1
12760: oGetLocal 6
12762: oPushResult
12763: oScopeDeclare
12764: oPop 1
12766: oScopeEnd
12767: oGetAddrLocal 1
12769: oPushResult
12770: inc
12771: oPop 1
12773: oGetAddrLocal 2
12775: oPushResult
12776: inc
12777: oPop 1
12779: oInputChoice 12783
12781: oJumpForward 12788
12783: Choice Lookup Table
          14   12781
12786: oJumpForward 12790
12788: oJumpBack 12552
12790: oInput 16
12792: oGetFromParam 1
12794: oPushResult
12795: oSetResult 41
12797: oPushResult
12798: oScopeCurrent
12799: oPushResult
12800: oNodeSet
12801: oPop 3
12803: oGetFromParam 1
12805: oPushResult
12806: oSetResult 17
12808: oPushResult
12809: oSetResult 4
12811: oPushResult
12812: oNodeSetInt
12813: oPop 3
12815: oScopeEnd
12816: oGetGlobal 2
12818: oPushResult
12819: oCall 13929
12821: oPop 1
12823: oPushResult
12824: oCodePush
12825: oPop 1
12827: oGetGlobal 2
12829: oPushResult
12830: oScopeEnter
12831: oPop 1
12833: oGetAddrLocal 8
12835: oPushResult
12836: oGetLocal 2
12838: oPushResult
12839: oSetResult 1
12841: oPushResult
12842: add
12843: oPop 2
12845: oPushResult
12846: oSetResult 16
12848: oPushResult
12849: multiply
12850: oPop 2
12852: oAssign
12853: oGetAddrLocal 9
12855: oPushResult
12856: oGetLocal 8
12858: oPushResult
12859: oSetResult 8
12861: oPushResult
12862: oScopeAlloc
12863: oPop 2
12865: oAssign
12866: oScopeEnd
12867: oGetFromParam 1
12869: oPushResult
12870: oSetResult 43
12872: oPushResult
12873: oGetLocal 9
12875: oPushResult
12876: oNodeSetInt
12877: oPop 3
12879: oGetAddrLocal 10
12881: oPushResult
12882: oGetFromParam 1
12884: oPushResult
12885: oSetResult 41
12887: oPushResult
12888: oNodeGet
12889: oPop 2
12891: oPushResult
12892: oSetResult 15
12894: oPushResult
12895: oNodeGetIter
12896: oPop 2
12898: oAssign
12899: oGetAddrLocal 11
12901: oPushResult
12902: oGetLocal 10
12904: oPushResult
12905: oNodeIterValue
12906: oPop 1
12908: oAssign
12909: oGetLocal 11
12911: oPushResult
12912: oNodeNull
12913: oPop 1
12915: oChoice 12921
12917: oJumpForward 13008
12919: oJumpForward 12924
12921: Choice Lookup Table
           1   12917
12924: oEmit 17
12926: oGetLocal 9
12928: oPushResult
12929: oEmitInt
12930: oPop 1
12932: oEmit 15
12934: oGetLocal 11
12936: oPushResult
12937: oSetResult 22
12939: oPushResult
12940: oNodeGetInt
12941: oPop 2
12943: oPushResult
12944: oEmitInt
12945: oPop 1
12947: oEmit 27
12949: oGetAddrLocal 9
12951: oPushResult
12952: oGetLocal 9
12954: oPushResult
12955: oSetResult 8
12957: oPushResult
12958: add
12959: oPop 2
12961: oAssign
12962: oEmit 17
12964: oGetLocal 9
12966: oPushResult
12967: oEmitInt
12968: oPop 1
12970: oEmit 17
12972: oGetLocal 11
12974: oPushResult
12975: oSetResult 32
12977: oPushResult
12978: oNodeGetInt
12979: oPop 2
12981: oPushResult
12982: oEmitInt
12983: oPop 1
12985: oEmit 29
12987: oGetAddrLocal 9
12989: oPushResult
12990: oGetLocal 9
12992: oPushResult
12993: oSetResult 8
12995: oPushResult
12996: add
12997: oPop 2
12999: oAssign
13000: oGetAddrLocal 10
13002: oPushResult
13003: oNodeIterNext
13004: oPop 1
13006: oJumpBack 12899
13008: oEmit 17
13010: oGetLocal 9
13012: oPushResult
13013: oEmitInt
13014: oPop 1
13016: oEmit 15
13018: oSetResult 0
13020: oPushResult
13021: oEmitInt
13022: oPop 1
13024: oEmit 27
13026: oGetAddrLocal 9
13028: oPushResult
13029: oGetLocal 9
13031: oPushResult
13032: oSetResult 8
13034: oPushResult
13035: add
13036: oPop 2
13038: oAssign
13039: oEmit 17
13041: oGetLocal 9
13043: oPushResult
13044: oEmitInt
13045: oPop 1
13047: oEmit 15
13049: oSetResult 0
13051: oPushResult
13052: oEmitInt
13053: oPop 1
13055: oEmit 29
13057: oGetAddrLocal 9
13059: oPushResult
13060: oGetLocal 9
13062: oPushResult
13063: oSetResult 8
13065: oPushResult
13066: add
13067: oPop 2
13069: oAssign
13070: oCodePop
13071: oGetFromParam 1
13073: oPushResult
13074: oTypeAdd
13075: oPop 1
13077: oReturn
13078: oLocalSpace 1
13080: oGetAddrLocal 1
13082: oPushResult
13083: oGetParam 1
13085: oPushResult
13086: oSetResult 36
13088: oPushResult
13089: oNodeGet
13090: oPop 2
13092: oAssign
13093: oGetLocal 1
13095: oPushResult
13096: oNodeNull
13097: oPop 1
13099: oChoice 13155
13101: oGetAddrLocal 1
13103: oPushResult
13104: oSetResult 36
13106: oPushResult
13107: oNodeNew
13108: oPop 1
13110: oAssign
13111: oGetLocal 1
13113: oPushResult
13114: oSetResult 37
13116: oPushResult
13117: oGetParam 1
13119: oPushResult
13120: oNodeSet
13121: oPop 3
13123: oGetLocal 1
13125: oPushResult
13126: oSetResult 17
13128: oPushResult
13129: oSetResult 8
13131: oPushResult
13132: oNodeSetInt
13133: oPop 3
13135: oGetLocal 1
13137: oPushResult
13138: oTypeAdd
13139: oPop 1
13141: oGetParam 1
13143: oPushResult
13144: oSetResult 36
13146: oPushResult
13147: oGetLocal 1
13149: oPushResult
13150: oNodeSet
13151: oPop 3
13153: oJumpForward 13158
13155: Choice Lookup Table
           1   13101
13158: oGetLocal 1
13160: oReturn
13161: oReturn
13162: oLocalSpace 2
13164: oGetParam 1
13166: oPushResult
13167: oNodeType
13168: oPop 1
13170: oChoice 13240
13172: oMININT
13173: oReturn
13174: oJumpForward 13256
13176: oSetResult 0
13178: oReturn
13179: oJumpForward 13256
13181: oSetResult 0
13183: oReturn
13184: oJumpForward 13256
13186: oGetAddrLocal 1
13188: oPushResult
13189: oGetParam 1
13191: oPushResult
13192: oSetResult 41
13194: oPushResult
13195: oNodeGet
13196: oPop 2
13198: oAssign
13199: oGetAddrLocal 2
13201: oPushResult
13202: oGetLocal 1
13204: oPushResult
13205: oSetResult 15
13207: oPushResult
13208: oNodeGetIter
13209: oPop 2
13211: oPushResult
13212: oNodeIterValue
13213: oPop 1
13215: oAssign
13216: oGetLocal 2
13218: oPushResult
13219: oSetResult 22
13221: oPushResult
13222: oNodeGetInt
13223: oPop 2
13225: oReturn
13226: oJumpForward 13256
13228: oGetParam 1
13230: oPushResult
13231: oSetResult 39
13233: oPushResult
13234: oNodeGetInt
13235: oPop 2
13237: oReturn
13238: oJumpForward 13256
13240: Choice Lookup Table
          39   13228
          43   13186
          35   13181
          33   13176
          30   13172
13251: oError 3
13253: oSetResult 0
13255: oReturn
13256: oReturn
13257: oLocalSpace 2
13259: oGetParam 1
13261: oPushResult
13262: oNodeType
13263: oPop 1
13265: oChoice 13335
13267: oMAXINT
13268: oReturn
13269: oJumpForward 13351
13271: oSetResult 1
13273: oReturn
13274: oJumpForward 13351
13276: oSetResult 255
13278: oReturn
13279: oJumpForward 13351
13281: oGetAddrLocal 1
13283: oPushResult
13284: oGetParam 1
13286: oPushResult
13287: oSetResult 41
13289: oPushResult
13290: oNodeGet
13291: oPop 2
13293: oAssign
13294: oGetAddrLocal 2
13296: oPushResult
13297: oGetLocal 1
13299: oPushResult
13300: oSetResult 15
13302: oPushResult
13303: oNodeGetIterLast
13304: oPop 2
13306: oPushResult
13307: oNodeIterValue
13308: oPop 1
13310: oAssign
13311: oGetLocal 2
13313: oPushResult
13314: oSetResult 22
13316: oPushResult
13317: oNodeGetInt
13318: oPop 2
13320: oReturn
13321: oJumpForward 13351
13323: oGetParam 1
13325: oPushResult
13326: oSetResult 40
13328: oPushResult
13329: oNodeGetInt
13330: oPop 2
13332: oReturn
13333: oJumpForward 13351
13335: Choice Lookup Table
          39   13323
          43   13281
          35   13276
          33   13271
          30   13267
13346: oError 3
13348: oSetResult 0
13350: oReturn
13351: oReturn
13352: oLocalSpace 5
13354: oGetAddrGlobal 1
13356: oPushResult
13357: oWorkspaceNew
13358: oAssign
13359: oSetResult 0
13361: oPushResult
13362: oSetResult 0
13364: oPushResult
13365: oScopeBegin
13366: oPop 2
13368: oGetAddrLocal 2
13370: oPushResult
13371: oScopeCurrent
13372: oAssign
13373: oCall 14101
13375: oEmit 69
13377: oSetResult 0
13379: oPushResult
13380: oEmitInt
13381: oPop 1
13383: oGetAddrLocal 3
13385: oPushResult
13386: oLabelNew
13387: oAssign
13388: oEmit 63
13390: oSetResult 0
13392: oPushResult
13393: oEmitInt
13394: oPop 1
13396: oEmit 66
13398: oGetLocal 3
13400: oPushResult
13401: oEmitLabel
13402: oPop 1
13404: oEmit 65
13406: oSetResult 0
13408: oPushResult
13409: oEmitInt
13410: oPop 1
13412: oEmit 68
13414: oInput 29
13416: oInput 0
13418: oGetAddrLocal 4
13420: oPushResult
13421: oSetResult 4
13423: oPushResult
13424: oNodeNew
13425: oPop 1
13427: oAssign
13428: oGetLocal 4
13430: oPushResult
13431: oSetResult 4
13433: oPushResult
13434: LAST_ID
13435: oPushResult
13436: oNodeSetInt
13437: oPop 3
13439: oGetGlobal 1
13441: oPushResult
13442: oSetResult 2
13444: oPushResult
13445: oGetLocal 4
13447: oPushResult
13448: oNodeSet
13449: oPop 3
13451: oInputChoice 13525
13453: oInput 0
13455: oGetAddrLocal 1
13457: oPushResult
13458: oSetResult 20
13460: oPushResult
13461: LAST_ID
13462: oPushResult
13463: oCall 14031
13465: oPop 2
13467: oAssign
13468: oGetLocal 1
13470: oPushResult
13471: oSetResult 21
13473: oPushResult
13474: oGetGlobal 5
13476: oPushResult
13477: oNodeSet
13478: oPop 3
13480: oGetLocal 1
13482: oPushResult
13483: oScopeDeclareAlloc
13484: oPop 1
13486: oInput 14
13488: oInput 0
13490: oGetAddrLocal 1
13492: oPushResult
13493: oSetResult 20
13495: oPushResult
13496: LAST_ID
13497: oPushResult
13498: oCall 14031
13500: oPop 2
13502: oAssign
13503: oGetLocal 1
13505: oPushResult
13506: oSetResult 21
13508: oPushResult
13509: oGetGlobal 5
13511: oPushResult
13512: oNodeSet
13513: oPop 3
13515: oGetLocal 1
13517: oPushResult
13518: oScopeDeclareAlloc
13519: oPop 1
13521: oInput 16
13523: oJumpForward 13528
13525: Choice Lookup Table
          15   13453
13528: oInput 6
13530: oGetLocal 4
13532: oPushResult
13533: oCall 34
13535: oPop 1
13537: oInputChoice 13548
13539: oGetLocal 4
13541: oPushResult
13542: oCall 7
13544: oPop 1
13546: oJumpForward 13551
13548: Choice Lookup Table
          60   13539
13551: oGetLocal 4
13553: oPushResult
13554: oCall 287
13556: oPop 1
13558: oSetResult 0
13560: oPushResult
13561: oSetResult 0
13563: oPushResult
13564: oScopeBegin
13565: oPop 2
13567: oGetAddrGlobal 2
13569: oPushResult
13570: oScopeCurrent
13571: oAssign
13572: oSetResult 0
13574: oPushResult
13575: oSetResult 1
13577: oPushResult
13578: oScopeBegin
13579: oPop 2
13581: oScopeCurrent
13582: oPushResult
13583: oSetResult 16
13585: oPushResult
13586: oGetGlobal 2
13588: oPushResult
13589: oNodeSet
13590: oPop 3
13592: oGetAddrGlobal 3
13594: oPushResult
13595: oScopeCurrent
13596: oAssign
13597: oGetLocal 4
13599: oPushResult
13600: oSetResult 7
13602: oPushResult
13603: oGetGlobal 3
13605: oPushResult
13606: oNodeSet
13607: oPop 3
13609: oScopeEnd
13610: oSetResult 21
13612: oPushResult
13613: oCall 13680
13615: oPop 1
13617: oGetGlobal 3
13619: oPushResult
13620: oScopeEnter
13621: oPop 1
13623: oGetAddrLocal 5
13625: oPushResult
13626: oSetResult 1
13628: oAssign
13629: oGetLocal 3
13631: oPushResult
13632: oGetGlobal 2
13634: oPushResult
13635: oGetLocal 5
13637: oPushResult
13638: oCall 13831
13640: oPop 3
13642: oScopeEnd
13643: oInput 21
13645: oCall 13736
13647: oScopeEnd
13648: oGetLocal 4
13650: oPushResult
13651: oCall 349
13653: oPop 1
13655: oReturn
13656: oLocalSpace 0
13658: oGetParam 2
13660: oPushResult
13661: oCall 13680
13663: oPop 1
13665: oGetParam 1
13667: oPushResult
13668: oScopeCurrent
13669: oPushResult
13670: oSetResult 0
13672: oPushResult
13673: oCall 13831
13675: oPop 3
13677: oCall 13736
13679: oReturn
13680: oLocalSpace 0
13682: oInputChoice 13713
13684: oCall 2520
13686: oJumpForward 13728
13688: oCall 3184
13690: oJumpForward 13728
13692: oGetParam 1
13694: oPushResult
13695: oCall 3240
13697: oPop 1
13699: oJumpForward 13728
13701: oCall 3474
13703: oJumpForward 13728
13705: oCall 1743
13707: oJumpForward 13728
13709: oCall 2178
13711: oJumpForward 13728
13713: Choice Lookup Table
          31   13709
          30   13705
          35   13701
          34   13692
          33   13688
          32   13684
13726: oJumpForward 13730
13728: oJumpBack 13682
13730: oCall 13733
13732: oReturn
13733: oLocalSpace 0
13735: oReturn
13736: oLocalSpace 2
13738: oGetAddrLocal 1
13740: oPushResult
13741: oScopeCurrent
13742: oPushResult
13743: oSetResult 15
13745: oPushResult
13746: oNodeGetIter
13747: oPop 2
13749: oAssign
13750: oGetAddrLocal 2
13752: oPushResult
13753: oGetLocal 1
13755: oPushResult
13756: oNodeIterValue
13757: oPop 1
13759: oAssign
13760: oGetLocal 2
13762: oPushResult
13763: oNodeNull
13764: oPop 1
13766: oChoice 13770
13768: oJumpForward 13775
13770: Choice Lookup Table
           0   13768
13773: oJumpForward 13830
13775: oGetLocal 2
13777: oPushResult
13778: oNodeType
13779: oPop 1
13781: oChoice 13819
13783: oGetLocal 2
13785: oPushResult
13786: oSetResult 35
13788: oPushResult
13789: oNodeGetBoolean
13790: oPop 2
13792: oChoice 13814
13794: oGetLocal 2
13796: oPushResult
13797: oSetResult 28
13799: oPushResult
13800: oNodeGetBoolean
13801: oPop 2
13803: oChoice 13809
13805: oError 27
13807: oJumpForward 13812
13809: Choice Lookup Table
           1   13805
13812: oJumpForward 13817
13814: Choice Lookup Table
           0   13794
13817: oJumpForward 13822
13819: Choice Lookup Table
          26   13783
13822: oGetAddrLocal 1
13824: oPushResult
13825: oNodeIterNext
13826: oPop 1
13828: oJumpBack 13750
13830: oReturn
13831: oLocalSpace 3
13833: oEmit 79
13835: oGetParam 3
13837: oPushResult
13838: oEmitLabel
13839: oPop 1
13841: oEmit 69
13843: oGetAddrLocal 1
13845: oPushResult
13846: Here
13847: oAssign
13848: oEmit 97
13850: oGetParam 1
13852: oChoice 13858
13854: oCall 1220
13856: oJumpForward 13861
13858: Choice Lookup Table
           1   13854
13861: oGetAddrLocal 2
13863: oPushResult
13864: oGetParam 2
13866: oPushResult
13867: oSetResult 19
13869: oPushResult
13870: oNodeGetCode
13871: oPop 2
13873: oAssign
13874: oGetLocal 2
13876: oPushResult
13877: oEmitCode
13878: oPop 1
13880: oGetParam 2
13882: oPushResult
13883: oSetResult 19
13885: oPushResult
13886: oSetResult 0
13888: oPushResult
13889: oNodeSetCode
13890: oPop 3
13892: oCall 8744
13894: oGetParam 1
13896: oChoice 13902
13898: oCall 1305
13900: oJumpForward 13905
13902: Choice Lookup Table
           1   13898
13905: oEmit 68
13907: oGetAddrLocal 3
13909: oPushResult
13910: oScopeCurrent
13911: oPushResult
13912: oSetResult 17
13914: oPushResult
13915: oNodeGetInt
13916: oPop 2
13918: oAssign
13919: oGetLocal 1
13921: oPushResult
13922: oGetLocal 3
13924: oPushResult
13925: oPatch
13926: oPop 2
13928: oReturn
13929: oLocalSpace 1
13931: oGetAddrLocal 1
13933: oPushResult
13934: oGetParam 1
13936: oPushResult
13937: oSetResult 19
13939: oPushResult
13940: oNodeGetCode
13941: oPop 2
13943: oAssign
13944: oGetLocal 1
13946: oPushResult
13947: oSetResult 0
13949: oPushResult
13950: equal_code
13951: oPop 2
13953: oChoice 13974
13955: oGetAddrLocal 1
13957: oPushResult
13958: oCodeNew
13959: oAssign
13960: oGetParam 1
13962: oPushResult
13963: oSetResult 19
13965: oPushResult
13966: oGetLocal 1
13968: oPushResult
13969: oNodeSetCode
13970: oPop 3
13972: oJumpForward 13977
13974: Choice Lookup Table
           1   13955
13977: oGetLocal 1
13979: oReturn
13980: oReturn
13981: oLocalSpace 0
13983: oScopeCurrent
13984: oPushResult
13985: oSetResult 14
13987: oPushResult
13988: oNodeGetInt
13989: oPop 2
13991: oReturn
13992: oReturn
13993: oLocalSpace 0
13995: oGetParam 1
13997: oPushResult
13998: oSetResult 20
14000: oPushResult
14001: oNodeGet
14002: oPop 2
14004: oPushResult
14005: oSetResult 14
14007: oPushResult
14008: oNodeGetInt
14009: oPop 2
14011: oReturn
14012: oReturn
14013: oLocalSpace 0
14015: oCall 13981
14017: oPushResult
14018: oGetParam 1
14020: oPushResult
14021: oCall 13993
14023: oPop 1
14025: oPushResult
14026: subtract
14027: oPop 2
14029: oReturn
14030: oReturn
14031: oLocalSpace 1
14033: oGetAddrLocal 1
14035: oPushResult
14036: oGetParam 2
14038: oPushResult
14039: oNodeNew
14040: oPop 1
14042: oAssign
14043: oGetLocal 1
14045: oPushResult
14046: oSetResult 4
14048: oPushResult
14049: oGetParam 1
14051: oPushResult
14052: oNodeSetInt
14053: oPop 3
14055: oGetLocal 1
14057: oReturn
14058: oReturn
14059: oLocalSpace 0
14061: oGetParam 1
14063: oPushResult
14064: oSetResult 22
14066: oPushResult
14067: oNodeGetInt
14068: oPop 2
14070: oPushResult
14071: oEmitInt
14072: oPop 1
14074: oReturn
14075: oLocalSpace 1
14077: oGetAddrLocal 1
14079: oPushResult
14080: oSetResult 14
14082: oPushResult
14083: oGetParam 1
14085: oPushResult
14086: oCall 14031
14088: oPop 2
14090: oAssign
14091: oGetLocal 1
14093: oPushResult
14094: oScopeDeclare
14095: oPop 1
14097: oGetLocal 1
14099: oReturn
14100: oReturn
14101: oLocalSpace 1
14103: oGetAddrGlobal 25
14105: oPushResult
14106: oSetResult 0
14108: oAssign
14109: oGetAddrGlobal 4
14111: oPushResult
14112: oId_mysystem
14113: oAssign
14114: oGetAddrGlobal 5
14116: oPushResult
14117: oSetResult 28
14119: oPushResult
14120: oSetResult 4
14122: oPushResult
14123: oCall 11965
14125: oPop 2
14127: oAssign
14128: oGetAddrGlobal 6
14130: oPushResult
14131: oSetResult 30
14133: oPushResult
14134: oSetResult 4
14136: oPushResult
14137: oCall 11965
14139: oPop 2
14141: oAssign
14142: oGetAddrGlobal 7
14144: oPushResult
14145: oSetResult 33
14147: oPushResult
14148: oSetResult 1
14150: oPushResult
14151: oCall 11965
14153: oPop 2
14155: oAssign
14156: oGetAddrGlobal 8
14158: oPushResult
14159: oSetResult 34
14161: oPushResult
14162: oSetResult 1
14164: oPushResult
14165: oCall 11965
14167: oPop 2
14169: oAssign
14170: oGetAddrGlobal 9
14172: oPushResult
14173: oSetResult 35
14175: oPushResult
14176: oSetResult 1
14178: oPushResult
14179: oCall 11965
14181: oPop 2
14183: oAssign
14184: oGetAddrGlobal 10
14186: oPushResult
14187: oGetGlobal 9
14189: oPushResult
14190: oCall 13078
14192: oPop 1
14194: oAssign
14195: oGetAddrGlobal 11
14197: oPushResult
14198: oSetResult 29
14200: oPushResult
14201: oSetResult 1
14203: oPushResult
14204: oCall 11965
14206: oPop 2
14208: oAssign
14209: oGetAddrGlobal 12
14211: oPushResult
14212: oSetResult 31
14214: oPushResult
14215: oSetResult 4
14217: oPushResult
14218: oCall 11965
14220: oPop 2
14222: oAssign
14223: oGetAddrGlobal 13
14225: oPushResult
14226: oSetResult 32
14228: oPushResult
14229: oSetResult 8
14231: oPushResult
14232: oCall 11965
14234: oPop 2
14236: oAssign
14237: oGetAddrGlobal 14
14239: oPushResult
14240: oSetResult 37
14242: oPushResult
14243: oSetResult 8
14245: oPushResult
14246: oCall 11965
14248: oPop 2
14250: oAssign
14251: oGetGlobal 14
14253: oPushResult
14254: oSetResult 37
14256: oPushResult
14257: oGetGlobal 11
14259: oPushResult
14260: oNodeSet
14261: oPop 3
14263: oGetAddrGlobal 15
14265: oPushResult
14266: oSetResult 41
14268: oPushResult
14269: oSetResult 256
14271: oPushResult
14272: oCall 11965
14274: oPop 2
14276: oAssign
14277: oGetAddrGlobal 16
14279: oPushResult
14280: oSetResult 42
14282: oPushResult
14283: oSetResult 256
14285: oPushResult
14286: oCall 11965
14288: oPop 2
14290: oAssign
14291: oGetGlobal 16
14293: oPushResult
14294: oSetResult 42
14296: oPushResult
14297: oSetResult 255
14299: oPushResult
14300: oNodeSetInt
14301: oPop 3
14303: oGetAddrLocal 1
14305: oPushResult
14306: oSetResult 19
14308: oPushResult
14309: oId_File
14310: oPushResult
14311: oCall 14031
14313: oPop 2
14315: oAssign
14316: oGetLocal 1
14318: oPushResult
14319: oSetResult 21
14321: oPushResult
14322: oGetGlobal 5
14324: oPushResult
14325: oNodeSet
14326: oPop 3
14328: oGetLocal 1
14330: oPushResult
14331: oScopeDeclare
14332: oPop 1
14334: oGetAddrLocal 1
14336: oPushResult
14337: oSetResult 19
14339: oPushResult
14340: oId_Integer
14341: oPushResult
14342: oCall 14031
14344: oPop 2
14346: oAssign
14347: oGetLocal 1
14349: oPushResult
14350: oSetResult 21
14352: oPushResult
14353: oGetGlobal 6
14355: oPushResult
14356: oNodeSet
14357: oPop 3
14359: oGetLocal 1
14361: oPushResult
14362: oScopeDeclare
14363: oPop 1
14365: oGetAddrLocal 1
14367: oPushResult
14368: oSetResult 19
14370: oPushResult
14371: oId_Boolean
14372: oPushResult
14373: oCall 14031
14375: oPop 2
14377: oAssign
14378: oGetLocal 1
14380: oPushResult
14381: oSetResult 21
14383: oPushResult
14384: oGetGlobal 7
14386: oPushResult
14387: oNodeSet
14388: oPop 3
14390: oGetLocal 1
14392: oPushResult
14393: oScopeDeclare
14394: oPop 1
14396: oGetAddrLocal 1
14398: oPushResult
14399: oSetResult 19
14401: oPushResult
14402: oId_Char
14403: oPushResult
14404: oCall 14031
14406: oPop 2
14408: oAssign
14409: oGetLocal 1
14411: oPushResult
14412: oSetResult 21
14414: oPushResult
14415: oGetGlobal 9
14417: oPushResult
14418: oNodeSet
14419: oPop 3
14421: oGetLocal 1
14423: oPushResult
14424: oScopeDeclare
14425: oPop 1
14427: oGetAddrLocal 1
14429: oPushResult
14430: oSetResult 19
14432: oPushResult
14433: oId_Byte
14434: oPushResult
14435: oCall 14031
14437: oPop 2
14439: oAssign
14440: oGetLocal 1
14442: oPushResult
14443: oSetResult 21
14445: oPushResult
14446: oGetGlobal 11
14448: oPushResult
14449: oNodeSet
14450: oPop 3
14452: oGetLocal 1
14454: oPushResult
14455: oScopeDeclare
14456: oPop 1
14458: oGetAddrLocal 1
14460: oPushResult
14461: oSetResult 19
14463: oPushResult
14464: oId_Single
14465: oPushResult
14466: oCall 14031
14468: oPop 2
14470: oAssign
14471: oGetLocal 1
14473: oPushResult
14474: oSetResult 21
14476: oPushResult
14477: oGetGlobal 12
14479: oPushResult
14480: oNodeSet
14481: oPop 3
14483: oGetLocal 1
14485: oPushResult
14486: oScopeDeclare
14487: oPop 1
14489: oGetAddrLocal 1
14491: oPushResult
14492: oSetResult 19
14494: oPushResult
14495: oId_Double
14496: oPushResult
14497: oCall 14031
14499: oPop 2
14501: oAssign
14502: oGetLocal 1
14504: oPushResult
14505: oSetResult 21
14507: oPushResult
14508: oGetGlobal 13
14510: oPushResult
14511: oNodeSet
14512: oPop 3
14514: oGetLocal 1
14516: oPushResult
14517: oScopeDeclare
14518: oPop 1
14520: oGetAddrLocal 1
14522: oPushResult
14523: oSetResult 19
14525: oPushResult
14526: oId_Pointer
14527: oPushResult
14528: oCall 14031
14530: oPop 2
14532: oAssign
14533: oGetLocal 1
14535: oPushResult
14536: oSetResult 21
14538: oPushResult
14539: oGetGlobal 14
14541: oPushResult
14542: oNodeSet
14543: oPop 3
14545: oGetLocal 1
14547: oPushResult
14548: oScopeDeclare
14549: oPop 1
14551: oGetAddrLocal 1
14553: oPushResult
14554: oSetResult 19
14556: oPushResult
14557: oId_ShortString
14558: oPushResult
14559: oCall 14031
14561: oPop 2
14563: oAssign
14564: oGetLocal 1
14566: oPushResult
14567: oSetResult 21
14569: oPushResult
14570: oGetGlobal 16
14572: oPushResult
14573: oNodeSet
14574: oPop 3
14576: oGetLocal 1
14578: oPushResult
14579: oScopeDeclare
14580: oPop 1
14582: oGetAddrLocal 1
14584: oPushResult
14585: oSetResult 16
14587: oPushResult
14588: oId_True
14589: oPushResult
14590: oCall 14031
14592: oPop 2
14594: oAssign
14595: oGetLocal 1
14597: oPushResult
14598: oSetResult 21
14600: oPushResult
14601: oGetGlobal 7
14603: oPushResult
14604: oNodeSet
14605: oPop 3
14607: oGetLocal 1
14609: oPushResult
14610: oSetResult 22
14612: oPushResult
14613: oSetResult 1
14615: oPushResult
14616: oNodeSetInt
14617: oPop 3
14619: oGetLocal 1
14621: oPushResult
14622: oScopeDeclare
14623: oPop 1
14625: oGetAddrLocal 1
14627: oPushResult
14628: oSetResult 16
14630: oPushResult
14631: oId_False
14632: oPushResult
14633: oCall 14031
14635: oPop 2
14637: oAssign
14638: oGetLocal 1
14640: oPushResult
14641: oSetResult 21
14643: oPushResult
14644: oGetGlobal 7
14646: oPushResult
14647: oNodeSet
14648: oPop 3
14650: oGetLocal 1
14652: oPushResult
14653: oSetResult 22
14655: oPushResult
14656: oSetResult 0
14658: oPushResult
14659: oNodeSetInt
14660: oPop 3
14662: oGetLocal 1
14664: oPushResult
14665: oScopeDeclare
14666: oPop 1
14668: oGetAddrLocal 1
14670: oPushResult
14671: oSetResult 16
14673: oPushResult
14674: oId_Nil
14675: oPushResult
14676: oCall 14031
14678: oPop 2
14680: oAssign
14681: oGetLocal 1
14683: oPushResult
14684: oSetResult 21
14686: oPushResult
14687: oGetGlobal 14
14689: oPushResult
14690: oNodeSet
14691: oPop 3
14693: oGetLocal 1
14695: oPushResult
14696: oSetResult 22
14698: oPushResult
14699: oSetResult 0
14701: oPushResult
14702: oNodeSetInt
14703: oPop 3
14705: oGetLocal 1
14707: oPushResult
14708: oScopeDeclare
14709: oPop 1
14711: oGetAddrGlobal 17
14713: oPushResult
14714: oId_Ord
14715: oPushResult
14716: oCall 14075
14718: oPop 1
14720: oAssign
14721: oGetAddrGlobal 18
14723: oPushResult
14724: oId_Chr
14725: oPushResult
14726: oCall 14075
14728: oPop 1
14730: oAssign
14731: oGetAddrGlobal 19
14733: oPushResult
14734: oId_Pred
14735: oPushResult
14736: oCall 14075
14738: oPop 1
14740: oAssign
14741: oGetAddrGlobal 20
14743: oPushResult
14744: oId_Succ
14745: oPushResult
14746: oCall 14075
14748: oPop 1
14750: oAssign
14751: oGetAddrGlobal 21
14753: oPushResult
14754: oId_Sizeof
14755: oPushResult
14756: oCall 14075
14758: oPop 1
14760: oAssign
14761: oReturn
