%
% Pascal Compiler
%

% --------------------------- Const Expressions --------------------------


% Constant expressions are evaluated at compile time.
% They are limited to constant literals, declared constants (not including TypedConstants!)
% and a small selection of built-in functions. 
%
% The value of a constant expression is left on the Value Stack.
% The type is left on the Type Stack.

ConstExpr:
   @ConstBoolExpr
   {[
      | '=' :
         @ConstBoolTerm
         @ConstMatchTypes
         oTypeSPop  oTypeSPush( BooleanType )
         oValueEqual
      | '<>' :
         @ConstBoolExpr
         @ConstMatchTypes
         oTypeSPop  oTypeSPush( BooleanType )
         oValueNotEqual
      | '<' :
         @ConstBoolExpr
         @ConstMatchTypes
         oTypeSPop  oTypeSPush( BooleanType )
         oValueLess
      | '>' :
         @ConstBoolExpr
         @ConstMatchTypes
         oTypeSPop  oTypeSPush( BooleanType )
         oValueGreater
      | '<=' :
         @ConstBoolExpr
         @ConstMatchTypes
         oTypeSPop  oTypeSPush( BooleanType )
         oValueLessEqual
      | '>=' :
         @ConstBoolExpr
         @ConstMatchTypes
         oTypeSPop  oTypeSPush( BooleanType )
         oValueGreaterEqual
      | * :  >
   ]};


ConstBoolExpr:
   @ConstBoolTerm
   {[
      | pOr :
         @ConstRequireBool
         @ConstBoolTerm
         @ConstRequireBoolPop
         oValueOr
      | * :  >
   ]};


ConstBoolTerm:
   @ConstBoolFactor
   {[
      | pAnd :
         @ConstRequireBool
         @ConstBoolFactor
         @ConstRequireBoolPop
         oValueAnd
      | * :  >
   ]};


ConstBoolFactor:
   [
      | pNot :
         @ConstBoolFactor
         @ConstRequireBool
         oValueNot
      | * :
         @ConstArithExpr
   ];


ConstArithExpr:
   @ConstTerm
   {[
      | '+' :
         @ConstTerm
         @ConstMatchTypes
         oValueAdd
      | '-' :
         @ConstTerm
         @ConstMatchTypes
         oValueSub
      | * :  >
   ]};


ConstTerm:
   @ConstFactor
   {[
      | pTimes :
         @ConstFactor
         @ConstMatchTypes
         oValueMult
      | pDivide :
         @ConstFactor
         @ConstMatchTypes
         oValueDiv
      | * :  >
   ]};


ConstFactor:
   [
      | pPlus :
         @ConstPrimary
      | pMinus :
         @ConstPrimary
         oValueNegate
      | * :
         @ConstPrimary
   ];


ConstPrimary:
   [
      | pIntLit :
         oValuePush( TOKEN_VALUE )
         oTypeSPush( IntegerType )
      | pCharLit :
         oValuePush( TOKEN_VALUE )
         oTypeSPush( CharType )
      | pStrLit :
         oValuePushString( CURRENT_STRLIT )
         oTypeSPush( StrLitType )
      | '(' :
         @ConstExpr
         ')'
      | pIdent :
         Node decl = oScopeFindRequire
         @ResolveUnitRef( decl )
         [ oNodeType( decl )
            | nBuiltInFunc :
               @ConstBuiltInFunc( decl )
            | nConst :
               oValuePush( oNodeGetInt( decl, qValue ) )
               oTypeSPush( oNodeGet( decl, qType ) )
            | nEnumValue :
               oValuePush( oNodeGetInt( decl, qValue ) )
               oTypeSPush( oNodeGet( decl, qType ) )
            | * :
               #eNotConst
               oValuePush( 0 )
               oTypeSPush( IntegerType )
         ]
      | '@' :
         #eNotImplemented
         oValuePush( 0 )
         oTypeSPush( UniversalPointerType )
      | * :
         #eNotConst
         oValuePush( 0 )
         oTypeSPush( IntegerType )
   ];


ConstBuiltInFunc( Node decl ):
   #eNotImplemented
   ;


ConstRequireBoolPop:
   [ oTypeSNodeType
      | nBooleanType :
      | * :          #eNotBoolean
   ]
   oTypeSPop;


ConstRequireBool:
   [ oTypeSNodeType
      | nBooleanType :
      | * :          #eNotBoolean
   ];


% Require that the top two types on the type stack are matching (ignoring subranges).
% Pop one of them, leaving only one.
% The types refer to constant values on the Value Stack,
% so any implicit conversion would occur there, not in code.
%
% Some implicit conversion is allowed for either of the types.
% See also ConstCoerceType where only the top type may change.
%
ConstMatchTypes:
   node_type nt = oTypeSNodeType
   oTypeSPop
   [ equal_node_type( nt, oTypeSNodeType )
      | false :
         % Some implicit conversion is allowed even here
         [ oTypeSNodeType
            | nPointerType :
               [ nt
                  | nUniversalPointerType :  >>
                  | * :
               ]
            | nUniversalPointerType :
               [ nt
                  | nPointerType :  >>
                  | * :
               ]
            | nStrLitType :
               [ nt
                  | nCharType :
                     oValueCharToString
                     >>
                  | * :
               ]
            | nCharType :
               [ nt
                  | nStrLitType :
                     oValueSwap
                     oValueCharToString
                     oValueSwap
                     oTypeSPop
                     oTypeSPush( StrLitType )
                     >>
                  | * :
               ]
            | * :
         ]
         #eTypeMismatch
      | * :
   ];


% Given two constant values on the value stack, and two types on the type stack.
% Perform any necessary implicit conversions so the second value is the type of the
% value under it.  Pop the top type, leaving only the desired type.
%
ConstCoerceType:
   node_type nt = oTypeSNodeType
   oTypeSPop
   [ equal_node_type( nt, oTypeSNodeType )
      | false :
         % Some implicit conversion is allowed even here
         [ oTypeSNodeType
            | nPointerType :
               [ nt
                  | nUniversalPointerType :  >>
                  | * :
               ]
            | nUniversalPointerType :
               [ nt
                  | nPointerType :  >>
                  | * :
               ]
            | nStrLitType :
               [ nt
                  | nCharType :
                     oValueCharToString
                     >>
                  | * :
               ]
            | * :
         ]
         #eTypeMismatch
      | * :
   ];

