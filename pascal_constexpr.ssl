%
% Pascal Compiler
%

% --------------------------- Const Expressions --------------------------


% Constant expressions are evaluated at compile time.
% They are limited to constant literals, declared constants (not including TypedConstants!)
% and a small selection of built-in functions. 
%
% The value of a constant expression is left on the Value Stack.
% The type is left on the Type Stack.

ConstExpr:
   @ConstBoolExpr
   {[
      | '=' :
         @ConstBoolTerm
         @ConstMatchTypes
         [ oTypeSNodeType
            | nStrLitType :   oValueStringCmp  oValuePush( 0 )  oValueEqual
            | * :             oValueEqual
         ]
         oTypeSPop  oTypeSPush( BooleanType )
      | '<>' :
         @ConstBoolExpr
         @ConstMatchTypes
         [ oTypeSNodeType
            | nStrLitType :   oValueStringCmp  oValuePush( 0 )  oValueNotEqual
            | * :             oValueNotEqual
         ]
         oTypeSPop  oTypeSPush( BooleanType )
      | '<' :
         @ConstBoolExpr
         @ConstMatchTypes
         [ oTypeSNodeType
            | nStrLitType :   oValueStringCmp  oValuePush( 0 )  oValueLess
            | * :             oValueLess
         ]
         oTypeSPop  oTypeSPush( BooleanType )
      | '>' :
         @ConstBoolExpr
         @ConstMatchTypes
         [ oTypeSNodeType
            | nStrLitType :   oValueStringCmp  oValuePush( 0 )  oValueGreater
            | * :             oValueGreater
         ]
         oTypeSPop  oTypeSPush( BooleanType )
      | '<=' :
         @ConstBoolExpr
         @ConstMatchTypes
         [ oTypeSNodeType
            | nStrLitType :   oValueStringCmp  oValuePush( 0 )  oValueLessEqual
            | * :             oValueLessEqual
         ]
         oTypeSPop  oTypeSPush( BooleanType )
      | '>=' :
         @ConstBoolExpr
         @ConstMatchTypes
         [ oTypeSNodeType
            | nStrLitType :   oValueStringCmp  oValuePush( 0 )  oValueGreaterEqual
            | * :             oValueGreaterEqual
         ]
         oTypeSPop  oTypeSPush( BooleanType )
      | * :  >
   ]};


ConstBoolExpr:
   @ConstBoolTerm
   {[
      | pOr :
         @ConstRequireBool
         @ConstBoolTerm
         @ConstRequireBoolPop
         oValueOr
      | * :  >
   ]};


ConstBoolTerm:
   @ConstBoolFactor
   {[
      | pAnd :
         @ConstRequireBool
         @ConstBoolFactor
         @ConstRequireBoolPop
         oValueAnd
      | * :  >
   ]};


ConstBoolFactor:
   [
      | pNot :
         @ConstBoolFactor
         @ConstRequireBool
         oValueNot
      | * :
         @ConstArithExpr
   ];


ConstArithExpr:
   @ConstTerm
   {[
      | '+' :
         @ConstTerm
         @ConstMatchTypes
         [ oTypeSNodeType
            | nStrLitType :   oValueStringConcat
            | * :             oValueAdd
         ]
      | '-' :
         @ConstTerm
         @ConstMatchTypes
         [ oTypeSNodeType
            | nStrLitType :   #eNotAllowed
            | * :             oValueSub
         ]
      | * :  >
   ]};


ConstTerm:
   @ConstFactor
   {[
      | pTimes :
         @ConstFactor
         @ConstMatchTypes
         [ oTypeSNodeType
            | nStrLitType :   #eNotAllowed
            | * :             oValueMult
         ]
      | pDivide :
         @ConstFactor
         @ConstMatchTypes
         [ oTypeSNodeType
            | nStrLitType :   #eNotAllowed
            | * :             oValueDiv
         ]
      | * :  >
   ]};


ConstFactor:
   [
      | pPlus :
         @ConstPrimary
      | pMinus :
         @ConstPrimary
         oValueNegate
      | * :
         @ConstPrimary
   ];


ConstPrimary:
   [
      | pIntLit :
         oValuePush( TOKEN_VALUE )
         oTypeSPush( IntegerType )
      | pCharLit :
         oValuePush( TOKEN_VALUE )
         oTypeSPush( CharType )
      | pStrLit :
         oValuePushString( CURRENT_STRLIT )
         oTypeSPush( StrLitType )
      | '(' :
         @ConstExpr
         ')'
      | pIdent :
         Node decl = oScopeFindRequire
         @ResolveUnitRef( decl )
         [ oNodeType( decl )
            | nBuiltInFunc :
               @ConstBuiltInFunc( decl )
            | nConst :
               oValuePush( oNodeGetInt( decl, qValue ) )
               oTypeSPush( oNodeGet( decl, qType ) )
            | nConstStr :
               oValuePushString( oNodeGetString( decl, qValueStr ) )
               oTypeSPush( oNodeGet( decl, qType ) )
            | nEnumValue :
               oValuePush( oNodeGetInt( decl, qValue ) )
               oTypeSPush( oNodeGet( decl, qType ) )
            | * :
               #eNotConst
               oValuePush( 0 )
               oTypeSPush( IntegerType )
         ]
      | '@' :
         #eNotImplemented
         oValuePush( 0 )
         oTypeSPush( UniversalPointerType )
      | * :
         #eNotConst
         oValuePush( 0 )
         oTypeSPush( IntegerType )
   ];

ConstRequireBoolPop:
   [ oTypeSNodeType
      | nBooleanType :
      | * :          #eNotBoolean
   ]
   oTypeSPop;


ConstRequireBool:
   [ oTypeSNodeType
      | nBooleanType :
      | * :          #eNotBoolean
   ];


% Require that the top two types on the type stack are matching (ignoring subranges).
% Pop one of them, leaving only one.
% The types refer to constant values on the Value Stack,
% so any implicit conversion would occur there, not in code.
%
% Some implicit conversion is allowed for either of the types.
% See also ConstCoerceType where only the top type may change.
%
ConstMatchTypes:
   node_type nt = oTypeSNodeType
   oTypeSPop
   [ equal_node_type( nt, oTypeSNodeType )
      | false :
         % Some implicit conversion is allowed even here
         [ oTypeSNodeType
            | nPointerType :
               [ nt
                  | nUniversalPointerType :  >>
                  | * :
               ]
            | nUniversalPointerType :
               [ nt
                  | nPointerType :  >>
                  | * :
               ]
            | nStrLitType :
               [ nt
                  | nCharType :
                     oValueCharToString
                     >>
                  | * :
               ]
            | nCharType :
               [ nt
                  | nStrLitType :
                     oValueSwap
                     oValueCharToString
                     oValueSwap
                     oTypeSPop
                     oTypeSPush( StrLitType )
                     >>
                  | * :
               ]
            | * :
         ]
         #eTypeMismatch
      | * :
   ];


% Given a constant value on the value stack, its type on the type stack,
% and the desired type under it on the type stack.
% Perform any necessary implicit conversions so the value is the desired type.
% Pop the top type, leaving only the desired type.
%
ConstCoerceType:
   node_type nt = oTypeSNodeType
   oTypeSPop
   [ equal_node_type( nt, oTypeSNodeType )
      | false :
         % Some implicit conversion is allowed even here
         [ oTypeSNodeType
            | nPointerType :
               [ nt
                  | nUniversalPointerType :  >>
                  | * :
               ]
            | nUniversalPointerType :
               [ nt
                  | nPointerType :  >>
                  | * :
               ]
            | nStrLitType :
               [ nt
                  | nCharType :
                     oValueCharToString
                     >>
                  | * :
               ]
            | nShortStringType :
               [ nt
                  | nStrLitType :  >>
                  | nCharType :
                     oValueCharToString
                     >>
                  | * :
               ]
            | * :
         ]
         #eTypeMismatch
      | * :
   ];


% These are the methods that Pascal allows in a constant expression:
%   Abs( x: integer_or_real ) : integer_or_real
%   Round( x: real ) : integer
%   Trunc( x: real ) : integer
%   Chr( x: integer ) : char
%   Ord( x: ordinal ) : integer
%   Length( s: string ) : integer
%   Pred( x: ordinal ) : ordinal
%   Succ( x: ordinal ) : ordinal
%   SizeOf( var, expr, or typename ) : integer
%   Odd( x: integer ) : boolean  - true if the argument is odd
%
ConstBuiltInFunc( Node method ):

   % Ord(x)
   [ oNodeEqual( method, BuiltIn_Ord )
      | true :
         '('
         @ConstExpr
         ')'
         [ oTypeSNodeType
            | nIntegerType, nEnumType :
            | nBooleanType, nByteType, nCharType :
            | * :  #eTypeMismatch
         ]
         oTypeSPop
         oTypeSPush( IntegerType )
         ')'
         >>
      | * :
   ]

   % Chr(x)
   [ oNodeEqual( method, BuiltIn_Chr )
      | true :
         '('
         @ConstExpr
         ')'
         [ oTypeSNodeType
            | nIntegerType :
            | nByteType :
            | * :  #eTypeMismatch
         ]
         oTypeSPop
         oTypeSPush( CharType )
         ')'
         >>
      | * :
   ]

   % Pred(x)
   [ oNodeEqual( method, BuiltIn_Pred )
      | true :
         '('
         @ConstExpr
         [ oTypeSNodeType
            | nEnumType :
               [ oNodeGetBoolean( oTypeSTop, qHasGap )
                  | true :   #eCantUsePredSuccOnEnumWithValueGaps
                  | * :
               ]
            | * :  #eTypeMismatch
         ]
         oValuePush( 1 )  oValueSub
         ')'
         >>
      | * :
   ]

   % Succ(x)
   [ oNodeEqual( method, BuiltIn_Succ )
      | true :
         '('
         @ConstExpr
         [ oTypeSNodeType
            | nEnumType :
               [ oNodeGetBoolean( oTypeSTop, qHasGap )
                  | true :   #eCantUsePredSuccOnEnumWithValueGaps
                  | * :
               ]
            | * :  #eTypeMismatch
         ]
         oValuePush( 1 )  oValueAdd
         ')'
         >>
      | * :
   ]

   #eNotImplemented
   ;


