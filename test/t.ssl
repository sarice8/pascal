%  sccsid = "%W% %G% %U% %P%";

title: 'SSL Translator 1.3.0 -- August 23 ''93';

%
% *****************************************************************************
%
%   Syntax/Semantic Language Compiler
%
%   by Steve Rice
%
%   Aug 31, 1989
%
% *****************************************************************************
%
%   ssl.ssl             SSL compiler
%
%   HISTORY
% -----------------------------------------------------------------------------
%   08/31/89 | Steve  | Translated from my SSL processor hardcoded in C
%   09/08/89 |        | SSL processor now functional, except for error recovery
%   10/18/89 |        | Added 'title' section
%   02/03/90 |        | Change to ssl.c: Added debugger output
%   03/20/91 |        | Change to ssl.c: Increased string table size
%   03/26/91 |        | Fixed bug in handling of statement ">>value"
%            |        | Fixed bug in handling of choice using a choice rule
%            |        | defined later
%   04/24/91 |        | Change to ssl.c: Increased identifier size to 50 chars
%   05/05/91 |        | Change to ssl.c: Increased identifier table size to
%            |        | 600, and moved names out of table. New limit 256 chars.
%            |        | Added "include" feature.
%   05/21/91 |        | Multiple "error" sections will use distinct error #'s
%            |        | Added postprocess optimization: reduce chains of jumps
%   06/04/91 |        | Change to ssl.c: Write rule addresses to code file
%   08/23/93 |        | Fix some loops so error recovery can terminate
%   08/25/93 |        | Reimplement using schema database for symbol table
%   08/27/93 |        | Add new language features: local variables,
%            |        | multiple parameters, inout parameters,
%            |        | expressions with nested function calls.
%            |        | (User program requires the 2.0 runtime model for new
%            |        | instructions in generated code).
%   08/29/93 |        | Reimplement compiler using above new language features
%            |        | (typically using local variables rather than stacks)
%            |        |
% 
% *****************************************************************************
%
%   BUGS
% -----------------------------------------------------------------------------
%   01/28/90 | Doesn't complain if functions called but never declared!	
%
% *****************************************************************************
%

input:
    pIdent
    pIntLit
    pStrLit
    pMinus      '-'
    pEquals     '='
    pColon      ':'
    pSemiColon  ';'
    pComma      ','
    pLParen     '('
    pRParen     ')'
    pReturn     '>>'
    pBreak      '>'
    pLCurly     '{'
    pRCurly     '}'
    pLSquare    '['
    pRSquare    ']'
    pBar        '|'
    pCall       '@'
    pEmit       '.'
    pStar       '*'
    pErr        '#'
    pQuestion   '?'
    pEof
    pInvalid

%  keywords

    pTitle
    pInput
    pOutput
    pType
    pError
    pMechanism
    pInclude
    pRules
    pEnd
    pIn
    pOut
    pInOut
    ;


output:

%  codes for SSL machine instructions

    iJumpForward
    iJumpBack
    iInput
    iInputAny
    iEmit
    iError
    iInputChoice
    iCall
    iReturn
    iSetResult
    iChoice
    iEndChoice
    iPushResult      % push ssl_result on variable stack
    iPop             % (n)  discard n entries from variable stack
    iBreak           % instruction used by debugger
    iGlobalSpace     % (n)  make space for n globals on variable stack (sets initial fp)
    iLocalSpace      % (n)  make space for n locals on variable stack
    iGetParam        % (n)  ssl_result = value of param n
    iGetFromParam    % (n)  ssl_result = value of variable whose address is in param n
    iGetLocal        % (n)  ssl_result = value of local var n
    iGetGlobal       % (n)  ssl_result = value of global var n
    iGetAddrParam    % (n)  ssl_result = addr of param n
    iGetAddrLocal    % (n)  ssl_result = addr of local var n
    iGetAddrGlobal   % (n)  ssl_result = addr of global var n
    iAssign          % variable whose address is pushed on stack = ssl_result; pop stack

%   NOTE: Any instructions added here should also be added to
%         the system_operations table in ssl.c
%         as well as optimize_table, list_generated_code.

%  other output

    iSpace;          % emit a dummy value; a value will be patched here later

error:
   eWrongType
   eNotAType
   eNotAValue
   eNotInput
   eNotOutput
   eNotARule
   eNotAnErrSig
   eNotInLoop
   eChoiceOpRuleOutOfPlace
   eUndeclRuleParamsNotSupported
   eNotTyped
   eIdentNotAllowedInExpr
   eIllegalLvalue
   eNotRuleOrGlobalDefn
   eRuleBodyAlreadyDeclared
   eReturnTypeMismatch
   eParameterMismatch
   eUndeclaredIdentifier
    eAliasNotAllowed
   ;



% Generated automatically by schema

type node_type:
	nINVALID
	Object
	nScope
	nDeclaration
	nIdent
	nInput
	nOutput
	nError
	nType
	nValue
	nMechanism
	nOperation
	nRule
	nVariable
	nParam
	nInParam
	nOutParam
	nInOutParam
	nLocal
	nGlobal
	;

type node_attribute:
	qINVALID
	qParentScope
	qDecls
	qIdent
	qValue
	qType
	qParamScope
	qScope
	qAddrDefined
	qTypeDefined
	qAddr
	;


type boolean:
    false    = 0
    true     = 1
    no       = 0
    yes      = 1;

type number:
    zero            = 0
    one             = 1
    ;

type warning:
    wRuleMissingAtSign
    ;

type Node:     % A pointer to a node in the schema database (symbol database)
    Null = 0
    ;

type kind:
    kIllegal        % not an identifier
    kUnknown        % new identifier
    kInput
    kOutput
    kError
    kType
    kVal            % an element of a type
    kMech
    kOp
    kRule
    kVar
    ;

mechanism warning_mech:
    oWarning (warning);       % issue warning message,
                              % continue normally (not in error recovery mode)

mechanism emit_mech:
    oEmitInt (int)            % emit an integer into the generated code
    Here >> int               % return the current address in the generated code
    oPatch (int addr, int val) % patch an integer into any address in the generated code
    ;

mechanism math:
    inc (inout int)
    dec (inout int)
    negate (int) >> int
    equal_zero (int) >> boolean
    equal_node_type (node_type, node_type) >> boolean     % Want equal_<type> for every type
    ;

mechanism more_builtins:      % These should be built-in SSL operations
    TOKEN_VALUE >> int        % value of just accepted token, e.g. IntLit token
    LAST_ID >> int            % id number of last accepted identifier
    ;

mechanism shortForm:          % keep a table of string shortforms for input/output
    oShortFormAdd (Node)      % associate current StrLit token with nDeclaration
    oShortFormLookup (out Node);   % look up strLit, return associated nDeclaration


% keep different patch stacks, each with a stack of position markers:

type patchStack:
    patchChoiceTableAddr    % addr where pointer to table is stored
    patchChoiceTable        % build up choice table here (value,addr)
    patchChoiceExit         % addrs where jumps at end of each option are
    patchCall               % (addr,ident) where calls to undefined rules are
    patchLoop               % addr of start of a loop
    patchBreak;             % addrs where jumps out of a loop are

mechanism patch_mech:
    oPatchMark(patchStack)             % mark current position on a stack
    oPatchAtMark(patchStack) >> boolean     % true if all items since
                                           %   last mark are popped
                                           %   (mark is dropped if true)
    oPatchPushHere(patchStack)         % put current address on a patch stack
    oPatchPushInt (patchStack, int)    % put int on a patch stack
    oPatchPushIdent(patchStack)        % put last ident on a patch stack
    oPatchAnyEntries(patchStack) >> boolean    % are there any entries?
    oPatchPopFwd(patchStack)           % fix table, storing here-x at x,
                                       %   where x is on top of the stack
    oPatchPopBack(patchStack)          % emit here-x here (advance 'here')
    oPatchPopValue(patchStack)         % emit x here (advance 'here')
    oPatchPopCall(patchStack);         % fix table, storing value of ident i
                                       %   at x, where i is on top of stack
                                       %   and x is under it  (pop both)

mechanism titleMech:
    oTitleSet;          % define title to be strlit just read

mechanism doc:         % display documentary info
    oDocNewRule;        % print "Rule <token>"

mechanism include_mech:
    oInclude;           % include the SSL file whose name is in the
                       % string token just accepted

mechanism node_mech:
    oNodeNew (node_type) >> Node         % create new node
    oNodeSet (Node, node_attribute, Node)   % set Node attribute of node
    oNodeSetInt (Node, node_attribute, int) % set int attribute of node
    oNodeSetBoolean (Node, node_attribute, boolean)
    oNodeGet (Node, node_attribute) >> Node    % get Node attribute of node
    oNodeGetInt (Node, node_attribute) >> int  % get int attribute of node
    oNodeGetBoolean (Node, node_attribute) >> boolean  % get int attribute of node
    oNodeNull (Node) >> boolean          % is node null?
    oNodeNext (inout Node)               % advance Node to next in list    
    oNodeType (Node) >> node_type        % return node type of node
    oNodeEqual (Node, Node) >> boolean   % compare two nodes for equality
                                         % (i.e. same node, not just same contents)
    ;

mechanism scope_mech:
    oScopeBegin (out Node)             % create a new scope.  Subsequent declarations will go here.
                                       % Sets nScope's qParent to parent scope.
    oScopeOpen (Node)                  % open an existing scope.  Its definitions become visible again.
    oScopeEnd                          % end current scope.  Subsequent declarations will go to parent scope.
    oScopeDeclare (Node)               % declare node in current scope
    oScopeFind (out Node) >> boolean   % find declaration of last accepted identifier
    oScopeFindRequire (out Node)       % find declaration of last accepted identifier.
                                       % Go into error recovery if not found.
    ;


mechanism install_mech:
    oInstallSystemOperations (inout int next_operation)   % Predefine some operations
    oInstallSystemTypes (out Node int_type)   % Predefine some types.
                                              % Return nType declaration of int type.
    ;

mechanism write_mech:
    oWriteTables (Node global_scope);   % Write files, given global scope of symbol table.

rules

% ---------------------- Global Variables --------------------

Node    IntType             % nType node for built-in "int" type
Node    CurrentRule         % nRule node for current rule being declared
int     NumGlobals          % number of global variables in program
int     NumLocals           % number of local variables in current rule
int     RuleLocalSpaceAddr  % address of LocalSpace argument for rule
int     NextOperation       % code for next semantic operation decl
int     NextError           % next error code
Node    GlobalScope         % global nScope

% -------------------- Forward Declarations ------------------

Section >> boolean;
ValueList (node_type class, inout int value, boolean str_alias_allowed, Node t);
OperationDefinition >> boolean;
RuleSectionDefinition >> boolean;
RuleBodyDefinition (Node r);
RuleRedefinition (Node r);
Statement >> boolean;
CallOperation (Node o);
ActualParams (Node r) >> int;
CallRule (Node r);
CallUndefinedRule;
Assignment (Node i);
CopyChoiceTable (int num_options);
Expr (out Node t);
Lvalue (out Node t);
Lvalue_HaveIdent (Node i, out Node t);
Const (out Node t) >> int;
IntConst >> int;
LookupType (out Node i);
LookupInput (out Node i);
LookupOutput (out Node i);
LookupValue (out Node i);
LookupError (out Node i);
RequireType (Node i);
RequireInput (Node i);
RequireOutput (Node i);
RequireValue (Node i);
RequireError (Node i);
RequireRule (Node i);
RequireNoType (Node r);
RequireMatchValueType (Node v, Node t);
MatchType (Node t1, Node t2) >> boolean;
RequireMatchType (Node t1, Node t2);
MatchIntType (Node t) >> boolean;
RequireMatchIntType (Node t);
EmitValue (Node i);
EmitAddr (Node v);

% ------------------------- Main Parser ----------------------

ProcessSSL:
    int   global_space_addr  % address of iGlobalSpace arg for global vars

    oScopeBegin (GlobalScope)

    NextError = 0
    NextOperation = 0

    oInstallSystemOperations (NextOperation)
    oInstallSystemTypes (IntType)

    NumGlobals = 0                 % Count global variables
    .iGlobalSpace                  % Make space for global variables
    global_space_addr = Here   .iSpace


    {[ @Section
        | true:
        | *:  >
    ]}

    @FixForwardCalls

    inc (NumGlobals)   % because globals addressed from 1 (addr 0 unused)
    oPatch (global_space_addr, NumGlobals)

    oScopeEnd

    oWriteTables (GlobalScope)
    ;


% Returns true if a section found

Section >> boolean:

    [
        | pTitle:      @Title
        | pInput:      @Input
        | pOutput:     @Output
        | pError:      @Error
        | pType:       @Type
        | pInclude:    @Include
        | pMechanism:  @Mechanism
        | pRules:      @Rules

        | pEof:        >> false      % end of file
    ]
    >> true
    ;

% ------------------------- Sections -------------------------

Title:
    ':' pStrLit oTitleSet ';' ;

Input:
    int  next_value
    ':'
    next_value = 0
    @ValueList (nInput, next_value, true, Null)
    ';';

Output:
    int  next_value
    ':'
    next_value = 0
    @ValueList (nOutput, next_value, true, Null)
    ';';

Error:
    ':'
    @ValueList (nError, NextError, false, Null)
    ';';

Type:
    Node  t
    int   next_value

    pIdent  t = oNodeNew (nType)  oNodeSetInt (t, qIdent, LAST_ID)
    oScopeDeclare (t)
    ':'
    next_value = 0
    @ValueList (nValue, next_value, false, t)
    ';';

Include:
    pStrLit oInclude;

Mechanism:
    Node  m

    pIdent
    m = oNodeNew (nMechanism)  oNodeSetInt(m, qIdent, LAST_ID)
    oScopeDeclare (m)

    ':'
    {[ @OperationDefinition
        | true:
        | *:  >
    ]}
    ';' ;

Rules:
    {[ @RuleSectionDefinition
        | true:
        | *:  >
    ]}
    pEnd ;


% ------------------------- Value List ----------------------

ValueList (node_type class, inout int value, boolean str_alias_allowed, Node t):
    Node  p, t2
    {[
        | pIdent:
            p = oNodeNew (class)  oNodeSetInt (p, qIdent, LAST_ID)

            [ class
                | nValue :    oNodeSet (p, qType, t)
                | * :
            ]

            [ | pStrLit:
                [ str_alias_allowed
                    | true:  oShortFormAdd (p)   % Associate short form with declaration
                    | *:     #eAliasNotAllowed
                ]
              | *:
            ]

            [ | '=':       value = @Const(t2)
                           [ @MatchType (t, t2)
                               | true :
                               | false :  @RequireMatchIntType(t2)
                           ]
              |*:
            ]
            oNodeSetInt (p, qValue, value)
            inc (value)

            oScopeDeclare (p)

        | *:  >
    ]};

% ------------------------- Variables ------------------------

%  Declare a list of variables, given class (local/global),
%  nType, and a counter used to assign addresses for that class.

DeclareVariables (node_type class, Node t, inout int addr_counter):
    Node  i
    {
        pIdent
        i = oNodeNew(class)  oNodeSetInt(i, qIdent, LAST_ID)
        oNodeSet (i, qType, t)

        % Assign address to variable
        inc (addr_counter)   oNodeSetInt (i, qAddr, addr_counter)

        oScopeDeclare (i)

        [ | ',' :
          | * :   >
        ]
    };

%  Declare a list of global variables, given nType.

DeclareGlobals (Node t):
    @DeclareVariables (nGlobal, t, NumGlobals);

%  Declare a list of local variables, given nType.

DeclareLocals (Node t):
    @DeclareVariables (nLocal, t, NumLocals);


%  Defines formal parameters (if any) in current scope.
%  The caller should have called oScopeBegin to begin a
%  scope just for parameters.  (This gives a simple way
%  to check if an operation/rule has parameters).
%  Does not end the scope.
%
%  nParam's may be named or unnamed (qIdent == 0)
%
%  Parameters are assigned addresses in reverse order
%  from n to 1.  This is for efficient stack access.
%  E.g. func(a,b,c):  address of a:3, b:2, c:1
%  (Later I would like to instead push actuals in reverse order)

FormalParamDefinition (Node scope):
    int        num_params
    node_type  dir
    Node       p, t

    [ | '(' :
      | *   : >>
    ]

    num_params = 0      % Count the parameters, to assign addresses

    {
        inc (num_params)

        % parameter direction
        [
            | pIn :     dir = nInParam
            | pOut :    dir = nOutParam
            | pInOut :  dir = nInOutParam
            | * :       dir = nInParam
        ]

        % parameter type
        pIdent  @LookupType (t)

        p = oNodeNew(dir)
        oNodeSet (p, qType, t)

        % parameter name
        [
            | pIdent :  oNodeSetInt (p, qIdent, LAST_ID)   % named parameter
            | * :       % unnamed parameter
        ]

        oScopeDeclare (p)       % declare nParam

        [
            | ',' :
            | * :   >
        ]
    }

    ')'

    %  Now go back and assign addresses to the parameters

    p = oNodeGet (scope, qDecls)

    {
        [ equal_zero (num_params)
            | true:  >
            | false:
        ]

        oNodeSetInt (p, qAddr, num_params)

        dec (num_params)
        oNodeNext (p)
    }
    ;

%  Redefine formal parameters during declaration of actual rule (with body).
%  Previously, parameters were declared by a forward declaration or by usage.
%  Ensure that types match.  Update parameter names to new names given.
%  (All parameters must be named since this will be the final declaration).
%
%  Previous parameter nScope is given, and scope has been opened.
%  (Addresses were assigned previously, no need to do it again).
%  NOTE: I probably don't really want to open the previous scope since the
%  old param names are not valid.

FormalParamRedefinition (Node scope):
    Node      p
    node_type dir, dir2
    Node      t, t2

    p = oNodeGet (scope, qDecls)       % previous param declarations

    [ | '(' :
      | *   : [ oNodeNull(p)
                  | true :
                  | * :    #eParameterMismatch
              ]
              >>
    ]

    {
        [ oNodeNull(p)
            | true :    #eParameterMismatch  % too many params given this time
            | false :
        ]

        dir = oNodeType(p)         % previous direction
        % parameter direction
        [
            | pIn :     dir2 = nInParam
            | pOut :    dir2 = nOutParam
            | pInOut :  dir2 = nInOutParam
            | * :       dir2 = nInParam
        ]
        [ equal_node_type (dir, dir2)
            | true :
            | * :     #eParameterMismatch
        ]

        t = oNodeGet (p, qType)    % previous type
        pIdent  @LookupType(t2)    % parameter type
        @RequireMatchType (t, t2)

        % parameter name
        pIdent  oNodeSetInt (p, qIdent, LAST_ID)    % must be named

        oNodeNext (p)

        [
            | ',' :
            | * :   >
        ]
    }

    ')'

    [ oNodeNull(p)
        | true :
        | * :    #eParameterMismatch   % Not enough params given this time
    ]
    ;


% ------------------------- Operations -----------------------

%  Returns true if definition found

OperationDefinition >> boolean:
    Node  op, s, t
    [
        | pIdent:
        | *:        >> false
    ]

    op = oNodeNew (nOperation)  oNodeSetInt (op, qIdent, LAST_ID)
    oNodeSetInt (op, qValue, NextOperation)
    inc (NextOperation)

    oScopeBegin (s)   % parameter scope

    @FormalParamDefinition(s)

    oNodeSet (op, qParamScope, s)

    [ | '>>': pIdent  @LookupType (t)   oNodeSet (op, qType, t)
      |*:     %  qType is Null by default
    ]

    oScopeEnd      % parameter scope

    oScopeDeclare (op)

    >> true
    ;

% ------------------------- Rules ----------------------------

%  Parse a definition in the rules secition.
%  This could be:
%      a rule definition, a rule prototype, or a global variable definition.
%  Returns true if one of the above found

RuleSectionDefinition >> boolean:
    Node  i
    [
        | pIdent:
        | * :        >> false
    ]

    [ oScopeFind (i)
        | false:     @RuleDefinition
        | true:
            [ oNodeType(i)
                | nType :  @DeclareGlobals(i)
                | nRule :  @RuleRedefinition(i)    % Should be body of fwd declared rule
                | * :      #eNotRuleOrGlobalDefn  >> true  % True to skip to next
            ]
    ]

    >> true
    ;

%   Define the parameters, and possibly the body, of a rule
%   that has not been defined previously.
%   Just parsed ident of rule.

RuleDefinition:
    Node  r
    Node  s
    Node  t

    oDocNewRule

    r = oNodeNew(nRule)  oNodeSetInt(r, qIdent, LAST_ID)
    CurrentRule = r


    oScopeBegin (s)                 % param scope
    @FormalParamDefinition(s)
    oNodeSet (r, qParamScope, s)    % leave scope open, to access params during rule

    [ | '>>':   pIdent  @LookupType(t)  oNodeSet (r, qType, t)
      | * :
    ]

    [
        | ':' :  @RuleBodyDefinition (r)
        | * :    % No body; a forward declaration of the rule.
    ]
    ';'

    oScopeEnd            % parameters scope (already linked to nRule above)

    oScopeDeclare (r)    % declare nRule
                         % (Note, can't call rule recursively since not defined until end)
    ;


% Given the nRule node

RuleBodyDefinition (Node r):
    Node  s

    oNodeSetInt (r, qValue, Here)      % Address of rule is now defined
    oNodeSetBoolean (r, qAddrDefined, yes)

    oScopeBegin (s)       % rule variables scope

    NumLocals = 0

    .iLocalSpace 
    RuleLocalSpaceAddr = Here   .iSpace

    {[ @Statement
        | true:
        | *:  >
    ]}

    .iReturn

    oPatch (RuleLocalSpaceAddr, NumLocals)

    oScopeEnd            % rule variables scope
    oNodeSet (r, qScope, s)

    ;


%   Redefine a rule (to provide body of a forward-declared rule).
%   Given the existing nRule declaration.

RuleRedefinition (Node r):
    Node  s, p
    Node  t, t2

    [ oNodeGetBoolean (r, qAddrDefined)
        | yes :   #eRuleBodyAlreadyDeclared  >>
        | * :
    ]

    oDocNewRule

    CurrentRule = r

    s = oNodeGet(r, qParamScope)
    oScopeOpen (s)   % Make the existing parameters visible.
                     % (Actually, probably don't want to do this).

    @FormalParamRedefinition (s)   % verify types, update param names

    % Verify return type matches previous declaration/usage
    t = oNodeGet (r, qType)
    [ | '>>':   pIdent  @LookupType(t2)  @RequireMatchType(t, t2)
      | * :     @RequireMatchType(t, Null)
    ]

    ':'
    @RuleBodyDefinition (r)
    ';'

    oScopeEnd            % parameters scope (already linked to nRule)
    ;

% ------------------------- Statements -----------------------

%  Returns true if statement found

Statement >> boolean:
    Node  i
    Node  t, t2

    [
        | pStrLit:           % input alias
            oShortFormLookup(i)  @RequireInput(i)
            .iInput @EmitValue(i)

        | pIdent:            % input or operation
            oScopeFindRequire(i)
            [ oNodeType(i)

                | nInput:      .iInput @EmitValue(i)

                | nOperation:  @RequireNoType(i) @CallOperation(i)

                | nType:       @DeclareLocals(i)

                | *:           @Assignment(i)
            ]

	| '#':
            pIdent  @LookupError(i)
            .iError @EmitValue(i)

	| '.':
	    [ | pIdent:    @LookupOutput(i)
              | pStrLit:   oShortFormLookup(i) @RequireOutput(i)
            ]
            .iEmit @EmitValue(i)

	| '@':
	    pIdent
            [ oScopeFind(i)
                | true :
                    @RequireRule(i)  @RequireNoType(i)
                    @CallRule(i)

                | false :
                    @CallUndefinedRule
            ]

	| '>>':
            t = oNodeGet (CurrentRule, qType)
	    [ oNodeNull(t)
                | true :
                | * :       @Expr(t2)  @RequireMatchType(t, t2)
            ]
            .iReturn

	| '{':
            oPatchPushHere (patchLoop)
            oPatchMark (patchBreak)
	    {[ @Statement
		| true:
		| *:  >
	    ]}
	    '}'
            .iJumpBack
            oPatchPopBack (patchLoop)

            % Fix up break statements
            {[ oPatchAtMark (patchBreak)
                | false :    oPatchPopFwd (patchBreak)
                | * :        >
            ]}

	| '>':
            [ oPatchAnyEntries (patchLoop)
                | false:  #eNotInLoop
                | *:
            ]
            .iJumpForward  oPatchPushHere (patchBreak)  .iSpace

	| '?':  .iInputAny

	| '[':  @Choice

        | *:    >> false    % Not a statement
    ]
    >> true ;


%  Given nOperation

CallOperation (Node o):
    int  num_params

    num_params = @ActualParams (o)

    @EmitValue(o)        % call operation

    [ equal_zero (num_params)
        | true :
        | false :     .iPop oEmitInt(num_params)
    ]
    ;


%  Given nOperation or nRule.  Returns number of parameters.

ActualParams (Node r) >> int:

    int   num_params
    Node  param_scope, p
    Node  t, t2

    param_scope = oNodeGet (r, qParamScope)  % Always present, but might contain no nParams
    p = oNodeGet (param_scope, qDecls)

    [ oNodeNull(p)

        | true :    >> 0
        | false :
    ]

    num_params = 0

    '('

    {
        inc (num_params)

        %  ----------------------------

        %  One actual parameter.

        t = oNodeGet (p, qType)    % formal param type

        [ oNodeType(p)
            | nInParam :                @Expr (t2)
            | nOutParam, nInOutParam :  @Lvalue (t2)
        ]
        
        @RequireMatchType (t, t2)
        .iPushResult

        %  ----------------------------

        oNodeNext (p)

        [ oNodeNull (p)
            | true :   >
            | false :
        ]

        ','
    }

    ')'

    >> num_params
    ;



%  Called for a nRule whose parameter types are defined.
%  The rule address might not yet be known.

CallRule (Node r):
    int  num_params

    num_params = @ActualParams(r)

    [ oNodeGetBoolean (r, qAddrDefined)     % A call to a forward-declared rule?
        | yes :   .iCall @EmitValue(r)
        | no :    .iCall oPatchPushHere(patchCall) 
                         oPatchPushInt (patchCall, oNodeGetInt(r, qIdent))
                         .iSpace
    ]

    % Pop actual params
    [ equal_zero (num_params)
        | true :
        | false :     .iPop oEmitInt(num_params)
    ]
    ;


%  Implicitly declare a rule that has not previously been declared.
%  Rule name is last accepted identifier.
%  Implicitly declares InParam parameters, and no return type.

CallUndefinedRule:
    Node  r, s, t, p
    int   id, num_params, addr

    r = oNodeNew (nRule)  id = LAST_ID  oNodeSetInt (r, qIdent, id)
    oNodeSetBoolean(r, qAddrDefined, false)

    % Implicit parameters

    oScopeBegin (s)
    oNodeSet (r, qParamScope, s)

    num_params = 0

    [ | '(' :

        {
            @Expr(t)
            p = oNodeNew (nInParam)  oNodeSet(p, qType, t)
            oScopeDeclare(p)
            inc(num_params)

            [ | ',' :
              | * :   >
            ]
        }

        % Assign parameter addresses

        addr = num_params
        p = oNodeGet (s, qDecls)
        {
            [ oNodeNull(p)
                | true :  >
                | false :
            ]
            oNodeSetInt (p, qAddr, addr)
            dec (addr)
            oNodeNext (p)
        }

      | * :
    ]

    oScopeEnd    % param scope
    oScopeDeclare (r)

    % Now call rule

    .iCall
    oPatchPushHere (patchCall)
    oPatchPushInt (patchCall, id)
    .iSpace

    [ equal_zero (num_params)
        | true :
        | * :     .iPop oEmitInt(num_params)
    ];


%  Already parsed pIdent and determined it is not a rule/type/operation.

Assignment (Node i):
    Node t, t2
    @Lvalue_HaveIdent(i,t)
    .iPushResult
    '='
    @Expr(t2)  @RequireMatchType(t,t2)
    .iAssign
    ;

Choice:
    int    num_options    % count the number of options in the choice
    kind   choice_kind    % input choice, expr choice, expr undefined type choice
    Node   choice_type    % type of expr choice
    Node   t
    Node   i
    int    val

    %  Determine if this is an input choice or a value choice.
    %  For value choice, determine type of value (if known).

    [
        | '|' :
            .iInputChoice   choice_kind = kInput

        | * :
            @Expr(choice_type)  .iChoice

            % Expr indicates forward use of undefined rule by returning type Null.
            % We will indicate this for ourselves by setting kind to kUnknown.

            [ oNodeNull(choice_type)
                | true :    choice_kind = kUnknown   % flag that this is expr choice, unknown type
                | false:    choice_kind = kType      % flag that this is expr choice, known type
            ]

            '|'
    ]

    oPatchPushHere (patchChoiceTableAddr)
    .iSpace

    oPatchMark (patchChoiceTable)    % build up choice table in this stack
    oPatchMark (patchChoiceExit)     % remember end of each option
    num_options = 0                  % count options

    {
        [
            | '*':     % default code (must be last option)
                ':'
                @CopyChoiceTable (num_options)

                {[ @Statement
                    | true :
                    | *: >
	        ]}
                ']'

                % Finish up
                @FixChoiceExits
                >>

            | * :
                {
                    [ choice_kind

                        | kType :         % expr choice
                            val = @Const(t)
                            @RequireMatchType (choice_type, t)

                        | kUnknown :      % expr choice, type not known yet
                            val = @Const(choice_type)

                            % NOTE: now that we know type of forward rule in expr, we could update nRule

                            % Now know type
                            choice_kind = kType

                        | kInput :        % input choice
                            [ | pIdent :  @LookupInput(i)
                              | pStrLit : oShortFormLookup(i) @RequireInput(i)
                            ]
                            val = oNodeGetInt (i, qValue)
                    ]

                    oPatchPushHere (patchChoiceTable)
                    oPatchPushInt  (patchChoiceTable, val)
                    inc (num_options)

                    [
                        | ':' :   >
                        | ',' :
                    ]
                }
        ]

        % Code for this option:

        {[ @Statement
            | true:
            | *:  >
        ]}

        [
            | ']' :     % end of choice, no default
                .iJumpForward
                oPatchPushHere (patchChoiceExit) .iSpace
                @CopyChoiceTable (num_options)

                .iEndChoice

                @FixChoiceExits
                >>

            | '|' :     % more options follow
                .iJumpForward
                oPatchPushHere (patchChoiceExit) .iSpace
        ]
    };


%  Install choice table here, given number of options.
%  Order of options is opposite that in the source (note for error recovery)

CopyChoiceTable (int num_options):
    oPatchPopFwd (patchChoiceTableAddr)    % fix pointer to table
    oEmitInt (num_options)                 % # table entries
    {[ oPatchAtMark (patchChoiceTable)
        | false :
            oPatchPopValue (patchChoiceTable)
            oPatchPopBack (patchChoiceTable)
        | * :   >
    ]};
    
% Fix jumps from end of each option to end of choice

FixChoiceExits:
    {[ oPatchAtMark (patchChoiceExit)
        | false:    oPatchPopFwd (patchChoiceExit)
        | *:        >
    ]};

FixForwardCalls:
    {[ oPatchAnyEntries (patchCall)
        | true :    oPatchPopCall (patchCall)
        | * :       >
    ]};

%  ------------------------------------------------------- 

%  Emits code for expression (with result in ssl_result).
%  Returns nType of expression.

Expr (out Node t):
    Node  i
    [
        | pIdent :

            [ oScopeFind (i)
                | true :
                    [ oNodeType (i)
                        | nRule :        oWarning(wRuleMissingAtSign) @CallRule(i)
                        | nOperation :   @CallOperation(i)
                        | nValue :       .iSetResult    @EmitValue(i)
                        | nInParam :     .iGetParam     @EmitAddr(i)
                        | nOutParam :    .iGetFromParam @EmitAddr(i)
                        | nInOutParam :  .iGetFromParam @EmitAddr(i)
                        | nLocal :       .iGetLocal     @EmitAddr(i)
                        | nGlobal :      .iGetGlobal    @EmitAddr(i)
                        | * : #eIdentNotAllowedInExpr
                    ]

                    t = oNodeGet (i, qType)         % Get type of identifier
                    [ oNodeNull(t)
                        | true:  #eNotTyped   % e.g. call with no return value
                        | * :
                    ]

                | false :
                    t = Null  #eUndeclaredIdentifier
            ]

        | '@' :
	    pIdent
            [ oScopeFind (i)
                | true :
                    @RequireRule(i) @CallRule(i)
                    t = oNodeGet (i, qType)
                    [ oNodeNull (t)
                        | true:  #eNotTyped   % e.g. call with no return value
                        | * :
                    ]

                | false :
                    % Call before defined.  Limited use in this case.
                    % The nType pushed will be NULL.  We don't know the real type.
                    % This is really just allowed so we can have simple rules in a Choice expression.

                    @CallUndefinedRule
                    t = Null
            ]

        | '-' :
            pIntLit   .iSetResult  oEmitInt(negate(TOKEN_VALUE))
            t = IntType
        | pIntLit :
            .iSetResult  oEmitInt(TOKEN_VALUE)
            t = IntType
    ];

%  Emits code for lvalue (putting address of variable in ssl_result).
%  Returns nType of the referenced value.

Lvalue (out Node t):
    Node i
    [
        | pIdent :

            [ oScopeFind(i)
                | true :      @Lvalue_HaveIdent(i,t)

                | false :     % a forward use of rule, illegal as lvalue
                    t = Null  #eIllegalLvalue
            ]

        | '-' :   pIntLit     t = Null    #eIllegalLvalue
        | pIntLit :           t = Null    #eIllegalLvalue
    ];

%  Emit code for lvalue, given nDeclaration of identifier.
%  Return lvalue's nType

Lvalue_HaveIdent (Node i, out Node t):
    [ oNodeType(i)
        | nInParam :     .iGetAddrParam  @EmitAddr(i)
        | nOutParam :    .iGetParam      @EmitAddr(i)
        | nInOutParam :  .iGetParam      @EmitAddr(i)
        | nLocal :       .iGetAddrLocal  @EmitAddr(i)
        | nGlobal :      .iGetAddrGlobal @EmitAddr(i)
        | * : #eIllegalLvalue
    ]
    t = oNodeGet (i, qType)         % Get type of identifier
    ;

%  Return a constant value.  Also return the type of the value.
%  No code is generated.

Const (out Node t) >> int:
    Node  i
    int   val
    [
        | pIdent :
            @LookupValue (i)
            val = oNodeGetInt (i, qValue)
            t = oNodeGet (i, qType)
        | '-' :
            pIntLit
            val = negate(TOKEN_VALUE)
            t = IntType
        | pIntLit :
            val = TOKEN_VALUE
            t = IntType
    ]
    >> val;

%  Return integer constant.  Only values of type "int" are
%  permitted.  No code is generated.

IntConst >> int:
    Node t
    int  i
    i = @Const (t)  @RequireMatchIntType (t)
    >> i;

%  ------------------------------------------------------- 

%  Assert that the ident we just read is a particular kind of
%  identifier.  Return the declaration node of the identifier.

LookupType (out Node i):
    oScopeFindRequire (i)
    @RequireType (i);

LookupInput (out Node i):
    oScopeFindRequire (i)
    @RequireInput (i);

LookupOutput (out Node i):
    oScopeFindRequire (i)
    @RequireOutput (i);

LookupValue (out Node i):
    oScopeFindRequire (i)
    @RequireValue (i);

LookupError (out Node i):
    oScopeFindRequire (i)
    @RequireError (i);

%  Assert that the given nDeclaration represents a particular
%  kind of declaration.

RequireType (Node i):
    [ oNodeType(i)
        | nType :
        | * :    #eNotAType
    ];

RequireInput (Node i):
    [ oNodeType(i)
        | nInput :
        | * :    #eNotInput
    ];

RequireOutput (Node i):
    [ oNodeType(i)
        | nOutput :
        | * :    #eNotOutput
    ];

RequireValue (Node i):
    [ oNodeType(i)
        | nValue :
        | * :    #eNotAValue
    ];

RequireError (Node i):
    [ oNodeType(i)
        | nError :
        | * :    #eNotAnErrSig
    ];

RequireRule (Node i):
    [ oNodeType(i)
        | nRule :
        | * :    #eNotARule
    ];

%  Require that rule/operation has no return type

RequireNoType (Node r):
    [ oNodeNull (oNodeGet(r, qType))
        | false: #eChoiceOpRuleOutOfPlace
        | * :
    ];

%  Given a value nDeclaration, and a nType.
%  Ensure that the value symbol has the type nType.

RequireMatchValueType (Node v, Node t):
    [ oNodeEqual (oNodeGet(v, qType), t)
        | true :
        | * :    #eWrongType
    ];


%  Do two types match?

MatchType (Node t1, Node t2) >> boolean:
    >> oNodeEqual (t1, t2);

RequireMatchType (Node t1, Node t2):
    [ oNodeEqual (t1, t2)
        | true :
        | * :    #eWrongType
    ];

%  Is the nType "int"?

MatchIntType (Node t) >> boolean:
    >> oNodeEqual (t, IntType);

RequireMatchIntType (Node t):
    [ oNodeEqual (t, IntType)
        | true :
        | * :     #eWrongType
    ];


%  ------------------------------------------------------- 


%  Emit the value of an identifier declaration, given its nDeclaration

EmitValue (Node i):
    oEmitInt (oNodeGetInt(i, qValue));

%  Emit the addr of a variable, given its declaration

EmitAddr (Node v):
    oEmitInt (oNodeGetInt(v, qAddr));

end

