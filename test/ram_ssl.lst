      %  sccsid = "%W% %G% %U% %P%";
      
   2: title: 'SSL Translator 1.3.0 -- August 23 ''93';
      
      %
      % *****************************************************************************
      %
      %   Syntax/Semantic Language Compiler
      %
      %   by Steve Rice
      %
      %   Aug 31, 1989
      %
      % *****************************************************************************
      %
      %   ssl.ssl             SSL compiler
      %
      %   HISTORY
      % -----------------------------------------------------------------------------
      %   08/31/89 | Steve  | Translated from my SSL processor hardcoded in C
      %   09/08/89 |        | SSL processor now functional, except for error recovery
      %   10/18/89 |        | Added 'title' section
      %   02/03/90 |        | Change to ssl.c: Added debugger output
      %   03/20/91 |        | Change to ssl.c: Increased string table size
      %   03/26/91 |        | Fixed bug in handling of statement ">>value"
      %            |        | Fixed bug in handling of choice using a choice rule
      %            |        | defined later
      %   04/24/91 |        | Change to ssl.c: Increased identifier size to 50 chars
      %   05/05/91 |        | Change to ssl.c: Increased identifier table size to
      %            |        | 600, and moved names out of table. New limit 256 chars.
      %            |        | Added "include" feature.
      %   05/21/91 |        | Multiple "error" sections will use distinct error #'s
      %            |        | Added postprocess optimization: reduce chains of jumps
      %   06/04/91 |        | Change to ssl.c: Write rule addresses to code file
      %   08/23/93 |        | Fix some loops so error recovery can terminate
      %   08/25/93 |        | Reimplement using schema database for symbol table
      %   08/27/93 |        | Add new language features: local variables,
      %            |        | multiple parameters, inout parameters,
      %            |        | expressions with nested function calls.
      %            |        | (User program requires the 2.0 runtime model for new
      %            |        | instructions in generated code).
      %            |        |
      % 
      % *****************************************************************************
      %
      %   BUGS
      % -----------------------------------------------------------------------------
      %   01/28/90 | Doesn't complain if functions called but never declared!	
      %
      % *****************************************************************************
      %
      %   NOTES
      %
      %   *  The base counter in the count stack counts semantic operations.
      %
      %   *  When a new identifier is added to the table by the scanner,
      %      it is given a default kind kUnknown.  ** NOT ANYMORE, DO I DEPEND ON IT?
      %
      %   *  Stack entries that are read by an operation are left there,
      %      unless the operation contains the word 'Pop'.
      %      The emit statement never pops stack entries (i.e. .iConstant
      %      emits the value on the value stack, but does not pop it.)
      %
      % *****************************************************************************
      %
      
   2: input:
   2:     pIdent
   2:     pIntLit
   2:     pStrLit
   2:     pMinus      '-'
   2:     pEquals     '='
   2:     pColon      ':'
   2:     pSemiColon  ';'
   2:     pComma      ','
   2:     pLParen     '('
   2:     pRParen     ')'
   2:     pReturn     '>>'
   2:     pBreak      '>'
   2:     pLCurly     '{'
   2:     pRCurly     '}'
   2:     pLSquare    '['
   2:     pRSquare    ']'
   2:     pBar        '|'
   2:     pCall       '@'
   2:     pEmit       '.'
   2:     pStar       '*'
   2:     pErr        '#'
   2:     pQuestion   '?'
   2:     pEof
   2:     pInvalid
      
      %  keywords
      
   2:     pTitle
   2:     pInput
   2:     pOutput
   2:     pType
   2:     pError
   2:     pMechanism
   2:     pInclude
   2:     pRules
   2:     pEnd
   2:     pIn
   2:     pOut
   2:     pInOut
   2:     ;
      
      
   2: output:
      
      %  codes for SSL machine instructions
      
   2:     iJumpForward
   2:     iJumpBack
   2:     iInput
   2:     iInputAny
   2:     iEmit
   2:     iError
   2:     iInputChoice
   2:     iCall
   2:     iReturn
   2:     iSetResult
   2:     iChoice
   2:     iEndChoice
   2:     iPushResult      % push ssl_result on variable stack
   2:     iPop             % (n)  discard n entries from variable stack
   2:     iBreak           % instruction used by debugger
   2:     iLocalSpace      % (n)  make space for n locals on variable stack
   2:     iGetParam        % (n)  ssl_result = value of param n
   2:     iGetFromParam    % (n)  ssl_result = value of variable whose address is in param n
   2:     iGetLocal        % (n)  ssl_result = value of local var n
   2:     iGetGlobal       % (n)  ssl_result = value of global var n
   2:     iGetAddrParam    % (n)  ssl_result = addr of param n
   2:     iGetAddrLocal    % (n)  ssl_result = addr of local var n
   2:     iGetAddrGlobal   % (n)  ssl_result = addr of global var n
   2:     iAssign          % variable whose address is pushed on stack = ssl_result; pop stack
      
      %   NOTE: Any instructions added here should also be added to
      %         the system_operations table in ssl.c
      %         as well as optimize_table, list_generated_code.
      
      %  other output
      
   2:     iSpace           % emit a dummy value; a value will be patched here later
   2:     iConstant;       % emit the value on the value stack
      
   2: error:
   2:    eMissingProgramBlock
   2:    eMissingEnd
   2:    eWrongType
   2:    eNoShortFormHere
   2:    eNotAType
   2:    eNotAValue
   2:    eNotInput
   2:    eNotOutput
   2:    eNotARule
   2:    eNotAStatement
   2:    eUndeclaredIdent
   2:    eBadStatement
   2:    eNotAnErrSig
   2:    eNotInLoop
   2:    eNotChoice     % rule or op
   2:    eChoiceOpRuleOutOfPlace
      
   2:    eUnexpectedKind
   2:    eWrongNumberParams
   2:    eFwdRuleParamsNotSupportedYet
   2:    eNotTyped
   2:    eIdentNotAllowedInExpr
   2:    eParamNotSupportedYet
   2:    eIllegalLvalue
   2:    eNotRuleOrGlobalDefn
   2:    ;
      
      
      %include 'ssl_schema.ssl'
      
      % Generated automatically by schema
      
   2: type node_type:
   2: 	nINVALID
   2: 	Object
   2: 	nScope
   2: 	nDeclaration
   2: 	nIdent
   2: 	nInput
   2: 	nOutput
   2: 	nError
   2: 	nType
   2: 	nValue
   2: 	nMechanism
   2: 	nOperation
   2: 	nRule
   2: 	nVariable
   2: 	nParam
   2: 	nInParam
   2: 	nOutParam
   2: 	nInOutParam
   2: 	nLocal
   2: 	nGlobal
   2: 	;
      
   2: type node_attribute:
   2: 	qINVALID
   2: 	qParentScope
   2: 	qDecls
   2: 	qIdent
   2: 	qValue
   2: 	qType
   2: 	qParamScope
   2: 	qScope
   2: 	qAddr
   2: 	;
      
      
   2: type boolean:
   2:     false    = 0
   2:     true     = 1;
      
   2: type number:
   2:     zero            = 0
   2:     one             = 1
   2:     ;
      
   2: type kind:
   2:     kIllegal        % not an identifier
   2:     kUnknown        % new identifier
   2:     kInput
   2:     kOutput
   2:     kError
   2:     kType
   2:     kVal            % an element of a type
   2:     kMech
   2:     kOp
   2:     kRule
   2:     kVar
   2:     ;
      
   2: mechanism count:
   2:     oCountPush(number)        % push a new counter, with initial value
   2:     oCountPushIntLit          % push value of integer just read
   2:     oCountPushValue           % push value from value stack
   2:     oCountPop                 % discard counter
   2:     oCountInc
   2:     oCountDec
   2:     oCountNegate              % negate top counter
   2:     oCountZero >> boolean;    % is the top counter 0?
      
   2: mechanism next_error:                % variable to determine error #
   2:     oNextErrorPushCount               % push variable onto Count stack
   2:     oNextErrorPopCount;               % pop variable off Count stack
      
      
   2: mechanism value:                     % multi-purpose stack
   2:     oValuePush(number)                % push a constant value
   2:     oValuePushKind(kind)              % push a kind value
   2:     oValuePushNodeType(node_type)     % push a node type
   2:     oValuePushIdent                   % push ident# of last ident read
   2:     oValuePushIntLit                  % push integer just read
   2:     oValueChooseKind >> kind          % kind on top of stack
   2:     oValuePushCount                   % value on top of count stack
   2:     oValuePushHere                    % push current (output) address
   2:     oValueNegate                      % negate top value
   2:     oValueSwap                        % swap top two elements
   2:     oValueZero >> boolean             % is top value zero?
   2:     oValuePop;
      
      % keep different patch stacks, each with a stack of position markers:
      
   2: type patchStack:
   2:     patchChoiceTableAddr    % addr where pointer to table is stored
   2:     patchChoiceTable        % build up choice table here (value,addr)
   2:     patchChoiceExit         % addrs where jumps at end of each option are
   2:     patchCall               % (addr,ident) where calls to undefined rules are
   2:     patchLoop               % addr of start of a loop
   2:     patchBreak;             % addrs where jumps out of a loop are
      
   2: mechanism patch_mech:
   2:     oPatchMark(patchStack)             % mark current position on a stack
   2:     oPatchAtMark(patchStack) >> boolean     % true if all items since
                                                 %   last mark are popped
                                                 %   (mark is dropped if true)
   2:     oPatchPushHere(patchStack)         % put current address on a patch stack
   2:     oPatchPushIdent(patchStack)        % put last ident on a patch stack
   2:     oPatchPushValue(patchStack)        % push value on value stack
   2:     oPatchAnyEntries(patchStack) >> boolean    % are there any entries?
   2:     oPatchPopFwd(patchStack)           % fix table, storing here-x at x,
                                             %   where x is on top of the stack
   2:     oPatchPopBack(patchStack)          % emit here-x here (advance 'here')
   2:     oPatchPopValue(patchStack)         % emit x here (advance 'here')
   2:     oPatchPopCall(patchStack);         % fix table, storing value of ident i
                                             %   at x, where i is on top of stack
                                             %   and x is under it  (pop both)
   2: mechanism shortForm:    % keep a table of string shortforms for input/output
   2:     oShortFormAdd       % associate current StrLit token with nDeclaration on node stack
   2:     oShortFormLookup;   % look up strLit, push associated nDeclaration on node stack
      
   2: mechanism titleMech:
   2:     oTitleSet;          % define title to be strlit just read
      
   2: mechanism doc:         % display documentary info
   2:     oDocNewRule         % print "Rule <token>"
   2:     oDocCheckpoint;     % display current pc value, for debugging
      
   2: mechanism include_mech:
   2:     oInclude;           % include the SSL file whose name is in the
                             % string token just accepted
      
   2: mechanism node_mech:
   2:     oNodeNew (node_type)               % create new node, push on node stack
   2:     oNodeNewValue                      % like oNodeNew, take node type from value stack
   2:     oNodeLink (node_attribute)         % link Node attribute of 2nd node to top node, pop
   2:     oNodeLinkUnder1 (node_attribute)   % link Node attribute of top node to 2nd node (top-1)
   2:     oNodeSetValue (node_attribute)     % set int attribute of node from value stack no pop
   2:     oNodeSetIdent (node_attribute)     % set attribute of node with id# of last accepted id
   2:     oNodeAppend (node_attribute)       % append top node to list attr of 2nd node
   2:     oNodeAppendNode                    % append top node to list starting with 2nd node
   2:     oNodeGet (node_attribute)          % push Node attribute on stack
   2:     oNodeGetValue (node_attribute)     % push int attribute on value stack
   2:     oNodeNull >> boolean               % is top node null (pop if it is)
   2:     oNodePushNull                      % push null on stack
   2:     oNodeNext                          % replace top node with next in list
   2:     oNodeIsA (node_type) >> boolean    % return true if top node IsA <class>
   2:     oNodeChooseType >> node_type       % return node type of top node in stack
   2:     oNodeCompareExact >> boolean       % compare top two nodes for equality
                                             % Return true only if both are the same node
   2:     oNodeCompareExactUnder2 >> boolean % compare node on stack with node 2 under it
                                             % Return true only if both are the same node
   2:     oNodeSwap
   2:     oNodePop
      
          % Some global variables
      
   2:     oNodeGetIntType                    % Get nType node for system type "int"
   2:     ;
      
   2: mechanism rule_mech:
   2:     oRuleSetCurrentRule                % Global variable to hold current rule node
   2:     oRuleGetCurrentRule
      
   2:     oRuleSetNumLocals(number)          % set counter of #locals in rule
   2:     oRuleIncNumLocals                  % inc #locals_in_rule counter
   2:     oRuleGetNumLocals                  % push #locals_in_rule counter on value stack
   2:     oRuleSetLocalSpaceAddr             % set location of .iLocalSpace argument to patch
   2:     oRulePatchLocalSpace               % patch rule's .iLocalSpace argument with #locals_in_rule
      
   2:     oSetNumGlobals(number)    % set counter of #globals in program
   2:     oIncNumGlobals
   2:     oGetNumGlobals            % to value stack
   2:     oSetGlobalSpaceAddr       % similar to locals.  Program starts with .iLocalSpace(n) for globals on stack
   2:     oPatchGlobalSpace
   2:     ;
      
   2: mechanism scope_mech:
   2:     oScopeBegin                        % create a new scope.  Subsequent declarations will go here.
                                             % Pushes nScope on node stack.  Sets nScope's qParent to parent scope.
   2:     oScopeExtend                       % Extend an existing scope, whose nScope node is on node stack.
                                             % The nScope should have been previously created by oScopeBegin.
   2:     oScopeEnd                          % End current scope.  Subsequent declarations will go to parent scope.
                                             % Does not remove nScope from node stack
   2:     oScopeDeclare                      % Add top node to declaration list of current scope.  Pop node.
   2:     oScopeDeclareKeep                  % Like oScopeDeclare, but keep node on stack.
      
   2:     oScopeFind >> boolean              % Find declaration of last accepted identifier.
                                             % Push on stack if found.
   2:     oScopeFindRequire                  % Find declaration of last accepted identifier.
                                             % Go into error recovery if not found.
   2:     ;
      
      
   2: mechanism install_mech:
   2:     oInstallSystemOperations (inout int NextOperation)
   2:     oInstallSystemTypes;
      
   2: mechanism write_mech:
   2:     oWriteTables;
      
      % ------- new in test -------
      
   2: type Addr:   % Addresses in generated code
   2:     ;
      
   2: mechanism Gen_mech:
   2:     Here >> Addr     % location in generated code
   2:     patch (Addr, int)
   2:     ;
      
   2: type Node:
   2:     Null = 0
   2:     ;
      
   2: mechanism node_more:
   2:     oNodeSetInt (node_attribute, int)
   2:     ;
      
   2: mechanism math:
   2:     inc (inout int);
      
   2: rules
      
      
      %  Global variables
      
   2: int  NumGlobals, NextError, NextOperation
      
      
   2: ProcessSSL:
      
   4:     Addr  global_space
      
   4:     oScopeBegin
      
   5:     NextError = 0
  11:     NextOperation = 0
      
  17:     oInstallSystemOperations (NextOperation)
  23:     oInstallSystemTypes
      
  24:     NumGlobals = 0                 % Count global variables
  30:     .iLocalSpace                   % Make space for global variables
  32:     global_space = Here   .iSpace
      
      
  39:     {[ Section
  42:         | true:
  43:         | *:  >
  50:     ]}
      
  52:     @FixForwardCalls
      
  54:     inc (NumGlobals)   % increase because globals addressed from 1 (addr 0 unused)
  60:     patch (global_space, NumGlobals)
      
  69:     oScopeEnd
      
  70:     oWriteTables
  71:     oNodePop   % global nScope
  72:     ;
      
      
      % Returns true if a section found
      
  73: Section >> boolean:
      
  75:     [
  75:         | pTitle:      @Title
  79:         | pInput:      @Input
  83:         | pOutput:     @Output
  87:         | pError:      @Error
  91:         | pType:       @Type
  95:         | pInclude:    @Include
  99:         | pMechanism:  @Mechanism
 103:         | pRules:      @Rules
      
 107:         | pEof:        >> false      % end of file
 112:     ]
 134:     >> true
 137:     ;
      
      % ------------------------- Sections -------------------------
      
 138: Title:
 140:     ':' pStrLit oTitleSet ';' ;
      
      % Forward declaration
      % Returns next value after highest assigned
      % Note, return value may be ignored
      
 148: ValueList (node_type, int initial_value, boolean string_alias_allowed, Node value_type) >> int;
