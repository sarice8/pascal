%  sccsid = "%W% %G% %U% %P%";

title: 'SSL Translator 1.3.0 -- August 23 ''93';

%
% *****************************************************************************
%
%   Syntax/Semantic Language Compiler
%
%   by Steve Rice
%
%   Aug 31, 1989
%
% *****************************************************************************
%
%   ssl.ssl             SSL compiler
%
%   HISTORY
% -----------------------------------------------------------------------------
%   08/31/89 | Steve  | Translated from my SSL processor hardcoded in C
%   09/08/89 |        | SSL processor now functional, except for error recovery
%   10/18/89 |        | Added 'title' section
%   02/03/90 |        | Change to ssl.c: Added debugger output
%   03/20/91 |        | Change to ssl.c: Increased string table size
%   03/26/91 |        | Fixed bug in handling of statement ">>value"
%            |        | Fixed bug in handling of choice using a choice rule
%            |        | defined later
%   04/24/91 |        | Change to ssl.c: Increased identifier size to 50 chars
%   05/05/91 |        | Change to ssl.c: Increased identifier table size to
%            |        | 600, and moved names out of table. New limit 256 chars.
%            |        | Added "include" feature.
%   05/21/91 |        | Multiple "error" sections will use distinct error #'s
%            |        | Added postprocess optimization: reduce chains of jumps
%   06/04/91 |        | Change to ssl.c: Write rule addresses to code file
%   08/23/93 |        | Fix some loops so error recovery can terminate
%   08/25/93 |        | Reimplement using schema database for symbol table
%   08/27/93 |        | Add new language features: local variables,
%            |        | multiple parameters, inout parameters,
%            |        | expressions with nested function calls.
%            |        | (User program requires the 2.0 runtime model for new
%            |        | instructions in generated code).
%            |        |
% 
% *****************************************************************************
%
%   BUGS
% -----------------------------------------------------------------------------
%   01/28/90 | Doesn't complain if functions called but never declared!	
%
% *****************************************************************************
%
%   NOTES
%
%   *  The base counter in the count stack counts semantic operations.
%
%   *  When a new identifier is added to the table by the scanner,
%      it is given a default kind kUnknown.  ** NOT ANYMORE, DO I DEPEND ON IT?
%
%   *  Stack entries that are read by an operation are left there,
%      unless the operation contains the word 'Pop'.
%      The emit statement never pops stack entries (i.e. .iConstant
%      emits the value on the value stack, but does not pop it.)
%
% *****************************************************************************
%

input:
    pIdent
    pIntLit
    pStrLit
    pMinus      '-'
    pEquals     '='
    pColon      ':'
    pSemiColon  ';'
    pComma      ','
    pLParen     '('
    pRParen     ')'
    pReturn     '>>'
    pBreak      '>'
    pLCurly     '{'
    pRCurly     '}'
    pLSquare    '['
    pRSquare    ']'
    pBar        '|'
    pCall       '@'
    pEmit       '.'
    pStar       '*'
    pErr        '#'
    pQuestion   '?'
    pEof
    pInvalid

%  keywords

    pTitle
    pInput
    pOutput
    pType
    pError
    pMechanism
    pInclude
    pRules
    pEnd
    pIn
    pOut
    pInOut
    ;


output:

%  codes for SSL machine instructions

    iJumpForward
    iJumpBack
    iInput
    iInputAny
    iEmit
    iError
    iInputChoice
    iCall
    iReturn
    iSetResult
    iChoice
    iEndChoice
    iPushResult      % push ssl_result on variable stack
    iPop             % (n)  discard n entries from variable stack
    iBreak           % instruction used by debugger
    iLocalSpace      % (n)  make space for n locals on variable stack
    iGetParam        % (n)  ssl_result = value of param n
    iGetFromParam    % (n)  ssl_result = value of variable whose address is in param n
    iGetLocal        % (n)  ssl_result = value of local var n
    iGetGlobal       % (n)  ssl_result = value of global var n
    iGetAddrParam    % (n)  ssl_result = addr of param n
    iGetAddrLocal    % (n)  ssl_result = addr of local var n
    iGetAddrGlobal   % (n)  ssl_result = addr of global var n
    iAssign          % variable whose address is pushed on stack = ssl_result; pop stack

%   NOTE: Any instructions added here should also be added to
%         the system_operations table in ssl.c
%         as well as optimize_table, list_generated_code.

%  other output

    iSpace           % emit a dummy value; a value will be patched here later
    iConstant;       % emit the value on the value stack

error:
   eMissingProgramBlock
   eMissingEnd
   eWrongType
   eNoShortFormHere
   eNotAType
   eNotAValue
   eNotInput
   eNotOutput
   eNotARule
   eNotAStatement
   eUndeclaredIdent
   eBadStatement
   eNotAnErrSig
   eNotInLoop
   eNotChoice     % rule or op
   eChoiceOpRuleOutOfPlace

   eUnexpectedKind
   eWrongNumberParams
   eFwdRuleParamsNotSupportedYet
   eNotTyped
   eIdentNotAllowedInExpr
   eParamNotSupportedYet
   eIllegalLvalue
   eNotRuleOrGlobalDefn
   ;


%include 'ssl_schema.ssl'

% Generated automatically by schema

type node_type:
	nINVALID
	Object
	nScope
	nDeclaration
	nIdent
	nInput
	nOutput
	nError
	nType
	nValue
	nMechanism
	nOperation
	nRule
	nVariable
	nParam
	nInParam
	nOutParam
	nInOutParam
	nLocal
	nGlobal
	;

type node_attribute:
	qINVALID
	qParentScope
	qDecls
	qIdent
	qValue
	qType
	qParamScope
	qScope
	qAddr
	;


type boolean:
    false    = 0
    true     = 1;

type number:
    zero            = 0
    one             = 1
    ;

type kind:
    kIllegal        % not an identifier
    kUnknown        % new identifier
    kInput
    kOutput
    kError
    kType
    kVal            % an element of a type
    kMech
    kOp
    kRule
    kVar
    ;

mechanism count:
    oCountPush(number)        % push a new counter, with initial value
    oCountPushIntLit          % push value of integer just read
    oCountPushValue           % push value from value stack
    oCountPop                 % discard counter
    oCountInc
    oCountDec
    oCountNegate              % negate top counter
    oCountZero >> boolean;    % is the top counter 0?

mechanism next_error:                % variable to determine error #
    oNextErrorPushCount               % push variable onto Count stack
    oNextErrorPopCount;               % pop variable off Count stack


mechanism value:                     % multi-purpose stack
    oValuePush(number)                % push a constant value
    oValuePushKind(kind)              % push a kind value
    oValuePushNodeType(node_type)     % push a node type
    oValuePushIdent                   % push ident# of last ident read
    oValuePushIntLit                  % push integer just read
    oValueChooseKind >> kind          % kind on top of stack
    oValuePushCount                   % value on top of count stack
    oValuePushHere                    % push current (output) address
    oValueNegate                      % negate top value
    oValueSwap                        % swap top two elements
    oValueZero >> boolean             % is top value zero?
    oValuePop;

% keep different patch stacks, each with a stack of position markers:

type patchStack:
    patchChoiceTableAddr    % addr where pointer to table is stored
    patchChoiceTable        % build up choice table here (value,addr)
    patchChoiceExit         % addrs where jumps at end of each option are
    patchCall               % (addr,ident) where calls to undefined rules are
    patchLoop               % addr of start of a loop
    patchBreak;             % addrs where jumps out of a loop are

mechanism patch_mech:
    oPatchMark(patchStack)             % mark current position on a stack
    oPatchAtMark(patchStack) >> boolean     % true if all items since
                                           %   last mark are popped
                                           %   (mark is dropped if true)
    oPatchPushHere(patchStack)         % put current address on a patch stack
    oPatchPushIdent(patchStack)        % put last ident on a patch stack
    oPatchPushValue(patchStack)        % push value on value stack
    oPatchAnyEntries(patchStack) >> boolean    % are there any entries?
    oPatchPopFwd(patchStack)           % fix table, storing here-x at x,
                                       %   where x is on top of the stack
    oPatchPopBack(patchStack)          % emit here-x here (advance 'here')
    oPatchPopValue(patchStack)         % emit x here (advance 'here')
    oPatchPopCall(patchStack);         % fix table, storing value of ident i
                                       %   at x, where i is on top of stack
                                       %   and x is under it  (pop both)
mechanism shortForm:    % keep a table of string shortforms for input/output
    oShortFormAdd       % associate current StrLit token with nDeclaration on node stack
    oShortFormLookup;   % look up strLit, push associated nDeclaration on node stack

mechanism titleMech:
    oTitleSet;          % define title to be strlit just read

mechanism doc:         % display documentary info
    oDocNewRule         % print "Rule <token>"
    oDocCheckpoint;     % display current pc value, for debugging

mechanism include_mech:
    oInclude;           % include the SSL file whose name is in the
                       % string token just accepted

mechanism node_mech:
    oNodeNew (node_type)               % create new node, push on node stack
    oNodeNewValue                      % like oNodeNew, take node type from value stack
    oNodeLink (node_attribute)         % link Node attribute of 2nd node to top node, pop
    oNodeLinkUnder1 (node_attribute)   % link Node attribute of top node to 2nd node (top-1)
    oNodeSetValue (node_attribute)     % set int attribute of node from value stack no pop
    oNodeSetIdent (node_attribute)     % set attribute of node with id# of last accepted id
    oNodeAppend (node_attribute)       % append top node to list attr of 2nd node
    oNodeAppendNode                    % append top node to list starting with 2nd node
    oNodeGet (node_attribute)          % push Node attribute on stack
    oNodeGetValue (node_attribute)     % push int attribute on value stack
    oNodeNull >> boolean               % is top node null (pop if it is)
    oNodePushNull                      % push null on stack
    oNodeNext                          % replace top node with next in list
    oNodeIsA (node_type) >> boolean    % return true if top node IsA <class>
    oNodeChooseType >> node_type       % return node type of top node in stack
    oNodeCompareExact >> boolean       % compare top two nodes for equality
                                       % Return true only if both are the same node
    oNodeCompareExactUnder2 >> boolean % compare node on stack with node 2 under it
                                       % Return true only if both are the same node
    oNodeSwap
    oNodePop

    % Some global variables

    oNodeGetIntType                    % Get nType node for system type "int"
    ;

mechanism rule_mech:
    oRuleSetCurrentRule                % Global variable to hold current rule node
    oRuleGetCurrentRule

    oRuleSetNumLocals(number)          % set counter of #locals in rule
    oRuleIncNumLocals                  % inc #locals_in_rule counter
    oRuleGetNumLocals                  % push #locals_in_rule counter on value stack
    oRuleSetLocalSpaceAddr             % set location of .iLocalSpace argument to patch
    oRulePatchLocalSpace               % patch rule's .iLocalSpace argument with #locals_in_rule

    oSetNumGlobals(number)    % set counter of #globals in program
    oIncNumGlobals
    oGetNumGlobals            % to value stack
    oSetGlobalSpaceAddr       % similar to locals.  Program starts with .iLocalSpace(n) for globals on stack
    oPatchGlobalSpace
    ;

mechanism scope_mech:
    oScopeBegin                        % create a new scope.  Subsequent declarations will go here.
                                       % Pushes nScope on node stack.  Sets nScope's qParent to parent scope.
    oScopeExtend                       % Extend an existing scope, whose nScope node is on node stack.
                                       % The nScope should have been previously created by oScopeBegin.
    oScopeEnd                          % End current scope.  Subsequent declarations will go to parent scope.
                                       % Does not remove nScope from node stack
    oScopeDeclare                      % Add top node to declaration list of current scope.  Pop node.
    oScopeDeclareKeep                  % Like oScopeDeclare, but keep node on stack.

    oScopeFind >> boolean              % Find declaration of last accepted identifier.
                                       % Push on stack if found.
    oScopeFindRequire                  % Find declaration of last accepted identifier.
                                       % Go into error recovery if not found.
    ;


mechanism install_mech:
    oInstallSystemOperations (inout int NextOperation)
    oInstallSystemTypes;

mechanism write_mech:
    oWriteTables;

% ------- new in test -------

type Addr:   % Addresses in generated code
    ;

mechanism Gen_mech:
    Here >> Addr     % location in generated code
    patch (Addr, int)
    ;

type Node:
    Null = 0
    ;

mechanism node_more:
    oNodeSetInt (node_attribute, int)
    ;

mechanism math:
    inc (inout int);

rules


%  Global variables

int  NumGlobals, NextError, NextOperation


ProcessSSL:

    Addr  global_space

    oScopeBegin

    NextError = 0
    NextOperation = 0

    oInstallSystemOperations (NextOperation)
    oInstallSystemTypes

    NumGlobals = 0                 % Count global variables
    .iLocalSpace                   % Make space for global variables
    global_space = Here   .iSpace


    {[ Section
        | true:
        | *:  >
    ]}

    @FixForwardCalls

    inc (NumGlobals)   % increase because globals addressed from 1 (addr 0 unused)
    patch (global_space, NumGlobals)

    oScopeEnd

    oWriteTables
    oNodePop   % global nScope
    ;


% Returns true if a section found

Section >> boolean:

    [
        | pTitle:      @Title
        | pInput:      @Input
        | pOutput:     @Output
        | pError:      @Error
        | pType:       @Type
        | pInclude:    @Include
        | pMechanism:  @Mechanism
        | pRules:      @Rules

        | pEof:        >> false      % end of file
    ]
    >> true
    ;

% ------------------------- Sections -------------------------

Title:
    ':' pStrLit oTitleSet ';' ;

% Forward declaration
% Returns next value after highest assigned
% Note, return value may be ignored

ValueList (node_type, int initial_value, boolean string_alias_allowed, Node value_type) >> int;

Input:
    ':' 
    ValueList (nInput, 0, true, Null)
    ';' ;

Output:
    ':'
    ValueList (nOutput, 0, true, Null)
    ';' ;


Error:
    ':'
    NextError = ValueList (nError, NextError, false, Null)
    ';' ;

Type:
    Node t

    pIdent    t = NodeNew(nType)  NodeSet(t, qIdent, Ident)
              ScopeDeclare(t)
    ':'
    ValueList (nValue, 0, false, t)
    ';' ;

Include:
    pStrLit oInclude;

Mechanism:
    Node m

    pIdent    m = NodeNew(nMechanism)  NodeSet(m, qIdent, Ident)
              oScopeDeclare(t)
    ':'
    {[ OperationDefinition
        | true:
        | *:  >
    ]}
    ';' ;

Rules:
    {[ RuleSectionDefinition
        | true:
        | *:  >
    ]}
    pEnd ;


% ------------------------- Value Lists ----------------------

ValueList (node_type decl_type, int value, boolean string_alias_allowed, Node value_type) >> int:
    Node p, const_type
    {[
        | pIdent:
            p = NodeNew(decl_type)  NodeSet (p, qIdent, Ident)

            [ decl_type
                | nType :    NodeSet (p, qType, t)
                | * :
            ]

            [ | pStrLit:
                [ string_alias_allowed
                    | true:  oShortFormAdd (p)   % Associate short form with declaration
                    | *:     #eAliasNotAllowed
                ]
              | *:
            ]

            [ | '=':       value = @Const(const_type)
                           [ Match(const_type, value_type)
                               | true :
                               | false :  RequireMatchType (const_type, IntType)
                           ]
              |*:
            ]
            NodeSet (p, qValue, value)

            oScopeDeclare (p)
            inc (value)
        | *:  >
    ]}
    >> value ;


% ------------------------- Variables ------------------------

%  Declare a list of variables.
%  class is class of variable (nGlobal or nLocal)

DeclareVariables (node_type class, Node var_type, inout int address):
    Node   v
    {
        pIdent
        v = NodeNew(class)  NodeSet(v, qIdent, Ident)
        NodeSet (v, qType, var_type)

        % Assign address to local variable
        inc (address)   NodeSet (v, qAddr, address)

        ScopeDeclare (v)

        [ | ',' :
          | * :   >
        ]
    };

DeclareGlobals (Node var_type)
    DeclareVariables (nGlobal, var_type, NumGlobals);

DeclareLocals (Node var_type)
    DeclareVariables (nLocal, var_type, NumLocals);



%  Defines formal parameters (if any) in current scope.
%  The caller should have called oScopeBegin to begin a
%  scope just for parameters.  (This gives a simple way
%  to check if an operation/rule has parameters).

%  Parameters are assigned addresses in reverse order
%  from n to 1.  This is for efficient stack access.
%  E.g. func(a,b,c):  address of a:3, b:2, c:1
%
%  (Later I would like to instead push actuals in reverse order)

FormalParamDefinition:

    int     num_params
    Node    param, t

    [ | '(' :
      | *   : >>
    ]

    num_params = 0

    {
        inc (num_params)

        % parameter direction
        [
            | pIn :     param = NodeNew (nInParam)
            | pOut :    param = NodeNew (nOutParam)
            | pInOut :  param = NodeNew (nInOutParam)
            | * :       param = NodeNew (nInParam)
        ]

        % parameter type
        pIdent    t = LookupType  NodeSet(param, qType, t)

        % parameter name
        [
            | pIdent :  NodeSet(param, qIdent, Ident)   % named parameter
            | * :       % unnamed parameter
        ]

        % To do: assign an address (qAddr)

        oScopeDeclare       % declare nParam
        oNodePop            % pop nType

        [
            | ',' :
            | * :   >
        ]
    }

    ')'

    %  Now go back and assign addresses to the parameters

    oNodeGet (qDecls)

    {
        [ oCountZero
            | true:  >
            | false:
        ]

        oValuePushCount oNodeSetValue(qAddr) oValuePop

        oCountDec
        oNodeNext
    }
    oNodePop % Null at end of param list
    oCountPop

    ;

% ------------------------- Operations -----------------------

%  Returns true if definition found

OperationDefinition >> boolean:

    [
        | pIdent:
        | *:        >> false
    ]

    oNodeNew (nOperation)  oNodeSetIdent(qIdent)
    oValuePushCount  oNodeSetValue (qValue)  oValuePop   % op# from counter

    oCountInc

    oScopeBegin    % parameter scope

    @FormalParamDefinition

    oNodeLink (qParamScope)

    [ | '>>': pIdent  @LookupType
              oNodeLink (qType)
      |*:     %  qType and qParamType are NULL by default
    ]

    oScopeEnd      % parameter scope

    oScopeDeclare  % declare operation

    >> true
    ;

% ------------------------- Rules ----------------------------

%  Start a definition in the rules secition.
%  This could be:
%      a rule definition, a rule prototype, or a global variable definition.
%  Returns true if one of the above found

RuleSectionDefinition >> boolean:
    [
        | pIdent:
        | * :        >> false
    ]

    [ oScopeFind
        | false:     @RuleDefinition
        | true:
            [ oNodeChooseType
                | nType :  @DeclareGlobals   oNodePop
                | * :      oNodePop #eNotRuleOrGlobalDefn  >> true  % True to skip to next
            ]
    ]

    >> true
    ;

%   Just parsed ident of rule.
RuleDefinition:

    oDocNewRule

    oNodeNew (nRule)  oNodeSetIdent(qIdent)  oRuleSetCurrentRule

    oValuePushHere  oNodeSetValue (qValue)  oValuePop

    oScopeBegin                % param scope
    @FormalParamDefinition
    oNodeLink (qParamScope)    % leave scope open, to access params during rule

    [ | '>>':
          pIdent  @LookupType  oNodeLink (qType)
      | * :
    ]

    ':'

    oScopeBegin       % rule variables scope

    oRuleSetNumLocals(zero)    % count local vars, to assign addresses and make space for them
    .iLocalSpace 
    oRuleSetLocalSpaceAddr .iSpace

    {[ Statement
        | true:
        | *:  >
    ]}

    ';'
    .iReturn

    oRulePatchLocalSpace


    oScopeEnd            % rule variables scope
    oNodeLink (qScope)

    oScopeEnd            % parameters scope (already linked to nRule above)

    oScopeDeclare        % declare nRule
                         % (Note, can't call rule recursively
                         % since not defined until end)
    ;

% ------------------------- Statements -----------------------

%  Returns true if statement found

Statement >> boolean:

    [
        | pStrLit:           % input alias
            oShortFormLookup @RequireInput
            .iInput @EmitValue oNodePop

        | pIdent:            % input or operation
            oScopeFindRequire
            [ oNodeChooseType

                | nInput:      .iInput @EmitValue  oNodePop

                | nOperation:  @RequireNoType @CallOperation   oNodePop

                | nType:       @DeclareLocals     oNodePop

                | *:           @Assignment    % pops identifier
            ]

	| '#':
            pIdent  @LookupError
            .iError @EmitValue  oNodePop

	| '.':
	    [ | pIdent:    @LookupOutput
              | pStrLit:   oShortFormLookup @RequireOutput
            ]
            .iEmit @EmitValue  oNodePop

	| '@':
	    pIdent
            [ oScopeFind
                | true :
                    @RequireRule  @RequireNoType
                    @CallRule
                    oNodePop

                | false :
                    @CallUndefinedRule
            ]

	| '>>':
            oRuleGetCurrentRule   % ugh.  To check return type of current rule.
            oNodeGet (qType)
	    [ oNodeNull
                | true :
                | * :
                    @Expr  @RequireMatchType
                    oNodePop   % type of expr
                    oNodePop   % type of rule

            ]
            oNodePop   % current nRule
            .iReturn

	| '{':
            oPatchPushHere (patchLoop)
            oPatchMark (patchBreak)
	    {[ Statement
		| true:
		| *:  >
	    ]}
	    '}'
            .iJumpBack
            oPatchPopBack (patchLoop)

            % Fix up break statements
            {[ oPatchAtMark (patchBreak)
                | false :    oPatchPopFwd (patchBreak)
                | * :        >
            ]}

	| '>':
            [ oPatchAnyEntries (patchLoop)
                | false:  #eNotInLoop
                | *:
            ]
            .iJumpForward  oPatchPushHere (patchBreak)  .iSpace

	| '?':  .iInputAny

	| '[':  @Choice

        | *:    >> false    % Not a statement
    ]
    >> true ;


%  Called with nOperation on stack

CallOperation:
    @ActualParams     % pushes #params on value stack

    @EmitValue        % call operation

    [ oValueZero
        | true :
        | false :     .iPop .iConstant
    ]
    oValuePop
    ;


%  Called with nOperation or nRule on stack
%  Pushes number of parameters on value stack

ActualParams:

    oNodeGet (qParamScope)    % nScope always present, but may be empty (no nParams)
    oNodeGet (qDecls)         % first nParam

    [ oNodeNull

        | true :    oValuePush (zero)   oNodePop  >>
        | false :
    ]

    oCountPush (zero)

    '('

    {
        oCountInc

        %  ----------------------------

        %  One actual parameter.  Formal nParam is on stack.

        [ oNodeChooseType
            | nInParam :
                oNodeGet (qType)   % type of formal param
                @Expr              % type of actual param to stack

            | nOutParam, nInOutParam :
                oNodeGet (qType)   % type of formal param
                @Lvalue            % type (pointed to by lvalue) to stack
        ]
        @RequireMatchType
        .iPushResult

        oNodePop oNodePop  % actual param type, formal param type

        %  ----------------------------

        oNodeNext

        [ oNodeNull
            | true :   >
            | false :
        ]

        ','
    }

    ')'

    oNodePop    % param nScope
    oValuePushCount oCountPop
    ;



%  Called with nRule on stack

CallRule:
    @ActualParams      % pushes #params on value stack

    .iCall @EmitValue  % call rule

    % Pop actual params
    [ oValueZero
        | true :
        | false :     .iPop .iConstant
    ]
    oValuePop
    ;

%  Implicitly declare a rule that has not previously been declared.
%  Rule name is last accepted identifier.
%  NOTE, for now, I just don't declare it. This means we don't get
%  consistency checking.  Should do some work and add qDeclared field.

CallUndefinedRule:
    .iCall
    oPatchPushHere (patchCall)
    oPatchPushIdent (patchCall)
    .iSpace

    [ | '(' :  #eFwdRuleParamsNotSupportedYet
      | *:
    ]
    ;


%  Already parsed pIdent and determined it is not a rule/type/operation.
%  nDeclaration is on stack.  Will be replaced with lvalue type.

Assignment:
    @Lvalue_HaveIdent     % replaces ident on stack with type referenced by lvalue
    .iPushResult
    '='
    @Expr  @RequireMatchType
    oNodePop  oNodePop    % rvalue type, lvalue type
    .iAssign
    ;

Choice:
    %  Determine if this is an input choice or a value choice.
    %  Push flag on value stack indicating which of the above cases this is.
    %  Push type of value choice on node stack (or Null if not known yet)

    [
        | '|' :
            .iInputChoice   oValuePushKind (kInput)   % flag that this is an input choice

            oNodePushNull   % dummy to hold place of choice nType

        | * :
            @Expr  .iChoice

            % Expr indicates forward use of undefined rule by returning expr type NULL
            % We will indicate this for ourselves by pushing value kUnknown

            [ oNodeNull
                | true :    oNodePushNull    % keep Null type on stack for now
                            oValuePushKind (kUnknown)
                | false:    oValuePushKind (kType)  % flag that choice is typed
            ]

            '|'
    ]

    oPatchPushHere (patchChoiceTableAddr)
    .iSpace

    oPatchMark (patchChoiceTable)    % build up choice table in this stack
    oPatchMark (patchChoiceExit)     % remember end of each option
    oCountPush (zero)                % count options

    {
        [
            | '*':     % default code (must be last option)
                ':'
                @CopyChoiceTable

                {[ Statement
                    | true :
                    | *: >
	        ]}
                ']'

                % Clean up
                oCountPop oValuePop
                oNodePop     % choice nType

                @FixChoiceExits
                >>

            | * :
                {
                    [ oValueChooseKind   % kind of choice statement

                        | kType :         % rule/op choice
                            @Const        % constant value to value stack, nType to node stack
                            @RequireMatchType
                            oNodePop      % type of constant

                        | kUnknown :      % rule choice, rule type not known yet

                            % Change flag to indicate the choice will be typed now
                            oValuePop oValuePushKind (kType)

                            % Get constant value on value stack,
                            % and replace dummy nType with nType of constant.

                            oNodePop     % dummy nType
                            @Const       % get constant in value stack, type on node stack

                            % NOTE: now that we know type of forward rule, we could update nRule

                        | kInput :        % input choice
                            [ | pIdent :  @LookupInput
                              | pStrLit : oShortFormLookup @RequireInput
                            ]
                            oNodeGetValue (qValue)
                            oNodePop
                    ]

                    % value of option is now on value stack

                    oPatchPushHere (patchChoiceTable)
                    oPatchPushValue (patchChoiceTable)
                    oValuePop  oCountInc

                    [
                        | ':' :   >
                        | ',' :
                    ]
                }
        ]

        % Code for this option:

        {[ Statement
            | true:
            | *:  >
        ]}

        [
            | ']' :     % end of choice, no default
                .iJumpForward
                oPatchPushHere (patchChoiceExit) .iSpace
                @CopyChoiceTable

                % Clean up
                oCountPop oValuePop
                oNodePop     % choice nType

                .iEndChoice

                @FixChoiceExits
                >>

            | '|' :     % more options follow
                .iJumpForward
                oPatchPushHere (patchChoiceExit) .iSpace
        ]
    };


%  Install choice table here.
%  #options is in the top counter.
%  Order of options is opposite that in the source (note for error recovery)

CopyChoiceTable:
    oPatchPopFwd (patchChoiceTableAddr)    % fix pointer to table
    oValuePushCount  .iConstant  oValuePop       % # entries
    {[ oPatchAtMark (patchChoiceTable)
        | false :
            oPatchPopValue (patchChoiceTable)
            oPatchPopBack (patchChoiceTable)
        | * :   >
    ]};
    
% Fix jumps from end of each option to end of choice

FixChoiceExits:
    {[ oPatchAtMark (patchChoiceExit)
        | false:    oPatchPopFwd (patchChoiceExit)
        | *:        >
    ]};

FixForwardCalls:
    {[ oPatchAnyEntries (patchCall)
        | true :    oPatchPopCall (patchCall)
        | * :       >
    ]};

%  ------------------------------------------------------- 

%  Emits code for expression (with result in ssl_result).
%  Leaves nType of expression on node stack.

Expr:
    [
        | pIdent :

            [ oScopeFind
                | true :
                    [ oNodeChooseType
                        | nRule :        @CallRule
                        | nOperation :   @CallOperation
                        | nValue :       .iSetResult @EmitValue
                        | nInParam :     .iGetParam  @EmitAddr
                        | nOutParam :    .iGetFromParam @EmitAddr
                        | nInOutParam :  .iGetFromParam @EmitAddr
                        | nLocal :       .iGetLocal @EmitAddr
                        | nGlobal :      .iGetGlobal @EmitAddr
                        | * : #eIdentNotAllowedInExpr
                    ]
                    oNodeGet (qType)         % Get type of identifier
                    oNodeSwap oNodePop       % Pop identifier, leaving its type

                    [ oNodeNull
                        | true:  oNodePushNull  #eNotTyped   % e.g. call with no return value
                        | * :
                    ]

                | false :
                    % Call before defined.  Limited use in this case.
                    % The nType pushed will be NULL.  We don't know the real type.
                    % This is really just allowed so we can have simple rules in a Choice expression.

                    @CallUndefinedRule

                    oNodePushNull
            ]

        | '-' :
            pIntLit
            .iSetResult oValuePushIntLit oValueNegate .iConstant oValuePop
            oNodeGetIntType
        | pIntLit :
            .iSetResult oValuePushIntLit .iConstant oValuePop
            oNodeGetIntType
    ];

%  Emits code for lvalue (putting address of variable in ssl_result).
%  Leaves nType of the referenced value on node stack.

Lvalue:
    [
        | pIdent :

            [ oScopeFind
                | true :
                    @Lvalue_HaveIdent

                | false :   % a forward use of rule, illegal as lvalue
                    oNodePushNull #eIllegalLvalue
            ]

        | '-' :   pIntLit     oNodePushNull #eIllegalLvalue
        | pIntLit :           oNodePushNull #eIllegalLvalue
    ];

%  Emit code for lvalue, given nDeclaration of identifier on stack.
%  Replace ident nDeclaration on stack, with the lvalue's nType

Lvalue_HaveIdent:
    [ oNodeChooseType
        | nInParam :     .iGetAddrParam  @EmitAddr
        | nOutParam :    .iGetParam      @EmitAddr
        | nInOutParam :  .iGetParam      @EmitAddr
        | nLocal :       .iGetAddrLocal  @EmitAddr
        | nLocal :       .iGetAddrGlobal @EmitAddr
        | * : #eIllegalLvalue
    ]
    oNodeGet (qType)         % Get type of identifier
    oNodeSwap oNodePop       % Pop identifier, leaving its type
    ;

%  Get constant value onto value stack.
%  Push nType of value onto node stack.
%  NOTE: Does not emit any code.

Const:
    [
        | pIdent :
            @LookupValue
            oNodeGetValue (qValue)
            oNodeGet (qType)
            oNodeSwap oNodePop    % pop nValue, leave nType
        | '-' :
            pIntLit oValuePushIntLit oValueNegate
            oNodeGetIntType
        | pIntLit :
            oValuePushIntLit
            oNodeGetIntType
    ];

%  Return integer constant on value stack.
%  Only values of type "int" are permitted.
%  Leave node stack unchanged.
IntConst:
    @Const
    oNodeGetIntType  @RequireMatchType  oNodePop
    oNodePop;

%  ------------------------------------------------------- 

%  Assert that the ident we just read is a particular kind of
%  identifier.  Also, leave the declaration node of the name
%  on the node stack.

LookupType:
    oScopeFindRequire
    @RequireType;

LookupInput:
    oScopeFindRequire
    @RequireInput;

LookupOutput:
    oScopeFindRequire
    @RequireOutput;

LookupValue:
    oScopeFindRequire
    @RequireValue;

LookupError:
    oScopeFindRequire
    @RequireError;

%  Assert that current nDeclaration on node stack represents
%  a particular kind of declaration.

RequireType:
    [ oNodeChooseType
        | nType :
        | * :    #eNotAType
    ];

RequireInput:
    [ oNodeChooseType
        | nInput :
        | * :    #eNotInput
    ];

RequireOutput:
    [ oNodeChooseType
        | nOutput :
        | * :    #eNotOutput
    ];

RequireValue:
    [ oNodeChooseType
        | nValue :
        | * :    #eNotAValue
    ];

RequireError:
    [ oNodeChooseType
        | nError :
        | * :    #eNotAnErrSig
    ];

RequireRule:
    [ oNodeChooseType
        | nRule :
        | * :    #eNotARule
    ];

%  Require that rule/operation has no return type

RequireNoType:
    oNodeGet (qType)
    [ oNodeNull
        | false: #eChoiceOpRuleOutOfPlace  oNodePop
        | * :
    ];

%  Given a value nDeclaration on stack, and nType under it.
%  Ensure that the value symbol has the type nType.

RequireMatchValueType:
    oNodeGet (qType)    % Get value's type
    [ oNodeCompareExactUnder2
        | true :
        | * :    #eWrongType
    ]
    oNodePop;


%  Given a nType on stack and a nType under it,
%  ensure that the types are the same.

RequireMatchType:
    [ oNodeCompareExact
        | true :
        | * :    #eWrongType
    ];


%  Given nType on stack, and nType two under it.

RequireMatchTypeUnder2:
    [ oNodeCompareExactUnder2
        | true :
        | * :    #eWrongType
    ];

%  Is the top node the nType of "int" type?

MatchIntType >> boolean:
    oNodeGetIntType
    [ oNodeCompareExact
        | true :  oNodePop  >> true
        | * :     oNodePop  >> false
    ];

%  ------------------------------------------------------- 


%  Emit the value of an identifier declaration, given its nDeclaration

EmitValue:
    oNodeGetValue(qValue) .iConstant oValuePop;

%  Emit the addr of a variable, given its declaration

EmitAddr:
    oNodeGetValue(qAddr) .iConstant oValuePop;

end

