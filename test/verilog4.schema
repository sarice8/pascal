%  
%****************************************************************************
%
%  verilog.schema
%
%  by Steve Rice
%
%  May 1, 1991
%
%****************************************************************************
%
%   Describes the tree used to represent the parsed Verilog program.
%
%   HISTORY
%----------------------------------------------------------------------------
%   05/01/91 | Steve  | Created.
%   05/09/91 |        | Added nodes for expressions and lvalues.
%   05/12/91 |        | Added nodes for gate instances.
%   05/13/91 |        | Added net declarations.
%   05/23/91 |        | Added nSym node, to list all declarations.
%   06/05/91 |        | Added nodes for statements.
%
%****************************************************************************
%

Schema VERILOG Root LibraryUnit Is

%  Object is the initial item.
%  Any object can be made into a LIST, if nodes are appended together.
%  Each object has a LIST or NODE flag.
%  Each object has a unique object number, to save tree to a file.
%  Each object has a NEXT field, so an object can be part of one (1) LIST.

%  I've called range attributes "qLow, qHigh" even though the
%  range can be ascending or descending.  Should change this.


% Identifier declarations are often divided into two nodes:
% a head and an instance.  The head says what the type is,
% along with other attributes common to that type.
% The instance gives further specifics for that identifier.
% (example: nGateHead and nGateInstance)
% nModule is derived from nDeclHead for the moment, because
% there is an nSym node who's qDeclHead points to it.
% I'll have to change this because I want nModule to derive
% from library unit.

Object ::= nDeclHead

nDeclHead ::= nModule
nModule =>
	qIdent:     Integer4
	qSyms:      List      (nSym)            [Pri,Opt]  % name space
	qPorts:     List      (nPort)           [Pri,Opt]
	qParams:    List      (nParamDecl)      [Pri,Opt]
	qInputs:    List      (nInputDecl)      [Pri,Opt]
	qOutputs:   List      (nOutputDecl)     [Pri,Opt]
	qInOuts:    List      (nInOutDecl)      [Pri,Opt]
	qNets:      List      (nNetDecl)        [Pri,Opt]
	qRegs:      List      (nRegDecl)        [Pri,Opt]
	qTimes:     List      (nTimeDecl)       [Pri,Opt]
	qIntegers:  List      (nIntegerDecl)    [Pri,Opt]
	qReals:     List      (nRealDecl)       [Pri,Opt]
        qEventDecls:List      (nEventDecl)      [Pri,Opt]
	qGates:     List      (nGateHead)       [Pri,Opt]
	qDefParams: List      (nParamDecl)      [Pri,Opt]
	qContAssign:List      (nContAssign)     [Pri,Opt]  % continuous assign
	qInitial:   List      (nStatement)      [Pri,Opt]
	qAlways:    List      (nStatement)      [Pri,Opt]


Object ::= nPort
nPort =>
	qIdent:     Integer4
	qPortExpr:  List      (nPortRef)        [Pri,Opt]
	            % if >1 nPortRef in List, they are concated refs using {}

Object ::= nPortRef
nPortRef =>
	qIdent:     Integer4
	qLow:       Node      (nConstExpr)      [Pri,Opt]
	qHigh:      Node      (nConstExpr)      [Pri,Opt]

nDeclHead ::= nInputDecl
nInputDecl =>
	qLow:       Node      (nConstExpr)      [Pri,Opt]
	qHigh:      Node      (nConstExpr)      [Pri,Opt]
	qVars:      List      (nVar)            [Pri,Opt]

nDeclHead ::= nOutputDecl
nOutputDecl =>
	qLow:       Node      (nConstExpr)      [Pri,Opt]
	qHigh:      Node      (nConstExpr)      [Pri,Opt]
	qVars:      List      (nVar)            [Pri,Opt]

nDeclHead ::= nInOutDecl
nInOutDecl =>
	qLow:       Node      (nConstExpr)      [Pri,Opt]
	qHigh:      Node      (nConstExpr)      [Pri,Opt]
	qVars:      List      (nVar)            [Pri,Opt]

nDeclHead ::= nParamDecl
nParamDecl =>
	qAssigns:   List      (nAssign)         [Pri,Opt]

Object ::= nVar
nVar =>
	qIdent:     Integer4

nDeclHead ::= nRegDecl
nRegDecl =>
	qLow:       Node      (nConstExpr)      [Pri,Opt]
	qHigh:      Node      (nConstExpr)      [Pri,Opt]
	qRegVars:   List      (nRegVar)         [Pri]

Object ::= nRegVar
nRegVar =>
	qIdent:     Integer4
	qLow:       Node      (nConstExpr)      [Pri,Opt]  % if present, require
	qHigh:      Node      (nConstExpr)      [Pri,Opt]  % both qLow and qHigh

nDeclHead ::= nTimeDecl
nTimeDecl =>
	qRegVars:   List      (nRegVar)         [Pri]

nDeclHead ::= nIntegerDecl
nIntegerDecl =>
	qRegVars:   List      (nRegVar)         [Pri]

nDeclHead ::= nRealDecl
nRealDecl =>
	qVars:      List      (nVar)            [Pri,Opt]


Object ::= nMacromodule
	% TO BE DEFINED

Object ::= nPrimitive
	% TO BE DEFINED

Object ::= nPort
	% TO BE DEFINED

Object ::= nAssign
nAssign =>
	qLvalue:    Node      (nLvalue)         [Pri]
	qExpr:      Node      (nExpr)           [Pri]

Object ::= nLvalue
	% TO BE DEFINED

Object ::= nEventCtrl      % either nIdentRef or List of nEventExpr
                           % A List of nEventExpr indicates they are 'or'ed

Object ::= nEventExpr
nEventExpr =>
	qEdge:      Integer4     % pPosedge, pNegedge   0 = none specified
	qExpr:      Node      (nExpr)           [Pri]

Object ::= nExpr

nExpr ::= nUnaryOperator
nUnaryOperator =>
	qOp:        Integer4
	qExpr:      Node      (nExpr)           [Pri]

nExpr ::= nBinaryOperator
nBinaryOperator =>
	qOp:        Integer4
	qLeft:      Node      (nExpr)           [Pri]
	qRight:     Node      (nExpr)           [Pri]

nExpr ::= nIfOperator      % expr ? expr : expr
nIfOperator =>
	qExpr:      Node      (nExpr)           [Pri]
	qLeft:      Node      (nExpr)           [Pri]   % Or, "qTrue" ?
	qRight:     Node      (nExpr)           [Pri]

Object ::= nString
nString =>
	qString:    Integer4        % CHANGE to String (C string)

nExpr ::= nDecimalNumber
nDecimalNumber =>
	qDecimalNumber: Integer4

nExpr ::= nIdentRef
nIdentRef =>
	qIdentPath: List      (nIdent)          [Pri]
	qLow:       Node      (nExpr)           [Opt,Pri]
	qHigh:      Node      (nConstExpr)      [Opt,Pri]   % if present,then
	                                                    % both are constant
Object ::= nIdent
nIdent =>
	qIdent:     Integer4

nExpr ::= nFunctionCall
nFunctionCall =>
	qIdent:     Integer4
	qArgs:      List      (nExpr)           [Pri]

nFunctionCall ::= nFunctionCallSys

nExpr ::= nConcat
nConcat =>
	qArgs:      List      (nExpr)           [Pri]

nExpr ::= nMultConcat
nMultConcat =>
	qLeft:      Node      (nExpr)           [Pri]   % iterations
	qRight:     Node      (nExpr)           [Pri]   % an nConcat node

nDeclHead ::= nGateHead   % head of a list of gate instances
nGateHead =>
	qGateType:  Integer4
	qStrength1: Integer4                    [Opt]
	qStrength0: Integer4                    [Opt]
	qDelay:     Node      (nDelay)          [Pri,Opt]
	qGateInst:  List      (nGateInst)       [Pri]

Object ::= nGateInst
nGateInst =>
	qIdent:     Integer4
	qTerminals: List      (nExpr)           [Pri]

Object ::= nDelay      % could actually be LIST of nIdent,
	               % nDecimalNumber, or LIST of nExpr (or nMinTypMax)

% mintypmax -- if only one part given, then it's just one nExpr node

nExpr ::= nMinTypMax
nMinTypMax =>
	qMin:       Node      (nExpr)           [Pri]
	qTyp:       Node      (nExpr)           [Pri]
	qMax:       Node      (nExpr)           [Pri]

nDeclHead ::= nNetDecl
nNetDecl =>
	qNetType:   Integer4
	qCharge:    Integer4                    [Opt]   % for trireg only
	qStrength1: Integer4                    [Opt]
	qStrength0: Integer4                    [Opt]
	qExpand:    Integer4                    [Opt]  % pVectored,pScalared
	qLow:       Node      (nExpr)           [Pri,Opt] 
	qHigh:      Node      (nExpr)           [Pri,Opt]
	qDelay:     Node      (nDelay)          [Pri,Opt]
	qVars:      List      (nVar)            [Pri,Opt]
	qAssigns:   List      (nAssign)         [Pri,Opt]

Object ::= nContAssign    % continuous assign
nContAssign =>
	qStrength1: Integer4                    [Opt]
	qStrength0: Integer4                    [Opt]
	qDelay:     Node      (nDelay)          [Pri,Opt]
	qAssigns:   List      (nAssign)         [Pri,Opt]

nDeclHead ::= nEventDecl
nEventDecl =>
	qEvents:    List      (nEvent)          [Pri,Opt]

Object ::= nEvent
nEvent =>
	qIdent:     Integer4

Object ::= nStatement

nStatement ::= nStmtAssign
nStmtAssign =>
	qLvalue:    Node      (nLvalue)         [Pri]
	qExpr:      Node      (nExpr)           [Pri]

nStmtAssign ::= nStmtContAssign   % "quasi" continuous assign (p.67)

nStmtAssign ::= nStmtAssignDelay
nStmtAssignDelay =>
	qDelayCtrl: Node      (nExpr)           [Pri]

nStmtAssign ::= nStmtAssignEvent
nStmtAssignEvent =>
	qEventCtrl: Node      (nEventCtrl)      [Pri]

nStatement ::= nStmtIf
nStmtIf =>
	qExpr:      Node      (nExpr)           [Pri]
	qStatement: Node      (nStatement)      [Pri,Opt]
	qElse:      Node      (nStatement)      [Pri,Opt]

nStatement ::= nStmtForever
nStmtForever =>
	qStatement: Node      (nStatement)      [Pri,Opt]

nStatement ::= nStmtRepeat
nStmtRepeat =>
	qExpr:      Node      (nExpr)           [Pri]
	qStatement: Node      (nStatement)      [Pri,Opt]

nStatement ::= nStmtWhile
nStmtWhile =>
	qExpr:      Node      (nExpr)           [Pri]
	qStatement: Node      (nStatement)      [Pri,Opt]

nStatement ::= nStmtWait
nStmtWait =>
	qExpr:      Node      (nExpr)           [Pri]
	qStatement: Node      (nStatement)      [Pri,Opt]

nStatement ::= nStmtFor
nStmtFor =>
	qAssign1:   Node      (nAssign)         [Pri]
	qExpr:      Node      (nExpr)           [Pri]
	qAssign2:   Node      (nAssign)         [Pri]
	qStatement: Node      (nStatement)      [Pri,Opt]

nStatement ::= nStmtDelayCtrl
nStmtDelay =>
	qDelayCtrl: Node      (nExpr)           [Pri]
	qStatement: Node      (nStatement)      [Pri,Opt]

nStatement ::= nStmtEventCtrl
nStmtEventCtrl =>
	qEventCtrl: Node      (nEventCtrl)      [Pri]
	qStatement: Node      (nStatement)      [Pri,Opt]

nStatement ::= nStmtEvent
nStmtEvent =>
	qIdent:     Integer4

nStatement ::= nStmtDeassign
nStmtDeassign =>
	qLvalue:    Node      (nLvalue)         [Pri]

nStatement ::= nStmtTask
nStmtTask =>
	qIdent:     Integer4
	qArgs:      List      (nExpr)           [Pri]

nStmtTask ::= nStmtTaskSys

nStatement ::= nBlock
nBlock =>
	qIdent:     Integer4
	qParams:    List      (nParamDecl)      [Pri,Opt]
	qRegs:      List      (nRegDecl)        [Pri,Opt]
	qIntegers:  List      (nIntegerDecl)    [Pri,Opt]
	qReals:     List      (nRealDecl)       [Pri,Opt]
	qTimes:     List      (nTimeDecl)       [Pri,Opt]
        qEventDecls:List      (nEventDecl)      [Pri,Opt]
	qStatements:List      (nStatement)      [Pri,Opt]


nBlock ::= nBlockSeq

nBlock ::= nBlockPar



Object ::= nSym
nSym =>
	qIdent:     Integer4
	qDeclHead:  Node      (nDeclHead)       [Alt,Opt]
        qDeclInst:  Node      (Object)          [Alt,Opt]
        qValue:     Node      (nExpr)           [Alt,Opt]  % initial value

Object ::= nTO_DO      % indicates that tree building
	               % not implemented yet; just a placeholder

End
