%  This version makes actual use of object derivation.
%  However, it's just for testing the schema compiler;
%  I haven't made efforts to be true to Verilog.
%
%  Also, the way I'm doing it now, you shouldn't add
%  further attributes to an object once you've derived
%  another object from that object.
%  This is because I copy all attributes when I derive,
%  so if you add further attributes later then they
%  won't be available in the previously derived object.
%  How does this compare to the IDL method?
%
%  Also note, right now I'm only dealing with
%  objects and attributes; not the types of the attributes
%  or their tags.


Schema VERILOG Root LibraryUnit Is

%  Object is the initial item.
%  Any object can be made into a LIST, if nodes are appended together.
%  Each object has a LIST or NODE flag.
%  Each object has a unique object number, to save tree to a file.
%  Each object has a NEXT field, so an object can be part of one (1) LIST.

%  I've called range attributes "qLow, qHigh" even though the
%  range can be ascending or descending.  Should change this.

Object ::= nModule
nModule =>
	qIdent:     Integer4
	qPorts:     List      (nPort)           [Pri,Opt]
	qParams:    List      (nAssign)         [Pri,Opt]
	qInputs:    List      (nInputDecl)      [Pri,Opt]
	qOutputs:   List      (nOutputDecl)     [Pri,Opt]
	qInOuts:    List      (nInOutDecl)      [Pri,Opt]
	qRegs:      List      (nRegDecl)        [Pri,Opt]
	qTimes:     List      (nTimeDecl)       [Pri,Opt]
	qIntegers:  List      (nIntegerDecl)    [Pri,Opt]
	qReals:     List      (nRealDecl)       [Pri,Opt]

Object ::= nPort
nPort =>
	qIdent:     Integer4                    [Opt]
	qExpr:      List      (nPortRef)        [Pri,Opt]
	            % if >1 qExpr in List, they are concated refs using {}

Object ::= nConstRange        % none, low, or low,high attributes
nConstRange =>
	qLow:       Node      (nConstExpr)      [Pri,Opt]
	qHigh:      Node      (nConstExpr)      [Pri,Opt]

nConstRange ::= nPortRef
nPortRef =>
	qIdent:     Integer4

nConstRange ::= nIOVarDecl
nIOVarDecl =>
	qVars:      List      (nVar)            [Pri]

nIOVarDecl ::= nInputDecl

nIOVarDecl ::= nOutputDecl

nIOVarDecl ::= nInOutDecl

Object ::= nVar
nVar =>
	qIdent:     Integer4

nConstRange ::= nRegDecl
nRegDecl =>
	qRegVars:   List      (nRegVar)         [Pri]

nConstRange ::= nConstRangeBoth     % none, or both low,high

nConstRangeBoth ::= nRegVar
nRegVar =>
	qIdent:     Integer4

Object ::= nAbstractRegDecl
nAbstractRegDecl =>
	qRegVars:   List      (nRegVar)         [Pri]

nAbstractRegDecl ::= nTimeDecl

nAbstractRegDecl ::= nIntegerDecl

Object ::= nRealDecl
nRealDecl =>
	qVars:      List      (nVar)            [Pri]


Object ::= nMacromodule
	% TO BE DEFINED

Object ::= nPrimitive
	% TO BE DEFINED

Object ::= nPort
	% TO BE DEFINED

End
