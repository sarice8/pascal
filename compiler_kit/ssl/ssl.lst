      %  sccsid = "%W% %G% %U% %P%";
      
   2: title: 'SSL Translator 1.3.2 -- September 14 ''93';
      
      %
      % *****************************************************************************
      %
      %   Syntax/Semantic Language Compiler
      %
      %   by Steve Rice
      %
      %   Aug 31, 1989
      %
      % *****************************************************************************
      %
      %   ssl.ssl             SSL compiler
      %
      %   HISTORY
      % -----------------------------------------------------------------------------
      %   08/31/89 | Steve  | Translated from my SSL processor hardcoded in C
      %   09/08/89 |        | SSL processor now functional, except for error recovery
      %   10/18/89 |        | Added 'title' section
      %   02/03/90 |        | Change to ssl.c: Added debugger output
      %   03/20/91 |        | Change to ssl.c: Increased string table size
      %   03/26/91 |        | Fixed bug in handling of statement ">>value"
      %            |        | Fixed bug in handling of choice using a choice rule
      %            |        | defined later
      %   04/24/91 |        | Change to ssl.c: Increased identifier size to 50 chars
      %   05/05/91 |        | Change to ssl.c: Increased identifier table size to
      %            |        | 600, and moved names out of table. New limit 256 chars.
      %            |        | Added "include" feature.
      %   05/21/91 |        | Multiple "error" sections will use distinct error #'s
      %            |        | Added postprocess optimization: reduce chains of jumps
      %   06/04/91 |        | Change to ssl.c: Write rule addresses to code file
      %   08/23/93 |        | Fix some loops so error recovery can terminate
      %   08/25/93 |        | Reimplement using schema database for symbol table
      %   08/27/93 |        | Add new language features: local variables,
      %            |        | multiple parameters, inout parameters,
      %            |        | expressions with nested function calls.
      %            |        | (User program requires the 2.0 runtime model for new
      %            |        | instructions in generated code).
      %   08/29/93 |        | Reimplement compiler using above new language features
      %            |        | (typically using local variables rather than stacks)
      %   09/14/93 |        | Split into two passes: collect definitions, generate
      %            |        | code for rules.  So user is not required to provide
      %            |        | forward definitions for rules with out parameters.
      %            |        |
      % 
      % *****************************************************************************
      %
      
   2: input:
   2:     pIdent
   2:     pIntLit
   2:     pStrLit
   2:     pMinus      '-'
   2:     pEquals     '='
   2:     pColon      ':'
   2:     pSemiColon  ';'
   2:     pComma      ','
   2:     pLParen     '('
   2:     pRParen     ')'
   2:     pReturn     '>>'
   2:     pBreak      '>'
   2:     pLCurly     '{'
   2:     pRCurly     '}'
   2:     pLSquare    '['
   2:     pRSquare    ']'
   2:     pBar        '|'
   2:     pCall       '@'
   2:     pEmit       '.'
   2:     pStar       '*'
   2:     pErr        '#'
   2:     pQuestion   '?'
   2:     pEof
   2:     pInvalid
      
      %  keywords
      
   2:     pTitle
   2:     pInput
   2:     pOutput
   2:     pType
   2:     pError
   2:     pMechanism
   2:     pInclude
   2:     pRules
   2:     pEnd
   2:     pIn
   2:     pOut
   2:     pInOut
   2:     ;
      
      
   2: output:
      
      %  codes for SSL machine instructions
      
   2:     iJumpForward
   2:     iJumpBack
   2:     iInput
   2:     iInputAny
   2:     iEmit
   2:     iError
   2:     iInputChoice
   2:     iCall
   2:     iReturn
   2:     iSetResult
   2:     iChoice
   2:     iEndChoice
   2:     iPushResult      % push ssl_result on variable stack
   2:     iPop             % (n)  discard n entries from variable stack
   2:     iBreak           % instruction used by debugger
   2:     iGlobalSpace     % (n)  make space for n globals on variable stack (sets initial fp)
   2:     iLocalSpace      % (n)  make space for n locals on variable stack
   2:     iGetParam        % (n)  ssl_result = value of param n
   2:     iGetFromParam    % (n)  ssl_result = value of variable whose address is in param n
   2:     iGetLocal        % (n)  ssl_result = value of local var n
   2:     iGetGlobal       % (n)  ssl_result = value of global var n
   2:     iGetAddrParam    % (n)  ssl_result = addr of param n
   2:     iGetAddrLocal    % (n)  ssl_result = addr of local var n
   2:     iGetAddrGlobal   % (n)  ssl_result = addr of global var n
   2:     iAssign          % variable whose address is pushed on stack = ssl_result; pop stack
      
      %   NOTE: Any instructions added here should also be added to
      %         the system_operations table in ssl.c
      %         as well as optimize_table, list_generated_code.
      
      %  other output
      
   2:     iSpace;          % emit a dummy value; a value will be patched here later
      
   2: error:
   2:    eWrongType
   2:    eNotAType
   2:    eNotAValue
   2:    eNotInput
   2:    eNotOutput
   2:    eNotARule
   2:    eNotAnErrSig
   2:    eNotInLoop
   2:    eChoiceOpRuleOutOfPlace
   2:    eUndeclRuleParamsNotSupported
   2:    eNotTyped
   2:    eIdentNotAllowedInExpr
   2:    eIllegalLvalue
   2:    eNotRuleOrGlobalDefn
   2:    eRuleBodyAlreadyDeclared
   2:    eReturnTypeMismatch
   2:    eParameterMismatch
   2:    eUndeclaredIdentifier
   2:    eAliasNotAllowed
   2:    eCantInitGlobalVarsYet
   2:    eRedeclaration
   2:    ;
      
      
   2: include 'ssl_schema.ssl'
      
      % Generated automatically by schema
      
   2: type node_type:
   2: 	nINVALID
   2: 	Object
   2: 	nScope
   2: 	nDeclaration
   2: 	nIdent
   2: 	nOutput
   2: 	nError
   2: 	nType
   2: 	nValue
   2: 	nMechanism
   2: 	nOperation
   2: 	nRule
   2: 	nVariable
   2: 	nParam
   2: 	nInParam
   2: 	nOutParam
   2: 	nInOutParam
   2: 	nLocal
   2: 	nGlobal
   2: 	;
      
   2: type node_attribute:
   2: 	qINVALID
   2: 	qParentScope
   2: 	qDecls
   2: 	qIdent
   2: 	qValue
   2: 	qType
   2: 	qParamScope
   2: 	qScope
   2: 	qAddrDefined
   2: 	qTypeDefined
   2: 	qAddr
   2: 	;
      
      
      
   2: type boolean:
   2:     false    = 0
   2:     true     = 1
   2:     no       = 0
   2:     yes      = 1;
      
   2: type warning:
   2:     wRuleMissingAtSign
   2:     wReturnValueIgnored
   2:     ;
      
   2: type Node:     % A pointer to a node in the schema database (symbol database)
   2:     Null = 0
   2:     ;
      
   2: type NodeIter:  % An iterator over nodes in a list, in the schema database
   2:     NullIter = 0
   2:     ;
      
   2: type kind:
   2:     kIllegal        % not an identifier
   2:     kUnknown        % new identifier
   2:     kInput
   2:     kOutput
   2:     kError
   2:     kType
   2:     kVal            % an element of a type
   2:     kMech
   2:     kOp
   2:     kRule
   2:     kVar
   2:     ;
      
   2: type pass:
   2:     CollectDefinitionsPass
   2:     CodeGenerationPass
   2:     ;
      
   2: mechanism scanner_mech:
   2:     oResetInput               % reset input to start (if required)
   2:     oStartListing             % start listing if requested; collect debug line numbers
   2:     ;
      
   2: mechanism warning_mech:
   2:     oWarning (warning);       % issue warning message,
                                    % continue normally (not in error recovery mode)
      
   2: mechanism more_errors_mech:
   2:     oUndeclaredRule (int id)     % Report that rule id was referenced, but never
                                       % declared (i.e. no body).  No error recovery mode.
   2:     ;
      
   2: mechanism emit_mech:
   2:     oEmitInt (int)            % emit an integer into the generated code
   2:     Here >> int               % return the current address in the generated code
   2:     oPatch (int addr, int val) % patch an integer into any address in the generated code
   2:     ;
      
   2: mechanism math:
   2:     inc (inout int)
   2:     dec (inout int)
   2:     negate (int) >> int
   2:     equal_zero (int) >> boolean
   2:     equal_node_type (node_type, node_type) >> boolean     % Want equal_<type> for every type
   2:     ;
      
   2: mechanism more_builtins:      % These should be built-in SSL operations
   2:     TOKEN_VALUE >> int        % value of just accepted token, e.g. IntLit token
   2:     LAST_ID >> int            % id number of last accepted identifier
   2:     ;
      
   2: mechanism shortForm:          % keep a table of string shortforms for input/output
   2:     oShortFormAdd (Node)      % associate current StrLit token with nDeclaration
   2:     oShortFormLookup (out Node);   % look up strLit, return associated nDeclaration
      
      
      % keep different patch stacks, each with a stack of position markers:
      
   2: type patchStack:
   2:     patchChoiceTableAddr    % addr where pointer to table is stored
   2:     patchChoiceTable        % build up choice table here (value,addr)
   2:     patchChoiceExit         % addrs where jumps at end of each option are
   2:     patchCall               % (addr,ident) where calls to undefined rules are
   2:     patchLoop               % addr of start of a loop
   2:     patchBreak;             % addrs where jumps out of a loop are
      
   2: mechanism patch_mech:
   2:     oPatchMark(patchStack)             % mark current position on a stack
   2:     oPatchAtMark(patchStack) >> boolean     % true if all items since
                                                 %   last mark are popped
                                                 %   (mark is dropped if true)
   2:     oPatchPushHere(patchStack)         % put current address on a patch stack
   2:     oPatchPushInt (patchStack, int)    % put int on a patch stack
   2:     oPatchPushIdent(patchStack)        % put last ident on a patch stack
   2:     oPatchAnyEntries(patchStack) >> boolean    % are there any entries?
   2:     oPatchPopFwd(patchStack)           % fix table, storing here-x at x,
                                             %   where x is on top of the stack
   2:     oPatchPopBack(patchStack)          % emit here-x here (advance 'here')
   2:     oPatchPopValue(patchStack)         % emit x here (advance 'here')
   2:     oPatchPopCall(patchStack);         % fix table, storing value of ident i
                                             %   at x, where i is on top of stack
                                             %   and x is under it  (pop both)
      
   2: mechanism titleMech:
   2:     oTitleSet;          % define title to be strlit just read
      
   2: mechanism doc:         % display documentary info
   2:     oDocNewRule;        % print "Rule <token>"
      
   2: mechanism include_mech:
   2:     oInclude;           % include the SSL file whose name is in the
                             % string token just accepted
      
   2: mechanism node_mech:
   2:     oNodeNew (node_type) >> Node         % create new node
   2:     oNodeSet (Node, node_attribute, Node)   % set Node attribute of node
   2:     oNodeSetInt (Node, node_attribute, int) % set int attribute of node
   2:     oNodeSetBoolean (Node, node_attribute, boolean)
   2:     oNodeGet (Node, node_attribute) >> Node    % get Node attribute of node
   2:     oNodeGetInt (Node, node_attribute) >> int  % get int attribute of node
   2:     oNodeGetBoolean (Node, node_attribute) >> boolean  % get int attribute of node
   2:     oNodeNull (Node) >> boolean          % is node null?
      
   2:     oNodeGetIter (Node, node_attribute) >> NodeIter  % get an iterator over nodes in a List attribute
   2:     oNodeIterValue (NodeIter) >> Node                % the node that iter is referring to (NodeNull if no more nodes)
   2:     oNodeIterNext (inout NodeIter)                   % advance iterator through list
   2:     oNodeIterPrev (inout NodeIter)                   % advance iterator backwards through list
      
   2:     oNodeType (Node) >> node_type        % return node type of node
   2:     oNodeEqual (Node, Node) >> boolean   % compare two nodes for equality
                                               % (i.e. same node, not just same contents)
   2:     ;
      
   2: mechanism scope_mech:
   2:     oScopeBegin (out Node)             % create a new scope.  Subsequent declarations will go here.
                                             % Sets nScope's qParent to parent scope.
   2:     oScopeOpen (Node)                  % open an existing scope.  Its definitions become visible again.
   2:     oScopeEnd                          % end current scope.  Subsequent declarations will go to parent scope.
   2:     oScopeDeclare (Node)               % declare node in current scope
   2:     oScopeFind (out Node) >> boolean   % find declaration of last accepted identifier
   2:     oScopeFindInCurrentScope >> Node   % find declaration of last accepted identifier, only in current scope
   2:     oScopeFindRequire (out Node)       % find declaration of last accepted identifier.
                                             % Go into error recovery if not found.
   2:     ;
      
      
   2: mechanism install_mech:
   2:     oInstallSystemOperations (inout int next_operation)   % Predefine some operations
   2:     oInstallSystemTypes (out Node int_type, out Node token_type)   % Predefine some types.
                                                    % Return nType declaration of types int, token.
   2:     ;
      
   2: mechanism write_mech:
   2:     oWriteTables (Node global_scope);   % Write files, given global scope of symbol table.
      
   2: rules
      
      % ---------------------- Global Variables --------------------
      
   2: pass    CurrentPass         % which of two passes are we in?
   2: Node    IntType             % nType node for built-in "int" type
   2: Node    TokenType           % nType node for built-in "token" type (input tokens)
   2: Node    CurrentRule         % nRule node for current rule being declared
   2: int     NumGlobals          % number of global variables in program
   2: int     NumLocals           % number of local variables in current rule
   2: int     RuleLocalSpaceAddr  % address of LocalSpace argument for rule
   2: int     NextOperation       % code for next semantic operation decl
   2: int     NextError           % next error code
   2: Node    GlobalScope         % global nScope
      
      % -------------------- Forward Declarations ------------------
      
   2: Section >> boolean;
   2: ValueList (node_type class, inout int value, boolean str_alias_allowed, Node t);
   2: OperationDefinition >> boolean;
   2: RuleSectionDefinition >> boolean;
   2: RuleBodyDefinition (Node r);
   2: RuleRedefinition (Node r);
   2: Statement >> boolean;
   2: CallOperation (Node o);
   2: ActualParams (Node r) >> int;
   2: CallRule (Node r);
   2: CallUndefinedRule;
   2: Assignment (Node i);
   2: CopyChoiceTable (int num_options);
   2: Expr (out Node t);
   2: Lvalue (out Node t);
   2: Lvalue_HaveIdent (Node i, out Node t);
   2: Const (out Node t) >> int;
   2: IntConst >> int;
   2: LookupType (out Node i);
   2: LookupInput (out Node i);
   2: LookupOutput (out Node i);
   2: LookupValue (out Node i);
   2: LookupError (out Node i);
   2: RequireType (Node i);
   2: RequireInput (Node i);
   2: RequireOutput (Node i);
   2: RequireValue (Node i);
   2: RequireError (Node i);
   2: RequireRule (Node i);
   2: RequireNoType (Node r);
   2: RequireMatchValueType (Node v, Node t);
   2: MatchType (Node t1, Node t2) >> boolean;
   2: RequireMatchType (Node t1, Node t2);
   2: MatchIntType (Node t) >> boolean;
   2: RequireMatchIntType (Node t);
   2: EmitValue (Node i);
   2: EmitAddr (Node v);
      
      % ------------------------- Main Parser ----------------------
      
   2: ProcessSSL:
   4:     @CollectDefinitions     % first pass through input
   6:     oResetInput
   7:     @CodeGeneration         % second pass through input
  10:     ;
      
      
  10: CollectDefinitions:
      
  12:     CurrentPass = CollectDefinitionsPass
      
  18:     oScopeBegin (GlobalScope)
      
  24:     NextError = 0
  30:     NextOperation = 0
      
  36:     oInstallSystemOperations (NextOperation)
  42:     oInstallSystemTypes (IntType, TokenType)
      
  51:     NumGlobals = 0                 % Count global variables
      
  57:     {[ @Section
  60:         | true:
  61:         | *:  >
  68:     ]}
      
  70:     oScopeEnd
  72:     ;
      
      
  72: CodeGeneration:
      
  74:     CurrentPass = CodeGenerationPass
      
  80:     oScopeOpen (GlobalScope)   % Re-open scope
      
  86:     oStartListing   % Listing done in second pass, so it contains
                          % addresses of generated code.
                          % Also, collects line numbers for debugging.
      
          % Make space for global variables (inc because addressed from 1, not 0)
  87:     inc (NumGlobals)   .iGlobalSpace  oEmitInt(NumGlobals)
      
 101:     {[ @Section
 104:         | true:
 105:         | *:  >
 112:     ]}
      
 114:     @FixForwardCalls
 116:     @VerifyAllRulesDeclared
      
 118:     oScopeEnd
      
 119:     oWriteTables (GlobalScope)
 126:     ;
      
      
      % Returns true if a section found
      
 126: Section >> boolean:
      
 128:     [ CurrentPass
 131:         | CollectDefinitionsPass :
 132:             [
 132:                 | pTitle:      @Title
 136:                 | pInput:      @Input
 140:                 | pOutput:     @Output
 144:                 | pError:      @Error
 148:                 | pType:       @Type
 152:                 | pInclude:    @Include
 156:                 | pMechanism:  @Mechanism
 160:                 | pRules:      @Rules
 164:                 | pEof:        >> false      % end of file
 169:             ]
      
 191:         | CodeGenerationPass :
 193:             [
 193:                 | pTitle, pInput, pOutput, pError, pType, pMechanism :
 195:                                @SkipSection
      
 197:                 | pInclude:    @Include
 201:                 | pRules:      @Rules
 205:                 | pEof:        >> false      % end of file
 210:             ]
 232:     ]
 240:     >> true
 244:     ;
      
 244: SkipSection:
 246:     {[
 246:         | ';' : >
 250:         | * :   ?
 256:     ]};
      
      % ------------------------- Sections -------------------------
      
 259: Title:
 261:     ':' pStrLit oTitleSet ';' ;
      
      % Input tokens are values of the predefined "token" type
 269: Input:
 271:     int  next_value
 271:     ':'
 273:     next_value = 0
 279:     @ValueList (nValue, next_value, true, TokenType)
 295:     ';';
      
 298: Output:
 300:     int  next_value
 300:     ':'
 302:     next_value = 0
 308:     @ValueList (nOutput, next_value, true, Null)
 324:     ';';
      
 327: Error:
 329:     ':'
 331:     @ValueList (nError, NextError, false, Null)
 347:     ';';
      
      
 350: Type:
 352:     Node  t
 352:     int   next_value
      
 352:     pIdent
 354:     [ oScopeFind (t)
 361:         | false:
 362:             t = oNodeNew (nType)  oNodeSetInt (t, qIdent, LAST_ID)
 383:             oScopeDeclare (t)
      
 389:         | true:
      
                  % Extend existing definition (to add more values)
                  % Note, new values will start from 0 again unless told otherwise!
      
 391:             @RequireType (t)
 398:     ]
      
 406:     ':'
 408:     next_value = 0
 414:     @ValueList (nValue, next_value, false, t)
 430:     ';';
      
      
 433: Include:
 435:     pStrLit oInclude;
      
 439: Mechanism:
 441:     Node  m
      
 441:     pIdent
 443:     m = oNodeNew (nMechanism)  oNodeSetInt(m, qIdent, LAST_ID)
 464:     oScopeDeclare (m)
      
 470:     ':'
 472:     {[ @OperationDefinition
 475:         | true:
 476:         | *:  >
 483:     ]}
 485:     ';' ;
      
 488: Rules:
 490:     {[ @RuleSectionDefinition
 493:         | true:
 494:         | *:  >
 501:     ]}
 503:     pEnd ;
      
      
      % ------------------------- Value List ----------------------
      
 506: ValueList (node_type class, inout int value, boolean str_alias_allowed, Node t):
 508:     Node  p, t2
 508:     {[
 508:         | pIdent:
 510:             p = oNodeNew (class)  oNodeSetInt (p, qIdent, LAST_ID)
      
 531:             [ class
 534:                 | nValue :    oNodeSet (p, qType, t)
 547:                 | * :
 552:             ]
      
 552:             [ | pStrLit:
 554:                 [ str_alias_allowed
 557:                     | true:  oShortFormAdd (p)   % Associate short form with declaration
 564:                     | *:     #eAliasNotAllowed
 571:                 ]
 571:               | *:
 576:             ]
      
 576:             [ | '=':       value = @Const(t2)
 589:                            [ @MatchType (t, t2)
 600:                                | true :
 601:                                | false :  @RequireMatchIntType(t2)
 610:                            ]
 618:               |*:
 623:             ]
 623:             oNodeSetInt (p, qValue, value)
 635:             inc (value)
      
 641:             oScopeDeclare (p)
      
 647:         | *:  >
 654:     ]};
      
      % ------------------------- Variables ------------------------
      
      %  Declare a list of variables, given class (local/global),
      %  nType, and a counter used to assign addresses for that class.
      
 657: DeclareVariables (node_type class, Node t, inout int addr_counter):
 659:     Node  i
 659:     {
 659:         pIdent
 661:         i = oNodeNew(class)  oNodeSetInt(i, qIdent, LAST_ID)
 682:         oNodeSet (i, qType, t)
      
              % Assign address to variable
 694:         inc (addr_counter)   oNodeSetInt (i, qAddr, addr_counter)
      
 712:         [ oNodeNull( oScopeFindInCurrentScope )
 718:             | false : #eRedeclaration
 721:             | * :
 726:         ]
 726:         oScopeDeclare (i)
      
              % optional initialization
 732:         [ | '=' :
      
                  % Unfortunately I can't allow initialization of global vars yet.
                  % This is only because @SkipGlobals would need to know how to skip the
                  % initialization expression, which is a little hard. It could be implemented
                  % but didn't do it yet.
 734:             [ class
 737:                 | nGlobal :  #eCantInitGlobalVarsYet
 740:                 | * :
 745:             ]
      
 745:             Node tv, t2
 745:             @Lvalue_HaveIdent(i,tv)
 755:             .iPushResult
 757:             @Expr(t2)  @RequireMatchType(tv,t2)
 774:             .iAssign
 776:           | * :
 781:         ]
      
 781:         [ | ',' :
 783:           | * :   >
 790:         ]
 790:     };
      
      %  Declare a list of global variables, given nType.
      
 793: DeclareGlobals (Node t):
 795:     @DeclareVariables (nGlobal, t, NumGlobals);
      
      %  Declare a list of local variables, given nType.
      
 809: DeclareLocals (Node t):
 811:     @DeclareVariables (nLocal, t, NumLocals);
      
      
      %  Skip list of global variables, during second pass.
      
 825: SkipGlobals:
 827:     {
 827:         pIdent
 829:         [ | ',' : | * : > ]
 838:     };
      
      
      %  Defines formal parameters (if any) in current scope.
      %  The caller should have called oScopeBegin to begin a
      %  scope just for parameters.  (This gives a simple way
      %  to check if an operation/rule has parameters).
      %  Does not end the scope.
      %
      %  nParam's may be named or unnamed (qIdent == 0)
      %
      %  Parameters are assigned addresses in reverse order
      %  from n to 1.  This is for efficient stack access.
      %  E.g. func(a,b,c):  address of a:3, b:2, c:1
      %  (Later I would like to instead push actuals in reverse order)
      
 841: FormalParamDefinition (Node scope):
 843:     int        num_params
 843:     node_type  dir
 843:     Node       p, t
      
 843:     [ | '(' :
 845:       | *   : >>
 851:     ]
      
 851:     num_params = 0      % Count the parameters, to assign addresses
      
 857:     {
 857:         inc (num_params)
      
              % parameter direction
 863:         [
 863:             | pIn :     dir = nInParam
 871:             | pOut :    dir = nOutParam
 879:             | pInOut :  dir = nInOutParam
 887:             | * :       dir = nInParam
 902:         ]
      
              % parameter type
 902:         pIdent  @LookupType (t)
      
 911:         p = oNodeNew(dir)
 921:         oNodeSet (p, qType, t)
      
              % parameter name
 933:         [
 933:             | pIdent :  oNodeSetInt (p, qIdent, LAST_ID)   % named parameter
 946:             | * :       % unnamed parameter
 951:         ]
      
 951:         oScopeDeclare (p)       % declare nParam
      
 957:         [
 957:             | ',' :
 959:             | * :   >
 966:         ]
 966:     }
      
 968:     ')'
      
          %  Now go back and assign addresses to the parameters
      
 970:     NodeIter it = oNodeGetIter( scope, qDecls )
 983:     {
 983:         p = oNodeIterValue( it )
 993:         [ oNodeNull( p )
1000:             | false :
1001:             | * : >
1008:         ]
      
1008:         oNodeSetInt( p, qAddr, num_params )
      
1020:         dec( num_params )
1026:         oNodeIterNext( it )
1032:     }
1035:     ;
      
      %  Redefine formal parameters, perhaps during declaration of actual rule (with body).
      %  Previously, parameters were declared by a forward declaration or by usage.
      %  Ensure that types match.  Update parameter names to new names given.
      %
      %  Previous parameter nScope is given, and scope has been opened.
      %  (Addresses were assigned previously, no need to do it again).
      %  NOTE: I probably don't really want to open the previous scope since the
      %  old param names are not valid.
      
1035: FormalParamRedefinition (Node scope):
1037:     Node      p
1037:     node_type dir, dir2
1037:     Node      t, t2
      
1037:     NodeIter it = oNodeGetIter( scope, qDecls )   % previous param declarations
      
1050:     [ | '(' :
1052:       | *   : [ oNodeNull( oNodeIterValue( it ) )
1068:                   | true :
1069:                   | * :    #eParameterMismatch
1076:               ]
1076:               >>
1077:     ]
      
1077:     {
1077:         p = oNodeIterValue( it )
1087:         [ oNodeNull(p)
1094:             | true :    #eParameterMismatch  % too many params given this time
1097:             | false :
1099:         ]
      
1107:         dir = oNodeType(p)         % previous direction
              % parameter direction
1117:         [
1117:             | pIn :     dir2 = nInParam
1125:             | pOut :    dir2 = nOutParam
1133:             | pInOut :  dir2 = nInOutParam
1141:             | * :       dir2 = nInParam
1156:         ]
1156:         [ equal_node_type (dir, dir2)
1166:             | true :
1167:             | * :     #eParameterMismatch
1174:         ]
      
1174:         t = oNodeGet (p, qType)    % previous type
1187:         pIdent  @LookupType(t2)    % parameter type
1196:         @RequireMatchType (t, t2)
      
              % parameter name
1206:         [
1206:             | pIdent :  oNodeSetInt (p, qIdent, LAST_ID)
1219:             | * :       oNodeSetInt (p, qIdent, 0)   % currently unnamed
1236:         ]
      
1236:         oNodeIterNext( it )
      
1242:         [
1242:             | ',' :
1244:             | * :   >
1251:         ]
1251:     }
      
1253:     ')'
      
1255:     [ oNodeNull( oNodeIterValue( it ) )
1266:         | true :
1267:         | * :    #eParameterMismatch   % Not enough params given this time
1274:     ]
1275:     ;
      
      
      % ------------------------- Operations -----------------------
      
      %  Returns true if definition found
      
1275: OperationDefinition >> boolean:
1277:     Node  op, s, t
1277:     [
1277:         | pIdent:
1279:         | *:        >> false
1287:     ]
      
1287:     op = oNodeNew (nOperation)  oNodeSetInt (op, qIdent, LAST_ID)
1308:     oNodeSetInt (op, qValue, NextOperation)
1320:     inc (NextOperation)
      
1326:     oScopeBegin (s)   % parameter scope
      
1332:     @FormalParamDefinition(s)
      
1339:     oNodeSet (op, qParamScope, s)
      
1351:     [ | '>>': pIdent  @LookupType (t)   oNodeSet (op, qType, t)
1374:       |*:     %  qType is Null by default
1379:     ]
      
1379:     oScopeEnd      % parameter scope
      
1380:     oScopeDeclare (op)
      
1386:     >> true
1390:     ;
      
      % ------------------------- Rules ----------------------------
      
      %  Parse a definition in the rules secition.
      %  This could be:
      %      a rule definition, a rule prototype, or a global variable definition.
      %  Returns true if one of the above found
      
1390: RuleSectionDefinition >> boolean:
1392:     Node  i
1392:     [
1392:         | pInclude:  @Include
1396:                      >> true
1399:         | pIdent:
1401:         | * :        >> false
1411:     ]
      
1411:     [ oScopeFind (i)
1418:         | false:     @RuleDefinition
1421:         | true:
1423:             [ oNodeType(i)
1430:                 | nType :  [ CurrentPass
1434:                                | CollectDefinitionsPass :  @DeclareGlobals(i)
1442:                                | CodeGenerationPass :      @SkipGlobals
1446:                            ]
1454:                 | nRule :  @RuleRedefinition(i)    % Probably body of fwd declared rule
1463:                 | * :      #eNotRuleOrGlobalDefn  >> true  % True to skip to next
1475:             ]
1475:     ]
      
1483:     >> true
1487:     ;
      
      
      % Skip a rule body during first pass (may begin with ':', or may not be a body)
1487: SkipRule:
1489:     {[
1489:         | ';' : >
1493:         | * :   ?
1499:     ]};
      
      %   Define the parameters, and possibly the body, of a rule
      %   that has not been defined previously.
      %   Just parsed ident of rule.
      
1502: RuleDefinition:
1504:     Node  r
1504:     Node  s
1504:     Node  t
      
1504:     oDocNewRule
      
1505:     r = oNodeNew(nRule)  oNodeSetInt(r, qIdent, LAST_ID)
1526:     CurrentRule = r
      
      
1532:     oScopeBegin (s)                 % param scope
1538:     @FormalParamDefinition(s)
1545:     oNodeSet (r, qParamScope, s)    % leave scope open, to access params during rule
      
1557:     [ | '>>':   pIdent  @LookupType(t)  oNodeSet (r, qType, t)
1580:       | * :
1585:     ]
      
1585:     [ CurrentPass
1588:         | CollectDefinitionsPass :
1589:             @SkipRule
1591:         | CodeGenerationPass :
1593:             [
1593:                 | ':' :  @RuleBodyDefinition (r)
1602:                 | * :    % No body; a forward declaration of the rule.
1607:             ]
1607:             ';'
1609:     ]
      
      
1617:     oScopeEnd            % parameters scope (already linked to nRule above)
      
1618:     oScopeDeclare (r)    % declare nRule
                               % (Note, can't call rule recursively since not defined until end)
1625:     ;
      
      
      % Given the nRule node
      
1625: RuleBodyDefinition (Node r):
1627:     Node  s
      
1627:     oNodeSetInt (r, qValue, Here)      % Address of rule is now defined
1638:     oNodeSetBoolean (r, qAddrDefined, yes)
      
1650:     oScopeBegin (s)       % rule variables scope
      
1656:     NumLocals = 0
      
1662:     .iLocalSpace 
1664:     RuleLocalSpaceAddr = Here   .iSpace
      
1671:     {[ @Statement
1674:         | true:
1675:         | *:  >
1682:     ]}
      
1684:     .iReturn
      
1686:     oPatch (RuleLocalSpaceAddr, NumLocals)
      
1695:     oScopeEnd            % rule variables scope
1696:     oNodeSet (r, qScope, s)
      
1709:     ;
      
      
      %   Redefine a rule (to provide body of a forward-declared rule).
      %   Given the existing nRule declaration.
      
1709: RuleRedefinition (Node r):
1711:     Node  s, p
1711:     Node  t, t2
      
1711:     [ oNodeGetBoolean (r, qAddrDefined)
1721:         | yes :   #eRuleBodyAlreadyDeclared  >>
1725:         | * :
1730:     ]
      
1730:     oDocNewRule
      
1731:     CurrentRule = r
      
1737:     s = oNodeGet(r, qParamScope)
1750:     oScopeOpen (s)   % Make the existing parameters visible.
                           % (Actually, probably don't want to do this).
      
1756:     @FormalParamRedefinition (s)   % verify types, update param names
      
          % Verify return type matches previous declaration/usage
1763:     t = oNodeGet (r, qType)
1776:     [ | '>>':   pIdent  @LookupType(t2)  @RequireMatchType(t, t2)
1797:       | * :     @RequireMatchType(t, Null)
1812:     ]
      
1812:     [ CurrentPass
1815:         | CollectDefinitionsPass :
1816:             @SkipRule
1818:         | CodeGenerationPass :
1820:             [
1820:                 | ':' :  @RuleBodyDefinition (r)
1829:                 | * :    % No body; a forward declaration of the rule.
1834:             ]
1834:             ';'
1836:     ]
      
1844:     oScopeEnd            % parameters scope (already linked to nRule)
1846:     ;
      
      % ------------------------- Statements -----------------------
      
      %  Returns true if statement found
      
1846: Statement >> boolean:
1848:     Node  i
1848:     Node  t, t2
1848:     Node  s
      
1848:     [
1848:         | pStrLit:           % input alias
1850:             oShortFormLookup(i)  @RequireInput(i)
1863:             .iInput @EmitValue(i)
      
1872:         | pIdent:            % input or operation
1874:             oScopeFindRequire(i)
1880:             [ oNodeType(i)
      
      %  | nInput:      .iInput @EmitValue(i)
      
1887:                 | nOperation:  @RequireNoType(i) @CallOperation(i)
      
1902:                 | nType:       @DeclareLocals(i)
      
1911:                 | nValue:      @RequireInput(i)
1920:                                .iInput @EmitValue(i)
      
1929:                 | *:           @Assignment(i)
1945:             ]
      
1945: 	| '#':
1947:             pIdent  @LookupError(i)
1956:             .iError @EmitValue(i)
      
1965: 	| '.':
1967: 	    [ | pIdent:    @LookupOutput(i)
1976:               | pStrLit:   oShortFormLookup(i) @RequireOutput(i)
1991:             ]
1999:             .iEmit @EmitValue(i)
      
2008: 	| '@':
2010: 	    pIdent
2012:             [ oScopeFind(i)
2019:                 | true :
2020:                     @RequireRule(i)  @RequireNoType(i)
2034:                     @CallRule(i)
      
2041:                 | false :
2043:                     @CallUndefinedRule
2045:             ]
      
2053: 	| '>>':
2055:             t = oNodeGet (CurrentRule, qType)
2068: 	    [ oNodeNull(t)
2075:                 | true :
2076:                 | * :       @Expr(t2)  @RequireMatchType(t, t2)
2098:             ]
2098:             .iReturn
      
2100: 	| '{':
2102:             oScopeBegin( s )
2108:             oPatchPushHere (patchLoop)
2114:             oPatchMark (patchBreak)
2120: 	    {[ @Statement
2123: 		| true:
2124: 		| *:  >
2131: 	    ]}
2133: 	    '}'
2135:             .iJumpBack
2137:             oPatchPopBack (patchLoop)
      
                  % Fix up break statements
2143:             {[ oPatchAtMark (patchBreak)
2150:                 | false :    oPatchPopFwd (patchBreak)
2157:                 | * :        >
2164:             ]}
2166:             oScopeEnd
      
2167: 	| '>':
2169:             [ oPatchAnyEntries (patchLoop)
2176:                 | false:  #eNotInLoop
2179:                 | *:
2184:             ]
2184:             .iJumpForward  oPatchPushHere (patchBreak)  .iSpace
      
2194: 	| '?':  .iInputAny
      
2198: 	| '[':  @Choice
      
2202:         | *:    >> false    % Not a statement
2228:     ]
2228:     >> true ;
      
      
      %  Given nOperation
      
2232: CallOperation (Node o):
2234:     int  num_params
      
2234:     num_params = @ActualParams (o)
      
2245:     @EmitValue(o)        % call operation
      
2252:     [ equal_zero (num_params)
2259:         | true :
2260:         | false :     .iPop oEmitInt(num_params)
2270:     ]
2279:     ;
      
      
      %  Given nOperation or nRule.  Returns number of parameters.
      
2279: ActualParams (Node r) >> int:
      
2281:     int   num_params
2281:     Node  param_scope, p
2281:     Node  t, t2
      
2281:     param_scope = oNodeGet (r, qParamScope)  % Always present, but might contain no nParams
2294:     NodeIter it = oNodeGetIter( param_scope, qDecls )
2307:     p = oNodeIterValue( it )
      
2317:     [ oNodeNull( p )
      
2324:         | true :    >> 0
2328:         | false :
2330:     ]
      
2338:     num_params = 0
      
2344:     '('
      
2346:     {
2346:         inc (num_params)
      
              %  ----------------------------
      
              %  One actual parameter.
      
2352:         t = oNodeGet (p, qType)    % formal param type
      
2365:         [ oNodeType(p)
2372:             | nInParam :                @Expr (t2)
2380:             | nOutParam, nInOutParam :  @Lvalue (t2)
2389:         ]
              
2399:         @RequireMatchType (t, t2)
2409:         .iPushResult
      
              %  ----------------------------
      
2411:         oNodeIterNext( it )
2417:         p = oNodeIterValue( it )
      
2427:         [ oNodeNull (p)
2434:             | true :   >
2437:             | false :
2439:         ]
      
2447:         ','
2449:     }
      
2451:     ')'
      
2453:     >> num_params
2457:     ;
      
      
      
      %  Called for a nRule whose parameter types are defined.
      %  The rule address might not yet be known.
      
2457: CallRule (Node r):
2459:     int  num_params
      
2459:     num_params = @ActualParams(r)
      
2470:     [ oNodeGetBoolean (r, qAddrDefined)     % A call to a forward-declared rule?
2480:         | yes :   .iCall @EmitValue(r)
2490:         | no :    .iCall oPatchPushHere(patchCall) 
2500:                          oPatchPushInt (patchCall, oNodeGetInt(r, qIdent))
2516:                          .iSpace
2518:     ]
      
          % Pop actual params
2526:     [ equal_zero (num_params)
2533:         | true :
2534:         | false :     .iPop oEmitInt(num_params)
2544:     ]
2553:     ;
      
      
      %  Implicitly declare a rule that has not previously been declared.
      %  Rule name is last accepted identifier.
      %  Implicitly declares InParam parameters, and no return type.
      %
      %  Rule is declared in GlobalScope.
      
2553: CallUndefinedRule:
2555:     Node  r, s, t, p
2555:     int   id, num_params, addr
      
          % Global scope opened so that rule will be declared in it,
          % and so the parameters we declare for the rule will have the
          % correct ParentScope
      
2555:     oScopeOpen (GlobalScope)
      
      
2561:     r = oNodeNew (nRule)  id = LAST_ID  oNodeSetInt (r, qIdent, id)
2588:     oNodeSetBoolean(r, qAddrDefined, false)
      
          % Implicit parameters
      
2600:     oScopeBegin (s)
2606:     oNodeSet (r, qParamScope, s)
      
2618:     num_params = 0
      
2624:     [ | '(' :
      
2626:         {
2626:             @Expr(t)
2633:             .iPushResult
2635:             p = oNodeNew (nInParam)  oNodeSet(p, qType, t)
2657:             oScopeDeclare(p)
2663:             inc(num_params)
      
2669:             [ | ',' :
2671:               | * :   >
2678:             ]
2678:         }
2680:         ')'
      
              % Assign parameter addresses
      
2682:         addr = num_params
2688:         NodeIter it = oNodeGetIter( s, qDecls )
2701:         {
2701:             p = oNodeIterValue( it )
2711:             [ oNodeNull(p)
2718:                 | true :  >
2721:                 | false :
2723:             ]
2731:             oNodeSetInt (p, qAddr, addr)
2743:             dec (addr)
2749:             oNodeIterNext( it )
2755:         }
      
2757:       | * :
2762:     ]
      
2762:     oScopeEnd    % param scope
2763:     oScopeDeclare (r)
      
2769:     oScopeEnd    % GlobalScope
      
      
          % Now call rule
      
2770:     .iCall
2772:     oPatchPushHere (patchCall)
2778:     oPatchPushInt (patchCall, id)
2787:     .iSpace
      
2789:     [ equal_zero (num_params)
2796:         | true :
2797:         | * :     .iPop oEmitInt(num_params)
2810:     ];
      
      
      %  Already parsed pIdent and determined it is not a rule/type/operation/value.
      
2811: Assignment (Node i):
2813:     Node t, t2
2813:     @Lvalue_HaveIdent(i,t)
2823:     .iPushResult
2825:     '='
2827:     @Expr(t2)  @RequireMatchType(t,t2)
2844:     .iAssign
2847:     ;
      
2847: Choice:
2849:     int    num_options    % count the number of options in the choice
2849:     kind   choice_kind    % input choice, expr choice, expr undefined type choice
2849:     Node   choice_type    % type of expr choice
2849:     Node   t
2849:     Node   i
2849:     Node   s
2849:     int    val
      
          %  Determine if this is an input choice or a value choice.
          %  For value choice, determine type of value (if known).
      
2849:     [
2849:         | '|' :
2851:             .iInputChoice   choice_kind = kInput
      
2859:         | * :
2864:             @Expr(choice_type)  .iChoice
      
                  % Expr indicates forward use of undefined rule by returning type Null.
                  % We will indicate this for ourselves by setting kind to kUnknown.
      
2873:             [ oNodeNull(choice_type)
2880:                 | true :    choice_kind = kUnknown   % flag that this is expr choice, unknown type
2887:                 | false:    choice_kind = kType      % flag that this is expr choice, known type
2895:             ]
      
2903:             '|'
2905:     ]
      
2905:     oPatchPushHere (patchChoiceTableAddr)
2911:     .iSpace
      
2913:     oPatchMark (patchChoiceTable)    % build up choice table in this stack
2919:     oPatchMark (patchChoiceExit)     % remember end of each option
2925:     num_options = 0                  % count options
      
2931:     {
2931:         [
2931:             | '*':     % default code (must be last option)
2933:                 ':'
2935:                 @CopyChoiceTable (num_options)
      
2942:                 oScopeBegin( s )
2948:                 {[ @Statement
2951:                     | true :
2952:                     | *: >
2959:                 ]}
2961:                 oScopeEnd
2962:                 ']'
      
                      % Finish up
2964:                 @FixChoiceExits
2966:                 >>
      
2967:             | * :
2972:                 {
2972:                     [ choice_kind
      
2975:                         | kType :         % expr choice
2976:                             val = @Const(t)
2987:                             @RequireMatchType (choice_type, t)
      
2997:                         | kUnknown :      % expr choice, type not known yet
2999:                             val = @Const(choice_type)
      
                                  % NOTE: now that we know type of forward rule in expr, we could update nRule
      
                                  % Now know type
3010:                             choice_kind = kType
      
3016:                         | kInput :        % input choice
3018:                             val = @Const(t)
3029:                             @RequireMatchTokenType(t)
3036:                     ]
      
3046:                     oPatchPushHere (patchChoiceTable)
3052:                     oPatchPushInt  (patchChoiceTable, val)
3061:                     inc (num_options)
      
3067:                     [
3067:                         | ':' :   >
3071:                         | ',' :
3073:                     ]
3081:                 }
3083:         ]
      
              % Code for this option:
3083:         oScopeBegin( s )
3089:         {[ @Statement
3092:             | true:
3093:             | *:  >
3100:         ]}
3102:         oScopeEnd
3103:         [
3103:             | ']' :     % end of choice, no default
3105:                 .iJumpForward
3107:                 oPatchPushHere (patchChoiceExit) .iSpace
3115:                 @CopyChoiceTable (num_options)
      
3122:                 .iEndChoice
      
3124:                 @FixChoiceExits
3126:                 >>
      
3127:             | '|' :     % more options follow
3129:                 .iJumpForward
3131:                 oPatchPushHere (patchChoiceExit) .iSpace
3139:         ]
3147:     };
      
      
      %  Install choice table here, given number of options.
      %  Order of options is opposite that in the source (note for error recovery)
      
3150: CopyChoiceTable (int num_options):
3152:     oPatchPopFwd (patchChoiceTableAddr)    % fix pointer to table
3158:     oEmitInt (num_options)                 % # table entries
3164:     {[ oPatchAtMark (patchChoiceTable)
3171:         | false :
3172:             oPatchPopValue (patchChoiceTable)
3178:             oPatchPopBack (patchChoiceTable)
3184:         | * :   >
3191:     ]};
          
      % Fix jumps from end of each option to end of choice
      
3194: FixChoiceExits:
3196:     {[ oPatchAtMark (patchChoiceExit)
3203:         | false:    oPatchPopFwd (patchChoiceExit)
3210:         | *:        >
3217:     ]};
      
3220: FixForwardCalls:
3222:     {[ oPatchAnyEntries (patchCall)
3229:         | true :    oPatchPopCall (patchCall)
3236:         | * :       >
3243:     ]};
      
      % Ensure that there are no rules referenced but never declared
3246: VerifyAllRulesDeclared:
3248:     NodeIter it = oNodeGetIter( GlobalScope, qDecls )
3261:     {
3261:         Node n = oNodeIterValue( it )
3271:         [ oNodeNull(n)
3278:             | true : >
3281:             | false :
3283:         ]
      
3291:         [ oNodeType(n)
3298:             | nRule :
3299:                 [ oNodeGetBoolean (n, qAddrDefined)
3309:                     | false :   oUndeclaredRule(oNodeGetInt(n, qIdent))
3323:                     | * :
3328:                 ]
3328:             | * :
3333:         ]
      
3333:         oNodeIterNext( it )
3339:     };
      
      %  ------------------------------------------------------- 
      
      %  Emits code for expression (with result in ssl_result).
      %  Returns nType of expression.
      
3342: Expr (out Node t):
3344:     Node  i
3344:     [
3344:         | pIdent :
      
3346:             [ oScopeFind (i)
3353:                 | true :
3354:                     [ oNodeType (i)
3361:                         | nRule :        oWarning(wRuleMissingAtSign) @CallRule(i)
3375:                         | nOperation :   @CallOperation(i)
3384:                         | nValue :       .iSetResult    @EmitValue(i)
3395:                         | nInParam :     .iGetParam     @EmitAddr(i)
3406:                         | nOutParam :    .iGetFromParam @EmitAddr(i)
3417:                         | nInOutParam :  .iGetFromParam @EmitAddr(i)
3428:                         | nLocal :       .iGetLocal     @EmitAddr(i)
3439:                         | nGlobal :      .iGetGlobal    @EmitAddr(i)
3450:                         | * : #eIdentNotAllowedInExpr
3471:                     ]
      
3471:                     t = oNodeGet (i, qType)         % Get type of identifier
3484:                     [ oNodeNull(t)
3491:                         | true:  #eNotTyped   % e.g. call with no return value
3494:                         | * :
3499:                     ]
      
3499:                 | false :
3501:                     t = Null  #eUndeclaredIdentifier
3509:             ]
      
3517:         | '@' :
3519: 	    pIdent
3521:             [ oScopeFind (i)
3528:                 | true :
3529:                     @RequireRule(i) @CallRule(i)
3543:                     t = oNodeGet (i, qType)
3556:                     [ oNodeNull (t)
3563:                         | true:  #eNotTyped   % e.g. call with no return value
3566:                         | * :
3571:                     ]
      
3571:                 | false :
                          % Call before defined.  Limited use in this case.
                          % The nType pushed will be NULL.  We don't know the real type.
                          % This is really just allowed so we can have simple rules in a Choice expression.
      
3573:                     @CallUndefinedRule
3575:                     t = Null
3581:             ]
      
3589:         | '-' :
3591:             pIntLit   .iSetResult  oEmitInt(negate(TOKEN_VALUE))
3604:             t = IntType
3610:         | pIntLit :
3612:             .iSetResult  oEmitInt(TOKEN_VALUE)
3619:             t = IntType
3625:     ];
      
      %  Emits code for lvalue (putting address of variable in ssl_result).
      %  Returns nType of the referenced value.
      
3638: Lvalue (out Node t):
3640:     Node i
3640:     [
3640:         | pIdent :
      
3642:             [ oScopeFind(i)
3649:                 | true :      @Lvalue_HaveIdent(i,t)
      
3660:                 | false :     % a forward use of rule, illegal as lvalue
3662:                     t = Null  #eIllegalLvalue
3670:             ]
      
3678:         | '-' :   pIntLit     t = Null    #eIllegalLvalue
3690:         | pIntLit :           t = Null    #eIllegalLvalue
3700:     ];
      
      %  Emit code for lvalue, given nDeclaration of identifier.
      %  Return lvalue's nType
      
3711: Lvalue_HaveIdent (Node i, out Node t):
3713:     [ oNodeType(i)
3720:         | nInParam :     .iGetAddrParam  @EmitAddr(i)
3730:         | nOutParam :    .iGetParam      @EmitAddr(i)
3741:         | nInOutParam :  .iGetParam      @EmitAddr(i)
3752:         | nLocal :       .iGetAddrLocal  @EmitAddr(i)
3763:         | nGlobal :      .iGetAddrGlobal @EmitAddr(i)
3774:         | * : #eIllegalLvalue
3789:     ]
3789:     t = oNodeGet (i, qType)         % Get type of identifier
3803:     ;
      
      %  Return a constant value.  Also return the type of the value.
      %  No code is generated.
      
3803: Const (out Node t) >> int:
3805:     Node  i
3805:     int   val
3805:     [
3805:         | pIdent :
3807:             @LookupValue (i)
3814:             val = oNodeGetInt (i, qValue)
3827:             t = oNodeGet (i, qType)
3840:         | '-' :
3842:             pIntLit
3844:             val = negate(TOKEN_VALUE)
3853:             t = IntType
3859:         | pIntLit :
3861:             val = TOKEN_VALUE
3866:             t = IntType
3872:         | pStrLit :
3874:             oShortFormLookup (i)
3880:             val = oNodeGetInt (i, qValue)
3893:             t = oNodeGet (i, qType)
3906:     ]
3918:     >> val;
      
      %  Return integer constant.  Only values of type "int" are
      %  permitted.  No code is generated.
      
3922: IntConst >> int:
3924:     Node t
3924:     int  i
3924:     i = @Const (t)  @RequireMatchIntType (t)
3942:     >> i;
      
      %  ------------------------------------------------------- 
      
      %  Assert that the ident we just read is a particular kind of
      %  identifier.  Return the declaration node of the identifier.
      
3946: LookupType (out Node i):
3948:     oScopeFindRequire (i)
3954:     @RequireType (i);
      
3962: LookupInput (out Node i):
3964:     oScopeFindRequire (i)
3970:     @RequireInput (i);
      
3978: LookupOutput (out Node i):
3980:     oScopeFindRequire (i)
3986:     @RequireOutput (i);
      
3994: LookupValue (out Node i):
3996:     oScopeFindRequire (i)
4002:     @RequireValue (i);
      
4010: LookupError (out Node i):
4012:     oScopeFindRequire (i)
4018:     @RequireError (i);
      
      %  Assert that the given nDeclaration represents a particular
      %  kind of declaration.
      
4026: RequireType (Node i):
4028:     [ oNodeType(i)
4035:         | nType :
4036:         | * :    #eNotAType
4043:     ];
      
      %  Ensure that value is an input token (value of type "token")
4044: RequireInput (Node i):
4046:     [ oNodeEqual(oNodeGet(i, qType), TokenType)
4063:         | true :
4064:         | * :    #eNotInput
4071:     ];
      
4072: RequireOutput (Node i):
4074:     [ oNodeType(i)
4081:         | nOutput :
4082:         | * :    #eNotOutput
4089:     ];
      
4090: RequireValue (Node i):
4092:     [ oNodeType(i)
4099:         | nValue :
4100:         | * :    #eNotAValue
4107:     ];
      
4108: RequireError (Node i):
4110:     [ oNodeType(i)
4117:         | nError :
4118:         | * :    #eNotAnErrSig
4125:     ];
      
4126: RequireRule (Node i):
4128:     [ oNodeType(i)
4135:         | nRule :
4136:         | * :    #eNotARule
4143:     ];
      
      %  Require that rule/operation has no return type
      
4144: RequireNoType (Node r):
4146:     [ oNodeNull (oNodeGet(r, qType))
4160:         | false: oWarning(wReturnValueIgnored)  % #eChoiceOpRuleOutOfPlace
4167:         | * :
4172:     ];
      
      %  Given a value nDeclaration, and a nType.
      %  Ensure that the value symbol has the type nType.
      
4173: RequireMatchValueType (Node v, Node t):
4175:     [ oNodeEqual (oNodeGet(v, qType), t)
4192:         | true :
4193:         | * :    #eWrongType
4200:     ];
      
      
      %  Do two types match?
      
4201: MatchType (Node t1, Node t2) >> boolean:
4203:     >> oNodeEqual (t1, t2);
      
4214: RequireMatchType (Node t1, Node t2):
4216:     [ oNodeEqual (t1, t2)
4226:         | true :
4227:         | * :    #eWrongType
4234:     ];
      
      %  Is the nType "int"?
      
4235: MatchIntType (Node t) >> boolean:
4237:     >> oNodeEqual (t, IntType);
      
4248: RequireMatchIntType (Node t):
4250:     [ oNodeEqual (t, IntType)
4260:         | true :
4261:         | * :     #eWrongType
4268:     ];
      
4269: RequireMatchTokenType (Node t):
4271:     [ oNodeEqual (t, TokenType)
4281:         | true :
4282:         | * :     #eNotInput
4289:     ];
      
      %  ------------------------------------------------------- 
      
      
      %  Emit the value of an identifier declaration, given its nDeclaration
      
4290: EmitValue (Node i):
4292:     oEmitInt (oNodeGetInt(i, qValue));
      
      %  Emit the addr of a variable, given its declaration
      
4306: EmitAddr (Node v):
4308:     oEmitInt (oNodeGetInt(v, qAddr));
      
4322: end
      
4322: 

Generated code:

   0: oGlobalSpace 11
   2: oLocalSpace 0
   4: oCall 10
   6: oResetInput
   7: oCall 72
   9: oReturn
  10: oLocalSpace 0
  12: oGetAddrGlobal 1
  14: oPushResult
  15: oSetResult 0
  17: oAssign
  18: oGetAddrGlobal 10
  20: oPushResult
  21: oScopeBegin
  22: oPop 1
  24: oGetAddrGlobal 9
  26: oPushResult
  27: oSetResult 0
  29: oAssign
  30: oGetAddrGlobal 8
  32: oPushResult
  33: oSetResult 0
  35: oAssign
  36: oGetAddrGlobal 8
  38: oPushResult
  39: oInstallSystemOperations
  40: oPop 1
  42: oGetAddrGlobal 2
  44: oPushResult
  45: oGetAddrGlobal 3
  47: oPushResult
  48: oInstallSystemTypes
  49: oPop 2
  51: oGetAddrGlobal 5
  53: oPushResult
  54: oSetResult 0
  56: oAssign
  57: oCall 126
  59: oChoice 63
  61: oJumpForward 68
  63: Choice Lookup Table
           1     61
  66: oJumpForward 70
  68: oJumpBack 57
  70: oScopeEnd
  71: oReturn
  72: oLocalSpace 0
  74: oGetAddrGlobal 1
  76: oPushResult
  77: oSetResult 1
  79: oAssign
  80: oGetGlobal 10
  82: oPushResult
  83: oScopeOpen
  84: oPop 1
  86: oStartListing
  87: oGetAddrGlobal 5
  89: oPushResult
  90: inc
  91: oPop 1
  93: oEmit 15
  95: oGetGlobal 5
  97: oPushResult
  98: oEmitInt
  99: oPop 1
 101: oCall 126
 103: oChoice 107
 105: oJumpForward 112
 107: Choice Lookup Table
           1    105
 110: oJumpForward 114
 112: oJumpBack 101
 114: oCall 3220
 116: oCall 3246
 118: oScopeEnd
 119: oGetGlobal 10
 121: oPushResult
 122: oWriteTables
 123: oPop 1
 125: oReturn
 126: oLocalSpace 0
 128: oGetGlobal 1
 130: oChoice 234
 132: oInputChoice 171
 134: oCall 259
 136: oJumpForward 191
 138: oCall 269
 140: oJumpForward 191
 142: oCall 298
 144: oJumpForward 191
 146: oCall 327
 148: oJumpForward 191
 150: oCall 350
 152: oJumpForward 191
 154: oCall 433
 156: oJumpForward 191
 158: oCall 439
 160: oJumpForward 191
 162: oCall 488
 164: oJumpForward 191
 166: oSetResult 0
 168: oReturn
 169: oJumpForward 191
 171: Choice Lookup Table
          22    166
          31    162
          29    158
          30    154
          27    150
          28    146
          26    142
          25    138
          24    134
 190: oEndChoice
 191: oJumpForward 240
 193: oInputChoice 212
 195: oCall 244
 197: oJumpForward 232
 199: oCall 433
 201: oJumpForward 232
 203: oCall 488
 205: oJumpForward 232
 207: oSetResult 0
 209: oReturn
 210: oJumpForward 232
 212: Choice Lookup Table
          22    207
          31    203
          30    199
          29    195
          27    195
          28    195
          26    195
          25    195
          24    195
 231: oEndChoice
 232: oJumpForward 240
 234: Choice Lookup Table
           1    193
           0    132
 239: oEndChoice
 240: oSetResult 1
 242: oReturn
 243: oReturn
 244: oLocalSpace 0
 246: oInputChoice 252
 248: oJumpForward 258
 250: oJumpForward 256
 252: Choice Lookup Table
           6    248
 255: oInputAny
 256: oJumpBack 246
 258: oReturn
 259: oLocalSpace 0
 261: oInput 5
 263: oInput 2
 265: oTitleSet
 266: oInput 6
 268: oReturn
 269: oLocalSpace 1
 271: oInput 5
 273: oGetAddrLocal 1
 275: oPushResult
 276: oSetResult 0
 278: oAssign
 279: oSetResult 8
 281: oPushResult
 282: oGetAddrLocal 1
 284: oPushResult
 285: oSetResult 1
 287: oPushResult
 288: oGetGlobal 3
 290: oPushResult
 291: oCall 506
 293: oPop 4
 295: oInput 6
 297: oReturn
 298: oLocalSpace 1
 300: oInput 5
 302: oGetAddrLocal 1
 304: oPushResult
 305: oSetResult 0
 307: oAssign
 308: oSetResult 5
 310: oPushResult
 311: oGetAddrLocal 1
 313: oPushResult
 314: oSetResult 1
 316: oPushResult
 317: oSetResult 0
 319: oPushResult
 320: oCall 506
 322: oPop 4
 324: oInput 6
 326: oReturn
 327: oLocalSpace 0
 329: oInput 5
 331: oSetResult 6
 333: oPushResult
 334: oGetAddrGlobal 9
 336: oPushResult
 337: oSetResult 0
 339: oPushResult
 340: oSetResult 0
 342: oPushResult
 343: oCall 506
 345: oPop 4
 347: oInput 6
 349: oReturn
 350: oLocalSpace 2
 352: oInput 0
 354: oGetAddrLocal 1
 356: oPushResult
 357: oScopeFind
 358: oPop 1
 360: oChoice 400
 362: oGetAddrLocal 1
 364: oPushResult
 365: oSetResult 7
 367: oPushResult
 368: oNodeNew
 369: oPop 1
 371: oAssign
 372: oGetLocal 1
 374: oPushResult
 375: oSetResult 3
 377: oPushResult
 378: LAST_ID
 379: oPushResult
 380: oNodeSetInt
 381: oPop 3
 383: oGetLocal 1
 385: oPushResult
 386: oScopeDeclare
 387: oPop 1
 389: oJumpForward 406
 391: oGetLocal 1
 393: oPushResult
 394: oCall 4026
 396: oPop 1
 398: oJumpForward 406
 400: Choice Lookup Table
           1    391
           0    362
 405: oEndChoice
 406: oInput 5
 408: oGetAddrLocal 2
 410: oPushResult
 411: oSetResult 0
 413: oAssign
 414: oSetResult 8
 416: oPushResult
 417: oGetAddrLocal 2
 419: oPushResult
 420: oSetResult 0
 422: oPushResult
 423: oGetLocal 1
 425: oPushResult
 426: oCall 506
 428: oPop 4
 430: oInput 6
 432: oReturn
 433: oLocalSpace 0
 435: oInput 2
 437: oInclude
 438: oReturn
 439: oLocalSpace 1
 441: oInput 0
 443: oGetAddrLocal 1
 445: oPushResult
 446: oSetResult 9
 448: oPushResult
 449: oNodeNew
 450: oPop 1
 452: oAssign
 453: oGetLocal 1
 455: oPushResult
 456: oSetResult 3
 458: oPushResult
 459: LAST_ID
 460: oPushResult
 461: oNodeSetInt
 462: oPop 3
 464: oGetLocal 1
 466: oPushResult
 467: oScopeDeclare
 468: oPop 1
 470: oInput 5
 472: oCall 1275
 474: oChoice 478
 476: oJumpForward 483
 478: Choice Lookup Table
           1    476
 481: oJumpForward 485
 483: oJumpBack 472
 485: oInput 6
 487: oReturn
 488: oLocalSpace 0
 490: oCall 1390
 492: oChoice 496
 494: oJumpForward 501
 496: Choice Lookup Table
           1    494
 499: oJumpForward 503
 501: oJumpBack 490
 503: oInput 32
 505: oReturn
 506: oLocalSpace 2
 508: oInputChoice 649
 510: oGetAddrLocal 1
 512: oPushResult
 513: oGetParam 4
 515: oPushResult
 516: oNodeNew
 517: oPop 1
 519: oAssign
 520: oGetLocal 1
 522: oPushResult
 523: oSetResult 3
 525: oPushResult
 526: LAST_ID
 527: oPushResult
 528: oNodeSetInt
 529: oPop 3
 531: oGetParam 4
 533: oChoice 549
 535: oGetLocal 1
 537: oPushResult
 538: oSetResult 5
 540: oPushResult
 541: oGetParam 1
 543: oPushResult
 544: oNodeSet
 545: oPop 3
 547: oJumpForward 552
 549: Choice Lookup Table
           8    535
 552: oInputChoice 573
 554: oGetParam 2
 556: oChoice 566
 558: oGetLocal 1
 560: oPushResult
 561: oShortFormAdd
 562: oPop 1
 564: oJumpForward 571
 566: Choice Lookup Table
           1    558
 569: oError 18
 571: oJumpForward 576
 573: Choice Lookup Table
           2    554
 576: oInputChoice 620
 578: oGetParam 3
 580: oPushResult
 581: oGetAddrLocal 2
 583: oPushResult
 584: oCall 3803
 586: oPop 1
 588: oAssign
 589: oGetParam 1
 591: oPushResult
 592: oGetLocal 2
 594: oPushResult
 595: oCall 4201
 597: oPop 2
 599: oChoice 612
 601: oJumpForward 618
 603: oGetLocal 2
 605: oPushResult
 606: oCall 4248
 608: oPop 1
 610: oJumpForward 618
 612: Choice Lookup Table
           0    603
           1    601
 617: oEndChoice
 618: oJumpForward 623
 620: Choice Lookup Table
           4    578
 623: oGetLocal 1
 625: oPushResult
 626: oSetResult 4
 628: oPushResult
 629: oGetFromParam 3
 631: oPushResult
 632: oNodeSetInt
 633: oPop 3
 635: oGetParam 3
 637: oPushResult
 638: inc
 639: oPop 1
 641: oGetLocal 1
 643: oPushResult
 644: oScopeDeclare
 645: oPop 1
 647: oJumpForward 654
 649: Choice Lookup Table
           0    510
 652: oJumpForward 656
 654: oJumpBack 508
 656: oReturn
 657: oLocalSpace 3
 659: oInput 0
 661: oGetAddrLocal 1
 663: oPushResult
 664: oGetParam 3
 666: oPushResult
 667: oNodeNew
 668: oPop 1
 670: oAssign
 671: oGetLocal 1
 673: oPushResult
 674: oSetResult 3
 676: oPushResult
 677: LAST_ID
 678: oPushResult
 679: oNodeSetInt
 680: oPop 3
 682: oGetLocal 1
 684: oPushResult
 685: oSetResult 5
 687: oPushResult
 688: oGetParam 2
 690: oPushResult
 691: oNodeSet
 692: oPop 3
 694: oGetParam 1
 696: oPushResult
 697: inc
 698: oPop 1
 700: oGetLocal 1
 702: oPushResult
 703: oSetResult 10
 705: oPushResult
 706: oGetFromParam 1
 708: oPushResult
 709: oNodeSetInt
 710: oPop 3
 712: oScopeFindInCurrentScope
 713: oPushResult
 714: oNodeNull
 715: oPop 1
 717: oChoice 723
 719: oError 20
 721: oJumpForward 726
 723: Choice Lookup Table
           0    719
 726: oGetLocal 1
 728: oPushResult
 729: oScopeDeclare
 730: oPop 1
 732: oInputChoice 778
 734: oGetParam 3
 736: oChoice 742
 738: oError 19
 740: oJumpForward 745
 742: Choice Lookup Table
          18    738
 745: oGetLocal 1
 747: oPushResult
 748: oGetAddrLocal 2
 750: oPushResult
 751: oCall 3711
 753: oPop 2
 755: oEmit 12
 757: oGetAddrLocal 3
 759: oPushResult
 760: oCall 3342
 762: oPop 1
 764: oGetLocal 2
 766: oPushResult
 767: oGetLocal 3
 769: oPushResult
 770: oCall 4214
 772: oPop 2
 774: oEmit 24
 776: oJumpForward 781
 778: Choice Lookup Table
           4    734
 781: oInputChoice 785
 783: oJumpForward 790
 785: Choice Lookup Table
           7    783
 788: oJumpForward 792
 790: oJumpBack 659
 792: oReturn
 793: oLocalSpace 0
 795: oSetResult 18
 797: oPushResult
 798: oGetParam 1
 800: oPushResult
 801: oGetAddrGlobal 5
 803: oPushResult
 804: oCall 657
 806: oPop 3
 808: oReturn
 809: oLocalSpace 0
 811: oSetResult 17
 813: oPushResult
 814: oGetParam 1
 816: oPushResult
 817: oGetAddrGlobal 6
 819: oPushResult
 820: oCall 657
 822: oPop 3
 824: oReturn
 825: oLocalSpace 0
 827: oInput 0
 829: oInputChoice 833
 831: oJumpForward 838
 833: Choice Lookup Table
           7    831
 836: oJumpForward 840
 838: oJumpBack 827
 840: oReturn
 841: oLocalSpace 5
 843: oInputChoice 847
 845: oJumpForward 851
 847: Choice Lookup Table
           8    845
 850: oReturn
 851: oGetAddrLocal 1
 853: oPushResult
 854: oSetResult 0
 856: oAssign
 857: oGetAddrLocal 1
 859: oPushResult
 860: inc
 861: oPop 1
 863: oInputChoice 889
 865: oGetAddrLocal 2
 867: oPushResult
 868: oSetResult 14
 870: oAssign
 871: oJumpForward 902
 873: oGetAddrLocal 2
 875: oPushResult
 876: oSetResult 15
 878: oAssign
 879: oJumpForward 902
 881: oGetAddrLocal 2
 883: oPushResult
 884: oSetResult 16
 886: oAssign
 887: oJumpForward 902
 889: Choice Lookup Table
          35    881
          34    873
          33    865
 896: oGetAddrLocal 2
 898: oPushResult
 899: oSetResult 14
 901: oAssign
 902: oInput 0
 904: oGetAddrLocal 4
 906: oPushResult
 907: oCall 3946
 909: oPop 1
 911: oGetAddrLocal 3
 913: oPushResult
 914: oGetLocal 2
 916: oPushResult
 917: oNodeNew
 918: oPop 1
 920: oAssign
 921: oGetLocal 3
 923: oPushResult
 924: oSetResult 5
 926: oPushResult
 927: oGetLocal 4
 929: oPushResult
 930: oNodeSet
 931: oPop 3
 933: oInputChoice 948
 935: oGetLocal 3
 937: oPushResult
 938: oSetResult 3
 940: oPushResult
 941: LAST_ID
 942: oPushResult
 943: oNodeSetInt
 944: oPop 3
 946: oJumpForward 951
 948: Choice Lookup Table
           0    935
 951: oGetLocal 3
 953: oPushResult
 954: oScopeDeclare
 955: oPop 1
 957: oInputChoice 961
 959: oJumpForward 966
 961: Choice Lookup Table
           7    959
 964: oJumpForward 968
 966: oJumpBack 857
 968: oInput 9
 970: oGetAddrLocal 5
 972: oPushResult
 973: oGetParam 1
 975: oPushResult
 976: oSetResult 2
 978: oPushResult
 979: oNodeGetIter
 980: oPop 2
 982: oAssign
 983: oGetAddrLocal 3
 985: oPushResult
 986: oGetLocal 5
 988: oPushResult
 989: oNodeIterValue
 990: oPop 1
 992: oAssign
 993: oGetLocal 3
 995: oPushResult
 996: oNodeNull
 997: oPop 1
 999: oChoice 1003
1001: oJumpForward 1008
1003: Choice Lookup Table
           0   1001
1006: oJumpForward 1034
1008: oGetLocal 3
1010: oPushResult
1011: oSetResult 10
1013: oPushResult
1014: oGetLocal 1
1016: oPushResult
1017: oNodeSetInt
1018: oPop 3
1020: oGetAddrLocal 1
1022: oPushResult
1023: dec
1024: oPop 1
1026: oGetAddrLocal 5
1028: oPushResult
1029: oNodeIterNext
1030: oPop 1
1032: oJumpBack 983
1034: oReturn
1035: oLocalSpace 6
1037: oGetAddrLocal 6
1039: oPushResult
1040: oGetParam 1
1042: oPushResult
1043: oSetResult 2
1045: oPushResult
1046: oNodeGetIter
1047: oPop 2
1049: oAssign
1050: oInputChoice 1054
1052: oJumpForward 1077
1054: Choice Lookup Table
           8   1052
1057: oGetLocal 6
1059: oPushResult
1060: oNodeIterValue
1061: oPop 1
1063: oPushResult
1064: oNodeNull
1065: oPop 1
1067: oChoice 1071
1069: oJumpForward 1076
1071: Choice Lookup Table
           1   1069
1074: oError 16
1076: oReturn
1077: oGetAddrLocal 1
1079: oPushResult
1080: oGetLocal 6
1082: oPushResult
1083: oNodeIterValue
1084: oPop 1
1086: oAssign
1087: oGetLocal 1
1089: oPushResult
1090: oNodeNull
1091: oPop 1
1093: oChoice 1101
1095: oError 16
1097: oJumpForward 1107
1099: oJumpForward 1107
1101: Choice Lookup Table
           0   1099
           1   1095
1106: oEndChoice
1107: oGetAddrLocal 2
1109: oPushResult
1110: oGetLocal 1
1112: oPushResult
1113: oNodeType
1114: oPop 1
1116: oAssign
1117: oInputChoice 1143
1119: oGetAddrLocal 3
1121: oPushResult
1122: oSetResult 14
1124: oAssign
1125: oJumpForward 1156
1127: oGetAddrLocal 3
1129: oPushResult
1130: oSetResult 15
1132: oAssign
1133: oJumpForward 1156
1135: oGetAddrLocal 3
1137: oPushResult
1138: oSetResult 16
1140: oAssign
1141: oJumpForward 1156
1143: Choice Lookup Table
          35   1135
          34   1127
          33   1119
1150: oGetAddrLocal 3
1152: oPushResult
1153: oSetResult 14
1155: oAssign
1156: oGetLocal 2
1158: oPushResult
1159: oGetLocal 3
1161: oPushResult
1162: equal_node_type
1163: oPop 2
1165: oChoice 1169
1167: oJumpForward 1174
1169: Choice Lookup Table
           1   1167
1172: oError 16
1174: oGetAddrLocal 4
1176: oPushResult
1177: oGetLocal 1
1179: oPushResult
1180: oSetResult 5
1182: oPushResult
1183: oNodeGet
1184: oPop 2
1186: oAssign
1187: oInput 0
1189: oGetAddrLocal 5
1191: oPushResult
1192: oCall 3946
1194: oPop 1
1196: oGetLocal 4
1198: oPushResult
1199: oGetLocal 5
1201: oPushResult
1202: oCall 4214
1204: oPop 2
1206: oInputChoice 1221
1208: oGetLocal 1
1210: oPushResult
1211: oSetResult 3
1213: oPushResult
1214: LAST_ID
1215: oPushResult
1216: oNodeSetInt
1217: oPop 3
1219: oJumpForward 1236
1221: Choice Lookup Table
           0   1208
1224: oGetLocal 1
1226: oPushResult
1227: oSetResult 3
1229: oPushResult
1230: oSetResult 0
1232: oPushResult
1233: oNodeSetInt
1234: oPop 3
1236: oGetAddrLocal 6
1238: oPushResult
1239: oNodeIterNext
1240: oPop 1
1242: oInputChoice 1246
1244: oJumpForward 1251
1246: Choice Lookup Table
           7   1244
1249: oJumpForward 1253
1251: oJumpBack 1077
1253: oInput 9
1255: oGetLocal 6
1257: oPushResult
1258: oNodeIterValue
1259: oPop 1
1261: oPushResult
1262: oNodeNull
1263: oPop 1
1265: oChoice 1269
1267: oJumpForward 1274
1269: Choice Lookup Table
           1   1267
1272: oError 16
1274: oReturn
1275: oLocalSpace 3
1277: oInputChoice 1281
1279: oJumpForward 1287
1281: Choice Lookup Table
           0   1279
1284: oSetResult 0
1286: oReturn
1287: oGetAddrLocal 1
1289: oPushResult
1290: oSetResult 10
1292: oPushResult
1293: oNodeNew
1294: oPop 1
1296: oAssign
1297: oGetLocal 1
1299: oPushResult
1300: oSetResult 3
1302: oPushResult
1303: LAST_ID
1304: oPushResult
1305: oNodeSetInt
1306: oPop 3
1308: oGetLocal 1
1310: oPushResult
1311: oSetResult 4
1313: oPushResult
1314: oGetGlobal 8
1316: oPushResult
1317: oNodeSetInt
1318: oPop 3
1320: oGetAddrGlobal 8
1322: oPushResult
1323: inc
1324: oPop 1
1326: oGetAddrLocal 2
1328: oPushResult
1329: oScopeBegin
1330: oPop 1
1332: oGetLocal 2
1334: oPushResult
1335: oCall 841
1337: oPop 1
1339: oGetLocal 1
1341: oPushResult
1342: oSetResult 6
1344: oPushResult
1345: oGetLocal 2
1347: oPushResult
1348: oNodeSet
1349: oPop 3
1351: oInputChoice 1376
1353: oInput 0
1355: oGetAddrLocal 3
1357: oPushResult
1358: oCall 3946
1360: oPop 1
1362: oGetLocal 1
1364: oPushResult
1365: oSetResult 5
1367: oPushResult
1368: oGetLocal 3
1370: oPushResult
1371: oNodeSet
1372: oPop 3
1374: oJumpForward 1379
1376: Choice Lookup Table
          10   1353
1379: oScopeEnd
1380: oGetLocal 1
1382: oPushResult
1383: oScopeDeclare
1384: oPop 1
1386: oSetResult 1
1388: oReturn
1389: oReturn
1390: oLocalSpace 1
1392: oInputChoice 1403
1394: oCall 433
1396: oSetResult 1
1398: oReturn
1399: oJumpForward 1411
1401: oJumpForward 1411
1403: Choice Lookup Table
           0   1401
          30   1394
1408: oSetResult 0
1410: oReturn
1411: oGetAddrLocal 1
1413: oPushResult
1414: oScopeFind
1415: oPop 1
1417: oChoice 1477
1419: oCall 1502
1421: oJumpForward 1483
1423: oGetLocal 1
1425: oPushResult
1426: oNodeType
1427: oPop 1
1429: oChoice 1465
1431: oGetGlobal 1
1433: oChoice 1448
1435: oGetLocal 1
1437: oPushResult
1438: oCall 793
1440: oPop 1
1442: oJumpForward 1454
1444: oCall 825
1446: oJumpForward 1454
1448: Choice Lookup Table
           1   1444
           0   1435
1453: oEndChoice
1454: oJumpForward 1475
1456: oGetLocal 1
1458: oPushResult
1459: oCall 1709
1461: oPop 1
1463: oJumpForward 1475
1465: Choice Lookup Table
          11   1456
           7   1431
1470: oError 13
1472: oSetResult 1
1474: oReturn
1475: oJumpForward 1483
1477: Choice Lookup Table
           1   1423
           0   1419
1482: oEndChoice
1483: oSetResult 1
1485: oReturn
1486: oReturn
1487: oLocalSpace 0
1489: oInputChoice 1495
1491: oJumpForward 1501
1493: oJumpForward 1499
1495: Choice Lookup Table
           6   1491
1498: oInputAny
1499: oJumpBack 1489
1501: oReturn
1502: oLocalSpace 3
1504: oDocNewRule
1505: oGetAddrLocal 1
1507: oPushResult
1508: oSetResult 11
1510: oPushResult
1511: oNodeNew
1512: oPop 1
1514: oAssign
1515: oGetLocal 1
1517: oPushResult
1518: oSetResult 3
1520: oPushResult
1521: LAST_ID
1522: oPushResult
1523: oNodeSetInt
1524: oPop 3
1526: oGetAddrGlobal 4
1528: oPushResult
1529: oGetLocal 1
1531: oAssign
1532: oGetAddrLocal 2
1534: oPushResult
1535: oScopeBegin
1536: oPop 1
1538: oGetLocal 2
1540: oPushResult
1541: oCall 841
1543: oPop 1
1545: oGetLocal 1
1547: oPushResult
1548: oSetResult 6
1550: oPushResult
1551: oGetLocal 2
1553: oPushResult
1554: oNodeSet
1555: oPop 3
1557: oInputChoice 1582
1559: oInput 0
1561: oGetAddrLocal 3
1563: oPushResult
1564: oCall 3946
1566: oPop 1
1568: oGetLocal 1
1570: oPushResult
1571: oSetResult 5
1573: oPushResult
1574: oGetLocal 3
1576: oPushResult
1577: oNodeSet
1578: oPop 3
1580: oJumpForward 1585
1582: Choice Lookup Table
          10   1559
1585: oGetGlobal 1
1587: oChoice 1611
1589: oCall 1487
1591: oJumpForward 1617
1593: oInputChoice 1604
1595: oGetLocal 1
1597: oPushResult
1598: oCall 1625
1600: oPop 1
1602: oJumpForward 1607
1604: Choice Lookup Table
           5   1595
1607: oInput 6
1609: oJumpForward 1617
1611: Choice Lookup Table
           1   1593
           0   1589
1616: oEndChoice
1617: oScopeEnd
1618: oGetLocal 1
1620: oPushResult
1621: oScopeDeclare
1622: oPop 1
1624: oReturn
1625: oLocalSpace 1
1627: oGetParam 1
1629: oPushResult
1630: oSetResult 4
1632: oPushResult
1633: Here
1634: oPushResult
1635: oNodeSetInt
1636: oPop 3
1638: oGetParam 1
1640: oPushResult
1641: oSetResult 8
1643: oPushResult
1644: oSetResult 1
1646: oPushResult
1647: oNodeSetBoolean
1648: oPop 3
1650: oGetAddrLocal 1
1652: oPushResult
1653: oScopeBegin
1654: oPop 1
1656: oGetAddrGlobal 6
1658: oPushResult
1659: oSetResult 0
1661: oAssign
1662: oEmit 16
1664: oGetAddrGlobal 7
1666: oPushResult
1667: Here
1668: oAssign
1669: oEmit 25
1671: oCall 1846
1673: oChoice 1677
1675: oJumpForward 1682
1677: Choice Lookup Table
           1   1675
1680: oJumpForward 1684
1682: oJumpBack 1671
1684: oEmit 8
1686: oGetGlobal 7
1688: oPushResult
1689: oGetGlobal 6
1691: oPushResult
1692: oPatch
1693: oPop 2
1695: oScopeEnd
1696: oGetParam 1
1698: oPushResult
1699: oSetResult 7
1701: oPushResult
1702: oGetLocal 1
1704: oPushResult
1705: oNodeSet
1706: oPop 3
1708: oReturn
1709: oLocalSpace 4
1711: oGetParam 1
1713: oPushResult
1714: oSetResult 8
1716: oPushResult
1717: oNodeGetBoolean
1718: oPop 2
1720: oChoice 1727
1722: oError 14
1724: oReturn
1725: oJumpForward 1730
1727: Choice Lookup Table
           1   1722
1730: oDocNewRule
1731: oGetAddrGlobal 4
1733: oPushResult
1734: oGetParam 1
1736: oAssign
1737: oGetAddrLocal 1
1739: oPushResult
1740: oGetParam 1
1742: oPushResult
1743: oSetResult 6
1745: oPushResult
1746: oNodeGet
1747: oPop 2
1749: oAssign
1750: oGetLocal 1
1752: oPushResult
1753: oScopeOpen
1754: oPop 1
1756: oGetLocal 1
1758: oPushResult
1759: oCall 1035
1761: oPop 1
1763: oGetAddrLocal 3
1765: oPushResult
1766: oGetParam 1
1768: oPushResult
1769: oSetResult 5
1771: oPushResult
1772: oNodeGet
1773: oPop 2
1775: oAssign
1776: oInputChoice 1799
1778: oInput 0
1780: oGetAddrLocal 4
1782: oPushResult
1783: oCall 3946
1785: oPop 1
1787: oGetLocal 3
1789: oPushResult
1790: oGetLocal 4
1792: oPushResult
1793: oCall 4214
1795: oPop 2
1797: oJumpForward 1812
1799: Choice Lookup Table
          10   1778
1802: oGetLocal 3
1804: oPushResult
1805: oSetResult 0
1807: oPushResult
1808: oCall 4214
1810: oPop 2
1812: oGetGlobal 1
1814: oChoice 1838
1816: oCall 1487
1818: oJumpForward 1844
1820: oInputChoice 1831
1822: oGetParam 1
1824: oPushResult
1825: oCall 1625
1827: oPop 1
1829: oJumpForward 1834
1831: Choice Lookup Table
           5   1822
1834: oInput 6
1836: oJumpForward 1844
1838: Choice Lookup Table
           1   1820
           0   1816
1843: oEndChoice
1844: oScopeEnd
1845: oReturn
1846: oLocalSpace 4
1848: oInputChoice 2204
1850: oGetAddrLocal 1
1852: oPushResult
1853: oShortFormLookup
1854: oPop 1
1856: oGetLocal 1
1858: oPushResult
1859: oCall 4044
1861: oPop 1
1863: oEmit 2
1865: oGetLocal 1
1867: oPushResult
1868: oCall 4290
1870: oPop 1
1872: oJumpForward 2228
1874: oGetAddrLocal 1
1876: oPushResult
1877: oScopeFindRequire
1878: oPop 1
1880: oGetLocal 1
1882: oPushResult
1883: oNodeType
1884: oPop 1
1886: oChoice 1931
1888: oGetLocal 1
1890: oPushResult
1891: oCall 4144
1893: oPop 1
1895: oGetLocal 1
1897: oPushResult
1898: oCall 2232
1900: oPop 1
1902: oJumpForward 1945
1904: oGetLocal 1
1906: oPushResult
1907: oCall 809
1909: oPop 1
1911: oJumpForward 1945
1913: oGetLocal 1
1915: oPushResult
1916: oCall 4044
1918: oPop 1
1920: oEmit 2
1922: oGetLocal 1
1924: oPushResult
1925: oCall 4290
1927: oPop 1
1929: oJumpForward 1945
1931: Choice Lookup Table
           8   1913
           7   1904
          10   1888
1938: oGetLocal 1
1940: oPushResult
1941: oCall 2811
1943: oPop 1
1945: oJumpForward 2228
1947: oInput 0
1949: oGetAddrLocal 1
1951: oPushResult
1952: oCall 4010
1954: oPop 1
1956: oEmit 5
1958: oGetLocal 1
1960: oPushResult
1961: oCall 4290
1963: oPop 1
1965: oJumpForward 2228
1967: oInputChoice 1993
1969: oGetAddrLocal 1
1971: oPushResult
1972: oCall 3978
1974: oPop 1
1976: oJumpForward 1999
1978: oGetAddrLocal 1
1980: oPushResult
1981: oShortFormLookup
1982: oPop 1
1984: oGetLocal 1
1986: oPushResult
1987: oCall 4072
1989: oPop 1
1991: oJumpForward 1999
1993: Choice Lookup Table
           2   1978
           0   1969
1998: oEndChoice
1999: oEmit 4
2001: oGetLocal 1
2003: oPushResult
2004: oCall 4290
2006: oPop 1
2008: oJumpForward 2228
2010: oInput 0
2012: oGetAddrLocal 1
2014: oPushResult
2015: oScopeFind
2016: oPop 1
2018: oChoice 2047
2020: oGetLocal 1
2022: oPushResult
2023: oCall 4126
2025: oPop 1
2027: oGetLocal 1
2029: oPushResult
2030: oCall 4144
2032: oPop 1
2034: oGetLocal 1
2036: oPushResult
2037: oCall 2457
2039: oPop 1
2041: oJumpForward 2053
2043: oCall 2553
2045: oJumpForward 2053
2047: Choice Lookup Table
           0   2043
           1   2020
2052: oEndChoice
2053: oJumpForward 2228
2055: oGetAddrLocal 2
2057: oPushResult
2058: oGetGlobal 4
2060: oPushResult
2061: oSetResult 5
2063: oPushResult
2064: oNodeGet
2065: oPop 2
2067: oAssign
2068: oGetLocal 2
2070: oPushResult
2071: oNodeNull
2072: oPop 1
2074: oChoice 2078
2076: oJumpForward 2098
2078: Choice Lookup Table
           1   2076
2081: oGetAddrLocal 3
2083: oPushResult
2084: oCall 3342
2086: oPop 1
2088: oGetLocal 2
2090: oPushResult
2091: oGetLocal 3
2093: oPushResult
2094: oCall 4214
2096: oPop 2
2098: oEmit 8
2100: oJumpForward 2228
2102: oGetAddrLocal 4
2104: oPushResult
2105: oScopeBegin
2106: oPop 1
2108: oSetResult 4
2110: oPushResult
2111: oPatchPushHere
2112: oPop 1
2114: oSetResult 5
2116: oPushResult
2117: oPatchMark
2118: oPop 1
2120: oCall 1846
2122: oChoice 2126
2124: oJumpForward 2131
2126: Choice Lookup Table
           1   2124
2129: oJumpForward 2133
2131: oJumpBack 2120
2133: oInput 13
2135: oEmit 1
2137: oSetResult 4
2139: oPushResult
2140: oPatchPopBack
2141: oPop 1
2143: oSetResult 5
2145: oPushResult
2146: oPatchAtMark
2147: oPop 1
2149: oChoice 2159
2151: oSetResult 5
2153: oPushResult
2154: oPatchPopFwd
2155: oPop 1
2157: oJumpForward 2164
2159: Choice Lookup Table
           0   2151
2162: oJumpForward 2166
2164: oJumpBack 2143
2166: oScopeEnd
2167: oJumpForward 2228
2169: oSetResult 4
2171: oPushResult
2172: oPatchAnyEntries
2173: oPop 1
2175: oChoice 2181
2177: oError 7
2179: oJumpForward 2184
2181: Choice Lookup Table
           0   2177
2184: oEmit 0
2186: oSetResult 5
2188: oPushResult
2189: oPatchPushHere
2190: oPop 1
2192: oEmit 25
2194: oJumpForward 2228
2196: oEmit 3
2198: oJumpForward 2228
2200: oCall 2847
2202: oJumpForward 2228
2204: Choice Lookup Table
          14   2200
          21   2196
          11   2169
          12   2102
          10   2055
          17   2010
          18   1967
          20   1947
           0   1874
           2   1850
2225: oSetResult 0
2227: oReturn
2228: oSetResult 1
2230: oReturn
2231: oReturn
2232: oLocalSpace 1
2234: oGetAddrLocal 1
2236: oPushResult
2237: oGetParam 1
2239: oPushResult
2240: oCall 2279
2242: oPop 1
2244: oAssign
2245: oGetParam 1
2247: oPushResult
2248: oCall 4290
2250: oPop 1
2252: oGetLocal 1
2254: oPushResult
2255: equal_zero
2256: oPop 1
2258: oChoice 2272
2260: oJumpForward 2278
2262: oEmit 13
2264: oGetLocal 1
2266: oPushResult
2267: oEmitInt
2268: oPop 1
2270: oJumpForward 2278
2272: Choice Lookup Table
           0   2262
           1   2260
2277: oEndChoice
2278: oReturn
2279: oLocalSpace 6
2281: oGetAddrLocal 2
2283: oPushResult
2284: oGetParam 1
2286: oPushResult
2287: oSetResult 6
2289: oPushResult
2290: oNodeGet
2291: oPop 2
2293: oAssign
2294: oGetAddrLocal 6
2296: oPushResult
2297: oGetLocal 2
2299: oPushResult
2300: oSetResult 2
2302: oPushResult
2303: oNodeGetIter
2304: oPop 2
2306: oAssign
2307: oGetAddrLocal 3
2309: oPushResult
2310: oGetLocal 6
2312: oPushResult
2313: oNodeIterValue
2314: oPop 1
2316: oAssign
2317: oGetLocal 3
2319: oPushResult
2320: oNodeNull
2321: oPop 1
2323: oChoice 2332
2325: oSetResult 0
2327: oReturn
2328: oJumpForward 2338
2330: oJumpForward 2338
2332: Choice Lookup Table
           0   2330
           1   2325
2337: oEndChoice
2338: oGetAddrLocal 1
2340: oPushResult
2341: oSetResult 0
2343: oAssign
2344: oInput 8
2346: oGetAddrLocal 1
2348: oPushResult
2349: inc
2350: oPop 1
2352: oGetAddrLocal 4
2354: oPushResult
2355: oGetLocal 3
2357: oPushResult
2358: oSetResult 5
2360: oPushResult
2361: oNodeGet
2362: oPop 2
2364: oAssign
2365: oGetLocal 3
2367: oPushResult
2368: oNodeType
2369: oPop 1
2371: oChoice 2391
2373: oGetAddrLocal 5
2375: oPushResult
2376: oCall 3342
2378: oPop 1
2380: oJumpForward 2399
2382: oGetAddrLocal 5
2384: oPushResult
2385: oCall 3638
2387: oPop 1
2389: oJumpForward 2399
2391: Choice Lookup Table
          16   2382
          15   2382
          14   2373
2398: oEndChoice
2399: oGetLocal 4
2401: oPushResult
2402: oGetLocal 5
2404: oPushResult
2405: oCall 4214
2407: oPop 2
2409: oEmit 12
2411: oGetAddrLocal 6
2413: oPushResult
2414: oNodeIterNext
2415: oPop 1
2417: oGetAddrLocal 3
2419: oPushResult
2420: oGetLocal 6
2422: oPushResult
2423: oNodeIterValue
2424: oPop 1
2426: oAssign
2427: oGetLocal 3
2429: oPushResult
2430: oNodeNull
2431: oPop 1
2433: oChoice 2441
2435: oJumpForward 2451
2437: oJumpForward 2447
2439: oJumpForward 2447
2441: Choice Lookup Table
           0   2439
           1   2435
2446: oEndChoice
2447: oInput 7
2449: oJumpBack 2346
2451: oInput 9
2453: oGetLocal 1
2455: oReturn
2456: oReturn
2457: oLocalSpace 1
2459: oGetAddrLocal 1
2461: oPushResult
2462: oGetParam 1
2464: oPushResult
2465: oCall 2279
2467: oPop 1
2469: oAssign
2470: oGetParam 1
2472: oPushResult
2473: oSetResult 8
2475: oPushResult
2476: oNodeGetBoolean
2477: oPop 2
2479: oChoice 2520
2481: oEmit 7
2483: oGetParam 1
2485: oPushResult
2486: oCall 4290
2488: oPop 1
2490: oJumpForward 2526
2492: oEmit 7
2494: oSetResult 3
2496: oPushResult
2497: oPatchPushHere
2498: oPop 1
2500: oSetResult 3
2502: oPushResult
2503: oGetParam 1
2505: oPushResult
2506: oSetResult 3
2508: oPushResult
2509: oNodeGetInt
2510: oPop 2
2512: oPushResult
2513: oPatchPushInt
2514: oPop 2
2516: oEmit 25
2518: oJumpForward 2526
2520: Choice Lookup Table
           0   2492
           1   2481
2525: oEndChoice
2526: oGetLocal 1
2528: oPushResult
2529: equal_zero
2530: oPop 1
2532: oChoice 2546
2534: oJumpForward 2552
2536: oEmit 13
2538: oGetLocal 1
2540: oPushResult
2541: oEmitInt
2542: oPop 1
2544: oJumpForward 2552
2546: Choice Lookup Table
           0   2536
           1   2534
2551: oEndChoice
2552: oReturn
2553: oLocalSpace 8
2555: oGetGlobal 10
2557: oPushResult
2558: oScopeOpen
2559: oPop 1
2561: oGetAddrLocal 1
2563: oPushResult
2564: oSetResult 11
2566: oPushResult
2567: oNodeNew
2568: oPop 1
2570: oAssign
2571: oGetAddrLocal 5
2573: oPushResult
2574: LAST_ID
2575: oAssign
2576: oGetLocal 1
2578: oPushResult
2579: oSetResult 3
2581: oPushResult
2582: oGetLocal 5
2584: oPushResult
2585: oNodeSetInt
2586: oPop 3
2588: oGetLocal 1
2590: oPushResult
2591: oSetResult 8
2593: oPushResult
2594: oSetResult 0
2596: oPushResult
2597: oNodeSetBoolean
2598: oPop 3
2600: oGetAddrLocal 2
2602: oPushResult
2603: oScopeBegin
2604: oPop 1
2606: oGetLocal 1
2608: oPushResult
2609: oSetResult 6
2611: oPushResult
2612: oGetLocal 2
2614: oPushResult
2615: oNodeSet
2616: oPop 3
2618: oGetAddrLocal 6
2620: oPushResult
2621: oSetResult 0
2623: oAssign
2624: oInputChoice 2759
2626: oGetAddrLocal 3
2628: oPushResult
2629: oCall 3342
2631: oPop 1
2633: oEmit 12
2635: oGetAddrLocal 4
2637: oPushResult
2638: oSetResult 14
2640: oPushResult
2641: oNodeNew
2642: oPop 1
2644: oAssign
2645: oGetLocal 4
2647: oPushResult
2648: oSetResult 5
2650: oPushResult
2651: oGetLocal 3
2653: oPushResult
2654: oNodeSet
2655: oPop 3
2657: oGetLocal 4
2659: oPushResult
2660: oScopeDeclare
2661: oPop 1
2663: oGetAddrLocal 6
2665: oPushResult
2666: inc
2667: oPop 1
2669: oInputChoice 2673
2671: oJumpForward 2678
2673: Choice Lookup Table
           7   2671
2676: oJumpForward 2680
2678: oJumpBack 2626
2680: oInput 9
2682: oGetAddrLocal 7
2684: oPushResult
2685: oGetLocal 6
2687: oAssign
2688: oGetAddrLocal 8
2690: oPushResult
2691: oGetLocal 2
2693: oPushResult
2694: oSetResult 2
2696: oPushResult
2697: oNodeGetIter
2698: oPop 2
2700: oAssign
2701: oGetAddrLocal 4
2703: oPushResult
2704: oGetLocal 8
2706: oPushResult
2707: oNodeIterValue
2708: oPop 1
2710: oAssign
2711: oGetLocal 4
2713: oPushResult
2714: oNodeNull
2715: oPop 1
2717: oChoice 2725
2719: oJumpForward 2757
2721: oJumpForward 2731
2723: oJumpForward 2731
2725: Choice Lookup Table
           0   2723
           1   2719
2730: oEndChoice
2731: oGetLocal 4
2733: oPushResult
2734: oSetResult 10
2736: oPushResult
2737: oGetLocal 7
2739: oPushResult
2740: oNodeSetInt
2741: oPop 3
2743: oGetAddrLocal 7
2745: oPushResult
2746: dec
2747: oPop 1
2749: oGetAddrLocal 8
2751: oPushResult
2752: oNodeIterNext
2753: oPop 1
2755: oJumpBack 2701
2757: oJumpForward 2762
2759: Choice Lookup Table
           8   2626
2762: oScopeEnd
2763: oGetLocal 1
2765: oPushResult
2766: oScopeDeclare
2767: oPop 1
2769: oScopeEnd
2770: oEmit 7
2772: oSetResult 3
2774: oPushResult
2775: oPatchPushHere
2776: oPop 1
2778: oSetResult 3
2780: oPushResult
2781: oGetLocal 5
2783: oPushResult
2784: oPatchPushInt
2785: oPop 2
2787: oEmit 25
2789: oGetLocal 6
2791: oPushResult
2792: equal_zero
2793: oPop 1
2795: oChoice 2799
2797: oJumpForward 2810
2799: Choice Lookup Table
           1   2797
2802: oEmit 13
2804: oGetLocal 6
2806: oPushResult
2807: oEmitInt
2808: oPop 1
2810: oReturn
2811: oLocalSpace 2
2813: oGetParam 1
2815: oPushResult
2816: oGetAddrLocal 1
2818: oPushResult
2819: oCall 3711
2821: oPop 2
2823: oEmit 12
2825: oInput 4
2827: oGetAddrLocal 2
2829: oPushResult
2830: oCall 3342
2832: oPop 1
2834: oGetLocal 1
2836: oPushResult
2837: oGetLocal 2
2839: oPushResult
2840: oCall 4214
2842: oPop 2
2844: oEmit 24
2846: oReturn
2847: oLocalSpace 7
2849: oInputChoice 2861
2851: oEmit 6
2853: oGetAddrLocal 2
2855: oPushResult
2856: oSetResult 2
2858: oAssign
2859: oJumpForward 2905
2861: Choice Lookup Table
          16   2851
2864: oGetAddrLocal 3
2866: oPushResult
2867: oCall 3342
2869: oPop 1
2871: oEmit 10
2873: oGetLocal 3
2875: oPushResult
2876: oNodeNull
2877: oPop 1
2879: oChoice 2897
2881: oGetAddrLocal 2
2883: oPushResult
2884: oSetResult 1
2886: oAssign
2887: oJumpForward 2903
2889: oGetAddrLocal 2
2891: oPushResult
2892: oSetResult 5
2894: oAssign
2895: oJumpForward 2903
2897: Choice Lookup Table
           0   2889
           1   2881
2902: oEndChoice
2903: oInput 16
2905: oSetResult 0
2907: oPushResult
2908: oPatchPushHere
2909: oPop 1
2911: oEmit 25
2913: oSetResult 1
2915: oPushResult
2916: oPatchMark
2917: oPop 1
2919: oSetResult 2
2921: oPushResult
2922: oPatchMark
2923: oPop 1
2925: oGetAddrLocal 1
2927: oPushResult
2928: oSetResult 0
2930: oAssign
2931: oInputChoice 2969
2933: oInput 5
2935: oGetLocal 1
2937: oPushResult
2938: oCall 3150
2940: oPop 1
2942: oGetAddrLocal 6
2944: oPushResult
2945: oScopeBegin
2946: oPop 1
2948: oCall 1846
2950: oChoice 2954
2952: oJumpForward 2959
2954: Choice Lookup Table
           1   2952
2957: oJumpForward 2961
2959: oJumpBack 2948
2961: oScopeEnd
2962: oInput 15
2964: oCall 3194
2966: oReturn
2967: oJumpForward 3083
2969: Choice Lookup Table
          19   2933
2972: oGetLocal 2
2974: oChoice 3038
2976: oGetAddrLocal 7
2978: oPushResult
2979: oGetAddrLocal 4
2981: oPushResult
2982: oCall 3803
2984: oPop 1
2986: oAssign
2987: oGetLocal 3
2989: oPushResult
2990: oGetLocal 4
2992: oPushResult
2993: oCall 4214
2995: oPop 2
2997: oJumpForward 3046
2999: oGetAddrLocal 7
3001: oPushResult
3002: oGetAddrLocal 3
3004: oPushResult
3005: oCall 3803
3007: oPop 1
3009: oAssign
3010: oGetAddrLocal 2
3012: oPushResult
3013: oSetResult 5
3015: oAssign
3016: oJumpForward 3046
3018: oGetAddrLocal 7
3020: oPushResult
3021: oGetAddrLocal 4
3023: oPushResult
3024: oCall 3803
3026: oPop 1
3028: oAssign
3029: oGetLocal 4
3031: oPushResult
3032: oCall 4269
3034: oPop 1
3036: oJumpForward 3046
3038: Choice Lookup Table
           2   3018
           1   2999
           5   2976
3045: oEndChoice
3046: oSetResult 1
3048: oPushResult
3049: oPatchPushHere
3050: oPop 1
3052: oSetResult 1
3054: oPushResult
3055: oGetLocal 7
3057: oPushResult
3058: oPatchPushInt
3059: oPop 2
3061: oGetAddrLocal 1
3063: oPushResult
3064: inc
3065: oPop 1
3067: oInputChoice 3075
3069: oJumpForward 3083
3071: oJumpForward 3081
3073: oJumpForward 3081
3075: Choice Lookup Table
           7   3073
           5   3069
3080: oEndChoice
3081: oJumpBack 2972
3083: oGetAddrLocal 6
3085: oPushResult
3086: oScopeBegin
3087: oPop 1
3089: oCall 1846
3091: oChoice 3095
3093: oJumpForward 3100
3095: Choice Lookup Table
           1   3093
3098: oJumpForward 3102
3100: oJumpBack 3089
3102: oScopeEnd
3103: oInputChoice 3141
3105: oEmit 0
3107: oSetResult 2
3109: oPushResult
3110: oPatchPushHere
3111: oPop 1
3113: oEmit 25
3115: oGetLocal 1
3117: oPushResult
3118: oCall 3150
3120: oPop 1
3122: oEmit 11
3124: oCall 3194
3126: oReturn
3127: oJumpForward 3147
3129: oEmit 0
3131: oSetResult 2
3133: oPushResult
3134: oPatchPushHere
3135: oPop 1
3137: oEmit 25
3139: oJumpForward 3147
3141: Choice Lookup Table
          16   3129
          15   3105
3146: oEndChoice
3147: oJumpBack 2931
3149: oReturn
3150: oLocalSpace 0
3152: oSetResult 0
3154: oPushResult
3155: oPatchPopFwd
3156: oPop 1
3158: oGetParam 1
3160: oPushResult
3161: oEmitInt
3162: oPop 1
3164: oSetResult 1
3166: oPushResult
3167: oPatchAtMark
3168: oPop 1
3170: oChoice 3186
3172: oSetResult 1
3174: oPushResult
3175: oPatchPopValue
3176: oPop 1
3178: oSetResult 1
3180: oPushResult
3181: oPatchPopBack
3182: oPop 1
3184: oJumpForward 3191
3186: Choice Lookup Table
           0   3172
3189: oJumpForward 3193
3191: oJumpBack 3164
3193: oReturn
3194: oLocalSpace 0
3196: oSetResult 2
3198: oPushResult
3199: oPatchAtMark
3200: oPop 1
3202: oChoice 3212
3204: oSetResult 2
3206: oPushResult
3207: oPatchPopFwd
3208: oPop 1
3210: oJumpForward 3217
3212: Choice Lookup Table
           0   3204
3215: oJumpForward 3219
3217: oJumpBack 3196
3219: oReturn
3220: oLocalSpace 0
3222: oSetResult 3
3224: oPushResult
3225: oPatchAnyEntries
3226: oPop 1
3228: oChoice 3238
3230: oSetResult 3
3232: oPushResult
3233: oPatchPopCall
3234: oPop 1
3236: oJumpForward 3243
3238: Choice Lookup Table
           1   3230
3241: oJumpForward 3245
3243: oJumpBack 3222
3245: oReturn
3246: oLocalSpace 2
3248: oGetAddrLocal 1
3250: oPushResult
3251: oGetGlobal 10
3253: oPushResult
3254: oSetResult 2
3256: oPushResult
3257: oNodeGetIter
3258: oPop 2
3260: oAssign
3261: oGetAddrLocal 2
3263: oPushResult
3264: oGetLocal 1
3266: oPushResult
3267: oNodeIterValue
3268: oPop 1
3270: oAssign
3271: oGetLocal 2
3273: oPushResult
3274: oNodeNull
3275: oPop 1
3277: oChoice 3285
3279: oJumpForward 3341
3281: oJumpForward 3291
3283: oJumpForward 3291
3285: Choice Lookup Table
           0   3283
           1   3279
3290: oEndChoice
3291: oGetLocal 2
3293: oPushResult
3294: oNodeType
3295: oPop 1
3297: oChoice 3330
3299: oGetLocal 2
3301: oPushResult
3302: oSetResult 8
3304: oPushResult
3305: oNodeGetBoolean
3306: oPop 2
3308: oChoice 3325
3310: oGetLocal 2
3312: oPushResult
3313: oSetResult 3
3315: oPushResult
3316: oNodeGetInt
3317: oPop 2
3319: oPushResult
3320: oUndeclaredRule
3321: oPop 1
3323: oJumpForward 3328
3325: Choice Lookup Table
           0   3310
3328: oJumpForward 3333
3330: Choice Lookup Table
          11   3299
3333: oGetAddrLocal 1
3335: oPushResult
3336: oNodeIterNext
3337: oPop 1
3339: oJumpBack 3261
3341: oReturn
3342: oLocalSpace 1
3344: oInputChoice 3627
3346: oGetAddrLocal 1
3348: oPushResult
3349: oScopeFind
3350: oPop 1
3352: oChoice 3511
3354: oGetLocal 1
3356: oPushResult
3357: oNodeType
3358: oPop 1
3360: oChoice 3452
3362: oSetResult 0
3364: oPushResult
3365: oWarning
3366: oPop 1
3368: oGetLocal 1
3370: oPushResult
3371: oCall 2457
3373: oPop 1
3375: oJumpForward 3471
3377: oGetLocal 1
3379: oPushResult
3380: oCall 2232
3382: oPop 1
3384: oJumpForward 3471
3386: oEmit 9
3388: oGetLocal 1
3390: oPushResult
3391: oCall 4290
3393: oPop 1
3395: oJumpForward 3471
3397: oEmit 17
3399: oGetLocal 1
3401: oPushResult
3402: oCall 4306
3404: oPop 1
3406: oJumpForward 3471
3408: oEmit 18
3410: oGetLocal 1
3412: oPushResult
3413: oCall 4306
3415: oPop 1
3417: oJumpForward 3471
3419: oEmit 18
3421: oGetLocal 1
3423: oPushResult
3424: oCall 4306
3426: oPop 1
3428: oJumpForward 3471
3430: oEmit 19
3432: oGetLocal 1
3434: oPushResult
3435: oCall 4306
3437: oPop 1
3439: oJumpForward 3471
3441: oEmit 20
3443: oGetLocal 1
3445: oPushResult
3446: oCall 4306
3448: oPop 1
3450: oJumpForward 3471
3452: Choice Lookup Table
          18   3441
          17   3430
          16   3419
          15   3408
          14   3397
           8   3386
          10   3377
          11   3362
3469: oError 11
3471: oGetParam 1
3473: oPushResult
3474: oGetLocal 1
3476: oPushResult
3477: oSetResult 5
3479: oPushResult
3480: oNodeGet
3481: oPop 2
3483: oAssign
3484: oGetFromParam 1
3486: oPushResult
3487: oNodeNull
3488: oPop 1
3490: oChoice 3496
3492: oError 10
3494: oJumpForward 3499
3496: Choice Lookup Table
           1   3492
3499: oJumpForward 3517
3501: oGetParam 1
3503: oPushResult
3504: oSetResult 0
3506: oAssign
3507: oError 17
3509: oJumpForward 3517
3511: Choice Lookup Table
           0   3501
           1   3354
3516: oEndChoice
3517: oJumpForward 3637
3519: oInput 0
3521: oGetAddrLocal 1
3523: oPushResult
3524: oScopeFind
3525: oPop 1
3527: oChoice 3583
3529: oGetLocal 1
3531: oPushResult
3532: oCall 4126
3534: oPop 1
3536: oGetLocal 1
3538: oPushResult
3539: oCall 2457
3541: oPop 1
3543: oGetParam 1
3545: oPushResult
3546: oGetLocal 1
3548: oPushResult
3549: oSetResult 5
3551: oPushResult
3552: oNodeGet
3553: oPop 2
3555: oAssign
3556: oGetFromParam 1
3558: oPushResult
3559: oNodeNull
3560: oPop 1
3562: oChoice 3568
3564: oError 10
3566: oJumpForward 3571
3568: Choice Lookup Table
           1   3564
3571: oJumpForward 3589
3573: oCall 2553
3575: oGetParam 1
3577: oPushResult
3578: oSetResult 0
3580: oAssign
3581: oJumpForward 3589
3583: Choice Lookup Table
           0   3573
           1   3529
3588: oEndChoice
3589: oJumpForward 3637
3591: oInput 1
3593: oEmit 9
3595: TOKEN_VALUE
3596: oPushResult
3597: negate
3598: oPop 1
3600: oPushResult
3601: oEmitInt
3602: oPop 1
3604: oGetParam 1
3606: oPushResult
3607: oGetGlobal 2
3609: oAssign
3610: oJumpForward 3637
3612: oEmit 9
3614: TOKEN_VALUE
3615: oPushResult
3616: oEmitInt
3617: oPop 1
3619: oGetParam 1
3621: oPushResult
3622: oGetGlobal 2
3624: oAssign
3625: oJumpForward 3637
3627: Choice Lookup Table
           1   3612
           3   3591
          17   3519
           0   3346
3636: oEndChoice
3637: oReturn
3638: oLocalSpace 1
3640: oInputChoice 3702
3642: oGetAddrLocal 1
3644: oPushResult
3645: oScopeFind
3646: oPop 1
3648: oChoice 3672
3650: oGetLocal 1
3652: oPushResult
3653: oGetParam 1
3655: oPushResult
3656: oCall 3711
3658: oPop 2
3660: oJumpForward 3678
3662: oGetParam 1
3664: oPushResult
3665: oSetResult 0
3667: oAssign
3668: oError 12
3670: oJumpForward 3678
3672: Choice Lookup Table
           0   3662
           1   3650
3677: oEndChoice
3678: oJumpForward 3710
3680: oInput 1
3682: oGetParam 1
3684: oPushResult
3685: oSetResult 0
3687: oAssign
3688: oError 12
3690: oJumpForward 3710
3692: oGetParam 1
3694: oPushResult
3695: oSetResult 0
3697: oAssign
3698: oError 12
3700: oJumpForward 3710
3702: Choice Lookup Table
           1   3692
           3   3680
           0   3642
3709: oEndChoice
3710: oReturn
3711: oLocalSpace 0
3713: oGetParam 2
3715: oPushResult
3716: oNodeType
3717: oPop 1
3719: oChoice 3776
3721: oEmit 21
3723: oGetParam 2
3725: oPushResult
3726: oCall 4306
3728: oPop 1
3730: oJumpForward 3789
3732: oEmit 17
3734: oGetParam 2
3736: oPushResult
3737: oCall 4306
3739: oPop 1
3741: oJumpForward 3789
3743: oEmit 17
3745: oGetParam 2
3747: oPushResult
3748: oCall 4306
3750: oPop 1
3752: oJumpForward 3789
3754: oEmit 22
3756: oGetParam 2
3758: oPushResult
3759: oCall 4306
3761: oPop 1
3763: oJumpForward 3789
3765: oEmit 23
3767: oGetParam 2
3769: oPushResult
3770: oCall 4306
3772: oPop 1
3774: oJumpForward 3789
3776: Choice Lookup Table
          18   3765
          17   3754
          16   3743
          15   3732
          14   3721
3787: oError 12
3789: oGetParam 1
3791: oPushResult
3792: oGetParam 2
3794: oPushResult
3795: oSetResult 5
3797: oPushResult
3798: oNodeGet
3799: oPop 2
3801: oAssign
3802: oReturn
3803: oLocalSpace 2
3805: oInputChoice 3908
3807: oGetAddrLocal 1
3809: oPushResult
3810: oCall 3994
3812: oPop 1
3814: oGetAddrLocal 2
3816: oPushResult
3817: oGetLocal 1
3819: oPushResult
3820: oSetResult 4
3822: oPushResult
3823: oNodeGetInt
3824: oPop 2
3826: oAssign
3827: oGetParam 1
3829: oPushResult
3830: oGetLocal 1
3832: oPushResult
3833: oSetResult 5
3835: oPushResult
3836: oNodeGet
3837: oPop 2
3839: oAssign
3840: oJumpForward 3918
3842: oInput 1
3844: oGetAddrLocal 2
3846: oPushResult
3847: TOKEN_VALUE
3848: oPushResult
3849: negate
3850: oPop 1
3852: oAssign
3853: oGetParam 1
3855: oPushResult
3856: oGetGlobal 2
3858: oAssign
3859: oJumpForward 3918
3861: oGetAddrLocal 2
3863: oPushResult
3864: TOKEN_VALUE
3865: oAssign
3866: oGetParam 1
3868: oPushResult
3869: oGetGlobal 2
3871: oAssign
3872: oJumpForward 3918
3874: oGetAddrLocal 1
3876: oPushResult
3877: oShortFormLookup
3878: oPop 1
3880: oGetAddrLocal 2
3882: oPushResult
3883: oGetLocal 1
3885: oPushResult
3886: oSetResult 4
3888: oPushResult
3889: oNodeGetInt
3890: oPop 2
3892: oAssign
3893: oGetParam 1
3895: oPushResult
3896: oGetLocal 1
3898: oPushResult
3899: oSetResult 5
3901: oPushResult
3902: oNodeGet
3903: oPop 2
3905: oAssign
3906: oJumpForward 3918
3908: Choice Lookup Table
           2   3874
           1   3861
           3   3842
           0   3807
3917: oEndChoice
3918: oGetLocal 2
3920: oReturn
3921: oReturn
3922: oLocalSpace 2
3924: oGetAddrLocal 2
3926: oPushResult
3927: oGetAddrLocal 1
3929: oPushResult
3930: oCall 3803
3932: oPop 1
3934: oAssign
3935: oGetLocal 1
3937: oPushResult
3938: oCall 4248
3940: oPop 1
3942: oGetLocal 2
3944: oReturn
3945: oReturn
3946: oLocalSpace 0
3948: oGetParam 1
3950: oPushResult
3951: oScopeFindRequire
3952: oPop 1
3954: oGetFromParam 1
3956: oPushResult
3957: oCall 4026
3959: oPop 1
3961: oReturn
3962: oLocalSpace 0
3964: oGetParam 1
3966: oPushResult
3967: oScopeFindRequire
3968: oPop 1
3970: oGetFromParam 1
3972: oPushResult
3973: oCall 4044
3975: oPop 1
3977: oReturn
3978: oLocalSpace 0
3980: oGetParam 1
3982: oPushResult
3983: oScopeFindRequire
3984: oPop 1
3986: oGetFromParam 1
3988: oPushResult
3989: oCall 4072
3991: oPop 1
3993: oReturn
3994: oLocalSpace 0
3996: oGetParam 1
3998: oPushResult
3999: oScopeFindRequire
4000: oPop 1
4002: oGetFromParam 1
4004: oPushResult
4005: oCall 4090
4007: oPop 1
4009: oReturn
4010: oLocalSpace 0
4012: oGetParam 1
4014: oPushResult
4015: oScopeFindRequire
4016: oPop 1
4018: oGetFromParam 1
4020: oPushResult
4021: oCall 4108
4023: oPop 1
4025: oReturn
4026: oLocalSpace 0
4028: oGetParam 1
4030: oPushResult
4031: oNodeType
4032: oPop 1
4034: oChoice 4038
4036: oJumpForward 4043
4038: Choice Lookup Table
           7   4036
4041: oError 1
4043: oReturn
4044: oLocalSpace 0
4046: oGetParam 1
4048: oPushResult
4049: oSetResult 5
4051: oPushResult
4052: oNodeGet
4053: oPop 2
4055: oPushResult
4056: oGetGlobal 3
4058: oPushResult
4059: oNodeEqual
4060: oPop 2
4062: oChoice 4066
4064: oJumpForward 4071
4066: Choice Lookup Table
           1   4064
4069: oError 3
4071: oReturn
4072: oLocalSpace 0
4074: oGetParam 1
4076: oPushResult
4077: oNodeType
4078: oPop 1
4080: oChoice 4084
4082: oJumpForward 4089
4084: Choice Lookup Table
           5   4082
4087: oError 4
4089: oReturn
4090: oLocalSpace 0
4092: oGetParam 1
4094: oPushResult
4095: oNodeType
4096: oPop 1
4098: oChoice 4102
4100: oJumpForward 4107
4102: Choice Lookup Table
           8   4100
4105: oError 2
4107: oReturn
4108: oLocalSpace 0
4110: oGetParam 1
4112: oPushResult
4113: oNodeType
4114: oPop 1
4116: oChoice 4120
4118: oJumpForward 4125
4120: Choice Lookup Table
           6   4118
4123: oError 6
4125: oReturn
4126: oLocalSpace 0
4128: oGetParam 1
4130: oPushResult
4131: oNodeType
4132: oPop 1
4134: oChoice 4138
4136: oJumpForward 4143
4138: Choice Lookup Table
          11   4136
4141: oError 5
4143: oReturn
4144: oLocalSpace 0
4146: oGetParam 1
4148: oPushResult
4149: oSetResult 5
4151: oPushResult
4152: oNodeGet
4153: oPop 2
4155: oPushResult
4156: oNodeNull
4157: oPop 1
4159: oChoice 4169
4161: oSetResult 1
4163: oPushResult
4164: oWarning
4165: oPop 1
4167: oJumpForward 4172
4169: Choice Lookup Table
           0   4161
4172: oReturn
4173: oLocalSpace 0
4175: oGetParam 2
4177: oPushResult
4178: oSetResult 5
4180: oPushResult
4181: oNodeGet
4182: oPop 2
4184: oPushResult
4185: oGetParam 1
4187: oPushResult
4188: oNodeEqual
4189: oPop 2
4191: oChoice 4195
4193: oJumpForward 4200
4195: Choice Lookup Table
           1   4193
4198: oError 0
4200: oReturn
4201: oLocalSpace 0
4203: oGetParam 2
4205: oPushResult
4206: oGetParam 1
4208: oPushResult
4209: oNodeEqual
4210: oPop 2
4212: oReturn
4213: oReturn
4214: oLocalSpace 0
4216: oGetParam 2
4218: oPushResult
4219: oGetParam 1
4221: oPushResult
4222: oNodeEqual
4223: oPop 2
4225: oChoice 4229
4227: oJumpForward 4234
4229: Choice Lookup Table
           1   4227
4232: oError 0
4234: oReturn
4235: oLocalSpace 0
4237: oGetParam 1
4239: oPushResult
4240: oGetGlobal 2
4242: oPushResult
4243: oNodeEqual
4244: oPop 2
4246: oReturn
4247: oReturn
4248: oLocalSpace 0
4250: oGetParam 1
4252: oPushResult
4253: oGetGlobal 2
4255: oPushResult
4256: oNodeEqual
4257: oPop 2
4259: oChoice 4263
4261: oJumpForward 4268
4263: Choice Lookup Table
           1   4261
4266: oError 0
4268: oReturn
4269: oLocalSpace 0
4271: oGetParam 1
4273: oPushResult
4274: oGetGlobal 3
4276: oPushResult
4277: oNodeEqual
4278: oPop 2
4280: oChoice 4284
4282: oJumpForward 4289
4284: Choice Lookup Table
           1   4282
4287: oError 3
4289: oReturn
4290: oLocalSpace 0
4292: oGetParam 1
4294: oPushResult
4295: oSetResult 4
4297: oPushResult
4298: oNodeGetInt
4299: oPop 2
4301: oPushResult
4302: oEmitInt
4303: oPop 1
4305: oReturn
4306: oLocalSpace 0
4308: oGetParam 1
4310: oPushResult
4311: oSetResult 10
4313: oPushResult
4314: oNodeGetInt
4315: oPop 2
4317: oPushResult
4318: oEmitInt
4319: oPop 1
4321: oReturn
