title: 'Pascal Compiler 1.1.5 -- Jan 01 ''90';
   
%
%  Pascal.ssl
%
%  Pascal Compiler for the Amiga, by Steve Rice.
%
%  HISTORY
%    11Sep89   First version, framework of parser.
%    18Sep89   Added some semantic mechanisms.
%    21Sep89   Added simple type references; expressions generate code.
%    22Sep89   Allocate variable addresses as they're declared.
%    24Sep89   Added arrays, pointers.
%    27Sep89   Added for statement.
%    23Oct89   Fixed for statement, so CYCLE goes to next step.
%    01Jan90   Added string literals
%    09Sep22   I have returned.  Migrate symbol table to schema, to ease development.
%    01Oct22   Language: Switch from cycle/exit (Mac Pascal extension) to continue/break (Borland).
%
%  NOTES
%    -  The 'value' of a var symbol is its allocated address.
%    -  References to vars of intrinsic types, and pointer types,
%       pushes the value of the var on the expr stack.  Referenecs to
%       vars of compound types (arrays, records...) pushes the address
%       on the expr stack.
%    -  Just as there is only one type table entry for a given (named) type,
%       there is only one type table entry for a pointer to a named type.
%       When a pointer type is declared, a field in the TT entry of the
%       type pointed to will be set to indicate the TT entry of the pointer
%       to that type (0 means none defined yet).  When evaluating the
%       expression @x, the type in that field in the entry for the type of x
%       will be used (unless it's 0, in which case a new TT entry will be
%       created).
%
%
%  MISSING
%
%    - procedure and function declarations may be nested within other procs/funcs!
%      They are allowed to see locals within those parent scopes.
%      Pass a hidden parameter to nested methods, to follow up to parent scopes as needed.
%      Need a level counter at each scope, and uplevels count on reference to local/param.
%      
%    - Consider non-ISO extensions.  e.g. see "Units" e.g. from Turbo Pascal wikipedia page.
%      Dynamic arrays.  Objects.  But, perhaps stick to my old goal, standard Pascal.
%
%  PASCAL DOCS
%      Here's some handy language material:
%      https://www.freepascal.org/docs-html/ref/ref.html
%      https://www.freepascal.org/docs-html/prog/prog.html
%      https://en.wikipedia.org/wiki/Turbo_Pascal
%      https://en.wikipedia.org/wiki/Pascal_(programming_language)#Standards
%      http://www.standardpascaline.org/
%

input:
   pIdent
   pIntLit
   pStrLit
   pAssign       ':='
   pSemiColon    ';'
   pEqual        '='
   pNotEqual     '<>'
   pLess         '<'
   pGreater      '>'
   pLessEqual    '<='
   pGreaterEqual '>='
   pColon        ':'
   pComma        ','
   pLParen       '('
   pRParen       ')'
   pLSquare      '['
   pRSquare      ']'
   pCarat        '^'
   pAt           '@'
   pDot          '.'
   pDotDot       '..'
   pTimes        '*'
   pDivide       '/'
   pPlus         '+'
   pMinus        '-'
   pEof
   pInvalid

%  keywords  (built-in types 'integer', 'byte', 'char', etc, are not keywords,
%             type constructors 'array', 'record', 'set' are keywords,
%             pseudo-procedures 'writeln', 'readln' are keywords)
%
%             forward/external/name/cdecl appear in method modifiers, in fpc grammar.
%             I'm making them keywords to simplify parsing, but could reconsider.

   pProgram
   pProcedure
   pFunction
   pConst
   pType
   pVar
   pBegin
   pEnd
   pArray
   pRecord
   pSet
   pOf
   pIf
   pThen
   pElse
   pFor
   pTo
   pDownto
   pDo
   pWhile
   pRepeat
   pUntil
   pContinue
   pBreak
   pAnd
   pOr
   pNot
   pUses
   pUnit
   pInterface
   pImplementation
   pInitialization
   pFinalization
   pWriteln
   pWrite
   pReadln
   pRead

   pForward
   pExternal
   pName
   pCdecl
   ;


output:

%  Instructions for a stack machine (all vars are 32-bit integers)

   tPushGlobalI      % <ptr> - push int value read from ptr
   tPushGlobalB      % <ptr> - push byte value read from ptr
   tPushGlobalP      % <ptr> - push ptr value read from ptr
   tPushLocalI       % <offset> - push int value read from local var in current scope
   tPushLocalB       % <offset> - push byte value read from local var in current scope
   tPushLocalP       % <offset> - push ptr value read from local var in current scope
   tPushParamI       % <offset> - push int value read from param in current scope
   tPushParamB       % <offset> - push byte value read from param in current scope
   tPushParamP       % <offset> - push ptr value read from param in current scope
   tPushUpLocalI     % <uplevels> <offset> - push int value read from local var in a parent static scope
   tPushUpLocalB     % <uplevels> <offset> - push byte value read from local var in a parent static scope
   tPushUpLocalP     % <uplevels> <offset> - push ptr value read from local var in a parent static scope
   tPushUpParamI     % <uplevels> <offset> - push int value read from param in a parent static scope
   tPushUpParamB     % <uplevels> <offset> - push byte value read from param in a parent static scope
   tPushUpParamP     % <uplevels> <offset> - push ptr value read from param in a parent static scope
   tPushConstI       % <int> - push int value on stack (NOTE, used for BOOLEAN too)
   tPushAddrGlobal   % <offset> - push ptr to global var (same as tPushConstP)
   tPushAddrLocal    % <offset> - push ptr to local var
   tPushAddrParam    % <offset> - push ptr to formal param (used by method to see its param)
   tPushAddrActual   % <offset> - push ptr to actual param, in actuals space (used by caller)
   tPushAddrUpLocal  % <uplevels> <offset> - push ptr to local var in a parent static scope
   tPushAddrUpParam  % <uplevels> <offset> - push ptr to formal param in a parent static scope
   tFetchI           % pop ptr from stack, and push int value it points to
   tFetchB           %    "      "      "     "     byte  "   "    "
   tFetchP           %    "      "      "     "     ptr   "   "    "   
   tAssignI          % assign int value on top of stack to addr under it (pop both)
   tAssignB          %   "    byte   "    "   "  "   "    "    "   "   "
   tAssignP          %   "    ptr    "    "   "  "   "    "    "   "   "
   tCopy             % <#bytes> - copy bytes.  tos=src, 2nd=dest (pop 2)
   tIncI             % increment int value on top of expr stack
   tDecI             % decrement int value on top of expr stack
   tMultI            % multiply top two integers (replacing with result)
   tDivI
   tAddPI            % add ptr (2nd value) and int (top value), resulting in a ptr
   tAddI
   tSubI
   tNegI             % top entry *= -1
   tNot              % negate top boolean
   tEqualI           % top two entries equal? (pop 2, push 1) (true=1)
   tNotEqualI        %    NOTE, these all work for booleans too
   tGreaterI         % 2nd entry greater than top entry? (pop 2, push answer)
   tLessI  
   tGreaterEqualI
   tLessEqualI
   tEqualP           % two two pointer values equal? (pop 2, push 1) (true=1)
   tNotEqualP
   tAllocActuals     % <#bytes> - make space on call stack for actual params (adjusting call stack sp)
   tAllocActualsCdecl  % <#bytes> - starting a call to a cdecl method.  tcode still describes my own calling convention.
   tFreeActuals      % <#bytes> - discard space on call stack allocated by tAllocActuals
   tCall             % <label#>
   tCallCdecl        % <label#> - call a method using native (C) calling convention. Only supported for extern labels.
   tReturn
   tEnter            % <#bytes> - start a stack frame on the call stack, reserving #bytes of local variable space
   tJump             % <label#>
   tJumpTrue         % <label#>  (pops top of stack, jumps if true)
   tJumpFalse        % <label#>  (pops top of stack, jumps if false)
   tLabel            % <label#> - define label# at the current address
   tLabelAlias       % <label#> <aliasToLabel#> - defines label to be an alias of another label
   tLabelExtern      % <label#> <offsetToStrLit> - defines label to mean an extern symbol, whose name is in global data
   tWriteI           % for writeln : write integer on tos, pop
   tWriteBool        %  "     "    : write TRUE/FALSE, pop
   tWriteStr         %  "     "    : write string whose addr is on tos, pop
   tWriteP           %  "     "    : write ptr var whose addr is on tos, pop
   tWriteCR          %  "     "    : write cr

%  Other:

   tSpace            % emit a hole, to be patched later
   ;

error:
   eBadStatement
   eNotConst
   eNotType
   eNotOrdinalType
   eNotVar
   eNotIntVar
   eNotValue
   eNotInteger
   eNotBoolean
   eNotPointer
   eNotArray
   eNotRecord
   eNotRecordField
   eTooManySubscripts
   eTypeMismatch
   eMissingParameter
   eNotImplemented
   eNotAllowed
   eNotInALoop
   eRecordEmpty
   eNotCurrentFunction
   eAlreadyDefined
   eOnlyOneVarCanBeInitialized
   eExternalMethodCannotBeNested
   ;

include 'pascal_schema.ssl'

type Node:     % A pointer to a node in the schema database (symbol database)
   Null = 0
   ;

type NodeIter:   % An iterator over nodes in a list, in the schema database
   NullIter = 0
   ;

type NodeVec:  % A pointer to a vector of Node.  See mechanism node_vec_mech
   NullVec = 0
   ;

type boolean:
   false    = 0
   true     = 1;

type kind:           % kind of identifier
   kUndefined        % not yet added to symbol table
   kProgram
   kProc
   kFunc
   kConst
   kType
   kVar;

% intrinsic types & type constructs

type typ:
   tyNone     = 0    % in ptrTyp field of TT, means no ptr to type defined
   tyInteger
   tyBoolean
   tyChar
   tyString
   tyFile            % tyInteger..tyFile are scalars (types on their own)
   tyPointer         % following are type constructor classes...
   tyArray           %   (they are not type#'s)
   tyRecord
   tyParams          % like record; a collection of proc/func params
   tySet;

type Label:
   labelNull = 0;

% An output code stream.
type Code:
   codeNull = 0
   codeDefault = 1
   ;

% A string
type String:
   stringNull = 0
   ;


% Some general schema node operations.
% node_type and node_attribute are defined in generated file pascal_schema.ssl included above.
%
mechanism node_mech:
    oNodeNew (node_type) >> Node         % create new node
    oNodeSet (Node, node_attribute, Node)   % set Node attribute of node
    oNodeSetString (Node, node_attribute, String)
    oNodeSetInt (Node, node_attribute, int) % set int attribute of node
    oNodeSetBoolean (Node, node_attribute, boolean)
    oNodeSetKind (Node, node_attribute, kind) % set attribute of node  *** MIGHT NOT NEED
    oNodeSetLabel( Node, node_attribute, Label )  % set Label attribute of node
    oNodeSetCode( Node, node_attribute, Code )    % set Code attribute of node
    oNodeGet (Node, node_attribute) >> Node    % get Node attribute of node
    oNodeGetString (Node, node_attribute) >> String
    oNodeGetInt (Node, node_attribute) >> int  % get int attribute of node
    oNodeGetBoolean (Node, node_attribute) >> boolean  % get int attribute of node
    oNodeGetLabel (Node, node_attribute) >> Label      % get Label attribute of node
    oNodeGetCode (Node, node_attribute) >> Code        % get code stream attribute of node
    oNodeNull (Node) >> boolean          % is node null?
    oNodeGetIter (Node, node_attribute) >> NodeIter   % get an iterator over nodes in a List attribute
    oNodeIterValue (NodeIter) >> Node             % the node that iter is referring to (NodeNull if no more nodes)
    oNodeIterNext (inout NodeIter)                 % advance iterator through list
    oNodeType (Node) >> node_type        % return node type of node
    oNodeEqual (Node, Node) >> boolean   % compare two nodes for equality
                                         % (i.e. same node, not just same contents)
    ;


% Manipulate a temporary vector of Node
%
mechanism node_vec_mech:
    oNodeVecNew >> NodeVec
    oNodeVecDelete( NodeVec nv )
    oNodeVecAppend( NodeVec nv, Node n )
    oNodeVecSize( NodeVec nv ) >> int                % how many elements
    oNodeVecElement( NodeVec nv, int idx ) >> Node   % element at index idx (0..size-1)
    ;



mechanism emit_mech:
    oEmitInt( int )              % emit int into the generated code
    oEmitLabel( Label )
    oEmitCode( Code )            % append a code stream to the current code stream
    Here >> int                  % current address in the generated code
                                 %   (only usable in the default code stream)
    oPatch( int addr, int val )  % patch an int into address in the generated code
                                 %   (only usable in the default code stream)
    ;

mechanism math:
    inc (inout int)
    dec (inout int)
    negate (int) >> int
    subtract( int x, int y ) >> int     % x - y
    multiply( int x, int y ) >> int     % x * y
    equal( int x, int y ) >> boolean
    equal_zero (int) >> boolean
    equal_node( Node, Node ) >> boolean
    equal_string( String, String ) >> boolean
    equal_node_type (node_type, node_type) >> boolean     % Want equal_<type> for every type
    equal_label( Label, Label ) >> boolean
    equal_code( Code, Code ) >> boolean
    greater( int x, int y ) >> boolean
    oMININT >> int    % the minimum 32-bit integer.
    ;

mechanism more_builtins:      % These should be built-in SSL operations
    TOKEN_VALUE >> int        % value of just accepted token, e.g. IntLit token
    LAST_ID >> int            % id number of last accepted identifier
    ID_STRING( int id ) >> String       % text name of identifier with given id
    CURRENT_STRLIT >> String            % text value of just-accepted string literal
    ;

mechanism scope_mech:
    oScopeBegin( int level )             % create a new scope. Subsequent declarations will go here.
                                         %  level = static scope depth (0 = globals)
    oScopeEnter( Node scope )            % enter an existing scope.
    oScopeEnd                            % end current scope. Subsequent declarations will go to previous scope.
    oScopeCurrent >> Node                % returns current scope
    oScopeDeclare( Node decl )           % add declaration to current scope.
    oScopeDeclareAlloc( Node decl )      % add declaration to current scope, and allocate space according to its type
    oScopeAllocType( Node theType ) >> int   % allocate space for type in current scope, and return its address
    oScopeFind >> Node                   % find declaration of last accepted identifier.  Returns Null if not found.
    oScopeFindRequire >> Node            % find declaration of last accepted identifier.  Error if not found.
    oScopeFindInCurrentScope >> Node     % find declaration of last accepted identifier, only within the current scope.  Null if not found.
    ;

mechanism type_mech:
    oTypeAdd( Node node )     % add the given nType to the type table
    ;

mechanism type_stack_mech:
    oTypeSPush( Node node )
    oTypeSPop
    oTypeSTop >> Node
    oTypeSNodeType >> node_type          % node_type of the node on top of type stack, skipping subranges
    ;


mechanism id_mech:
    % adds a predefined id to the scanner's id table, and returns the id code
    oIdAdd_File >> int
    oIdAdd_Integer >> int
    oIdAdd_Boolean >> int
    oIdAdd_Char >> int
    oIdAdd_String >> int
    oIdAdd_True >> int
    oIdAdd_False >> int
    ;



mechanism label_mech:
   oLabelNew >> Label
   ;

mechanism code_mech:
   oCodeNew >> Code         % create a new empty code stream
   oCodePush( Code )        % change the current output code stream to the given one
   oCodePop                 % restore the current code stream to the previous one
   ;


mechanism count :
   oCountPush(int)          % start a new counter, with initial value
   oCountInc
   oCountDec
   oCountIsZero >> boolean
   oCountPop;


mechanism value :              % value stack, to calc. const expr's
   oValuePush(int)             % push an explicit int lit
   oValueNegate                % negate top value
   oValueTop >> int            % get top value on value stack
   oValuePop;

mechanism string :
   oStringAllocLit( String ) >> int      % alloc global space for strlit, return address
   ;

% track labels for the loop we're in, if any
mechanism loop_mech:
   oLoopPush( Label continueLabel, Label breakLabel )
   oLoopContinueLabel >> Label
   oLoopBreakLabel >> Label
   oLoopPop
   ;

% for hacky debugging
mechanism msg_mech:
   oMsg( int num )             % print message "oMsg <num>"
   oMsgTrace( int num )        % print message "oMsg <num>" followed by ssl traceback
   oMsgNode( Node node )       % print node
   oMsgNodeVec( NodeVec vec )  % print node vec
   ;


rules

% ----------------------------- Global Variables ----------------------------

Node    workspace              % root of database
Node    globalScope            % global nScope
Node    mainRoutineScope       % scope for temporaries in main routine

% built-in nTypes
Node    FileType
Node    IntegerType
Node    BooleanType
Node    BooleanCFType
Node    CharType
Node    StringType

% -------------------------- Forward Declarations -------------------------

Block( node_type varNodeType, Label labelForBody );
BlockDecls( node_type varNodeType );
BlockStmt( Label labelForBody, Node varScope );
VarDecl( node_type varNodeType );
newType( node_type nt, int size ) >> Node;
newIdent( node_type nt, kind k, int id ) >> Node;
EmitValue( Node decl );
TypeRef( out Node theType );
PointerTypeTo( Node theType ) >> Node;
OrdinalLow( Node theType ) >> int;
AssignStmt( Node decl );
BooleanExprControlFlow( out Label falseLabel );
ExprAllowCF( out Label falseLabel );
BoolExprAllowCF( out Label falseLabel );
BoolTermAllowCF( out Label falseLabel );
BoolFactorAllowCF( out Label falseLabel );
ArithExprAllowCF( out Label falseLabel );
TermAllowCF( out Label falseLabel );
FactorAllowCF( out Label falseLabel );
PrimaryAllowCF( out Label falseLabel );

VarExpr( Node decl );
LValueVar( Node decl );
IncVar( Node decl );
DecVar( Node decl );

CFToVal( inout Label falseLabel );
ValToCF( out Label falseLabel );

DeclLevel( Node decl ) >> int;
DeclUpLevels( Node decl ) >> int;

% ----------------------------- Declarations ----------------------------

Program:
   Node t

   workspace = oNodeNew( nWorkspace )

   oScopeBegin( 0 )
   globalScope = oScopeCurrent

   @installBuiltIns

   % Start by calling the main program routine.

   % This dummy call to main needs to look like a normal method itself,
   % so jit can align the stack properly.  So we need .tEnter,
   % and .tAllocActuals / .tFreeActuals.
   .tEnter  oEmitInt( 0 )
   Label mainLabel = oLabelNew

   .tAllocActuals  oEmitInt( 0 )
   .tCall  oEmitLabel( mainLabel )
   .tFreeActuals  oEmitInt( 0 )
   .tReturn

   pProgram
   pIdent

   Node program = oNodeNew( nProgram )
   oNodeSetInt( program, qIdent, LAST_ID )
   oNodeSet( workspace, qProgram, program )


   [
      | '(' :
         pIdent      % input, output files

         t = @newIdent( nVar, kVar, LAST_ID )
         oNodeSet( t, qType, FileType )
         oScopeDeclareAlloc( t )

         ','
         pIdent

         t = @newIdent( nVar, kVar, LAST_ID )
         oNodeSet( t, qType, FileType )
         oScopeDeclareAlloc( t )

         ')'
      | * :
   ]
   ';'

   % A new scope just for temporaries in the main routine
   % Create it up front, in case it's needed by variable initialization exprs.
   % But we won't stay in it here.
   oScopeBegin( 0 )
   mainRoutineScope = oScopeCurrent
   oNodeSetBoolean( oScopeCurrent, qAllocDown, true )
   oNodeSet( program, qMainRoutineScope, oScopeCurrent )
   oScopeEnd

   @BlockDecls( nGlobalVar )


   oScopeEnter( mainRoutineScope )

   % The block statement includes a stack frame, and enter/return,
   % even for the main routine.
   % That will be necessary for temporaries allocated in the main routine.
   @BlockStmt( mainLabel, globalScope )

   oScopeEnd   % main routine scope

   '.'
   oScopeEnd   % global scope
   ;


Block( node_type varNodeType, Label labelForBody ):
   @BlockDecls( varNodeType )
   @BlockStmt( labelForBody, oScopeCurrent )
   ;


BlockDecls( node_type varNodeType ):
   {[
      | pConst :     @ConstDecl
      | pType :      @TypeDecl
      | pVar :       @VarDecl( varNodeType )
      | pProcedure : @ProcDecl
      | pFunction :  @FuncDecl
      | * :          >
   ]}
   @CheckForUndefinedMethods
   ;


% were there any procedures or functions declared in this scope
% that were never defined?
CheckForUndefinedMethods:
   % TO DO
   % Note: disregard methods marked external
   ;



% Given the scope of vars in this block.
% Usually it's the current scope, but it's a bit different for the main statement.
%
BlockStmt( Label labelForBody, Node varScope ):
   .tLabel  oEmitLabel( labelForBody )

   % Proc, func, and main routine all start with tEnter
   % to create a stack frame.  This will be used for temporaries
   % (and local vars in the case of proc, func).

   int patchLS
   .tEnter  patchLS = Here  .tSpace

   % insert any code for initialization of this scope's variables
   Code initCode = oNodeGetCode( varScope, qInitCode )
   oEmitCode( initCode )
   oNodeSetCode( oScopeCurrent, qInitCode, codeNull )

   @Statement
   .tReturn

   int localSpace = oNodeGetInt( oScopeCurrent, qSize )
   oPatch( patchLS, localSpace )
   ;


% modifers that may appear on a proc/function declaration.
%
MethodModifiers( Node decl ):
   {[
      | pCdecl :
         oNodeSetBoolean( decl, qCdecl, true )
         ';'

      | * : >
   ]}
   ;


% We need an initCode code stream for the current scope.
% Create it if not present yet.  Return it.
% (This will be used for variable initialization.)
%
GetOrCreateInitCode >> Code:
   Code initCode = oNodeGetCode( oScopeCurrent, qInitCode )
   [ equal_code( initCode, codeNull )
      | true :
         initCode = oCodeNew
         oNodeSetCode( oScopeCurrent, qInitCode, initCode )
      | * :
   ]
   >> initCode;


% external method resides in an external object file
% (or in my system, the built-in runtime library).
% The method has a label, as usual, which callers will use.
% But we define that label with .tLabelExtern rather than .tLabel.
%
% Note, I'll hold off on issuing the .tLabelExtern until we see that
% the external method is actually called.  Otherwise we'd fill each output file
% with all the external method names in my included libraries, which seems dumb.
%
% Note this is fpc syntax.  I'm not sure about other Pascals.
%
ExternalDecl( Node decl ):
   [ equal_zero( @DeclLevel( decl ) )
      | false :  #eExternalMethodCannotBeNested
      | * :
   ]
   oNodeSetBoolean( decl, qExternal, true )
   [
      | pStrLit :
         % that was the optional library name containing the method.
         % TO DO: I'm currently ignoring this.
         [
            | pName :
               pStrLit
               % that was the optional method name defined in that library,
               % which might differ from the Pascal name.
               oNodeSetString( decl, qExternalName, CURRENT_STRLIT )
            | * :
         ]
      | * :
   ]
   ;


ProcDecl:
   pIdent

   % If we already have a forward declaration, we'll modify that decl
   % instead of creating a second symbol table entry.
   % (Alternatively could delete or hide the old entry.)
   boolean redeclaring = false
   Node decl = oScopeFindInCurrentScope

   [ oNodeNull( decl )
      | true :
         % first declaration
         decl = @newIdent( nProc, kProc, LAST_ID )
         oNodeSetLabel( decl, qValue, oLabelNew )

      | false :
         % we already have a declaration.
         % Keep it, and its label.
         redeclaring = true
         [ oNodeGetBoolean( decl, qBodyDefined )
            | true : #eAlreadyDefined
            | * :
         ]
         [ oNodeGetBoolean( decl, qExternal )
            | true : #eAlreadyDefined
            | * :
         ]
         [ oNodeType( decl )
            | nProc :
            | * : #eAlreadyDefined   % wrong kind
         ]
         % Move the existing param scope aside, so we can check that the
         % new one is consistent.  And, the body will want to see the new one
         % since the names might differ.
         % TO DO: If qOldParams already set, we have multiple forward decls,
         % which I believe is supposed to be an error.
         oNodeSet( decl, qOldParams, oNodeGet( decl, qParams ) )
         oNodeSet( decl, qParams, Null )
   ]

   int level = oNodeGetInt( oScopeCurrent, qLevel )
   boolean nested = greater( level, 0 )
   inc( level )
   oScopeBegin( level )
   Node paramScope = oScopeCurrent

   % A nested method has a hidden first param for the parent static scope.
   % This won't appear in the param decls list, just reserve space for it.
   % It's first so the static chain is always at a fixed offset from the frame pointer.
   [ nested
      | true :
         int offset = oScopeAllocType( @PointerTypeTo( IntegerType ) )   % arbitrary ptr type
      | * :
   ]

   @FormalArgDecl
   oNodeSet( decl, qParams, paramScope )
   oScopeEnd
   ';'

   [ redeclaring
      | false : oScopeDeclare( decl )
      | true :  % TO DO: check that qParams is consistent with qOldParams
   ]

   @MethodModifiers( decl )

   % Body may be a statement, "forward", "external".
   % Note, this syntax is based on FPC, and I'm not sure if other Pascals are similar.
   % FPC says that forward, external, cdecl, name, etc are not reserved words -
   % I think this means the user may declare other things with those names, but if so the
   % original meaning is lost.  I'll make them keywords for simplicity, for now
   % (just not too happy about "name").

   [
      | pForward :
         % Nothing to do.  We simply won't set qBodyDefined.

      | pExternal : @ExternalDecl( decl )

      | * :
         % Body statement

         % Enter the params scope again, so params are visible in body.
         % TO DO: Perhaps I could mark the scope read-only at this point.
         oScopeEnter( paramScope )

         % Start scope for declarations within the proc
         oScopeBegin( level )
         oNodeSetBoolean( oScopeCurrent, qAllocDown, true )
         oNodeSet( decl, qChildScope, oScopeCurrent )

         Label label = oNodeGetLabel( decl, qValue )
         @Block( nLocalVar, label )
         oNodeSetBoolean( decl, qBodyDefined, true )
         oScopeEnd

         oScopeEnd  % paramScope
   ]
   ';';


FuncDecl:
   pIdent

   % If we already have a forward declaration, we'll modify that decl
   % instead of creating a second symbol table entry.
   % (Alternatively could delete or hide the old entry.)
   boolean redeclaring = false
   Node decl = oScopeFindInCurrentScope

   [ oNodeNull( decl )
      | true :
         % first declaration
         decl = @newIdent( nFunc, kFunc, LAST_ID )
         oNodeSetLabel( decl, qValue, oLabelNew )

      | false :
         % we already have a declaration.
         % Keep it, and its label.
         redeclaring = true
         [ oNodeGetBoolean( decl, qBodyDefined )
            | true : #eAlreadyDefined
            | * :
         ]
         [ oNodeType( decl )
            | nFunc :
            | * : #eAlreadyDefined   % wrong kind
         ]
         % Move the existing param scope and return value aside,
         % so we can check that the new one is consistent.
         % And, the body will want to see the new one since the names might differ.
         % TO DO: If qOldParams already set, we have multiple forward decls,
         % which I believe is supposed to be an error.
         oNodeSet( decl, qOldParams, oNodeGet( decl, qParams ) )
         oNodeSet( decl, qParams, Null )
         oNodeSet( decl, qOldType, oNodeGet( decl, qType ) )
         oNodeSet( decl, qType, Null )
   ]

   int level = oNodeGetInt( oScopeCurrent, qLevel )
   boolean nested = greater( level, 0 )
   inc( level )
   oScopeBegin( level )
   Node paramScope = oScopeCurrent

   % A nested method has a hidden first param for the parent static scope.
   % This won't appear in the param decls list, just reserve space for it.
   % It's first so the static chain is always at a fixed offset from the frame pointer.
   [ nested
      | true :
         int offset = oScopeAllocType( @PointerTypeTo( IntegerType ) )   % arbitrary ptr type
      | * :
   ]

   @FormalArgDecl
   oNodeSet( decl, qParams, paramScope )

   ':'

   Node theType
   @TypeRef( theType )
   oNodeSet( decl, qType, theType )

   % The function's param space gets an additional pointer,
   % which will point to a temporary in the caller's scope.
   % This pointer is essentially a VAR param, but I won't create an nParam for it.

   Node ptrType = @PointerTypeTo( theType )
   oNodeSetInt( decl, qResultOffset, oScopeAllocType( ptrType ) )
   oScopeEnd
   ';'

   [ redeclaring
      | false : oScopeDeclare( decl )
      | true :  % TO DO: check that qParams is consistent with qOldParams
                % and qType is consistent with qOldType
   ]

   @MethodModifiers( decl )

   % Body may be a statement, "forward", "external".
   [
      | pForward :
         % Nothing to do.  We simply won't set qBodyDefined.

      | pExternal : @ExternalDecl( decl )

      | * :
         % Body statement

         % Enter the params scope again, so params are visible in body.
         % TO DO: Perhaps I could mark the scope read-only at this point.
         oScopeEnter( paramScope )

         oScopeBegin( level )
         oNodeSetBoolean( oScopeCurrent, qAllocDown, true )
         oNodeSet( decl, qChildScope, oScopeCurrent )

         Label label = oNodeGetLabel( decl, qValue )
         @Block( nLocalVar, label )
         oNodeSetBoolean( decl, qBodyDefined, true )
         oScopeEnd

         oScopeEnd  % paramScope
   ]
   ';';


FormalArgDecl:
   [
      | '(' :
         {
            NodeVec decls = oNodeVecNew
            Node decl
            boolean isInOut = false

            [
               | pVar : isInOut = true
               | * :
            ]

            {  pIdent

               decl = @newIdent( nParam, kVar, LAST_ID )
               oNodeSetBoolean( decl, qInOut, isInOut )
               oNodeVecAppend( decls, decl )

               [
                  | ':' : >
                  | ',' :
               ]
            }

            Node theType
            @TypeRef( theType )

            % VAR param is declared with its given type, but allocated as a pointer.
            Node allocType
            [ isInOut
               | true :   allocType = @PointerTypeTo( theType )
               | * :      allocType = theType
            ]

            int i = 0
            {[ equal( i, oNodeVecSize( decls ) )
               | false :
                  decl = oNodeVecElement( decls, i )

                  oNodeSet( decl, qType, theType )
                  oScopeDeclare( decl )
                  oNodeSetInt( decl, qValue, oScopeAllocType( allocType ) )
                  inc( i )
               | * :
                  >
            ]}

            oNodeVecDelete( decls )

            [
               | ')' : >
               | ';' :
            ]
         }
      | * :
   ];

ConstDecl:
   {[
      | pIdent :
         Node decl = @newIdent( nConst, kConst, LAST_ID )
         '='

         @ConstExpr
         % TO DO: currently ConstExpr leaves int result on oValue stack
         int val = oValueTop
         oValuePop
         oNodeSetInt( decl, qValue, val )

         % TO DO: different types.  Currently assumes int!
         oNodeSet( decl, qType, IntegerType )

         oScopeDeclare( decl )
         ';'
      | * :
         >
   ]};

TypeDecl:
   {[
      | pIdent :
         Node decl = @newIdent( nTypeDecl, kType, LAST_ID )
         '='
         Node theType
         @TypeRef( theType )
         oNodeSet( decl, qType, theType )
         oScopeDeclare( decl )
         ';'
      | * :
         >
   ]};

VarDecl( node_type varNodeType ):
   {[
      | pIdent :
         NodeVec decls = oNodeVecNew
         Node decl
         {
            decl = @newIdent( varNodeType, kVar, LAST_ID )
            oNodeVecAppend( decls, decl )
            [
               | ',' :
                  pIdent
               | * :
                  >
            ]
         }
         ':'
         Node theType
         @TypeRef( theType )

         int i = 0
         {[ equal( i, oNodeVecSize( decls ) )
            | false :
               decl = oNodeVecElement( decls, i )
               oNodeSet( decl, qType, theType )
               oScopeDeclareAlloc( decl )
               inc( i )
            | * :
              >
         ]}

         % optional initialization
         [
            | '=' :
               [ oNodeVecSize( decls )
                  | 1 :
                  | * :  #eOnlyOneVarCanBeInitialized
               ]

               % we need an initCode stream for this scope
               Code initCode = @GetOrCreateInitCode
               oCodePush( initCode )

               % currently the global level has two scopes:
               % the one for declarations e.g. vars and methods,
               % and a second one for temporaries needed by the main block stmt.
               % During evaluation of the init expr, we need to be in the 2nd scope
               % in case the expression requires temporaries
               % (so the temporaries get allocated in the right scope).
               % TO DO: Maybe I should make the global scope the special case, instead.
               boolean changedScope = false
               [ equal_node( oScopeCurrent, globalScope )
                  | true : oScopeEnter( mainRoutineScope )
                           changedScope = true
                  | * :
               ]
               % generate assignment in initCode stream
               @LValueVar( decl )
               @Expr
               @MatchTypes
               @Assign
               [ changedScope
                  | true : oScopeEnd
                  | * :
               ]
               oCodePop
             
            | * :
         ]

         oNodeVecDelete( decls )
         ';'
      | * :
         >
   ]};


% Parse a type reference, returning the nType.
% This will add types to the type table, as needed.
%
% Style question - at the moment I think callers look clearer if we use
% an out param here, rather than a return value.
%
TypeRef( out Node resultType ):
   [
      | pIdent :           % previously named type (including intrinsics)
         Node decl = oScopeFindRequire
         [ oNodeType( decl )
           | nTypeDecl :
               resultType = oNodeGet( decl, qType )
           | * :
               #eNotType
               resultType = IntegerType
         ]
   
      | pArray :
         '['

         % A multi-dimensional array is represented as a chain
         %    array [subrange1] of array [subrange2] of elementType

         % First, we build a vector of nArray's, each with one subrange as its index type,
         % but without setting the "of" type or size.

         NodeVec dimensions = oNodeVecNew

         {
            % to do: probably should use general subrange parsing, incl minimal size value
            %   In fact, supposed to parse ordinal_type here.  all ordinal types have a static low, high.
            %   Not necessary to be a subrange.

            Node subrange = oNodeNew( nSubrangeType )
            % TO DO: currently assuming subrange of integer
            oNodeSet( subrange, qBaseType, IntegerType )

            % TO DO: currently ConstExpr leaves int result on oValue stack
            @ConstExpr
            oNodeSetInt( subrange, qLow, oValueTop )
            oValuePop
            '..'
            @ConstExpr
            oNodeSetInt( subrange, qHigh, oValueTop )
            oValuePop
            oNodeSetInt( subrange, qSize, 4 )   % maybe don't need

            oTypeAdd( subrange )

            Node a = oNodeNew( nArrayType )
            oNodeSet( a, qIndexType, subrange )

            oNodeVecAppend( dimensions, a )
            % I'll hold off on adding 'a' to the type table since not fully formed yet

            [
               | ']' : >
               | ',' :
            ]
         }

         pOf
         Node baseType
         @TypeRef( baseType )

         % Work backwards through the dimensions,
         % hooking up the 'of' type and calculating the size.
         % At each iteration, baseType is the 'of' type.

         int dim = oNodeVecSize( dimensions )

         {
             dec(dim)

             Node a = oNodeVecElement( dimensions, dim )

             oNodeSet( a, qBaseType, baseType )
             Node subrange = oNodeGet( a, qIndexType )
             int width = subtract( oNodeGetInt( subrange, qHigh ), oNodeGetInt( subrange, qLow ) )
             inc( width )
             oNodeSetInt( a, qSize, multiply( width, oNodeGetInt( baseType, qSize ) ) )

             oTypeAdd( a )
             baseType = a

             [ equal_zero(dim)
                 | true:  >
                 | *:
             ]
         }

         resultType = oNodeVecElement( dimensions, 0 )
         oNodeVecDelete( dimensions )

      | '^' :
         Node theType
         @TypeRef( theType )
         resultType = @PointerTypeTo( theType )

      | pRecord :
         resultType = oNodeNew( nRecordType )
         oScopeBegin( -1 )    % level is meaningless here

         @VarDecl( nRecordField )

         int size = oNodeGetInt( oScopeCurrent, qSize )
         % to do: padding
         [ equal_zero( size )
            | true : #eRecordEmpty
            | * :
         ]

         pEnd

         oNodeSet( resultType, qScope, oScopeCurrent )
         oNodeSetInt( resultType, qSize, size )
         oScopeEnd
         oTypeAdd( resultType )


      % *** TO DO: following type constructors are not implemented *** 
      % *** TO DO: also missing declaration of enum type
      | pSet :
         pOf
         Node theType
         @TypeRef( theType )
      | * :       % this works for cases except where expr starts with an id
         @ConstExpr '..' @ConstExpr
   ];


% --------------------------- Const Expressions --------------------------

% Constant expressions: currently, only literal integers or previously
% named constant integers are supported, possibly with a negation.
% Constant expressions are evaluated at compile time.

ConstExpr:
   [
      | pIntLit :
         oValuePush( TOKEN_VALUE )
      | pIdent :
         Node decl = oScopeFindRequire
         [ oNodeType( decl )
            | nConst :
               oValuePush( oNodeGetInt( decl, qValue ) )
            | * :
               #eNotConst
               oValuePush( 0 )
         ]
      | pMinus :
         @ConstExpr
         oValueNegate
   ];



% ------------------------------ Expressions -----------------------------

% There are two wrappers leading into expression parsing:
%   Expr()
%   BooleanExprControlFlow( out Label falseLabel )
%
% Expr always produces a value on the runtime expr stack,
% and pushes its type on the type stack.
%
% BooleanExprControlFlow always generates control-flow code.
% It does not push a value on the runtime expr stack.
% It does not push a type on the type stack.
% The control flow code ends up at Here if the expr is true,
% and jumps to falseLabel if the expr is false.
% This rule allocates falseLabel, and passes it back.
% The caller will need to define its location.
%
% The internal methods of expr parsing may produce a mix of
% values and control flow, depending on the operators seen.
% We don't always do one or the other, hoping to be efficient for
% cases like   "func_call( bool_var1, bool_var2 )"
% as well as  "if bool_expr1 or bool_expr2 then ...".
% If a subexpression rule produces control flow, it will allocate a
% falseLabel and pass it back up.  And it will push the
% result type as BooleanCFType, to distinguish from BooleanType
% which corresponds with a boolean value on the expr stack.
% 
% Note that my expression parsing is broken into more levels than
% grammars describe for Pascal precedence levels.  This follows my
% original parser implementation.  I think my rationale was that
% operators from the levels that I split up couldn't have been
% mixed anyway, since they require different data types
% (e.g. boolean vs int/real).  And splitting them up simplified
% my code.  But, I should revisit this.
%


% Public entry point:
%
% Parse an expression, leaving a value on the runtime expr stack
% and its type on the type stack.
%
% This rule does not export control flow (though it may generate
% control flow internally for subexpressions).
%
Expr:
   Label falseLabel = labelNull

   @ExprAllowCF( falseLabel )
   @CFToVal( falseLabel );


% Public entry point:
%
% Parse a Boolean expression, producing control flow code rather than a value.
% Does not leave a value on the runtime expr stack.
% Does not leave a type on the type stack.
%
% If the expression is true, the code will fall through to the end (Here).
% If the expression is false, the code will jump to the given falseLabel,
% which this rule will allocate but not define the location for.
% The caller must do so.
%
BooleanExprControlFlow( out Label falseLabel ):
   @ExprAllowCF( falseLabel )
   [ oTypeSNodeType
      | nBooleanCFType :
      | nBooleanType :
         % convert value to control flow
         falseLabel = oLabelNew
         .tJumpFalse  oEmitLabel( falseLabel )
      | * :
         #eNotBoolean
   ]
   oTypeSPop;


% If the current expr result is control flow, convert it to a value.
% falseLabel is the label that had been used by the control flow.
% On return it will be set to labelNull.
%
CFToVal( inout Label falseLabel ):
   [ oTypeSNodeType
      | nBooleanCFType :
         Label doneLabel = oLabelNew
         .tPushConstI  oEmitInt( 1 )
         .tJump  oEmitLabel( doneLabel )
         .tLabel  oEmitLabel( falseLabel )
         .tPushConstI  oEmitInt( 0 )
         .tLabel  oEmitLabel( doneLabel )
         oTypeSPop
         oTypeSPush( BooleanType )
         falseLabel = labelNull
      | * :
   ];


% If the current expr result is boolean value, convert it to control flow.
% falseLabel will be allocated by this rule and passed back.
% The caller must define its location.
%
ValToCF( out Label falseLabel ):
   [ oTypeSNodeType
      | nBooleanType :
         falseLabel = oLabelNew
         .tJumpFalse  oEmitLabel( falseLabel )
         oTypeSPop
         oTypeSPush( BooleanCFType )
      | * :
   ];


% Parse an expression.  It may produce a value on the expr stack,
% or control flow, depending on what's seen in the expression.
% Leaves the expression type on the type stack.
%
% If the expression produces control flow, the expression type will be
% nBooleanCFType.  In this case, a true value falls through to Here,
% and a false value jumps to falseLabel.  This rule will allocate falseLabel
% and return it, but will not define its location; the caller must do so.
%
% If the expression produces a value, the value will be left on the
% expression stack, and the type will be some type other than nBooleanCFType.
% In this case, falseLabel is ignored.
%
ExprAllowCF( out Label falseLabel ):
   @BoolExprAllowCF( falseLabel )
   {[
      | '=' :
         @CFToVal( falseLabel )
         @BoolExprAllowCF( falseLabel )
         @CFToVal( falseLabel )
         @MatchTypes
         [ oTypeSNodeType
            | nIntegerType, nBooleanType :  .tEqualI
            | nPointerType :                .tEqualP
            | nCharType, nStringType :      #eNotImplemented
            | * :                           #eNotAllowed
         ]
         oTypeSPop
         oTypeSPush( BooleanType )

      | '<>' :
         @CFToVal( falseLabel )
         @BoolExprAllowCF( falseLabel )
         @CFToVal( falseLabel )
         @MatchTypes
         [ oTypeSNodeType
            | nIntegerType, nBooleanType :  .tNotEqualI
            | nPointerType :                .tNotEqualP
            | nCharType, nStringType :      #eNotImplemented
            | * :                           #eNotAllowed
         ]
         oTypeSPop
         oTypeSPush( BooleanType )

      | '<' :
         @CFToVal( falseLabel )
         @BoolExprAllowCF( falseLabel )
         @CFToVal( falseLabel )
         @MatchTypes
         [ oTypeSNodeType
            | nIntegerType, nBooleanType :  .tLessI
            | nCharType, nStringType :      #eNotImplemented
            | * :                           #eNotAllowed
         ]
         oTypeSPop
         oTypeSPush( BooleanType )

      | '>' :
         @CFToVal( falseLabel )
         @BoolExprAllowCF( falseLabel )
         @CFToVal( falseLabel )
         @MatchTypes
         [ oTypeSNodeType
            | nIntegerType, nBooleanType :  .tGreaterI
            | nCharType, nStringType :      #eNotImplemented
            | * :                           #eNotAllowed
         ]
         oTypeSPop
         oTypeSPush( BooleanType )

      | '<=' :
         @CFToVal( falseLabel )
         @BoolExprAllowCF( falseLabel )
         @CFToVal( falseLabel )
         @MatchTypes
         [ oTypeSNodeType
            | nIntegerType, nBooleanType :  .tLessEqualI
            | nCharType, nStringType :      #eNotImplemented
            | * :                           #eNotAllowed
         ]
         oTypeSPop
         oTypeSPush( BooleanType )

      | '>=' :
         @CFToVal( falseLabel )
         @BoolExprAllowCF( falseLabel )
         @CFToVal( falseLabel )
         @MatchTypes
         [ oTypeSNodeType
            | nIntegerType, nBooleanType :  .tGreaterEqualI
            | nCharType, nStringType :      #eNotImplemented
            | * :                           #eNotAllowed
         ]
         oTypeSPop
         oTypeSPush( BooleanType )

      | * :
         >
   ]};


BoolExprAllowCF( out Label falseLabel ):
   Label trueLabel = labelNull

   @BoolTermAllowCF( falseLabel )
   {[
      | pOr :
         [ oTypeSNodeType
            | nBooleanCFType :
               % We are true here. Jump ahead to done
               [ equal_label( trueLabel, labelNull )
                  | true :  trueLabel = oLabelNew
                  | * :
               ]
               .tJump  oEmitLabel( trueLabel )
            | nBooleanType :
               @ValToCF( falseLabel )
               % We are true here. Jump ahead to done
               [ equal_label( trueLabel, labelNull )
                  | true :  trueLabel = oLabelNew
                  | * :
               ]
               .tJump  oEmitLabel( trueLabel )
            | * : #eNotBoolean
         ]
         oTypeSPop

         % false in previous term will jump here, to try this alternative term
         .tLabel  oEmitLabel( falseLabel )

         % we'll get a new falseLabel for this term
         falseLabel = labelNull
         @BoolTermAllowCF( falseLabel )

         [ oTypeSNodeType
            | nBooleanCFType :
            | nBooleanType :
               @ValToCF( falseLabel )
            | * : #eNotBoolean
         ]

         oTypeSPop
         oTypeSPush( BooleanCFType )

      | * :
         >
   ]}

   % any short-circuit trues jump here to the end
   [ equal_label( trueLabel, labelNull )
      | false :
         .tLabel  oEmitLabel( trueLabel )
      | * :
   ]
   ;


BoolTermAllowCF( out Label falseLabel ):
   Label overallFalseLabel = labelNull

   @BoolFactorAllowCF( falseLabel )
   {[
      | pAnd :
         [ oTypeSNodeType
            | nBooleanCFType :
            | nBooleanType :
               @ValToCF( falseLabel )
            | * :
               #eNotBoolean
         ]
         oTypeSPop

         % We're going to have a different falseLabel for each term,
         % because we let each rule allocate its own (rather than accepting labels passed in).
         % And in this case we want them all to go to the same place,
         % to be determined by the caller.
         %
         % I'll allow for label aliases.  This will be more optimal than generating
         % multiple private false-handling code segments, that the true path would have to
         % jump around.  That would be hard to eliminate afterwards.

         [ equal_label( overallFalseLabel, labelNull )
            | true :
               overallFalseLabel = oLabelNew
               .tLabelAlias  oEmitLabel( falseLabel )  oEmitLabel( overallFalseLabel )
               falseLabel = overallFalseLabel
            | * :
         ]

         Label factorFalseLabel = labelNull
         @BoolFactorAllowCF( factorFalseLabel )

         [ oTypeSNodeType
            | nBooleanCFType :
            | nBooleanType :
               @ValToCF( factorFalseLabel )
            | * : #eNotBoolean
         ]
        .tLabelAlias  oEmitLabel( factorFalseLabel )  oEmitLabel( overallFalseLabel )

      | * :
         >
   ]};

BoolFactorAllowCF( out Label falseLabel ):
   [
      | pNot :
         Label factorFalseLabel = labelNull

         @BoolFactorAllowCF( factorFalseLabel )
         [ oTypeSNodeType
            | nBooleanCFType :
               % We have control flow, and are sitting at the point that has value false.
               falseLabel = oLabelNew
               .tJump  oEmitLabel( falseLabel )
               % The true path jumps here
               .tLabel  oEmitLabel( factorFalseLabel )

            | nBooleanType :
               % I have a value.  I'll leave it as a value, rather than create control flow.
               % See how this goes.
               .tNot

            | * : #eNotBoolean
         ]

      | * :
         @ArithExprAllowCF( falseLabel )
   ];

ArithExprAllowCF( out Label falseLabel ):
   @TermAllowCF( falseLabel )
   {[
      | pPlus :
         @RequireIntPop
         @TermAllowCF( falseLabel )  % actually not allowing CF, will be caught by type check
         @RequireInt
         .tAddI
      | pMinus :
         @RequireIntPop
         @TermAllowCF( falseLabel )
         @RequireInt
         .tSubI
      | * :
         >
   ]};

TermAllowCF( out Label falseLabel ):
   @FactorAllowCF( falseLabel )
   {[
      | pTimes :
         @RequireIntPop
         @FactorAllowCF( falseLabel )  % actually not allowing CF, will be caught by type check
         @RequireInt
         .tMultI
      | pDivide :
         @RequireIntPop
         @FactorAllowCF( falseLabel )
         @RequireInt
         .tDivI
      | * :
         >
   ]};

FactorAllowCF( out Label falseLabel ):
   [
      | pPlus :
         @PrimaryAllowCF( falseLabel )  % actually not allowing CF, will be caught by type check
         @RequireInt
      | pMinus :
         @PrimaryAllowCF( falseLabel )
         @RequireInt
         .tNegI
      | * :
         @PrimaryAllowCF( falseLabel )
   ];

PrimaryAllowCF( out Label falseLabel ):
   [
      | pIntLit :
         .tPushConstI  oEmitInt( TOKEN_VALUE )
         oTypeSPush( IntegerType )

      | '(' :
         @ExprAllowCF( falseLabel )
         ')'

      | pStrLit :
         int addr = oStringAllocLit( CURRENT_STRLIT )     % store in global data
         .tPushAddrGlobal oEmitInt( addr )
         % TO DO: do we need to create a type with the literal's length?
         oTypeSPush( StringType )

      | pIdent :
         Node decl = oScopeFindRequire
         Node theType

         [ oNodeType( decl )
            | nFunc :

               @Call( decl )

            | nConst :
               theType = oNodeGet( decl, qType )
               oTypeSPush( theType )
               [ oTypeSNodeType
                  | nIntegerType, nBooleanType :
                     .tPushConstI @EmitValue( decl )
                  | * :
                     #eNotImplemented
               ]

            | nGlobalVar, nLocalVar, nParam :
               @VarExpr( decl )

            | * :
               #eNotValue
               oTypeSPush( IntegerType )
         ]

      | '@' :        % @var -- pointer to var
         pIdent

         Node decl = oScopeFindRequire
         Node theType

         @LValueVar( decl )

         % The above leaves the pointed-to type on type stack.
         % Replace with ptr-to-<type>.
         theType = oTypeSTop
         oTypeSPop
         Node ptrType = @PointerTypeTo( theType )
         oTypeSPush( ptrType )

      | * :
         #eNotValue
         oTypeSPush( IntegerType )
   ];


% Parse a variable expression, given the declaration of the
% just-accepted identifier.
% Leaves the value on the expression stack, and type on the type stack.
%
VarExpr( Node decl ):
   Node theType = oNodeGet( decl, qType )
   % how many levels up the static scope? Will ignore for globals.
   int uplevels = @DeclUpLevels( decl )

   oTypeSPush( theType )
   [ oTypeSNodeType
      | nIntegerType :
         [ oNodeType( decl )
            | nGlobalVar :   .tPushGlobalI  @EmitValue( decl )
            | nLocalVar :
               [ equal_zero( uplevels )
                  | true :  .tPushLocalI  @EmitValue( decl )
                  | * :     .tPushUpLocalI  oEmitInt( uplevels )  @EmitValue( decl )
               ]
            | nParam :
               [ oNodeGetBoolean( decl, qInOut )
                  | true :    % VAR param points to the var.  Auto dereference.
                     [ equal_zero( uplevels )
                        | true :  .tPushParamP  @EmitValue( decl )
                        | * :     .tPushUpParamP  oEmitInt( uplevels )  @EmitValue( decl )
                     ]
                     .tFetchI
                  | * :
                     [ equal_zero( uplevels )
                        | true :  .tPushParamI  @EmitValue( decl )
                        | * :     .tPushUpParamI  oEmitInt( uplevels )  @EmitValue( decl )
                     ]
               ]
         ]

      | nBooleanType :
         [ oNodeType( decl )
            | nGlobalVar :   .tPushGlobalB  @EmitValue( decl )
            | nLocalVar :
               [ equal_zero( uplevels )
                  | true :  .tPushLocalB  @EmitValue( decl )
                  | * :     .tPushUpLocalB  oEmitInt( uplevels )  @EmitValue( decl )
               ]
            | nParam :
               [ oNodeGetBoolean( decl, qInOut )
                  | true :    % VAR param points to the var.  Auto dereference.
                     [ equal_zero( uplevels )
                        | true :  .tPushParamP  @EmitValue( decl )
                        | * :     .tPushUpParamP  oEmitInt( uplevels )  @EmitValue( decl )
                     ]
                     .tFetchB
                  | * :
                     [ equal_zero( uplevels )
                        | true :  .tPushParamB  @EmitValue( decl )
                        | * :     .tPushUpParamB  oEmitInt( uplevels )  @EmitValue( decl )
                     ]
               ]
         ]

      | nCharType, nStringType, nFileType :
         #eNotImplemented

      | nPointerType :
         [ oNodeType( decl )
            | nGlobalVar :   .tPushGlobalP @EmitValue( decl )
            | nLocalVar :
               [ equal_zero( uplevels )
                  | true :  .tPushLocalP  @EmitValue( decl )
                  | * :     .tPushUpLocalP  oEmitInt( uplevels )  @EmitValue( decl )
               ]
            | nParam :
               [ oNodeGetBoolean( decl, qInOut )
                  | true :    % VAR param points to the var.  Auto dereference.
                     [ equal_zero( uplevels )
                        | true :  .tPushParamP  @EmitValue( decl )
                        | * :     .tPushUpParamP  oEmitInt( uplevels )  @EmitValue( decl )
                     ]
                     .tFetchP
                  | * :
                     [ equal_zero( uplevels )
                        | true :  .tPushParamP  @EmitValue( decl )
                        | * :     .tPushUpParamP  oEmitInt( uplevels )  @EmitValue( decl )
                     ]
               ]
         ]
         [
            | '^' :             % dereferenced
               oTypeSPop
               oTypeSPush( oNodeGet( theType, qBaseType ) )
               @LValueIndexes
               @FetchVar
            | * :               % just ptr value alone
         ]

      | * :
         % compound type
         % first, push addr of start of var
         [ oNodeType( decl )
            | nGlobalVar :   .tPushAddrGlobal @EmitValue( decl )
            | nLocalVar :
               [ equal_zero( uplevels )
                  | true :  .tPushAddrLocal  @EmitValue( decl )
                  | * :     .tPushAddrUpLocal  oEmitInt( uplevels )  @EmitValue( decl )
               ]
            | nParam :
               [ oNodeGetBoolean( decl, qInOut )
                  | true :    % VAR param points to the var.  Auto dereference.
                     [ equal_zero( uplevels )
                        | true :  .tPushParamP  @EmitValue( decl )
                        | * :     .tPushUpParamP  oEmitInt( uplevels )  @EmitValue( decl )
                     ]
                  | * :
                     [ equal_zero( uplevels )
                        | true :  .tPushAddrParam  @EmitValue( decl )
                        | * :     .tPushAddrUpParam  oEmitInt( uplevels )  @EmitValue( decl )
                     ]
               ]
         ]
         % modify addr for subscripts, field references, etc
         @LValueIndexes
         % get final value
         @FetchVar
   ];


% Addr of start of var is on expr stack; type is on type stack.
% Replace expr stack with value of var.
% (In the case of compound vars, this remains as the addr of the var).

FetchVar:
   [ oTypeSNodeType
      | nIntegerType :   .tFetchI
      | nBooleanType :   .tFetchB
      | nCharType, nStringType, nFileType : #eNotImplemented
      | nPointerType :   .tFetchP
      | * :              % compound type; leave as addr
   ];


% Addr of start of var is already on run stack, and type is on type stack.
% Read subscripts, record fields, etc, to get final addr on run stack, and final type
% on type stack.

LValueIndexes:
   {[
      | '[' :       @ArraySubscripts
      | '.' :       @RecordFieldRef
      | '^' :       @PointerDeref
      | * :         >
   ]};

ArraySubscripts:
   [ oTypeSNodeType
      | nArrayType :
      | * :       #eNotArray
   ]
   {
      [ oTypeSNodeType
         | nArrayType :
         | * :    #eTooManySubscripts
      ]

      % low subscript of this dimension
      int low = @OrdinalLow( oNodeGet( oTypeSTop, qIndexType ) )

      % replace type stack with next dimension, or OF type
      Node baseType
      baseType = oNodeGet( oTypeSTop, qBaseType )
      oTypeSPop
      oTypeSPush( baseType )

      @Expr
      @RequireIntPop
      % adjust for low subscript
      [ equal_zero( low )
         | false :
            .tPushConstI oEmitInt( low ) .tSubI
         | * :
      ]

      % multiply by element size
      int size = oNodeGetInt( baseType, qSize )
      [ equal( size, 1 )
         | false :
            .tPushConstI oEmitInt( size ) .tMultI
         | * :
      ]

      % update start address
      .tAddPI
      [
         | ']' :  >
         | ',' :
      ]
   };


RecordFieldRef:
   [ oTypeSNodeType
      | nRecordType :
      | * :    #eNotRecord
   ]
   oScopeEnter( oNodeGet( oTypeSTop, qScope ) )
   pIdent
   Node field = oScopeFindRequire
   % oScopeFind searches all open scopes, so make sure we found nRecordField
   % which could only be seen in the local scope we entered above.
   [ oNodeType( field )
      | nRecordField :
      | * :   #eNotRecordField
   ]
   oScopeEnd
   int offset = oNodeGetInt( field, qValue )
   [ equal_zero( offset )
      | false :
         .tPushConstI oEmitInt( offset ) .tAddPI
      | * :
   ]

   % replace the type on the type stack, with the field type
   oTypeSPop
   oTypeSPush( oNodeGet( field, qType ) )
   ;


% ptr deref on left side, i.e. BEFORE addr of ptr var is on stack,
%                              AFTER addr of thing pointed to is on stack
PointerDeref:
   [ oTypeSNodeType
      | nPointerType :
      | * :       #eNotPointer
   ]
   .tFetchP           % now addr on stack is addr of what we're pointing to

   Node theType = oTypeSTop
   oTypeSPop
   oTypeSPush( oNodeGet( theType, qBaseType ) )
   ;


% The expr stack contains a value whose type is on top of the type stack.
% Generate code to coerce the value to the type under it in the type stack
% (pop the type stack, leaving only the desired type).
% This is used for assignment.
%
CoerceType:
   % TO DO: not implemented yet.  For now I require exact type match.
   @MatchTypes
   ;


% Called on first use of an extern method
%
DefineExternLabel( Node method ):
   % The extern name might be given explicitly, otherwise the pascal method name.
   int strAddr
   String externalName = oNodeGetString( method, qExternalName )
   [ equal_string( externalName, stringNull )
      | true :
         strAddr = oStringAllocLit( ID_STRING( oNodeGetInt( method, qIdent ) ) )
      | false :
         strAddr = oStringAllocLit( externalName )
   ]
   .tLabelExtern  @EmitValue( method )  oEmitInt( strAddr )
   ;


% Parse a call, given an nProc or nFunc for the just-accepted identifier.
% If a func, this will also generate the code to push the return value on the expr stack,
% and push the return type on the type stack.
%
Call( Node method ):

   % Prior to first call, issue extern label for a called method.
   % I don't want to issue .tLabelExtern for unused methods, that seems inefficient.
   [ oNodeGetBoolean( method, qExternal )
      | true :
         [ oNodeGetBoolean( method, qCalled )
            | false :
               % define the extern label on first use
               @DefineExternLabel( method )
            | * :
         ]
     | * :
   ]
   oNodeSetBoolean( method, qCalled, true )

   % If the method has a cdecl modifier, the back end will need to use the native
   % calling convention, instead of my own.  But, the convention varies by platform,
   % so the front end won't assume what it needs.  I'll still generate the normal tcode
   % that copies values into actuals space on the stack.
   % However, to help the back end, I will at least use a different instruction for the
   % allocation of the actuals space, and for the actual call.
   %
   % p.s. I only support cdecl on external methods, because I don't have a way
   % to let my own Pascal methods read params passed in with the cdecl calling convention.
   %
   boolean cdecl = oNodeGetBoolean( method, qCdecl )

   % If this is a function, we will allocate a temporary
   % in the current scope, to hold the result value.
   % And pass a pointer to that temporary as an extra parameter.
   Node resultType
   int tempOffset

   boolean isFunc = equal_node_type( oNodeType( method ), nFunc )

   [ isFunc
      | true :
         resultType = oNodeGet( method, qType )
         tempOffset = oScopeAllocType( resultType )
         % TO DO: we could manage temp allocation, so temp space can be reused
         %        by different code branches.
      | * :
   ]
   

   Node paramScope = oNodeGet( method, qParams )
   int actualsSize = oNodeGetInt( paramScope, qSize )
   [ cdecl
      | true : .tAllocActualsCdecl  oEmitInt( actualsSize )
      | false :  .tAllocActuals  oEmitInt( actualsSize )
   ]

   % If method is nested, it takes a hidden first parameter:
   % a pointer to the frame of the static scope in which the method is declared.
   % The location of a scope's frame is equivalent to offset 0 in the scope's locals space
   % (since local offsets are relative to the scope's frame pointer).
   %
   % The nested method may be in a higher scope (upLevels > 1),
   % or a sibling of the method we're in (upLevels = 1),
   % or an immediate child of the current method (upLevels = 0).
   %
   % To understand the upLevels computation, remember that a method's declaration
   % and its contents (variables, nested functions, and body statement)
   % are in two different scopes.

   [ greater( @DeclLevel( method ), 0 )
      | true :
         .tPushAddrActual  oEmitInt( 0 )    % hidden param is at param offset 0
         .tPushAddrUpLocal  oEmitInt( @DeclUpLevels( method ) )  oEmitInt( 0 )
         .tAssignP
      | * :
   ]


   NodeIter paramIter = oNodeGetIter( paramScope, qDecls )
   Node param = oNodeIterValue( paramIter )
   [
      | '(' :
      
         {
            [ oNodeNull( param )
               | true : >
               | * :
            ]

            int offset = oNodeGetInt( param, qValue )

            % Assign actual value to spot in actuals space
            .tPushAddrActual oEmitInt( offset )
            oTypeSPush( oNodeGet( param, qType ) )

            [ oNodeGetBoolean( param, qInOut )
               | true :   % A VAR param.
                          % The actual is a pointer to the value.
                          % The type on the type stack (pushed above) is for the pointed-to value.

                          @LValueExpr
                          % Addr of the referenced variable is on the expr stack,
                          % type of the variable is on the type stack.

                          % Match types more exactly. It's not sufficient to be assign compatible
                          % since the method will be assigning to the actual using the param type.
                          % Maybe something like type contents must match, incl subrange bounds.
                          @MatchTypes

                          .tAssignP

               | false :  @Expr
                          @CoerceType
                          
                          % Assign to offset in actuals space

                          [ oTypeSNodeType
                             | nIntegerType :            .tAssignI
                             | nBooleanType :            .tAssignB
                             | nCharType, nStringType, nFileType :   #eNotImplemented
                             | nPointerType :            .tAssignP
                             | * :
                                 % compound types: copy value into actuals space
                                 int size = oNodeGetInt( oTypeSTop, qSize )
                                 .tCopy  oEmitInt( size )    % multi-word copy
                          ]
            ]
            oTypeSPop

            oNodeIterNext( paramIter )
            param = oNodeIterValue( paramIter )
            [ oNodeNull( param )
               | true :  >
               | false :
            ]

            ','
         }

         ')'

      | * :
   ]

   [ oNodeNull( param )
      | false :    #eMissingParameter
      | * :
   ]

   [ isFunc
      | true :
         % Pass result temp as an additional VAR parameter.
         .tPushAddrActual oEmitInt( oNodeGetInt( method, qResultOffset ) )
         .tPushAddrLocal  oEmitInt( tempOffset )
         .tAssignP
      | * :
   ]

   [ cdecl
      | true :
         .tCallCdecl  @EmitValue( method )
      | false :
         .tCall   @EmitValue( method )
   ]

   [ isFunc
      | true :
         % push return value from temp
         oTypeSPush( resultType )

         [ oTypeSNodeType
            | nIntegerType :   .tPushLocalI  oEmitInt( tempOffset )
            | nBooleanType :   .tPushLocalB  oEmitInt( tempOffset )
            | nCharType, nStringType, nFileType : #eNotImplemented
            | nPointerType :   .tPushLocalP  oEmitInt( tempOffset )
            | * :              % compound type: push address
                               .tPushAddrLocal  oEmitInt( tempOffset )
         ]
      | * :
   ]
   
   .tFreeActuals  oEmitInt( actualsSize )
   ;


% ------------------------------ Statements -----------------------------

Statement:
   [
      | pWriteln :     @WritelnStmt
      | pWrite :       @WriteStmt
      | pReadln :      @ReadlnStmt
      | pRead :        @ReadStmt
      | pIf :          @IfStmt
      | pWhile :       @WhileStmt
      | pFor :         @ForStmt
      | pRepeat :      @RepeatStmt
      | pBreak :       @BreakStmt
      | pContinue :    @ContinueStmt
      | pBegin :       @BeginStmt
      | pIdent :       @AssignOrCallStmt
      | * :            % null statement : don't accept any tokens
   ];


AssignOrCallStmt:
   Node decl = oScopeFindRequire
   [ oNodeType( decl )
      | nProc :                           @Call( decl )
      | nGlobalVar, nLocalVar, nParam :   @AssignStmt( decl )
      | nFunc :                           @AssignResultStmt( decl )
      | * :                               #eBadStatement
   ];


% Given decl, the just-accepted first identifier on the left hand side.
%
AssignStmt( Node decl ):

   @LValueVar( decl )
   ':=' 
   @Expr
   @MatchTypes
   @Assign
   ;


% Performs a raw assignment.
% Given lvalue 2nd on stack, and expr value top of stack,
% and type of both of these on the type stack,
% perform the assignment and pop the type off the type stack.
%
Assign:
   [ oTypeSNodeType
      | nIntegerType :            .tAssignI
      | nBooleanType :            .tAssignB
      | nCharType, nStringType, nFileType :   #eNotImplemented

      % compound var assigns; addrs of src, dest on stack
      | nPointerType :            .tAssignP
      | * :
          int size = oNodeGetInt( oTypeSTop, qSize )
          .tCopy  oEmitInt( size )    % multi-word copy
   ]
   oTypeSPop
   ;

% Given nFunc for the just-accepted identifier on the left hand side.
% Parse an assignment that represents assignment of the function result.
%
AssignResultStmt( Node funcDecl ):
   % Only allowed to assign the result of the immediately enclosing function, I think.
   [ oNodeEqual( oNodeGet( funcDecl, qChildScope ), oScopeCurrent )
      | false :   #eNotCurrentFunction
      | * :
   ]

   % Result value is stored in the caller's space, via a hidden VAR parameter.
   .tPushParamP  oEmitInt( oNodeGetInt( funcDecl, qResultOffset ) )
   oTypeSPush( oNodeGet( funcDecl, qType ) )

   ':='
   @Expr
   @MatchTypes
   [ oTypeSNodeType
      | nIntegerType :            .tAssignI
      | nBooleanType :            .tAssignB
      | nCharType, nStringType, nFileType :   #eNotImplemented

      % compound var assigns; addrs of src, dest on stack
      | nPointerType :            .tAssignP
      | * :
          int size = oNodeGetInt( oTypeSTop, qSize )
          .tCopy  oEmitInt( size )    % multi-word copy
   ]
   oTypeSPop
   ;



% Parse an lvalue expression, from scratch.
% This is an expression that may appear on the left side of an assignment.
% Leaves the address of the value on the expr stack,
% and the type of the value at that address on the type stack.
%
LValueExpr:
   % At the moment, all lvalue expressions start with a variable name.
   % I think there can also be typecasts, not supported yet.  Check standard syntax.
   pIdent
   Node decl = oScopeFindRequire
   [ oNodeType( decl )
      | nGlobalVar, nLocalVar, nParam :
      | * :  #eNotVar
   ]
   @LValueVar( decl )
   ;


% Parse an lvalue expression (e.g. left side of an assign statement)
% that starts with the just-accepted identifier indicated by the given decl.
% Leaves the lvalue address on the expression stack,
% and the type of the value at that address on the type stack.
%
LValueVar( Node decl ):
   [ oNodeType( decl )
      | nGlobalVar :   .tPushAddrGlobal @EmitValue( decl )
      | nLocalVar :    .tPushAddrLocal @EmitValue( decl )
      | nParam :
         [ oNodeGetBoolean( decl, qInOut )
            | true :   % VAR param points to variable.  No dereference.
                       .tPushParamP @EmitValue( decl )
            | * :      .tPushAddrParam @EmitValue( decl )
         ]
      | * :            #eNotVar
   ]

   oTypeSPush( oNodeGet( decl, qType ) )
   @LValueIndexes        % handle subscripts, if any
   ;


IncVar( Node decl ):
   @LValueVar( decl )
   @RequireIntPop
   @VarExpr( decl )
   oTypeSPop
   .tIncI
   .tAssignI;

DecVar( Node decl ):
   @LValueVar( decl )
   @RequireIntPop
   @VarExpr( decl )
   oTypeSPop
   .tDecI
   .tAssignI;


IfStmt:
   Label falseLabel = labelNull

   @BooleanExprControlFlow( falseLabel )
   pThen
   @Statement
   [
      | pElse :
         Label doneLabel = oLabelNew

         .tJump  oEmitLabel( doneLabel )
         .tLabel oEmitLabel( falseLabel )
         @Statement
         .tLabel oEmitLabel( doneLabel )

      | * :
         .tLabel oEmitLabel( falseLabel )
   ];


ForStmt:
   pIdent

   Node decl = oScopeFindRequire
   % TO DO: disallow use of a compound variable field.
   %        Could do that by disallowing use of LValueIndexes,
   %        or by double-checking the decl's qType here.
   @LValueVar( decl )
   @RequireIntPop

   ':='

   @Expr
   @RequireIntPop
   .tAssignI

   Label breakLabel = oLabelNew

   Label checkLabel = oLabelNew
   .tJump  oEmitLabel( checkLabel )

   Label continueLabel = oLabelNew
   .tLabel  oEmitLabel( continueLabel )
   [
      | pTo :
         @IncVar( decl )
         .tLabel  oEmitLabel( checkLabel )
         @VarExpr( decl )  oTypeSPop
         @Expr
         @RequireIntPop
         .tGreaterI
         .tJumpTrue  oEmitLabel( breakLabel )
      | pDownto :
         @DecVar( decl )
         .tLabel  oEmitLabel( checkLabel )
         @VarExpr( decl )  oTypeSPop
         @Expr
         @RequireIntPop
         .tLessI
         .tJumpTrue  oEmitLabel( breakLabel )
   ]
   oLoopPush( continueLabel, breakLabel )
   pDo
   @Statement
   .tJump  oEmitLabel( continueLabel )
   .tLabel  oEmitLabel( breakLabel )
   oLoopPop;


RepeatStmt:
   Label continueLabel = oLabelNew
   .tLabel  oEmitLabel( continueLabel )

   Label breakLabel = oLabelNew

   oLoopPush( continueLabel, breakLabel )
   @Statement
   {[
      | ';' :
         @Statement
      | pUntil :
         Label falseLabel
         @BooleanExprControlFlow( falseLabel )
         .tLabelAlias  oEmitLabel( falseLabel )  oEmitLabel( continueLabel )
         >
   ]}
   .tLabel  oEmitLabel( breakLabel )
   oLoopPop;


WhileStmt:
   Label continueLabel = oLabelNew
   .tLabel  oEmitLabel( continueLabel )

   Label breakLabel
   @BooleanExprControlFlow( breakLabel )

   oLoopPush( continueLabel, breakLabel )
   pDo
   @Statement
   .tJump  oEmitLabel( continueLabel )
   .tLabel  oEmitLabel( breakLabel )
   oLoopPop;


ContinueStmt:                     % NOTE, for repeat..until, skips test (??)
   [ equal_label( oLoopContinueLabel, labelNull )
      | true :
         #eNotInALoop
      | false :
         .tJump  oEmitLabel( oLoopContinueLabel )
   ];


BreakStmt:
   [ equal_label( oLoopBreakLabel, labelNull )
      | true :
         #eNotInALoop
      | false :
         .tJump  oEmitLabel( oLoopBreakLabel )
   ];


BeginStmt:
   @Statement
   {[
      | ';' :   @Statement
      | pEnd :  >
   ]};


WritelnStmt:
   @WriteStmt
   .tWriteCR;


WriteStmt:
   [
      | '(' :
         {
            @Expr
            [ oTypeSNodeType
               | nIntegerType :             .tWriteI
               | nBooleanType :             .tWriteBool
               | nStringType :              .tWriteStr
               | nCharType, nFileType :     #eNotImplemented
               | nPointerType :             .tWriteP
               | * :                        #eNotAllowed
            ]
            oTypeSPop
            [
               | ')' : >
               | ',' :
            ]
         }
      | * :
   ];


ReadlnStmt:      % ***
   % TO DO
   ;

ReadStmt:
   % TO DO
   ;

% -------------------------------- Utilities -------------------------------


% Return the static scope level of the given declaration
%
DeclLevel( Node decl ) >> int:
   >> oNodeGetInt( oNodeGet( decl, qParentScope ), qLevel );
   

% How many levels higher is the given declaration from the current scope?
%
DeclUpLevels( Node decl ) >> int:
   >> subtract( oNodeGetInt( oScopeCurrent, qLevel ), @DeclLevel( decl ) );


% Require that the top two types on the type stack are matching (ignoring subranges).
% Pop one of them, leaving only one.
%
MatchTypes:
   node_type nt = oTypeSNodeType
   oTypeSPop
   [ equal_node_type( nt, oTypeSNodeType )
      | false :
         #eTypeMismatch
      | * :
   ];


% Require that the top type on the type stack is integer (ignoring subranges).
% Pop it.
%
RequireIntPop:
   [ oTypeSNodeType
      | nIntegerType :
      | * :          #eNotInteger
   ]
   oTypeSPop;

RequireInt:
   [ oTypeSNodeType
      | nIntegerType :
      | * :          #eNotInteger
   ];

RequireBoolPop:
   [ oTypeSNodeType
      | nBooleanType :
      | * :          #eNotBoolean
   ]
   oTypeSPop;

RequireBool:
   [ oTypeSNodeType
      | nBooleanType :
      | * :          #eNotBoolean
   ];


% Create and return a new nType of the given node_type, adding it to the type table.
%
newType( node_type nt, int size ) >> Node:
  Node node = oNodeNew( nt )
  oNodeSetInt( node, qSize, size )
  oTypeAdd( node )
  >> node
  ;


% Create and return a new nIdent of the given node_type, with the given ident id.
% Does not add it to any scope.
%
newIdent( node_type nt, kind k, int id ) >> Node:
  Node t = oNodeNew( nt )
  oNodeSetInt( t, qIdent, id )
  >> t
  ;


% Return an nType representing a pointer to the given type.
% (Creates a new type if necessary.)
%
PointerTypeTo( Node theType ) >> Node:
   Node ptrType = oNodeGet( theType, qPointerType )
   [ oNodeNull( ptrType )
      | true :
         ptrType = oNodeNew( nPointerType )
         oNodeSet( ptrType, qBaseType, theType )
         oNodeSetInt( ptrType, qSize, 8 )
         oTypeAdd( ptrType )
         oNodeSet( theType, qPointerType, ptrType )
      | * :
   ]
   >> ptrType;


% Return the low value of an ordinal type
%
OrdinalLow( Node theType ) >> int:
   [ oNodeType( theType )
      | nIntegerType :  >> oMININT
      | nBooleanType :  >> 0
      | nCharType :     >> 0
      | nSubrangeType : >> oNodeGetInt( theType, qLow )
      | * :             #eNotOrdinalType
                        >> 0
   ];


% Emit the value in a declaration.
% For a constant integer, this is the constant value.
% For a global variable, this is the global address.
% For a local variable, this is the local address relative to the call stack frame.
%
EmitValue( Node decl ):
    oEmitInt( oNodeGetInt( decl, qValue ));


installBuiltIns:

   % install built-in types
   FileType = @newType( nFileType, 4 )
   IntegerType = @newType( nIntegerType, 4 )
   BooleanType = @newType( nBooleanType, 1 )
   BooleanCFType = @newType( nBooleanCFType, 1 )
   CharType = @newType( nCharType, 1 )
   StringType = @newType( nStringType, 256 )    % string with default length 256

   % Declare those type identifiers.
   % SSL doesn't support strings, so need help from operations e.g. oIdAdd_File

   Node t

   t = @newIdent( nTypeDecl, kType, oIdAdd_File )
   oNodeSet( t, qType, FileType )
   oScopeDeclare( t )

   t = @newIdent( nTypeDecl, kType, oIdAdd_Integer )
   oNodeSet( t, qType, IntegerType )
   oScopeDeclare( t )

   t = @newIdent( nTypeDecl, kType, oIdAdd_Boolean )
   oNodeSet( t, qType, BooleanType )
   oScopeDeclare( t )

   t = @newIdent( nTypeDecl, kType, oIdAdd_Char )
   oNodeSet( t, qType, CharType )
   oScopeDeclare( t )

   t = @newIdent( nTypeDecl, kType, oIdAdd_String )
   oNodeSet( t, qType, StringType )
   oScopeDeclare( t )

   % Built-in constants

   t = @newIdent( nConst, kConst, oIdAdd_True )
   oNodeSet( t, qType, BooleanType )
   oNodeSetInt( t, qValue, 1 )
   oScopeDeclare( t )

   t = @newIdent( nConst, kConst, oIdAdd_False )
   oNodeSet( t, qType, BooleanType )
   oNodeSetInt( t, qValue, 0 )
   oScopeDeclare( t )

   ;

end

