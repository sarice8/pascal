title: 'Pascal Compiler 1.1.5 -- Jan 01 ''90';
   
%
%  Pascal.ssl
%
%  Pascal Compiler for the Amiga, by Steve Rice.
%
%  HISTORY
%    11Sep89   First version, framework of parser.
%    18Sep89   Added some semantic mechanisms.
%    21Sep89   Added simple type references; expressions generate code.
%    22Sep89   Allocate variable addresses as they're declared.
%    24Sep89   Added arrays, pointers.
%    27Sep89   Added for statement.
%    23Oct89   Fixed for statement, so CYCLE goes to next step.
%    01Jan90   Added string literals
%    09Sep22   I have returned.  Migrate symbol table to schema, to ease development.
%    01Oct22   Language: Switch from cycle/exit (Mac Pascal extension) to continue/break (Borland).
%
%  NOTES
%    -  The 'value' of a var symbol is its allocated address.
%    -  References to vars of intrinsic types, and pointer types,
%       pushes the value of the var on the expr stack.  Referenecs to
%       vars of compound types (arrays, records...) pushes the address
%       on the expr stack.
%    -  Just as there is only one type table entry for a given (named) type,
%       there is only one type table entry for a pointer to a named type.
%       When a pointer type is declared, a field in the TT entry of the
%       type pointed to will be set to indicate the TT entry of the pointer
%       to that type (0 means none defined yet).  When evaluating the
%       expression @x, the type in that field in the entry for the type of x
%       will be used (unless it's 0, in which case a new TT entry will be
%       created).
%
%
%  MISSING
%
%    - Consider non-ISO extensions.  e.g. 
%      Dynamic arrays.  Objects.  But, perhaps stick to my old goal, standard Pascal.
%
%  PASCAL DOCS
%      Here's some handy language material:
%      https://www.freepascal.org/docs-html/ref/ref.html
%      https://www.freepascal.org/docs-html/prog/prog.html
%      https://en.wikipedia.org/wiki/Turbo_Pascal
%      https://en.wikipedia.org/wiki/Pascal_(programming_language)#Standards
%      http://www.standardpascaline.org/
%

input:
   pIdent
   pIntLit
   pStrLit
   pCharLit
   pAssign       ':='
   pSemiColon    ';'
   pEqual        '='
   pNotEqual     '<>'
   pLess         '<'
   pGreater      '>'
   pLessEqual    '<='
   pGreaterEqual '>='
   pColon        ':'
   pComma        ','
   pLParen       '('
   pRParen       ')'
   pLSquare      '['
   pRSquare      ']'
   pCarat        '^'
   pAt           '@'
   pDot          '.'
   pDotDot       '..'
   pTimes        '*'
   pDivide       '/'
   pPlus         '+'
   pMinus        '-'
   pEof
   pInvalid

%  keywords  (built-in types 'integer', 'byte', 'char', etc, are not keywords,
%             type constructors 'array', 'record', 'set' are keywords,
%             pseudo-procedures 'writeln', 'readln' are keywords)
%
%             forward/external/name/cdecl appear in method modifiers, in fpc grammar.
%             I'm making them keywords to simplify parsing, but could reconsider.

   pProgram
   pProcedure
   pFunction
   pConst
   pType
   pVar
   pLabel
   pBegin
   pEnd
   pArray
   pRecord
   pSet
   pOf
   pIf
   pThen
   pElse
   pFor
   pTo
   pDownto
   pDo
   pWhile
   pRepeat
   pUntil
   pContinue
   pBreak
   pGoto
   pAnd
   pOr
   pNot
   pUses
   pUnit
   pInterface
   pImplementation
   pInitialization
   pFinalization
   pWriteln
   pWrite
   pReadln
   pRead

   pForward
   pExternal
   pName
   pCdecl
   ;


output:

%  Instructions for a stack machine (all vars are 32-bit integers)

   tPushGlobalI      % <ptr> - push int value read from ptr
   tPushGlobalB      % <ptr> - push byte value read from ptr
   tPushGlobalP      % <ptr> - push ptr value read from ptr
   tPushLocalI       % <offset> - push int value read from local var in current scope
   tPushLocalB       % <offset> - push byte value read from local var in current scope
   tPushLocalP       % <offset> - push ptr value read from local var in current scope
   tPushParamI       % <offset> - push int value read from param in current scope
   tPushParamB       % <offset> - push byte value read from param in current scope
   tPushParamP       % <offset> - push ptr value read from param in current scope
   tPushUpLocalI     % <uplevels> <offset> - push int value read from local var in a parent static scope
   tPushUpLocalB     % <uplevels> <offset> - push byte value read from local var in a parent static scope
   tPushUpLocalP     % <uplevels> <offset> - push ptr value read from local var in a parent static scope
   tPushUpParamI     % <uplevels> <offset> - push int value read from param in a parent static scope
   tPushUpParamB     % <uplevels> <offset> - push byte value read from param in a parent static scope
   tPushUpParamP     % <uplevels> <offset> - push ptr value read from param in a parent static scope
   tPushConstI       % <int> - push int value on stack (NOTE, used for BOOLEAN too)
   tPushAddrGlobal   % <offset> - push ptr to global var (same as tPushConstP)
   tPushAddrLocal    % <offset> - push ptr to local var
   tPushAddrParam    % <offset> - push ptr to formal param (used by method to see its param)
   tPushAddrActual   % <offset> - push ptr to actual param, in actuals space (used by caller)
   tPushAddrUpLocal  % <uplevels> <offset> - push ptr to local var in a parent static scope
   tPushAddrUpParam  % <uplevels> <offset> - push ptr to formal param in a parent static scope
   tFetchI           % pop ptr from stack, and push int value it points to
   tFetchB           %    "      "      "     "     byte  "   "    "
   tFetchP           %    "      "      "     "     ptr   "   "    "   
   tAssignI          % assign int value on top of stack to addr under it (pop both)
   tAssignB          %   "    byte   "    "   "  "   "    "    "   "   "
   tAssignP          %   "    ptr    "    "   "  "   "    "    "   "   "
   tCopy             % <#bytes> - copy bytes.  tos=src, 2nd=dest (pop 2)
   tCastBtoI         % zero-extend uint8_t to int32_t
   tCastItoB         % truncate int32_t to uint8_t
   tIncI             % increment int value on top of expr stack
   tDecI             % decrement int value on top of expr stack
   tMultI            % multiply top two integers (replacing with result)
   tDivI
   tAddPI            % add ptr (2nd value) and int (top value), resulting in a ptr
   tAddI
   tSubI
   tNegI             % top entry *= -1
   tNot              % negate top boolean
   tEqualI           % top two entries equal? (pop 2, push 1) (true=1)
   tNotEqualI        %    NOTE, these all work for booleans too
   tGreaterI         % 2nd entry greater than top entry? (pop 2, push answer)
   tLessI  
   tGreaterEqualI
   tLessEqualI
   tEqualP           % two two pointer values equal? (pop 2, push 1) (true=1)
   tNotEqualP
   tAllocActuals     % <#bytes> - make space on call stack for actual params (adjusting call stack sp)
   tAllocActualsCdecl  % <#bytes> - starting a call to a cdecl method.  tcode still describes my own calling convention.
   tFreeActuals      % <#bytes> - discard space on call stack allocated by tAllocActuals
   tCall             % <label#>
   tCallCdecl        % <label#> - call a method using native (C) calling convention. Only supported for extern labels.
   tReturn
   tEnter            % <#bytes> - start a stack frame on the call stack, reserving #bytes of local variable space
   tJump             % <label#>
   tJumpTrue         % <label#>  (pops top of stack, jumps if true)
   tJumpFalse        % <label#>  (pops top of stack, jumps if false)
   tLabel            % <label#> - define label# at the current address
   tLabelAlias       % <label#> <aliasToLabel#> - defines label to be an alias of another label
   tLabelExtern      % <label#> <offsetToStrLit> - defines label to mean an extern symbol, whose name is in global data
   tWriteI           % for writeln : write integer on tos, pop
   tWriteBool        %  "     "    : write TRUE/FALSE, pop
   tWriteChar        %  "     "    : write char, pop
   tWriteStr         %  "     "    : write string whose addr is on tos, pop
   tWriteP           %  "     "    : write ptr var whose addr is on tos, pop
   tWriteEnum        %  "     "    : write enum name.  Name table on tos, value under it, pop both
   tWriteCR          %  "     "    : write cr

%  Other:

   tSpace            % emit a hole, to be patched later
   ;

error:
   eBadStatement
   eNotConst
   eNotType
   eNotOrdinalType
   eNotVar
   eNotIntVar
   eNotValue
   eNotInteger
   eNotBoolean
   eNotPointer
   eNotArray
   eNotRecord
   eNotRecordField
   eTooManySubscripts
   eTypeMismatch
   eMissingParameter
   eNotImplemented
   eNotAllowed
   eNotInALoop
   eRecordEmpty
   eNotCurrentFunction
   eAlreadyDefined
   eOnlyOneVarCanBeInitialized
   eExternalMethodCannotBeNested
   eCantFindUnitFile
   eInternalScopeMismatch
   eEnumValueNotAscending
   eUsedButNotDefined
   eCantUsePredSuccOnEnumWithValueGaps
   ;

include 'pascal_schema.ssl'

type Node:     % A pointer to a node in the schema database (symbol database)
   Null = 0
   ;

type NodeIter:   % An iterator over nodes in a list, in the schema database
   NullIter = 0
   ;

type NodeVec:  % A pointer to a vector of Node.  See mechanism node_vec_mech
   NullVec = 0
   ;

type boolean:
   false    = 0
   true     = 1;

% intrinsic types & type constructs

type typ:
   tyNone     = 0    % in ptrTyp field of TT, means no ptr to type defined
   tyInteger
   tyBoolean
   tyChar
   tyString
   tyFile            % tyInteger..tyFile are scalars (types on their own)
   tyPointer         % following are type constructor classes...
   tyArray           %   (they are not type#'s)
   tyRecord
   tyParams          % like record; a collection of proc/func params
   tySet;

type Label:
   labelNull = 0;

% An output code stream.
type Code:
   codeNull = 0
   codeDefault = 1
   ;

% A string
type String:
   stringNull = 0
   ;

% allocation modes for oScopeBegin
type AllocMode:
   allocGlobal = 0  % allocate from global data
   allocDown        % allocate down the stack
   allocUp          % allocate up the stack
   ;

% Some general schema node operations.
% node_type and node_attribute are defined in generated file pascal_schema.ssl included above.
%
mechanism node_mech:
    oNodeNew (node_type) >> Node         % create new node
    oNodeSet (Node, node_attribute, Node)   % set Node attribute of node
    oNodeSetString (Node, node_attribute, String)
    oNodeSetInt (Node, node_attribute, int) % set int attribute of node
    oNodeSetBoolean (Node, node_attribute, boolean)
    oNodeSetLabel( Node, node_attribute, Label )  % set Label attribute of node
    oNodeSetCode( Node, node_attribute, Code )    % set Code attribute of node
    oNodeAddLast( Node, node_attribute, Node value )  % append to a List attribute of node
    oNodeGet (Node, node_attribute) >> Node    % get Node attribute of node
    oNodeGetString (Node, node_attribute) >> String
    oNodeGetInt (Node, node_attribute) >> int  % get int attribute of node
    oNodeGetBoolean (Node, node_attribute) >> boolean  % get int attribute of node
    oNodeGetLabel (Node, node_attribute) >> Label      % get Label attribute of node
    oNodeGetCode (Node, node_attribute) >> Code        % get code stream attribute of node
    oNodeNull (Node) >> boolean          % is node null?
    oNodeFind (Node, node_attribute listAttr, node_attribute valueAttr, int value) >> Node  % find node with value in list
    oNodeGetIter (Node, node_attribute) >> NodeIter   % get an iterator over nodes in a List attribute
    oNodeGetIterLast (Node, node_attribute) >> NodeIter  % get an iterator over nodes in a List, starting at last
    oNodeIterValue (NodeIter) >> Node             % the node that iter is referring to (NodeNull if no more nodes)
    oNodeIterNext (inout NodeIter)                % advance iterator through list
    oNodeIterPrev (inout NodeIter)                % advance iterator backwards through list
    oNodeType (Node) >> node_type        % return node type of node
    oNodeEqual (Node, Node) >> boolean   % compare two nodes for equality
                                         % (i.e. same node, not just same contents)
    ;


% Manipulate a temporary vector of Node
%
mechanism node_vec_mech:
    oNodeVecNew >> NodeVec
    oNodeVecDelete( NodeVec nv )
    oNodeVecAppend( NodeVec nv, Node n )
    oNodeVecSize( NodeVec nv ) >> int                % how many elements
    oNodeVecElement( NodeVec nv, int idx ) >> Node   % element at index idx (0..size-1)
    ;



mechanism emit_mech:
    oEmitInt( int )              % emit int into the generated code
    oEmitLabel( Label )
    oEmitCode( Code )            % append a code stream to the current code stream
    Here >> int                  % current address in the generated code
                                 %   (only usable in the default code stream)
    oPatch( int addr, int val )  % patch an int into address in the generated code
                                 %   (only usable in the default code stream)
    ;

mechanism math:
    inc (inout int)
    dec (inout int)
    negate (int) >> int
    add( int x, int y ) >> int
    subtract( int x, int y ) >> int     % x - y
    multiply( int x, int y ) >> int     % x * y
    equal( int x, int y ) >> boolean
    equal_zero (int) >> boolean
    equal_node( Node, Node ) >> boolean
    equal_string( String, String ) >> boolean
    equal_node_type (node_type, node_type) >> boolean     % Want equal_<type> for every type
    equal_label( Label, Label ) >> boolean
    equal_code( Code, Code ) >> boolean
    greater( int x, int y ) >> boolean
    oMININT >> int    % the minimum 32-bit integer.
    oMAXINT >> int    % the maximum 32-bit integer.
    ;

mechanism more_builtins:      % These should be built-in SSL operations
    TOKEN_VALUE >> int        % value of just accepted token, e.g. IntLit token
    LAST_ID >> int            % id number of last accepted identifier
    ID_STRING( int id ) >> String       % text name of identifier with given id
    CURRENT_STRLIT >> String            % text value of just-accepted string literal
    ;

mechanism workspace_mech:
    oWorkspaceNew >> Node
    ;

mechanism scope_mech:
    oScopeBegin( int level, AllocMode )  % create a new scope. Subsequent declarations will go here.
                                         %  level = static scope depth (0 = globals)
    oScopeEnter( Node scope )            % enter an existing scope.
    oScopeEnd                            % end current scope. Subsequent declarations will go to previous scope.
    oScopeCurrent >> Node                % returns current scope
    oScopeDeclare( Node decl )           % add declaration to current scope.
    oScopeDeclareAlloc( Node decl )      % add declaration to current scope, and allocate space according to its type
    oScopeAllocType( Node theType ) >> int   % allocate space for type in current scope, and return its address
    oScopeAlloc( int size, int align ) >> int % allocate bytes, with given alignment in bytes 
    oScopeFind >> Node                   % find declaration of last accepted identifier.  Returns Null if not found.
    oScopeFindRequire >> Node            % find declaration of last accepted identifier.  Error if not found.
    oScopeFindInCurrentScope >> Node     % find declaration of last accepted identifier, only within the current scope.  Null if not found.
    oScopeFindRequireInScope( Node scope ) >> Node  % find decl of last accepted identifier, only within the given scope.  Error it not found.
    ;

mechanism type_mech:
    oTypeAdd( Node node )     % add the given nType to the type table
    ;

mechanism type_stack_mech:
    oTypeSPush( Node node )
    oTypeSPop
    oTypeSTop >> Node
    oTypeSNodeType >> node_type          % node_type of the node on top of type stack, skipping subranges
    ;


mechanism id_mech:
    % adds a predefined id to the scanner's id table, and returns the id code
    oIdAdd_File >> int
    oIdAdd_Integer >> int
    oIdAdd_Boolean >> int
    oIdAdd_Char >> int
    oIdAdd_Byte >> int
    oIdAdd_String >> int
    oIdAdd_True >> int
    oIdAdd_False >> int
    oIdAdd_Ord >> int
    oIdAdd_Chr >> int
    oIdAdd_Pred >> int
    oIdAdd_Succ >> int
    oChangeIntLitToLabelIdent    % change current token from pIntLit to pIdent "_label_<intlit>"
    ;



mechanism label_mech:
   oLabelNew >> Label
   ;

mechanism code_mech:
   oCodeNew >> Code         % create a new empty code stream
   oCodePush( Code )        % change the current output code stream to the given one
   oCodePop                 % restore the current code stream to the previous one
   ;

mechanism include_mech:
   oIncludeUnitFile( int id ) >> boolean  % search for <unit>.pas and include it.
                                          % returns false if can't find.
   oIncludeEnd              % stop including the current file
   ;


mechanism count :
   oCountPush(int)          % start a new counter, with initial value
   oCountInc
   oCountDec
   oCountIsZero >> boolean
   oCountPop;


mechanism value :              % value stack, to calc. const expr's
   oValuePush(int)             % push an explicit int lit
   oValueNegate                % negate top value
   oValueTop >> int            % get top value on value stack
   oValuePop;

mechanism string :
   oStringAllocLit( String ) >> int      % alloc global space for strlit, return address
   ;

% track labels for the loop we're in, if any
mechanism loop_mech:
   oLoopPush( Label continueLabel, Label breakLabel )
   oLoopContinueLabel >> Label
   oLoopBreakLabel >> Label
   oLoopPop
   ;

% for hacky debugging
mechanism msg_mech:
   oMsg( int num )             % print message "oMsg <num>"
   oMsgTrace( int num )        % print message "oMsg <num>" followed by ssl traceback
   oMsgNode( Node node )       % print node
   oMsgNodeLong( Node node )   % print node with more detail
   oMsgNodeVec( NodeVec vec )  % print node vec
   ;


rules

% ----------------------------- Global Variables ----------------------------

Node    workspace              % root of database
Node    globalScope            % scope for globals in the current module
Node    initScope              % scope for temporaries global var init,
                               % and program main stmt / unit initialization stmts
% built-in nTypes
Node    FileType
Node    IntegerType
Node    BooleanType
Node    BooleanCFType
Node    CharType
Node    ByteType
Node    StringType

% nBuiltInFunc
Node    BuiltIn_Ord
Node    BuiltIn_Chr
Node    BuiltIn_Pred
Node    BuiltIn_Succ


% -------------------------- Forward Declarations -------------------------

Block( node_type varNodeType, Label labelForBody );
BlockDecls( node_type varNodeType );
BlockStmt( Label labelForBody, Node varScope, boolean isMain );
VarDecl( node_type varNodeType );
newType( node_type nt, int size ) >> Node;
newIdent( node_type nt, int id ) >> Node;
EmitValue( Node decl );
TypeRef( out Node theType );
EnumTypeRef( out Node resultType );
PointerTypeTo( Node theType ) >> Node;
OrdinalLow( Node theType ) >> int;
OrdinalHigh( Node theType ) >> int;
AssignStmt( Node decl );
BooleanExprControlFlow( out Label falseLabel );
ExprAllowCF( out Label falseLabel );
BoolExprAllowCF( out Label falseLabel );
BoolTermAllowCF( out Label falseLabel );
BoolFactorAllowCF( out Label falseLabel );
ArithExprAllowCF( out Label falseLabel );
TermAllowCF( out Label falseLabel );
FactorAllowCF( out Label falseLabel );
PrimaryAllowCF( out Label falseLabel );

VarExpr( Node decl );
LValueVar( Node decl );
IncVar( Node decl );
DecVar( Node decl );

CFToVal( inout Label falseLabel );
ValToCF( out Label falseLabel );

DeclLevel( Node decl ) >> int;
DeclUpLevels( Node decl ) >> int;

% ----------------------------- Declarations ----------------------------

Program:
   Node t

   workspace = oWorkspaceNew

   % root scope is used for builtins e.g. Integer,
   % and is a parent to any used units, and the program's own global scope.
   oScopeBegin( 0, allocGlobal )
   Node rootScope = oScopeCurrent

   @installBuiltIns

   % Start by calling the main program routine.

   % This dummy call to main needs to look like a normal method itself,
   % so jit can align the stack properly.  So we need .tEnter,
   % and .tAllocActuals / .tFreeActuals.
   .tEnter  oEmitInt( 0 )
   Label mainLabel = oLabelNew

   .tAllocActuals  oEmitInt( 0 )
   .tCall  oEmitLabel( mainLabel )
   .tFreeActuals  oEmitInt( 0 )
   .tReturn

   pProgram
   pIdent

   Node program = oNodeNew( nProgram )
   oNodeSetInt( program, qIdent, LAST_ID )
   oNodeSet( workspace, qProgram, program )


   [
      | '(' :
         pIdent      % input, output files

         t = @newIdent( nVar, LAST_ID )
         oNodeSet( t, qType, FileType )
         oScopeDeclareAlloc( t )
         % TO DO: I shouldn't declare the files in root scope.
         %        Should save them for program's global scope.

         ','
         pIdent

         t = @newIdent( nVar, LAST_ID )
         oNodeSet( t, qType, FileType )
         oScopeDeclareAlloc( t )

         ')'
      | * :
   ]
   ';'

   % The uses clause may only appear once, immediately after the program declaration.
   [
      | pUses :  @UsesClause( program )
      | * :
   ]
   @EnterUsedUnits( program )

   % Global scope for the program, below any used units.
   oScopeBegin( 0, allocGlobal )
   globalScope = oScopeCurrent

   % A new scope just for temporaries in the main routine
   % Create it up front, in case it's needed by variable initialization exprs.
   % But we won't stay in it here.
   % Note we say it extends the global scope, so that during main statement evaluation
   % any user labels declared in the global scope are considered to be part of the current scope.
   oScopeBegin( 0, allocDown )
   oNodeSet( oScopeCurrent, qExtends, globalScope )
   initScope = oScopeCurrent
   oNodeSet( program, qMainRoutineScope, initScope )
   oScopeEnd

   @BlockDecls( nGlobalVar )


   oScopeEnter( initScope )

   % The block statement includes a stack frame, and enter/return,
   % even for the main routine.
   % That will be necessary for temporaries allocated in the main routine.

   % isMain means we'll generate calls to the unit init/final methods in here too.
   % Alternatively we could do that in a higher level method that calls main.
   boolean isMain = true
   @BlockStmt( mainLabel, globalScope, isMain )

   oScopeEnd   % main routine scope

   '.'
   @CheckForUndefinedLabels
   oScopeEnd   % global scope
   @EndUsedUnits( program )   % used units scopes
   ;


% The uses clause is a list of units required by the user program or unit.
% We will find and compile the named units (unless already loaded).
% We do not make the unit interface visible to the user, the caller will do so later.
UsesClause( Node user ):
   {
      pIdent
      Node unit = @FindOrCompileUnit( LAST_ID )
      [ equal_node( unit, Null )
         | false :
            oNodeAddLast( user, qUsedUnits, unit )

            % Put a declaration in the current scope, naming the unit and pointing to it.
            % This is to allow references to  <unit>.<identifier_in_unit>
            Node unitRef = oNodeNew( nUnitRef )
            oNodeSetInt( unitRef, qIdent, oNodeGetInt( unit, qIdent ) )
            oNodeSet( unitRef, qPublicScope, oNodeGet( unit, qPublicScope ) )
            oScopeDeclare( unitRef )
         | * :
      ]
      [
         | ',' :
         | * :  >
      ]
   }   
   ';'
   ;


% If the given decl is for an nUnitRef, the program is using syntax <unit>.<identifier>
% Parse the rest of that to find the intended decl.
%
ResolveUnitRef( inout Node decl ):
   [ oNodeType( decl )
      | nUnitRef :
         Node scope = oNodeGet( decl, qPublicScope )
         '.'
         pIdent
         decl = oScopeFindRequireInScope( scope )
      | * :
   ];


EnterUsedUnits( Node user ):
   % Make the used units' public scopes directly visible.
   % This is done after the units are all compiled, so they don't interfere with each other incorrectly.
   % Units later in the list have priority.
   NodeIter unitIt = oNodeGetIter( user, qUsedUnits )
   {
      Node unit = oNodeIterValue( unitIt )
      [ oNodeNull( unit )
         | false :
            oScopeEnter( oNodeGet( unit, qPublicScope ) )
         | * :
            >
      ]
      oNodeIterNext( unitIt )
   }
   ;

EndUsedUnits( Node user ):
   % Leave the units' public scopes, so no longer visible.
   NodeIter unitIt = oNodeGetIterLast( user, qUsedUnits )
   {
      Node unit = oNodeIterValue( unitIt )
      [ oNodeNull( unit )
         | false :
            % Consistency check.  Make sure our scope enter / end have lined up correctly.
            [ oNodeEqual( oScopeCurrent, oNodeGet( unit, qPublicScope ) )
               | true :
               | false :  #eInternalScopeMismatch
            ]
            oScopeEnd
         | * :
            >
      ]
      oNodeIterPrev( unitIt )
   }
   ;


FindOrCompileUnit( int id ) >> Node:
   % We might have this unit loaded already
   Node unit = oNodeFind( workspace, qUnits, qIdent, id )
   [ equal_node( unit, Null )
      | false :  >> unit
      | * :
   ]

   % If not, search for the source file on disk
   boolean ok = oIncludeUnitFile( id )
   [ ok
      | false :  #eCantFindUnitFile  >> Null
      | * :
   ]

   % compile it, adding it into the workspace
   % then return it.
   unit = @Unit

   % TO DO: ensure we are at pEof
   % end the include
   oIncludeEnd
   >> unit;



Unit >> Node:
   pUnit
   pIdent
   Node unit = oNodeNew( nUnit )
   oNodeSetInt( unit, qIdent, LAST_ID )
   Node unitImpl = oNodeNew( nUnitImpl )
   oNodeSetInt( unitImpl, qIdent, LAST_ID )
   oNodeSet( unit, qImpl, unitImpl )
   ';'

   % mandatory sections

   pInterface
   [
      | pUses :   @UsesClause( unit )
      | * :
   ]
   @EnterUsedUnits( unit )

   oScopeBegin( 0, allocGlobal )
   oNodeSet( unit, qPublicScope, oScopeCurrent )
   globalScope = oScopeCurrent

   % A scope for temporaries needed by variable initialization
   oScopeBegin( 0, allocDown )
   initScope = oScopeCurrent
   oNodeSet( unit, qInitRoutineScope, initScope )
   oScopeEnd

   @UnitInterface( unit )
   oScopeEnd  % interface scope

   pImplementation
   [
      | pUses :   @UsesClause( unitImpl )
      | * :
   ]
   @EnterUsedUnits( unitImpl )
   % re-enter interface scope after impl's uses.  interface still has priority.
   oScopeEnter( oNodeGet( unit, qPublicScope ) )
   
   oScopeBegin( 0, allocGlobal )
   oNodeSet( unit, qPrivateScope, oScopeCurrent )
   oNodeSet( oScopeCurrent, qExtends, oNodeGet( unit, qPublicScope ) )
   globalScope = oScopeCurrent
   @UnitImplementation( unit )

   [
      | pInitialization :  @UnitInitialization( unit, true )   % init routine with statements from init section
      | * :                @UnitInitialization( unit, false )  % implicit init routine
   ]
   [
      | pFinalization :  @UnitFinalization( unit, true )
      | * :              @UnitFinalization( unit, false )   % implicit final routine, may be handy later
   ]
   pEnd  '.'

   oScopeEnd  % impl scope
   oScopeEnd  % interface scope
   @EndUsedUnits( unitImpl )  % used units scopes
   @EndUsedUnits( unit )
   oNodeAddLast( workspace, qUnits, unit )
   >> unit;


UnitInterface( Node unit ):
   {[
      | pConst :     @ConstDecl
      | pType :      @TypeDecl
      | pVar :       @VarDecl( nGlobalVar )
      % label declaration not allowed in interface

      | pProcedure :
         Node decl = @ProcHeaderDecl
         % despite syntax diagrams, fpc does allow external clause on methods in unit interface,
         % even though this clause is an alternative for the body statement.
         [
            | pExternal :
               @ExternalDecl( decl )
               ';'
            | * :
         ]

      | pFunction :
         Node decl = @FuncHeaderDecl
         [
            | pExternal :
               @ExternalDecl( decl )
               ';'
            | * :
         ]

      | * :          >
   ]}
   ;

UnitImplementation( Node unit ):
   @BlockDecls( nGlobalVar )
   ;


UnitInitialization( Node unit, boolean hasStmts ):
   Label label = oLabelNew
   .tLabel  oEmitLabel( label )
   oNodeSetLabel( unit, qInitLabel, label )

   int patchLS
   .tEnter  patchLS = Here  .tSpace

   % insert any code for initialization of this unit's variables.
   
   Node scope
   Code initCode

   scope = oNodeGet( unit, qPublicScope )
   initCode = oNodeGetCode( scope, qInitCode )
   oEmitCode( initCode )
   oNodeSetCode( scope, qInitCode, codeNull )

   scope = oNodeGet( unit, qPrivateScope )
   initCode = oNodeGetCode( scope, qInitCode )
   oEmitCode( initCode )
   oNodeSetCode( scope, qInitCode, codeNull )

   oScopeEnter( oNodeGet( unit, qInitRoutineScope ) )

   [ hasStmts
      | true :     
         @Statement
         {[
            | ';' :  @Statement
            | * :    >
         ]}
      | * :
   ]

   .tReturn

   int localSpace = oNodeGetInt( oScopeCurrent, qSize )
   oPatch( patchLS, localSpace )
   oScopeEnd   % init routine scope, for temporaries
   ;


UnitFinalization( Node unit, boolean hasStmts ):
   Label label = oLabelNew
   .tLabel  oEmitLabel( label )
   oNodeSetLabel( unit, qFinalLabel, label )

   int patchLS
   .tEnter  patchLS = Here  .tSpace

   % final routine scope, for temporaries
   oScopeBegin( 0, allocDown )

   [ hasStmts
      | true :     
         @Statement
         {[
            | ';' :  @Statement
            | * :    >
         ]}
      | * :
   ]

   .tReturn

   int localSpace = oNodeGetInt( oScopeCurrent, qSize )
   oPatch( patchLS, localSpace )
   oScopeEnd   % final routine scope, for temporaries
   ;


Block( node_type varNodeType, Label labelForBody ):
   @BlockDecls( varNodeType )
   @BlockStmt( labelForBody, oScopeCurrent, false )
   @CheckForUndefinedLabels
   ;


BlockDecls( node_type varNodeType ):
   {[
      | pConst :     @ConstDecl
      | pType :      @TypeDecl
      | pVar :       @VarDecl( varNodeType )
      | pLabel :     @LabelDecl
      | pProcedure : @ProcDecl
      | pFunction :  @FuncDecl
      | * :          >
   ]}
   @CheckForUndefinedMethods
   ;


% were there any procedures or functions declared in this scope
% that were never defined?
CheckForUndefinedMethods:
   % TO DO
   % Note: disregard methods marked external
   ;

% were there any labels declared in the current scope, and used,
% but never defined (as the prefix of a stement)?
%
CheckForUndefinedLabels:
   NodeIter it = oNodeGetIter( oScopeCurrent, qDecls )
   {
      Node decl = oNodeIterValue( it )
      [ oNodeNull( decl )
         | false :
         | * :  >
      ]
      [ oNodeType( decl )
         | nLabel :
            [ oNodeGetBoolean( decl, qDefined )
               | false :
                  [ oNodeGetBoolean( decl, qUsed )
                     | true :    #eUsedButNotDefined  % TO DO: give the decl in the message
                     | * :
                  ]
               | * :
            ]
         | * :
      ]
      oNodeIterNext( it )
   }
   ;


InitializeUnits:
   % call init routine of each loaded unit, in the order they were loaded
   % (used directly or indirectly by the main program).
   NodeIter it = oNodeGetIter( workspace, qUnits )
   {
      Node unit = oNodeIterValue( it )
      [ oNodeNull( unit )
         | true :  >
         | false :
            .tAllocActuals  oEmitInt( 0 )  % not sure I need this. maybe for stack alignment.
            .tCall  oEmitLabel( oNodeGetLabel( unit, qInitLabel ) )
            .tFreeActuals  oEmitInt( 0 )
            oNodeIterNext( it )
      ]
   };


FinalizeUnits:
   NodeIter it = oNodeGetIterLast( workspace, qUnits )
   {
      Node unit = oNodeIterValue( it )
      [ oNodeNull( unit )
         | true :  >
         | false :
            .tAllocActuals  oEmitInt( 0 )  % not sure I need this. maybe for stack alignment.
            .tCall  oEmitLabel( oNodeGetLabel( unit, qFinalLabel ) )
            .tFreeActuals  oEmitInt( 0 )
            oNodeIterPrev( it )
      ]
   };


% Given the scope of vars in this block.
% Usually it's the current scope, but it's a bit different for the main statement.
%
BlockStmt( Label labelForBody, Node varScope, boolean isMain ):
   .tLabel  oEmitLabel( labelForBody )

   % Proc, func, and main routine all start with tEnter
   % to create a stack frame.  This will be used for temporaries
   % (and local vars in the case of proc, func).

   int patchLS
   .tEnter  patchLS = Here  .tSpace

   % If we're generating the program main method,
   % add in calls to the loaded units' initialization and finalization.
   [ isMain
      | true :  @InitializeUnits
      | * :
   ]

   % insert any code for initialization of this scope's variables
   Code initCode = oNodeGetCode( varScope, qInitCode )
   oEmitCode( initCode )
   oNodeSetCode( varScope, qInitCode, codeNull )

   @Statement

   [ isMain
      | true :  @FinalizeUnits
      | * :
   ]

   .tReturn

   int localSpace = oNodeGetInt( oScopeCurrent, qSize )
   oPatch( patchLS, localSpace )
   ;


% modifers that may appear on a proc/function declaration.
%
MethodModifiers( Node decl ):
   {[
      | pCdecl :
         oNodeSetBoolean( decl, qCdecl, true )
         ';'

      | * : >
   ]}
   ;


% We need an initCode code stream for the given scope.
% Create it if not present yet.  Return it.
% (This will be used for variable initialization.)
%
GetOrCreateInitCode( Node scope ) >> Code:
   Code initCode = oNodeGetCode( scope, qInitCode )
   [ equal_code( initCode, codeNull )
      | true :
         initCode = oCodeNew
         oNodeSetCode( scope, qInitCode, initCode )
      | * :
   ]
   >> initCode;


% external method resides in an external object file
% (or in my system, the built-in runtime library).
% The method has a label, as usual, which callers will use.
% But we define that label with .tLabelExtern rather than .tLabel.
%
% Note, I'll hold off on issuing the .tLabelExtern until we see that
% the external method is actually called.  Otherwise we'd fill each output file
% with all the external method names in my included libraries, which seems dumb.
%
% Note this is fpc syntax.  I'm not sure about other Pascals.
%
ExternalDecl( Node decl ):
   [ equal_zero( @DeclLevel( decl ) )
      | false :  #eExternalMethodCannotBeNested
      | * :
   ]
   oNodeSetBoolean( decl, qExternal, true )
   [
      | pStrLit :
         % that was the optional library name containing the method.
         % TO DO: I'm currently ignoring this.
         [
            | pName :
               pStrLit
               % that was the optional method name defined in that library,
               % which might differ from the Pascal name.
               oNodeSetString( decl, qExternalName, CURRENT_STRLIT )
            | * :
         ]
      | * :
   ]
   ;


ProcHeaderDecl >> Node:
   pIdent

   % If we already have a forward declaration, we'll modify that decl
   % instead of creating a second symbol table entry.
   % (Alternatively could delete or hide the old entry.)
   boolean redeclaring = false
   Node decl = oScopeFindInCurrentScope

   [ oNodeNull( decl )
      | true :
         % first declaration
         decl = @newIdent( nProc, LAST_ID )
         oNodeSetLabel( decl, qValue, oLabelNew )

      | false :
         % we already have a declaration.
         % Keep it, and its label.
         redeclaring = true
         [ oNodeGetBoolean( decl, qBodyDefined )
            | true : #eAlreadyDefined
            | * :
         ]
         [ oNodeGetBoolean( decl, qExternal )
            | true : #eAlreadyDefined
            | * :
         ]
         [ oNodeType( decl )
            | nProc :
            | * : #eAlreadyDefined   % wrong kind
         ]
         % Move the existing param scope aside, so we can check that the
         % new one is consistent.  And, the body will want to see the new one
         % since the names might differ.
         % TO DO: If qOldParams already set, we have multiple forward decls,
         % which I believe is supposed to be an error.
         oNodeSet( decl, qOldParams, oNodeGet( decl, qParams ) )
         oNodeSet( decl, qParams, Null )
   ]

   int level = @ScopeLevel
   boolean nested = greater( level, 0 )
   inc( level )
   oScopeBegin( level, allocUp )
   Node paramScope = oScopeCurrent

   % A nested method has a hidden first param for the parent static scope.
   % This won't appear in the param decls list, just reserve space for it.
   % It's first so the static chain is always at a fixed offset from the frame pointer.
   [ nested
      | true :
         int offset = oScopeAllocType( @PointerTypeTo( IntegerType ) )   % arbitrary ptr type
      | * :
   ]

   @FormalArgDecl
   oNodeSet( decl, qParams, paramScope )
   oScopeEnd
   ';'

   [ redeclaring
      | false : oScopeDeclare( decl )
      | true :  % TO DO: check that qParams is consistent with qOldParams
   ]

   @MethodModifiers( decl )
   >> decl;


ProcDecl:
   Node decl = @ProcHeaderDecl

   % Body may be a statement, "forward", "external".
   % Note, this syntax is based on FPC, and I'm not sure if other Pascals are similar.
   % FPC says that forward, external, cdecl, name, etc are not reserved words -
   % I think this means the user may declare other things with those names, but if so the
   % original meaning is lost.  I'll make them keywords for simplicity, for now
   % (just not too happy about "name").

   [
      | pForward :
         % Nothing to do.  We simply won't set qBodyDefined.

      | pExternal : @ExternalDecl( decl )

      | * :
         % Body statement

         % Enter the params scope again, so params are visible in body.
         % TO DO: Perhaps I could mark the scope read-only at this point.
         Node paramScope = oNodeGet( decl, qParams )
         oScopeEnter( paramScope )

         % Start scope for declarations within the proc
         int level = oNodeGetInt( paramScope, qLevel )
         oScopeBegin( level, allocDown )
         oNodeSet( decl, qChildScope, oScopeCurrent )

         Label label = oNodeGetLabel( decl, qValue )
         @Block( nLocalVar, label )
         oNodeSetBoolean( decl, qBodyDefined, true )
         oScopeEnd

         oScopeEnd  % paramScope
   ]
   ';';



FuncHeaderDecl >> Node:
   pIdent

   % If we already have a forward declaration, we'll modify that decl
   % instead of creating a second symbol table entry.
   % (Alternatively could delete or hide the old entry.)
   boolean redeclaring = false
   Node decl = oScopeFindInCurrentScope

   [ oNodeNull( decl )
      | true :
         % first declaration
         decl = @newIdent( nFunc, LAST_ID )
         oNodeSetLabel( decl, qValue, oLabelNew )

      | false :
         % we already have a declaration.
         % Keep it, and its label.
         redeclaring = true
         [ oNodeGetBoolean( decl, qBodyDefined )
            | true : #eAlreadyDefined
            | * :
         ]
         [ oNodeType( decl )
            | nFunc :
            | * : #eAlreadyDefined   % wrong kind
         ]
         % Move the existing param scope and return value aside,
         % so we can check that the new one is consistent.
         % And, the body will want to see the new one since the names might differ.
         % TO DO: If qOldParams already set, we have multiple forward decls,
         % which I believe is supposed to be an error.
         oNodeSet( decl, qOldParams, oNodeGet( decl, qParams ) )
         oNodeSet( decl, qParams, Null )
         oNodeSet( decl, qOldType, oNodeGet( decl, qType ) )
         oNodeSet( decl, qType, Null )
   ]

   int level = @ScopeLevel
   boolean nested = greater( level, 0 )
   inc( level )
   oScopeBegin( level, allocUp )
   Node paramScope = oScopeCurrent

   % A nested method has a hidden first param for the parent static scope.
   % This won't appear in the param decls list, just reserve space for it.
   % It's first so the static chain is always at a fixed offset from the frame pointer.
   [ nested
      | true :
         int offset = oScopeAllocType( @PointerTypeTo( IntegerType ) )   % arbitrary ptr type
      | * :
   ]

   @FormalArgDecl
   oNodeSet( decl, qParams, paramScope )

   ':'

   Node theType
   @TypeRef( theType )
   oNodeSet( decl, qType, theType )

   % The function's param space gets an additional pointer,
   % which will point to a temporary in the caller's scope.
   % This pointer is essentially a VAR param, but I won't create an nParam for it.

   Node ptrType = @PointerTypeTo( theType )
   oNodeSetInt( decl, qResultOffset, oScopeAllocType( ptrType ) )
   oScopeEnd
   ';'

   [ redeclaring
      | false : oScopeDeclare( decl )
      | true :  % TO DO: check that qParams is consistent with qOldParams
                % and qType is consistent with qOldType
   ]

   @MethodModifiers( decl )

   >> decl;


FuncDecl:
   Node decl = @FuncHeaderDecl

   % Body may be a statement, "forward", "external".
   [
      | pForward :
         % Nothing to do.  We simply won't set qBodyDefined.

      | pExternal : @ExternalDecl( decl )

      | * :
         % Body statement

         % Enter the params scope again, so params are visible in body.
         % TO DO: Perhaps I could mark the scope read-only at this point.
         Node paramScope = oNodeGet( decl, qParams )
         oScopeEnter( paramScope )

         % Start scope for declarations within the func
         int level = oNodeGetInt( paramScope, qLevel )
         oScopeBegin( level, allocDown )
         oNodeSet( decl, qChildScope, oScopeCurrent )

         Label label = oNodeGetLabel( decl, qValue )
         @Block( nLocalVar, label )
         oNodeSetBoolean( decl, qBodyDefined, true )
         oScopeEnd

         oScopeEnd  % paramScope
   ]
   ';';


FormalArgDecl:
   [
      | '(' :
         {
            NodeVec decls = oNodeVecNew
            Node decl
            boolean isInOut = false

            [
               | pVar : isInOut = true
               | * :
            ]

            {  pIdent

               decl = @newIdent( nParam, LAST_ID )
               oNodeSetBoolean( decl, qInOut, isInOut )
               oNodeVecAppend( decls, decl )

               [
                  | ':' : >
                  | ',' :
               ]
            }

            Node theType
            @TypeRef( theType )

            % VAR param is declared with its given type, but allocated as a pointer.
            Node allocType
            [ isInOut
               | true :   allocType = @PointerTypeTo( theType )
               | * :      allocType = theType
            ]

            int i = 0
            {[ equal( i, oNodeVecSize( decls ) )
               | false :
                  decl = oNodeVecElement( decls, i )

                  oNodeSet( decl, qType, theType )
                  oScopeDeclare( decl )
                  oNodeSetInt( decl, qValue, oScopeAllocType( allocType ) )
                  inc( i )
               | * :
                  >
            ]}

            oNodeVecDelete( decls )

            [
               | ')' : >
               | ';' :
            ]
         }
      | * :
   ];


ConstDecl:
   {[
      | pIdent :
         [
            | ':' :
               @TypedConstDecl
            | * :
               @UntypedConstDecl
         ]
      | * :
         >
   ]};


% Parse an untyped const declaration.
% We've just accepted the identifier.
%
UntypedConstDecl:
   Node decl = @newIdent( nConst, LAST_ID )
   '='

   @ConstExpr
   % TO DO: currently ConstExpr leaves int result on oValue stack
   int val = oValueTop
   oValuePop
   oNodeSetInt( decl, qValue, val )

   % TO DO: different types.  Currently assumes int!
   % Untyped const decl is supposed to allow:
   %   ordinal types, set types, pointer types (but only Nil), real types, char, string.
   oNodeSet( decl, qType, IntegerType )

   oScopeDeclare( decl )
   ';'
   ;


% Parse a typed const declaration.
% We've just accepted the identifier and ':'
%
TypedConstDecl:
   Node decl = @newIdent( nTypedConst, LAST_ID )

   Node theType
   @TypeRef( theType )
   oNodeSet( decl, qType, theType )

   % TO DO: array and record consts are allocated in global memory,
   % with global offset stored as decl value.
   % Scalar consts are not allocated in memory, and their value is
   % stored directly as the decl value.

   % TO DO: skip subranges, similar to oTypeSNodeType.
   [ oNodeType( theType )
      | nBooleanType, nByteType, nCharType, nIntegerType, nEnumType:
         % Parse expression and store value in decl
         '='

         @ConstExpr
         % TO DO: currently ConstExpr leaves int result on oValue stack
         int val = oValueTop
         oValuePop
         oNodeSetInt( decl, qValue, val )
         oScopeDeclare( decl )
         ';'

      | nStringType, nFileType, nPointerType :
         #eNotImplemented

      | nArrayType, nRecordType :
         % Allocate global space, store address in decl.
         % Push into global scope init code stream (since we'll be issuing code
         % rather than creating static data, at the moment).
         % Parse expression and store in global memory.
         oScopeEnter( globalScope )
         int addr = oScopeAllocType( theType )
         oScopeEnd
         oCodePush( @GetOrCreateInitCode( globalScope ) )
         oNodeSetInt( decl, qValue, addr )
         '='
         @TypedConstInit( theType, addr )
         oCodePop
         oScopeDeclare( decl )
         ';'
   ]
   ;


% Parse the initial value of a constant that's being stored in global memory.
% (An array or record constant, and recursively all its elements.)
% Given the type, and the address in global memory for the const value.
% The caller has already pushed into the global init code stream.
%
TypedConstInit( Node theType, int addr ):

   % TO DO: skip subranges, similar to oTypeSNodeTYpe
   [ oNodeType( theType )
      | nArrayType :
         Node baseType = oNodeGet( theType, qBaseType )
         Node indexType = oNodeGet( theType, qIndexType )
         int low = @OrdinalLow( indexType )
         int high = @OrdinalHigh( indexType )
         int elementSize = oNodeGetInt( baseType, qSize )

         '('
         % Loop over elements
         int i = low
         {
            @TypedConstInit( baseType, addr )
            [ equal( i, high )
               | true : >
               | false :
            ]
            ','
            addr = add( addr, elementSize )
            inc( i )
         }
         ')'

      | nRecordType :
         '('
         Node fieldScope = oNodeGet( theType, qScope )
         % Loop over zero or more named fields.  It's not necessary to name them all.
         % fpc says the names that are given should be in order, but I'm not requiring that.
         % Since this is global memory, uninitialized fields will be left as 0.
         {
            [
               | pIdent :
               | * :  >
            ]
            Node field = oScopeFindRequireInScope( fieldScope )
            ':'
            Node fieldType = oNodeGet( field, qType )
            int fieldAddr = add( addr, oNodeGetInt( field, qValue ) )
            @TypedConstInit( fieldType, fieldAddr )
            [
               | ';' :
               | * :  >
            ]
         }
         ')'

      | nBooleanType, nByteType, nCharType:
         .tPushAddrGlobal  oEmitInt( addr )
         @ConstExpr
         .tPushConstI  oEmitInt( oValueTop )
         oValuePop
         .tAssignB

      | nIntegerType, nEnumType:
         .tPushAddrGlobal  oEmitInt( addr )
         @ConstExpr
         .tPushConstI  oEmitInt( oValueTop )
         oValuePop
         .tAssignI

      | nStringType, nFileType, nPointerType :
         #eNotImplemented
   ]
   ;


TypeDecl:
   {[
      | pIdent :
         Node decl = @newIdent( nTypeDecl, LAST_ID )
         '='
         Node theType
         @TypeRef( theType )
         oNodeSet( decl, qType, theType )
         oScopeDeclare( decl )
         ';'
      | * :
         >
   ]};

VarDecl( node_type varNodeType ):
   {[
      | pIdent :
         NodeVec decls = oNodeVecNew
         Node decl
         {
            decl = @newIdent( varNodeType, LAST_ID )
            oNodeVecAppend( decls, decl )
            [
               | ',' :
                  pIdent
               | * :
                  >
            ]
         }
         ':'
         Node theType
         @TypeRef( theType )

         int i = 0
         {[ equal( i, oNodeVecSize( decls ) )
            | false :
               decl = oNodeVecElement( decls, i )
               oNodeSet( decl, qType, theType )
               oScopeDeclareAlloc( decl )
               inc( i )
            | * :
              >
         ]}

         % optional initialization
         [
            | '=' :
               [ oNodeVecSize( decls )
                  | 1 :
                  | * :  #eOnlyOneVarCanBeInitialized
               ]

               % we need an initCode stream for this scope
               Code initCode = @GetOrCreateInitCode( oScopeCurrent )
               oCodePush( initCode )

               % currently the global level has two scopes:
               % the one for declarations e.g. vars and methods,
               % and a second one for temporaries needed by the main block stmt.
               % During evaluation of the init expr, we need to be in the 2nd scope
               % in case the expression requires temporaries
               % (so the temporaries get allocated in the right scope).
               % TO DO: Maybe I should make the global scope the special case, instead.
               boolean changedScope = false
               [ equal_zero( @ScopeLevel )
                  | true : oScopeEnter( initScope )
                           changedScope = true
                  | * :
               ]
               % generate assignment in initCode stream
               @LValueVar( decl )
               @Expr
               @MatchTypes
               @Assign
               [ changedScope
                  | true : oScopeEnd
                  | * :
               ]
               oCodePop
             
            | * :
         ]

         oNodeVecDelete( decls )
         ';'
      | * :
         >
   ]};


% Parse a list of label declarations.
% We'll create a tcode label at declaration time, for each user label.
% If the user label is an integer, we'll record it as _label_<int> in the decl.
%
LabelDecl:
   {
      Node decl
      [
         | pIdent :
         | pIntLit :
            % Replace token with identifier "_label_<intlit>"
            oChangeIntLitToLabelIdent
      ]
      decl = @newIdent( nLabel, LAST_ID )
      % TO DO: ensure not already declared in this scope.
      %        Or maybe that can be part of oScopeDeclare.
      Label label = oLabelNew
      oNodeSetLabel( decl, qValue, label )
      oScopeDeclare( decl )
      [
         | ',' :
         | * :
            >
      ]
   }
   ';'
   ;


% Parse a type reference, returning the nType.
% This will add types to the type table, as needed.
%
% Style question - at the moment I think callers look clearer if we use
% an out param here, rather than a return value.
%
TypeRef( out Node resultType ):
   [
      | pIdent :           % previously named type (including intrinsics)
         Node decl = oScopeFindRequire
         @ResolveUnitRef( decl )
         [ oNodeType( decl )
            | nTypeDecl :
               resultType = oNodeGet( decl, qType )
            | * :
               #eNotType
               resultType = IntegerType
         ]
   
      | pArray :
         '['

         % A multi-dimensional array is represented as a chain
         %    array [subrange1] of array [subrange2] of elementType

         % First, we build a vector of nArray's, each with one subrange as its index type,
         % but without setting the "of" type or size.

         NodeVec dimensions = oNodeVecNew

         {
            % to do: probably should use general subrange parsing, incl minimal size value
            %   In fact, supposed to parse ordinal_type here.  all ordinal types have a static low, high.
            %   Not necessary to be a subrange.

            Node subrange = oNodeNew( nSubrangeType )
            % TO DO: currently assuming subrange of integer
            oNodeSet( subrange, qBaseType, IntegerType )

            % TO DO: currently ConstExpr leaves int result on oValue stack
            @ConstExpr
            oNodeSetInt( subrange, qLow, oValueTop )
            oValuePop
            '..'
            @ConstExpr
            oNodeSetInt( subrange, qHigh, oValueTop )
            oValuePop
            oNodeSetInt( subrange, qSize, 4 )   % maybe don't need

            oTypeAdd( subrange )

            Node a = oNodeNew( nArrayType )
            oNodeSet( a, qIndexType, subrange )

            oNodeVecAppend( dimensions, a )
            % I'll hold off on adding 'a' to the type table since not fully formed yet

            [
               | ']' : >
               | ',' :
            ]
         }

         pOf
         Node baseType
         @TypeRef( baseType )

         % Work backwards through the dimensions,
         % hooking up the 'of' type and calculating the size.
         % At each iteration, baseType is the 'of' type.

         int dim = oNodeVecSize( dimensions )

         {
             dec(dim)

             Node a = oNodeVecElement( dimensions, dim )

             oNodeSet( a, qBaseType, baseType )
             Node subrange = oNodeGet( a, qIndexType )
             int width = subtract( oNodeGetInt( subrange, qHigh ), oNodeGetInt( subrange, qLow ) )
             inc( width )
             oNodeSetInt( a, qSize, multiply( width, oNodeGetInt( baseType, qSize ) ) )

             oTypeAdd( a )
             baseType = a

             [ equal_zero(dim)
                 | true:  >
                 | *:
             ]
         }

         resultType = oNodeVecElement( dimensions, 0 )
         oNodeVecDelete( dimensions )

      | '^' :
         Node theType
         @TypeRef( theType )
         resultType = @PointerTypeTo( theType )

      | pRecord :
         resultType = oNodeNew( nRecordType )
         oScopeBegin( -1, allocUp )    % level is meaningless here

         @VarDecl( nRecordField )

         int size = oNodeGetInt( oScopeCurrent, qSize )
         % to do: padding
         [ equal_zero( size )
            | true : #eRecordEmpty
            | * :
         ]

         pEnd

         oNodeSet( resultType, qScope, oScopeCurrent )
         oNodeSetInt( resultType, qSize, size )
         oScopeEnd
         oTypeAdd( resultType )


      | '(' :
         % An enum type declaration.
         @EnumTypeRef( resultType )


      % *** TO DO: following type constructors are not implemented *** 
      | pSet :
         pOf
         Node theType
         @TypeRef( theType )
      | * :       % this works for cases except where expr starts with an id
         @ConstExpr '..' @ConstExpr
   ];


% Parse an enum type.
% We've already accepted the '('
% Returns the new type.
%
EnumTypeRef( out Node resultType ):

   resultType = oNodeNew( nEnumType )
   int value = 0
   int numValues = 0
   boolean first = true

   % We'll declare the enum values in two scopes: the current scope, and a scope nested in the enum type.
   % That will let programs use either <val> or <enumType>.<val>
   Node outerScope = oScopeCurrent
   oScopeBegin( -1, allocUp )   % level is meaningless, and we won't use allocate

   {
      % TO DO: assert that name not already seen in this scope, i.e. this enum.
      %  And possibly not in the outerScope either, since that probably wouldn't count as shadowing.
      %  It might be in some other higher/used scope.
      pIdent
      Node decl = @newIdent( nEnumValue, LAST_ID )
      Node decl2 = @newIdent( nEnumValue, LAST_ID )
      oNodeSet( decl, qType, resultType )
      oNodeSet( decl2, qType, resultType )

      % build up name table, for i/o
      int nameOffset = oStringAllocLit( ID_STRING( LAST_ID ) )
      oNodeSetInt( decl, qNameOffset, nameOffset )
      oNodeSetInt( decl2, qNameOffset, nameOffset )
      [
         | '=', ':=' :
            @ConstExpr
            % value must be ascending
            % this obviously doesn't apply to the first value
            [ equal_zero( numValues )
               | false :
                  [ greater( oValueTop, value )
                     | false :   #eEnumValueNotAscending
                     | * :
                  ]
               | * :
            ]
            [ equal( value, oValueTop )
               | false :
                  % The values differ from 0..N-1.  pred/succ may not be used with this type.
                  oNodeSetBoolean( resultType, qHasGap, true )
               | * :
            ]
            value = oValueTop
            oValuePop
         | * :
      ]
      oNodeSetInt( decl, qValue, value )
      oNodeSetInt( decl2, qValue, value )
      oScopeDeclare( decl )

      oScopeEnter( outerScope )
      oScopeDeclare( decl2 )
      oScopeEnd

      inc( value )
      inc( numValues )
      [
         | ',' :
         | * :    >
      ]
   }
   ')'

   oNodeSet( resultType, qScope, oScopeCurrent )
   oNodeSetInt( resultType, qSize, 4 )   % always integer sized
   oScopeEnd

   % Finish creation of the name table
   %    struct {
   %      int    value;
   %      int    padding;
   %      char*  name;
   %    } table[ numValues + 1 ];
   %  final entry will have name == nullptr
   %
   % I'll need to generate init code, to store pointers in global data,
   % since I don't have a relocation mechanism for static data at the moment.
   oCodePush( @GetOrCreateInitCode( globalScope ) )
   oScopeEnter( globalScope )
   int size = multiply( add( numValues, 1 ), 16 )
   int addr = oScopeAlloc( size, 8 )
   oScopeEnd
   oNodeSetInt( resultType, qNameTable, addr )
   % loop over enum values
   NodeIter it = oNodeGetIter( oNodeGet( resultType, qScope ), qDecls )
   {
      Node enumValue = oNodeIterValue( it )
      [ oNodeNull( enumValue )
         | true :  >
         | * :
      ]
      .tPushAddrGlobal  oEmitInt( addr )
      .tPushConstI  oEmitInt( oNodeGetInt( enumValue, qValue ) )
      .tAssignI
      addr = add( addr, 8 )
      .tPushAddrGlobal  oEmitInt( addr )
      .tPushAddrGlobal  oEmitInt( oNodeGetInt( enumValue, qNameOffset ) )
      .tAssignP
      addr = add( addr, 8 )
      oNodeIterNext( it )
   }
   % final table entry
   .tPushAddrGlobal  oEmitInt( addr )
   .tPushConstI  oEmitInt( 0 )
   .tAssignI
   addr = add( addr, 8 )
   .tPushAddrGlobal  oEmitInt( addr )
   .tPushConstI  oEmitInt( 0 )
   .tAssignP
   addr = add( addr, 8 )
   oCodePop

   oTypeAdd( resultType )
   ;


% --------------------------- Const Expressions --------------------------

% Constant expressions: currently, only literal integers or previously
% named constant integers are supported, possibly with a negation.
% Constant expressions are evaluated at compile time.

ConstExpr:
   [
      | pIntLit :
         oValuePush( TOKEN_VALUE )
      | pIdent :
         Node decl = oScopeFindRequire
         @ResolveUnitRef( decl )
         [ oNodeType( decl )
            | nConst :
               oValuePush( oNodeGetInt( decl, qValue ) )
            | * :
               #eNotConst
               oValuePush( 0 )
         ]
      | pMinus :
         @ConstExpr
         oValueNegate
   ];



% ------------------------------ Expressions -----------------------------

% There are two wrappers leading into expression parsing:
%   Expr()
%   BooleanExprControlFlow( out Label falseLabel )
%
% Expr always produces a value on the runtime expr stack,
% and pushes its type on the type stack.
%
% BooleanExprControlFlow always generates control-flow code.
% It does not push a value on the runtime expr stack.
% It does not push a type on the type stack.
% The control flow code ends up at Here if the expr is true,
% and jumps to falseLabel if the expr is false.
% This rule allocates falseLabel, and passes it back.
% The caller will need to define its location.
%
% The internal methods of expr parsing may produce a mix of
% values and control flow, depending on the operators seen.
% We don't always do one or the other, hoping to be efficient for
% cases like   "func_call( bool_var1, bool_var2 )"
% as well as  "if bool_expr1 or bool_expr2 then ...".
% If a subexpression rule produces control flow, it will allocate a
% falseLabel and pass it back up.  And it will push the
% result type as BooleanCFType, to distinguish from BooleanType
% which corresponds with a boolean value on the expr stack.
% 
% Note that my expression parsing is broken into more levels than
% grammars describe for Pascal precedence levels.  This follows my
% original parser implementation.  I think my rationale was that
% operators from the levels that I split up couldn't have been
% mixed anyway, since they require different data types
% (e.g. boolean vs int/real).  And splitting them up simplified
% my code.  But, I should revisit this.
%


% Public entry point:
%
% Parse an expression, leaving a value on the runtime expr stack
% and its type on the type stack.
%
% This rule does not export control flow (though it may generate
% control flow internally for subexpressions).
%
Expr:
   Label falseLabel = labelNull

   @ExprAllowCF( falseLabel )
   @CFToVal( falseLabel );


% Public entry point:
%
% Parse a Boolean expression, producing control flow code rather than a value.
% Does not leave a value on the runtime expr stack.
% Does not leave a type on the type stack.
%
% If the expression is true, the code will fall through to the end (Here).
% If the expression is false, the code will jump to the given falseLabel,
% which this rule will allocate but not define the location for.
% The caller must do so.
%
BooleanExprControlFlow( out Label falseLabel ):
   @ExprAllowCF( falseLabel )
   [ oTypeSNodeType
      | nBooleanCFType :
      | nBooleanType :
         % convert value to control flow
         falseLabel = oLabelNew
         .tJumpFalse  oEmitLabel( falseLabel )
      | * :
         #eNotBoolean
   ]
   oTypeSPop;


% If the current expr result is control flow, convert it to a value.
% falseLabel is the label that had been used by the control flow.
% On return it will be set to labelNull.
%
CFToVal( inout Label falseLabel ):
   [ oTypeSNodeType
      | nBooleanCFType :
         Label doneLabel = oLabelNew
         .tPushConstI  oEmitInt( 1 )
         .tJump  oEmitLabel( doneLabel )
         .tLabel  oEmitLabel( falseLabel )
         .tPushConstI  oEmitInt( 0 )
         .tLabel  oEmitLabel( doneLabel )
         oTypeSPop
         oTypeSPush( BooleanType )
         falseLabel = labelNull
      | * :
   ];


% If the current expr result is boolean value, convert it to control flow.
% falseLabel will be allocated by this rule and passed back.
% The caller must define its location.
%
ValToCF( out Label falseLabel ):
   [ oTypeSNodeType
      | nBooleanType :
         falseLabel = oLabelNew
         .tJumpFalse  oEmitLabel( falseLabel )
         oTypeSPop
         oTypeSPush( BooleanCFType )
      | * :
   ];


% Parse an expression.  It may produce a value on the expr stack,
% or control flow, depending on what's seen in the expression.
% Leaves the expression type on the type stack.
%
% If the expression produces control flow, the expression type will be
% nBooleanCFType.  In this case, a true value falls through to Here,
% and a false value jumps to falseLabel.  This rule will allocate falseLabel
% and return it, but will not define its location; the caller must do so.
%
% If the expression produces a value, the value will be left on the
% expression stack, and the type will be some type other than nBooleanCFType.
% In this case, falseLabel is ignored.
%
ExprAllowCF( out Label falseLabel ):
   @BoolExprAllowCF( falseLabel )
   {[
      | '=' :
         @CFToVal( falseLabel )
         @PromoteToIntOptional
         @BoolExprAllowCF( falseLabel )
         @CFToVal( falseLabel )
         @PromoteToIntOptional
         @MatchTypes
         [ oTypeSNodeType
            | nIntegerType, nEnumType, nBooleanType :  .tEqualI
            | nPointerType :                .tEqualP
            | nCharType, nStringType :      #eNotImplemented
            | * :                           #eNotAllowed
         ]
         oTypeSPop
         oTypeSPush( BooleanType )

      | '<>' :
         @CFToVal( falseLabel )
         @PromoteToIntOptional
         @BoolExprAllowCF( falseLabel )
         @CFToVal( falseLabel )
         @PromoteToIntOptional
         @MatchTypes
         [ oTypeSNodeType
            | nIntegerType, nEnumType, nBooleanType :  .tNotEqualI
            | nPointerType :                .tNotEqualP
            | nCharType, nStringType :      #eNotImplemented
            | * :                           #eNotAllowed
         ]
         oTypeSPop
         oTypeSPush( BooleanType )

      | '<' :
         @CFToVal( falseLabel )
         @PromoteToIntOptional
         @BoolExprAllowCF( falseLabel )
         @CFToVal( falseLabel )
         @PromoteToIntOptional
         @MatchTypes
         [ oTypeSNodeType
            | nIntegerType, nEnumType, nBooleanType :  .tLessI
            | nCharType, nStringType :      #eNotImplemented
            | * :                           #eNotAllowed
         ]
         oTypeSPop
         oTypeSPush( BooleanType )

      | '>' :
         @CFToVal( falseLabel )
         @PromoteToIntOptional
         @BoolExprAllowCF( falseLabel )
         @CFToVal( falseLabel )
         @PromoteToIntOptional
         @MatchTypes
         [ oTypeSNodeType
            | nIntegerType, nEnumType, nBooleanType :  .tGreaterI
            | nCharType, nStringType :      #eNotImplemented
            | * :                           #eNotAllowed
         ]
         oTypeSPop
         oTypeSPush( BooleanType )

      | '<=' :
         @CFToVal( falseLabel )
         @PromoteToIntOptional
         @BoolExprAllowCF( falseLabel )
         @CFToVal( falseLabel )
         @PromoteToIntOptional
         @MatchTypes
         [ oTypeSNodeType
            | nIntegerType, nEnumType, nBooleanType :  .tLessEqualI
            | nCharType, nStringType :      #eNotImplemented
            | * :                           #eNotAllowed
         ]
         oTypeSPop
         oTypeSPush( BooleanType )

      | '>=' :
         @CFToVal( falseLabel )
         @PromoteToIntOptional
         @BoolExprAllowCF( falseLabel )
         @CFToVal( falseLabel )
         @PromoteToIntOptional
         @MatchTypes
         [ oTypeSNodeType
            | nIntegerType, nEnumType, nBooleanType :  .tGreaterEqualI
            | nCharType, nStringType :      #eNotImplemented
            | * :                           #eNotAllowed
         ]
         oTypeSPop
         oTypeSPush( BooleanType )

      | * :
         >
   ]};


BoolExprAllowCF( out Label falseLabel ):
   Label trueLabel = labelNull

   @BoolTermAllowCF( falseLabel )
   {[
      | pOr :
         [ oTypeSNodeType
            | nBooleanCFType :
               % We are true here. Jump ahead to done
               [ equal_label( trueLabel, labelNull )
                  | true :  trueLabel = oLabelNew
                  | * :
               ]
               .tJump  oEmitLabel( trueLabel )
            | nBooleanType :
               @ValToCF( falseLabel )
               % We are true here. Jump ahead to done
               [ equal_label( trueLabel, labelNull )
                  | true :  trueLabel = oLabelNew
                  | * :
               ]
               .tJump  oEmitLabel( trueLabel )
            | * : #eNotBoolean
         ]
         oTypeSPop

         % false in previous term will jump here, to try this alternative term
         .tLabel  oEmitLabel( falseLabel )

         % we'll get a new falseLabel for this term
         falseLabel = labelNull
         @BoolTermAllowCF( falseLabel )

         [ oTypeSNodeType
            | nBooleanCFType :
            | nBooleanType :
               @ValToCF( falseLabel )
            | * : #eNotBoolean
         ]

         oTypeSPop
         oTypeSPush( BooleanCFType )

      | * :
         >
   ]}

   % any short-circuit trues jump here to the end
   [ equal_label( trueLabel, labelNull )
      | false :
         .tLabel  oEmitLabel( trueLabel )
      | * :
   ]
   ;


BoolTermAllowCF( out Label falseLabel ):
   Label overallFalseLabel = labelNull

   @BoolFactorAllowCF( falseLabel )
   {[
      | pAnd :
         [ oTypeSNodeType
            | nBooleanCFType :
            | nBooleanType :
               @ValToCF( falseLabel )
            | * :
               #eNotBoolean
         ]
         oTypeSPop

         % We're going to have a different falseLabel for each term,
         % because we let each rule allocate its own (rather than accepting labels passed in).
         % And in this case we want them all to go to the same place,
         % to be determined by the caller.
         %
         % I'll allow for label aliases.  This will be more optimal than generating
         % multiple private false-handling code segments, that the true path would have to
         % jump around.  That would be hard to eliminate afterwards.

         [ equal_label( overallFalseLabel, labelNull )
            | true :
               overallFalseLabel = oLabelNew
               .tLabelAlias  oEmitLabel( falseLabel )  oEmitLabel( overallFalseLabel )
               falseLabel = overallFalseLabel
            | * :
         ]

         Label factorFalseLabel = labelNull
         @BoolFactorAllowCF( factorFalseLabel )

         [ oTypeSNodeType
            | nBooleanCFType :
            | nBooleanType :
               @ValToCF( factorFalseLabel )
            | * : #eNotBoolean
         ]
        .tLabelAlias  oEmitLabel( factorFalseLabel )  oEmitLabel( overallFalseLabel )

      | * :
         >
   ]};

BoolFactorAllowCF( out Label falseLabel ):
   [
      | pNot :
         Label factorFalseLabel = labelNull

         @BoolFactorAllowCF( factorFalseLabel )
         [ oTypeSNodeType
            | nBooleanCFType :
               % We have control flow, and are sitting at the point that has value false.
               falseLabel = oLabelNew
               .tJump  oEmitLabel( falseLabel )
               % The true path jumps here
               .tLabel  oEmitLabel( factorFalseLabel )

            | nBooleanType :
               % I have a value.  I'll leave it as a value, rather than create control flow.
               % See how this goes.
               .tNot

            | * : #eNotBoolean
         ]

      | * :
         @ArithExprAllowCF( falseLabel )
   ];

ArithExprAllowCF( out Label falseLabel ):
   @TermAllowCF( falseLabel )
   {[
      | pPlus :
         @PromoteToIntPop
         @TermAllowCF( falseLabel )  % actually not allowing CF, will be caught by type check
         @PromoteToInt
         .tAddI
      | pMinus :
         @PromoteToIntPop
         @TermAllowCF( falseLabel )
         @PromoteToInt
         .tSubI
      | * :
         >
   ]};

TermAllowCF( out Label falseLabel ):
   @FactorAllowCF( falseLabel )
   {[
      | pTimes :
         @PromoteToIntPop
         @FactorAllowCF( falseLabel )  % actually not allowing CF, will be caught by type check
         @PromoteToInt
         .tMultI
      | pDivide :
         @PromoteToIntPop
         @FactorAllowCF( falseLabel )
         @PromoteToInt
         .tDivI
      | * :
         >
   ]};

FactorAllowCF( out Label falseLabel ):
   [
      | pPlus :
         @PrimaryAllowCF( falseLabel )  % actually not allowing CF, will be caught by type check
         % TO DO: unary +/- is supposed to leave expression type as-is.
         @PromoteToInt
      | pMinus :
         @PrimaryAllowCF( falseLabel )
         % TO DO: unary +/- is supposed to leave expression type as-is.
         @PromoteToInt
         .tNegI
      | * :
         @PrimaryAllowCF( falseLabel )
   ];

PrimaryAllowCF( out Label falseLabel ):
   [
      | pIntLit :
         .tPushConstI  oEmitInt( TOKEN_VALUE )
         oTypeSPush( IntegerType )

      | pCharLit :
         .tPushConstI  oEmitInt( TOKEN_VALUE )
         oTypeSPush( CharType )

      | '(' :
         @ExprAllowCF( falseLabel )
         ')'

      | pStrLit :
         int addr = oStringAllocLit( CURRENT_STRLIT )     % store in global data
         .tPushAddrGlobal oEmitInt( addr )
         % TO DO: do we need to create a type with the literal's length?
         oTypeSPush( StringType )

      | pIdent :
         Node decl = oScopeFindRequire
         @ResolveUnitRef( decl )
         Node theType

         [ oNodeType( decl )
            | nFunc :
               @Call( decl )

            | nBuiltInFunc :
               @CallBuiltInFunc( decl )

            | nConst, nEnumValue :
               theType = oNodeGet( decl, qType )
               oTypeSPush( theType )
               [ oTypeSNodeType
                  | nIntegerType, nEnumType, nBooleanType :
                     .tPushConstI @EmitValue( decl )
                  | * :
                     #eNotImplemented
               ]

            | nGlobalVar, nLocalVar, nParam, nTypedConst :
               @VarExpr( decl )

            | * :
               #eNotValue
               oTypeSPush( IntegerType )
         ]

      | '@' :        % @var -- pointer to var
         pIdent

         Node decl = oScopeFindRequire
         @ResolveUnitRef( decl )
         Node theType

         @LValueVar( decl )

         % The above leaves the pointed-to type on type stack.
         % Replace with ptr-to-<type>.
         theType = oTypeSTop
         oTypeSPop
         Node ptrType = @PointerTypeTo( theType )
         oTypeSPush( ptrType )

      | * :
         #eNotValue
         oTypeSPush( IntegerType )
   ];


% Parse a variable expression, given the declaration of the
% just-accepted identifier.
% Leaves the value on the expression stack, and type on the type stack.
%
VarExpr( Node decl ):
   Node theType = oNodeGet( decl, qType )
   % how many levels up the static scope? Will ignore for globals.
   int uplevels = @DeclUpLevels( decl )

   oTypeSPush( theType )
   [ oTypeSNodeType
      | nIntegerType, nEnumType :
         [ oNodeType( decl )
            | nGlobalVar, nTypedConst :   .tPushGlobalI  @EmitValue( decl )
            | nLocalVar :
               [ equal_zero( uplevels )
                  | true :  .tPushLocalI  @EmitValue( decl )
                  | * :     .tPushUpLocalI  oEmitInt( uplevels )  @EmitValue( decl )
               ]
            | nParam :
               [ oNodeGetBoolean( decl, qInOut )
                  | true :    % VAR param points to the var.  Auto dereference.
                     [ equal_zero( uplevels )
                        | true :  .tPushParamP  @EmitValue( decl )
                        | * :     .tPushUpParamP  oEmitInt( uplevels )  @EmitValue( decl )
                     ]
                     .tFetchI
                  | * :
                     [ equal_zero( uplevels )
                        | true :  .tPushParamI  @EmitValue( decl )
                        | * :     .tPushUpParamI  oEmitInt( uplevels )  @EmitValue( decl )
                     ]
               ]
         ]

      | nBooleanType, nByteType, nCharType :
         [ oNodeType( decl )
            | nGlobalVar, nTypedConst :   .tPushGlobalB  @EmitValue( decl )
            | nLocalVar :
               [ equal_zero( uplevels )
                  | true :  .tPushLocalB  @EmitValue( decl )
                  | * :     .tPushUpLocalB  oEmitInt( uplevels )  @EmitValue( decl )
               ]
            | nParam :
               [ oNodeGetBoolean( decl, qInOut )
                  | true :    % VAR param points to the var.  Auto dereference.
                     [ equal_zero( uplevels )
                        | true :  .tPushParamP  @EmitValue( decl )
                        | * :     .tPushUpParamP  oEmitInt( uplevels )  @EmitValue( decl )
                     ]
                     .tFetchB
                  | * :
                     [ equal_zero( uplevels )
                        | true :  .tPushParamB  @EmitValue( decl )
                        | * :     .tPushUpParamB  oEmitInt( uplevels )  @EmitValue( decl )
                     ]
               ]
         ]

      | nStringType, nFileType :
         #eNotImplemented

      | nPointerType :
         [ oNodeType( decl )
            | nGlobalVar, nTypedConst :   .tPushGlobalP @EmitValue( decl )
            | nLocalVar :
               [ equal_zero( uplevels )
                  | true :  .tPushLocalP  @EmitValue( decl )
                  | * :     .tPushUpLocalP  oEmitInt( uplevels )  @EmitValue( decl )
               ]
            | nParam :
               [ oNodeGetBoolean( decl, qInOut )
                  | true :    % VAR param points to the var.  Auto dereference.
                     [ equal_zero( uplevels )
                        | true :  .tPushParamP  @EmitValue( decl )
                        | * :     .tPushUpParamP  oEmitInt( uplevels )  @EmitValue( decl )
                     ]
                     .tFetchP
                  | * :
                     [ equal_zero( uplevels )
                        | true :  .tPushParamP  @EmitValue( decl )
                        | * :     .tPushUpParamP  oEmitInt( uplevels )  @EmitValue( decl )
                     ]
               ]
         ]
         [
            | '^' :             % dereferenced
               oTypeSPop
               oTypeSPush( oNodeGet( theType, qBaseType ) )
               @LValueIndexes
               @FetchVar
            | * :               % just ptr value alone
         ]

      | nArrayType, nRecordType :
         % compound type
         % first, push addr of start of var
         [ oNodeType( decl )
            | nGlobalVar, nTypedConst :   .tPushAddrGlobal @EmitValue( decl )
            | nLocalVar :
               [ equal_zero( uplevels )
                  | true :  .tPushAddrLocal  @EmitValue( decl )
                  | * :     .tPushAddrUpLocal  oEmitInt( uplevels )  @EmitValue( decl )
               ]
            | nParam :
               [ oNodeGetBoolean( decl, qInOut )
                  | true :    % VAR param points to the var.  Auto dereference.
                     [ equal_zero( uplevels )
                        | true :  .tPushParamP  @EmitValue( decl )
                        | * :     .tPushUpParamP  oEmitInt( uplevels )  @EmitValue( decl )
                     ]
                  | * :
                     [ equal_zero( uplevels )
                        | true :  .tPushAddrParam  @EmitValue( decl )
                        | * :     .tPushAddrUpParam  oEmitInt( uplevels )  @EmitValue( decl )
                     ]
               ]
         ]
         % modify addr for subscripts, field references, etc
         @LValueIndexes
         % get final value
         @FetchVar
   ];


% Addr of start of var is on expr stack; type is on type stack.
% Replace expr stack with value of var.
% (In the case of compound vars, this remains as the addr of the var).

FetchVar:
   [ oTypeSNodeType
      | nIntegerType, nEnumType :  .tFetchI
      | nBooleanType, nByteType, nCharType :  .tFetchB
      | nStringType, nFileType :   #eNotImplemented
      | nPointerType :             .tFetchP
      | nArrayType, nRecordType :  % compound type; leave as addr
   ];


% Addr of start of var is already on run stack, and type is on type stack.
% Read subscripts, record fields, etc, to get final addr on run stack, and final type
% on type stack.

LValueIndexes:
   {[
      | '[' :       @ArraySubscripts
      | '.' :       @RecordFieldRef
      | '^' :       @PointerDeref
      | * :         >
   ]};

ArraySubscripts:
   [ oTypeSNodeType
      | nArrayType :
      | * :       #eNotArray
   ]
   {
      [ oTypeSNodeType
         | nArrayType :
         | * :    #eTooManySubscripts
      ]

      % low subscript of this dimension
      int low = @OrdinalLow( oNodeGet( oTypeSTop, qIndexType ) )

      % replace type stack with next dimension, or OF type
      Node baseType
      baseType = oNodeGet( oTypeSTop, qBaseType )
      oTypeSPop
      oTypeSPush( baseType )

      @Expr
      @RequireIntPop
      % adjust for low subscript
      [ equal_zero( low )
         | false :
            .tPushConstI oEmitInt( low ) .tSubI
         | * :
      ]

      % multiply by element size
      int size = oNodeGetInt( baseType, qSize )
      [ equal( size, 1 )
         | false :
            .tPushConstI oEmitInt( size ) .tMultI
         | * :
      ]

      % update start address
      .tAddPI
      [
         | ']' :  >
         | ',' :
      ]
   };


RecordFieldRef:
   [ oTypeSNodeType
      | nRecordType :
      | * :    #eNotRecord
   ]
   oScopeEnter( oNodeGet( oTypeSTop, qScope ) )
   pIdent
   Node field = oScopeFindRequire
   % oScopeFind searches all open scopes, so make sure we found nRecordField
   % which could only be seen in the local scope we entered above.
   [ oNodeType( field )
      | nRecordField :
      | * :   #eNotRecordField
   ]
   oScopeEnd
   int offset = oNodeGetInt( field, qValue )
   [ equal_zero( offset )
      | false :
         .tPushConstI oEmitInt( offset ) .tAddPI
      | * :
   ]

   % replace the type on the type stack, with the field type
   oTypeSPop
   oTypeSPush( oNodeGet( field, qType ) )
   ;


% ptr deref on left side, i.e. BEFORE addr of ptr var is on stack,
%                              AFTER addr of thing pointed to is on stack
PointerDeref:
   [ oTypeSNodeType
      | nPointerType :
      | * :       #eNotPointer
   ]
   .tFetchP           % now addr on stack is addr of what we're pointing to

   Node theType = oTypeSTop
   oTypeSPop
   oTypeSPush( oNodeGet( theType, qBaseType ) )
   ;


% The expr stack contains a value whose type is on top of the type stack.
% Generate code to coerce the value to the type under it in the type stack
% (pop the type stack, leaving only the desired type).
% This is used for assignment.
%
CoerceType:
   node_type nt = oTypeSNodeType
   oTypeSPop
   [ equal_node_type( nt, oTypeSNodeType )
      | false :
         % Can we implicitly convert the value to the desired type?
         [ oTypeSNodeType
            | nIntegerType :
               [ nt
                  | nByteType :   .tCastBtoI  >>
                  | * :
               ]
            | nByteType :
               [ nt
                  | nIntegerType :   .tCastItoB  >>
                  | * :
               ]
            | * :
         ]
         #eTypeMismatch
      | * :
   ];


% Called on first use of an extern method
%
DefineExternLabel( Node method ):
   % The extern name might be given explicitly, otherwise the pascal method name.
   int strAddr
   String externalName = oNodeGetString( method, qExternalName )
   [ equal_string( externalName, stringNull )
      | true :
         strAddr = oStringAllocLit( ID_STRING( oNodeGetInt( method, qIdent ) ) )
      | false :
         strAddr = oStringAllocLit( externalName )
   ]
   .tLabelExtern  @EmitValue( method )  oEmitInt( strAddr )
   ;


% Parse a call, given an nProc or nFunc for the just-accepted identifier.
% If a func, this will also generate the code to push the return value on the expr stack,
% and push the return type on the type stack.
%
Call( Node method ):

   % Prior to first call, issue extern label for a called method.
   % I don't want to issue .tLabelExtern for unused methods, that seems inefficient.
   [ oNodeGetBoolean( method, qExternal )
      | true :
         [ oNodeGetBoolean( method, qUsed )
            | false :
               % define the extern label on first use
               @DefineExternLabel( method )
            | * :
         ]
     | * :
   ]
   oNodeSetBoolean( method, qUsed, true )

   % If the method has a cdecl modifier, the back end will need to use the native
   % calling convention, instead of my own.  But, the convention varies by platform,
   % so the front end won't assume what it needs.  I'll still generate the normal tcode
   % that copies values into actuals space on the stack.
   % However, to help the back end, I will at least use a different instruction for the
   % allocation of the actuals space, and for the actual call.
   %
   % p.s. I only support cdecl on external methods, because I don't have a way
   % to let my own Pascal methods read params passed in with the cdecl calling convention.
   %
   boolean cdecl = oNodeGetBoolean( method, qCdecl )

   % If this is a function, we will allocate a temporary
   % in the current scope, to hold the result value.
   % And pass a pointer to that temporary as an extra parameter.
   Node resultType
   int tempOffset

   boolean isFunc = equal_node_type( oNodeType( method ), nFunc )

   [ isFunc
      | true :
         resultType = oNodeGet( method, qType )
         tempOffset = oScopeAllocType( resultType )
         % TO DO: we could manage temp allocation, so temp space can be reused
         %        by different code branches.
      | * :
   ]
   

   Node paramScope = oNodeGet( method, qParams )
   int actualsSize = oNodeGetInt( paramScope, qSize )
   [ cdecl
      | true : .tAllocActualsCdecl  oEmitInt( actualsSize )
      | false :  .tAllocActuals  oEmitInt( actualsSize )
   ]

   % If method is nested, it takes a hidden first parameter:
   % a pointer to the frame of the static scope in which the method is declared.
   % The location of a scope's frame is equivalent to offset 0 in the scope's locals space
   % (since local offsets are relative to the scope's frame pointer).
   %
   % The nested method may be in a higher scope (upLevels > 1),
   % or a sibling of the method we're in (upLevels = 1),
   % or an immediate child of the current method (upLevels = 0).
   %
   % To understand the upLevels computation, remember that a method's declaration
   % and its contents (variables, nested functions, and body statement)
   % are in two different scopes.

   [ greater( @DeclLevel( method ), 0 )
      | true :
         .tPushAddrActual  oEmitInt( 0 )    % hidden param is at param offset 0
         .tPushAddrUpLocal  oEmitInt( @DeclUpLevels( method ) )  oEmitInt( 0 )
         .tAssignP
      | * :
   ]


   NodeIter paramIter = oNodeGetIter( paramScope, qDecls )
   Node param = oNodeIterValue( paramIter )
   [
      | '(' :
      
         {
            [ oNodeNull( param )
               | true : >
               | * :
            ]

            int offset = oNodeGetInt( param, qValue )

            % Assign actual value to spot in actuals space
            .tPushAddrActual oEmitInt( offset )
            oTypeSPush( oNodeGet( param, qType ) )

            [ oNodeGetBoolean( param, qInOut )
               | true :   % A VAR param.
                          % The actual is a pointer to the value.
                          % The type on the type stack (pushed above) is for the pointed-to value.

                          @LValueExpr
                          % Addr of the referenced variable is on the expr stack,
                          % type of the variable is on the type stack.

                          % Match types more exactly. It's not sufficient to be assign compatible
                          % since the method will be assigning to the actual using the param type.
                          % Maybe something like type contents must match, incl subrange bounds.
                          @MatchTypes

                          .tAssignP

               | false :  @Expr
                          @CoerceType
                          
                          % Assign to offset in actuals space

                          [ oTypeSNodeType
                             | nIntegerType, nEnumType : .tAssignI
                             | nBooleanType, nByteType, nCharType :  .tAssignB
                             | nStringType, nFileType :   #eNotImplemented
                             | nPointerType :            .tAssignP
                             | nArrayType, nRecordType :
                                 % compound types: copy value into actuals space
                                 int size = oNodeGetInt( oTypeSTop, qSize )
                                 .tCopy  oEmitInt( size )    % multi-word copy
                          ]
            ]
            oTypeSPop

            oNodeIterNext( paramIter )
            param = oNodeIterValue( paramIter )
            [ oNodeNull( param )
               | true :  >
               | false :
            ]

            ','
         }

         ')'

      | * :
   ]

   [ oNodeNull( param )
      | false :    #eMissingParameter
      | * :
   ]

   [ isFunc
      | true :
         % Pass result temp as an additional VAR parameter.
         .tPushAddrActual oEmitInt( oNodeGetInt( method, qResultOffset ) )
         .tPushAddrLocal  oEmitInt( tempOffset )
         .tAssignP
      | * :
   ]

   [ cdecl
      | true :
         .tCallCdecl  @EmitValue( method )
      | false :
         .tCall   @EmitValue( method )
   ]

   [ isFunc
      | true :
         % push return value from temp
         oTypeSPush( resultType )

         [ oTypeSNodeType
            | nIntegerType, nEnumType :   .tPushLocalI  oEmitInt( tempOffset )
            | nBooleanType, nByteType, nCharType :   .tPushLocalB  oEmitInt( tempOffset )
            | nStringType, nFileType :  #eNotImplemented
            | nPointerType :   .tPushLocalP  oEmitInt( tempOffset )
            | nArrayType, nRecordType :   % compound type: push address
                               .tPushAddrLocal  oEmitInt( tempOffset )
         ]
      | * :
   ]
   
   .tFreeActuals  oEmitInt( actualsSize )
   ;


% Parse a call to a built-in function, identified by the just-accepted identifier.
% This will also generate the code to push the return value on the expr stack,
% and push the return type on the type stack.
%
CallBuiltInFunc( Node method ):

   % Ord(x)
   [ oNodeEqual( method, BuiltIn_Ord )
      | true :
         % parameter is any scalar type (including boolean, enum, char)
         % result is integer
         '('
         @Expr
         [ oTypeSNodeType
            | nIntegerType, nEnumType :
            | nBooleanType, nByteType, nCharType :  .tCastBtoI
            | * :  #eTypeMismatch
         ]
         oTypeSPop
         oTypeSPush( IntegerType )
         ')'
         >>
      | * :
   ]

   % Chr(x)
   [ oNodeEqual( method, BuiltIn_Chr )
      | true :
         % parameter is integer
         % result is char
         '('
         @Expr
         [ oTypeSNodeType
            | nIntegerType :    .tCastItoB
            | nByteType :
            | * :  #eTypeMismatch
         ]
         oTypeSPop
         oTypeSPush( CharType )
         ')'
         >>
      | * :
   ]

   % Pred(x)
   [ oNodeEqual( method, BuiltIn_Pred )
      | true :
         % parameter is any enum type, as long as it has values 0..N-1
         % result is the same enum type
         '('
         @Expr
         [ oTypeSNodeType
            | nEnumType :
               % TO DO: does this skip past type aliases?
               % TO DO: what if using pred/succ on a subrange type?
               [ oNodeGetBoolean( oTypeSTop, qHasGap )
                  | true :   #eCantUsePredSuccOnEnumWithValueGaps
                  | * :
               ]
            | * :  #eTypeMismatch
         ]
         .tDecI
         ')'
         >>
      | * :
   ]

   % Succ(x)
   [ oNodeEqual( method, BuiltIn_Succ )
      | true :
         % parameter is any enum type, as long as it has values 0..N-1
         % result is the same enum type
         '('
         @Expr
         [ oTypeSNodeType
            | nEnumType :
               % TO DO: does this skip past type aliases?
               % TO DO: what if using pred/succ on a subrange type?
               [ oNodeGetBoolean( oTypeSTop, qHasGap )
                  | true :   #eCantUsePredSuccOnEnumWithValueGaps
                  | * :
               ]
            | * :  #eTypeMismatch
         ]
         .tIncI
         ')'
         >>
      | * :
   ]

   #eNotImplemented
   ;


% ------------------------------ Statements -----------------------------

Statement:
   [
      | pWriteln :     @WritelnStmt
      | pWrite :       @WriteStmt
      | pReadln :      @ReadlnStmt
      | pRead :        @ReadStmt
      | pIf :          @IfStmt
      | pWhile :       @WhileStmt
      | pFor :         @ForStmt
      | pRepeat :      @RepeatStmt
      | pBreak :       @BreakStmt
      | pContinue :    @ContinueStmt
      | pBegin :       @BeginStmt
      | pIdent :       @LabelOrAssignOrCallStmt
      | pGoto :        @GotoStmt
      | pIntLit :      % should be an integer label
                       oChangeIntLitToLabelIdent
                       @LabelOrAssignOrCallStmt
      | * :            % null statement : don't accept any tokens
   ];


LabelOrAssignOrCallStmt:
   Node decl = oScopeFindRequire
   @ResolveUnitRef( decl )
   [ oNodeType( decl )
      | nLabel :                          @LabelDefinition( decl )
                                          @Statement
      | nProc :                           @Call( decl )
      | nGlobalVar, nLocalVar, nParam :   @AssignStmt( decl )
      | nFunc :                           @AssignResultStmt( decl )
      | * :                               #eBadStatement
   ];


% Parse a "label:" prefix in front of a statement.
%
LabelDefinition( Node decl ):
   [ oNodeGetBoolean( decl, qDefined )
      | true :  #eAlreadyDefined
      | * :
   ]
   .tLabel  oEmitLabel( oNodeGetLabel( decl, qValue ) )
   oNodeSetBoolean( decl, qDefined, true )
   ':'
   ;


% Given decl, the just-accepted first identifier on the left hand side.
%
AssignStmt( Node decl ):

   @LValueVar( decl )
   ':=' 
   @Expr
   @CoerceType
   @Assign
   ;


% Performs a raw assignment.
% Given lvalue 2nd on stack, and expr value top of stack,
% and type of both of these on the type stack,
% perform the assignment and pop the type off the type stack.
%
Assign:
   [ oTypeSNodeType
      | nIntegerType, nEnumType :  .tAssignI
      | nBooleanType, nByteType, nCharType :  .tAssignB
      | nStringType, nFileType :   #eNotImplemented
      | nPointerType :             .tAssignP
      % compound var assigns; addrs of src, dest on stack
      | nArrayType, nRecordType :
          int size = oNodeGetInt( oTypeSTop, qSize )
          .tCopy  oEmitInt( size )    % multi-word copy
   ]
   oTypeSPop
   ;

% Given nFunc for the just-accepted identifier on the left hand side.
% Parse an assignment that represents assignment of the function result.
%
AssignResultStmt( Node funcDecl ):
   % Only allowed to assign the result of the immediately enclosing function, I think.
   [ oNodeEqual( oNodeGet( funcDecl, qChildScope ), oScopeCurrent )
      | false :   #eNotCurrentFunction
      | * :
   ]

   % Result value is stored in the caller's space, via a hidden VAR parameter.
   .tPushParamP  oEmitInt( oNodeGetInt( funcDecl, qResultOffset ) )
   oTypeSPush( oNodeGet( funcDecl, qType ) )

   ':='
   @Expr
   @CoerceType
   [ oTypeSNodeType
      | nIntegerType, nEnumType : .tAssignI
      | nBooleanType, nByteType, nCharType :  .tAssignB
      | nStringType, nFileType :   #eNotImplemented
      | nPointerType :            .tAssignP
      % compound var assigns; addrs of src, dest on stack
      | nArrayType, nRecordType :
          int size = oNodeGetInt( oTypeSTop, qSize )
          .tCopy  oEmitInt( size )    % multi-word copy
   ]
   oTypeSPop
   ;



% Parse an lvalue expression, from scratch.
% This is an expression that may appear on the left side of an assignment.
% Leaves the address of the value on the expr stack,
% and the type of the value at that address on the type stack.
%
LValueExpr:
   % At the moment, all lvalue expressions start with a variable name.
   % I think there can also be typecasts, not supported yet.  Check standard syntax.
   pIdent
   Node decl = oScopeFindRequire
   @ResolveUnitRef( decl )
   [ oNodeType( decl )
      | nGlobalVar, nLocalVar, nParam :
      | * :  #eNotVar
   ]
   @LValueVar( decl )
   ;


% Parse an lvalue expression (e.g. left side of an assign statement)
% that starts with the just-accepted identifier indicated by the given decl.
% Leaves the lvalue address on the expression stack,
% and the type of the value at that address on the type stack.
%
LValueVar( Node decl ):
   [ oNodeType( decl )
      | nGlobalVar :   .tPushAddrGlobal @EmitValue( decl )
      | nLocalVar :    .tPushAddrLocal @EmitValue( decl )
      | nParam :
         [ oNodeGetBoolean( decl, qInOut )
            | true :   % VAR param points to variable.  No dereference.
                       .tPushParamP @EmitValue( decl )
            | * :      .tPushAddrParam @EmitValue( decl )
         ]
      | * :            #eNotVar
   ]

   oTypeSPush( oNodeGet( decl, qType ) )
   @LValueIndexes        % handle subscripts, if any
   ;


IncVar( Node decl ):
   @LValueVar( decl )
   @RequireIntPop
   @VarExpr( decl )
   oTypeSPop
   .tIncI
   .tAssignI;

DecVar( Node decl ):
   @LValueVar( decl )
   @RequireIntPop
   @VarExpr( decl )
   oTypeSPop
   .tDecI
   .tAssignI;


IfStmt:
   Label falseLabel = labelNull

   @BooleanExprControlFlow( falseLabel )
   pThen
   @Statement
   [
      | pElse :
         Label doneLabel = oLabelNew

         .tJump  oEmitLabel( doneLabel )
         .tLabel oEmitLabel( falseLabel )
         @Statement
         .tLabel oEmitLabel( doneLabel )

      | * :
         .tLabel oEmitLabel( falseLabel )
   ];


ForStmt:
   pIdent

   Node decl = oScopeFindRequire
   % TO DO: disallow use of a compound variable field.
   %        Could do that by disallowing use of LValueIndexes,
   %        or by double-checking the decl's qType here.
   % TO DO: I think I read somewhere that the variable must be in current scope.
   @LValueVar( decl )
   @RequireIntPop

   ':='

   @Expr
   @RequireIntPop
   .tAssignI

   Label breakLabel = oLabelNew

   Label checkLabel = oLabelNew
   .tJump  oEmitLabel( checkLabel )

   Label continueLabel = oLabelNew
   .tLabel  oEmitLabel( continueLabel )
   [
      | pTo :
         @IncVar( decl )
         .tLabel  oEmitLabel( checkLabel )
         @VarExpr( decl )  oTypeSPop
         @Expr
         @RequireIntPop
         .tGreaterI
         .tJumpTrue  oEmitLabel( breakLabel )
      | pDownto :
         @DecVar( decl )
         .tLabel  oEmitLabel( checkLabel )
         @VarExpr( decl )  oTypeSPop
         @Expr
         @RequireIntPop
         .tLessI
         .tJumpTrue  oEmitLabel( breakLabel )
   ]
   oLoopPush( continueLabel, breakLabel )
   pDo
   @Statement
   .tJump  oEmitLabel( continueLabel )
   .tLabel  oEmitLabel( breakLabel )
   oLoopPop;


RepeatStmt:
   Label continueLabel = oLabelNew
   .tLabel  oEmitLabel( continueLabel )

   Label breakLabel = oLabelNew

   oLoopPush( continueLabel, breakLabel )
   @Statement
   {[
      | ';' :
         @Statement
      | pUntil :
         Label falseLabel
         @BooleanExprControlFlow( falseLabel )
         .tLabelAlias  oEmitLabel( falseLabel )  oEmitLabel( continueLabel )
         >
   ]}
   .tLabel  oEmitLabel( breakLabel )
   oLoopPop;


WhileStmt:
   Label continueLabel = oLabelNew
   .tLabel  oEmitLabel( continueLabel )

   Label breakLabel
   @BooleanExprControlFlow( breakLabel )

   oLoopPush( continueLabel, breakLabel )
   pDo
   @Statement
   .tJump  oEmitLabel( continueLabel )
   .tLabel  oEmitLabel( breakLabel )
   oLoopPop;


ContinueStmt:                     % NOTE, for repeat..until, skips test (??)
   [ equal_label( oLoopContinueLabel, labelNull )
      | true :
         #eNotInALoop
      | false :
         .tJump  oEmitLabel( oLoopContinueLabel )
   ];


BreakStmt:
   [ equal_label( oLoopBreakLabel, labelNull )
      | true :
         #eNotInALoop
      | false :
         .tJump  oEmitLabel( oLoopBreakLabel )
   ];


GotoStmt:
   [
      | pIdent :
      | pIntLit :
         % Replace token with identifier "_label_<intlit>"
         oChangeIntLitToLabelIdent
   ]

   % Some pascals have rules about where you can jump (to a sibling statement or
   % higher level statement in the block, but not into a lower lower level statement.)
   % fpc just says "jumping into a nested statement can have strange effects."
   % I'm going to follow that and not prohibit any goto, as long as it's in the same block.

   % Label must be declared in the same block (same scope) it is used.
   % Some pascals allow non-local goto, but we do not.
   % That would require more tracking of dynamic scope, to unwind stack.
   % Note: in main program statement, this relies on the temporaries scope extending
   %  the main scope (where a label declaration would occur).
   Node decl = oScopeFindRequireInScope( oScopeCurrent )
   oNodeSetBoolean( decl, qUsed, true )
   .tJump  oEmitLabel( oNodeGetLabel( decl, qValue ) )
   ;


BeginStmt:
   @Statement
   {[
      | ';' :   @Statement
      | pEnd :  >
   ]};


WritelnStmt:
   @WriteStmt
   .tWriteCR;


WriteStmt:
   [
      | '(' :
         {
            @Expr
            [ oTypeSNodeType
               | nIntegerType :             .tWriteI
               | nBooleanType :             .tWriteBool
               | nByteType :                .tCastBtoI  .tWriteI
               | nCharType :                .tWriteChar
               | nStringType :              .tWriteStr
               | nFileType :                #eNotImplemented
               | nEnumType :
                  % write name via table lookup
                  .tPushAddrGlobal  oEmitInt( oNodeGetInt( oTypeSTop, qNameTable ) )
                  .tWriteEnum
               | nPointerType :             .tWriteP
               | * :                        #eNotAllowed
            ]
            oTypeSPop
            [
               | ')' : >
               | ',' :
            ]
         }
      | * :
   ];


ReadlnStmt:      % ***
   % TO DO
   ;

ReadStmt:
   % TO DO
   ;

% -------------------------------- Utilities -------------------------------

% Return the static scope level of the current scope
%
ScopeLevel >> int:
   >> oNodeGetInt( oScopeCurrent, qLevel );

% Return the static scope level of the given declaration
%
DeclLevel( Node decl ) >> int:
   >> oNodeGetInt( oNodeGet( decl, qParentScope ), qLevel );
   

% How many levels higher is the given declaration from the current scope?
%
DeclUpLevels( Node decl ) >> int:
   >> subtract( @ScopeLevel, @DeclLevel( decl ) );


% Require that the top two types on the type stack are matching (ignoring subranges).
% Pop one of them, leaving only one.
%
MatchTypes:
   node_type nt = oTypeSNodeType
   oTypeSPop
   [ equal_node_type( nt, oTypeSNodeType )
      | false :
         #eTypeMismatch
      | * :
   ];


% Require that the top type on the type stack is integer (ignoring subranges).
% Pop it.
%
RequireIntPop:
   [ oTypeSNodeType
      | nIntegerType :
      | * :          #eNotInteger
   ]
   oTypeSPop;

RequireInt:
   [ oTypeSNodeType
      | nIntegerType :
      | * :          #eNotInteger
   ];


% Convert the top value to integer (if it isn't already).
% It must be implicitly convertable to integer.
% Pop the type stack.
%
PromoteToIntPop:
   [ oTypeSNodeType
      | nIntegerType :
      | nByteType :        .tCastBtoI
      | * :                #eNotInteger
   ]
   oTypeSPop;

% Convert the top value to integer (if it isn't already).
% It must be implicitly convertable to integer.
% Leave integer on the type stack.
%
PromoteToInt:
   [ oTypeSNodeType
      | nIntegerType :
      | nByteType :        .tCastBtoI
                           oTypeSPop
                           oTypeSPush( IntegerType )
      | * :                #eNotInteger
   ];


% If the top value is implicitly convertable to integer, do so.
% Otherwise leave it as-is.
%
PromoteToIntOptional:
   [ oTypeSNodeType
      | nByteType :        .tCastBtoI
                           oTypeSPop
                           oTypeSPush( IntegerType )
      | * :
   ];




RequireBoolPop:
   [ oTypeSNodeType
      | nBooleanType :
      | * :          #eNotBoolean
   ]
   oTypeSPop;

RequireBool:
   [ oTypeSNodeType
      | nBooleanType :
      | * :          #eNotBoolean
   ];


% Create and return a new nType of the given node_type, adding it to the type table.
%
newType( node_type nt, int size ) >> Node:
  Node node = oNodeNew( nt )
  oNodeSetInt( node, qSize, size )
  oTypeAdd( node )
  >> node
  ;


% Create and return a new nIdent of the given node_type, with the given ident id.
% Does not add it to any scope.
%
newIdent( node_type nt, int id ) >> Node:
  Node t = oNodeNew( nt )
  oNodeSetInt( t, qIdent, id )
  >> t
  ;


% Return an nType representing a pointer to the given type.
% (Creates a new type if necessary.)
%
PointerTypeTo( Node theType ) >> Node:
   Node ptrType = oNodeGet( theType, qPointerType )
   [ oNodeNull( ptrType )
      | true :
         ptrType = oNodeNew( nPointerType )
         oNodeSet( ptrType, qBaseType, theType )
         oNodeSetInt( ptrType, qSize, 8 )
         oTypeAdd( ptrType )
         oNodeSet( theType, qPointerType, ptrType )
      | * :
   ]
   >> ptrType;


% Return the low value of an ordinal type
%
OrdinalLow( Node theType ) >> int:
   [ oNodeType( theType )
      | nIntegerType :  >> oMININT
      | nBooleanType :  >> 0
      | nCharType :     >> 0
      | nEnumType :
         Node enumScope = oNodeGet( theType, qScope )
         Node first = oNodeIterValue( oNodeGetIter( enumScope, qDecls ) )
         >> oNodeGetInt( first, qValue )
      | nSubrangeType : >> oNodeGetInt( theType, qLow )
      | * :             #eNotOrdinalType
                        >> 0
   ];


% Return the high value of an ordinal type
%
OrdinalHigh( Node theType ) >> int:
   [ oNodeType( theType )
      | nIntegerType :  >> oMAXINT
      | nBooleanType :  >> 1
      | nCharType :     >> 255
      | nEnumType :
         Node enumScope = oNodeGet( theType, qScope )
         Node last = oNodeIterValue( oNodeGetIterLast( enumScope, qDecls ) )
         >> oNodeGetInt( last, qValue )
      | nSubrangeType : >> oNodeGetInt( theType, qHigh )
      | * :             #eNotOrdinalType
                        >> 0
   ];


% Emit the value in a declaration.
% For a constant integer, this is the constant value.
% For a global variable, this is the global address.
% For a local variable, this is the local address relative to the call stack frame.
%
EmitValue( Node decl ):
    oEmitInt( oNodeGetInt( decl, qValue ));


DeclareBuiltInFunc( int id ) >> Node:
   Node decl = @newIdent( nBuiltInFunc, id )
   oScopeDeclare( decl )
   >> decl;


installBuiltIns:

   % install built-in types
   FileType = @newType( nFileType, 4 )
   IntegerType = @newType( nIntegerType, 4 )
   BooleanType = @newType( nBooleanType, 1 )
   BooleanCFType = @newType( nBooleanCFType, 1 )
   CharType = @newType( nCharType, 1 )
   ByteType = @newType( nByteType, 1 )
   StringType = @newType( nStringType, 256 )    % string with default length 256

   % Declare those type identifiers.
   % SSL doesn't support strings, so need help from operations e.g. oIdAdd_File

   Node t

   t = @newIdent( nTypeDecl, oIdAdd_File )
   oNodeSet( t, qType, FileType )
   oScopeDeclare( t )

   t = @newIdent( nTypeDecl, oIdAdd_Integer )
   oNodeSet( t, qType, IntegerType )
   oScopeDeclare( t )

   t = @newIdent( nTypeDecl, oIdAdd_Boolean )
   oNodeSet( t, qType, BooleanType )
   oScopeDeclare( t )

   t = @newIdent( nTypeDecl, oIdAdd_Char )
   oNodeSet( t, qType, CharType )
   oScopeDeclare( t )

   t = @newIdent( nTypeDecl, oIdAdd_Byte )
   oNodeSet( t, qType, ByteType )
   oScopeDeclare( t )

   t = @newIdent( nTypeDecl, oIdAdd_String )
   oNodeSet( t, qType, StringType )
   oScopeDeclare( t )

   % Built-in constants

   t = @newIdent( nConst, oIdAdd_True )
   oNodeSet( t, qType, BooleanType )
   oNodeSetInt( t, qValue, 1 )
   oScopeDeclare( t )

   t = @newIdent( nConst, oIdAdd_False )
   oNodeSet( t, qType, BooleanType )
   oNodeSetInt( t, qValue, 0 )
   oScopeDeclare( t )

   % Built-in methods
   % These aren't declared like normal methods, because they may have
   % special rules for parameter types (e.g. any scalar type).
   % Calls to these methods will be handled specially by the compiler.

   BuiltIn_Ord = @DeclareBuiltInFunc( oIdAdd_Ord )
   BuiltIn_Chr = @DeclareBuiltInFunc( oIdAdd_Chr )
   BuiltIn_Pred = @DeclareBuiltInFunc( oIdAdd_Pred )
   BuiltIn_Succ = @DeclareBuiltInFunc( oIdAdd_Succ )
   ;

end

