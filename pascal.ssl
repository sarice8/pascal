title: 'Pascal Compiler 1.1.5 -- Jan 01 ''90';
   
%
%  Pascal.ssl
%
%  Pascal Compiler for the Amiga, by Steve Rice.
%
%  HISTORY
%    11Sep89   First version, framework of parser.
%    18Sep89   Added some semantic mechanisms.
%    21Sep89   Added simple type references; expressions generate code.
%    22Sep89   Allocate variable addresses as they're declared.
%    24Sep89   Added arrays, pointers.
%    27Sep89   Added for statement.
%    23Oct89   Fixed for statement, so CYCLE goes to next step.
%    01Jan90   Added string literals
%
%  *** WORKING ON : Records ***
%    - fields allocated now, but need to calculate size of whole record
%    - need to make ST a linked list structure for oSymPopLevelSaveType
%      (note, this will mess up SD, and oSymLevelAnySyms)
%    - references to records: currently pushes addr on stack. ok.
%      Field selection '.' should push the fields on the SD, look up
%      the next ident only in that level, add the offset if not 0,
%      replace the current type with the field type, and continue
%      (note, we're in fetch mode here, working with addresses on run stack
%      just as with arrays).
%
%  *** WORKING ON : Procedures ***
%    - formal args declared but not saved (see Records)
%    - allocate args so the #'s match the stack (esp. re VAR flag)
%    - pay attention to VAR flag
%    - formal params are visible to body of proc, but requires special
%      code to access non-global vars.
%      i.e. in expressions, if var is found at SD level > 0, must take it
%      off stack. (possibly with indirection).
%      NOTE, VAR parameters are like pointer vars, with automatic deref ('^')
%      Maybe this helps with the implementation.
%    - Big choice: what is runtime environment of stack machine?
%        Call stack with params, returns
%        Expr stack used within a statement
%        These can be the same if Expr stack always empty before/after an
%        indivisible expression. (??)
%
%  NOTES
%    1) During a loop, the top counter counts the number of 'exit'
%       statements to be patched.
%    2) During a loop, the top entry in the patchLoop stack is the addr
%       of the start of the loop (used by 'cycle' to repeat the loop).
%    3) The 'value' of a var symbol is its allocated address.
%    4) References to vars of intrinsic types, and pointer types,
%       pushes the value of the var on the expr stack.  Referenecs to
%       vars of compound types (arrays, records...) pushes the address
%       on the expr stack.
%    5) Just as there is only one type table entry for a given (named) type,
%       there is only one type table entry for a pointer to a named type.
%       When a pointer type is declared, a field in the TT entry of the
%       type pointed to will be set to indicate the TT entry of the pointer
%       to that type (0 means none defined yet).  When evaluating the
%       expression ^x, the type in that field in the entry for the type of x
%       will be used (unless it's 0, in which case a new TT entry will be
%       created).

input:
   pIdent
   pIntLit
   pStrLit
   pAssign       ':='
   pSemiColon    ';'
   pEqual        '='
   pNotEqual     '<>'
   pLess         '<'
   pGreater      '>'
   pLessEqual    '<='
   pGreaterEqual '>='
   pColon        ':'
   pComma        ','
   pLParen       '('
   pRParen       ')'
   pLSquare      '['
   pRSquare      ']'
   pCarat        '^'
   pDot          '.'
   pDotDot       '..'
   pTimes        '*'
   pDivide       '/'
   pPlus         '+'
   pMinus        '-'
   pEof
   pInvalid

%  keywords  (built-in types 'integer', 'char', etc, are not keywords,
%             type constructors 'array', 'record', 'set' are keywords,
%             pseudo-procedures 'writeln', 'readln' are keywords)

   pProgram
   pProcedure
   pFunction
   pConst
   pType
   pVar
   pBegin
   pEnd
   pArray
   pRecord
   pSet
   pOf
   pIf
   pThen
   pElse
   pFor
   pTo
   pDownto
   pDo
   pWhile
   pRepeat
   pUntil
   pCycle
   pExit
   pReturn
   pAnd
   pOr
   pNot
   pWriteln
   pWrite
   pReadln
   pRead;


output:

%  Instructions for a stack machine (all vars are 32-bit integers)

   tPushIntVar       % push value of int var; addr follows
   tPushBoolVar
   tPushPtrVar
   tPushAddr         % addr (of a var) follows
   tFetchInt         % replace addr (on tos) of int var with contents
   tFetchBool        %    "      "      "     " bool  "   "    "
   tFetchPtr         %    "      "      "     " ptr   "   "    "   
   tPushIntLit       % int lit follows (NOTE, used for BOOLEAN too)
   tAssignInt        % assign value on tos to addr under it (pop both)
   tAssignBool       %   "      "    "   "  "   "    "    "   "   "
   tAssignPtr        % assign val WHOSE ADDR is on tos to addr under it (pop)
   tCopy             % #words follows.  tos=src, 2nd=dest (pop 2)
   tIncIntVar        % increment int var (addr follows)
   tDecIntVar        % decrement int var (addr follows)
   tMultiplyInt      % multiply top two integers (replacing with result)
   tDivideInt
   tAddInt
   tSubtractInt
   tNegateInt        % top entry *= -1
   tNot              % negate top boolean
   tAnd              % boolean AND of top 2 (pop 2, push 1)
   tOr               % boolean OR or top 2 (pop 2, push 1)
   tEqualInt         % top two entries equal? (pop 2, push 1) (true=1)
   tNotEqualInt      %    NOTE, these all work for booleans too
   tGreaterInt       % 2nd entry greater than top entry? (pop 2, push answer)
   tLessInt
   tGreaterEqualInt
   tLessEqualInt
   tEqualPtr         % are the ptr vars whose addresses are top 2 equal?
   tNotEqualPtr
   tCall             % addr follows
   tReturn
   tJump             % addr follows
   tJumpTrue         % addr follows  (pops top of stack, jumps if true)
   tJumpFalse        % addr follows  (pops top of stack, jumps if false)
   tPutInt           % for writeln : write integer on tos, pop
   tPutBool          %  "     "    : write TRUE/FALSE, pop
   tPutStr           %  "     "    : write string whose addr is on tos, pop
   tPutPtr           %  "     "    : write ptr var whose addr is on tos, pop
   tPutCR            %  "     "    : write cr

%  Other:

   tSpace            % emit a hole, to be patched later
   tSymVal           % emit value of symbol looked-up with oSymLookup
   ;

error:
   eBadStatement
   eNotConst
   eNotType
   eNotVar
   eNotIntVar
   eNotValue
   eNotInteger
   eNotBoolean
   eNotPointer
   eNotArray
   eTooManySubscripts
   eTypeMismatch
   eNotImplemented
   eNotAllowed
   eNotInALoop
   eRecordEmpty;

include 'pascal_schema.ssl'

type Node:     % A pointer to a node in the schema database (symbol database)
    Null = 0
    ;

type NodeVec:  % A pointer to a vector of Node.  See mechanism node_vec_mech
    NullVec = 0
    ;

type boolean:
   false    = 0
   true     = 1;

type kind:           % kind of identifier
   kUndefined        % not yet added to symbol table
   kProgram
   kProc
   kFunc
   kConst
   kType
   kVar;

% intrinsic types & type constructs

type typ:
   tyNone     = 0    % in ptrTyp field of TT, means no ptr to type defined
   tyInteger
   tyBoolean
   tyChar
   tyString
   tyFile            % tyInteger..tyFile are scalars (types on their own)
   tyPointer         % following are type constructor classes...
   tyArray           %   (they are not type#'s)
   tyRecord
   tyParams          % like record; a collection of proc/func params
   tySet;


% Some general schema node operations.
% node_type and node_attribute are defined in generated file pascal_schema.ssl included above.
%
mechanism node_mech:
    oNodeNew (node_type) >> Node         % create new node
    oNodeSet (Node, node_attribute, Node)   % set Node attribute of node
    oNodeSetInt (Node, node_attribute, int) % set int attribute of node
    oNodeSetBoolean (Node, node_attribute, boolean)
    oNodeSetKind (Node, node_attribute, kind) % set attribute of node  *** MIGHT NOT NEED
    oNodeGet (Node, node_attribute) >> Node    % get Node attribute of node
    oNodeGetInt (Node, node_attribute) >> int  % get int attribute of node
    oNodeGetBoolean (Node, node_attribute) >> boolean  % get int attribute of node
    oNodeNull (Node) >> boolean          % is node null?
    oNodeNext (inout Node)               % advance Node to next in list
    oNodeType (Node) >> node_type        % return node type of node
    oNodeEqual (Node, Node) >> boolean   % compare two nodes for equality
                                         % (i.e. same node, not just same contents)
    ;


% Manipulate a temporary vector of Node
%
mechanism node_vec_mech:
    oNodeVecNew >> NodeVec
    oNodeVecDelete( NodeVec nv )
    oNodeVecAppend( NodeVec nv, Node n )
    oNodeVecSize( NodeVec nv ) >> int                % how many elements
    oNodeVecElement( NodeVec nv, int idx ) >> Node   % element at index idx (0..size-1)
    ;


mechanism emit_mech:
    oEmitInt( int )              % emit int into the generated code
    Here >> int                  % current address in the generated code
    oPatch( int addr, int val )  % patch an int into address in the generated code
    ;

mechanism math:
    inc (inout int)
    dec (inout int)
    negate (int) >> int
    subtract( int x, int y ) >> int     % x - y
    multiply( int x, int y ) >> int     % x * y
    equal( int x, int y ) >> boolean
    equal_zero (int) >> boolean
    equal_node_type (node_type, node_type) >> boolean     % Want equal_<type> for every type
    ;

mechanism more_builtins:      % These should be built-in SSL operations
    TOKEN_VALUE >> int        % value of just accepted token, e.g. IntLit token
    LAST_ID >> int            % id number of last accepted identifier
    ;

mechanism scope_mech:
    oScopeBegin                          % create a new scope. Subsequent declarations will go here.
    oScopeEnd                            % end current scope. Subsequent declarations will go to parent scope.
    oScopeCurrent >> Node                % returns current scope
    oScopeDeclare( Node )                % add declaration to current scope.
    oScopeDeclareAlloc( Node )           % add declaration to current scope, and allocate space according to its type
    oScopeFind >> Node                   % find declaration of last accepted identifier.  Returns Null if not found.
    oScopeFindRequire >> Node            % find declaration of last accepted identifier.  Error if not found.
    ;


mechanism type_mech:
    oTypeAdd( Node node )     % add the given nType to the type table
    ;

mechanism type_stack_mech:
    oTypeSPush( Node node )
    oTypeSPop
    oTypeSTop >> Node
    oTypeSNodeType >> node_type          % node_type of the node on top of type stack, skipping subranges
    ;


mechanism id_mech:
    % adds a predefined id to the scanner's id table, and returns the id code
    oIdAdd_File >> int
    oIdAdd_Integer >> int
    oIdAdd_Boolean >> int
    oIdAdd_Char >> int
    oIdAdd_String >> int
    oIdAdd_True >> int
    oIdAdd_False >> int
    ;


mechanism count :
   oCountPush(int)          % start a new counter, with initial value
   oCountInc
   oCountDec
   oCountIsZero >> boolean
   oCountPop;

mechanism sym :                

   % symbol table

   oSymPushLevel               % new lexical level
   oSymPopLevel                % return to old lexical level
   oSymPopLevelSaveType        % attach id's in lex level to the syms field
                               %   of the type on top of the type stack
   oSymLookup                  % lookup last id accepted (for use by
                               %   other semantic operations...)
   oSymChooseKind >> kind      % kind of symbol looked-up
   oSymAddSPop                 % add id on symbol stack to symbol table
                               %   (pop symbol stack)
   oSymLevelAnySyms >> boolean % any symbols in top lexical level?

   % symbol stack
   % (used to construct entries for the symbol table,
   %       and to handle references to symbols)

   oSymSPushId                 % push id# of last id accepted
   oSymSSetKind(kind)          % set kind of top symbol (kVar, kType, etc)
                               %   ... error if it was already set
   oSymSSetValPop              % set val of sym on SS from val on VS (pop VS)
   oSymSSetTypS                % set type of top symbol, from type on
                               %   type stack (don't pop type stack)
   oSymSSetParamTypS           % set param type of top symbol from type on TS
   oSymSAllocate               % allocate data space for var, using size of
                               %   type on type stack
   ;

mechanism value :              % value stack, to calc. const expr's
   oValuePushToken             % push value of (int lit) token just read
   oValuePushVal               % push val of symbol looked-up
   oValuePush(int)             % push an explicit int lit
   oValuePushSizeTS            % push size of type on type stack
   oValuePushLowTS             % push low subscript of type on type stack
   oValueNegate                % negate top value
   oValueDifference            % pop 2, push (top - 2nd + 1)
   oValueMultiply              % pop 2, push (top * 2nd)
   oValueIsZero >> boolean     % is top value zero?
   oValueIsOne >> boolean      % is top value one?
   oValueTop >> int            % get top value on value stack
   oValuePop;

mechanism string :
   oStringAllocLit;            % alloc data space for strlit, push address
                               %   on value stack

mechanism typS :               % type stack
   oTypSPushTyp                % push type# of sym looked-up (not root type)
   oTypSPush(typ)              % push explicit type# (intrinsic)
   oTypSPopPushBase            % replace top TS with type# of its base type
   oTypSPopPushPtr             % replace top TS with its ptrType field
   oTypSMatch >> boolean       % do top 2 types match? (pop both, push 1)
   oTypSChoose >> typ          % return type on TS (not root type)
   oTypSChoosePop >> typ       % return type on TS (not root type), pop it
   oTypSChooseKind >> typ      % return kind (array,etc) of top type; no pop
   oTypSChoosePtr >> typ       % return 'ptrType' field of type; no pop
   oTypSSwap                   % swap top two TS entries
   oTypSPop

   oTypNew(typ)                % new TT entry, with type class (e.g. array)
                               %   push typ# on TS, for use by following:
   oTypSetSize                 % size field = VS (don't pop VS)
   oTypAssignBasePop           % base of 2nd on TS := top of TS, pop TS
   oTypAssignPtr               % ptrType of 2nd on TS := top of TS, no pop
;

type patchStack:
   patchLoop                   % addr of start of loop (repeat, while, for)
   patchExit                   % addrs where jumps out of loop are
                               %   (use count mechanism to count how many)
   patchIf;                    % addr of jump around code in 'if' statement

mechanism patch:               % note, creates absolute-address jumps
   oPatchPushHere(patchStack)  % put current address on a patch stack
   oPatchAnyEntries(patchStack) >> boolean     % anything in patch stack?
   oPatchSwap(patchStack)      % swap top two entries
   oPatchDup(patchStack)       % duplicate the top entry
   oPatchPopFwd(patchStack)    % store here at x (x=top of stack), pop stack
   oPatchPopBack(patchStack);  % emit x (so advance 'here'), pop stack

rules

% ----------------------------- Global Variables ----------------------------

Node    globalScope            % global nScope

% built-in nTypes
Node    FileType
Node    IntegerType
Node    BooleanType
Node    CharType
Node    StringType

% -------------------------- Forward Declarations -------------------------

Block( node_type varNodeType );
VarDecl( node_type varNodeType );
newType( node_type nt, int size ) >> Node;
newIdent( node_type nt, kind k, int id ) >> Node;
EmitValue( Node decl );
TypeRef( out Node theType );
PointerTypeTo( Node theType ) >> Node;


% ----------------------------- Declarations ----------------------------

Program:
   Node t

   oScopeBegin
   globalScope = oScopeCurrent

   @installBuiltIns

   pProgram
   pIdent

   t = @newIdent( nProgram, kProgram, LAST_ID )
   oScopeDeclare( t )

   [
      | '(' :
         pIdent      % input, output files

         t = @newIdent( nVar, kVar, LAST_ID )
         oNodeSet( t, qType, FileType )
         oScopeDeclareAlloc( t )

         ','
         pIdent

         t = @newIdent( nVar, kVar, LAST_ID )
         oNodeSet( t, qType, FileType )
         oScopeDeclareAlloc( t )

         ')'
      | * :
   ]
   ';'
   @Block( nGlobalVar )    % not including punctuation after body's 'end'
   '.'
   oScopeEnd
   ;

Block( node_type varNodeType ):
   {[
      | pConst :     @ConstDecl
      | pType :      @TypeDecl
      | pVar :       @VarDecl( varNodeType )
      | pProcedure : @ProcDecl
      | pFunction :  @FuncDecl
      | * :          @Statement
                     .tReturn
                     >
   ]};

ProcDecl:
   Node decl

   pIdent
   decl = @newIdent( nProc, kProc, LAST_ID )

   oScopeBegin
   @FormalArgDecl
   oNodeSet( decl, qParams, oScopeCurrent )
   oScopeEnd
   oScopeDeclare( decl )
   ';'

   oScopeBegin
   @Block( nLocalVar )
   oNodeSet( decl, qChildScope, oScopeCurrent )
   oScopeEnd
   ';';

FuncDecl:
   Node decl
   Node theType

   pIdent
   decl = @newIdent( nFunc, kFunc, LAST_ID )

   oScopeBegin
   @FormalArgDecl
   oNodeSet( decl, qParams, oScopeCurrent )
   oScopeEnd
   oScopeDeclare( decl )
   ':'

   @TypeRef( theType )
   oNodeSet( decl, qType, theType )
   ';'

   oScopeBegin
   @Block( nLocalVar )
   oNodeSet( decl, qChildScope, oScopeCurrent )
   oScopeEnd
   ';';


% TO DO:
%   This code is declaring params in the wrong order.
%   Also ignoring var keyword.
%   Also not using schema yet.
%   Also should use a var instead of count stack.
%
FormalArgDecl:
   [
      | '(' :
         {
            NodeVec decls
            decls = oNodeVecNew
            Node decl
            boolean isInOut
            isInOut = false

            [
               | pVar : isInOut = true
               | * :
            ]

            {  pIdent

               decl = @newIdent( nParam, kVar, LAST_ID )
               oNodeSetBoolean( decl, qInOut, isInOut )
               oNodeVecAppend( decls, decl )

               [
                  | ':' : >
                  | ',' :
               ]
            }

            Node theType
            @TypeRef( theType )

            int i
            i = 0
            {[ equal( i, oNodeVecSize( decls ) )
               | false :
                  decl = oNodeVecElement( decls, i )
                  oNodeSet( decl, qType, theType )
                  oScopeDeclareAlloc( decl )
                  inc( i )
               | * :
                  >
            ]}

            oNodeVecDelete( decls )

            [
               | ')' : >
               | ';' :
            ]
         }
      | * :
   ];

ConstDecl:
   {[
      | pIdent :
         Node decl
         decl = @newIdent( nConst, kConst, LAST_ID )
         '='

         @ConstExpr
         % TO DO: currently ConstExpr leaves int result on oValue stack
         int val
         val = oValueTop
         oValuePop
         oNodeSetInt( decl, qValue, val )

         % TO DO: different types.  Currently assumes int!
         oNodeSet( decl, qType, IntegerType )

         oScopeDeclare( decl )
         ';'
      | * :
         >
   ]};

TypeDecl:
   {[
      | pIdent :
         Node decl
         decl = @newIdent( nTypeDecl, kType, LAST_ID )
         '='
         Node theType
         @TypeRef( theType )
         oNodeSet( decl, qType, theType )
         oScopeDeclare( decl )
         ';'
      | * :
         >
   ]};

VarDecl( node_type varNodeType ):
   {[
      | pIdent :
         NodeVec decls
         decls = oNodeVecNew
         Node decl
         {
            decl = @newIdent( varNodeType, kVar, LAST_ID )
            oNodeVecAppend( decls, decl )
            [
               | ',' :
                  pIdent
               | * :
                  >
            ]
         }
         ':'
         Node theType
         @TypeRef( theType )

         int i
         i = 0
         {[ equal( i, oNodeVecSize( decls ) )
           | false :
             decl = oNodeVecElement( decls, i )
             oNodeSet( decl, qType, theType )
             oScopeDeclareAlloc( decl )
             inc( i )
            | * :
              >
         ]}

         oNodeVecDelete( decls )
         ';'
      | * :
         >
   ]};


% Parse a type reference, returning the nType.
% This will add types to the type table, as needed.
%
% Style question - at the moment I think callers look clearer if we use
% an out param here, rather than a return value.
%
TypeRef( out Node resultType ):
   [
      | pIdent :           % previously named type (including intrinsics)
         Node decl
         decl = oScopeFindRequire
         [ oNodeType( decl )
           | nTypeDecl :
               resultType = oNodeGet( decl, qType )
           | * :
               #eNotType
               resultType = IntegerType
         ]
   
      | pArray :
         '['

         % A multi-dimensional array is represented as a chain
         %    array [subrange1] of array [subrange2] of elementType

         % First, we build a vector of nArray's, each with one subrange as its index type,
         % but without setting the "of" type or size.

         NodeVec dimensions
         dimensions = oNodeVecNew

         {
            % to do: probably should use general subrange parsing, incl minimal size value
            %   In fact, supposed to parse ordinal_type here.  all ordinal types have a static low, high.
            %   Not necessary to be a subrange.

            Node subrange
            subrange = oNodeNew( nSubrangeType )
            % TO DO: currently assuming subrange of integer
            oNodeSet( subrange, qBaseType, IntegerType )

            % TO DO: currently ConstExpr leaves int result on oValue stack
            @ConstExpr
            oNodeSetInt( subrange, qLow, oValueTop )
            oValuePop
            '..'
            @ConstExpr
            oNodeSetInt( subrange, qHigh, oValueTop )
            oValuePop
            oNodeSetInt( subrange, qSize, 4 )   % maybe don't need

            oTypeAdd( subrange )

            Node a
            a = oNodeNew( nArrayType )
            oNodeSet( a, qIndexType, subrange )

            oNodeVecAppend( dimensions, a )
            % I'll hold off on adding 'a' to the type table since not fully formed yet

            [
               | ']' : >
               | ',' :
            ]
         }
         pOf
         Node baseType
         @TypeRef( baseType )

         % Work backwards through the dimensions,
         % hooking up the 'of' type and calculating the size.
         % At each iteration, baseType is the 'of' type.

         int dim
         dim = oNodeVecSize( dimensions )
         {
             dec(dim)

             Node a
             a = oNodeVecElement( dimensions, dim )
             oNodeSet( a, qBaseType, baseType )
             Node subrange
             subrange = oNodeGet( a, qIndexType )
             int width
             width = subtract( oNodeGetInt( subrange, qHigh ), oNodeGetInt( subrange, qLow ) )
             inc( width )
             oNodeSetInt( a, qSize, multiply( width, oNodeGetInt( baseType, qSize ) ) )

             oTypeAdd( a )
             baseType = a

             [ equal_zero(dim)
                 | true:  >
                 | *:
             ]
         }

         resultType = oNodeVecElement( dimensions, 0 )
         oNodeVecDelete( dimensions )

      | '^' :
         Node theType
         @TypeRef( theType )
         resultType = @PointerTypeTo( theType )

      | pRecord :
         resultType = oNodeNew( nRecordType )
         oScopeBegin

         @VarDecl( nRecordField )

         int size
         size = oNodeGetInt( oScopeCurrent, qNextOffset )
         % to do: padding
         [ equal_zero( size )
            | true : #eRecordEmpty
            | * :
         ]

         pEnd

         oNodeSet( resultType, qScope, oScopeCurrent )
         oNodeSetInt( resultType, qSize, size )
         oScopeEnd
         oTypeAdd( resultType )


      % *** TO DO: following type constructors are not implemented *** 
      % *** TO DO: also missing declaration of enum type
      | pSet :
         pOf
         Node theType
         @TypeRef( theType )
      | * :       % this works for cases except where expr starts with an id
         @ConstExpr '..' @ConstExpr
   ];


% ------------------------------ Expressions -----------------------------

% Constant expressions: currently, only literal integers or previously
% named constant integers are supported, possibly with a negation.
% Constant expressions are evaluated at compile time.

ConstExpr:
   [
      | pIntLit :
         oValuePush( TOKEN_VALUE )
      | pIdent :
         Node decl
         decl = oScopeFindRequire
         [ oNodeType( decl )
            | nConst :
               oValuePush( oNodeGetInt( decl, qValue ) )
            | * :
               #eNotConst
               oValuePush( 0 )
         ]
      | pMinus :
         @ConstExpr
         oValueNegate
   ];

%
% General run-time expressions
% The type stack tracks the type of the expression.
%

Expr:
   @BoolExpr
   {[
      | '=' :
         @BoolExpr
         @MatchTypes
         [ oTypeSNodeType
            | nIntegerType, nBooleanType :  .tEqualInt
            | nPointerType :                .tEqualPtr
            | nCharType, nStringType :      #eNotImplemented
            | * :                           #eNotAllowed
         ]
         oTypeSPop
         oTypeSPush( BooleanType )

      | '<>' :
         @BoolExpr
         @MatchTypes
         [ oTypeSNodeType
            | nIntegerType, nBooleanType :  .tNotEqualInt
            | nPointerType :                .tNotEqualPtr
            | nCharType, nStringType :      #eNotImplemented
            | * :                           #eNotAllowed
         ]
         oTypeSPop
         oTypeSPush( BooleanType )

      | '<' :
         @BoolExpr
         @MatchTypes
         [ oTypeSNodeType
            | nIntegerType, nBooleanType :  .tLessInt
            | nCharType, nStringType :      #eNotImplemented
            | * :                           #eNotAllowed
         ]
         oTypeSPop
         oTypeSPush( BooleanType )

      | '>' :
         @BoolExpr
         @MatchTypes
         [ oTypeSNodeType
            | nIntegerType, nBooleanType :  .tGreaterInt
            | nCharType, nStringType :      #eNotImplemented
            | * :                           #eNotAllowed
         ]
         oTypeSPop
         oTypeSPush( BooleanType )

      | '<=' :
         @BoolExpr
         @MatchTypes
         [ oTypeSNodeType
            | nIntegerType, nBooleanType :  .tLessEqualInt
            | nCharType, nStringType :      #eNotImplemented
            | * :                           #eNotAllowed
         ]
         oTypeSPop
         oTypeSPush( BooleanType )

      | '>=' :
         @BoolExpr
         @MatchTypes
         [ oTypeSNodeType
            | nIntegerType, nBooleanType :  .tGreaterEqualInt
            | nCharType, nStringType :      #eNotImplemented
            | * :                           #eNotAllowed
         ]
         oTypeSPop
         oTypeSPush( BooleanType )

      | * :
         >
   ]};

BoolExpr:
   @BoolTerm
   {[
      | pOr :
         @RequireBoolPop
         @BoolTerm
         @RequireBool
         .tOr
      | * :
         >
   ]};

BoolTerm:
   @BoolFactor
   {[
      | pAnd :
         @RequireBoolPop
         @BoolFactor
         @RequireBool
         .tAnd
      | * :
         >
   ]};

BoolFactor:
   [
      | pNot :
         @ArithExpr
         @RequireBool
         .tNot
      | * :
         @ArithExpr
   ];

ArithExpr:
   @Term
   {[
      | pPlus :
         @RequireIntPop
         @Term
         @RequireInt
         .tAddInt
      | pMinus :
         @RequireIntPop
         @Term
         @RequireInt
         .tSubtractInt
      | * :
         >
   ]};

Term:
   @Factor
   {[
      | pTimes :
         @RequireIntPop
         @Factor
         @RequireInt
         .tMultiplyInt
      | pDivide :
         @RequireIntPop
         @Factor
         @RequireInt
         .tDivideInt
      | * :
         >
   ]};

Factor:
   [
      | pPlus :
         @Primary
         @RequireInt
      | pMinus :
         @Primary
         @RequireInt
         .tNegateInt
      | * :
         @Primary
   ];

Primary:
   [
      | pIntLit :
         .tPushIntLit   oEmitInt( TOKEN_VALUE )
         oTypeSPush( IntegerType )

      | '(' :
         @Expr
         ')'

      | pStrLit :
         oStringAllocLit     % store, put addr on value stack
         .tPushAddr  oEmitInt( oValueTop )  oValuePop
         % TO DO: do we need to create a type with the literal's length?
         oTypeSPush( StringType )

      | pIdent :
         Node decl
         Node theType
         decl = oScopeFindRequire

         [ oNodeType( decl )
            | nFunc :
               [
                  | '(' :
                     {  @Expr

                        % TO DO: match type against param
                        % TO DO: push the expression onto the call stack e.g. iPush...
                        %  Meanwhile for now we are broken, leaving the value on the runtime value stack
                        oTypeSPop

                        [
                          | ')' : >
                          | ',' :
                        ]
                     }
                  | * :
               ]
               .tCall  @EmitValue( decl )
               oTypeSPush( oNodeGet( decl, qType ) )

            | nConst :
               theType = oNodeGet( decl, qType )
               oTypeSPush( theType )
               [ oTypeSNodeType
                  | nIntegerType, nBooleanType :
                     .tPushIntLit @EmitValue( decl )
                  | * :
                     #eNotImplemented
               ]

            | nGlobalVar :
               theType = oNodeGet( decl, qType )
               oTypeSPush( theType )
               [ oTypeSNodeType
                  | nIntegerType :
                     .tPushIntVar @EmitValue( decl )
                  | nBooleanType :
                     .tPushBoolVar @EmitValue( decl )
                  | nCharType, nStringType, nFileType :
                     #eNotImplemented
                  | nPointerType :
                     .tPushPtrVar @EmitValue( decl )
                     [
                        | '^' :             % dereferenced
                           oTypeSPop
                           oTypeSPush( oNodeGet( theType, qBaseType ) )
                           @LValue
                           @FetchVar
                        | * :               % just ptr value alone
                     ]
                  | * :                     % compound type
                     .tPushAddr @EmitValue( decl )    % addr of start of var
                     @LValue                % get final addr
                     @FetchVar              % get final value
               ]

            | * :
               #eNotValue
               oTypeSPush( IntegerType )
         ]

      | '^' :        % ^var
         pIdent

         Node decl
         Node theType
         decl = oScopeFindRequire
         theType = oNodeGet( decl, qType )

         [ oNodeType( decl )
            | nGlobalVar :
               .tPushAddr @EmitValue( decl )
               @LValue     % ptr value to expr stack

               Node ptrType
               ptrType = @PointerTypeTo( theType )
               oTypeSPush( ptrType )

            | nLocalVar, nParam : #eNotImplemented
               oTypeSPush( IntegerType )
            | * :
               #eNotVar
               oTypeSPush( IntegerType )
         ]

      | * :
         #eNotValue
         oTypeSPush( IntegerType )
   ];


% Addr of start of var is on expr stack; type is on type stack.
% Replace expr stack with value of var.
% (In the case of compound vars, this remains as the addr of the var).

FetchVar:
   [ oTypeSNodeType
      | nIntegerType :   .tFetchInt
      | nBooleanType :   .tFetchBool
      | nCharType, nStringType, nFileType : #eNotImplemented
      | nPointerType :   .tFetchPtr
      | * :              % compound type; leave as addr
   ];


% Addr of start of var is already on run stack, and type is on type stack.
% Read subscripts, etc, to get final addr on run stack, and final type
% on type stack.

LValue:
   {[
      | '[' :       @ArraySubscripts
      | '.' :       #eNotImplemented
      | '^' :       @PointerDeref
      | * :         >
   ]};

ArraySubscripts:
   [ oTypSChooseKind
      | tyArray :
      | * :       #eNotArray
   ]
   {
      [ oTypSChooseKind
         | tyArray :
         | * :    #eTooManySubscripts
      ]
      oValuePushLowTS   % low subscript of this dimension
      oTypSPopPushBase  % replace TS with next dimension, or OF type
      @Expr
      @RequireIntPop
      [ oValueIsZero    % adjust for low subscript
         | true :       oValuePop
         | * :          .tPushIntLit oEmitInt( oValueTop ) .tSubtractInt oValuePop
      ]
      oValuePushSizeTS
      [ oValueIsOne     % adjust for size of subtype
         | true :       oValuePop
         | * :          .tPushIntLit oEmitInt( oValueTop ) .tMultiplyInt oValuePop
      ]
      .tAddInt          % update start address
      [
         | ']' :  >
         | ',' :
      ]
   };

% ptr deref on left side, i.e. BEFORE addr of ptr var is on stack,
%                              AFTER addr of thing pointed to is on stack
PointerDeref:
   [ oTypeSNodeType
      | nPointerType :
      | * :       #eNotPointer
   ]
   .tFetchPtr           % now addr on stack is addr of what we're pointing to

   Node theType
   theType = oTypeSTop
   oTypeSPop
   oTypeSPush( oNodeGet( theType, qBaseType ) )
   ;


% ------------------------------ Statements -----------------------------

Statement:
   [
      | pWriteln :     @WritelnStmt
      | pWrite :       @WriteStmt
      | pReadln :      @ReadlnStmt
      | pRead :        @ReadStmt
      | pIf :          @IfStmt
      | pWhile :       @WhileStmt
      | pFor :         @ForStmt
      | pRepeat :      @RepeatStmt
      | pExit :        @ExitStmt
      | pCycle :       @CycleStmt
      | pBegin :       @BeginStmt
      | pIdent :       @AssignOrCallStmt
      | * :            % null statement : don't accept any tokens
   ];


AssignOrCallStmt:         % *** Call doesn't work yet ***
   Node decl
   decl = oScopeFindRequire
   [ oNodeType( decl )    % can parse without semantic info
      | nProc :           %    but this is easier
         [
            | '(' :
               {  @Expr oTypSPop  % ignore type for now
                  [
                    | ')' : >
                    | ',' :
                  ]
               }
            | * :
         ]
         .tCall  @EmitValue( decl )

      | nGlobalVar :
         .tPushAddr @EmitValue( decl )
         oTypeSPush( oNodeGet( decl, qType ) )
         @LValue        % handle subscripts, if any
         ':=' 
         @Expr
         @MatchTypes
         [ oTypeSNodeType
            | nIntegerType :            .tAssignInt
            | nBooleanType :            .tAssignBool
            | nCharType, nStringType, nFileType :   #eNotImplemented

            % compound var assigns; addrs of src, dest on stack
            | nPointerType :            .tAssignPtr
            | * :
                int size
                size = oNodeGetInt( oTypeSTop, qSize )
                .tCopy  oEmitInt( size )    % multi-word copy
         ]
         oTypeSPop

      | * :
         #eBadStatement
   ];

IfStmt:
   @Expr
   @RequireBoolPop
   pThen
   .tJumpFalse
   oPatchPushHere(patchIf)
   .tSpace
   @Statement
   [
      | pElse :
         .tJump
         oPatchPushHere(patchIf)
         .tSpace
         oPatchSwap(patchIf)
         oPatchPopFwd(patchIf)
         @Statement
      | * :
   ]
   oPatchPopFwd(patchIf);

ForStmt:
   pIdent
   oSymLookup
   [ oSymChooseKind
      | kVar :
         oTypSPushTyp
         @RequireIntPop
      | * :        #eNotIntVar
   ]
   oValuePushVal                   % address of index var (keep on VS)
   .tPushAddr oEmitInt( oValueTop )
   ':='
   @Expr
   @RequireIntPop
   .tAssignInt
   .tJump oPatchPushHere(patchLoop) .tSpace
   oPatchPushHere(patchLoop)
   oPatchSwap(patchLoop)
   [
      | pTo :
         .tIncIntVar oEmitInt( oValueTop )
         oPatchPopFwd(patchLoop)
         .tPushIntVar oEmitInt( oValueTop )
         @Expr
         @RequireIntPop
         .tGreaterInt
         .tJumpTrue oPatchPushHere(patchLoop) .tSpace
         oPatchSwap(patchLoop)
      | pDownto :
         .tDecIntVar oEmitInt( oValueTop )
         oPatchPopFwd(patchLoop)
         .tPushIntVar oEmitInt( oValueTop )
         @Expr
         @RequireIntPop
         .tLessInt
         .tJumpTrue oPatchPushHere(patchLoop) .tSpace
         oPatchSwap(patchLoop)
   ]
   oCountPush(0)          % count 'exit' patches
   pDo
   @Statement
   .tJump oPatchPopBack(patchLoop)
   oValuePop
   oPatchPopFwd(patchLoop)
   @PatchExitsPop;

RepeatStmt:
   oPatchPushHere(patchLoop) % start of loop
   oCountPush(0)          % count the 'exit' patches
   @Statement
   {[
      | ';' :
         @Statement
      | pUntil :
         @Expr
         @RequireBoolPop
         .tJumpFalse
         oPatchPopBack(patchLoop)
         @PatchExitsPop
         >
   ]};

WhileStmt:
   oPatchPushHere(patchLoop)    % start of loop
   oCountPush(0)
   @Expr
   @RequireBoolPop
   pDo
   .tJumpFalse
   oPatchPushHere(patchLoop)    % jump out
   .tSpace
   oPatchSwap(patchLoop)        % start on top
   @Statement
   .tJump
   oPatchPopBack(patchLoop)
   oPatchPopFwd(patchLoop)
   @PatchExitsPop;

CycleStmt:                     % NOTE, for repeat..until, skips test (??)
   [ oPatchAnyEntries(patchLoop)
      | true :
         .tJump
         oPatchDup(patchLoop)  % addr of start
         oPatchPopBack(patchLoop)
      | * :
         #eNotInALoop
   ];

ExitStmt:
   [ oPatchAnyEntries(patchLoop)
      | true :
         .tJump
         oPatchPushHere(patchExit)
         .tSpace
         oCountInc
      | * :
         #eNotInALoop
   ];

BeginStmt:
   @Statement
   {[
      | ';' :   @Statement
      | pEnd :  >
   ]};

WritelnStmt:
   @WriteStmt
   .tPutCR;

WriteStmt:
   [
      | '(' :
         {
            @Expr
            [ oTypSChoose
               | tyInteger :                .tPutInt
               | tyBoolean :                .tPutBool
               | tyString :                 .tPutStr
               | tyChar, tyFile :           #eNotImplemented
               | * :                        % compound types
                  [ oTypSChooseKind
                     | tyPointer :          .tPutPtr
                     | * :                  #eNotAllowed
                  ]
            ]
            oTypSPop
            [
               | ')' : >
               | ',' :
            ]
         }
      | * :
   ];


ReadlnStmt:      % ***
   ;
ReadStmt:
   ;

% -------------------------------- Utilities -------------------------------

PatchExitsPop:
   {[ oCountIsZero
      | false : oPatchPopFwd(patchExit)
      | * :     >
   ]}
   oCountPop;


% Require that the top two types on the type stack are matching (ignoring subranges).
% Pop one of them, leaving only one.
%
MatchTypes:
   node_type nt
   nt = oTypeSNodeType
   oTypeSPop
   [ equal_node_type( nt, oTypeSNodeType )
      | false :
         #eTypeMismatch
      | * :
   ];


% Require that the top type on the type stack is integer (ignoring subranges).
% Pop it.
%
RequireIntPop:
   [ oTypeSNodeType
      | nIntegerType :
      | * :          #eNotInteger
   ]
   oTypeSPop;

RequireInt:
   [ oTypeSNodeType
      | nIntegerType :
      | * :          #eNotInteger
   ];

RequireBoolPop:
   [ oTypeSNodeType
      | nBooleanType :
      | * :          #eNotBoolean
   ]
   oTypeSPop;

RequireBool:
   [ oTypeSNodeType
      | nBooleanType :
      | * :          #eNotBoolean
   ];


% Create and return a new nType of the given node_type, adding it to the type table.
%
newType( node_type nt, int size ) >> Node:
  Node node
  node = oNodeNew( nt )
  oNodeSetInt( node, qSize, size )
  oTypeAdd( node )
  >> node
  ;


% Create and return a new nIdent of the given node_type, with the given ident id.
% Does not add it to any scope.
%
newIdent( node_type nt, kind k, int id ) >> Node:
  Node t
  t = oNodeNew( nt )
  oNodeSetKind( t, qKind, k )   % deprecated attribute
  oNodeSetInt( t, qIdent, id )
  >> t
  ;


% Return an nType representing a pointer to the given type.
% (Creates a new type if necessary.)
%
PointerTypeTo( Node theType ) >> Node:
   Node ptrType
   ptrType = oNodeGet( theType, qPointerType )
   [ oNodeNull( ptrType )
      | true :
         ptrType = oNodeNew( nPointerType )
         oNodeSet( ptrType, qBaseType, theType )
         oNodeSetInt( ptrType, qSize, 8 )
         oTypeAdd( ptrType )
         oNodeSet( theType, qPointerType, ptrType )
      | * :
   ]
   >> ptrType;


% Emit the value in a declaration.
% For a constant integer, this is the constant value.
% For a global variable, this is the global address.
% For a local variable, this is the local address relative to the call stack frame.
%
EmitValue( Node decl ):
    oEmitInt( oNodeGetInt( decl, qValue ));


installBuiltIns:

   % install built-in types
   FileType = @newType( nFileType, 4 )
   IntegerType = @newType( nIntegerType, 4 )
   BooleanType = @newType( nBooleanType, 1 )
   CharType = @newType( nCharType, 1 )
   StringType = @newType( nStringType, 256 )    % string with default length 256

   % Declare those type identifiers.
   % SSL doesn't support strings, so need help from operations e.g. oIdAdd_File

   Node t

   t = @newIdent( nTypeDecl, kType, oIdAdd_File )
   oNodeSet( t, qType, FileType )
   oScopeDeclare( t )

   t = @newIdent( nTypeDecl, kType, oIdAdd_Integer )
   oNodeSet( t, qType, IntegerType )
   oScopeDeclare( t )

   t = @newIdent( nTypeDecl, kType, oIdAdd_Boolean )
   oNodeSet( t, qType, BooleanType )
   oScopeDeclare( t )

   t = @newIdent( nTypeDecl, kType, oIdAdd_Char )
   oNodeSet( t, qType, CharType )
   oScopeDeclare( t )

   t = @newIdent( nTypeDecl, kType, oIdAdd_String )
   oNodeSet( t, qType, StringType )
   oScopeDeclare( t )

   % Built-in constants

   t = @newIdent( nConst, kConst, oIdAdd_True )
   oNodeSet( t, qType, BooleanType )
   oNodeSetInt( t, qValue, 1 )
   oScopeDeclare( t )

   t = @newIdent( nConst, kConst, oIdAdd_False )
   oNodeSet( t, qType, BooleanType )
   oNodeSetInt( t, qValue, 0 )
   oScopeDeclare( t )

   ;

end

