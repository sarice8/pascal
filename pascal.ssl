title: 'Pascal Compiler 1.1.5 -- Jan 01 ''90';
   
%
%  Pascal.ssl
%
%  Pascal Compiler for the Amiga, by Steve Rice.
%
%  HISTORY
%    11Sep89   First version, framework of parser.
%    18Sep89   Added some semantic mechanisms.
%    21Sep89   Added simple type references; expressions generate code.
%    22Sep89   Allocate variable addresses as they're declared.
%    24Sep89   Added arrays, pointers.
%    27Sep89   Added for statement.
%    23Oct89   Fixed for statement, so CYCLE goes to next step.
%    01Jan90   Added string literals
%    09Sep22   I have returned.  Migrate symbol table to schema, to ease development.
%
%  NOTES
%    1) During a loop, the top counter counts the number of 'exit'
%       statements to be patched.
%    2) During a loop, the top entry in the patchLoop stack is the addr
%       of the start of the loop (used by 'cycle' to repeat the loop).
%    3) The 'value' of a var symbol is its allocated address.
%    4) References to vars of intrinsic types, and pointer types,
%       pushes the value of the var on the expr stack.  Referenecs to
%       vars of compound types (arrays, records...) pushes the address
%       on the expr stack.
%    5) Just as there is only one type table entry for a given (named) type,
%       there is only one type table entry for a pointer to a named type.
%       When a pointer type is declared, a field in the TT entry of the
%       type pointed to will be set to indicate the TT entry of the pointer
%       to that type (0 means none defined yet).  When evaluating the
%       expression ^x, the type in that field in the entry for the type of x
%       will be used (unless it's 0, in which case a new TT entry will be
%       created).
%
%
%  MISSING
%
%    - proceudre and function forward declarations.
%      I think it uses the keyword 'forward' in place of the body.
%      Only one forward declaration is allowed.  I will overwrite the nMethod info
%      with the final addr and param names when the true body is seen.
%      If a call is made to a foward declared method, add the forward decl node & Here to patch table.
% 
%    - procedure and function declarations may be nested within other procs/funcs!
%      They are allowed to see locals within those parent scopes.
%      Pass a hidden parameter to nested methods, to follow up to parent scopes as needed.
%      Need a level counter at each scope, and uplevels count on reference to local/param.
%      
%    - Confirm that var decls can't be nested inside statements as they can in C.
%      (i.e. is my "Block" concept correct?)
%      
%    - Non-ISO extensions.  Look at "Units" e.g. from Turbo Pascal wikipedia page.
%
%  PASCAL DOCS
%      Here's some handy language material:
%      https://www.freepascal.org/docs-html/ref/ref.html
%      https://www.freepascal.org/docs-html/prog/prog.html
%      https://en.wikipedia.org/wiki/Turbo_Pascal
%      https://en.wikipedia.org/wiki/Pascal_(programming_language)#Standards
%

input:
   pIdent
   pIntLit
   pStrLit
   pAssign       ':='
   pSemiColon    ';'
   pEqual        '='
   pNotEqual     '<>'
   pLess         '<'
   pGreater      '>'
   pLessEqual    '<='
   pGreaterEqual '>='
   pColon        ':'
   pComma        ','
   pLParen       '('
   pRParen       ')'
   pLSquare      '['
   pRSquare      ']'
   pCarat        '^'
   pDot          '.'
   pDotDot       '..'
   pTimes        '*'
   pDivide       '/'
   pPlus         '+'
   pMinus        '-'
   pEof
   pInvalid

%  keywords  (built-in types 'integer', 'char', etc, are not keywords,
%             type constructors 'array', 'record', 'set' are keywords,
%             pseudo-procedures 'writeln', 'readln' are keywords)

   pProgram
   pProcedure
   pFunction
   pConst
   pType
   pVar
   pBegin
   pEnd
   pArray
   pRecord
   pSet
   pOf
   pIf
   pThen
   pElse
   pFor
   pTo
   pDownto
   pDo
   pWhile
   pRepeat
   pUntil
   pCycle
   pExit
   pReturn
   pAnd
   pOr
   pNot
   pWriteln
   pWrite
   pReadln
   pRead;


output:

%  Instructions for a stack machine (all vars are 32-bit integers)

   tPushGlobalI      % <ptr> - push int value read from ptr
   tPushGlobalB      % <ptr> - push byte value read from ptr
   tPushGlobalP      % <ptr> - push ptr value read from ptr
   tPushLocalI       % <offset> - push int value read from local var
   tPushLocalB       % <offset> - push byte value read from local var
   tPushLocalP       % <offset> - push ptr value read from local var
   tPushParamI       % <offset> - push int value read from local var
   tPushParamB       % <offset> - push byte value read from local var
   tPushParamP       % <offset> - push ptr value read from local var

   tPushConstI       % <int> - push int value on stack (NOTE, used for BOOLEAN too)
   tPushConstP       % <ptr> - push constant ptr value
   tPushAddrGlobal   % <offset> - push ptr to global var (same as tPushConstP)
   tPushAddrLocal    % <offset> - push ptr to local var
   tPushAddrParam    % <offset> - push ptr to formal param (used by method to see its param)
   tPushAddrActual   % <offset> - push ptr to actual param, in actuals space (used by caller)
   tFetchI           % pop ptr from stack, and push int value it points to
   tFetchB           %    "      "      "     "     byte  "   "    "
   tFetchP           %    "      "      "     "     ptr   "   "    "   
   tAssignI          % assign int value on top of stack to addr under it (pop both)
   tAssignB          %   "    byte   "    "   "  "   "    "    "   "   "
   tAssignP          %   "    ptr    "    "   "  "   "    "    "   "   "
   tCopy             % #words follows.  tos=src, 2nd=dest (pop 2)
   tIncGlobalI       % <ptr> - increment int value pointed to by ptr
   tDecGlobalI       % <ptr> - decrement int value pointed to by ptr
   tMultI            % multiply top two integers (replacing with result)
   tDivI
   tAddI  
   tSubI
   tNegI             % top entry *= -1
   tNot              % negate top boolean
   tAnd              % boolean AND of top 2 (pop 2, push 1)
   tOr               % boolean OR or top 2 (pop 2, push 1)
   tEqualI           % top two entries equal? (pop 2, push 1) (true=1)
   tNotEqualI        %    NOTE, these all work for booleans too
   tGreaterI         % 2nd entry greater than top entry? (pop 2, push answer)
   tLessI  
   tGreaterEqualI
   tLessEqualI
   tEqualP           % two two pointer values equal? (pop 2, push 1) (true=1)
   tNotEqualP
   tAllocActuals     % <#bytes> - make space on call stack for actual params (adjusting call stack sp)
   tFreeActuals      % <#bytes> - discard space on call stack allocated by tAllocActuals
   tCall             % addr follows
   tReturn
   tEnter            % <#bytes> - start a stack frame on the call stack, reserving #bytes of local variable space
   tJump             % addr follows
   tJumpTrue         % addr follows  (pops top of stack, jumps if true)
   tJumpFalse        % addr follows  (pops top of stack, jumps if false)
   tWriteI           % for writeln : write integer on tos, pop
   tWriteBool        %  "     "    : write TRUE/FALSE, pop
   tWriteStr         %  "     "    : write string whose addr is on tos, pop
   tWriteP           %  "     "    : write ptr var whose addr is on tos, pop
   tWriteCR          %  "     "    : write cr

%  Other:

   tSpace            % emit a hole, to be patched later
   ;

error:
   eBadStatement
   eNotConst
   eNotType
   eNotOrdinalType
   eNotVar
   eNotIntVar
   eNotValue
   eNotInteger
   eNotBoolean
   eNotPointer
   eNotArray
   eNotRecord
   eNotRecordField
   eTooManySubscripts
   eTypeMismatch
   eMissingParameter
   eNotImplemented
   eNotAllowed
   eNotInALoop
   eRecordEmpty
   ;

include 'pascal_schema.ssl'

type Node:     % A pointer to a node in the schema database (symbol database)
    Null = 0
    ;

type NodeVec:  % A pointer to a vector of Node.  See mechanism node_vec_mech
    NullVec = 0
    ;

type boolean:
   false    = 0
   true     = 1;

type kind:           % kind of identifier
   kUndefined        % not yet added to symbol table
   kProgram
   kProc
   kFunc
   kConst
   kType
   kVar;

% intrinsic types & type constructs

type typ:
   tyNone     = 0    % in ptrTyp field of TT, means no ptr to type defined
   tyInteger
   tyBoolean
   tyChar
   tyString
   tyFile            % tyInteger..tyFile are scalars (types on their own)
   tyPointer         % following are type constructor classes...
   tyArray           %   (they are not type#'s)
   tyRecord
   tyParams          % like record; a collection of proc/func params
   tySet;


% Some general schema node operations.
% node_type and node_attribute are defined in generated file pascal_schema.ssl included above.
%
mechanism node_mech:
    oNodeNew (node_type) >> Node         % create new node
    oNodeSet (Node, node_attribute, Node)   % set Node attribute of node
    oNodeSetInt (Node, node_attribute, int) % set int attribute of node
    oNodeSetBoolean (Node, node_attribute, boolean)
    oNodeSetKind (Node, node_attribute, kind) % set attribute of node  *** MIGHT NOT NEED
    oNodeGet (Node, node_attribute) >> Node    % get Node attribute of node
    oNodeGetInt (Node, node_attribute) >> int  % get int attribute of node
    oNodeGetBoolean (Node, node_attribute) >> boolean  % get int attribute of node
    oNodeNull (Node) >> boolean          % is node null?
    oNodeNext (inout Node)               % advance Node to next in list
    oNodeType (Node) >> node_type        % return node type of node
    oNodeEqual (Node, Node) >> boolean   % compare two nodes for equality
                                         % (i.e. same node, not just same contents)
    ;


% Manipulate a temporary vector of Node
%
mechanism node_vec_mech:
    oNodeVecNew >> NodeVec
    oNodeVecDelete( NodeVec nv )
    oNodeVecAppend( NodeVec nv, Node n )
    oNodeVecSize( NodeVec nv ) >> int                % how many elements
    oNodeVecElement( NodeVec nv, int idx ) >> Node   % element at index idx (0..size-1)
    ;


mechanism emit_mech:
    oEmitInt( int )              % emit int into the generated code
    Here >> int                  % current address in the generated code
    oPatch( int addr, int val )  % patch an int into address in the generated code
    ;

mechanism math:
    inc (inout int)
    dec (inout int)
    negate (int) >> int
    subtract( int x, int y ) >> int     % x - y
    multiply( int x, int y ) >> int     % x * y
    equal( int x, int y ) >> boolean
    equal_zero (int) >> boolean
    equal_node_type (node_type, node_type) >> boolean     % Want equal_<type> for every type
    ;

mechanism more_builtins:      % These should be built-in SSL operations
    TOKEN_VALUE >> int        % value of just accepted token, e.g. IntLit token
    LAST_ID >> int            % id number of last accepted identifier
    ;

mechanism scope_mech:
    oScopeBegin                          % create a new scope. Subsequent declarations will go here.
    oScopeEnter( Node scope )            % enter an existing scope.
    oScopeEnd                            % end current scope. Subsequent declarations will go to previous scope.
    oScopeCurrent >> Node                % returns current scope
    oScopeDeclare( Node )                % add declaration to current scope.
    oScopeDeclareAlloc( Node )           % add declaration to current scope, and allocate space according to its type
    oScopeFind >> Node                   % find declaration of last accepted identifier.  Returns Null if not found.
    oScopeFindRequire >> Node            % find declaration of last accepted identifier.  Error if not found.
    ;


mechanism type_mech:
    oTypeAdd( Node node )     % add the given nType to the type table
    ;

mechanism type_stack_mech:
    oTypeSPush( Node node )
    oTypeSPop
    oTypeSTop >> Node
    oTypeSNodeType >> node_type          % node_type of the node on top of type stack, skipping subranges
    ;


mechanism id_mech:
    % adds a predefined id to the scanner's id table, and returns the id code
    oIdAdd_File >> int
    oIdAdd_Integer >> int
    oIdAdd_Boolean >> int
    oIdAdd_Char >> int
    oIdAdd_String >> int
    oIdAdd_True >> int
    oIdAdd_False >> int
    ;


mechanism count :
   oCountPush(int)          % start a new counter, with initial value
   oCountInc
   oCountDec
   oCountIsZero >> boolean
   oCountPop;


mechanism value :              % value stack, to calc. const expr's
   oValuePush(int)             % push an explicit int lit
   oValueNegate                % negate top value
   oValueTop >> int            % get top value on value stack
   oValuePop;

mechanism string :
   oStringAllocLit;            % alloc data space for strlit, push address
                               %   on value stack

type patchStack:
   patchLoop                   % addr of start of loop (repeat, while, for)
   patchExit                   % addrs where jumps out of loop are
                               %   (use count mechanism to count how many)
   patchIf;                    % addr of jump around code in 'if' statement

mechanism patch:               % note, creates absolute-address jumps
   oPatchPushHere(patchStack)  % put current address on a patch stack
   oPatchAnyEntries(patchStack) >> boolean     % anything in patch stack?
   oPatchSwap(patchStack)      % swap top two entries
   oPatchDup(patchStack)       % duplicate the top entry
   oPatchPopFwd(patchStack)    % store here at x (x=top of stack), pop stack
   oPatchPopBack(patchStack);  % emit x (so advance 'here'), pop stack

rules

% ----------------------------- Global Variables ----------------------------

Node    globalScope            % global nScope

% built-in nTypes
Node    FileType
Node    IntegerType
Node    BooleanType
Node    CharType
Node    StringType

% -------------------------- Forward Declarations -------------------------

Block( node_type varNodeType, out int addr );
VarDecl( node_type varNodeType );
newType( node_type nt, int size ) >> Node;
newIdent( node_type nt, kind k, int id ) >> Node;
EmitValue( Node decl );
TypeRef( out Node theType );
PointerTypeTo( Node theType ) >> Node;
OrdinalLow( Node theType ) >> int;
AssignStmt( Node decl );
VarExpr( Node decl );
VarLValue( Node decl );


% ----------------------------- Declarations ----------------------------

Program:
   Node t

   oScopeBegin
   globalScope = oScopeCurrent

   @installBuiltIns

   % Start by jumping to the main program statement
   int patchJumpMain
   .tJump 
   patchJumpMain = Here
   .tSpace

   pProgram
   pIdent

   t = @newIdent( nProgram, kProgram, LAST_ID )
   oScopeDeclare( t )

   [
      | '(' :
         pIdent      % input, output files

         t = @newIdent( nVar, kVar, LAST_ID )
         oNodeSet( t, qType, FileType )
         oScopeDeclareAlloc( t )

         ','
         pIdent

         t = @newIdent( nVar, kVar, LAST_ID )
         oNodeSet( t, qType, FileType )
         oScopeDeclareAlloc( t )

         ')'
      | * :
   ]
   ';'

   int addr
   @Block( nGlobalVar, addr )    % not including punctuation after body's 'end'
   oPatch( patchJumpMain, addr )

   '.'
   oScopeEnd
   ;


% Returns the addr of the block's statements.
% This might differ from the Here on entry to this rule,
% due to method declarations in the block.
%
Block( node_type varNodeType, out int addr ):
   {[
      | pConst :     @ConstDecl
      | pType :      @TypeDecl
      | pVar :       @VarDecl( varNodeType )
      | pProcedure : @ProcDecl
      | pFunction :  @FuncDecl
      | * :          >
   ]}
   addr = Here

   % proc/func body begins with tEnter
   int patchLS
   [ equal_node_type( varNodeType, nLocalVar )
      | true :       .tEnter  patchLS = Here  .tSpace
      | * :
   ]

   @Statement
   .tReturn

   [ equal_node_type( varNodeType, nLocalVar )
      | true :
         int localSpace
         localSpace = oNodeGetInt( oScopeCurrent, qNextOffset )
         oPatch( patchLS, localSpace )
      | * :
   ];


ProcDecl:
   Node decl

   pIdent
   decl = @newIdent( nProc, kProc, LAST_ID )

   oScopeBegin
   Node paramScope
   paramScope = oScopeCurrent

   @FormalArgDecl
   oNodeSet( decl, qParams, paramScope )
   oScopeEnd

   oScopeDeclare( decl )
   ';'

   % Enter the params scope again, so params are visible in body.
   % TO DO: Perhaps I could mark the scope read-only at this point.
   oScopeEnter( paramScope )

   % Start scope for declarations within the proc
   oScopeBegin
   int addr
   @Block( nLocalVar, addr )
   oNodeSet( decl, qChildScope, oScopeCurrent )
   oNodeSetInt( decl, qValue, addr )
   oNodeSetBoolean( decl, qAddrDefined, true )
   oScopeEnd

   oScopeEnd  % paramScope
   ';';

FuncDecl:
   Node decl
   Node theType

   pIdent
   decl = @newIdent( nFunc, kFunc, LAST_ID )

   oScopeBegin
   Node paramScope
   paramScope = oScopeCurrent

   @FormalArgDecl
   oNodeSet( decl, qParams, paramScope )
   oScopeEnd

   oScopeDeclare( decl )
   ':'

   @TypeRef( theType )
   oNodeSet( decl, qType, theType )
   ';'

   % Enter the params scope again, so params are visible in body.
   % TO DO: Perhaps I could mark the scope read-only at this point.
   oScopeEnter( paramScope )

   oScopeBegin
   int addr
   @Block( nLocalVar, addr )
   oNodeSet( decl, qChildScope, oScopeCurrent )
   oNodeSetInt( decl, qValue, addr )
   oNodeSetBoolean( decl, qAddrDefined, true )
   oScopeEnd

   oScopeEnd  % paramScope
   ';';


% TO DO:
%   This code is declaring params in the wrong order.
%   Also ignoring var keyword.
%   Also not using schema yet.
%   Also should use a var instead of count stack.
%
FormalArgDecl:
   [
      | '(' :
         {
            NodeVec decls
            decls = oNodeVecNew
            Node decl
            boolean isInOut
            isInOut = false

            [
               | pVar : isInOut = true
               | * :
            ]

            {  pIdent

               decl = @newIdent( nParam, kVar, LAST_ID )
               oNodeSetBoolean( decl, qInOut, isInOut )
               oNodeVecAppend( decls, decl )

               [
                  | ':' : >
                  | ',' :
               ]
            }

            Node theType
            @TypeRef( theType )

            int i
            i = 0
            {[ equal( i, oNodeVecSize( decls ) )
               | false :
                  decl = oNodeVecElement( decls, i )
                  oNodeSet( decl, qType, theType )
                  oScopeDeclareAlloc( decl )
                  inc( i )
               | * :
                  >
            ]}

            oNodeVecDelete( decls )

            [
               | ')' : >
               | ';' :
            ]
         }
      | * :
   ];

ConstDecl:
   {[
      | pIdent :
         Node decl
         decl = @newIdent( nConst, kConst, LAST_ID )
         '='

         @ConstExpr
         % TO DO: currently ConstExpr leaves int result on oValue stack
         int val
         val = oValueTop
         oValuePop
         oNodeSetInt( decl, qValue, val )

         % TO DO: different types.  Currently assumes int!
         oNodeSet( decl, qType, IntegerType )

         oScopeDeclare( decl )
         ';'
      | * :
         >
   ]};

TypeDecl:
   {[
      | pIdent :
         Node decl
         decl = @newIdent( nTypeDecl, kType, LAST_ID )
         '='
         Node theType
         @TypeRef( theType )
         oNodeSet( decl, qType, theType )
         oScopeDeclare( decl )
         ';'
      | * :
         >
   ]};

VarDecl( node_type varNodeType ):
   {[
      | pIdent :
         NodeVec decls
         decls = oNodeVecNew
         Node decl
         {
            decl = @newIdent( varNodeType, kVar, LAST_ID )
            oNodeVecAppend( decls, decl )
            [
               | ',' :
                  pIdent
               | * :
                  >
            ]
         }
         ':'
         Node theType
         @TypeRef( theType )

         int i
         i = 0
         {[ equal( i, oNodeVecSize( decls ) )
           | false :
             decl = oNodeVecElement( decls, i )
             oNodeSet( decl, qType, theType )
             oScopeDeclareAlloc( decl )
             inc( i )
            | * :
              >
         ]}

         oNodeVecDelete( decls )
         ';'
      | * :
         >
   ]};


% Parse a type reference, returning the nType.
% This will add types to the type table, as needed.
%
% Style question - at the moment I think callers look clearer if we use
% an out param here, rather than a return value.
%
TypeRef( out Node resultType ):
   [
      | pIdent :           % previously named type (including intrinsics)
         Node decl
         decl = oScopeFindRequire
         [ oNodeType( decl )
           | nTypeDecl :
               resultType = oNodeGet( decl, qType )
           | * :
               #eNotType
               resultType = IntegerType
         ]
   
      | pArray :
         '['

         % A multi-dimensional array is represented as a chain
         %    array [subrange1] of array [subrange2] of elementType

         % First, we build a vector of nArray's, each with one subrange as its index type,
         % but without setting the "of" type or size.

         NodeVec dimensions
         dimensions = oNodeVecNew

         {
            % to do: probably should use general subrange parsing, incl minimal size value
            %   In fact, supposed to parse ordinal_type here.  all ordinal types have a static low, high.
            %   Not necessary to be a subrange.

            Node subrange
            subrange = oNodeNew( nSubrangeType )
            % TO DO: currently assuming subrange of integer
            oNodeSet( subrange, qBaseType, IntegerType )

            % TO DO: currently ConstExpr leaves int result on oValue stack
            @ConstExpr
            oNodeSetInt( subrange, qLow, oValueTop )
            oValuePop
            '..'
            @ConstExpr
            oNodeSetInt( subrange, qHigh, oValueTop )
            oValuePop
            oNodeSetInt( subrange, qSize, 4 )   % maybe don't need

            oTypeAdd( subrange )

            Node a
            a = oNodeNew( nArrayType )
            oNodeSet( a, qIndexType, subrange )

            oNodeVecAppend( dimensions, a )
            % I'll hold off on adding 'a' to the type table since not fully formed yet

            [
               | ']' : >
               | ',' :
            ]
         }
         pOf
         Node baseType
         @TypeRef( baseType )

         % Work backwards through the dimensions,
         % hooking up the 'of' type and calculating the size.
         % At each iteration, baseType is the 'of' type.

         int dim
         dim = oNodeVecSize( dimensions )
         {
             dec(dim)

             Node a
             a = oNodeVecElement( dimensions, dim )
             oNodeSet( a, qBaseType, baseType )
             Node subrange
             subrange = oNodeGet( a, qIndexType )
             int width
             width = subtract( oNodeGetInt( subrange, qHigh ), oNodeGetInt( subrange, qLow ) )
             inc( width )
             oNodeSetInt( a, qSize, multiply( width, oNodeGetInt( baseType, qSize ) ) )

             oTypeAdd( a )
             baseType = a

             [ equal_zero(dim)
                 | true:  >
                 | *:
             ]
         }

         resultType = oNodeVecElement( dimensions, 0 )
         oNodeVecDelete( dimensions )

      | '^' :
         Node theType
         @TypeRef( theType )
         resultType = @PointerTypeTo( theType )

      | pRecord :
         resultType = oNodeNew( nRecordType )
         oScopeBegin

         @VarDecl( nRecordField )

         int size
         size = oNodeGetInt( oScopeCurrent, qNextOffset )
         % to do: padding
         [ equal_zero( size )
            | true : #eRecordEmpty
            | * :
         ]

         pEnd

         oNodeSet( resultType, qScope, oScopeCurrent )
         oNodeSetInt( resultType, qSize, size )
         oScopeEnd
         oTypeAdd( resultType )


      % *** TO DO: following type constructors are not implemented *** 
      % *** TO DO: also missing declaration of enum type
      | pSet :
         pOf
         Node theType
         @TypeRef( theType )
      | * :       % this works for cases except where expr starts with an id
         @ConstExpr '..' @ConstExpr
   ];


% ------------------------------ Expressions -----------------------------

% Constant expressions: currently, only literal integers or previously
% named constant integers are supported, possibly with a negation.
% Constant expressions are evaluated at compile time.

ConstExpr:
   [
      | pIntLit :
         oValuePush( TOKEN_VALUE )
      | pIdent :
         Node decl
         decl = oScopeFindRequire
         [ oNodeType( decl )
            | nConst :
               oValuePush( oNodeGetInt( decl, qValue ) )
            | * :
               #eNotConst
               oValuePush( 0 )
         ]
      | pMinus :
         @ConstExpr
         oValueNegate
   ];

%
% General run-time expressions
% The type stack tracks the type of the expression.
%

Expr:
   @BoolExpr
   {[
      | '=' :
         @BoolExpr
         @MatchTypes
         [ oTypeSNodeType
            | nIntegerType, nBooleanType :  .tEqualI
            | nPointerType :                .tEqualP
            | nCharType, nStringType :      #eNotImplemented
            | * :                           #eNotAllowed
         ]
         oTypeSPop
         oTypeSPush( BooleanType )

      | '<>' :
         @BoolExpr
         @MatchTypes
         [ oTypeSNodeType
            | nIntegerType, nBooleanType :  .tNotEqualI
            | nPointerType :                .tNotEqualP
            | nCharType, nStringType :      #eNotImplemented
            | * :                           #eNotAllowed
         ]
         oTypeSPop
         oTypeSPush( BooleanType )

      | '<' :
         @BoolExpr
         @MatchTypes
         [ oTypeSNodeType
            | nIntegerType, nBooleanType :  .tLessI
            | nCharType, nStringType :      #eNotImplemented
            | * :                           #eNotAllowed
         ]
         oTypeSPop
         oTypeSPush( BooleanType )

      | '>' :
         @BoolExpr
         @MatchTypes
         [ oTypeSNodeType
            | nIntegerType, nBooleanType :  .tGreaterI
            | nCharType, nStringType :      #eNotImplemented
            | * :                           #eNotAllowed
         ]
         oTypeSPop
         oTypeSPush( BooleanType )

      | '<=' :
         @BoolExpr
         @MatchTypes
         [ oTypeSNodeType
            | nIntegerType, nBooleanType :  .tLessEqualI
            | nCharType, nStringType :      #eNotImplemented
            | * :                           #eNotAllowed
         ]
         oTypeSPop
         oTypeSPush( BooleanType )

      | '>=' :
         @BoolExpr
         @MatchTypes
         [ oTypeSNodeType
            | nIntegerType, nBooleanType :  .tGreaterEqualI
            | nCharType, nStringType :      #eNotImplemented
            | * :                           #eNotAllowed
         ]
         oTypeSPop
         oTypeSPush( BooleanType )

      | * :
         >
   ]};

BoolExpr:
   @BoolTerm
   {[
      | pOr :
         @RequireBoolPop
         @BoolTerm
         @RequireBool
         .tOr
      | * :
         >
   ]};

BoolTerm:
   @BoolFactor
   {[
      | pAnd :
         @RequireBoolPop
         @BoolFactor
         @RequireBool
         .tAnd
      | * :
         >
   ]};

BoolFactor:
   [
      | pNot :
         @ArithExpr
         @RequireBool
         .tNot
      | * :
         @ArithExpr
   ];

ArithExpr:
   @Term
   {[
      | pPlus :
         @RequireIntPop
         @Term
         @RequireInt
         .tAddI
      | pMinus :
         @RequireIntPop
         @Term
         @RequireInt
         .tSubI
      | * :
         >
   ]};

Term:
   @Factor
   {[
      | pTimes :
         @RequireIntPop
         @Factor
         @RequireInt
         .tMultI
      | pDivide :
         @RequireIntPop
         @Factor
         @RequireInt
         .tDivI
      | * :
         >
   ]};

Factor:
   [
      | pPlus :
         @Primary
         @RequireInt
      | pMinus :
         @Primary
         @RequireInt
         .tNegI
      | * :
         @Primary
   ];

Primary:
   [
      | pIntLit :
         .tPushConstI  oEmitInt( TOKEN_VALUE )
         oTypeSPush( IntegerType )

      | '(' :
         @Expr
         ')'

      | pStrLit :
         oStringAllocLit     % store, put addr on value stack
         .tPushConstP oEmitInt( oValueTop )  oValuePop
         % TO DO: do we need to create a type with the literal's length?
         oTypeSPush( StringType )

      | pIdent :
         Node decl
         Node theType
         decl = oScopeFindRequire

         [ oNodeType( decl )
            | nFunc :

               @Call( decl )

            | nConst :
               theType = oNodeGet( decl, qType )
               oTypeSPush( theType )
               [ oTypeSNodeType
                  | nIntegerType, nBooleanType :
                     .tPushConstI @EmitValue( decl )
                  | * :
                     #eNotImplemented
               ]

            | nGlobalVar, nLocalVar, nParam :
               @VarExpr( decl )

            | * :
               #eNotValue
               oTypeSPush( IntegerType )
         ]

      | '^' :        % ^var
         pIdent

         Node decl
         Node theType
         decl = oScopeFindRequire

         @VarLValue( decl )

         % The above leaves the pointed-to type on type stack.
         % But our expression type is actually ptr-to-<type>.
         theType = oTypeSTop
         oTypeSPop
         Node ptrType
         ptrType = @PointerTypeTo( theType )
         oTypeSPush( ptrType )

      | * :
         #eNotValue
         oTypeSPush( IntegerType )
   ];


% Parse a variable expression, given the declaration of the
% just-accepted identifier.
% Leaves the value on the expression stack, and type on the type stack.
%
VarExpr( Node decl ):
   Node theType
   theType = oNodeGet( decl, qType )
   oTypeSPush( theType )
   [ oTypeSNodeType
      | nIntegerType :
         [ oNodeType( decl )
            | nGlobalVar :   .tPushGlobalI @EmitValue( decl )
            | nLocalVar :    .tPushLocalI @EmitValue( decl )
            | nParam :       .tPushParamI @EmitValue( decl )
                     % TO DO:   VAR params may need adjustment? (also cases below...)
         ]

      | nBooleanType :
         [ oNodeType( decl )
            | nGlobalVar :   .tPushGlobalB @EmitValue( decl )
            | nLocalVar :    .tPushLocalB @EmitValue( decl )
            | nParam :       .tPushParamB @EmitValue( decl )
         ]

      | nCharType, nStringType, nFileType :
         #eNotImplemented

      | nPointerType :
         [ oNodeType( decl )
            | nGlobalVar :   .tPushGlobalP @EmitValue( decl )
            | nLocalVar :    .tPushLocalP @EmitValue( decl )
            | nParam :       .tPushParamP @EmitValue( decl )
         ]
         [
            | '^' :             % dereferenced
               oTypeSPop
               oTypeSPush( oNodeGet( theType, qBaseType ) )
               @LValue
               @FetchVar
            | * :               % just ptr value alone
         ]

      | * :
         % compound type
         % first, push addr of start of var
         [ oNodeType( decl )
            | nGlobalVar :   .tPushAddrGlobal @EmitValue( decl )
            | nLocalVar :    .tPushAddrLocal @EmitValue( decl )
            | nParam :       .tPushAddrParam @EmitValue( decl )
         ]
         % modify addr for subscripts, field references, etc
         @LValue
         % get final value
         @FetchVar
   ];


% Addr of start of var is on expr stack; type is on type stack.
% Replace expr stack with value of var.
% (In the case of compound vars, this remains as the addr of the var).

FetchVar:
   [ oTypeSNodeType
      | nIntegerType :   .tFetchI
      | nBooleanType :   .tFetchB
      | nCharType, nStringType, nFileType : #eNotImplemented
      | nPointerType :   .tFetchP
      | * :              % compound type; leave as addr
   ];


% Addr of start of var is already on run stack, and type is on type stack.
% Read subscripts, etc, to get final addr on run stack, and final type
% on type stack.

LValue:
   {[
      | '[' :       @ArraySubscripts
      | '.' :       @RecordFieldRef
      | '^' :       @PointerDeref
      | * :         >
   ]};

ArraySubscripts:
   [ oTypeSNodeType
      | nArrayType :
      | * :       #eNotArray
   ]
   {
      [ oTypeSNodeType
         | nArrayType :
         | * :    #eTooManySubscripts
      ]

      % low subscript of this dimension
      int low
      low = @OrdinalLow( oNodeGet( oTypeSTop, qIndexType ) )

      % replace type stack with next dimension, or OF type
      Node baseType
      baseType = oNodeGet( oTypeSTop, qBaseType )
      oTypeSPop
      oTypeSPush( baseType )

      @Expr
      @RequireIntPop
      % adjust for low subscript
      [ equal_zero( low )
         | false :
            .tPushConstI oEmitInt( low ) .tSubI
         | * :
      ]

      % multiply by element size
      int size
      size = oNodeGetInt( baseType, qSize )
      [ equal( size, 1 )
         | false :
            .tPushConstI oEmitInt( size ) .tMultI
         | * :
      ]

      % update start address
      .tAddI
      [
         | ']' :  >
         | ',' :
      ]
   };


RecordFieldRef:
   [ oTypeSNodeType
      | nRecordType :
      | * :    #eNotRecord
   ]
   oScopeEnter( oNodeGet( oTypeSTop, qScope ) )
   pIdent
   Node field
   field = oScopeFindRequire
   % oScopeFind searches all open scopes, so make sure we found nRecordField
   % which could only be seen in the local scope we entered above.
   [ oNodeType( field )
      | nRecordField :
      | * :   #eNotRecordField
   ]
   oScopeEnd
   int offset
   offset = oNodeGetInt( field, qValue )
   [ equal_zero( offset )
      | false :
         .tPushConstI oEmitInt( offset ) .tAddI
      | * :
   ]

   % replace the type on the type stack, with the field type
   oTypeSPop
   oTypeSPush( oNodeGet( field, qType ) )
   ;


% ptr deref on left side, i.e. BEFORE addr of ptr var is on stack,
%                              AFTER addr of thing pointed to is on stack
PointerDeref:
   [ oTypeSNodeType
      | nPointerType :
      | * :       #eNotPointer
   ]
   .tFetchP           % now addr on stack is addr of what we're pointing to

   Node theType
   theType = oTypeSTop
   oTypeSPop
   oTypeSPush( oNodeGet( theType, qBaseType ) )
   ;


% The expr stack contains a value whose type is on top of the type stack.
% Generate code to coerce the value to the type under it in the type stack
% (pop the type stack, leaving only the desired type).
% This is used for assignment.
%
CoerceType:
   % TO DO: not implemented yet.  For now I require exact type match.
   @MatchTypes
   ;


% Parse a call, given an nProc or nFunc for the just-accepted identifier.
% If a func, this will also generate the code to push the return value on the expr stack,
% and push the return type on the type stack.
%
Call( Node method ):

   Node paramScope
   paramScope = oNodeGet( method, qParams )
   int actualsSize
   actualsSize = oNodeGetInt( paramScope, qNextOffset )
   .tAllocActuals  oEmitInt( actualsSize )

   Node param
   param = oNodeGet( paramScope, qDecls )
   [
      | '(' :
      
         {
            [ oNodeNull( param )
               | true : >
               | * :
            ]

            Node actualType
            actualType = oNodeGet( param, qType )
            int offset
            offset = oNodeGetInt( param, qValue )

            % Assign actual value to spot in actuals space
            .tPushAddrActual oEmitInt( offset )
            oTypeSPush( oNodeGet( param, qType ) )

            [ oNodeGetBoolean( param, qInOut )
               | true :
                          % I need something like @LvalueExpr
                          % that parses expr, generating code to push addr, and push type on type stack.
                          % Close to what I have but need to refactor.
                          #eNotImplemented
                          % TO DO: match types more exactly. not sufficient to be assign compatible
                          %        since the method will be assigning to the actual using the param type.
                          %        Maybe something like type contents must match, incl subrange bounds.
                          .tAssignP

               | false :  @Expr
                          @CoerceType
                          
                          % Assign to offset in actuals space

                          [ oTypeSNodeType
                             | nIntegerType :            .tAssignI
                             | nBooleanType :            .tAssignB
                             | nCharType, nStringType, nFileType :   #eNotImplemented
                             | nPointerType :            .tAssignP
                             | * :
                                 % compound types: copy value into actuals space
                                 int size
                                 size = oNodeGetInt( oTypeSTop, qSize )
                                 .tCopy  oEmitInt( size )    % multi-word copy
                          ]
            ]

            oNodeNext( param )
            [ oNodeNull( param )
               | true :  >
               | false :
            ]

            ','
         }

         ')'

      | * :
         [ oNodeNull( param )
            | false :    #eMissingParameter
            | * :
         ]
   ]

   .tCall   @EmitValue( method )

   [ oNodeType( method )
      | nFunc :
         % TO DO: push return value from actuals space
         oTypeSPush( oNodeGet( method, qType ) )
      | * :
   ]
   
   .tFreeActuals  oEmitInt( actualsSize )
   ;


% ------------------------------ Statements -----------------------------

Statement:
   [
      | pWriteln :     @WritelnStmt
      | pWrite :       @WriteStmt
      | pReadln :      @ReadlnStmt
      | pRead :        @ReadStmt
      | pIf :          @IfStmt
      | pWhile :       @WhileStmt
      | pFor :         @ForStmt
      | pRepeat :      @RepeatStmt
      | pExit :        @ExitStmt
      | pCycle :       @CycleStmt
      | pBegin :       @BeginStmt
      | pIdent :       @AssignOrCallStmt
      | * :            % null statement : don't accept any tokens
   ];


AssignOrCallStmt:
   Node decl
   decl = oScopeFindRequire
   [ oNodeType( decl )
      | nProc :                           @Call( decl )
      | nGlobalVar, nLocalVar, nParam :   @AssignStmt( decl )
      | * :                               #eBadStatement
   ];


% Given decl, the just-accepted first identifier on the left hand side.
%
AssignStmt( Node decl ):

   @VarLValue( decl )

   ':=' 
   @Expr
   @MatchTypes
   [ oTypeSNodeType
      | nIntegerType :            .tAssignI
      | nBooleanType :            .tAssignB
      | nCharType, nStringType, nFileType :   #eNotImplemented

      % compound var assigns; addrs of src, dest on stack
      | nPointerType :            .tAssignP
      | * :
          int size
          size = oNodeGetInt( oTypeSTop, qSize )
          .tCopy  oEmitInt( size )    % multi-word copy
   ]
   oTypeSPop
   ;



% Parse an lvalue expression (e.g. left side of an assign statement)
% that stars with the just-accepted identifier indicated by the given decl.
% Leaves the lvalue address on the expression stack, and the type on the type stack.
%
VarLValue( Node decl ):
   [ oNodeType( decl )
      | nGlobalVar :   .tPushAddrGlobal @EmitValue( decl )
      | nLocalVar :    .tPushAddrLocal @EmitValue( decl )
      | nParam :       .tPushAddrParam @EmitValue( decl )
          % TO DO:   VAR params may need adjustment?
      | * :            #eNotVar
   ]

   oTypeSPush( oNodeGet( decl, qType ) )
   @LValue        % handle subscripts, if any
   ;


IfStmt:
   @Expr
   @RequireBoolPop
   pThen
   .tJumpFalse
   oPatchPushHere(patchIf)
   .tSpace
   @Statement
   [
      | pElse :
         .tJump
         oPatchPushHere(patchIf)
         .tSpace
         oPatchSwap(patchIf)
         oPatchPopFwd(patchIf)
         @Statement
      | * :
   ]
   oPatchPopFwd(patchIf);

ForStmt:
   pIdent

   Node decl
   decl = oScopeFindRequire
   [ oNodeType( decl )
      | nGlobalVar :
      | nLocalVar :    #eNotImplemented
      | nParam :       #eNotImplemented
      | * :            #eNotIntVar
   ]
   oTypeSPush( oNodeGet( decl, qType ) )
   @RequireIntPop
   .tPushConstP  @EmitValue( decl )

   ':='

   @Expr
   @RequireIntPop
   .tAssignI

   .tJump oPatchPushHere(patchLoop) .tSpace
   oPatchPushHere(patchLoop)
   oPatchSwap(patchLoop)
   [
      | pTo :
         .tIncGlobalI @EmitValue( decl )
         oPatchPopFwd(patchLoop)
         .tPushGlobalI @EmitValue( decl )
         @Expr
         @RequireIntPop
         .tGreaterI
         .tJumpTrue oPatchPushHere(patchLoop) .tSpace
         oPatchSwap(patchLoop)
      | pDownto :
         .tDecGlobalI @EmitValue( decl )
         oPatchPopFwd(patchLoop)
         .tPushGlobalI @EmitValue( decl )
         @Expr
         @RequireIntPop
         .tLessI
         .tJumpTrue oPatchPushHere(patchLoop) .tSpace
         oPatchSwap(patchLoop)
   ]
   oCountPush(0)          % count 'exit' patches
   pDo
   @Statement
   .tJump oPatchPopBack(patchLoop)
   oPatchPopFwd(patchLoop)
   @PatchExitsPop;

RepeatStmt:
   oPatchPushHere(patchLoop) % start of loop
   oCountPush(0)          % count the 'exit' patches
   @Statement
   {[
      | ';' :
         @Statement
      | pUntil :
         @Expr
         @RequireBoolPop
         .tJumpFalse
         oPatchPopBack(patchLoop)
         @PatchExitsPop
         >
   ]};

WhileStmt:
   oPatchPushHere(patchLoop)    % start of loop
   oCountPush(0)
   @Expr
   @RequireBoolPop
   pDo
   .tJumpFalse
   oPatchPushHere(patchLoop)    % jump out
   .tSpace
   oPatchSwap(patchLoop)        % start on top
   @Statement
   .tJump
   oPatchPopBack(patchLoop)
   oPatchPopFwd(patchLoop)
   @PatchExitsPop;

CycleStmt:                     % NOTE, for repeat..until, skips test (??)
   [ oPatchAnyEntries(patchLoop)
      | true :
         .tJump
         oPatchDup(patchLoop)  % addr of start
         oPatchPopBack(patchLoop)
      | * :
         #eNotInALoop
   ];

ExitStmt:
   [ oPatchAnyEntries(patchLoop)
      | true :
         .tJump
         oPatchPushHere(patchExit)
         .tSpace
         oCountInc
      | * :
         #eNotInALoop
   ];

BeginStmt:
   @Statement
   {[
      | ';' :   @Statement
      | pEnd :  >
   ]};

WritelnStmt:
   @WriteStmt
   .tWriteCR;

WriteStmt:
   [
      | '(' :
         {
            @Expr
            [ oTypeSNodeType
               | nIntegerType :             .tWriteI
               | nBooleanType :             .tWriteBool
               | nStringType :              .tWriteStr
               | nCharType, nFileType :     #eNotImplemented
               | nPointerType :             .tWriteP
               | * :                        #eNotAllowed
            ]
            oTypeSPop
            [
               | ')' : >
               | ',' :
            ]
         }
      | * :
   ];


ReadlnStmt:      % ***
   ;
ReadStmt:
   ;

% -------------------------------- Utilities -------------------------------

PatchExitsPop:
   {[ oCountIsZero
      | false : oPatchPopFwd(patchExit)
                oCountDec
      | * :     >
   ]}
   oCountPop;


% Require that the top two types on the type stack are matching (ignoring subranges).
% Pop one of them, leaving only one.
%
MatchTypes:
   node_type nt
   nt = oTypeSNodeType
   oTypeSPop
   [ equal_node_type( nt, oTypeSNodeType )
      | false :
         #eTypeMismatch
      | * :
   ];


% Require that the top type on the type stack is integer (ignoring subranges).
% Pop it.
%
RequireIntPop:
   [ oTypeSNodeType
      | nIntegerType :
      | * :          #eNotInteger
   ]
   oTypeSPop;

RequireInt:
   [ oTypeSNodeType
      | nIntegerType :
      | * :          #eNotInteger
   ];

RequireBoolPop:
   [ oTypeSNodeType
      | nBooleanType :
      | * :          #eNotBoolean
   ]
   oTypeSPop;

RequireBool:
   [ oTypeSNodeType
      | nBooleanType :
      | * :          #eNotBoolean
   ];


% Create and return a new nType of the given node_type, adding it to the type table.
%
newType( node_type nt, int size ) >> Node:
  Node node
  node = oNodeNew( nt )
  oNodeSetInt( node, qSize, size )
  oTypeAdd( node )
  >> node
  ;


% Create and return a new nIdent of the given node_type, with the given ident id.
% Does not add it to any scope.
%
newIdent( node_type nt, kind k, int id ) >> Node:
  Node t
  t = oNodeNew( nt )
  oNodeSetKind( t, qKind, k )   % deprecated attribute
  oNodeSetInt( t, qIdent, id )
  >> t
  ;


% Return an nType representing a pointer to the given type.
% (Creates a new type if necessary.)
%
PointerTypeTo( Node theType ) >> Node:
   Node ptrType
   ptrType = oNodeGet( theType, qPointerType )
   [ oNodeNull( ptrType )
      | true :
         ptrType = oNodeNew( nPointerType )
         oNodeSet( ptrType, qBaseType, theType )
         oNodeSetInt( ptrType, qSize, 8 )
         oTypeAdd( ptrType )
         oNodeSet( theType, qPointerType, ptrType )
      | * :
   ]
   >> ptrType;


% Return the low value of an ordinal type
%
OrdinalLow( Node theType ) >> int:
   [ oNodeType( theType )
      | nIntegerType :  >> -2147483648
      | nBooleanType :  >> 0
      | nCharType :     >> 0
      | nSubrangeType : >> oNodeGetInt( theType, qLow )
      | * :             #eNotOrdinalType
                        >> 0
   ];



% Emit the value in a declaration.
% For a constant integer, this is the constant value.
% For a global variable, this is the global address.
% For a local variable, this is the local address relative to the call stack frame.
%
EmitValue( Node decl ):
    oEmitInt( oNodeGetInt( decl, qValue ));


installBuiltIns:

   % install built-in types
   FileType = @newType( nFileType, 4 )
   IntegerType = @newType( nIntegerType, 4 )
   BooleanType = @newType( nBooleanType, 1 )
   CharType = @newType( nCharType, 1 )
   StringType = @newType( nStringType, 256 )    % string with default length 256

   % Declare those type identifiers.
   % SSL doesn't support strings, so need help from operations e.g. oIdAdd_File

   Node t

   t = @newIdent( nTypeDecl, kType, oIdAdd_File )
   oNodeSet( t, qType, FileType )
   oScopeDeclare( t )

   t = @newIdent( nTypeDecl, kType, oIdAdd_Integer )
   oNodeSet( t, qType, IntegerType )
   oScopeDeclare( t )

   t = @newIdent( nTypeDecl, kType, oIdAdd_Boolean )
   oNodeSet( t, qType, BooleanType )
   oScopeDeclare( t )

   t = @newIdent( nTypeDecl, kType, oIdAdd_Char )
   oNodeSet( t, qType, CharType )
   oScopeDeclare( t )

   t = @newIdent( nTypeDecl, kType, oIdAdd_String )
   oNodeSet( t, qType, StringType )
   oScopeDeclare( t )

   % Built-in constants

   t = @newIdent( nConst, kConst, oIdAdd_True )
   oNodeSet( t, qType, BooleanType )
   oNodeSetInt( t, qValue, 1 )
   oScopeDeclare( t )

   t = @newIdent( nConst, kConst, oIdAdd_False )
   oNodeSet( t, qType, BooleanType )
   oNodeSetInt( t, qValue, 0 )
   oScopeDeclare( t )

   ;

end

