/**/ 
static char sccsid[] = "@(#)schema.c	1.4 8/23/93 20:10:04 /files/home/sim/sarice/compilers/schema/SCCS/s.schema.c";
/**/

/*
*****************************************************************************
*
*   Database Schema Compiler
*
*   by Steve Rice
*
*   May 1, 1991
*
*****************************************************************************
*
*   schema.c            Main program.
*
*   HISTORY
*----------------------------------------------------------------------------
*   05/01/91 | Steve  | Initial version.
*   05/04/91 |        | Generate attribute offset table.
*   05/05/91 |        | Record attribute class.
*            |        | Write SSL code and C code to different files.
*   05/30/91 |        | Collect tags (Pri...) and write to file.
*   08/24/93 |        | Repackaged to use generic SSL runtime module.
*
*****************************************************************************
*/


#include <stdio.h>
#include <string.h>

#ifdef AMIGA
#include <dos.h>
#endif AMIGA

/*  SSL Runtime module  */
#include "ssl_rt.h"


/* Schema database access functions */
#include "schema_db.h"


#define  SSL_INCLUDE_ERR_TABLE
#include "schema.h"

/* For now, generated by hand. Schema macros. */
#include "schema_schema.h"

#include "debug.h"


#define DEBUG_FILE   "schema.dbg"         /* SSL debug information */
#define PROGRAM_FILE "schema.lst"


#include "schema.tbl"


char     input_filename[256];             /* schema source */


FILE    *f_lst;                           /* listing file                   */
FILE    *f_out;                           /* C code output                  */
FILE    *f_h_out;                         /* H code output                  */
FILE    *f_ssl_out;                       /* SSL code output                */



/* Variables for semantic mechanisms */
/* --------------------------------- */

short    dTemp;                           /* multi-purpose                  */
short    dTemp2;                          /* multi-purpose                  */
short   *dPtr;                            /* multi-purpose                  */
short    dWords;                          /* multi-purpose                  */
short    dSym;                            /* index of symbol in ST          */
long     dLong;                           /* multi-purpose                  */
Node     dNode;
List     dList;
Item     dItem;

Node     SchemaRoot;                      /* Root of schema database */
Node     CurrentClass;                    /* class found with oFindClass */
Node     GetsAttrsClass;                  /* class to get attributes */
Node     CurrentAttr;                     /* current attribute */
Node     CurrentAttrSym;                  /* current attribute symbol */
long     NumAttrSyms;                     /* count of attribute symbols */
long     NumClasses;                      /* count of created/derived classes */

short w_define_obj ();                    /* Define an object given an id   */
short w_define_attr ();                   /* Define an attribute given id   */
w_define_attr_of_obj ();                  /* ...given attr # and object #   */
w_derive_obj ();                          /* obj1 derives from obj2         */
w_dump_table ();
Node     w_find_class();


char           C_out_filename[100];
char           H_out_filename[100];
char           SSL_out_filename[100];
char           list_filename[256];

int            option_list;
int            option_debug;


print_node();
print_long();

dbg_variables debug_variables[] =
{
    /* "Name",         address,                    udata,    function */

    "SchemaRoot",      (char *) &SchemaRoot,       0,        print_node,
    "CurrentClass",    (char *) &CurrentClass,     0,        print_node,
    "GetsAttrsClass",  (char *) &GetsAttrsClass,   0,        print_node,
    "CurrentAttrSym",  (char *) &CurrentAttrSym,   0,        print_node,

    "NumAttrSyms",     (char *) &NumAttrSyms,      0,        print_long,
    "NumClasses",      (char *) &NumAttrSyms,      0,        print_long,

    "",                NULL,                       0,        NULL,
};

int   my_listing_function ();
int   init_my_operations ();


/*
*****************************************************************************
*
* main
*
* Description:
*   Get the command line arguments, read the SSL program into memory,
*   and execute the SSL table walker (interpreter).
*
*****************************************************************************
*/

main (argc, argv)
int   argc;
char *argv[];
{
    int     t_hitBreak();
    short   arg;
    int     i;
    int     status;


    /* check command line arguments */

    option_list = 0;
    option_debug = 0;

    for (arg = 1; arg<argc && argv[arg][0]=='-'; arg++)
    {
        for (i = 1; argv[arg][i]; i++)
        {
            if (argv[arg][i]=='L' || argv[arg][i]=='l')
                option_list = 1;
            else if (argv[arg][i]=='D' || argv[arg][i]=='d')
                option_debug = 1;
        }
    }

    if (arg >= argc)
    {
        printf("Usage:  schema [-l] [-d] <file>\n");
        printf("        -l : produce listing file\n");
        printf("        -d : invoke full screen debugger\n");
        exit(10);
    }


    sprintf (input_filename,   "%s.schema",     argv[arg]);

    sprintf (C_out_filename,   "%s_schema.c",   argv[arg]);
    sprintf (H_out_filename,   "%s_schema.h",   argv[arg]);
    sprintf (SSL_out_filename, "%s_schema.ssl", argv[arg]);
    sprintf (list_filename,    "%s_schema.lst", argv[arg]);

    open_my_files ();

    ssl_init ();

    init_my_scanner ();

    ssl_set_debug (option_debug);
    ssl_set_debug_info (DEBUG_FILE, PROGRAM_FILE, oBreak, debug_variables);

    ssl_set_input_filename (input_filename);

    ssl_set_recovery_token (pDERIVES);

    if (option_list)
        ssl_set_listing_callback (my_listing_function);

    ssl_set_init_operations_callback (init_my_operations);

#ifdef AMIGA
    onbreak(&t_hitBreak);
#endif AMIGA


    /* execute SSL program */

    status = ssl_run_program ();

    close_my_files ();

    if (status != 0)
        exit(5);

    exit(0);
}


int my_listing_function (source_line, token_accepted)
char                    *source_line;
int                      token_accepted;
{

    fprintf(f_lst, "====  %s", source_line);
}


open_my_files ()
{

    if ((f_out=fopen(C_out_filename,"w"))==NULL)
    {
        printf ("Can't open output file %s\n", C_out_filename);
        exit (10);
    }

    if ((f_h_out=fopen(H_out_filename,"w"))==NULL)
    {
        printf ("Can't open output file %s\n", H_out_filename);
        exit (10);
    }

    if ((f_ssl_out=fopen(SSL_out_filename,"w"))==NULL)
    {
        printf ("Can't open output file %s\n", SSL_out_filename);
        exit (10);
    }

    if (option_list)
    {
        if ((f_lst=fopen(list_filename, "w"))==NULL)
        {
            printf ("Can't open listing file %s\n", list_filename);
            exit (10);
        }
    }
}


close_my_files ()
{
    fclose (f_out);
    fclose (f_h_out);
    fclose (f_ssl_out);
    if (option_list)
        fclose (f_lst);
}


t_hitBreak()
{
    printf("Breaking...\n");
    close_my_files ();
    return(1);
}


/*********** S e m a n t i c   O p e r a t i o n s ***********/

init_my_operations ()
{
    SCH_Init ();   /* Init schema database package */

    SchemaRoot = NULL;
    CurrentClass = NULL;
    GetsAttrsClass = NULL;
    CurrentAttr = NULL;
    CurrentAttrSym = NULL;
    NumAttrSyms = 0;
    NumClasses = 0;
}


/* ----------------------------------------------------------------------- */
/* ----------------------------------------------------------------------- */


#include "ssl_begin.h"

       /* mechanism Class */

       case oCreateEmptySchema :
              SchemaRoot = NewNode (nSchema);
              SetqClassTree (SchemaRoot, NewList(nClass));
              SetqAttrSyms (SchemaRoot, NewList(nAttrSym));

              dTemp = ssl_add_id ("nINVALID", pIDENTIFIER);   /* Add to ident table */
              dNode = NewNode (nClass);
              SetqIdent (dNode, dTemp);
              SetqText (dNode, "nINVALID");
              SetqAttrs (dNode, NewList(nAttr));
              SetqDerived (dNode, NewList(nClass));
              AddLast (qClassTree(SchemaRoot), dNode);
              NumClasses++;

              dTemp = ssl_add_id ("Object", pIDENTIFIER);   /* Add to ident table */
              dNode = NewNode (nClass);
              SetqIdent (dNode, dTemp);
              SetqText (dNode, "Object");
              SetqAttrs (dNode, NewList(nAttr));
              SetqDerived (dNode, NewList(nClass));
              AddLast (qClassTree(SchemaRoot), dNode);
              NumClasses++;

              dTemp = ssl_add_id ("qINVALID", pIDENTIFIER);   /* Add to ident table */
              dNode = NewNode (nAttrSym);
              SetqIdent (dNode, dTemp);
              SetqText (dNode, "qINVALID");
              SetqCode (dNode, NumAttrSyms);
              AddLast (qAttrSyms(SchemaRoot), dNode);
              NumAttrSyms++;

              continue;
       case oFindClass :
              CurrentClass = w_find_class (qClassTree(SchemaRoot), (long) ssl_last_id);
              if (CurrentClass == NULL)
                  ssl_fatal("Undefined class");
              continue;
       case oDeriveClass :
              /* Verify class not already defined */
              if (w_find_class (qClassTree(SchemaRoot), (long) ssl_last_id) != NULL)
                  ssl_fatal("Multiply defined class");
              dNode = NewNode (nClass);
              SetqIdent (dNode, ssl_last_id);
              SetqText (dNode, ssl_last_id_text);
              SetqAttrs (dNode, NewList(nAttr));
              SetqDerived (dNode, NewList(nClass));
              AddLast (qDerived(CurrentClass), dNode);
              NumClasses++;
              continue;
       case oThisClassWillGetAttrs :
              GetsAttrsClass = CurrentClass;
              continue;
       case oNoClassWillGetAttrs :
              GetsAttrsClass = NULL;
              continue;
       case oAClassWillGetAttrs :
              ssl_result = (GetsAttrsClass != NULL);
              continue;


       /* mechanism Attr */

       case oCreateAttrSym :
              for (dItem = FirstItem(qAttrSyms(SchemaRoot)); dItem != NULL; dItem = NextItem(dItem))
                  if (qIdent(Value(dItem)) == ssl_last_id)
                      break;
              if (dItem == NULL)
              {
                  dNode = NewNode (nAttrSym);
                  SetqIdent (dNode, ssl_last_id);
                  SetqText (dNode, ssl_last_id_text);
                  SetqCode (dNode, NumAttrSyms);
                  SetqType (dNode, type_INVALID);   /* Type not yet set */
                  dItem = AddLast (qAttrSyms(SchemaRoot), dNode);
                  NumAttrSyms++;
              }
              CurrentAttrSym = Value(dItem);
              continue;
       case oCreateAttr :
              CurrentAttr = NewNode (nAttr);
              SetqAttrSym (CurrentAttr, CurrentAttrSym);
              AddLast (qAttrs(GetsAttrsClass), CurrentAttr);
              continue;
       case oAttrType :
              dNode = qAttrSym(CurrentAttr);
              if ((qType(dNode) != type_INVALID) && (qType(dNode) != ssl_param))
              {
                  printf ("Inconsistent attribute type\n");
              }
              SetqType (dNode, ssl_param);
              continue;
       case oAttrTag :
              dLong = qTags(CurrentAttr);
              SetqTags (CurrentAttr, (dLong | ssl_param));
              continue;

       /* mechanism doc */

       case oDocDumpTable :
              w_dump_table ();
              continue;

#include "ssl_end.h"

/* ----------------------------------------------------------------------- */
/* ----------------------------------------------------------------------- */


Node      w_find_class (tree_list, ident)
List                    tree_list;
long                    ident;
{
    Node       root;
    Item       I;
    List       derived;
    Node       find_in_derived;

    for (I = FirstItem(tree_list); I != NULL; I = NextItem(I))
    {
        root = Value(I);

        if (qIdent(root) == ident)
            return (root);

        derived = qDerived (root);
        find_in_derived = w_find_class (derived, ident);
        if (find_in_derived != NULL)
            return (find_in_derived);
    }
    return (NULL);

}


w_dump_table ()
{
    Node                 class;
    Item                 I;
    Node                 N;
    short               *obj_sizes;
    char                *obj_isa;
    short               *attr_offsets;
    short               *attr_types;
    short               *attr_tags;
    short                next_offset;
    short                a, c;
    int                  current_class_code;

    w_create_all_classes_list ();

    printf ("\n");
    printf ("Writing SSL code to %s\n", SSL_out_filename);

    fprintf (f_ssl_out, "\n%% Generated automatically by schema\n\n");

    fprintf (f_ssl_out, "type node_type:\n");
    FOR_EACH_ITEM (I, qAllClasses(SchemaRoot))
    {
        fprintf (f_ssl_out, "\t%s\n", ssl_get_id_string(qIdent(Value(I))));
    }

    fprintf (f_ssl_out, "\t;\n\n");

    fprintf (f_ssl_out, "type node_attribute:\n");
    FOR_EACH_ITEM (I, qAttrSyms(SchemaRoot))
    {
        fprintf (f_ssl_out, "\tT_%s\n", ssl_get_id_string(qIdent(Value(I))));
    }

    fprintf (f_ssl_out, "\t;\n\n");

    printf ("Writing C code to %s\n", C_out_filename);

    fprintf (f_out, "\n/* Generated automatically by schema */\n\n");

    fprintf (f_out, "/* Private Data */\n\n");



    /* Initialize memory layout assignments before any classes created */

    attr_offsets = (short *) malloc (sizeof(short) * NumAttrSyms);
    obj_sizes    = (short *) malloc (sizeof(short) * NumClasses);
    obj_isa      = (char  *) malloc (sizeof(char)  * NumClasses);

    for (a = 0; a < NumAttrSyms; a++)
        attr_offsets[a] = -1;

    for (c = 0; c < NumClasses; c++)
        obj_sizes[c] = 0;

    for (c = 0; c < NumClasses; c++)
        obj_isa[c] = 0;


    /* Print entries for class tree */

    next_offset = 0;
    current_class_code = -1;

    fprintf (f_out, "static short dAttributeOffset [%d][%d] = {\n", NumClasses, NumAttrSyms);

    w_dump_c_attr_offsets (qClassTree(SchemaRoot), attr_offsets, next_offset,
                           &current_class_code, obj_sizes);
    fprintf (f_out, "};\n\n");


    fprintf (f_out, "static short dAttributeTags [%d][%d] = {\n", NumClasses, NumAttrSyms);

    attr_tags = (short *) malloc (sizeof(short) * NumAttrSyms);
    for (a = 0; a < NumAttrSyms; a++)
        attr_tags[a] = 0;

    w_dump_c_attr_tags (qClassTree(SchemaRoot), attr_tags);

    fprintf (f_out, "};\n\n");


    current_class_code = -1;

    fprintf (f_out, "static short dClassIsA [%d][%d] = {\n", NumClasses, NumClasses);

    w_dump_c_class_isa (qClassTree(SchemaRoot), &current_class_code, obj_isa);
    fprintf (f_out, "};\n\n");


    fprintf (f_out, "\n/* Public Data */\n\n");

    fprintf (f_out, "short dObjectSize [%d] = {\n\t", NumClasses);
    for (c = 0; c < NumClasses; c++)
    {
        fprintf (f_out, "%d, ", obj_sizes[c]);
        if ((c & 15) == 15)
            fprintf (f_out, "\n\t");
    }
    fprintf (f_out, "\n};\n\n");

    fprintf (f_out, "int   dObjects = %d;\n", NumClasses);
    fprintf (f_out, "char *dObjectName [%d] = {\n", NumClasses);

    FOR_EACH_ITEM (I, qAllClasses(SchemaRoot))
    {
        fprintf (f_out, "\t\"%s\",\n", ssl_get_id_string(qIdent(Value(I))));
    }

    fprintf (f_out, "};\n\n");

    fprintf (f_out, "int   dAttributes = %d;\n", NumAttrSyms);
    fprintf (f_out, "char *dAttributeName [%d] = {\n", NumAttrSyms);

    FOR_EACH_ITEM (I, qAttrSyms(SchemaRoot))
    {
        fprintf (f_out, "\t\"%s\",\n", ssl_get_id_string(qIdent(Value(I))));
    }

    fprintf (f_out, "};\n\n");

    w_dump_c_attr_types (qAttrSyms(SchemaRoot));

    fprintf (f_out, "\n/* Public Functions */\n\n");

    fprintf (f_out, "short dGetAttributeOffset (class, attribute)      \n");
    fprintf (f_out, "short                      class;                 \n");
    fprintf (f_out, "short                      attribute;             \n");
    fprintf (f_out, "{                                                 \n");
    fprintf (f_out, "    return (dAttributeOffset[class][attribute]);  \n");
    fprintf (f_out, "}                                                 \n");
    fprintf (f_out, "                                                  \n");
    fprintf (f_out, "short dGetAttributeType (attribute)               \n");
    fprintf (f_out, "short                    attribute;               \n");
    fprintf (f_out, "{                                                 \n");
    fprintf (f_out, "    return (dAttributeType[attribute]);           \n");
    fprintf (f_out, "}                                                 \n");
    fprintf (f_out, "                                                  \n");
    fprintf (f_out, "short dGetAttributeTags (class, attribute)        \n");
    fprintf (f_out, "short                    class;                   \n");
    fprintf (f_out, "short                    attribute;               \n");
    fprintf (f_out, "{                                                 \n");
    fprintf (f_out, "    return (dAttributeTags[class][attribute]);    \n");
    fprintf (f_out, "}                                                 \n");
    fprintf (f_out, "                                                  \n");
    fprintf (f_out, "int   dGetClassIsA      (class, isaclass)         \n");
    fprintf (f_out, "short                    class;                   \n");
    fprintf (f_out, "short                    isaclass;                \n");
    fprintf (f_out, "{                                                 \n");
    fprintf (f_out, "    return (dClassIsA[class][isaclass]);          \n");
    fprintf (f_out, "}                                                 \n");
    fprintf (f_out, "                                                  \n");


    w_dump_h_macros ();

    printf ("\n");
}


/*  This list can be used to traverse all classes in schema  */
w_create_all_classes_list ()
{
    List   L;

    L = NewList (nClass);

    w_create_all_classes_sub (qClassTree(SchemaRoot), L);

    SetqAllClasses (SchemaRoot, L);
}

w_create_all_classes_sub (class_tree, L)
List                      class_tree;
List                      L;
{
    Item       I;
    Node       N;

    FOR_EACH_ITEM (I, class_tree)
    {
        N = Value(I);
        AddLast (L, N);
        w_create_all_classes_sub (qDerived(N), L);
    }
}

w_dump_c_attr_offsets (class_tree, parent_offsets, parent_next_offset,
                       class_code_ptr, obj_sizes)
List                   class_tree;
short                 *parent_offsets;
short                  parent_next_offset;
int                   *class_code_ptr;
short                 *obj_sizes;
{
    short    *attr_offsets;
    short     next_offset;
    short     a;
    Node      Attr;
    long      attr_code;
    Node      N;
    Item      I;
    Item      AttrI;

    attr_offsets = (short *) malloc (sizeof(short) * NumAttrSyms);

    for (I = FirstItem(class_tree); I != NULL; I = NextItem(I))
    {
        N = Value(I);

        (*class_code_ptr)++;

        /* Derive attributes from parent */

        for (a = 0; a < NumAttrSyms; a++)
            attr_offsets[a] = parent_offsets[a];

        next_offset = parent_next_offset;

        /* Add attributes to this class */

        for (AttrI = FirstItem(qAttrs(N)); AttrI != NULL; AttrI = NextItem(AttrI))
        {
            attr_code = qCode(qAttrSym(Value(AttrI)));
            attr_offsets[attr_code] = next_offset;
            next_offset += 4;
        }

        obj_sizes[*class_code_ptr] = next_offset;

        /* Print class layout to file */

        fprintf (f_out, "\t");
        for (a = 0; a < NumAttrSyms; a++)
        {
            fprintf (f_out, "%3d, ", attr_offsets[a]);
        }
        fprintf (f_out, "\n");

        /* Now derive any other classes from this class */

        if (!IsEmpty(qDerived(N)))
        {
            w_dump_c_attr_offsets (qDerived(N), attr_offsets, next_offset,
                                   class_code_ptr, obj_sizes);
        }
    }

    free (attr_offsets);
}


w_dump_c_attr_types   (attr_syms)
List                   attr_syms;
{
    short    *attr_types;
    short     a;
    Node      Attr;
    Node      Derived;
    long      attr_code;
    Item      I;
    Node      N;
    Item      AttrI;


    attr_types = (short *) malloc (sizeof(short) * NumAttrSyms);
    for (a = 0; a < NumAttrSyms; a++)
        attr_types[a] = -1;

    attr_types = (short *) malloc (sizeof(short) * NumAttrSyms);

    for (I = FirstItem(attr_syms); I != NULL; I = NextItem(I))
    {
        N = Value(I);

        attr_code = qCode(N);
        attr_types[attr_code] = qType(N);
    }

    /* Print to file */

    fprintf (f_out, "short dAttributeType [%d] = {\n", NumAttrSyms);
    fprintf (f_out, "\t");

    for (a = 0; a < NumAttrSyms; a++)
    {
        fprintf (f_out, "%3d, ", attr_types[a]);
    }
    fprintf (f_out, "\n");
    fprintf (f_out, "};\n\n");

    free (attr_types);
}


w_dump_c_attr_tags    (class_tree, parent_attr_tags)
List                   class_tree;
short                 *parent_attr_tags;
{
    short    *attr_tags;
    short     a;
    Node      Attr;
    Node      Derived;
    long      attr_code;
    Item      I;
    Node      N;
    Item      AttrI;

    attr_tags = (short *) malloc (sizeof(short) * NumAttrSyms);

    for (I = FirstItem(class_tree); I != NULL; I = NextItem(I))
    {
        N = Value(I);

        /* Derive attributes from parent */

        for (a = 0; a < NumAttrSyms; a++)
            attr_tags[a] = parent_attr_tags[a];

        /* Add attributes to this class */

        for (AttrI = FirstItem(qAttrs(N)); AttrI != NULL; AttrI = NextItem(AttrI))
        {
            attr_code = qCode(qAttrSym(Value(AttrI)));
            attr_tags[attr_code] = qTags(Value(AttrI));
        }

        /* Print to file */

        fprintf (f_out, "\t");
        for (a = 0; a < NumAttrSyms; a++)
        {
            fprintf (f_out, "%3d, ", attr_tags[a]);
        }
        fprintf (f_out, "\n");

        /* Now derive any other classes from this class */

        if (!IsEmpty(qDerived(N)))
        {
            w_dump_c_attr_tags (qDerived(N), attr_tags);
        }
    }

    free (attr_tags);
}


w_dump_c_class_isa (class_tree, class_code_ptr, parent_obj_isa)
List                   class_tree;
int                   *class_code_ptr;
char                  *parent_obj_isa;
{
    char     *obj_isa;
    short     o;
    Item      I;
    Node      N;

    obj_isa = (char *) malloc (sizeof(char) * NumClasses);

    for (I = FirstItem(class_tree); I != NULL; I = NextItem(I))
    {
        N = Value(I);
        (*class_code_ptr)++;

        /* Derive IsA flags from parent */

        for (o = 0; o < NumClasses; o++)
            obj_isa[o] = parent_obj_isa[o];

        /* We are also our own object class */

        obj_isa[(*class_code_ptr)] = 1;


        /* Print IsA flags to file */

        fprintf (f_out, "\t");
        for (o = 0; o < NumClasses; o++)
        {
            fprintf (f_out, "%1d, ", obj_isa[o]);
        }
        fprintf (f_out, "\n");

        /* Now derive any other classes from this class */

        if (!IsEmpty(qDerived(N)))
        {
            w_dump_c_class_isa (qDerived(N), class_code_ptr, obj_isa);
        }
    }

    free (obj_isa);
}

w_dump_h_macros ()
{
    Item        I;
    Node        N;

    printf ("Writing C macros to %s\n", H_out_filename);

    fprintf (f_h_out, "/* Generated automatically by schema */\n");
    fprintf (f_h_out, "\n");
    fprintf (f_h_out, "#include \"schema_db.h\"\n");
    fprintf (f_h_out, "\n");

    /* Define Classes and Attributes, in case the definitions aren't
     * read from an SSL header.
     */

    fprintf (f_h_out, "#ifndef Object\n");

    fprintf (f_h_out, "typedef enum {\n");
    FOR_EACH_ITEM (I, qAllClasses(SchemaRoot))
    {
        fprintf (f_h_out, "    %s,\n", ssl_get_id_string(qIdent(Value(I))));
    }
    fprintf (f_h_out, "} ObjectType;\n");

    fprintf (f_h_out, "\n");
    fprintf (f_h_out, "typedef enum {\n");
    FOR_EACH_ITEM (I, qAttrSyms(SchemaRoot))
    {
        fprintf (f_h_out, "    T_%s,\n", ssl_get_id_string(qIdent(Value(I))));
    }
    fprintf (f_h_out, "} AttrCode;\n");

    fprintf (f_h_out, "#endif /* Object */\n");
    fprintf (f_h_out, "\n");

    /* Define query and set macros */

    FOR_EACH_ITEM (I, qAttrSyms(SchemaRoot))
    {
        N = Value(I);
        fprintf (f_h_out, "#define %s(N)\t\t(%s)\tGetAttr(T_%s, N)\n",
                 ssl_get_id_string(qIdent(N)),
                 SCH_GetTypeName(qType(N)),
                 ssl_get_id_string(qIdent(N)));
    }

    fprintf (f_h_out, "\n");
    FOR_EACH_ITEM (I, qAttrSyms(SchemaRoot))
    {
        N = Value(I);
        fprintf (f_h_out, "#define Set%s(N,V)\t\tSetAttr(T_%s, N, (void*)(V))\n",
                 ssl_get_id_string(qIdent(N)),
                 ssl_get_id_string(qIdent(N)));
    }

    fprintf (f_h_out, "\n");
    FOR_EACH_ITEM (I, qAllClasses(SchemaRoot))
    {
        N = Value(I);
        fprintf (f_h_out, "#define New%s()\t\tNewNode(%s)\n",
                 ssl_get_id_string (qIdent(N)),
                 ssl_get_id_string (qIdent(N)));
    }

    fprintf (f_h_out, "\n");
}


/*  Callbacks to display variables in debugger  */

print_node (variable, udata)
char       *variable;
char       *udata;
{
    Node      N = *((Node *) variable);

    DumpNodeShort (N);
}

print_long (variable, udata)
char       *variable;
char       *udata;
{
    printf ("%d\n", *((long *) variable));
}

/***** FIX THIS.  debug/1.2.8/debug.o calls it. *****/
nodeDumpTreeNum (node_number)
long             node_number;
{
    Node  N;
    N = SCH_LookupNode (node_number);
    DumpNodeLong (N);
}


/*
 *  Scanner
 */

struct ssl_token_table_struct my_keyword_table[] =
{
    "Boolean1",      pBoolean1,
    "Character1",    pCharacter1,
    "Integer4",      pInteger4,
    "Integer8",      pInteger8,
    "IntegerN",      pIntegerN,
    "Real4",         pReal4,
    "Real8",         pReal8,
    "RealN",         pRealN,
    "StringN",       pStringN,
    "ObjectType",    pObjectType,
    "Node",          pNode,
    "List",          pList,

    "Pri",           pPri,
    "Alt",           pAlt,
    "Opt",           pOpt,
    "Int",           pInt,
    "Ext",           pExt,
    "Sys",           pSys,
    "Tmp",           pTmp,

    "Schema",        pSchema,
    "Is",            pIs,
    "Root",          pRoot,
    "End",           pEnd,

    NULL,            0
};


struct ssl_token_table_struct my_operator_table[] =
{
    ":",             pCOLON,
    ",",             pCOMMA,
    "(",             pLPAREN,
    ")",             pRPAREN,
    "[",             pLSQUARE,
    "]",             pRSQUARE,
    "::=",           pDERIVES,
    "=>",            pCONTAINS,

    NULL,            0   
};

struct ssl_special_codes_struct my_special_codes;


init_my_scanner ()
{
    my_special_codes.invalid = pINVALID;
    my_special_codes.eof     = pEOF;
    my_special_codes.ident   = pIDENTIFIER;

    my_special_codes.intlit  = pINVALID;   /* Don't want integers for now */
    my_special_codes.strlit  = pINVALID;   /* Don't want strings for now */

    ssl_init_scanner (my_keyword_table, my_operator_table, &my_special_codes);
    ssl_set_case_sensitive (0);   /* Not case sensitive */
}


