      %  sccsid = "%W% %G% %U% %P%";
      
   0: title: 'SSL Translator 1.3.0 -- August 23 ''93';
      
      %
      % *****************************************************************************
      %
      %   Syntax/Semantic Language Compiler
      %
      %   by Steve Rice
      %
      %   Aug 31, 1989
      %
      % *****************************************************************************
      %
      %   ssl.ssl             SSL compiler
      %
      %   HISTORY
      % -----------------------------------------------------------------------------
      %   08/31/89 | Steve  | Translated from my SSL processor hardcoded in C
      %   09/08/89 |        | SSL processor now functional, except for error recovery
      %   10/18/89 |        | Added 'title' section
      %   02/03/90 |        | Change to ssl.c: Added debugger output
      %   03/20/91 |        | Change to ssl.c: Increased string table size
      %   03/26/91 |        | Fixed bug in handling of statement ">>value"
      %            |        | Fixed bug in handling of choice using a choice rule
      %            |        | defined later
      %   04/24/91 |        | Change to ssl.c: Increased identifier size to 50 chars
      %   05/05/91 |        | Change to ssl.c: Increased identifier table size to
      %            |        | 600, and moved names out of table. New limit 256 chars.
      %            |        | Added "include" feature.
      %   05/21/91 |        | Multiple "error" sections will use distinct error #'s
      %            |        | Added postprocess optimization: reduce chains of jumps
      %   06/04/91 |        | Change to ssl.c: Write rule addresses to code file
      %   08/23/93 |        | Fix some loops so error recovery can terminate
      %   08/25/93 |        | Reimplement using schema database for symbol table
      %   08/27/93 |        | Add new language features: local variables,
      %            |        | multiple parameters, inout parameters,
      %            |        | expressions with nested function calls.
      %            |        | (User program requires the 2.0 runtime model for new
      %            |        | instructions in generated code).
      %            |        |
      % 
      % *****************************************************************************
      %
      %   BUGS
      % -----------------------------------------------------------------------------
      %   01/28/90 | Doesn't complain if functions called but never declared!	
      %
      % *****************************************************************************
      %
      %   NOTES
      %
      %   *  The base counter in the count stack counts semantic operations.
      %
      %   *  When a new identifier is added to the table by the scanner,
      %      it is given a default kind kUnknown.  ** NOT ANYMORE, DO I DEPEND ON IT?
      %
      %   *  Stack entries that are read by an operation are left there,
      %      unless the operation contains the word 'Pop'.
      %      The emit statement never pops stack entries (i.e. .iConstant
      %      emits the value on the value stack, but does not pop it.)
      %
      % *****************************************************************************
      %
      
   0: input:
   0:     pIdent
   0:     pIntLit
   0:     pStrLit
   0:     pMinus      '-'
   0:     pEquals     '='
   0:     pColon      ':'
   0:     pSemiColon  ';'
   0:     pComma      ','
   0:     pLParen     '('
   0:     pRParen     ')'
   0:     pReturn     '>>'
   0:     pBreak      '>'
   0:     pLCurly     '{'
   0:     pRCurly     '}'
   0:     pLSquare    '['
   0:     pRSquare    ']'
   0:     pBar        '|'
   0:     pCall       '@'
   0:     pEmit       '.'
   0:     pStar       '*'
   0:     pErr        '#'
   0:     pQuestion   '?'
   0:     pEof
   0:     pInvalid
      
      %  keywords
      
   0:     pTitle
   0:     pInput
   0:     pOutput
   0:     pType
   0:     pError
   0:     pMechanism
   0:     pInclude
   0:     pRules
   0:     pEnd
   0:     pIn
   0:     pOut
   0:     pInOut
   0:     ;
      
      
   0: output:
      
      %  codes for SSL machine instructions
      
   0:     iJumpForward
   0:     iJumpBack
   0:     iInput
   0:     iInputAny
   0:     iEmit
   0:     iError
   0:     iInputChoice
   0:     iCall
   0:     iReturn
   0:     iSetResult
   0:     iChoice
   0:     iEndChoice
   0:     iPushResult      % push ssl_result on variable stack
   0:     iPop             % (n)  discard n entries from variable stack
   0:     iBreak           % instruction used by debugger
   0:     iGlobalSpace     % (n)  make space for n globals on variable stack (sets initial fp)
   0:     iLocalSpace      % (n)  make space for n locals on variable stack
   0:     iGetParam        % (n)  ssl_result = value of param n
   0:     iGetFromParam    % (n)  ssl_result = value of variable whose address is in param n
   0:     iGetLocal        % (n)  ssl_result = value of local var n
   0:     iGetGlobal       % (n)  ssl_result = value of global var n
   0:     iGetAddrParam    % (n)  ssl_result = addr of param n
   0:     iGetAddrLocal    % (n)  ssl_result = addr of local var n
   0:     iGetAddrGlobal   % (n)  ssl_result = addr of global var n
   0:     iAssign          % variable whose address is pushed on stack = ssl_result; pop stack
      
      %   NOTE: Any instructions added here should also be added to
      %         the system_operations table in ssl.c
      %         as well as optimize_table, list_generated_code.
      
      %  other output
      
   0:     iSpace           % emit a dummy value; a value will be patched here later
   0:     iConstant;       % emit the value on the value stack
      
   0: error:
   0:    eMissingProgramBlock
   0:    eMissingEnd
   0:    eWrongType
   0:    eNoShortFormHere
   0:    eNotAType
   0:    eNotAValue
   0:    eNotInput
   0:    eNotOutput
   0:    eNotARule
   0:    eNotAStatement
   0:    eUndeclaredIdent
   0:    eBadStatement
   0:    eNotAnErrSig
   0:    eNotInLoop
   0:    eNotChoice     % rule or op
   0:    eChoiceOpRuleOutOfPlace
      
   0:    eUnexpectedKind
   0:    eWrongNumberParams
   0:    eUndeclRuleParamsNotSupported
   0:    eNotTyped
   0:    eIdentNotAllowedInExpr
   0:    eParamNotSupportedYet
   0:    eIllegalLvalue
   0:    eNotRuleOrGlobalDefn
   0:    eRuleBodyAlreadyDeclared
   0:    eReturnTypeMismatch
   0:    eParameterMismatch
   0:    eUndefinedIdentifier
   0:    ;
      
      
   0: include 'ssl_schema.ssl'
      
      % Generated automatically by schema
      
   0: type node_type:
   0: 	nINVALID
   0: 	Object
   0: 	nScope
   0: 	nDeclaration
   0: 	nIdent
   0: 	nInput
   0: 	nOutput
   0: 	nError
   0: 	nType
   0: 	nValue
   0: 	nMechanism
   0: 	nOperation
   0: 	nRule
   0: 	nVariable
   0: 	nParam
   0: 	nInParam
   0: 	nOutParam
   0: 	nInOutParam
   0: 	nLocal
   0: 	nGlobal
   0: 	;
      
   0: type node_attribute:
   0: 	qINVALID
   0: 	qParentScope
   0: 	qDecls
   0: 	qIdent
   0: 	qValue
   0: 	qType
   0: 	qParamScope
   0: 	qScope
   0: 	qAddrDefined
   0: 	qTypeDefined
   0: 	qAddr
   0: 	;
      
      
      
   0: type boolean:
   0:     false    = 0
   0:     true     = 1
   0:     no       = 0
   0:     yes      = 1;
      
   0: type number:
   0:     zero            = 0
   0:     one             = 1
   0:     ;
      
   0: type warning:
   0:     wRuleMissingAtSign
   0:     ;
      
   0: type kind:
   0:     kIllegal        % not an identifier
   0:     kUnknown        % new identifier
   0:     kInput
   0:     kOutput
   0:     kError
   0:     kType
   0:     kVal            % an element of a type
   0:     kMech
   0:     kOp
   0:     kRule
   0:     kVar
   0:     ;
      
   0: mechanism warning_mech:
   0:     oWarning (warning);       % issue warning message,
                                    % continue normally (not in error recovery mode)
      
   0: mechanism count:
   0:     oCountPush(number)        % push a new counter, with initial value
   0:     oCountPushIntLit          % push value of integer just read
   0:     oCountPushValue           % push value from value stack
   0:     oCountPop                 % discard counter
   0:     oCountInc
   0:     oCountDec
   0:     oCountNegate              % negate top counter
   0:     oCountZero >> boolean;    % is the top counter 0?
      
   0: mechanism next_error:                % variable to determine error #
   0:     oNextErrorPushCount               % push variable onto Count stack
   0:     oNextErrorPopCount;               % pop variable off Count stack
      
      
   0: mechanism value:                     % multi-purpose stack
   0:     oValuePush(number)                % push a constant value
   0:     oValuePushBoolean(boolean)        % push a constant boolean
   0:     oValuePushKind(kind)              % push a kind value
   0:     oValuePushNodeType(node_type)     % push a node type
   0:     oValuePushIdent                   % push ident# of last ident read
   0:     oValuePushIntLit                  % push integer just read
   0:     oValueChooseKind >> kind          % kind on top of stack
   0:     oValueChooseBoolean >> boolean    % boolean on top of stack
   0:     oValuePushCount                   % value on top of count stack
   0:     oValuePushHere                    % push current (output) address
   0:     oValueNegate                      % negate top value
   0:     oValueSwap                        % swap top two elements
   0:     oValueZero >> boolean             % is top value zero?
   0:     oValueMatch >> boolean            % are top two values the same?
   0:     oValuePop;
      
      % keep different patch stacks, each with a stack of position markers:
      
   0: type patchStack:
   0:     patchChoiceTableAddr    % addr where pointer to table is stored
   0:     patchChoiceTable        % build up choice table here (value,addr)
   0:     patchChoiceExit         % addrs where jumps at end of each option are
   0:     patchCall               % (addr,ident) where calls to undefined rules are
   0:     patchLoop               % addr of start of a loop
   0:     patchBreak;             % addrs where jumps out of a loop are
      
   0: mechanism patch:
   0:     oPatchMark(patchStack)             % mark current position on a stack
   0:     oPatchAtMark(patchStack) >> boolean     % true if all items since
                                                 %   last mark are popped
                                                 %   (mark is dropped if true)
   0:     oPatchPushHere(patchStack)         % put current address on a patch stack
   0:     oPatchPushIdent(patchStack)        % put last ident on a patch stack
   0:     oPatchPushValue(patchStack)        % push value on value stack
   0:     oPatchAnyEntries(patchStack) >> boolean    % are there any entries?
   0:     oPatchPopFwd(patchStack)           % fix table, storing here-x at x,
                                             %   where x is on top of the stack
   0:     oPatchPopBack(patchStack)          % emit here-x here (advance 'here')
   0:     oPatchPopValue(patchStack)         % emit x here (advance 'here')
   0:     oPatchPopCall(patchStack);         % fix table, storing value of ident i
                                             %   at x, where i is on top of stack
                                             %   and x is under it  (pop both)
   0: mechanism shortForm:    % keep a table of string shortforms for input/output
   0:     oShortFormAdd       % associate current StrLit token with nDeclaration on node stack
   0:     oShortFormLookup;   % look up strLit, push associated nDeclaration on node stack
      
   0: mechanism titleMech:
   0:     oTitleSet;          % define title to be strlit just read
      
   0: mechanism doc:         % display documentary info
   0:     oDocNewRule         % print "Rule <token>"
   0:     oDocCheckpoint;     % display current pc value, for debugging
      
   0: mechanism include_mech:
   0:     oInclude;           % include the SSL file whose name is in the
                             % string token just accepted
      
   0: mechanism node_mech:
   0:     oNodeNew (node_type)               % create new node, push on node stack
   0:     oNodeNewValue                      % like oNodeNew, take node type from value stack
   0:     oNodeLink (node_attribute)         % link Node attribute of 2nd node to top node, pop
   0:     oNodeLinkUnder1 (node_attribute)   % link Node attribute of top node to 2nd node (top-1)
   0:     oNodeSetValue (node_attribute)     % set int attribute of node from value stack no pop
   0:     oNodeSetIdent (node_attribute)     % set attribute of node with id# of last accepted id
   0:     oNodeAppend (node_attribute)       % append top node to list attr of 2nd node
   0:     oNodeAppendNode                    % append top node to list starting with 2nd node
   0:     oNodeGet (node_attribute)          % push Node attribute on stack
   0:     oNodeGetValue (node_attribute)     % push int attribute on value stack
   0:     oNodeNull >> boolean               % is top node null (pop if it is)
   0:     oNodePushNull                      % push null on stack
   0:     oNodeNext                          % replace top node with next in list
   0:     oNodeIsA (node_type) >> boolean    % return true if top node IsA <class>
   0:     oNodeChooseType >> node_type       % return node type of top node in stack
   0:     oNodeGetType                       % push node type of top node onto value stack
   0:     oNodeCompareExact >> boolean       % compare top two nodes for equality
                                             % Return true only if both are the same node
   0:     oNodeCompareExactUnder2 >> boolean % compare node on stack with node 2 under it
                                             % Return true only if both are the same node
   0:     oNodeSwap
   0:     oNodePop
      
          % Some global variables
      
   0:     oNodeGetIntType                    % Get nType node for system type "int"
   0:     ;
      
   0: mechanism rule_mech:
   0:     oRuleSetCurrentRule                % Global variable to hold current rule node
   0:     oRuleGetCurrentRule
      
   0:     oRuleSetNumLocals(number)          % set counter of #locals in rule
   0:     oRuleIncNumLocals                  % inc #locals_in_rule counter
   0:     oRuleGetNumLocals                  % push #locals_in_rule counter on value stack
   0:     oRuleSetLocalSpaceAddr             % set location of .iLocalSpace argument to patch
   0:     oRulePatchLocalSpace               % patch rule's .iLocalSpace argument with #locals_in_rule
      
   0:     oSetNumGlobals(number)    % set counter of #globals in program
   0:     oIncNumGlobals
   0:     oGetNumGlobals            % to value stack
   0:     oSetGlobalSpaceAddr       % similar to locals.  Program starts with .iGlobalSpace(n) for globals on stack
   0:     oPatchGlobalSpace
   0:     ;
      
   0: mechanism scope_mech:
   0:     oScopeBegin                        % create a new scope.  Subsequent declarations will go here.
                                             % Pushes nScope on node stack.  Sets nScope's qParent to parent scope.
   0:     oScopeOpen                         % Open an existing scope, whose nScope node is on node stack.
                                             % The nScope should have been previously created by oScopeBegin.
                                             % (Once the scope is opened, its definitions become visible again)
   0:     oScopeEnd                          % End current scope.  Subsequent declarations will go to parent scope.
                                             % Does not remove nScope from node stack
   0:     oScopeDeclare                      % Add top node to declaration list of current scope.  Pop node.
   0:     oScopeDeclareKeep                  % Like oScopeDeclare, but keep node on stack.
      
   0:     oScopeFind >> boolean              % Find declaration of last accepted identifier.
                                             % Push on stack if found.
   0:     oScopeFindRequire                  % Find declaration of last accepted identifier.
                                             % Go into error recovery if not found.
   0:     ;
      
      
   0: mechanism install_mech:
   0:     oInstallSystemOperations
   0:     oInstallSystemTypes;
      
   0: mechanism write_mech:
   0:     oWriteTables;
      
   0: rules
      
      
   0: ProcessSSL:
      
   0:     oScopeBegin
      
   1:     oCountPush (zero) oNextErrorPopCount     % error #
      
   5:     oCountPush (zero)
   8:     oInstallSystemOperations
   9:     oInstallSystemTypes
      
  10:     oSetNumGlobals(zero)           % Count global variables
  13:     .iGlobalSpace                  % Make space for global variables
  15:     oSetGlobalSpaceAddr .iSpace
      
      
  18:     {[ Section
  22:         | true:
  22:         | *:  >
  29:     ]}
      
  31:     @FixForwardCalls
  33:     oCountPop
      
  34:     oIncNumGlobals   % increase because globals addressed from 1 (addr 0 unused)
  35:     oPatchGlobalSpace
      
  36:     oScopeEnd
      
  37:     oWriteTables
  38:     oNodePop   % global nScope
  39:     ;
      
      
      % Returns true if a section found
      
  40: Section >> boolean:
      
  40:     [
  42:         | pTitle:      @Title
  44:         | pInput:      @Input
  48:         | pOutput:     @Output
  52:         | pError:      @Error
  56:         | pType:       @Type
  60:         | pInclude:    @Include
  64:         | pMechanism:  @Mechanism
  68:         | pRules:      @Rules
      
  72:         | pEof:        >> false      % end of file
  77:     ]
  99:     >> true
 102:     ;
      
      % ------------------------- Sections -------------------------
      
 103: Title:
 103:     ':' pStrLit oTitleSet ';' ;
      
 111: Input:
 111:     ':' oValuePushNodeType (nInput)
 116:         oCountPush(zero)
 119:     @ValueList_StringAliasAllowed
 121:         oCountPop oValuePop
 123:     ';' ;
      
 126: Output:
 126:     ':' oValuePushNodeType (nOutput)
 131:         oCountPush(zero)
 134:     @ValueList_StringAliasAllowed
 136:         oCountPop oValuePop
 138:     ';' ;
      
 141: Error:
 141:     ':' oValuePushNodeType (nError)
 146:         oNextErrorPushCount
 147:     @ValueList
 149:         oNextErrorPopCount oValuePop
 151:     ';' ;
      
 154: Type:
 154:     pIdent
 156:         oNodeNew (nType)  oNodeSetIdent (qIdent)
 162:         oScopeDeclareKeep     % Leave nType on stack to assign type in ValueList_AssignType
 163:         oValuePushNodeType (nValue)
 166:         oCountPush (zero)
 169:     ':'
 171:     @ValueList_AssignType
 173:         oCountPop oValuePop
 175:         oNodePop       % Pop nType
 176:     ';' ;
      
 179: Include:
 179:     pStrLit oInclude;
      
 183: Mechanism:
 183:     pIdent
 185:         oNodeNew (nMechanism)  oNodeSetIdent(qIdent)  oScopeDeclare
 192:     ':'
 194:     {[ OperationDefinition
 198:         | true:
 198:         | *:  >
 205:     ]}
 207:     ';' ;
      
 210: Rules:
 210:     {[ RuleSectionDefinition
 214:         | true:
 214:         | *:  >
 221:     ]}
 223:     pEnd ;
      
      
      % ------------------------- Value Lists ----------------------
      
 226: ValueList_StringAliasAllowed:
 226:     {[
 228:         | pIdent:
 228:             oNodeNewValue  oNodeSetIdent(qIdent)
 232:             [ | pStrLit:  oShortFormAdd   % Associate short form with declaration
 235:               |*:
 240:             ]
 240:             [ | '=':
 242:                 @IntConst  oCountPop  oCountPushValue  oValuePop
 247:               |*:
 252:             ]
 252:             oValuePushCount oNodeSetValue(qValue) oValuePop
 257:             oScopeDeclare
 258:             oCountInc
 259:         | *:  >
 266:     ]} ;
      
 269: ValueList:
 269:     {[
 271:         | pIdent:
 271:             oNodeNewValue  oNodeSetIdent(qIdent)
 275:             [ | '=':
 277:                 @IntConst  oCountPop  oCountPushValue  oValuePop
 282:               |*:
 287:             ]
 287:             oValuePushCount oNodeSetValue(qValue) oValuePop
 292:             oScopeDeclare
 293:             oCountInc
 294:         | *:  >
 301:     ]} ;
      
      %  nType is on object stack
      
 304: ValueList_AssignType:
 304:     {[
 306:         | pIdent:
 306:             oNodeNewValue  oNodeSetIdent(qIdent)
 310:             oNodeLinkUnder1 (qType)
 313:             [ | '=':
      
                      % Value may be specified as an int value, or as another
                      % value of the current type
      
 315:                 @Const  oCountPop  oCountPushValue  oValuePop
      
                      % Require const to be type "int" or same type as current type
 320:                 [ MatchIntType
 324:                     | true :
 324:                     | false :    @RequireMatchTypeUnder2
 328:                 ]
 336:                 oNodePop    % nType of constant
      
 337:               |*:
 342:             ]
 342:             oValuePushCount oNodeSetValue(qValue) oValuePop
 347:             oScopeDeclare
 348:             oCountInc
 349:         | *:  >
 356:     ]} ;
      
      
      % ------------------------- Variables ------------------------
      
      %  Declare a list of global variables.
      %  nType is on stack
      
 359: DeclareGlobals:
 359:     {
 359:         pIdent
 361:         oNodeNew(nGlobal)  oNodeSetIdent(qIdent)
 367:         oNodeLinkUnder1 (qType)
      
              % Assign address to local variable
 370:         oIncNumGlobals
 371:         oGetNumGlobals oNodeSetValue(qAddr)  oValuePop
      
 376:         oScopeDeclare
      
 377:         [ | ',' :
 379:           | * :   >
 386:         ]
 386:     }
 388:     ;
      
      %  Declare a list of local variables.
      %  nType is on stack
      
 389: DeclareLocals:
 389:     {
 389:         pIdent
 391:         oNodeNew(nLocal)  oNodeSetIdent(qIdent)
 397:         oNodeLinkUnder1 (qType)
      
              % Assign address to local variable
 400:         oRuleIncNumLocals
 401:         oRuleGetNumLocals  oNodeSetValue(qAddr)  oValuePop
      
 406:         oScopeDeclare
      
 407:         [ | ',' :
 409:           | * :   >
 416:         ]
 416:     }
 418:     ;
      
      
      %  Defines formal parameters (if any) in current scope.
      %  The caller should have called oScopeBegin to begin a
      %  scope just for parameters.  (This gives a simple way
      %  to check if an operation/rule has parameters).
      
      %  Leaves nScope on stack, (does not end the scope).
      %  nParam's may be named or unnamed (qIdent == 0)
      
      %  Parameters are assigned addresses in reverse order
      %  from n to 1.  This is for efficient stack access.
      %  E.g. func(a,b,c):  address of a:3, b:2, c:1
      %
      %  (Later I would like to instead push actuals in reverse order)
      
 419: FormalParamDefinition:
      
 419:     [ | '(' :
 421:       | *   : >>
 427:     ]
      
 427:     oCountPush (zero)   % Count the parameters, to assign addresses
      
 430:     {
 430:         oCountInc
      
              % parameter direction
 431:         [
 433:             | pIn :     oValuePushNodeType (nInParam)
 436:             | pOut :    oValuePushNodeType (nOutParam)
 441:             | pInOut :  oValuePushNodeType (nInOutParam)
 446:             | * :       oValuePushNodeType (nInParam)
 458:         ]
      
              % parameter type
 458:         pIdent  @LookupType
      
 462:         oNodeNewValue   oValuePop     % nParam
 464:         oNodeLinkUnder1 (qType)
      
              % parameter name
 467:         [
 469:             | pIdent :  oNodeSetIdent (qIdent)   % named parameter
 472:             | * :       % unnamed parameter
 477:         ]
      
              % To do: assign an address (qAddr)
      
 477:         oScopeDeclare       % declare nParam
 478:         oNodePop            % pop nType
      
 479:         [
 481:             | ',' :
 481:             | * :   >
 488:         ]
 488:     }
      
 490:     ')'
      
          %  Now go back and assign addresses to the parameters
      
 492:     oNodeGet (qDecls)
      
 495:     {
 495:         [ oCountZero
 498:             | true:  >
 500:             | false:
 502:         ]
      
 510:         oValuePushCount oNodeSetValue(qAddr) oValuePop
      
 515:         oCountDec
 516:         oNodeNext
 517:     }
 519:     oNodePop % Null at end of param list
 520:     oCountPop
      
 521:     ;
      
      %  Redefine formal parameters during declaration of actual rule (with body).
      %  Previously, parameters were declared by a forward declaration or by usage.
      %  Ensure that types match.  Update parameter names to new names given.
      %  (All parameters must be named since this will be the final declaration).
      %
      %  Previous parameter nScope is on stack and scope has been opened.
      %  (Addresses were assigned previously, no need to do it again).
      %
      %  NOTE, previous params may not have been named, or may have been given
      %  different names.  So, we must be cautious in doing oScopeFind's
      %  (i.e. we can lookup type names, but not variable names since they may
      %  match previous names for parameters).
      
 522: FormalParamRedefinition:
      
 522:     oNodeGet (qDecls)  % Get previous list of parameters
      
 525:     [ | '(' :
 527:       | *   : [ oNodeNull
 535:                   | true :
 535:                   | * :   oNodePop #eParameterMismatch
 543:               ]
 543:               >>
 544:     ]
      
 544:     {
 544:         [ oNodeNull
 547:             | true :    #eParameterMismatch  % too many params given this time
 549:             | false :
 551:         ]
      
              % previous direction
 559:         oNodeGetType
              % parameter direction
 560:         [
 562:             | pIn :     oValuePushNodeType (nInParam)
 565:             | pOut :    oValuePushNodeType (nOutParam)
 570:             | pInOut :  oValuePushNodeType (nInOutParam)
 575:             | * :       oValuePushNodeType (nInParam)
 587:         ]
 587:         [ oValueMatch
 590:             | true :    oValuePop oValuePop
 592:             | * :       oValuePop oValuePop #eParameterMismatch
 601:         ]
      
              % previous type
 601:         oNodeGet (qType)
              % parameter type
 604:         pIdent  @LookupType
 608:         @RequireMatchType
 610:         oNodePop oNodePop
      
              % parameter name
 612:         pIdent    oNodeSetIdent (qIdent)    % must be named
      
 617:         oNodeNext
      
 618:         [
 620:             | ',' :
 620:             | * :   >
 627:         ]
 627:     }
      
 629:     ')'
      
 631:     [ oNodeNull
 634:         | true :
 634:         | * :    oNodePop #eParameterMismatch   % Not enough params given this time
 642:     ]
 642:     ;
      
      
      % ------------------------- Operations -----------------------
      
      %  Returns true if definition found
      
 643: OperationDefinition >> boolean:
      
 643:     [
 645:         | pIdent:
 645:         | *:        >> false
 653:     ]
      
 653:     oNodeNew (nOperation)  oNodeSetIdent(qIdent)
 659:     oValuePushCount  oNodeSetValue (qValue)  oValuePop   % op# from counter
      
 664:     oCountInc
      
 665:     oScopeBegin    % parameter scope
      
 666:     @FormalParamDefinition
      
 668:     oNodeLink (qParamScope)
      
 671:     [ | '>>': pIdent  @LookupType
 677:               oNodeLink (qType)
 680:       |*:     %  qType and qParamType are NULL by default
 685:     ]
      
 685:     oScopeEnd      % parameter scope
      
 686:     oScopeDeclare  % declare operation
      
 687:     >> true
 690:     ;
      
      % ------------------------- Rules ----------------------------
      
      %  Start a definition in the rules secition.
      %  This could be:
      %      a rule definition, a rule prototype, or a global variable definition.
      %  Returns true if one of the above found
      
 691: RuleSectionDefinition >> boolean:
 691:     [
 693:         | pIdent:
 693:         | * :        >> false
 701:     ]
      
 701:     [ oScopeFind
 704:         | false:     @RuleDefinition
 706:         | true:
 708:             [ oNodeChooseType
 711:                 | nType :  @DeclareGlobals   oNodePop
 714:                 | nRule :  @RuleRedefinition    % Should be body of fwd declared rule
 718:                 | * :      oNodePop #eNotRuleOrGlobalDefn  >> true  % True to skip to next
 731:             ]
 731:     ]
      
 739:     >> true
 742:     ;
      
      %   Define the parameters, and possibly the body, of a rule
      %   that has not been defined previously.
      %   Just parsed ident of rule.
      
 743: RuleDefinition:
      
 743:     oDocNewRule
      
 744:     oNodeNew (nRule)  oNodeSetIdent(qIdent)  oRuleSetCurrentRule
      
      
 751:     oScopeBegin                % param scope
 752:     @FormalParamDefinition
 754:     oNodeLink (qParamScope)    % leave scope open, to access params during rule
      
 757:     [ | '>>':
 759:           pIdent  @LookupType  oNodeLink (qType)
 766:       | * :
 771:     ]
      
 771:     [
 773:         | ':' :  @RuleBodyDefinition
 775:         | * :    % No body; a forward declaration of the rule.
 780:     ]
 780:     ';'
      
 782:     oScopeEnd            % parameters scope (already linked to nRule above)
      
 783:     oScopeDeclare        % declare nRule
                               % (Note, can't call rule recursively
                               % since not defined until end)
 784:     ;
      
 785: RuleBodyDefinition:
      
          % Address of rule is now defined
 785:     oValuePushHere  oNodeSetValue (qValue)  oValuePop
 790:     oValuePushBoolean (yes)  oNodeSetValue (qAddrDefined) oValuePop
      
 797:     oScopeBegin       % rule variables scope
      
 798:     oRuleSetNumLocals(zero)    % count local vars, to assign addresses and make space for them
 801:     .iLocalSpace 
 803:     oRuleSetLocalSpaceAddr .iSpace
      
 806:     {[ Statement
 810:         | true:
 810:         | *:  >
 817:     ]}
      
 819:     .iReturn
      
 821:     oRulePatchLocalSpace
      
      
 822:     oScopeEnd            % rule variables scope
 823:     oNodeLink (qScope)
      
 826:     ;
      
      
      %   Redefine a rule (to provide body of a forward-declared rule).
      %   The existing nRule declaration is on the stack.
      
 827: RuleRedefinition:
      
 827:     oNodeGetValue(qAddrDefined)
 830:     [ oValueChooseBoolean
 833:         | yes :   #eRuleBodyAlreadyDeclared
 835:         | * :
 840:     ]
 840:     oValuePop
      
 841:     oDocNewRule
      
 842:     oRuleSetCurrentRule
      
 843:     oNodeGet (qParamScope)   oScopeOpen    % Make the existing param scope visible
      
 847:     @FormalParamRedefinition   % verify types, update param names
      
 849:     oNodePop   % nScope of params
      
          % Verify return type matches previous declaration/usage
 850:     oNodeGet (qType)
 853:     [ | '>>':
 855:           pIdent  @LookupType  @RequireMatchType oNodePop oNodePop
 863:       | * :   [ oNodeNull
 871:                   | true :
 871:                   | * :     oNodePop #eReturnTypeMismatch
 879:               ]
 879:     ]
      
 879:     ':'
 881:     @RuleBodyDefinition
 883:     ';'
      
 885:     oScopeEnd            % parameters scope (already linked to nRule)
      
 886:     oNodePop             % nRule (already declared)
 887:     ;
      
      % ------------------------- Statements -----------------------
      
      %  Returns true if statement found
      
 888: Statement >> boolean:
      
 888:     [
 890:         | pStrLit:           % input alias
 890:             oShortFormLookup @RequireInput
 893:             .iInput @EmitValue oNodePop
      
 898:         | pIdent:            % input or operation
 900:             oScopeFindRequire
 901:             [ oNodeChooseType
      
 904:                 | nInput:      .iInput @EmitValue  oNodePop
      
 909:                 | nOperation:  @RequireNoType @CallOperation   oNodePop
      
 916:                 | nType:       @DeclareLocals     oNodePop
      
 921:                 | *:           @Assignment    % pops identifier
 932:             ]
      
 932: 	| '#':
 934:             pIdent  @LookupError
 938:             .iError @EmitValue  oNodePop
      
 943: 	| '.':
 945: 	    [ | pIdent:    @LookupOutput
 949:               | pStrLit:   oShortFormLookup @RequireOutput
 954:             ]
 962:             .iEmit @EmitValue  oNodePop
      
 967: 	| '@':
 969: 	    pIdent
 971:             [ oScopeFind
 974:                 | true :
 974:                     @RequireRule  @RequireNoType
 978:                     @CallRule
 980:                     oNodePop
      
 981:                 | false :
 983:                     @CallUndefinedRule
 985:             ]
      
 993: 	| '>>':
 995:             oRuleGetCurrentRule   % ugh.  To check return type of current rule.
 996:             oNodeGet (qType)
 999: 	    [ oNodeNull
1002:                 | true :
1002:                 | * :
1007:                     @Expr  @RequireMatchType
1011:                     oNodePop   % type of expr
1012:                     oNodePop   % type of rule
      
1013:             ]
1013:             oNodePop   % current nRule
1014:             .iReturn
      
1016: 	| '{':
1018:             oPatchPushHere (patchLoop)
1021:             oPatchMark (patchBreak)
1024: 	    {[ Statement
1028: 		| true:
1028: 		| *:  >
1035: 	    ]}
1037: 	    '}'
1039:             .iJumpBack
1041:             oPatchPopBack (patchLoop)
      
                  % Fix up break statements
1044:             {[ oPatchAtMark (patchBreak)
1049:                 | false :    oPatchPopFwd (patchBreak)
1052:                 | * :        >
1059:             ]}
      
1061: 	| '>':
1063:             [ oPatchAnyEntries (patchLoop)
1068:                 | false:  #eNotInLoop
1070:                 | *:
1075:             ]
1075:             .iJumpForward  oPatchPushHere (patchBreak)  .iSpace
      
1082: 	| '?':  .iInputAny
      
1086: 	| '[':  @Choice
      
1090:         | *:    >> false    % Not a statement
1116:     ]
1116:     >> true ;
      
      
      %  Called with nOperation on stack
      
1120: CallOperation:
1120:     @ActualParams     % pushes #params on value stack
      
1122:     @EmitValue        % call operation
      
1124:     [ oValueZero
1127:         | true :
1127:         | false :     .iPop .iConstant
1133:     ]
1141:     oValuePop
1142:     ;
      
      
      %  Called with nOperation or nRule on stack
      %  Pushes number of parameters on value stack
      
1143: ActualParams:
      
1143:     oNodeGet (qParamScope)    % nScope always present, but may be empty (no nParams)
1146:     oNodeGet (qDecls)         % first nParam
      
1149:     [ oNodeNull
      
1152:         | true :    oValuePush (zero)   oNodePop  >>
1157:         | false :
1159:     ]
      
1167:     oCountPush (zero)
      
1170:     '('
      
1172:     {
1172:         oCountInc
      
              %  ----------------------------
      
              %  One actual parameter.  Formal nParam is on stack.
      
1173:         [ oNodeChooseType
1176:             | nInParam :
1176:                 oNodeGet (qType)   % type of formal param
1179:                 @Expr              % type of actual param to stack
      
1181:             | nOutParam, nInOutParam :
1183:                 oNodeGet (qType)   % type of formal param
1186:                 @Lvalue            % type (pointed to by lvalue) to stack
1188:         ]
1198:         @RequireMatchType
1200:         .iPushResult
      
1202:         oNodePop oNodePop  % actual param type, formal param type
      
              %  ----------------------------
      
1204:         oNodeNext
      
1205:         [ oNodeNull
1208:             | true :   >
1210:             | false :
1212:         ]
      
1220:         ','
1222:     }
      
1224:     ')'
      
1226:     oNodePop    % param nScope
1227:     oValuePushCount oCountPop
1229:     ;
      
      
      
      %  Called for a nRule whose parameter types are defined.
      %  The rule address might not yet be known.
      %  Called with nRule on stack
      
1230: CallRule:
1230:     @ActualParams      % pushes #params on value stack
      
1232:     oNodeGetValue (qAddrDefined)     % A call to a forward-declared rule?
1235:     [ oValueChooseBoolean
1238:         | yes :        .iCall @EmitValue
1242:         | no :         .iCall oPatchPushHere(patchCall) 
1249:                               oNodeGetValue(qIdent) oPatchPushValue(patchCall) oValuePop
1256:                               .iSpace
1258:     ]
1266:     oValuePop
      
          % Pop actual params
1267:     [ oValueZero
1270:         | true :
1270:         | false :     .iPop .iConstant
1276:     ]
1284:     oValuePop
1285:     ;
      
      %  Implicitly declare a rule that has not previously been declared.
      %  Rule name is last accepted identifier.
      %  NOTE, for now, I just don't declare it. This means we don't get
      %  consistency checking.
      %  Note, should implicitly declare InParam's based on types observed,
      %  but for now I don't bother and it's not supported.
      %  User may define a forward decl to make this work though.
       
1286: CallUndefinedRule:
1286:     .iCall
1288:     oPatchPushHere (patchCall)
1291:     oPatchPushIdent (patchCall)
1294:     .iSpace
      
1296:     [ | '(' :  #eUndeclRuleParamsNotSupported
1300:       | *:
1305:     ]
1305:     ;
      
      
      %  Already parsed pIdent and determined it is not a rule/type/operation.
      %  nDeclaration is on stack.  Will be replaced with lvalue type.
      
1306: Assignment:
1306:     @Lvalue_HaveIdent     % replaces ident on stack with type referenced by lvalue
1308:     .iPushResult
1310:     '='
1312:     @Expr  @RequireMatchType
1316:     oNodePop  oNodePop    % rvalue type, lvalue type
1318:     .iAssign
1320:     ;
      
1321: Choice:
          %  Determine if this is an input choice or a value choice.
          %  Push flag on value stack indicating which of the above cases this is.
          %  Push type of value choice on node stack (or Null if not known yet)
      
1321:     [
1323:         | '|' :
1323:             .iInputChoice   oValuePushKind (kInput)   % flag that this is an input choice
      
1328:             oNodePushNull   % dummy to hold place of choice nType
      
1329:         | * :
1334:             @Expr  .iChoice
      
                  % Expr indicates forward use of undefined rule by returning expr type NULL
                  % We will indicate this for ourselves by pushing value kUnknown
      
1338:             [ oNodeNull
1341:                 | true :    oNodePushNull    % keep Null type on stack for now
1342:                             oValuePushKind (kUnknown)
1345:                 | false:    oValuePushKind (kType)  % flag that choice is typed
1350:             ]
      
1358:             '|'
1360:     ]
      
1360:     oPatchPushHere (patchChoiceTableAddr)
1363:     .iSpace
      
1365:     oPatchMark (patchChoiceTable)    % build up choice table in this stack
1368:     oPatchMark (patchChoiceExit)     % remember end of each option
1371:     oCountPush (zero)                % count options
      
1374:     {
1374:         [
1376:             | '*':     % default code (must be last option)
1376:                 ':'
1378:                 @CopyChoiceTable
      
1380:                 {[ Statement
1384:                     | true :
1384:                     | *: >
1391: 	        ]}
1393:                 ']'
      
                      % Clean up
1395:                 oCountPop oValuePop
1397:                 oNodePop     % choice nType
      
1398:                 @FixChoiceExits
1400:                 >>
      
1401:             | * :
1406:                 {
1406:                     [ oValueChooseKind   % kind of choice statement
      
1409:                         | kType :         % rule/op choice
1409:                             @Const        % constant value to value stack, nType to node stack
1411:                             @RequireMatchType
1413:                             oNodePop      % type of constant
      
1414:                         | kUnknown :      % rule choice, rule type not known yet
      
                                  % Change flag to indicate the choice will be typed now
1416:                             oValuePop oValuePushKind (kType)
      
                                  % Get constant value on value stack,
                                  % and replace dummy nType with nType of constant.
      
1420:                             oNodePop     % dummy nType
1421:                             @Const       % get constant in value stack, type on node stack
      
                                  % NOTE: now that we know type of forward rule, we could update nRule
      
1423:                         | kInput :        % input choice
1425:                             [ | pIdent :  @LookupInput
1429:                               | pStrLit : oShortFormLookup @RequireInput
1434:                             ]
1442:                             oNodeGetValue (qValue)
1445:                             oNodePop
1446:                     ]
      
                          % value of option is now on value stack
      
1456:                     oPatchPushHere (patchChoiceTable)
1459:                     oPatchPushValue (patchChoiceTable)
1462:                     oValuePop  oCountInc
      
1464:                     [
1466:                         | ':' :   >
1468:                         | ',' :
1470:                     ]
1478:                 }
1480:         ]
      
              % Code for this option:
      
1480:         {[ Statement
1484:             | true:
1484:             | *:  >
1491:         ]}
      
1493:         [
1495:             | ']' :     % end of choice, no default
1495:                 .iJumpForward
1497:                 oPatchPushHere (patchChoiceExit) .iSpace
1502:                 @CopyChoiceTable
      
                      % Clean up
1504:                 oCountPop oValuePop
1506:                 oNodePop     % choice nType
      
1507:                 .iEndChoice
      
1509:                 @FixChoiceExits
1511:                 >>
      
1512:             | '|' :     % more options follow
1514:                 .iJumpForward
1516:                 oPatchPushHere (patchChoiceExit) .iSpace
1521:         ]
1529:     };
      
      
      %  Install choice table here.
      %  #options is in the top counter.
      %  Order of options is opposite that in the source (note for error recovery)
      
1532: CopyChoiceTable:
1532:     oPatchPopFwd (patchChoiceTableAddr)    % fix pointer to table
1535:     oValuePushCount  .iConstant  oValuePop       % # entries
1539:     {[ oPatchAtMark (patchChoiceTable)
1544:         | false :
1544:             oPatchPopValue (patchChoiceTable)
1547:             oPatchPopBack (patchChoiceTable)
1550:         | * :   >
1557:     ]};
          
      % Fix jumps from end of each option to end of choice
      
1560: FixChoiceExits:
1560:     {[ oPatchAtMark (patchChoiceExit)
1565:         | false:    oPatchPopFwd (patchChoiceExit)
1568:         | *:        >
1575:     ]};
      
1578: FixForwardCalls:
1578:     {[ oPatchAnyEntries (patchCall)
1583:         | true :    oPatchPopCall (patchCall)
1586:         | * :       >
1593:     ]};
      
      %  ------------------------------------------------------- 
      
      %  Emits code for expression (with result in ssl_result).
      %  Leaves nType of expression on node stack.
      
1596: Expr:
1596:     [
1598:         | pIdent :
      
1598:             [ oScopeFind
1601:                 | true :
1601:                     [ oNodeChooseType
1604:                         | nRule :        oWarning(wRuleMissingAtSign) @CallRule
1609:                         | nOperation :   @CallOperation
1613:                         | nValue :       .iSetResult @EmitValue
1619:                         | nInParam :     .iGetParam  @EmitAddr
1625:                         | nOutParam :    .iGetFromParam @EmitAddr
1631:                         | nInOutParam :  .iGetFromParam @EmitAddr
1637:                         | nLocal :       .iGetLocal @EmitAddr
1643:                         | nGlobal :      .iGetGlobal @EmitAddr
1649:                         | * : #eIdentNotAllowedInExpr
1670:                     ]
1670:                     oNodeGet (qType)         % Get type of identifier
1673:                     oNodeSwap oNodePop       % Pop identifier, leaving its type
      
1675:                     [ oNodeNull
1678:                         | true:  oNodePushNull  #eNotTyped   % e.g. call with no return value
1681:                         | * :
1686:                     ]
      
1686:                 | false :
1688:                     oNodePushNull  #eUndefinedIdentifier
1691:             ]
      
1699:         | '@' :
1701: 	    pIdent
1703:             [ oScopeFind
1706:                 | true :
1706:                     @RequireRule
1708:                     @CallRule
1710:                     oNodeGet (qType) oNodeSwap oNodePop  % type of rule
1715:                     [ oNodeNull
1718:                         | true:  oNodePushNull  #eNotTyped   % e.g. call with no return value
1721:                         | * :
1726:                     ]
      
1726:                 | false :
                          % Call before defined.  Limited use in this case.
                          % The nType pushed will be NULL.  We don't know the real type.
                          % This is really just allowed so we can have simple rules in a Choice expression.
      
1728:                     @CallUndefinedRule
1730:                     oNodePushNull
1731:             ]
      
1739:         | '-' :
1741:             pIntLit
1743:             .iSetResult oValuePushIntLit oValueNegate .iConstant oValuePop
1750:             oNodeGetIntType
1751:         | pIntLit :
1753:             .iSetResult oValuePushIntLit .iConstant oValuePop
1759:             oNodeGetIntType
1760:     ];
      
      %  Emits code for lvalue (putting address of variable in ssl_result).
      %  Leaves nType of the referenced value on node stack.
      
1773: Lvalue:
1773:     [
1775:         | pIdent :
      
1775:             [ oScopeFind
1778:                 | true :
1778:                     @Lvalue_HaveIdent
      
1780:                 | false :   % a forward use of rule, illegal as lvalue
1782:                     oNodePushNull #eIllegalLvalue
1785:             ]
      
1793:         | '-' :   pIntLit     oNodePushNull #eIllegalLvalue
1800:         | pIntLit :           oNodePushNull #eIllegalLvalue
1805:     ];
      
      %  Emit code for lvalue, given nDeclaration of identifier on stack.
      %  Replace ident nDeclaration on stack, with the lvalue's nType
      
1816: Lvalue_HaveIdent:
1816:     [ oNodeChooseType
1819:         | nInParam :     .iGetAddrParam  @EmitAddr
1823:         | nOutParam :    .iGetParam      @EmitAddr
1829:         | nInOutParam :  .iGetParam      @EmitAddr
1835:         | nLocal :       .iGetAddrLocal  @EmitAddr
1841:         | nGlobal :      .iGetAddrGlobal @EmitAddr
1847:         | * : #eIllegalLvalue
1862:     ]
1862:     oNodeGet (qType)         % Get type of identifier
1865:     oNodeSwap oNodePop       % Pop identifier, leaving its type
1867:     ;
      
      %  Get constant value onto value stack.
      %  Push nType of value onto node stack.
      %  NOTE: Does not emit any code.
      
1868: Const:
1868:     [
1870:         | pIdent :
1870:             @LookupValue
1872:             oNodeGetValue (qValue)
1875:             oNodeGet (qType)
1878:             oNodeSwap oNodePop    % pop nValue, leave nType
1880:         | '-' :
1882:             pIntLit oValuePushIntLit oValueNegate
1886:             oNodeGetIntType
1887:         | pIntLit :
1889:             oValuePushIntLit
1890:             oNodeGetIntType
1891:     ];
      
      %  Return integer constant on value stack.
      %  Only values of type "int" are permitted.
      %  Leave node stack unchanged.
1902: IntConst:
1902:     @Const
1904:     oNodeGetIntType  @RequireMatchType  oNodePop
1908:     oNodePop;
      
      %  ------------------------------------------------------- 
      
      %  Assert that the ident we just read is a particular kind of
      %  identifier.  Also, leave the declaration node of the name
      %  on the node stack.
      
1910: LookupType:
1910:     oScopeFindRequire
1911:     @RequireType;
      
1914: LookupInput:
1914:     oScopeFindRequire
1915:     @RequireInput;
      
1918: LookupOutput:
1918:     oScopeFindRequire
1919:     @RequireOutput;
      
1922: LookupValue:
1922:     oScopeFindRequire
1923:     @RequireValue;
      
1926: LookupError:
1926:     oScopeFindRequire
1927:     @RequireError;
      
      %  Assert that current nDeclaration on node stack represents
      %  a particular kind of declaration.
      
1930: RequireType:
1930:     [ oNodeChooseType
1933:         | nType :
1933:         | * :    #eNotAType
1940:     ];
      
1941: RequireInput:
1941:     [ oNodeChooseType
1944:         | nInput :
1944:         | * :    #eNotInput
1951:     ];
      
1952: RequireOutput:
1952:     [ oNodeChooseType
1955:         | nOutput :
1955:         | * :    #eNotOutput
1962:     ];
      
1963: RequireValue:
1963:     [ oNodeChooseType
1966:         | nValue :
1966:         | * :    #eNotAValue
1973:     ];
      
1974: RequireError:
1974:     [ oNodeChooseType
1977:         | nError :
1977:         | * :    #eNotAnErrSig
1984:     ];
      
1985: RequireRule:
1985:     [ oNodeChooseType
1988:         | nRule :
1988:         | * :    #eNotARule
1995:     ];
      
      %  Require that rule/operation has no return type
      
1996: RequireNoType:
1996:     oNodeGet (qType)
1999:     [ oNodeNull
2002:         | false: #eChoiceOpRuleOutOfPlace  oNodePop
2005:         | * :
2010:     ];
      
      %  Given a value nDeclaration on stack, and nType under it.
      %  Ensure that the value symbol has the type nType.
      
2011: RequireMatchValueType:
2011:     oNodeGet (qType)    % Get value's type
2014:     [ oNodeCompareExactUnder2
2017:         | true :
2017:         | * :    #eWrongType
2024:     ]
2024:     oNodePop;
      
      
      %  Given a nType on stack and a nType under it,
      %  ensure that the types are the same.
      
2026: RequireMatchType:
2026:     [ oNodeCompareExact
2029:         | true :
2029:         | * :    #eWrongType
2036:     ];
      
      
      %  Given nType on stack, and nType two under it.
      
2037: RequireMatchTypeUnder2:
2037:     [ oNodeCompareExactUnder2
2040:         | true :
2040:         | * :    #eWrongType
2047:     ];
      
      %  Is the top node the nType of "int" type?
      
2048: MatchIntType >> boolean:
2048:     oNodeGetIntType
2049:     [ oNodeCompareExact
2052:         | true :  oNodePop  >> true
2056:         | * :     oNodePop  >> false
2065:     ];
      
      %  ------------------------------------------------------- 
      
      
      %  Emit the value of an identifier declaration, given its nDeclaration
      
2066: EmitValue:
2066:     oNodeGetValue(qValue) .iConstant oValuePop;
      
      %  Emit the addr of a variable, given its declaration
      
2073: EmitAddr:
2073:     oNodeGetValue(qAddr) .iConstant oValuePop;
      
2080: end
      
2080: 
