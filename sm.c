/*

  StackMachine.c

               This executes the intermediate t-code generated by
               my Pascal compiler.

  HISTORY
    21Sep89    1st version, runs test.pas
    24Sep89    Pointer instructions
    28Sep89    -dump will dump a readable t-code file
    01Jan90    read string literals into data segment

*/

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <assert.h>

#ifdef AMIGA
#include <dos.h>
#endif // AMIGA

#include "pascal.h"

FILE *src,*dmp;

#define codeMax 1000
short code[codeMax],pc;      /* Program memory */
short codeWords;             /* Actual #words used */

#define stackMax 200
short stack[stackMax],sp;    /* Call stack */

#define dataMax 400
short data[dataMax];         /* Data memory */

short temp, *ptr1, *ptr2;
char trace, underflow, dump;


// Forward declarations
void walkTable();
void dumpTable();
void hitBreak();
void fatal( char* msg );
void cleanup();


void
main(argc,argv)
int argc;
char *argv[];
{
  int temp;                /* I can't seem to read a 'short' */
  short arg;
  short address,count;

  trace = 0;

  /* Prepare Files */

  arg = 1;
  if (arg>=argc) {
    printf("Usage:  stackmachine -trace -underflow -dump <file>\n");
    exit(-1);
  }
  while (argv[arg][0]=='-') {
    if (argv[arg][1]=='t' || argv[arg][1]=='T')
      trace = 1;
    else if (argv[arg][1]=='u' || argv[arg][1]=='U')
      underflow = 1;
    else if (argv[arg][1]=='d' || argv[arg][1]=='D')
      dump = 1;
    arg++;
  }
  if((src=fopen(argv[arg],"r"))==NULL) {
    printf("Can't open program file %s\n",argv[arg]);
    exit(-1);
  }
  int read = fscanf(src,"%d",&temp);
  assert( read == 1 );
  codeWords = temp;
  if (codeWords >= codeMax) {
    printf("Program code too big for buffer\n");
    exit(-1);
  }
  printf("Stack Machine ");
  for (pc=0; pc<codeWords; pc++) {
    read = fscanf(src,"%d",&temp);
    assert( read == 1 );
    code[pc] = temp;
  } 

  /* Also get any string literals, and store in data segemnt */
  /* File format: <addr> <#words> <data words>               */

  while (fscanf(src,"%d",&temp) != EOF) {
    address = temp;
    read = fscanf(src,"%d",&temp);
    assert( read == 1 );
    count = temp;
    while (count--) {
      read = fscanf(src,"%d",&temp);
      assert( read == 1 );
      data[address++] = temp;
    }
  }

  fclose(src);
  printf("- program loaded (%d words)\n",codeWords);

#ifdef AMIGA
  onbreak(&hitBreak);
#endif // AMIGA

  if (dump) {
    dumpTable();
    exit(0);
  }

  /* Execute code */

  pc = 0;                        /* Initialize walker */
  sp = 0;

  walkTable();

  printf(".Done\n");
  cleanup();
}


void
walkTable()
{

   while (1) {

     if (trace) printf("[%d]",pc);
     if (underflow)
       if (sp<0) fatal("+++Stack Underflow+++");

     switch (code[pc++]) {

       case tPushIntVar :
              if (++sp>=stackMax) fatal("stack overflow");
              stack[sp] = data[code[pc++]];
              continue;
       case tPushBoolVar :
              if (++sp>=stackMax) fatal("stack overflow");
              stack[sp] = data[code[pc++]];
              continue;
       case tPushAddr :
              if (++sp>=stackMax) fatal("stack overflow");
              stack[sp] = code[pc++];
              continue;
       case tFetchInt :
              stack[sp] = data[stack[sp]];
              continue;
       case tFetchBool :
              stack[sp] = data[stack[sp]];
              continue;
       case tFetchPtr :
              stack[sp] = data[stack[sp]];
              continue;
       case tPushIntLit :
              if (++sp>=stackMax) fatal("stack overflow");
              stack[sp] = code[pc++];
              continue;
       case tAssignInt :
              data[stack[sp-1]] = stack[sp];
              sp -= 2;
              continue;
       case tAssignBool :
              data[stack[sp-1]] = stack[sp];
              sp -= 2;
              continue;
       case tAssignPtr :
              data[stack[sp-1]] = stack[sp];
              sp -= 2;
              continue;
       case tCopy :
              ptr1 = &data[stack[sp-1]];
              ptr2 = &data[stack[sp]];
              for (temp=0; temp<code[pc]; temp++)
                *ptr1++ = *ptr2++;
              sp -= 2;
              pc++;
              continue;
       case tIncIntVar :
              data[code[pc++]]++;
              continue;
       case tDecIntVar :
              data[code[pc++]]--;
              continue;
       case tMultiplyInt :
              stack[sp-1] *= stack[sp];
              sp--;
              continue;
       case tDivideInt :
              stack[sp-1] /= stack[sp];
              sp--;
              continue;
       case tAddInt :
              stack[sp-1] += stack[sp];
              sp--;
              continue;
       case tSubtractInt :
              stack[sp-1] -= stack[sp];
              sp--;
              continue;
       case tNegateInt :
              stack[sp] *= -1;
              continue;
       case tNot :
              stack[sp] = !stack[sp];
              continue;
       case tAnd :
              stack[sp-1] = stack[sp-1] && stack[sp];
              sp--;
              continue;
       case tOr :
              stack[sp-1] = stack[sp-1] || stack[sp];
              sp--;
              continue;
       case tEqualInt :
              stack[sp-1] = stack[sp-1] == stack[sp];
              sp--;
              continue;
       case tNotEqualInt :
              stack[sp-1] = stack[sp-1] != stack[sp];
              sp--;
              continue;
       case tGreaterInt :
              stack[sp-1] = stack[sp-1] > stack[sp];
              sp--;
              continue;
       case tLessInt :
              stack[sp-1] = stack[sp-1] < stack[sp];
              sp--;
              continue;
       case tGreaterEqualInt :
              stack[sp-1] = stack[sp-1] >= stack[sp];
              sp--;
              continue;
       case tLessEqualInt :
              stack[sp-1] = stack[sp-1] <= stack[sp];
              sp--;
              continue;
       case tEqualPtr :
              stack[sp-1] = stack[sp-1] == stack[sp];
              sp--;
              continue;
       case tNotEqualPtr :
              stack[sp-1] = stack[sp-1] != stack[sp];
              sp--;
              continue;
       case tCall :
              if (++sp==stackMax) fatal("call stack overflow");
              stack[sp] = pc+1;
              pc = code[pc];
              continue;
       case tReturn :
              if (sp) {
                pc = stack[sp--];
                continue;
              } else
                return;            /* done program table */
       case tJump :
              pc = code[pc];
              continue;
       case tJumpTrue :
              if (stack[sp--]) {
                pc = code[pc];
                continue;
              }
              pc++;
              continue;
       case tJumpFalse :
              if (!stack[sp--]) {
                pc = code[pc];
                continue;
              }
              pc++;
              continue;
       case tPutInt :
              printf("%d",stack[sp--]);
              continue;
       case tPutBool :
              printf(stack[sp--] ? "TRUE" : "FALSE");
              continue;
       case tPutStr :
              // SARICE 9/26/2021 - string literals are stored in the intermediate file
              //   as pairs of characters in a short, so have an endian problem.
              printf("%s",(char*)&data[stack[sp--]]);
              continue;
       case tPutPtr :
              printf(" <%d>",stack[sp--]);
              continue;
       case tPutCR :
              printf("\n");
              continue;

       default:
              pc--;
              fatal("bad instruction");
     } /* switch */
   }
}


#define op0(str) { fprintf(dmp,"%s\n",str); continue; }
#define op1(str) { fprintf(dmp,"%s\t%4d\n",str,code[pc++]); continue; }

void
dumpTable()
{
  if((dmp=fopen("a.dmp","w"))==NULL) {
    printf("Can't open dump file a.dmp\n");
    exit(5);
  }

   pc = 0;
   while (pc < codeWords) {
     fprintf(dmp,"%4d\t",pc);
     switch (code[pc++]) {
       case tPushIntVar :    op1("tPushIntVar");
       case tPushBoolVar :   op1("tPushBoolVar"); 
       case tPushAddr :      op1("tPushAddr");
       case tFetchInt :      op0("tFetchInt");
       case tFetchBool :     op0("tFetchBool");
       case tFetchPtr :      op0("tFetchPtr");
       case tPushIntLit :    op1("tPushIntLit");
       case tAssignInt :     op0("tAssignInt");
       case tAssignBool :    op0("tAssignBool");
       case tAssignPtr :     op0("tAssignPtr");
       case tCopy :          op1("tCopy   ");
       case tIncIntVar :     op1("tIncIntVar");
       case tDecIntVar :     op1("tDecIntVar");
       case tMultiplyInt :   op0("tMultiplyInt");
       case tDivideInt :     op0("tDivideInt");
       case tAddInt :        op0("tAddInt");
       case tSubtractInt :   op0("tSubtractInt");
       case tNegateInt :     op0("tNegateInt");
       case tNot :           op0("tNot");
       case tAnd :           op0("tAnd");
       case tOr :            op0("tOr");
       case tEqualInt :      op0("tEqualInt");
       case tNotEqualInt :   op0("tNotEqualInt");
       case tGreaterInt :    op0("tGreaterInt");
       case tLessInt :       op0("tLessInt");
       case tGreaterEqualInt : op0("tGreaterEqualInt");
       case tLessEqualInt :  op0("tLessEqualInt");
       case tEqualPtr :      op0("tEqualPtr");
       case tNotEqualPtr :   op0("tNotEqualPtr");
       case tCall :          op1("tCall   ");
       case tReturn :        op0("tReturn");
       case tJump :          op1("tJump   ");
       case tJumpTrue :      op1("tJumpTrue");
       case tJumpFalse :     op1("tJumpFalse");
       case tPutInt :        op0("tPutInt");
       case tPutBool :       op0("tPutBool");
       case tPutStr :        op0("tPutStr");
       case tPutPtr :        op0("tPutPtr");
       case tPutCR :         op0("tPutCR");
       default :             op0("???");
     }
   }
}


void
hitBreak()
{
  printf(".Breaking...\n");
  cleanup();
  //return(1);
  exit(1);
}


void
fatal( char* msg )
{
  printf(".FATAL - %s at %d\n",msg,pc);
  exit(5);
}


void
cleanup()
{
}

