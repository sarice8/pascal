      %  sccsid = "%W% %G% %U% %P%";
      
   2: title: 'SSL Translator 1.3.2 -- September 14 ''93';
      
      %
      % *****************************************************************************
      %
      %   Syntax/Semantic Language Compiler
      %
      %   by Steve Rice
      %
      %   Aug 31, 1989
      %
      % *****************************************************************************
      %
      %   ssl.ssl             SSL compiler
      %
      %   HISTORY
      % -----------------------------------------------------------------------------
      %   08/31/89 | Steve  | Translated from my SSL processor hardcoded in C
      %   09/08/89 |        | SSL processor now functional, except for error recovery
      %   10/18/89 |        | Added 'title' section
      %   02/03/90 |        | Change to ssl.c: Added debugger output
      %   03/20/91 |        | Change to ssl.c: Increased string table size
      %   03/26/91 |        | Fixed bug in handling of statement ">>value"
      %            |        | Fixed bug in handling of choice using a choice rule
      %            |        | defined later
      %   04/24/91 |        | Change to ssl.c: Increased identifier size to 50 chars
      %   05/05/91 |        | Change to ssl.c: Increased identifier table size to
      %            |        | 600, and moved names out of table. New limit 256 chars.
      %            |        | Added "include" feature.
      %   05/21/91 |        | Multiple "error" sections will use distinct error #'s
      %            |        | Added postprocess optimization: reduce chains of jumps
      %   06/04/91 |        | Change to ssl.c: Write rule addresses to code file
      %   08/23/93 |        | Fix some loops so error recovery can terminate
      %   08/25/93 |        | Reimplement using schema database for symbol table
      %   08/27/93 |        | Add new language features: local variables,
      %            |        | multiple parameters, inout parameters,
      %            |        | expressions with nested function calls.
      %            |        | (User program requires the 2.0 runtime model for new
      %            |        | instructions in generated code).
      %   08/29/93 |        | Reimplement compiler using above new language features
      %            |        | (typically using local variables rather than stacks)
      %   09/14/93 |        | Split into two passes: collect definitions, generate
      %            |        | code for rules.  So user is not required to provide
      %            |        | forward definitions for rules with out parameters.
      %            |        |
      % 
      % *****************************************************************************
      %
      
   2: input:
   2:     pIdent
   2:     pIntLit
   2:     pStrLit
   2:     pMinus      '-'
   2:     pEquals     '='
   2:     pColon      ':'
   2:     pSemiColon  ';'
   2:     pComma      ','
   2:     pLParen     '('
   2:     pRParen     ')'
   2:     pReturn     '>>'
   2:     pBreak      '>'
   2:     pLCurly     '{'
   2:     pRCurly     '}'
   2:     pLSquare    '['
   2:     pRSquare    ']'
   2:     pBar        '|'
   2:     pCall       '@'
   2:     pEmit       '.'
   2:     pStar       '*'
   2:     pErr        '#'
   2:     pQuestion   '?'
   2:     pEof
   2:     pInvalid
      
      %  keywords
      
   2:     pTitle
   2:     pInput
   2:     pOutput
   2:     pType
   2:     pError
   2:     pMechanism
   2:     pInclude
   2:     pRules
   2:     pEnd
   2:     pIn
   2:     pOut
   2:     pInOut
   2:     ;
      
      
   2: output:
      
      %  codes for SSL machine instructions
      
   2:     iJumpForward
   2:     iJumpBack
   2:     iInput
   2:     iInputAny
   2:     iEmit
   2:     iError
   2:     iInputChoice
   2:     iCall
   2:     iReturn
   2:     iSetResult
   2:     iChoice
   2:     iEndChoice
   2:     iPushResult      % push ssl_result on variable stack
   2:     iPop             % (n)  discard n entries from variable stack
   2:     iBreak           % instruction used by debugger
   2:     iGlobalSpace     % (n)  make space for n globals on variable stack (sets initial fp)
   2:     iLocalSpace      % (n)  make space for n locals on variable stack
   2:     iGetParam        % (n)  ssl_result = value of param n
   2:     iGetFromParam    % (n)  ssl_result = value of variable whose address is in param n
   2:     iGetLocal        % (n)  ssl_result = value of local var n
   2:     iGetGlobal       % (n)  ssl_result = value of global var n
   2:     iGetAddrParam    % (n)  ssl_result = addr of param n
   2:     iGetAddrLocal    % (n)  ssl_result = addr of local var n
   2:     iGetAddrGlobal   % (n)  ssl_result = addr of global var n
   2:     iAssign          % variable whose address is pushed on stack = ssl_result; pop stack
      
      %   NOTE: Any instructions added here should also be added to
      %         the system_operations table in ssl.c
      %         as well as optimize_table, list_generated_code.
      
      %  other output
      
   2:     iSpace;          % emit a dummy value; a value will be patched here later
      
   2: error:
   2:    eWrongType
   2:    eNotAType
   2:    eNotAValue
   2:    eNotInput
   2:    eNotOutput
   2:    eNotARule
   2:    eNotAnErrSig
   2:    eNotInLoop
   2:    eChoiceOpRuleOutOfPlace
   2:    eUndeclRuleParamsNotSupported
   2:    eNotTyped
   2:    eIdentNotAllowedInExpr
   2:    eIllegalLvalue
   2:    eNotRuleOrGlobalDefn
   2:    eRuleBodyAlreadyDeclared
   2:    eReturnTypeMismatch
   2:    eParameterMismatch
   2:    eUndeclaredIdentifier
   2:    eAliasNotAllowed
   2:    eCantInitGlobalVarsYet
   2:    ;
      
      
   2: include 'ssl_schema.ssl'
      
      % Generated automatically by schema
      
   2: type node_type:
   2: 	nINVALID
   2: 	Object
   2: 	nScope
   2: 	nDeclaration
   2: 	nIdent
   2: 	nOutput
   2: 	nError
   2: 	nType
   2: 	nValue
   2: 	nMechanism
   2: 	nOperation
   2: 	nRule
   2: 	nVariable
   2: 	nParam
   2: 	nInParam
   2: 	nOutParam
   2: 	nInOutParam
   2: 	nLocal
   2: 	nGlobal
   2: 	;
      
   2: type node_attribute:
   2: 	qINVALID
   2: 	qParentScope
   2: 	qDecls
   2: 	qIdent
   2: 	qValue
   2: 	qType
   2: 	qParamScope
   2: 	qScope
   2: 	qAddrDefined
   2: 	qTypeDefined
   2: 	qAddr
   2: 	;
      
      
      
   2: type boolean:
   2:     false    = 0
   2:     true     = 1
   2:     no       = 0
   2:     yes      = 1;
      
   2: type warning:
   2:     wRuleMissingAtSign
   2:     wReturnValueIgnored
   2:     ;
      
   2: type Node:     % A pointer to a node in the schema database (symbol database)
   2:     Null = 0
   2:     ;
      
   2: type kind:
   2:     kIllegal        % not an identifier
   2:     kUnknown        % new identifier
   2:     kInput
   2:     kOutput
   2:     kError
   2:     kType
   2:     kVal            % an element of a type
   2:     kMech
   2:     kOp
   2:     kRule
   2:     kVar
   2:     ;
      
   2: type pass:
   2:     CollectDefinitionsPass
   2:     CodeGenerationPass
   2:     ;
      
   2: mechanism scanner_mech:
   2:     oResetInput               % reset input to start (if required)
   2:     oStartListing             % start listing if requested; collect debug line numbers
   2:     ;
      
   2: mechanism warning_mech:
   2:     oWarning (warning);       % issue warning message,
                                    % continue normally (not in error recovery mode)
      
   2: mechanism more_errors_mech:
   2:     oUndeclaredRule (int id)     % Report that rule id was referenced, but never
                                       % declared (i.e. no body).  No error recovery mode.
   2:     ;
      
   2: mechanism emit_mech:
   2:     oEmitInt (int)            % emit an integer into the generated code
   2:     Here >> int               % return the current address in the generated code
   2:     oPatch (int addr, int val) % patch an integer into any address in the generated code
   2:     ;
      
   2: mechanism math:
   2:     inc (inout int)
   2:     dec (inout int)
   2:     negate (int) >> int
   2:     equal_zero (int) >> boolean
   2:     equal_node_type (node_type, node_type) >> boolean     % Want equal_<type> for every type
   2:     ;
      
   2: mechanism more_builtins:      % These should be built-in SSL operations
   2:     TOKEN_VALUE >> int        % value of just accepted token, e.g. IntLit token
   2:     LAST_ID >> int            % id number of last accepted identifier
   2:     ;
      
   2: mechanism shortForm:          % keep a table of string shortforms for input/output
   2:     oShortFormAdd (Node)      % associate current StrLit token with nDeclaration
   2:     oShortFormLookup (out Node);   % look up strLit, return associated nDeclaration
      
      
      % keep different patch stacks, each with a stack of position markers:
      
   2: type patchStack:
   2:     patchChoiceTableAddr    % addr where pointer to table is stored
   2:     patchChoiceTable        % build up choice table here (value,addr)
   2:     patchChoiceExit         % addrs where jumps at end of each option are
   2:     patchCall               % (addr,ident) where calls to undefined rules are
   2:     patchLoop               % addr of start of a loop
   2:     patchBreak;             % addrs where jumps out of a loop are
      
   2: mechanism patch_mech:
   2:     oPatchMark(patchStack)             % mark current position on a stack
   2:     oPatchAtMark(patchStack) >> boolean     % true if all items since
                                                 %   last mark are popped
                                                 %   (mark is dropped if true)
   2:     oPatchPushHere(patchStack)         % put current address on a patch stack
   2:     oPatchPushInt (patchStack, int)    % put int on a patch stack
   2:     oPatchPushIdent(patchStack)        % put last ident on a patch stack
   2:     oPatchAnyEntries(patchStack) >> boolean    % are there any entries?
   2:     oPatchPopFwd(patchStack)           % fix table, storing here-x at x,
                                             %   where x is on top of the stack
   2:     oPatchPopBack(patchStack)          % emit here-x here (advance 'here')
   2:     oPatchPopValue(patchStack)         % emit x here (advance 'here')
   2:     oPatchPopCall(patchStack);         % fix table, storing value of ident i
                                             %   at x, where i is on top of stack
                                             %   and x is under it  (pop both)
      
   2: mechanism titleMech:
   2:     oTitleSet;          % define title to be strlit just read
      
   2: mechanism doc:         % display documentary info
   2:     oDocNewRule;        % print "Rule <token>"
      
   2: mechanism include_mech:
   2:     oInclude;           % include the SSL file whose name is in the
                             % string token just accepted
      
   2: mechanism node_mech:
   2:     oNodeNew (node_type) >> Node         % create new node
   2:     oNodeSet (Node, node_attribute, Node)   % set Node attribute of node
   2:     oNodeSetInt (Node, node_attribute, int) % set int attribute of node
   2:     oNodeSetBoolean (Node, node_attribute, boolean)
   2:     oNodeGet (Node, node_attribute) >> Node    % get Node attribute of node
   2:     oNodeGetInt (Node, node_attribute) >> int  % get int attribute of node
   2:     oNodeGetBoolean (Node, node_attribute) >> boolean  % get int attribute of node
   2:     oNodeNull (Node) >> boolean          % is node null?
   2:     oNodeNext (inout Node)               % advance Node to next in list    
   2:     oNodeType (Node) >> node_type        % return node type of node
   2:     oNodeEqual (Node, Node) >> boolean   % compare two nodes for equality
                                               % (i.e. same node, not just same contents)
   2:     ;
      
   2: mechanism scope_mech:
   2:     oScopeBegin (out Node)             % create a new scope.  Subsequent declarations will go here.
                                             % Sets nScope's qParent to parent scope.
   2:     oScopeOpen (Node)                  % open an existing scope.  Its definitions become visible again.
   2:     oScopeEnd                          % end current scope.  Subsequent declarations will go to parent scope.
   2:     oScopeDeclare (Node)               % declare node in current scope
   2:     oScopeFind (out Node) >> boolean   % find declaration of last accepted identifier
   2:     oScopeFindRequire (out Node)       % find declaration of last accepted identifier.
                                             % Go into error recovery if not found.
   2:     ;
      
      
   2: mechanism install_mech:
   2:     oInstallSystemOperations (inout int next_operation)   % Predefine some operations
   2:     oInstallSystemTypes (out Node int_type, out Node token_type)   % Predefine some types.
                                                    % Return nType declaration of types int, token.
   2:     ;
      
   2: mechanism write_mech:
   2:     oWriteTables (Node global_scope);   % Write files, given global scope of symbol table.
      
   2: rules
      
      % ---------------------- Global Variables --------------------
      
   2: pass    CurrentPass         % which of two passes are we in?
   2: Node    IntType             % nType node for built-in "int" type
   2: Node    TokenType           % nType node for built-in "token" type (input tokens)
   2: Node    CurrentRule         % nRule node for current rule being declared
   2: int     NumGlobals          % number of global variables in program
   2: int     NumLocals           % number of local variables in current rule
   2: int     RuleLocalSpaceAddr  % address of LocalSpace argument for rule
   2: int     NextOperation       % code for next semantic operation decl
   2: int     NextError           % next error code
   2: Node    GlobalScope         % global nScope
      
      % -------------------- Forward Declarations ------------------
      
   2: Section >> boolean;
   2: ValueList (node_type class, inout int value, boolean str_alias_allowed, Node t);
   2: OperationDefinition >> boolean;
   2: RuleSectionDefinition >> boolean;
   2: RuleBodyDefinition (Node r);
   2: RuleRedefinition (Node r);
   2: Statement >> boolean;
   2: CallOperation (Node o);
   2: ActualParams (Node r) >> int;
   2: CallRule (Node r);
   2: CallUndefinedRule;
   2: Assignment (Node i);
   2: CopyChoiceTable (int num_options);
   2: Expr (out Node t);
   2: Lvalue (out Node t);
   2: Lvalue_HaveIdent (Node i, out Node t);
   2: Const (out Node t) >> int;
   2: IntConst >> int;
   2: LookupType (out Node i);
   2: LookupInput (out Node i);
   2: LookupOutput (out Node i);
   2: LookupValue (out Node i);
   2: LookupError (out Node i);
   2: RequireType (Node i);
   2: RequireInput (Node i);
   2: RequireOutput (Node i);
   2: RequireValue (Node i);
   2: RequireError (Node i);
   2: RequireRule (Node i);
   2: RequireNoType (Node r);
   2: RequireMatchValueType (Node v, Node t);
   2: MatchType (Node t1, Node t2) >> boolean;
   2: RequireMatchType (Node t1, Node t2);
   2: MatchIntType (Node t) >> boolean;
   2: RequireMatchIntType (Node t);
   2: EmitValue (Node i);
   2: EmitAddr (Node v);
      
      % ------------------------- Main Parser ----------------------
      
   2: ProcessSSL:
   4:     @CollectDefinitions     % first pass through input
   6:     oResetInput
   7:     @CodeGeneration         % second pass through input
  10:     ;
      
      
  10: CollectDefinitions:
      
  12:     CurrentPass = CollectDefinitionsPass
      
  18:     oScopeBegin (GlobalScope)
      
  24:     NextError = 0
  30:     NextOperation = 0
      
  36:     oInstallSystemOperations (NextOperation)
  42:     oInstallSystemTypes (IntType, TokenType)
      
  51:     NumGlobals = 0                 % Count global variables
      
  57:     {[ @Section
  60:         | true:
  61:         | *:  >
  68:     ]}
      
  70:     oScopeEnd
  72:     ;
      
      
  72: CodeGeneration:
      
  74:     CurrentPass = CodeGenerationPass
      
  80:     oScopeOpen (GlobalScope)   % Re-open scope
      
  86:     oStartListing   % Listing done in second pass, so it contains
                          % addresses of generated code.
                          % Also, collects line numbers for debugging.
      
          % Make space for global variables (inc because addressed from 1, not 0)
  87:     inc (NumGlobals)   .iGlobalSpace  oEmitInt(NumGlobals)
      
 101:     {[ @Section
 104:         | true:
 105:         | *:  >
 112:     ]}
      
 114:     @FixForwardCalls
 116:     @VerifyAllRulesDeclared
      
 118:     oScopeEnd
      
 119:     oWriteTables (GlobalScope)
 126:     ;
      
      
      % Returns true if a section found
      
 126: Section >> boolean:
      
 128:     [ CurrentPass
 131:         | CollectDefinitionsPass :
 132:             [
 132:                 | pTitle:      @Title
 136:                 | pInput:      @Input
 140:                 | pOutput:     @Output
 144:                 | pError:      @Error
 148:                 | pType:       @Type
 152:                 | pInclude:    @Include
 156:                 | pMechanism:  @Mechanism
 160:                 | pRules:      @Rules
 164:                 | pEof:        >> false      % end of file
 169:             ]
      
 191:         | CodeGenerationPass :
 193:             [
 193:                 | pTitle, pInput, pOutput, pError, pType, pMechanism :
 195:                                @SkipSection
      
 197:                 | pInclude:    @Include
 201:                 | pRules:      @Rules
 205:                 | pEof:        >> false      % end of file
 210:             ]
 232:     ]
 240:     >> true
 244:     ;
      
 244: SkipSection:
 246:     {[
 246:         | ';' : >
 250:         | * :   ?
 256:     ]};
      
      % ------------------------- Sections -------------------------
      
 259: Title:
 261:     ':' pStrLit oTitleSet ';' ;
      
      % Input tokens are values of the predefined "token" type
 269: Input:
 271:     int  next_value
 271:     ':'
 273:     next_value = 0
 279:     @ValueList (nValue, next_value, true, TokenType)
 295:     ';';
      
 298: Output:
 300:     int  next_value
 300:     ':'
 302:     next_value = 0
 308:     @ValueList (nOutput, next_value, true, Null)
 324:     ';';
      
 327: Error:
 329:     ':'
 331:     @ValueList (nError, NextError, false, Null)
 347:     ';';
      
      
 350: Type:
 352:     Node  t
 352:     int   next_value
      
 352:     pIdent
 354:     [ oScopeFind (t)
 361:         | false:
 362:             t = oNodeNew (nType)  oNodeSetInt (t, qIdent, LAST_ID)
 383:             oScopeDeclare (t)
      
 389:         | true:
      
                  % Extend existing definition (to add more values)
                  % Note, new values will start from 0 again unless told otherwise!
      
 391:             @RequireType (t)
 398:     ]
      
 406:     ':'
 408:     next_value = 0
 414:     @ValueList (nValue, next_value, false, t)
 430:     ';';
      
      
 433: Include:
 435:     pStrLit oInclude;
      
 439: Mechanism:
 441:     Node  m
      
 441:     pIdent
 443:     m = oNodeNew (nMechanism)  oNodeSetInt(m, qIdent, LAST_ID)
 464:     oScopeDeclare (m)
      
 470:     ':'
 472:     {[ @OperationDefinition
 475:         | true:
 476:         | *:  >
 483:     ]}
 485:     ';' ;
      
 488: Rules:
 490:     {[ @RuleSectionDefinition
 493:         | true:
 494:         | *:  >
 501:     ]}
 503:     pEnd ;
      
      
      % ------------------------- Value List ----------------------
      
 506: ValueList (node_type class, inout int value, boolean str_alias_allowed, Node t):
 508:     Node  p, t2
 508:     {[
 508:         | pIdent:
 510:             p = oNodeNew (class)  oNodeSetInt (p, qIdent, LAST_ID)
      
 531:             [ class
 534:                 | nValue :    oNodeSet (p, qType, t)
 547:                 | * :
 552:             ]
      
 552:             [ | pStrLit:
 554:                 [ str_alias_allowed
 557:                     | true:  oShortFormAdd (p)   % Associate short form with declaration
 564:                     | *:     #eAliasNotAllowed
 571:                 ]
 571:               | *:
 576:             ]
      
 576:             [ | '=':       value = @Const(t2)
 589:                            [ @MatchType (t, t2)
 600:                                | true :
 601:                                | false :  @RequireMatchIntType(t2)
 610:                            ]
 618:               |*:
 623:             ]
 623:             oNodeSetInt (p, qValue, value)
 635:             inc (value)
      
 641:             oScopeDeclare (p)
      
 647:         | *:  >
 654:     ]};
      
      % ------------------------- Variables ------------------------
      
      %  Declare a list of variables, given class (local/global),
      %  nType, and a counter used to assign addresses for that class.
      
 657: DeclareVariables (node_type class, Node t, inout int addr_counter):
 659:     Node  i
 659:     {
 659:         pIdent
 661:         i = oNodeNew(class)  oNodeSetInt(i, qIdent, LAST_ID)
 682:         oNodeSet (i, qType, t)
      
              % Assign address to variable
 694:         inc (addr_counter)   oNodeSetInt (i, qAddr, addr_counter)
      
 712:         oScopeDeclare (i)
      
              % optional initialization
 718:         [ | '=' :
      
                  % Unfortunately I can't allow initialization of global vars yet.
                  % This is only because @SkipGlobals would need to know how to skip the
                  % initialization expression, which is a little hard. It could be implemented
                  % but didn't do it yet.
 720:             [ class
 723:                 | nGlobal :  #eCantInitGlobalVarsYet
 726:                 | * :
 731:             ]
      
 731:             Node tv, t2
 731:             @Lvalue_HaveIdent(i,tv)
 741:             .iPushResult
 743:             @Expr(t2)  @RequireMatchType(tv,t2)
 760:             .iAssign
 762:           | * :
 767:         ]
      
 767:         [ | ',' :
 769:           | * :   >
 776:         ]
 776:     };
      
      %  Declare a list of global variables, given nType.
      
 779: DeclareGlobals (Node t):
 781:     @DeclareVariables (nGlobal, t, NumGlobals);
      
      %  Declare a list of local variables, given nType.
      
 795: DeclareLocals (Node t):
 797:     @DeclareVariables (nLocal, t, NumLocals);
      
      
      %  Skip list of global variables, during second pass.
      
 811: SkipGlobals:
 813:     {
 813:         pIdent
 815:         [ | ',' : | * : > ]
 824:     };
      
      
      %  Defines formal parameters (if any) in current scope.
      %  The caller should have called oScopeBegin to begin a
      %  scope just for parameters.  (This gives a simple way
      %  to check if an operation/rule has parameters).
      %  Does not end the scope.
      %
      %  nParam's may be named or unnamed (qIdent == 0)
      %
      %  Parameters are assigned addresses in reverse order
      %  from n to 1.  This is for efficient stack access.
      %  E.g. func(a,b,c):  address of a:3, b:2, c:1
      %  (Later I would like to instead push actuals in reverse order)
      
 827: FormalParamDefinition (Node scope):
 829:     int        num_params
 829:     node_type  dir
 829:     Node       p, t
      
 829:     [ | '(' :
 831:       | *   : >>
 837:     ]
      
 837:     num_params = 0      % Count the parameters, to assign addresses
      
 843:     {
 843:         inc (num_params)
      
              % parameter direction
 849:         [
 849:             | pIn :     dir = nInParam
 857:             | pOut :    dir = nOutParam
 865:             | pInOut :  dir = nInOutParam
 873:             | * :       dir = nInParam
 888:         ]
      
              % parameter type
 888:         pIdent  @LookupType (t)
      
 897:         p = oNodeNew(dir)
 907:         oNodeSet (p, qType, t)
      
              % parameter name
 919:         [
 919:             | pIdent :  oNodeSetInt (p, qIdent, LAST_ID)   % named parameter
 932:             | * :       % unnamed parameter
 937:         ]
      
 937:         oScopeDeclare (p)       % declare nParam
      
 943:         [
 943:             | ',' :
 945:             | * :   >
 952:         ]
 952:     }
      
 954:     ')'
      
          %  Now go back and assign addresses to the parameters
      
 956:     p = oNodeGet (scope, qDecls)
      
 969:     {
 969:         [ equal_zero (num_params)
 976:             | true:  >
 979:             | false:
 981:         ]
      
 989:         oNodeSetInt (p, qAddr, num_params)
      
1001:         dec (num_params)
1007:         oNodeNext (p)
1013:     }
1016:     ;
      
      %  Redefine formal parameters, perhaps during declaration of actual rule (with body).
      %  Previously, parameters were declared by a forward declaration or by usage.
      %  Ensure that types match.  Update parameter names to new names given.
      %
      %  Previous parameter nScope is given, and scope has been opened.
      %  (Addresses were assigned previously, no need to do it again).
      %  NOTE: I probably don't really want to open the previous scope since the
      %  old param names are not valid.
      
1016: FormalParamRedefinition (Node scope):
1018:     Node      p
1018:     node_type dir, dir2
1018:     Node      t, t2
      
1018:     p = oNodeGet (scope, qDecls)       % previous param declarations
      
1031:     [ | '(' :
1033:       | *   : [ oNodeNull(p)
1045:                   | true :
1046:                   | * :    #eParameterMismatch
1053:               ]
1053:               >>
1054:     ]
      
1054:     {
1054:         [ oNodeNull(p)
1061:             | true :    #eParameterMismatch  % too many params given this time
1064:             | false :
1066:         ]
      
1074:         dir = oNodeType(p)         % previous direction
              % parameter direction
1084:         [
1084:             | pIn :     dir2 = nInParam
1092:             | pOut :    dir2 = nOutParam
1100:             | pInOut :  dir2 = nInOutParam
1108:             | * :       dir2 = nInParam
1123:         ]
1123:         [ equal_node_type (dir, dir2)
1133:             | true :
1134:             | * :     #eParameterMismatch
1141:         ]
      
1141:         t = oNodeGet (p, qType)    % previous type
1154:         pIdent  @LookupType(t2)    % parameter type
1163:         @RequireMatchType (t, t2)
      
              % parameter name
1173:         [
1173:             | pIdent :  oNodeSetInt (p, qIdent, LAST_ID)
1186:             | * :       oNodeSetInt (p, qIdent, 0)   % currently unnamed
1203:         ]
      
1203:         oNodeNext (p)
      
1209:         [
1209:             | ',' :
1211:             | * :   >
1218:         ]
1218:     }
      
1220:     ')'
      
1222:     [ oNodeNull(p)
1229:         | true :
1230:         | * :    #eParameterMismatch   % Not enough params given this time
1237:     ]
1238:     ;
      
      
      % ------------------------- Operations -----------------------
      
      %  Returns true if definition found
      
1238: OperationDefinition >> boolean:
1240:     Node  op, s, t
1240:     [
1240:         | pIdent:
1242:         | *:        >> false
1250:     ]
      
1250:     op = oNodeNew (nOperation)  oNodeSetInt (op, qIdent, LAST_ID)
1271:     oNodeSetInt (op, qValue, NextOperation)
1283:     inc (NextOperation)
      
1289:     oScopeBegin (s)   % parameter scope
      
1295:     @FormalParamDefinition(s)
      
1302:     oNodeSet (op, qParamScope, s)
      
1314:     [ | '>>': pIdent  @LookupType (t)   oNodeSet (op, qType, t)
1337:       |*:     %  qType is Null by default
1342:     ]
      
1342:     oScopeEnd      % parameter scope
      
1343:     oScopeDeclare (op)
      
1349:     >> true
1353:     ;
      
      % ------------------------- Rules ----------------------------
      
      %  Parse a definition in the rules secition.
      %  This could be:
      %      a rule definition, a rule prototype, or a global variable definition.
      %  Returns true if one of the above found
      
1353: RuleSectionDefinition >> boolean:
1355:     Node  i
1355:     [
1355:         | pIdent:
1357:         | * :        >> false
1365:     ]
      
1365:     [ oScopeFind (i)
1372:         | false:     @RuleDefinition
1375:         | true:
1377:             [ oNodeType(i)
1384:                 | nType :  [ CurrentPass
1388:                                | CollectDefinitionsPass :  @DeclareGlobals(i)
1396:                                | CodeGenerationPass :      @SkipGlobals
1400:                            ]
1408:                 | nRule :  @RuleRedefinition(i)    % Probably body of fwd declared rule
1417:                 | * :      #eNotRuleOrGlobalDefn  >> true  % True to skip to next
1429:             ]
1429:     ]
      
1437:     >> true
1441:     ;
      
      
      % Skip a rule body during first pass (may begin with ':', or may not be a body)
1441: SkipRule:
1443:     {[
1443:         | ';' : >
1447:         | * :   ?
1453:     ]};
      
      %   Define the parameters, and possibly the body, of a rule
      %   that has not been defined previously.
      %   Just parsed ident of rule.
      
1456: RuleDefinition:
1458:     Node  r
1458:     Node  s
1458:     Node  t
      
1458:     oDocNewRule
      
1459:     r = oNodeNew(nRule)  oNodeSetInt(r, qIdent, LAST_ID)
1480:     CurrentRule = r
      
      
1486:     oScopeBegin (s)                 % param scope
1492:     @FormalParamDefinition(s)
1499:     oNodeSet (r, qParamScope, s)    % leave scope open, to access params during rule
      
1511:     [ | '>>':   pIdent  @LookupType(t)  oNodeSet (r, qType, t)
1534:       | * :
1539:     ]
      
1539:     [ CurrentPass
1542:         | CollectDefinitionsPass :
1543:             @SkipRule
1545:         | CodeGenerationPass :
1547:             [
1547:                 | ':' :  @RuleBodyDefinition (r)
1556:                 | * :    % No body; a forward declaration of the rule.
1561:             ]
1561:             ';'
1563:     ]
      
      
1571:     oScopeEnd            % parameters scope (already linked to nRule above)
      
1572:     oScopeDeclare (r)    % declare nRule
                               % (Note, can't call rule recursively since not defined until end)
1579:     ;
      
      
      % Given the nRule node
      
1579: RuleBodyDefinition (Node r):
1581:     Node  s
      
1581:     oNodeSetInt (r, qValue, Here)      % Address of rule is now defined
1592:     oNodeSetBoolean (r, qAddrDefined, yes)
      
1604:     oScopeBegin (s)       % rule variables scope
      
1610:     NumLocals = 0
      
1616:     .iLocalSpace 
1618:     RuleLocalSpaceAddr = Here   .iSpace
      
1625:     {[ @Statement
1628:         | true:
1629:         | *:  >
1636:     ]}
      
1638:     .iReturn
      
1640:     oPatch (RuleLocalSpaceAddr, NumLocals)
      
1649:     oScopeEnd            % rule variables scope
1650:     oNodeSet (r, qScope, s)
      
1663:     ;
      
      
      %   Redefine a rule (to provide body of a forward-declared rule).
      %   Given the existing nRule declaration.
      
1663: RuleRedefinition (Node r):
1665:     Node  s, p
1665:     Node  t, t2
      
1665:     [ oNodeGetBoolean (r, qAddrDefined)
1675:         | yes :   #eRuleBodyAlreadyDeclared  >>
1679:         | * :
1684:     ]
      
1684:     oDocNewRule
      
1685:     CurrentRule = r
      
1691:     s = oNodeGet(r, qParamScope)
1704:     oScopeOpen (s)   % Make the existing parameters visible.
                           % (Actually, probably don't want to do this).
      
1710:     @FormalParamRedefinition (s)   % verify types, update param names
      
          % Verify return type matches previous declaration/usage
1717:     t = oNodeGet (r, qType)
1730:     [ | '>>':   pIdent  @LookupType(t2)  @RequireMatchType(t, t2)
1751:       | * :     @RequireMatchType(t, Null)
1766:     ]
      
1766:     [ CurrentPass
1769:         | CollectDefinitionsPass :
1770:             @SkipRule
1772:         | CodeGenerationPass :
1774:             [
1774:                 | ':' :  @RuleBodyDefinition (r)
1783:                 | * :    % No body; a forward declaration of the rule.
1788:             ]
1788:             ';'
1790:     ]
      
1798:     oScopeEnd            % parameters scope (already linked to nRule)
1800:     ;
      
      % ------------------------- Statements -----------------------
      
      %  Returns true if statement found
      
1800: Statement >> boolean:
1802:     Node  i
1802:     Node  t, t2
      
1802:     [
1802:         | pStrLit:           % input alias
1804:             oShortFormLookup(i)  @RequireInput(i)
1817:             .iInput @EmitValue(i)
      
1826:         | pIdent:            % input or operation
1828:             oScopeFindRequire(i)
1834:             [ oNodeType(i)
      
      %  | nInput:      .iInput @EmitValue(i)
      
1841:                 | nOperation:  @RequireNoType(i) @CallOperation(i)
      
1856:                 | nType:       @DeclareLocals(i)
      
1865:                 | nValue:      @RequireInput(i)
1874:                                .iInput @EmitValue(i)
      
1883:                 | *:           @Assignment(i)
1899:             ]
      
1899: 	| '#':
1901:             pIdent  @LookupError(i)
1910:             .iError @EmitValue(i)
      
1919: 	| '.':
1921: 	    [ | pIdent:    @LookupOutput(i)
1930:               | pStrLit:   oShortFormLookup(i) @RequireOutput(i)
1945:             ]
1953:             .iEmit @EmitValue(i)
      
1962: 	| '@':
1964: 	    pIdent
1966:             [ oScopeFind(i)
1973:                 | true :
1974:                     @RequireRule(i)  @RequireNoType(i)
1988:                     @CallRule(i)
      
1995:                 | false :
1997:                     @CallUndefinedRule
1999:             ]
      
2007: 	| '>>':
2009:             t = oNodeGet (CurrentRule, qType)
2022: 	    [ oNodeNull(t)
2029:                 | true :
2030:                 | * :       @Expr(t2)  @RequireMatchType(t, t2)
2052:             ]
2052:             .iReturn
      
2054: 	| '{':
2056:             oPatchPushHere (patchLoop)
2062:             oPatchMark (patchBreak)
2068: 	    {[ @Statement
2071: 		| true:
2072: 		| *:  >
2079: 	    ]}
2081: 	    '}'
2083:             .iJumpBack
2085:             oPatchPopBack (patchLoop)
      
                  % Fix up break statements
2091:             {[ oPatchAtMark (patchBreak)
2098:                 | false :    oPatchPopFwd (patchBreak)
2105:                 | * :        >
2112:             ]}
      
2114: 	| '>':
2116:             [ oPatchAnyEntries (patchLoop)
2123:                 | false:  #eNotInLoop
2126:                 | *:
2131:             ]
2131:             .iJumpForward  oPatchPushHere (patchBreak)  .iSpace
      
2141: 	| '?':  .iInputAny
      
2145: 	| '[':  @Choice
      
2149:         | *:    >> false    % Not a statement
2175:     ]
2175:     >> true ;
      
      
      %  Given nOperation
      
2179: CallOperation (Node o):
2181:     int  num_params
      
2181:     num_params = @ActualParams (o)
      
2192:     @EmitValue(o)        % call operation
      
2199:     [ equal_zero (num_params)
2206:         | true :
2207:         | false :     .iPop oEmitInt(num_params)
2217:     ]
2226:     ;
      
      
      %  Given nOperation or nRule.  Returns number of parameters.
      
2226: ActualParams (Node r) >> int:
      
2228:     int   num_params
2228:     Node  param_scope, p
2228:     Node  t, t2
      
2228:     param_scope = oNodeGet (r, qParamScope)  % Always present, but might contain no nParams
2241:     p = oNodeGet (param_scope, qDecls)
      
2254:     [ oNodeNull(p)
      
2261:         | true :    >> 0
2265:         | false :
2267:     ]
      
2275:     num_params = 0
      
2281:     '('
      
2283:     {
2283:         inc (num_params)
      
              %  ----------------------------
      
              %  One actual parameter.
      
2289:         t = oNodeGet (p, qType)    % formal param type
      
2302:         [ oNodeType(p)
2309:             | nInParam :                @Expr (t2)
2317:             | nOutParam, nInOutParam :  @Lvalue (t2)
2326:         ]
              
2336:         @RequireMatchType (t, t2)
2346:         .iPushResult
      
              %  ----------------------------
      
2348:         oNodeNext (p)
      
2354:         [ oNodeNull (p)
2361:             | true :   >
2364:             | false :
2366:         ]
      
2374:         ','
2376:     }
      
2378:     ')'
      
2380:     >> num_params
2384:     ;
      
      
      
      %  Called for a nRule whose parameter types are defined.
      %  The rule address might not yet be known.
      
2384: CallRule (Node r):
2386:     int  num_params
      
2386:     num_params = @ActualParams(r)
      
2397:     [ oNodeGetBoolean (r, qAddrDefined)     % A call to a forward-declared rule?
2407:         | yes :   .iCall @EmitValue(r)
2417:         | no :    .iCall oPatchPushHere(patchCall) 
2427:                          oPatchPushInt (patchCall, oNodeGetInt(r, qIdent))
2443:                          .iSpace
2445:     ]
      
          % Pop actual params
2453:     [ equal_zero (num_params)
2460:         | true :
2461:         | false :     .iPop oEmitInt(num_params)
2471:     ]
2480:     ;
      
      
      %  Implicitly declare a rule that has not previously been declared.
      %  Rule name is last accepted identifier.
      %  Implicitly declares InParam parameters, and no return type.
      %
      %  Rule is declared in GlobalScope.
      
2480: CallUndefinedRule:
2482:     Node  r, s, t, p
2482:     int   id, num_params, addr
      
          % Global scope opened so that rule will be declared in it,
          % and so the parameters we declare for the rule will have the
          % correct ParentScope
      
2482:     oScopeOpen (GlobalScope)
      
      
2488:     r = oNodeNew (nRule)  id = LAST_ID  oNodeSetInt (r, qIdent, id)
2515:     oNodeSetBoolean(r, qAddrDefined, false)
      
          % Implicit parameters
      
2527:     oScopeBegin (s)
2533:     oNodeSet (r, qParamScope, s)
      
2545:     num_params = 0
      
2551:     [ | '(' :
      
2553:         {
2553:             @Expr(t)
2560:             .iPushResult
2562:             p = oNodeNew (nInParam)  oNodeSet(p, qType, t)
2584:             oScopeDeclare(p)
2590:             inc(num_params)
      
2596:             [ | ',' :
2598:               | * :   >
2605:             ]
2605:         }
2607:         ')'
      
              % Assign parameter addresses
      
2609:         addr = num_params
2615:         p = oNodeGet (s, qDecls)
2628:         {
2628:             [ oNodeNull(p)
2635:                 | true :  >
2638:                 | false :
2640:             ]
2648:             oNodeSetInt (p, qAddr, addr)
2660:             dec (addr)
2666:             oNodeNext (p)
2672:         }
      
2674:       | * :
2679:     ]
      
2679:     oScopeEnd    % param scope
2680:     oScopeDeclare (r)
      
2686:     oScopeEnd    % GlobalScope
      
      
          % Now call rule
      
2687:     .iCall
2689:     oPatchPushHere (patchCall)
2695:     oPatchPushInt (patchCall, id)
2704:     .iSpace
      
2706:     [ equal_zero (num_params)
2713:         | true :
2714:         | * :     .iPop oEmitInt(num_params)
2727:     ];
      
      
      %  Already parsed pIdent and determined it is not a rule/type/operation/value.
      
2728: Assignment (Node i):
2730:     Node t, t2
2730:     @Lvalue_HaveIdent(i,t)
2740:     .iPushResult
2742:     '='
2744:     @Expr(t2)  @RequireMatchType(t,t2)
2761:     .iAssign
2764:     ;
      
2764: Choice:
2766:     int    num_options    % count the number of options in the choice
2766:     kind   choice_kind    % input choice, expr choice, expr undefined type choice
2766:     Node   choice_type    % type of expr choice
2766:     Node   t
2766:     Node   i
2766:     int    val
      
          %  Determine if this is an input choice or a value choice.
          %  For value choice, determine type of value (if known).
      
2766:     [
2766:         | '|' :
2768:             .iInputChoice   choice_kind = kInput
      
2776:         | * :
2781:             @Expr(choice_type)  .iChoice
      
                  % Expr indicates forward use of undefined rule by returning type Null.
                  % We will indicate this for ourselves by setting kind to kUnknown.
      
2790:             [ oNodeNull(choice_type)
2797:                 | true :    choice_kind = kUnknown   % flag that this is expr choice, unknown type
2804:                 | false:    choice_kind = kType      % flag that this is expr choice, known type
2812:             ]
      
2820:             '|'
2822:     ]
      
2822:     oPatchPushHere (patchChoiceTableAddr)
2828:     .iSpace
      
2830:     oPatchMark (patchChoiceTable)    % build up choice table in this stack
2836:     oPatchMark (patchChoiceExit)     % remember end of each option
2842:     num_options = 0                  % count options
      
2848:     {
2848:         [
2848:             | '*':     % default code (must be last option)
2850:                 ':'
2852:                 @CopyChoiceTable (num_options)
      
2859:                 {[ @Statement
2862:                     | true :
2863:                     | *: >
2870: 	        ]}
2872:                 ']'
      
                      % Finish up
2874:                 @FixChoiceExits
2876:                 >>
      
2877:             | * :
2882:                 {
2882:                     [ choice_kind
      
2885:                         | kType :         % expr choice
2886:                             val = @Const(t)
2897:                             @RequireMatchType (choice_type, t)
      
2907:                         | kUnknown :      % expr choice, type not known yet
2909:                             val = @Const(choice_type)
      
                                  % NOTE: now that we know type of forward rule in expr, we could update nRule
      
                                  % Now know type
2920:                             choice_kind = kType
      
2926:                         | kInput :        % input choice
2928:                             val = @Const(t)
2939:                             @RequireMatchTokenType(t)
2946:                     ]
      
2956:                     oPatchPushHere (patchChoiceTable)
2962:                     oPatchPushInt  (patchChoiceTable, val)
2971:                     inc (num_options)
      
2977:                     [
2977:                         | ':' :   >
2981:                         | ',' :
2983:                     ]
2991:                 }
2993:         ]
      
              % Code for this option:
      
2993:         {[ @Statement
2996:             | true:
2997:             | *:  >
3004:         ]}
      
3006:         [
3006:             | ']' :     % end of choice, no default
3008:                 .iJumpForward
3010:                 oPatchPushHere (patchChoiceExit) .iSpace
3018:                 @CopyChoiceTable (num_options)
      
3025:                 .iEndChoice
      
3027:                 @FixChoiceExits
3029:                 >>
      
3030:             | '|' :     % more options follow
3032:                 .iJumpForward
3034:                 oPatchPushHere (patchChoiceExit) .iSpace
3042:         ]
3050:     };
      
      
      %  Install choice table here, given number of options.
      %  Order of options is opposite that in the source (note for error recovery)
      
3053: CopyChoiceTable (int num_options):
3055:     oPatchPopFwd (patchChoiceTableAddr)    % fix pointer to table
3061:     oEmitInt (num_options)                 % # table entries
3067:     {[ oPatchAtMark (patchChoiceTable)
3074:         | false :
3075:             oPatchPopValue (patchChoiceTable)
3081:             oPatchPopBack (patchChoiceTable)
3087:         | * :   >
3094:     ]};
          
      % Fix jumps from end of each option to end of choice
      
3097: FixChoiceExits:
3099:     {[ oPatchAtMark (patchChoiceExit)
3106:         | false:    oPatchPopFwd (patchChoiceExit)
3113:         | *:        >
3120:     ]};
      
3123: FixForwardCalls:
3125:     {[ oPatchAnyEntries (patchCall)
3132:         | true :    oPatchPopCall (patchCall)
3139:         | * :       >
3146:     ]};
      
      % Ensure that there are no rules referenced but never declared
3149: VerifyAllRulesDeclared:
3151:     Node  n
3151:     n = oNodeGet (GlobalScope, qDecls)
3164:     {
3164:         [ oNodeNull(n)
3171:             | true : >
3174:             | false :
3176:         ]
      
3184:         [ oNodeType(n)
3191:             | nRule :
3192:                 [ oNodeGetBoolean (n, qAddrDefined)
3202:                     | false :   oUndeclaredRule(oNodeGetInt(n, qIdent))
3216:                     | * :
3221:                 ]
3221:             | * :
3226:         ]
      
3226:         oNodeNext(n)
3232:     };
      
      %  ------------------------------------------------------- 
      
      %  Emits code for expression (with result in ssl_result).
      %  Returns nType of expression.
      
3235: Expr (out Node t):
3237:     Node  i
3237:     [
3237:         | pIdent :
      
3239:             [ oScopeFind (i)
3246:                 | true :
3247:                     [ oNodeType (i)
3254:                         | nRule :        oWarning(wRuleMissingAtSign) @CallRule(i)
3268:                         | nOperation :   @CallOperation(i)
3277:                         | nValue :       .iSetResult    @EmitValue(i)
3288:                         | nInParam :     .iGetParam     @EmitAddr(i)
3299:                         | nOutParam :    .iGetFromParam @EmitAddr(i)
3310:                         | nInOutParam :  .iGetFromParam @EmitAddr(i)
3321:                         | nLocal :       .iGetLocal     @EmitAddr(i)
3332:                         | nGlobal :      .iGetGlobal    @EmitAddr(i)
3343:                         | * : #eIdentNotAllowedInExpr
3364:                     ]
      
3364:                     t = oNodeGet (i, qType)         % Get type of identifier
3377:                     [ oNodeNull(t)
3384:                         | true:  #eNotTyped   % e.g. call with no return value
3387:                         | * :
3392:                     ]
      
3392:                 | false :
3394:                     t = Null  #eUndeclaredIdentifier
3402:             ]
      
3410:         | '@' :
3412: 	    pIdent
3414:             [ oScopeFind (i)
3421:                 | true :
3422:                     @RequireRule(i) @CallRule(i)
3436:                     t = oNodeGet (i, qType)
3449:                     [ oNodeNull (t)
3456:                         | true:  #eNotTyped   % e.g. call with no return value
3459:                         | * :
3464:                     ]
      
3464:                 | false :
                          % Call before defined.  Limited use in this case.
                          % The nType pushed will be NULL.  We don't know the real type.
                          % This is really just allowed so we can have simple rules in a Choice expression.
      
3466:                     @CallUndefinedRule
3468:                     t = Null
3474:             ]
      
3482:         | '-' :
3484:             pIntLit   .iSetResult  oEmitInt(negate(TOKEN_VALUE))
3497:             t = IntType
3503:         | pIntLit :
3505:             .iSetResult  oEmitInt(TOKEN_VALUE)
3512:             t = IntType
3518:     ];
      
      %  Emits code for lvalue (putting address of variable in ssl_result).
      %  Returns nType of the referenced value.
      
3531: Lvalue (out Node t):
3533:     Node i
3533:     [
3533:         | pIdent :
      
3535:             [ oScopeFind(i)
3542:                 | true :      @Lvalue_HaveIdent(i,t)
      
3553:                 | false :     % a forward use of rule, illegal as lvalue
3555:                     t = Null  #eIllegalLvalue
3563:             ]
      
3571:         | '-' :   pIntLit     t = Null    #eIllegalLvalue
3583:         | pIntLit :           t = Null    #eIllegalLvalue
3593:     ];
      
      %  Emit code for lvalue, given nDeclaration of identifier.
      %  Return lvalue's nType
      
3604: Lvalue_HaveIdent (Node i, out Node t):
3606:     [ oNodeType(i)
3613:         | nInParam :     .iGetAddrParam  @EmitAddr(i)
3623:         | nOutParam :    .iGetParam      @EmitAddr(i)
3634:         | nInOutParam :  .iGetParam      @EmitAddr(i)
3645:         | nLocal :       .iGetAddrLocal  @EmitAddr(i)
3656:         | nGlobal :      .iGetAddrGlobal @EmitAddr(i)
3667:         | * : #eIllegalLvalue
3682:     ]
3682:     t = oNodeGet (i, qType)         % Get type of identifier
3696:     ;
      
      %  Return a constant value.  Also return the type of the value.
      %  No code is generated.
      
3696: Const (out Node t) >> int:
3698:     Node  i
3698:     int   val
3698:     [
3698:         | pIdent :
3700:             @LookupValue (i)
3707:             val = oNodeGetInt (i, qValue)
3720:             t = oNodeGet (i, qType)
3733:         | '-' :
3735:             pIntLit
3737:             val = negate(TOKEN_VALUE)
3746:             t = IntType
3752:         | pIntLit :
3754:             val = TOKEN_VALUE
3759:             t = IntType
3765:         | pStrLit :
3767:             oShortFormLookup (i)
3773:             val = oNodeGetInt (i, qValue)
3786:             t = oNodeGet (i, qType)
3799:     ]
3811:     >> val;
      
      %  Return integer constant.  Only values of type "int" are
      %  permitted.  No code is generated.
      
3815: IntConst >> int:
3817:     Node t
3817:     int  i
3817:     i = @Const (t)  @RequireMatchIntType (t)
3835:     >> i;
      
      %  ------------------------------------------------------- 
      
      %  Assert that the ident we just read is a particular kind of
      %  identifier.  Return the declaration node of the identifier.
      
3839: LookupType (out Node i):
3841:     oScopeFindRequire (i)
3847:     @RequireType (i);
      
3855: LookupInput (out Node i):
3857:     oScopeFindRequire (i)
3863:     @RequireInput (i);
      
3871: LookupOutput (out Node i):
3873:     oScopeFindRequire (i)
3879:     @RequireOutput (i);
      
3887: LookupValue (out Node i):
3889:     oScopeFindRequire (i)
3895:     @RequireValue (i);
      
3903: LookupError (out Node i):
3905:     oScopeFindRequire (i)
3911:     @RequireError (i);
      
      %  Assert that the given nDeclaration represents a particular
      %  kind of declaration.
      
3919: RequireType (Node i):
3921:     [ oNodeType(i)
3928:         | nType :
3929:         | * :    #eNotAType
3936:     ];
      
      %  Ensure that value is an input token (value of type "token")
3937: RequireInput (Node i):
3939:     [ oNodeEqual(oNodeGet(i, qType), TokenType)
3956:         | true :
3957:         | * :    #eNotInput
3964:     ];
      
3965: RequireOutput (Node i):
3967:     [ oNodeType(i)
3974:         | nOutput :
3975:         | * :    #eNotOutput
3982:     ];
      
3983: RequireValue (Node i):
3985:     [ oNodeType(i)
3992:         | nValue :
3993:         | * :    #eNotAValue
4000:     ];
      
4001: RequireError (Node i):
4003:     [ oNodeType(i)
4010:         | nError :
4011:         | * :    #eNotAnErrSig
4018:     ];
      
4019: RequireRule (Node i):
4021:     [ oNodeType(i)
4028:         | nRule :
4029:         | * :    #eNotARule
4036:     ];
      
      %  Require that rule/operation has no return type
      
4037: RequireNoType (Node r):
4039:     [ oNodeNull (oNodeGet(r, qType))
4053:         | false: oWarning(wReturnValueIgnored)  % #eChoiceOpRuleOutOfPlace
4060:         | * :
4065:     ];
      
      %  Given a value nDeclaration, and a nType.
      %  Ensure that the value symbol has the type nType.
      
4066: RequireMatchValueType (Node v, Node t):
4068:     [ oNodeEqual (oNodeGet(v, qType), t)
4085:         | true :
4086:         | * :    #eWrongType
4093:     ];
      
      
      %  Do two types match?
      
4094: MatchType (Node t1, Node t2) >> boolean:
4096:     >> oNodeEqual (t1, t2);
      
4107: RequireMatchType (Node t1, Node t2):
4109:     [ oNodeEqual (t1, t2)
4119:         | true :
4120:         | * :    #eWrongType
4127:     ];
      
      %  Is the nType "int"?
      
4128: MatchIntType (Node t) >> boolean:
4130:     >> oNodeEqual (t, IntType);
      
4141: RequireMatchIntType (Node t):
4143:     [ oNodeEqual (t, IntType)
4153:         | true :
4154:         | * :     #eWrongType
4161:     ];
      
4162: RequireMatchTokenType (Node t):
4164:     [ oNodeEqual (t, TokenType)
4174:         | true :
4175:         | * :     #eNotInput
4182:     ];
      
      %  ------------------------------------------------------- 
      
      
      %  Emit the value of an identifier declaration, given its nDeclaration
      
4183: EmitValue (Node i):
4185:     oEmitInt (oNodeGetInt(i, qValue));
      
      %  Emit the addr of a variable, given its declaration
      
4199: EmitAddr (Node v):
4201:     oEmitInt (oNodeGetInt(v, qAddr));
      
4215: end
      
4215: 

Generated code:

   0: oGlobalSpace 11
   2: oLocalSpace 0
   4: oCall 10
   6: oResetInput
   7: oCall 72
   9: oReturn
  10: oLocalSpace 0
  12: oGetAddrGlobal 1
  14: oPushResult
  15: oSetResult 0
  17: oAssign
  18: oGetAddrGlobal 10
  20: oPushResult
  21: oScopeBegin
  22: oPop 1
  24: oGetAddrGlobal 9
  26: oPushResult
  27: oSetResult 0
  29: oAssign
  30: oGetAddrGlobal 8
  32: oPushResult
  33: oSetResult 0
  35: oAssign
  36: oGetAddrGlobal 8
  38: oPushResult
  39: oInstallSystemOperations
  40: oPop 1
  42: oGetAddrGlobal 2
  44: oPushResult
  45: oGetAddrGlobal 3
  47: oPushResult
  48: oInstallSystemTypes
  49: oPop 2
  51: oGetAddrGlobal 5
  53: oPushResult
  54: oSetResult 0
  56: oAssign
  57: oCall 126
  59: oChoice 63
  61: oJumpForward 68
  63: Choice Lookup Table
           1     61
  66: oJumpForward 70
  68: oJumpBack 57
  70: oScopeEnd
  71: oReturn
  72: oLocalSpace 0
  74: oGetAddrGlobal 1
  76: oPushResult
  77: oSetResult 1
  79: oAssign
  80: oGetGlobal 10
  82: oPushResult
  83: oScopeOpen
  84: oPop 1
  86: oStartListing
  87: oGetAddrGlobal 5
  89: oPushResult
  90: inc
  91: oPop 1
  93: oEmit 15
  95: oGetGlobal 5
  97: oPushResult
  98: oEmitInt
  99: oPop 1
 101: oCall 126
 103: oChoice 107
 105: oJumpForward 112
 107: Choice Lookup Table
           1    105
 110: oJumpForward 114
 112: oJumpBack 101
 114: oCall 3123
 116: oCall 3149
 118: oScopeEnd
 119: oGetGlobal 10
 121: oPushResult
 122: oWriteTables
 123: oPop 1
 125: oReturn
 126: oLocalSpace 0
 128: oGetGlobal 1
 130: oChoice 234
 132: oInputChoice 171
 134: oCall 259
 136: oJumpForward 191
 138: oCall 269
 140: oJumpForward 191
 142: oCall 298
 144: oJumpForward 191
 146: oCall 327
 148: oJumpForward 191
 150: oCall 350
 152: oJumpForward 191
 154: oCall 433
 156: oJumpForward 191
 158: oCall 439
 160: oJumpForward 191
 162: oCall 488
 164: oJumpForward 191
 166: oSetResult 0
 168: oReturn
 169: oJumpForward 191
 171: Choice Lookup Table
          22    166
          31    162
          29    158
          30    154
          27    150
          28    146
          26    142
          25    138
          24    134
 190: oEndChoice
 191: oJumpForward 240
 193: oInputChoice 212
 195: oCall 244
 197: oJumpForward 232
 199: oCall 433
 201: oJumpForward 232
 203: oCall 488
 205: oJumpForward 232
 207: oSetResult 0
 209: oReturn
 210: oJumpForward 232
 212: Choice Lookup Table
          22    207
          31    203
          30    199
          29    195
          27    195
          28    195
          26    195
          25    195
          24    195
 231: oEndChoice
 232: oJumpForward 240
 234: Choice Lookup Table
           1    193
           0    132
 239: oEndChoice
 240: oSetResult 1
 242: oReturn
 243: oReturn
 244: oLocalSpace 0
 246: oInputChoice 252
 248: oJumpForward 258
 250: oJumpForward 256
 252: Choice Lookup Table
           6    248
 255: oInputAny
 256: oJumpBack 246
 258: oReturn
 259: oLocalSpace 0
 261: oInput 5
 263: oInput 2
 265: oTitleSet
 266: oInput 6
 268: oReturn
 269: oLocalSpace 1
 271: oInput 5
 273: oGetAddrLocal 1
 275: oPushResult
 276: oSetResult 0
 278: oAssign
 279: oSetResult 8
 281: oPushResult
 282: oGetAddrLocal 1
 284: oPushResult
 285: oSetResult 1
 287: oPushResult
 288: oGetGlobal 3
 290: oPushResult
 291: oCall 506
 293: oPop 4
 295: oInput 6
 297: oReturn
 298: oLocalSpace 1
 300: oInput 5
 302: oGetAddrLocal 1
 304: oPushResult
 305: oSetResult 0
 307: oAssign
 308: oSetResult 5
 310: oPushResult
 311: oGetAddrLocal 1
 313: oPushResult
 314: oSetResult 1
 316: oPushResult
 317: oSetResult 0
 319: oPushResult
 320: oCall 506
 322: oPop 4
 324: oInput 6
 326: oReturn
 327: oLocalSpace 0
 329: oInput 5
 331: oSetResult 6
 333: oPushResult
 334: oGetAddrGlobal 9
 336: oPushResult
 337: oSetResult 0
 339: oPushResult
 340: oSetResult 0
 342: oPushResult
 343: oCall 506
 345: oPop 4
 347: oInput 6
 349: oReturn
 350: oLocalSpace 2
 352: oInput 0
 354: oGetAddrLocal 1
 356: oPushResult
 357: oScopeFind
 358: oPop 1
 360: oChoice 400
 362: oGetAddrLocal 1
 364: oPushResult
 365: oSetResult 7
 367: oPushResult
 368: oNodeNew
 369: oPop 1
 371: oAssign
 372: oGetLocal 1
 374: oPushResult
 375: oSetResult 3
 377: oPushResult
 378: LAST_ID
 379: oPushResult
 380: oNodeSetInt
 381: oPop 3
 383: oGetLocal 1
 385: oPushResult
 386: oScopeDeclare
 387: oPop 1
 389: oJumpForward 406
 391: oGetLocal 1
 393: oPushResult
 394: oCall 3919
 396: oPop 1
 398: oJumpForward 406
 400: Choice Lookup Table
           1    391
           0    362
 405: oEndChoice
 406: oInput 5
 408: oGetAddrLocal 2
 410: oPushResult
 411: oSetResult 0
 413: oAssign
 414: oSetResult 8
 416: oPushResult
 417: oGetAddrLocal 2
 419: oPushResult
 420: oSetResult 0
 422: oPushResult
 423: oGetLocal 1
 425: oPushResult
 426: oCall 506
 428: oPop 4
 430: oInput 6
 432: oReturn
 433: oLocalSpace 0
 435: oInput 2
 437: oInclude
 438: oReturn
 439: oLocalSpace 1
 441: oInput 0
 443: oGetAddrLocal 1
 445: oPushResult
 446: oSetResult 9
 448: oPushResult
 449: oNodeNew
 450: oPop 1
 452: oAssign
 453: oGetLocal 1
 455: oPushResult
 456: oSetResult 3
 458: oPushResult
 459: LAST_ID
 460: oPushResult
 461: oNodeSetInt
 462: oPop 3
 464: oGetLocal 1
 466: oPushResult
 467: oScopeDeclare
 468: oPop 1
 470: oInput 5
 472: oCall 1238
 474: oChoice 478
 476: oJumpForward 483
 478: Choice Lookup Table
           1    476
 481: oJumpForward 485
 483: oJumpBack 472
 485: oInput 6
 487: oReturn
 488: oLocalSpace 0
 490: oCall 1353
 492: oChoice 496
 494: oJumpForward 501
 496: Choice Lookup Table
           1    494
 499: oJumpForward 503
 501: oJumpBack 490
 503: oInput 32
 505: oReturn
 506: oLocalSpace 2
 508: oInputChoice 649
 510: oGetAddrLocal 1
 512: oPushResult
 513: oGetParam 4
 515: oPushResult
 516: oNodeNew
 517: oPop 1
 519: oAssign
 520: oGetLocal 1
 522: oPushResult
 523: oSetResult 3
 525: oPushResult
 526: LAST_ID
 527: oPushResult
 528: oNodeSetInt
 529: oPop 3
 531: oGetParam 4
 533: oChoice 549
 535: oGetLocal 1
 537: oPushResult
 538: oSetResult 5
 540: oPushResult
 541: oGetParam 1
 543: oPushResult
 544: oNodeSet
 545: oPop 3
 547: oJumpForward 552
 549: Choice Lookup Table
           8    535
 552: oInputChoice 573
 554: oGetParam 2
 556: oChoice 566
 558: oGetLocal 1
 560: oPushResult
 561: oShortFormAdd
 562: oPop 1
 564: oJumpForward 571
 566: Choice Lookup Table
           1    558
 569: oError 18
 571: oJumpForward 576
 573: Choice Lookup Table
           2    554
 576: oInputChoice 620
 578: oGetParam 3
 580: oPushResult
 581: oGetAddrLocal 2
 583: oPushResult
 584: oCall 3696
 586: oPop 1
 588: oAssign
 589: oGetParam 1
 591: oPushResult
 592: oGetLocal 2
 594: oPushResult
 595: oCall 4094
 597: oPop 2
 599: oChoice 612
 601: oJumpForward 618
 603: oGetLocal 2
 605: oPushResult
 606: oCall 4141
 608: oPop 1
 610: oJumpForward 618
 612: Choice Lookup Table
           0    603
           1    601
 617: oEndChoice
 618: oJumpForward 623
 620: Choice Lookup Table
           4    578
 623: oGetLocal 1
 625: oPushResult
 626: oSetResult 4
 628: oPushResult
 629: oGetFromParam 3
 631: oPushResult
 632: oNodeSetInt
 633: oPop 3
 635: oGetParam 3
 637: oPushResult
 638: inc
 639: oPop 1
 641: oGetLocal 1
 643: oPushResult
 644: oScopeDeclare
 645: oPop 1
 647: oJumpForward 654
 649: Choice Lookup Table
           0    510
 652: oJumpForward 656
 654: oJumpBack 508
 656: oReturn
 657: oLocalSpace 3
 659: oInput 0
 661: oGetAddrLocal 1
 663: oPushResult
 664: oGetParam 3
 666: oPushResult
 667: oNodeNew
 668: oPop 1
 670: oAssign
 671: oGetLocal 1
 673: oPushResult
 674: oSetResult 3
 676: oPushResult
 677: LAST_ID
 678: oPushResult
 679: oNodeSetInt
 680: oPop 3
 682: oGetLocal 1
 684: oPushResult
 685: oSetResult 5
 687: oPushResult
 688: oGetParam 2
 690: oPushResult
 691: oNodeSet
 692: oPop 3
 694: oGetParam 1
 696: oPushResult
 697: inc
 698: oPop 1
 700: oGetLocal 1
 702: oPushResult
 703: oSetResult 10
 705: oPushResult
 706: oGetFromParam 1
 708: oPushResult
 709: oNodeSetInt
 710: oPop 3
 712: oGetLocal 1
 714: oPushResult
 715: oScopeDeclare
 716: oPop 1
 718: oInputChoice 764
 720: oGetParam 3
 722: oChoice 728
 724: oError 19
 726: oJumpForward 731
 728: Choice Lookup Table
          18    724
 731: oGetLocal 1
 733: oPushResult
 734: oGetAddrLocal 2
 736: oPushResult
 737: oCall 3604
 739: oPop 2
 741: oEmit 12
 743: oGetAddrLocal 3
 745: oPushResult
 746: oCall 3235
 748: oPop 1
 750: oGetLocal 2
 752: oPushResult
 753: oGetLocal 3
 755: oPushResult
 756: oCall 4107
 758: oPop 2
 760: oEmit 24
 762: oJumpForward 767
 764: Choice Lookup Table
           4    720
 767: oInputChoice 771
 769: oJumpForward 776
 771: Choice Lookup Table
           7    769
 774: oJumpForward 778
 776: oJumpBack 659
 778: oReturn
 779: oLocalSpace 0
 781: oSetResult 18
 783: oPushResult
 784: oGetParam 1
 786: oPushResult
 787: oGetAddrGlobal 5
 789: oPushResult
 790: oCall 657
 792: oPop 3
 794: oReturn
 795: oLocalSpace 0
 797: oSetResult 17
 799: oPushResult
 800: oGetParam 1
 802: oPushResult
 803: oGetAddrGlobal 6
 805: oPushResult
 806: oCall 657
 808: oPop 3
 810: oReturn
 811: oLocalSpace 0
 813: oInput 0
 815: oInputChoice 819
 817: oJumpForward 824
 819: Choice Lookup Table
           7    817
 822: oJumpForward 826
 824: oJumpBack 813
 826: oReturn
 827: oLocalSpace 4
 829: oInputChoice 833
 831: oJumpForward 837
 833: Choice Lookup Table
           8    831
 836: oReturn
 837: oGetAddrLocal 1
 839: oPushResult
 840: oSetResult 0
 842: oAssign
 843: oGetAddrLocal 1
 845: oPushResult
 846: inc
 847: oPop 1
 849: oInputChoice 875
 851: oGetAddrLocal 2
 853: oPushResult
 854: oSetResult 14
 856: oAssign
 857: oJumpForward 888
 859: oGetAddrLocal 2
 861: oPushResult
 862: oSetResult 15
 864: oAssign
 865: oJumpForward 888
 867: oGetAddrLocal 2
 869: oPushResult
 870: oSetResult 16
 872: oAssign
 873: oJumpForward 888
 875: Choice Lookup Table
          35    867
          34    859
          33    851
 882: oGetAddrLocal 2
 884: oPushResult
 885: oSetResult 14
 887: oAssign
 888: oInput 0
 890: oGetAddrLocal 4
 892: oPushResult
 893: oCall 3839
 895: oPop 1
 897: oGetAddrLocal 3
 899: oPushResult
 900: oGetLocal 2
 902: oPushResult
 903: oNodeNew
 904: oPop 1
 906: oAssign
 907: oGetLocal 3
 909: oPushResult
 910: oSetResult 5
 912: oPushResult
 913: oGetLocal 4
 915: oPushResult
 916: oNodeSet
 917: oPop 3
 919: oInputChoice 934
 921: oGetLocal 3
 923: oPushResult
 924: oSetResult 3
 926: oPushResult
 927: LAST_ID
 928: oPushResult
 929: oNodeSetInt
 930: oPop 3
 932: oJumpForward 937
 934: Choice Lookup Table
           0    921
 937: oGetLocal 3
 939: oPushResult
 940: oScopeDeclare
 941: oPop 1
 943: oInputChoice 947
 945: oJumpForward 952
 947: Choice Lookup Table
           7    945
 950: oJumpForward 954
 952: oJumpBack 843
 954: oInput 9
 956: oGetAddrLocal 3
 958: oPushResult
 959: oGetParam 1
 961: oPushResult
 962: oSetResult 2
 964: oPushResult
 965: oNodeGet
 966: oPop 2
 968: oAssign
 969: oGetLocal 1
 971: oPushResult
 972: equal_zero
 973: oPop 1
 975: oChoice 983
 977: oJumpForward 1015
 979: oJumpForward 989
 981: oJumpForward 989
 983: Choice Lookup Table
           0    981
           1    977
 988: oEndChoice
 989: oGetLocal 3
 991: oPushResult
 992: oSetResult 10
 994: oPushResult
 995: oGetLocal 1
 997: oPushResult
 998: oNodeSetInt
 999: oPop 3
1001: oGetAddrLocal 1
1003: oPushResult
1004: dec
1005: oPop 1
1007: oGetAddrLocal 3
1009: oPushResult
1010: oNodeNext
1011: oPop 1
1013: oJumpBack 969
1015: oReturn
1016: oLocalSpace 5
1018: oGetAddrLocal 1
1020: oPushResult
1021: oGetParam 1
1023: oPushResult
1024: oSetResult 2
1026: oPushResult
1027: oNodeGet
1028: oPop 2
1030: oAssign
1031: oInputChoice 1035
1033: oJumpForward 1054
1035: Choice Lookup Table
           8   1033
1038: oGetLocal 1
1040: oPushResult
1041: oNodeNull
1042: oPop 1
1044: oChoice 1048
1046: oJumpForward 1053
1048: Choice Lookup Table
           1   1046
1051: oError 16
1053: oReturn
1054: oGetLocal 1
1056: oPushResult
1057: oNodeNull
1058: oPop 1
1060: oChoice 1068
1062: oError 16
1064: oJumpForward 1074
1066: oJumpForward 1074
1068: Choice Lookup Table
           0   1066
           1   1062
1073: oEndChoice
1074: oGetAddrLocal 2
1076: oPushResult
1077: oGetLocal 1
1079: oPushResult
1080: oNodeType
1081: oPop 1
1083: oAssign
1084: oInputChoice 1110
1086: oGetAddrLocal 3
1088: oPushResult
1089: oSetResult 14
1091: oAssign
1092: oJumpForward 1123
1094: oGetAddrLocal 3
1096: oPushResult
1097: oSetResult 15
1099: oAssign
1100: oJumpForward 1123
1102: oGetAddrLocal 3
1104: oPushResult
1105: oSetResult 16
1107: oAssign
1108: oJumpForward 1123
1110: Choice Lookup Table
          35   1102
          34   1094
          33   1086
1117: oGetAddrLocal 3
1119: oPushResult
1120: oSetResult 14
1122: oAssign
1123: oGetLocal 2
1125: oPushResult
1126: oGetLocal 3
1128: oPushResult
1129: equal_node_type
1130: oPop 2
1132: oChoice 1136
1134: oJumpForward 1141
1136: Choice Lookup Table
           1   1134
1139: oError 16
1141: oGetAddrLocal 4
1143: oPushResult
1144: oGetLocal 1
1146: oPushResult
1147: oSetResult 5
1149: oPushResult
1150: oNodeGet
1151: oPop 2
1153: oAssign
1154: oInput 0
1156: oGetAddrLocal 5
1158: oPushResult
1159: oCall 3839
1161: oPop 1
1163: oGetLocal 4
1165: oPushResult
1166: oGetLocal 5
1168: oPushResult
1169: oCall 4107
1171: oPop 2
1173: oInputChoice 1188
1175: oGetLocal 1
1177: oPushResult
1178: oSetResult 3
1180: oPushResult
1181: LAST_ID
1182: oPushResult
1183: oNodeSetInt
1184: oPop 3
1186: oJumpForward 1203
1188: Choice Lookup Table
           0   1175
1191: oGetLocal 1
1193: oPushResult
1194: oSetResult 3
1196: oPushResult
1197: oSetResult 0
1199: oPushResult
1200: oNodeSetInt
1201: oPop 3
1203: oGetAddrLocal 1
1205: oPushResult
1206: oNodeNext
1207: oPop 1
1209: oInputChoice 1213
1211: oJumpForward 1218
1213: Choice Lookup Table
           7   1211
1216: oJumpForward 1220
1218: oJumpBack 1054
1220: oInput 9
1222: oGetLocal 1
1224: oPushResult
1225: oNodeNull
1226: oPop 1
1228: oChoice 1232
1230: oJumpForward 1237
1232: Choice Lookup Table
           1   1230
1235: oError 16
1237: oReturn
1238: oLocalSpace 3
1240: oInputChoice 1244
1242: oJumpForward 1250
1244: Choice Lookup Table
           0   1242
1247: oSetResult 0
1249: oReturn
1250: oGetAddrLocal 1
1252: oPushResult
1253: oSetResult 10
1255: oPushResult
1256: oNodeNew
1257: oPop 1
1259: oAssign
1260: oGetLocal 1
1262: oPushResult
1263: oSetResult 3
1265: oPushResult
1266: LAST_ID
1267: oPushResult
1268: oNodeSetInt
1269: oPop 3
1271: oGetLocal 1
1273: oPushResult
1274: oSetResult 4
1276: oPushResult
1277: oGetGlobal 8
1279: oPushResult
1280: oNodeSetInt
1281: oPop 3
1283: oGetAddrGlobal 8
1285: oPushResult
1286: inc
1287: oPop 1
1289: oGetAddrLocal 2
1291: oPushResult
1292: oScopeBegin
1293: oPop 1
1295: oGetLocal 2
1297: oPushResult
1298: oCall 827
1300: oPop 1
1302: oGetLocal 1
1304: oPushResult
1305: oSetResult 6
1307: oPushResult
1308: oGetLocal 2
1310: oPushResult
1311: oNodeSet
1312: oPop 3
1314: oInputChoice 1339
1316: oInput 0
1318: oGetAddrLocal 3
1320: oPushResult
1321: oCall 3839
1323: oPop 1
1325: oGetLocal 1
1327: oPushResult
1328: oSetResult 5
1330: oPushResult
1331: oGetLocal 3
1333: oPushResult
1334: oNodeSet
1335: oPop 3
1337: oJumpForward 1342
1339: Choice Lookup Table
          10   1316
1342: oScopeEnd
1343: oGetLocal 1
1345: oPushResult
1346: oScopeDeclare
1347: oPop 1
1349: oSetResult 1
1351: oReturn
1352: oReturn
1353: oLocalSpace 1
1355: oInputChoice 1359
1357: oJumpForward 1365
1359: Choice Lookup Table
           0   1357
1362: oSetResult 0
1364: oReturn
1365: oGetAddrLocal 1
1367: oPushResult
1368: oScopeFind
1369: oPop 1
1371: oChoice 1431
1373: oCall 1456
1375: oJumpForward 1437
1377: oGetLocal 1
1379: oPushResult
1380: oNodeType
1381: oPop 1
1383: oChoice 1419
1385: oGetGlobal 1
1387: oChoice 1402
1389: oGetLocal 1
1391: oPushResult
1392: oCall 779
1394: oPop 1
1396: oJumpForward 1408
1398: oCall 811
1400: oJumpForward 1408
1402: Choice Lookup Table
           1   1398
           0   1389
1407: oEndChoice
1408: oJumpForward 1429
1410: oGetLocal 1
1412: oPushResult
1413: oCall 1663
1415: oPop 1
1417: oJumpForward 1429
1419: Choice Lookup Table
          11   1410
           7   1385
1424: oError 13
1426: oSetResult 1
1428: oReturn
1429: oJumpForward 1437
1431: Choice Lookup Table
           1   1377
           0   1373
1436: oEndChoice
1437: oSetResult 1
1439: oReturn
1440: oReturn
1441: oLocalSpace 0
1443: oInputChoice 1449
1445: oJumpForward 1455
1447: oJumpForward 1453
1449: Choice Lookup Table
           6   1445
1452: oInputAny
1453: oJumpBack 1443
1455: oReturn
1456: oLocalSpace 3
1458: oDocNewRule
1459: oGetAddrLocal 1
1461: oPushResult
1462: oSetResult 11
1464: oPushResult
1465: oNodeNew
1466: oPop 1
1468: oAssign
1469: oGetLocal 1
1471: oPushResult
1472: oSetResult 3
1474: oPushResult
1475: LAST_ID
1476: oPushResult
1477: oNodeSetInt
1478: oPop 3
1480: oGetAddrGlobal 4
1482: oPushResult
1483: oGetLocal 1
1485: oAssign
1486: oGetAddrLocal 2
1488: oPushResult
1489: oScopeBegin
1490: oPop 1
1492: oGetLocal 2
1494: oPushResult
1495: oCall 827
1497: oPop 1
1499: oGetLocal 1
1501: oPushResult
1502: oSetResult 6
1504: oPushResult
1505: oGetLocal 2
1507: oPushResult
1508: oNodeSet
1509: oPop 3
1511: oInputChoice 1536
1513: oInput 0
1515: oGetAddrLocal 3
1517: oPushResult
1518: oCall 3839
1520: oPop 1
1522: oGetLocal 1
1524: oPushResult
1525: oSetResult 5
1527: oPushResult
1528: oGetLocal 3
1530: oPushResult
1531: oNodeSet
1532: oPop 3
1534: oJumpForward 1539
1536: Choice Lookup Table
          10   1513
1539: oGetGlobal 1
1541: oChoice 1565
1543: oCall 1441
1545: oJumpForward 1571
1547: oInputChoice 1558
1549: oGetLocal 1
1551: oPushResult
1552: oCall 1579
1554: oPop 1
1556: oJumpForward 1561
1558: Choice Lookup Table
           5   1549
1561: oInput 6
1563: oJumpForward 1571
1565: Choice Lookup Table
           1   1547
           0   1543
1570: oEndChoice
1571: oScopeEnd
1572: oGetLocal 1
1574: oPushResult
1575: oScopeDeclare
1576: oPop 1
1578: oReturn
1579: oLocalSpace 1
1581: oGetParam 1
1583: oPushResult
1584: oSetResult 4
1586: oPushResult
1587: Here
1588: oPushResult
1589: oNodeSetInt
1590: oPop 3
1592: oGetParam 1
1594: oPushResult
1595: oSetResult 8
1597: oPushResult
1598: oSetResult 1
1600: oPushResult
1601: oNodeSetBoolean
1602: oPop 3
1604: oGetAddrLocal 1
1606: oPushResult
1607: oScopeBegin
1608: oPop 1
1610: oGetAddrGlobal 6
1612: oPushResult
1613: oSetResult 0
1615: oAssign
1616: oEmit 16
1618: oGetAddrGlobal 7
1620: oPushResult
1621: Here
1622: oAssign
1623: oEmit 25
1625: oCall 1800
1627: oChoice 1631
1629: oJumpForward 1636
1631: Choice Lookup Table
           1   1629
1634: oJumpForward 1638
1636: oJumpBack 1625
1638: oEmit 8
1640: oGetGlobal 7
1642: oPushResult
1643: oGetGlobal 6
1645: oPushResult
1646: oPatch
1647: oPop 2
1649: oScopeEnd
1650: oGetParam 1
1652: oPushResult
1653: oSetResult 7
1655: oPushResult
1656: oGetLocal 1
1658: oPushResult
1659: oNodeSet
1660: oPop 3
1662: oReturn
1663: oLocalSpace 4
1665: oGetParam 1
1667: oPushResult
1668: oSetResult 8
1670: oPushResult
1671: oNodeGetBoolean
1672: oPop 2
1674: oChoice 1681
1676: oError 14
1678: oReturn
1679: oJumpForward 1684
1681: Choice Lookup Table
           1   1676
1684: oDocNewRule
1685: oGetAddrGlobal 4
1687: oPushResult
1688: oGetParam 1
1690: oAssign
1691: oGetAddrLocal 1
1693: oPushResult
1694: oGetParam 1
1696: oPushResult
1697: oSetResult 6
1699: oPushResult
1700: oNodeGet
1701: oPop 2
1703: oAssign
1704: oGetLocal 1
1706: oPushResult
1707: oScopeOpen
1708: oPop 1
1710: oGetLocal 1
1712: oPushResult
1713: oCall 1016
1715: oPop 1
1717: oGetAddrLocal 3
1719: oPushResult
1720: oGetParam 1
1722: oPushResult
1723: oSetResult 5
1725: oPushResult
1726: oNodeGet
1727: oPop 2
1729: oAssign
1730: oInputChoice 1753
1732: oInput 0
1734: oGetAddrLocal 4
1736: oPushResult
1737: oCall 3839
1739: oPop 1
1741: oGetLocal 3
1743: oPushResult
1744: oGetLocal 4
1746: oPushResult
1747: oCall 4107
1749: oPop 2
1751: oJumpForward 1766
1753: Choice Lookup Table
          10   1732
1756: oGetLocal 3
1758: oPushResult
1759: oSetResult 0
1761: oPushResult
1762: oCall 4107
1764: oPop 2
1766: oGetGlobal 1
1768: oChoice 1792
1770: oCall 1441
1772: oJumpForward 1798
1774: oInputChoice 1785
1776: oGetParam 1
1778: oPushResult
1779: oCall 1579
1781: oPop 1
1783: oJumpForward 1788
1785: Choice Lookup Table
           5   1776
1788: oInput 6
1790: oJumpForward 1798
1792: Choice Lookup Table
           1   1774
           0   1770
1797: oEndChoice
1798: oScopeEnd
1799: oReturn
1800: oLocalSpace 3
1802: oInputChoice 2151
1804: oGetAddrLocal 1
1806: oPushResult
1807: oShortFormLookup
1808: oPop 1
1810: oGetLocal 1
1812: oPushResult
1813: oCall 3937
1815: oPop 1
1817: oEmit 2
1819: oGetLocal 1
1821: oPushResult
1822: oCall 4183
1824: oPop 1
1826: oJumpForward 2175
1828: oGetAddrLocal 1
1830: oPushResult
1831: oScopeFindRequire
1832: oPop 1
1834: oGetLocal 1
1836: oPushResult
1837: oNodeType
1838: oPop 1
1840: oChoice 1885
1842: oGetLocal 1
1844: oPushResult
1845: oCall 4037
1847: oPop 1
1849: oGetLocal 1
1851: oPushResult
1852: oCall 2179
1854: oPop 1
1856: oJumpForward 1899
1858: oGetLocal 1
1860: oPushResult
1861: oCall 795
1863: oPop 1
1865: oJumpForward 1899
1867: oGetLocal 1
1869: oPushResult
1870: oCall 3937
1872: oPop 1
1874: oEmit 2
1876: oGetLocal 1
1878: oPushResult
1879: oCall 4183
1881: oPop 1
1883: oJumpForward 1899
1885: Choice Lookup Table
           8   1867
           7   1858
          10   1842
1892: oGetLocal 1
1894: oPushResult
1895: oCall 2728
1897: oPop 1
1899: oJumpForward 2175
1901: oInput 0
1903: oGetAddrLocal 1
1905: oPushResult
1906: oCall 3903
1908: oPop 1
1910: oEmit 5
1912: oGetLocal 1
1914: oPushResult
1915: oCall 4183
1917: oPop 1
1919: oJumpForward 2175
1921: oInputChoice 1947
1923: oGetAddrLocal 1
1925: oPushResult
1926: oCall 3871
1928: oPop 1
1930: oJumpForward 1953
1932: oGetAddrLocal 1
1934: oPushResult
1935: oShortFormLookup
1936: oPop 1
1938: oGetLocal 1
1940: oPushResult
1941: oCall 3965
1943: oPop 1
1945: oJumpForward 1953
1947: Choice Lookup Table
           2   1932
           0   1923
1952: oEndChoice
1953: oEmit 4
1955: oGetLocal 1
1957: oPushResult
1958: oCall 4183
1960: oPop 1
1962: oJumpForward 2175
1964: oInput 0
1966: oGetAddrLocal 1
1968: oPushResult
1969: oScopeFind
1970: oPop 1
1972: oChoice 2001
1974: oGetLocal 1
1976: oPushResult
1977: oCall 4019
1979: oPop 1
1981: oGetLocal 1
1983: oPushResult
1984: oCall 4037
1986: oPop 1
1988: oGetLocal 1
1990: oPushResult
1991: oCall 2384
1993: oPop 1
1995: oJumpForward 2007
1997: oCall 2480
1999: oJumpForward 2007
2001: Choice Lookup Table
           0   1997
           1   1974
2006: oEndChoice
2007: oJumpForward 2175
2009: oGetAddrLocal 2
2011: oPushResult
2012: oGetGlobal 4
2014: oPushResult
2015: oSetResult 5
2017: oPushResult
2018: oNodeGet
2019: oPop 2
2021: oAssign
2022: oGetLocal 2
2024: oPushResult
2025: oNodeNull
2026: oPop 1
2028: oChoice 2032
2030: oJumpForward 2052
2032: Choice Lookup Table
           1   2030
2035: oGetAddrLocal 3
2037: oPushResult
2038: oCall 3235
2040: oPop 1
2042: oGetLocal 2
2044: oPushResult
2045: oGetLocal 3
2047: oPushResult
2048: oCall 4107
2050: oPop 2
2052: oEmit 8
2054: oJumpForward 2175
2056: oSetResult 4
2058: oPushResult
2059: oPatchPushHere
2060: oPop 1
2062: oSetResult 5
2064: oPushResult
2065: oPatchMark
2066: oPop 1
2068: oCall 1800
2070: oChoice 2074
2072: oJumpForward 2079
2074: Choice Lookup Table
           1   2072
2077: oJumpForward 2081
2079: oJumpBack 2068
2081: oInput 13
2083: oEmit 1
2085: oSetResult 4
2087: oPushResult
2088: oPatchPopBack
2089: oPop 1
2091: oSetResult 5
2093: oPushResult
2094: oPatchAtMark
2095: oPop 1
2097: oChoice 2107
2099: oSetResult 5
2101: oPushResult
2102: oPatchPopFwd
2103: oPop 1
2105: oJumpForward 2112
2107: Choice Lookup Table
           0   2099
2110: oJumpForward 2114
2112: oJumpBack 2091
2114: oJumpForward 2175
2116: oSetResult 4
2118: oPushResult
2119: oPatchAnyEntries
2120: oPop 1
2122: oChoice 2128
2124: oError 7
2126: oJumpForward 2131
2128: Choice Lookup Table
           0   2124
2131: oEmit 0
2133: oSetResult 5
2135: oPushResult
2136: oPatchPushHere
2137: oPop 1
2139: oEmit 25
2141: oJumpForward 2175
2143: oEmit 3
2145: oJumpForward 2175
2147: oCall 2764
2149: oJumpForward 2175
2151: Choice Lookup Table
          14   2147
          21   2143
          11   2116
          12   2056
          10   2009
          17   1964
          18   1921
          20   1901
           0   1828
           2   1804
2172: oSetResult 0
2174: oReturn
2175: oSetResult 1
2177: oReturn
2178: oReturn
2179: oLocalSpace 1
2181: oGetAddrLocal 1
2183: oPushResult
2184: oGetParam 1
2186: oPushResult
2187: oCall 2226
2189: oPop 1
2191: oAssign
2192: oGetParam 1
2194: oPushResult
2195: oCall 4183
2197: oPop 1
2199: oGetLocal 1
2201: oPushResult
2202: equal_zero
2203: oPop 1
2205: oChoice 2219
2207: oJumpForward 2225
2209: oEmit 13
2211: oGetLocal 1
2213: oPushResult
2214: oEmitInt
2215: oPop 1
2217: oJumpForward 2225
2219: Choice Lookup Table
           0   2209
           1   2207
2224: oEndChoice
2225: oReturn
2226: oLocalSpace 5
2228: oGetAddrLocal 2
2230: oPushResult
2231: oGetParam 1
2233: oPushResult
2234: oSetResult 6
2236: oPushResult
2237: oNodeGet
2238: oPop 2
2240: oAssign
2241: oGetAddrLocal 3
2243: oPushResult
2244: oGetLocal 2
2246: oPushResult
2247: oSetResult 2
2249: oPushResult
2250: oNodeGet
2251: oPop 2
2253: oAssign
2254: oGetLocal 3
2256: oPushResult
2257: oNodeNull
2258: oPop 1
2260: oChoice 2269
2262: oSetResult 0
2264: oReturn
2265: oJumpForward 2275
2267: oJumpForward 2275
2269: Choice Lookup Table
           0   2267
           1   2262
2274: oEndChoice
2275: oGetAddrLocal 1
2277: oPushResult
2278: oSetResult 0
2280: oAssign
2281: oInput 8
2283: oGetAddrLocal 1
2285: oPushResult
2286: inc
2287: oPop 1
2289: oGetAddrLocal 4
2291: oPushResult
2292: oGetLocal 3
2294: oPushResult
2295: oSetResult 5
2297: oPushResult
2298: oNodeGet
2299: oPop 2
2301: oAssign
2302: oGetLocal 3
2304: oPushResult
2305: oNodeType
2306: oPop 1
2308: oChoice 2328
2310: oGetAddrLocal 5
2312: oPushResult
2313: oCall 3235
2315: oPop 1
2317: oJumpForward 2336
2319: oGetAddrLocal 5
2321: oPushResult
2322: oCall 3531
2324: oPop 1
2326: oJumpForward 2336
2328: Choice Lookup Table
          16   2319
          15   2319
          14   2310
2335: oEndChoice
2336: oGetLocal 4
2338: oPushResult
2339: oGetLocal 5
2341: oPushResult
2342: oCall 4107
2344: oPop 2
2346: oEmit 12
2348: oGetAddrLocal 3
2350: oPushResult
2351: oNodeNext
2352: oPop 1
2354: oGetLocal 3
2356: oPushResult
2357: oNodeNull
2358: oPop 1
2360: oChoice 2368
2362: oJumpForward 2378
2364: oJumpForward 2374
2366: oJumpForward 2374
2368: Choice Lookup Table
           0   2366
           1   2362
2373: oEndChoice
2374: oInput 7
2376: oJumpBack 2283
2378: oInput 9
2380: oGetLocal 1
2382: oReturn
2383: oReturn
2384: oLocalSpace 1
2386: oGetAddrLocal 1
2388: oPushResult
2389: oGetParam 1
2391: oPushResult
2392: oCall 2226
2394: oPop 1
2396: oAssign
2397: oGetParam 1
2399: oPushResult
2400: oSetResult 8
2402: oPushResult
2403: oNodeGetBoolean
2404: oPop 2
2406: oChoice 2447
2408: oEmit 7
2410: oGetParam 1
2412: oPushResult
2413: oCall 4183
2415: oPop 1
2417: oJumpForward 2453
2419: oEmit 7
2421: oSetResult 3
2423: oPushResult
2424: oPatchPushHere
2425: oPop 1
2427: oSetResult 3
2429: oPushResult
2430: oGetParam 1
2432: oPushResult
2433: oSetResult 3
2435: oPushResult
2436: oNodeGetInt
2437: oPop 2
2439: oPushResult
2440: oPatchPushInt
2441: oPop 2
2443: oEmit 25
2445: oJumpForward 2453
2447: Choice Lookup Table
           0   2419
           1   2408
2452: oEndChoice
2453: oGetLocal 1
2455: oPushResult
2456: equal_zero
2457: oPop 1
2459: oChoice 2473
2461: oJumpForward 2479
2463: oEmit 13
2465: oGetLocal 1
2467: oPushResult
2468: oEmitInt
2469: oPop 1
2471: oJumpForward 2479
2473: Choice Lookup Table
           0   2463
           1   2461
2478: oEndChoice
2479: oReturn
2480: oLocalSpace 7
2482: oGetGlobal 10
2484: oPushResult
2485: oScopeOpen
2486: oPop 1
2488: oGetAddrLocal 1
2490: oPushResult
2491: oSetResult 11
2493: oPushResult
2494: oNodeNew
2495: oPop 1
2497: oAssign
2498: oGetAddrLocal 5
2500: oPushResult
2501: LAST_ID
2502: oAssign
2503: oGetLocal 1
2505: oPushResult
2506: oSetResult 3
2508: oPushResult
2509: oGetLocal 5
2511: oPushResult
2512: oNodeSetInt
2513: oPop 3
2515: oGetLocal 1
2517: oPushResult
2518: oSetResult 8
2520: oPushResult
2521: oSetResult 0
2523: oPushResult
2524: oNodeSetBoolean
2525: oPop 3
2527: oGetAddrLocal 2
2529: oPushResult
2530: oScopeBegin
2531: oPop 1
2533: oGetLocal 1
2535: oPushResult
2536: oSetResult 6
2538: oPushResult
2539: oGetLocal 2
2541: oPushResult
2542: oNodeSet
2543: oPop 3
2545: oGetAddrLocal 6
2547: oPushResult
2548: oSetResult 0
2550: oAssign
2551: oInputChoice 2676
2553: oGetAddrLocal 3
2555: oPushResult
2556: oCall 3235
2558: oPop 1
2560: oEmit 12
2562: oGetAddrLocal 4
2564: oPushResult
2565: oSetResult 14
2567: oPushResult
2568: oNodeNew
2569: oPop 1
2571: oAssign
2572: oGetLocal 4
2574: oPushResult
2575: oSetResult 5
2577: oPushResult
2578: oGetLocal 3
2580: oPushResult
2581: oNodeSet
2582: oPop 3
2584: oGetLocal 4
2586: oPushResult
2587: oScopeDeclare
2588: oPop 1
2590: oGetAddrLocal 6
2592: oPushResult
2593: inc
2594: oPop 1
2596: oInputChoice 2600
2598: oJumpForward 2605
2600: Choice Lookup Table
           7   2598
2603: oJumpForward 2607
2605: oJumpBack 2553
2607: oInput 9
2609: oGetAddrLocal 7
2611: oPushResult
2612: oGetLocal 6
2614: oAssign
2615: oGetAddrLocal 4
2617: oPushResult
2618: oGetLocal 2
2620: oPushResult
2621: oSetResult 2
2623: oPushResult
2624: oNodeGet
2625: oPop 2
2627: oAssign
2628: oGetLocal 4
2630: oPushResult
2631: oNodeNull
2632: oPop 1
2634: oChoice 2642
2636: oJumpForward 2674
2638: oJumpForward 2648
2640: oJumpForward 2648
2642: Choice Lookup Table
           0   2640
           1   2636
2647: oEndChoice
2648: oGetLocal 4
2650: oPushResult
2651: oSetResult 10
2653: oPushResult
2654: oGetLocal 7
2656: oPushResult
2657: oNodeSetInt
2658: oPop 3
2660: oGetAddrLocal 7
2662: oPushResult
2663: dec
2664: oPop 1
2666: oGetAddrLocal 4
2668: oPushResult
2669: oNodeNext
2670: oPop 1
2672: oJumpBack 2628
2674: oJumpForward 2679
2676: Choice Lookup Table
           8   2553
2679: oScopeEnd
2680: oGetLocal 1
2682: oPushResult
2683: oScopeDeclare
2684: oPop 1
2686: oScopeEnd
2687: oEmit 7
2689: oSetResult 3
2691: oPushResult
2692: oPatchPushHere
2693: oPop 1
2695: oSetResult 3
2697: oPushResult
2698: oGetLocal 5
2700: oPushResult
2701: oPatchPushInt
2702: oPop 2
2704: oEmit 25
2706: oGetLocal 6
2708: oPushResult
2709: equal_zero
2710: oPop 1
2712: oChoice 2716
2714: oJumpForward 2727
2716: Choice Lookup Table
           1   2714
2719: oEmit 13
2721: oGetLocal 6
2723: oPushResult
2724: oEmitInt
2725: oPop 1
2727: oReturn
2728: oLocalSpace 2
2730: oGetParam 1
2732: oPushResult
2733: oGetAddrLocal 1
2735: oPushResult
2736: oCall 3604
2738: oPop 2
2740: oEmit 12
2742: oInput 4
2744: oGetAddrLocal 2
2746: oPushResult
2747: oCall 3235
2749: oPop 1
2751: oGetLocal 1
2753: oPushResult
2754: oGetLocal 2
2756: oPushResult
2757: oCall 4107
2759: oPop 2
2761: oEmit 24
2763: oReturn
2764: oLocalSpace 6
2766: oInputChoice 2778
2768: oEmit 6
2770: oGetAddrLocal 2
2772: oPushResult
2773: oSetResult 2
2775: oAssign
2776: oJumpForward 2822
2778: Choice Lookup Table
          16   2768
2781: oGetAddrLocal 3
2783: oPushResult
2784: oCall 3235
2786: oPop 1
2788: oEmit 10
2790: oGetLocal 3
2792: oPushResult
2793: oNodeNull
2794: oPop 1
2796: oChoice 2814
2798: oGetAddrLocal 2
2800: oPushResult
2801: oSetResult 1
2803: oAssign
2804: oJumpForward 2820
2806: oGetAddrLocal 2
2808: oPushResult
2809: oSetResult 5
2811: oAssign
2812: oJumpForward 2820
2814: Choice Lookup Table
           0   2806
           1   2798
2819: oEndChoice
2820: oInput 16
2822: oSetResult 0
2824: oPushResult
2825: oPatchPushHere
2826: oPop 1
2828: oEmit 25
2830: oSetResult 1
2832: oPushResult
2833: oPatchMark
2834: oPop 1
2836: oSetResult 2
2838: oPushResult
2839: oPatchMark
2840: oPop 1
2842: oGetAddrLocal 1
2844: oPushResult
2845: oSetResult 0
2847: oAssign
2848: oInputChoice 2879
2850: oInput 5
2852: oGetLocal 1
2854: oPushResult
2855: oCall 3053
2857: oPop 1
2859: oCall 1800
2861: oChoice 2865
2863: oJumpForward 2870
2865: Choice Lookup Table
           1   2863
2868: oJumpForward 2872
2870: oJumpBack 2859
2872: oInput 15
2874: oCall 3097
2876: oReturn
2877: oJumpForward 2993
2879: Choice Lookup Table
          19   2850
2882: oGetLocal 2
2884: oChoice 2948
2886: oGetAddrLocal 6
2888: oPushResult
2889: oGetAddrLocal 4
2891: oPushResult
2892: oCall 3696
2894: oPop 1
2896: oAssign
2897: oGetLocal 3
2899: oPushResult
2900: oGetLocal 4
2902: oPushResult
2903: oCall 4107
2905: oPop 2
2907: oJumpForward 2956
2909: oGetAddrLocal 6
2911: oPushResult
2912: oGetAddrLocal 3
2914: oPushResult
2915: oCall 3696
2917: oPop 1
2919: oAssign
2920: oGetAddrLocal 2
2922: oPushResult
2923: oSetResult 5
2925: oAssign
2926: oJumpForward 2956
2928: oGetAddrLocal 6
2930: oPushResult
2931: oGetAddrLocal 4
2933: oPushResult
2934: oCall 3696
2936: oPop 1
2938: oAssign
2939: oGetLocal 4
2941: oPushResult
2942: oCall 4162
2944: oPop 1
2946: oJumpForward 2956
2948: Choice Lookup Table
           2   2928
           1   2909
           5   2886
2955: oEndChoice
2956: oSetResult 1
2958: oPushResult
2959: oPatchPushHere
2960: oPop 1
2962: oSetResult 1
2964: oPushResult
2965: oGetLocal 6
2967: oPushResult
2968: oPatchPushInt
2969: oPop 2
2971: oGetAddrLocal 1
2973: oPushResult
2974: inc
2975: oPop 1
2977: oInputChoice 2985
2979: oJumpForward 2993
2981: oJumpForward 2991
2983: oJumpForward 2991
2985: Choice Lookup Table
           7   2983
           5   2979
2990: oEndChoice
2991: oJumpBack 2882
2993: oCall 1800
2995: oChoice 2999
2997: oJumpForward 3004
2999: Choice Lookup Table
           1   2997
3002: oJumpForward 3006
3004: oJumpBack 2993
3006: oInputChoice 3044
3008: oEmit 0
3010: oSetResult 2
3012: oPushResult
3013: oPatchPushHere
3014: oPop 1
3016: oEmit 25
3018: oGetLocal 1
3020: oPushResult
3021: oCall 3053
3023: oPop 1
3025: oEmit 11
3027: oCall 3097
3029: oReturn
3030: oJumpForward 3050
3032: oEmit 0
3034: oSetResult 2
3036: oPushResult
3037: oPatchPushHere
3038: oPop 1
3040: oEmit 25
3042: oJumpForward 3050
3044: Choice Lookup Table
          16   3032
          15   3008
3049: oEndChoice
3050: oJumpBack 2848
3052: oReturn
3053: oLocalSpace 0
3055: oSetResult 0
3057: oPushResult
3058: oPatchPopFwd
3059: oPop 1
3061: oGetParam 1
3063: oPushResult
3064: oEmitInt
3065: oPop 1
3067: oSetResult 1
3069: oPushResult
3070: oPatchAtMark
3071: oPop 1
3073: oChoice 3089
3075: oSetResult 1
3077: oPushResult
3078: oPatchPopValue
3079: oPop 1
3081: oSetResult 1
3083: oPushResult
3084: oPatchPopBack
3085: oPop 1
3087: oJumpForward 3094
3089: Choice Lookup Table
           0   3075
3092: oJumpForward 3096
3094: oJumpBack 3067
3096: oReturn
3097: oLocalSpace 0
3099: oSetResult 2
3101: oPushResult
3102: oPatchAtMark
3103: oPop 1
3105: oChoice 3115
3107: oSetResult 2
3109: oPushResult
3110: oPatchPopFwd
3111: oPop 1
3113: oJumpForward 3120
3115: Choice Lookup Table
           0   3107
3118: oJumpForward 3122
3120: oJumpBack 3099
3122: oReturn
3123: oLocalSpace 0
3125: oSetResult 3
3127: oPushResult
3128: oPatchAnyEntries
3129: oPop 1
3131: oChoice 3141
3133: oSetResult 3
3135: oPushResult
3136: oPatchPopCall
3137: oPop 1
3139: oJumpForward 3146
3141: Choice Lookup Table
           1   3133
3144: oJumpForward 3148
3146: oJumpBack 3125
3148: oReturn
3149: oLocalSpace 1
3151: oGetAddrLocal 1
3153: oPushResult
3154: oGetGlobal 10
3156: oPushResult
3157: oSetResult 2
3159: oPushResult
3160: oNodeGet
3161: oPop 2
3163: oAssign
3164: oGetLocal 1
3166: oPushResult
3167: oNodeNull
3168: oPop 1
3170: oChoice 3178
3172: oJumpForward 3234
3174: oJumpForward 3184
3176: oJumpForward 3184
3178: Choice Lookup Table
           0   3176
           1   3172
3183: oEndChoice
3184: oGetLocal 1
3186: oPushResult
3187: oNodeType
3188: oPop 1
3190: oChoice 3223
3192: oGetLocal 1
3194: oPushResult
3195: oSetResult 8
3197: oPushResult
3198: oNodeGetBoolean
3199: oPop 2
3201: oChoice 3218
3203: oGetLocal 1
3205: oPushResult
3206: oSetResult 3
3208: oPushResult
3209: oNodeGetInt
3210: oPop 2
3212: oPushResult
3213: oUndeclaredRule
3214: oPop 1
3216: oJumpForward 3221
3218: Choice Lookup Table
           0   3203
3221: oJumpForward 3226
3223: Choice Lookup Table
          11   3192
3226: oGetAddrLocal 1
3228: oPushResult
3229: oNodeNext
3230: oPop 1
3232: oJumpBack 3164
3234: oReturn
3235: oLocalSpace 1
3237: oInputChoice 3520
3239: oGetAddrLocal 1
3241: oPushResult
3242: oScopeFind
3243: oPop 1
3245: oChoice 3404
3247: oGetLocal 1
3249: oPushResult
3250: oNodeType
3251: oPop 1
3253: oChoice 3345
3255: oSetResult 0
3257: oPushResult
3258: oWarning
3259: oPop 1
3261: oGetLocal 1
3263: oPushResult
3264: oCall 2384
3266: oPop 1
3268: oJumpForward 3364
3270: oGetLocal 1
3272: oPushResult
3273: oCall 2179
3275: oPop 1
3277: oJumpForward 3364
3279: oEmit 9
3281: oGetLocal 1
3283: oPushResult
3284: oCall 4183
3286: oPop 1
3288: oJumpForward 3364
3290: oEmit 17
3292: oGetLocal 1
3294: oPushResult
3295: oCall 4199
3297: oPop 1
3299: oJumpForward 3364
3301: oEmit 18
3303: oGetLocal 1
3305: oPushResult
3306: oCall 4199
3308: oPop 1
3310: oJumpForward 3364
3312: oEmit 18
3314: oGetLocal 1
3316: oPushResult
3317: oCall 4199
3319: oPop 1
3321: oJumpForward 3364
3323: oEmit 19
3325: oGetLocal 1
3327: oPushResult
3328: oCall 4199
3330: oPop 1
3332: oJumpForward 3364
3334: oEmit 20
3336: oGetLocal 1
3338: oPushResult
3339: oCall 4199
3341: oPop 1
3343: oJumpForward 3364
3345: Choice Lookup Table
          18   3334
          17   3323
          16   3312
          15   3301
          14   3290
           8   3279
          10   3270
          11   3255
3362: oError 11
3364: oGetParam 1
3366: oPushResult
3367: oGetLocal 1
3369: oPushResult
3370: oSetResult 5
3372: oPushResult
3373: oNodeGet
3374: oPop 2
3376: oAssign
3377: oGetFromParam 1
3379: oPushResult
3380: oNodeNull
3381: oPop 1
3383: oChoice 3389
3385: oError 10
3387: oJumpForward 3392
3389: Choice Lookup Table
           1   3385
3392: oJumpForward 3410
3394: oGetParam 1
3396: oPushResult
3397: oSetResult 0
3399: oAssign
3400: oError 17
3402: oJumpForward 3410
3404: Choice Lookup Table
           0   3394
           1   3247
3409: oEndChoice
3410: oJumpForward 3530
3412: oInput 0
3414: oGetAddrLocal 1
3416: oPushResult
3417: oScopeFind
3418: oPop 1
3420: oChoice 3476
3422: oGetLocal 1
3424: oPushResult
3425: oCall 4019
3427: oPop 1
3429: oGetLocal 1
3431: oPushResult
3432: oCall 2384
3434: oPop 1
3436: oGetParam 1
3438: oPushResult
3439: oGetLocal 1
3441: oPushResult
3442: oSetResult 5
3444: oPushResult
3445: oNodeGet
3446: oPop 2
3448: oAssign
3449: oGetFromParam 1
3451: oPushResult
3452: oNodeNull
3453: oPop 1
3455: oChoice 3461
3457: oError 10
3459: oJumpForward 3464
3461: Choice Lookup Table
           1   3457
3464: oJumpForward 3482
3466: oCall 2480
3468: oGetParam 1
3470: oPushResult
3471: oSetResult 0
3473: oAssign
3474: oJumpForward 3482
3476: Choice Lookup Table
           0   3466
           1   3422
3481: oEndChoice
3482: oJumpForward 3530
3484: oInput 1
3486: oEmit 9
3488: TOKEN_VALUE
3489: oPushResult
3490: negate
3491: oPop 1
3493: oPushResult
3494: oEmitInt
3495: oPop 1
3497: oGetParam 1
3499: oPushResult
3500: oGetGlobal 2
3502: oAssign
3503: oJumpForward 3530
3505: oEmit 9
3507: TOKEN_VALUE
3508: oPushResult
3509: oEmitInt
3510: oPop 1
3512: oGetParam 1
3514: oPushResult
3515: oGetGlobal 2
3517: oAssign
3518: oJumpForward 3530
3520: Choice Lookup Table
           1   3505
           3   3484
          17   3412
           0   3239
3529: oEndChoice
3530: oReturn
3531: oLocalSpace 1
3533: oInputChoice 3595
3535: oGetAddrLocal 1
3537: oPushResult
3538: oScopeFind
3539: oPop 1
3541: oChoice 3565
3543: oGetLocal 1
3545: oPushResult
3546: oGetParam 1
3548: oPushResult
3549: oCall 3604
3551: oPop 2
3553: oJumpForward 3571
3555: oGetParam 1
3557: oPushResult
3558: oSetResult 0
3560: oAssign
3561: oError 12
3563: oJumpForward 3571
3565: Choice Lookup Table
           0   3555
           1   3543
3570: oEndChoice
3571: oJumpForward 3603
3573: oInput 1
3575: oGetParam 1
3577: oPushResult
3578: oSetResult 0
3580: oAssign
3581: oError 12
3583: oJumpForward 3603
3585: oGetParam 1
3587: oPushResult
3588: oSetResult 0
3590: oAssign
3591: oError 12
3593: oJumpForward 3603
3595: Choice Lookup Table
           1   3585
           3   3573
           0   3535
3602: oEndChoice
3603: oReturn
3604: oLocalSpace 0
3606: oGetParam 2
3608: oPushResult
3609: oNodeType
3610: oPop 1
3612: oChoice 3669
3614: oEmit 21
3616: oGetParam 2
3618: oPushResult
3619: oCall 4199
3621: oPop 1
3623: oJumpForward 3682
3625: oEmit 17
3627: oGetParam 2
3629: oPushResult
3630: oCall 4199
3632: oPop 1
3634: oJumpForward 3682
3636: oEmit 17
3638: oGetParam 2
3640: oPushResult
3641: oCall 4199
3643: oPop 1
3645: oJumpForward 3682
3647: oEmit 22
3649: oGetParam 2
3651: oPushResult
3652: oCall 4199
3654: oPop 1
3656: oJumpForward 3682
3658: oEmit 23
3660: oGetParam 2
3662: oPushResult
3663: oCall 4199
3665: oPop 1
3667: oJumpForward 3682
3669: Choice Lookup Table
          18   3658
          17   3647
          16   3636
          15   3625
          14   3614
3680: oError 12
3682: oGetParam 1
3684: oPushResult
3685: oGetParam 2
3687: oPushResult
3688: oSetResult 5
3690: oPushResult
3691: oNodeGet
3692: oPop 2
3694: oAssign
3695: oReturn
3696: oLocalSpace 2
3698: oInputChoice 3801
3700: oGetAddrLocal 1
3702: oPushResult
3703: oCall 3887
3705: oPop 1
3707: oGetAddrLocal 2
3709: oPushResult
3710: oGetLocal 1
3712: oPushResult
3713: oSetResult 4
3715: oPushResult
3716: oNodeGetInt
3717: oPop 2
3719: oAssign
3720: oGetParam 1
3722: oPushResult
3723: oGetLocal 1
3725: oPushResult
3726: oSetResult 5
3728: oPushResult
3729: oNodeGet
3730: oPop 2
3732: oAssign
3733: oJumpForward 3811
3735: oInput 1
3737: oGetAddrLocal 2
3739: oPushResult
3740: TOKEN_VALUE
3741: oPushResult
3742: negate
3743: oPop 1
3745: oAssign
3746: oGetParam 1
3748: oPushResult
3749: oGetGlobal 2
3751: oAssign
3752: oJumpForward 3811
3754: oGetAddrLocal 2
3756: oPushResult
3757: TOKEN_VALUE
3758: oAssign
3759: oGetParam 1
3761: oPushResult
3762: oGetGlobal 2
3764: oAssign
3765: oJumpForward 3811
3767: oGetAddrLocal 1
3769: oPushResult
3770: oShortFormLookup
3771: oPop 1
3773: oGetAddrLocal 2
3775: oPushResult
3776: oGetLocal 1
3778: oPushResult
3779: oSetResult 4
3781: oPushResult
3782: oNodeGetInt
3783: oPop 2
3785: oAssign
3786: oGetParam 1
3788: oPushResult
3789: oGetLocal 1
3791: oPushResult
3792: oSetResult 5
3794: oPushResult
3795: oNodeGet
3796: oPop 2
3798: oAssign
3799: oJumpForward 3811
3801: Choice Lookup Table
           2   3767
           1   3754
           3   3735
           0   3700
3810: oEndChoice
3811: oGetLocal 2
3813: oReturn
3814: oReturn
3815: oLocalSpace 2
3817: oGetAddrLocal 2
3819: oPushResult
3820: oGetAddrLocal 1
3822: oPushResult
3823: oCall 3696
3825: oPop 1
3827: oAssign
3828: oGetLocal 1
3830: oPushResult
3831: oCall 4141
3833: oPop 1
3835: oGetLocal 2
3837: oReturn
3838: oReturn
3839: oLocalSpace 0
3841: oGetParam 1
3843: oPushResult
3844: oScopeFindRequire
3845: oPop 1
3847: oGetFromParam 1
3849: oPushResult
3850: oCall 3919
3852: oPop 1
3854: oReturn
3855: oLocalSpace 0
3857: oGetParam 1
3859: oPushResult
3860: oScopeFindRequire
3861: oPop 1
3863: oGetFromParam 1
3865: oPushResult
3866: oCall 3937
3868: oPop 1
3870: oReturn
3871: oLocalSpace 0
3873: oGetParam 1
3875: oPushResult
3876: oScopeFindRequire
3877: oPop 1
3879: oGetFromParam 1
3881: oPushResult
3882: oCall 3965
3884: oPop 1
3886: oReturn
3887: oLocalSpace 0
3889: oGetParam 1
3891: oPushResult
3892: oScopeFindRequire
3893: oPop 1
3895: oGetFromParam 1
3897: oPushResult
3898: oCall 3983
3900: oPop 1
3902: oReturn
3903: oLocalSpace 0
3905: oGetParam 1
3907: oPushResult
3908: oScopeFindRequire
3909: oPop 1
3911: oGetFromParam 1
3913: oPushResult
3914: oCall 4001
3916: oPop 1
3918: oReturn
3919: oLocalSpace 0
3921: oGetParam 1
3923: oPushResult
3924: oNodeType
3925: oPop 1
3927: oChoice 3931
3929: oJumpForward 3936
3931: Choice Lookup Table
           7   3929
3934: oError 1
3936: oReturn
3937: oLocalSpace 0
3939: oGetParam 1
3941: oPushResult
3942: oSetResult 5
3944: oPushResult
3945: oNodeGet
3946: oPop 2
3948: oPushResult
3949: oGetGlobal 3
3951: oPushResult
3952: oNodeEqual
3953: oPop 2
3955: oChoice 3959
3957: oJumpForward 3964
3959: Choice Lookup Table
           1   3957
3962: oError 3
3964: oReturn
3965: oLocalSpace 0
3967: oGetParam 1
3969: oPushResult
3970: oNodeType
3971: oPop 1
3973: oChoice 3977
3975: oJumpForward 3982
3977: Choice Lookup Table
           5   3975
3980: oError 4
3982: oReturn
3983: oLocalSpace 0
3985: oGetParam 1
3987: oPushResult
3988: oNodeType
3989: oPop 1
3991: oChoice 3995
3993: oJumpForward 4000
3995: Choice Lookup Table
           8   3993
3998: oError 2
4000: oReturn
4001: oLocalSpace 0
4003: oGetParam 1
4005: oPushResult
4006: oNodeType
4007: oPop 1
4009: oChoice 4013
4011: oJumpForward 4018
4013: Choice Lookup Table
           6   4011
4016: oError 6
4018: oReturn
4019: oLocalSpace 0
4021: oGetParam 1
4023: oPushResult
4024: oNodeType
4025: oPop 1
4027: oChoice 4031
4029: oJumpForward 4036
4031: Choice Lookup Table
          11   4029
4034: oError 5
4036: oReturn
4037: oLocalSpace 0
4039: oGetParam 1
4041: oPushResult
4042: oSetResult 5
4044: oPushResult
4045: oNodeGet
4046: oPop 2
4048: oPushResult
4049: oNodeNull
4050: oPop 1
4052: oChoice 4062
4054: oSetResult 1
4056: oPushResult
4057: oWarning
4058: oPop 1
4060: oJumpForward 4065
4062: Choice Lookup Table
           0   4054
4065: oReturn
4066: oLocalSpace 0
4068: oGetParam 2
4070: oPushResult
4071: oSetResult 5
4073: oPushResult
4074: oNodeGet
4075: oPop 2
4077: oPushResult
4078: oGetParam 1
4080: oPushResult
4081: oNodeEqual
4082: oPop 2
4084: oChoice 4088
4086: oJumpForward 4093
4088: Choice Lookup Table
           1   4086
4091: oError 0
4093: oReturn
4094: oLocalSpace 0
4096: oGetParam 2
4098: oPushResult
4099: oGetParam 1
4101: oPushResult
4102: oNodeEqual
4103: oPop 2
4105: oReturn
4106: oReturn
4107: oLocalSpace 0
4109: oGetParam 2
4111: oPushResult
4112: oGetParam 1
4114: oPushResult
4115: oNodeEqual
4116: oPop 2
4118: oChoice 4122
4120: oJumpForward 4127
4122: Choice Lookup Table
           1   4120
4125: oError 0
4127: oReturn
4128: oLocalSpace 0
4130: oGetParam 1
4132: oPushResult
4133: oGetGlobal 2
4135: oPushResult
4136: oNodeEqual
4137: oPop 2
4139: oReturn
4140: oReturn
4141: oLocalSpace 0
4143: oGetParam 1
4145: oPushResult
4146: oGetGlobal 2
4148: oPushResult
4149: oNodeEqual
4150: oPop 2
4152: oChoice 4156
4154: oJumpForward 4161
4156: Choice Lookup Table
           1   4154
4159: oError 0
4161: oReturn
4162: oLocalSpace 0
4164: oGetParam 1
4166: oPushResult
4167: oGetGlobal 3
4169: oPushResult
4170: oNodeEqual
4171: oPop 2
4173: oChoice 4177
4175: oJumpForward 4182
4177: Choice Lookup Table
           1   4175
4180: oError 3
4182: oReturn
4183: oLocalSpace 0
4185: oGetParam 1
4187: oPushResult
4188: oSetResult 4
4190: oPushResult
4191: oNodeGetInt
4192: oPop 2
4194: oPushResult
4195: oEmitInt
4196: oPop 1
4198: oReturn
4199: oLocalSpace 0
4201: oGetParam 1
4203: oPushResult
4204: oSetResult 10
4206: oPushResult
4207: oNodeGetInt
4208: oPop 2
4210: oPushResult
4211: oEmitInt
4212: oPop 1
4214: oReturn
