   0: title: 'SSL Translator 1.2.7 -- June 4 ''91';
      %
      %  ssl.ssl
      %
      %  Amiga Syntax/Semantic Language Processor
      %
      %  HISTORY
      %    31Aug89   Translated from my SSL processor hardcoded in C
      %    08Sep89   SSL processor now functional, except for error recovery
      %    18Oct89   Added 'title' section
      %    03Feb90   Change to ssl.c: Added debugger output
      %    20Mar91   Change to ssl.c: Increased string table size
      %    26Mar91   Fixed bug in handling of statement ">>value".
      %              Fixed bug in handling of choice using a choice rule defined later
      %    24Apr91   Change to ssl.c: Increased identifier size to 50 characters
      %    05May91   Change to ssl.c: Increased identifier table size to 600,
      %              and moved names out of table. New limit 256 chars.
      %              Added "include" feature.
      %    21May91   Multiple "error" sections will use distinct error #'s.
      %              Added postprocess optimization: reduce chains of jumps.
      %    04Jun91   Change to ssl.c: Write rule addresses to code file.
      %
      %  BUGS:
      %    28Jan90   Doesn't complain if functions called but never declared!	
      %
      %  NOTES:
      %   1) 'Kind' always means identifier kind (type, val, etc), not token kind.
      %      The phrase identKind is not used.
      %   2) Emitted values are written into a table rather than a file.
      %      The semantic mechanism Patch is able to modify values that have been
      %      previously emitted (i.e. labels).
      %   3) All mechanisms have hardcoded initialization routines which
      %      don't have to be listed here.  For example, stack pointers are
      %      set to 0, the symbol table is initialized with the predefined
      %      names, and so on.
      %   4) The scanner/screener maintains an identifier table, with extra
      %      fields set aside for this processor access via the Ident mechanism.
      %      There is no separate symbol table.
      %   5) Information on the 'last ident read' is valid until another ident
      %      is read.
      %   6) The base counter in the count stack counts semantic operations.
      %   7) When a new identifier is added to the table by the scanner,
      %      it is given a default kind kUnknown.
      %   8) Stack entries that are read by an operation are left there,
      %      unless the operation contains the word 'Pop'.
      %      The emit statement never pops stack entries (i.e. .iConstant
      %      emits the value on the value stack, but does not pop it.)
      %
      
   0: input:
   0:    pIdent
   0:    pIntLit
   0:    pStrLit
   0:    pEquals     '='
   0:    pColon      ':'
   0:    pSemiColon  ';'
   0:    pComma      ','
   0:    pLParen     '('
   0:    pRParen     ')'
   0:    pReturn     '>>'
   0:    pBreak      '>'
   0:    pLCurly     '{'
   0:    pRCurly     '}'
   0:    pLSquare    '['
   0:    pRSquare    ']'
   0:    pBar        '|'
   0:    pCall       '@'
   0:    pEmit       '.'
   0:    pStar       '*'
   0:    pErr        '#'
   0:    pQuestion   '?'
   0:    pEof
   0:    pInvalid
      
      %  keywords
      
   0:    pTitle
   0:    pInput
   0:    pOutput
   0:    pType
   0:    pError
   0:    pMechanism
   0:    pInclude
   0:    pRules
   0:    pEnd;
      
      
   0: output:
      
      %  codes for SSL machine instructions
      
   0:    iJumpForward
   0:    iJumpBack
   0:    iInput
   0:    iInputAny
   0:    iEmit
   0:    iError
   0:    iInputChoice
   0:    iCall
   0:    iReturn
   0:    iSetResult
   0:    iChoice
   0:    iEndChoice
   0:    iSetParameter
      
      %  other output
      
   0:    iSpace           % emit a dummy value; a value will be patched here later
   0:    iConstant        % emit the value on the value stack
   0:    iIdentVal        % emit the value of the last ident
   0:    iIdentISVal;     % emit the value of the ident on the ident stack
      
   0: error:
   0:    eMissingProgramBlock
   0:    eMissingEnd
   0:    eWrongType
   0:    eNoShortFormHere
   0:    eNotAType
   0:    eNotAVal
   0:    eNotInput
   0:    eNotOutput
   0:    eNotARule
   0:    eNotOpRule
   0:    eUndeclaredIdent
   0:    eBadStatement
   0:    eNotAnErrSig
   0:    eNotInLoop
   0:    eNotChoice     % rule or op
   0:    eChoiceRuleOutOfPlace
   0:    eChoiceOpOutOfPlace;
      
   0: type boolean:
   0:    false    = 0
   0:    true     = 1;
      
   0: type number:
   0:    zero            = 0
   0:    one             = 1
   0:    numberSystemOps = 14;   % # for the first user operation
      
   0: type kind:
   0:    kIllegal        % not an identifier
   0:    kUnknown        % new identifier
   0:    kInput
   0:    kOutput
   0:    kError
   0:    kType
   0:    kVal            % an element of a type
   0:    kMech
   0:    kOp
   0:    kRule;
      
   0: mechanism count:
   0:    oCountPush(number)        % push a new counter, with initial value
   0:    oCountPushIntLit          % push value of integer just read
   0:    oCountPop                 % discard counter
   0:    oCountInc
   0:    oCountDec
   0:    oCountZero >> boolean;    % is the top counter 0?
      
   0: mechanism next_error:                % variable to determine error #
   0:    oNextErrorPushCount               % push variable onto Count stack
   0:    oNextErrorPopCount;               % pop variable off Count stack
      
      
   0: mechanism value:                     % multi-purpose stack
   0:    oValuePushKind(kind)              % push a kind value
   0:    oValuePushVal                     % push value of last ident read
   0:    oValuePushISVal                   % value of ident on ident stack
   0:    oValuePushIdent                   % push ident# of last ident read
   0:    oValuePushType                    % push type of last ident read
   0:    oValueChooseKind >> kind          % kind on top of stack
   0:    oValuePushCount                   % value on top of count stack
   0:    oValueSwap                        % swap top two elements
   0:    oValuePop;
      
      % keep different patch stacks, each with a stack of position markers:
      
   0: type patchStack:
   0:    patchChoiceTableAddr    % addr where pointer to table is stored
   0:    patchChoiceTable        % build up choice table here (value,addr)
   0:    patchChoiceExit         % addrs where jumps at end of each option are
   0:    patchCall               % (addr,ident) where calls to undefined rules are
   0:    patchLoop               % addr of start of a loop
   0:    patchBreak;             % addrs where jumps out of a loop are
      
   0: mechanism patch:
   0:    oPatchMark(patchStack)             % mark current position on a stack
   0:    oPatchAtMark(patchStack) >> boolean     % true if all items since
                                                 %   last mark are popped
                                                 %   (mark is dropped if true)
   0:    oPatchPushHere(patchStack)         % put current address on a patch stack
   0:    oPatchPushIdent(patchStack)        % put last ident on a patch stack
   0:    oPatchPushValue(patchStack)        % push value on value stack
   0:    oPatchAnyEntries(patchStack) >> boolean    % are there any entries?
   0:    oPatchPopFwd(patchStack)           % fix table, storing here-x at x,
                                            %   where x is on top of the stack
   0:    oPatchPopBack(patchStack)          % emit here-x here (advance 'here')
   0:    oPatchPopValue(patchStack)         % emit x here (advance 'here')
   0:    oPatchPopCall(patchStack);         % fix table, storing value of ident i
                                            %   at x, where i is on top of stack
                                            %   and x is under it  (pop both)
   0: mechanism shortForm:   % keep a table of string shortforms for input/output
   0:    oShortFormAdd       % add current StrLit token, with last ident read
   0:    oShortFormLookup;   % look up strLit, push equiv ident on ident stack
      
   0: mechanism ident:
      
         % these work on the last ident read:
      
   0:    oIdentSetDeclared         % declared = true  (err if was already true)
   0:    oIdentSetKind(kind)       % kind = kind specified
   0:    oIdentSetKindVS           % kind = kind on value stack
   0:    oIdentSetType             % type = type on value stack
   0:    oIdentSetValCount         % val = integer on count stack
   0:    oIdentSetValHere          % val = current address
   0:    oIdentSetChoice(boolean)  % choice flag = true/false
   0:    oIdentChooseKind >> kind  % returns the kind of the last ident
   0:    oIdentChooseParam >> boolean
   0:    oIdentChooseChoice >> boolean
   0:    oIdentChooseDeclared >> boolean
   0:    oIdentMatchType >> boolean  % does the type of the last ident equal
                                     %   the type of the ident on the IS stack?
   0:    oIdentMatchParamType >> boolean  % does the type of the last ident equal
                                          %   the param type of the ident on IS?
      
         % these maintain an ident stack (IS) to be used with the ops below:
         %   (and some ops in other mechanisms)
      
   0:    oIdentISPush                  % remember index of last ident read
   0:    oIdentISPushBottom            % push id in bottom of IS to top (kludge to get rule type)
   0:    oIdentISPop                   % drop top stack entry
      
         % these work on the ident whose index is on top of the ident stack:
      
   0:    oIdentSetISParamType          % sets the param type from the value stack
   0:    oIdentSetISParam              % sets the param flag
   0:    oIdentSetISChoice(boolean)    % sets the choice flag
   0:    oIdentSetISType               % sets the rule/op type from the value stack
   0:    oIdentChooseISKind >> kind    % returns the ident's kind
   0:    oIdentChooseISChoice >> boolean
   0:    oIdentChooseISParam >> boolean
   0:    oIdentMatchISType >> boolean; % do the types of the top 2 idents match?
      
   0: mechanism titleMech:
   0:    oTitleSet;          % define title to be strlit just read
      
   0: mechanism doc:         % display documentary info
   0:    oDocNewRule         % print "Rule <token>"
   0:    oDocCheckpoint;     % display current pc value, for debugging
      
   0: mechanism include_mech:
   0:    oInclude;           % include the SSL file whose name is in the
                             % string token just accepted
      
   0: rules
      
   0: ProcessSSL:
      
   0:    oCountPush(zero)                % set variable to track error #
   3:    oNextErrorPopCount
      
   4:    oCountPush(numberSystemOps)     % this counter is used to
                                         %   give code #'s to semantic operations
   7:    {[
   9:       | pTitle :
   9:          ':'
  11:          pStrLit
  13:          oTitleSet
  14:          ';'
  16:       | pInput :
  18:          oValuePushKind(kInput)
  21:          oCountPush(zero)
  24:          @ReadIdList
  26:          oCountPop
  27:          oValuePop
  28:       | pOutput :
  30:          oValuePushKind(kOutput)
  33:          oCountPush(zero)
  36:          @ReadIdList
  38:          oCountPop
  39:          oValuePop
  40:       | pError :
  42:          oValuePushKind(kError)
  45:          oNextErrorPushCount
  46:          @ReadIdList
  48:          oNextErrorPopCount
  49:          oValuePop
  50:       | pType :
  52:          pIdent
  54:          oIdentSetDeclared
  55:          oIdentSetKind(kType)
  58:          oValuePushIdent          % type #
  59:          oIdentSetType            % record it in itself
  60:          oValuePushIdent          % type #, for following values
  61:          oValuePushKind(kVal)
  64:          oCountPush(zero)
  67:          @ReadIdList
  69:          oCountPop
  70:          oValuePop
  71:          oValuePop
  72:       | pInclude :
  74:          pStrLit
  76:          oInclude
  77:       | pMechanism :
  79:          pIdent
  81:          oIdentSetDeclared
  82:          oIdentSetKind(kMech)
  85:          ':'
  87:          {[
  89:             | pIdent :
  89:                @OpDefinition
  91:             | * :
  96:                >
  98:          ]}
 100:          ';'
 102:       | pRules :
 104:          {[
 106:             | pIdent :
 106:                oDocNewRule
 107:                @RuleDefinition
 109:             | pEnd :
 111:                >
 113:          ]}
 123:       | pEof :
 125:          >
 127:       | * :
 148:          #eMissingProgramBlock
 150:          ?      % skip token, try again
 151:    ]}
 153:    @FixForwardCalls
 155:    oCountPop;
      
 157: ReadIdList:     % initial # to use is on count stack
 157:    ':'
 159:    {[
 161:       | pIdent :
 161:          oIdentSetDeclared
 162:          oIdentSetKindVS            % from kind on value stack
 163:          [ oValueChooseKind
 166:             | kVal :
 166:                 oValueSwap         % type # to top
 167:                 oIdentSetType
 168:                 oValueSwap
 169:             | * :
 174:          ]
 174:          [
 176:             | pStrLit :
 176:                [ oValueChooseKind
 179:                   | kInput, kOutput :
 179:                      oShortFormAdd
 180:                   | * :
 187:                      #eNoShortFormHere
 189:                      ?
 190:                ]
 190:             | * :
 195:          ]
 195:          [
 197:             | '=' :
 197:                pIntLit
 199:                oCountPop          % replace counter with new integer
 200:                oCountPushIntLit
 201:             | * :
 206:          ]
 206:          oIdentSetValCount   % set value from count stack
 207:          oCountInc
 208:       | * :
 213:          >
 215:    ]}
 217:    ';';
      
      
 220: OpDefinition:
 220:    oIdentSetDeclared
 221:    oIdentISPush          % remember ident, to set types
 222:    oIdentSetKind(kOp)
 225:    oIdentSetValCount     % store operation# from counter
 226:    oCountInc
 227:    [
 229:       | '(' :
 229:          pIdent
 231:          [ oIdentChooseKind
 234:             | kType :
 234:                oValuePushIdent
 235:                oIdentSetISParamType
 236:                oValuePop
 237:                oIdentSetISParam
 238:             | * :
 243:                #eNotAType
 245:          ]
 245:          ')'
 247:       | * :
 252:    ]
 252:    [
 254:       | '>>' :
 254:          oIdentSetISChoice(true)
 257:          pIdent
 259:          [ oIdentChooseKind
 262:             | kType :
 262:                oValuePushIdent
 263:                oIdentSetISType
 264:                oValuePop
 265:             | * :
 270:                #eNotAType
 272:          ]
 272:       | * :
 277:          oIdentSetISChoice(false)
 280:    ]
 280:    oIdentISPop;
      
      
 282: RuleDefinition:
 282:    oIdentISPush          % remember rule ident throughout.  IT WILL SIT ON
                               % BOTTOM OF IS STACK (choice rules will push above it)
                               % (access from bottom is a kludge... should use a
                               % separate stack to remember the rule id)
 283:    oIdentSetDeclared
 284:    oIdentSetKind(kRule)
 287:    oIdentSetValHere      % address = here
 288:    [
 290:       | '>>' :
 290:          oIdentSetChoice(true)
 293:          pIdent
 295:          [ oIdentChooseKind
 298:             | kType :
 298:                oValuePushIdent
 299:                oIdentSetISType
 300:                oValuePop
 301:             | * :
 306:                #eNotAType
 308:          ]
 308:       | * :
 313:          oIdentSetChoice(false)
 316:    ]
 316:    ':'
 318:    {[
 320:       | ';' :
 320:          >
 322:       | * :
 327:          @Statement
 329:    ]}
 331:    .iReturn
 333:    oIdentISPop;
      
      
 335: Statement:
 335:    [
 337:       | pStrLit :
 337:          oShortFormLookup       % push index of equivalent ident
 338:          @InputOrOpPop          % actually, should only be input
 340:       | pIdent :
 342:          oIdentISPush
 343:          @InputOrOpPop
 345:       | pErr :
 347:          pIdent
 349:          [ oIdentChooseKind
 352:             | kError :
 352:                .iError
 354:                .iIdentVal
 356:             | * :
 361:                #eNotAnErrSig
 363:          ]
 363:       | pEmit :
 365:          [
 367:             | pIdent :
 367:                oIdentISPush
 368:             | pStrLit :
 370:                oShortFormLookup   % push ident on IS stack
 371:          ]
 379:          [ oIdentChooseISKind
 382:             | kOutput :
 382:                .iEmit
 384:                .iIdentISVal
 386:             | * :
 391:                #eNotOutput
 393:          ]
 393:          oIdentISPop
 394:       | pCall :
 396:          pIdent
 398:          [ oIdentChooseDeclared
 401:             | true :
 401:                [ oIdentChooseKind
 404:                   | kRule :
 404:                      [ oIdentChooseChoice
 407:                         | false :
 407:                            .iCall
 409:                            .iIdentVal
 411:                         | true :
 413:                            #eChoiceRuleOutOfPlace
 415:                      ]
 423:                   | * :
 428:                      #eNotARule
 430:                ]
 430:             | false :                 % rule used before declared
 432:                oIdentSetKind(kRule)   % don't set declared flag yet
 435:                .iCall
 437:                oPatchPushHere(patchCall)    % fix up at end
 440:                oPatchPushIdent(patchCall)
 443:                .iSpace
 445:          ]
 453:       | pReturn :
 455:          oIdentISPushBottom     % check type of current rule (bottom of IS)
 456:          [ oIdentChooseISChoice
 459:             | true :
 459:                pIdent
 461:                [ oIdentChooseKind
 464:                   | kVal :
 464:                      [ oIdentMatchType
 467:                         | true :
 467:                            .iSetResult
 469:                            .iIdentVal
 471:                         | false :
 473:                            #eWrongType
 475:                      ]
 483:                   | * :
 488:                      #eWrongType
 490:                ]
 490:             | false :
 492:          ]
 500:          oIdentISPop
 501:          .iReturn
 503:       | pLCurly :
 505:          oPatchPushHere(patchLoop)   % remember start of loop
 508:          oPatchMark(patchBreak)
 511:          {[
 513:             | pRCurly :    % *** WAS *** '}' :
 513:                >
 515:             | * :
 520:                @Statement
 522:          ]}
 524:          .iJumpBack
 526:          oPatchPopBack(patchLoop)
 529:          {[ oPatchAtMark(patchBreak)      % fix up break statements
 534:             | false :
 534:                oPatchPopFwd(patchBreak)
 537:             | true :
 539:                >
 541:          ]}
 551:       | pBreak :
 553:          [ oPatchAnyEntries(patchLoop)
 558:             | true :
 558:                .iJumpForward
 560:                oPatchPushHere(patchBreak)
 563:                .iSpace
 565:             | false :
 567:                #eNotInLoop
 569:          ]
 577:       | pLSquare :
 579:          @Choice
 581:       | pQuestion :
 583:          .iInputAny
 585:       | * :
 608:          #eBadStatement
 610:          ?
 611:    ];
      
 612: InputOrOpPop:        % ident is on ident stack (pop when done)
 612:    [ oIdentChooseISKind
 615:       | kInput :
 615:          .iInput
 617:          .iIdentISVal
 619:       | kOp :
 621:          @CallOp
 623:          [ oIdentChooseISChoice
 626:             | true :
 626:                #eChoiceOpOutOfPlace
 628:             | * :
 633:          ]
 633:       | kUnknown :
 635:          #eUndeclaredIdent
 637:       | * :
 646:          #eNotOpRule
 648:    ]
 648:    oIdentISPop;
      
 650: CallOp:                  % op ident on ident stack
 650:    [ oIdentChooseISParam
 653:       | true :
 653:          '('
 655:          pIdent
 657:          [ oIdentChooseKind
 660:             | kVal :
 660:                [ oIdentMatchParamType
 663:                   | true :
 663:                      .iSetParameter
 665:                      .iIdentVal
 667:                   | false :
 669:                      #eWrongType
 671:                ]
 679:             | * :
 684:                #eWrongType
 686:          ]
 686:          ')'
 688:       | * :
 693:    ]
 693:    .iIdentISVal;     % operation #
      
      
 696: Choice:
 696:    [
 698:       | pIdent :                     % rule/op choice
 698:          oIdentISPush                % remember type of options
 699:          [ oIdentChooseDeclared
 702:             | true :
 702:                [ oIdentChooseKind
 705:                   | kRule :
 705:                      .iCall
 707:                      .iIdentVal
 709:                   | kOp :
 711:                      @CallOp
 713:                   | * :
 720:                      #eNotOpRule
 722:                ]
 722:                [ oIdentChooseISChoice
 725:                   | false :
 725:                      #eNotChoice
 727:                   | * :
 732:                ]
 732:                oValuePushKind(kType)  % flag that IS has option type
 735:             | false :                 % rule used before declared
 737:                oIdentSetKind(kRule)   % don't set declared flag yet
 740:                .iCall
 742:                oPatchPushHere(patchCall)    % fix up call at end
 745:                oPatchPushIdent(patchCall)
 748:                .iSpace
 750:                oValuePushKind(kUnknown)  % flag that option type unknown
 753:          ]
 761:          .iChoice
 763:       | * :
 768:          oValuePushKind(kInput)  % flag that options should be input tokens
 771:          oIdentISPush            % DUMMY: push entry so can pop later
 772:          .iInputChoice           %        regardless of input/rule choice
 774:    ]
 774:    oPatchPushHere(patchChoiceTableAddr)  % addr of table will go here
 777:    .iSpace
 779:    oPatchMark(patchChoiceTable)    % build up choice table in this stack
 782:    oPatchMark(patchChoiceExit)     % remember ends of each option
 785:    oCountPush(zero)                % count the options
 788:    '|'
 790:    {
 790:       [
 792:          | '*' :       % default code (must be last option)
 792:             ':'
 794:             @CopyChoiceTable
 796:             oCountPop
 797:             oValuePop
 798:             oIdentISPop
 799:             {[
 801:                | ']' :
 801:                   >
 803:                | * :
 808:                   @Statement
 810:             ]}
 812:             @FixChoiceExits
 814:             >>
 815:          | * :         % option(s)
 820:             {
 820:                [ oValueChooseKind
 823:                   | kType :           % rule/op choice
 823:                      pIdent
 825:                      [ oIdentChooseKind
 828:                         | kVal :
 828:                            [ oIdentMatchType
 831:                               | false :
 831:                                  #eWrongType
 833:                               | * :
 838:                            ]
 838:                         | * :
 843:                            #eNotAVal
 845:                      ]
 845:                      oValuePushVal    % value# of option
 846:                   | kUnknown :        % rule, not yet defined
 848:                      pIdent
 850:                      [ oIdentChooseKind
 853:                         | kVal :
 853:                            oValuePushType   % now know type of rule
 854:                            oIdentSetISType
 855:                            oValuePop
 856:                            oValuePop        % replace flag
 857:                            oValuePushKind(kType)   % flag that IS has type
 860:                         | * :
 865:                            #eNotAVal
 867:                      ]
 867:                      oValuePushVal    % value# of option
 868:                   | kInput :
 870:                      [
 872:                         | pIdent :
 872:                            oIdentISPush
 873:                         | pStrLit :
 875:                            oShortFormLookup
 876:                      ]
 884:                      [ oIdentChooseISKind
 887:                         | kInput :
 887:                         | * :
 892:                            #eNotInput
 894:                      ]
 894:                      oValuePushISVal  % value# of option
 895:                      oIdentISPop
 896:                ]
                     % value of option is now on value stack
 906:                oPatchPushHere(patchChoiceTable)
 909:                oPatchPushValue(patchChoiceTable)  % build choice table
 912:                oValuePop
 913:                oCountInc
 914:                [
 916:                   | ':' :
 916:                      >
 918:                   | ',' :   % go around and get another
 920:                ]
 928:             }
 930:       ]
      
            % code for option:
      
 930:       {[
 932:          | '|' :      % more options follow
 932:             .iJumpForward
 934:             oPatchPushHere(patchChoiceExit)
 937:             .iSpace
 939:             >
 941:          | ']' :      % end of choice, no default
 943:             .iJumpForward
 945:             oPatchPushHere(patchChoiceExit)
 948:             .iSpace
 950:             @CopyChoiceTable
 952:             oCountPop      % #options
 953:             oValuePop      % flag: input/rule choice
 954:             oIdentISPop    % type of rule choice (dummy if input choice)
 955:             .iEndChoice
 957:             @FixChoiceExits
 959:             >>
 960:          | * :
 967:             @Statement
 969:       ]}
 971:    };
      
      
      % Install choice table here. #options is in top counter.
      % Note, the order of the options is opposite that in the source file.
      % So, in error recovery in a choice with no otherwise, take the
      % option just before the oEndChoice.
      
 974: CopyChoiceTable:
 974:    oPatchPopFwd(patchChoiceTableAddr)   % fix pointer to table
 977:    oValuePushCount   % #entries
 978:    .iConstant        % emit value
 980:    oValuePop
 981:    {[ oPatchAtMark(patchChoiceTable)
 986:       | true :
 986:          >
 988:       | * :
 993:          oPatchPopValue(patchChoiceTable)
 996:          oPatchPopBack(patchChoiceTable)
 999:    ]};
      
      
1002: FixChoiceExits:
1002:    {[ oPatchAtMark(patchChoiceExit)     % fix jumps from end of each option
1007:       | false :                         %    to end of the choice
1007:          oPatchPopFwd(patchChoiceExit)
1010:       | * :
1015:          >
1017:    ]};
      
1020: FixForwardCalls:
1020:    {[ oPatchAnyEntries(patchCall)
1025:       | true :
1025:          oPatchPopCall(patchCall)
1028:       | * :
1033:          >
1035:    ]};
      
      
1038: end
      
1038: 
