   0: title: 'SSL Translator 1.2.8 -- August 23 ''93';
      %
      %  ssl.ssl
      %
      %  Amiga Syntax/Semantic Language Processor
      %
      %  HISTORY
      %    31Aug89   Translated from my SSL processor hardcoded in C
      %    08Sep89   SSL processor now functional, except for error recovery
      %    18Oct89   Added 'title' section
      %    03Feb90   Change to ssl.c: Added debugger output
      %    20Mar91   Change to ssl.c: Increased string table size
      %    26Mar91   Fixed bug in handling of statement ">>value".
      %              Fixed bug in handling of choice using a choice rule defined later
      %    24Apr91   Change to ssl.c: Increased identifier size to 50 characters
      %    05May91   Change to ssl.c: Increased identifier table size to 600,
      %              and moved names out of table. New limit 256 chars.
      %              Added "include" feature.
      %    21May91   Multiple "error" sections will use distinct error #'s.
      %              Added postprocess optimization: reduce chains of jumps.
      %    04Jun91   Change to ssl.c: Write rule addresses to code file.
      %    23Aug93   Fix some loops so error recovery can terminate.
      %
      %  BUGS:
      %    28Jan90   Doesn't complain if functions called but never declared!	
      %
      %  NOTES:
      %   1) 'Kind' always means identifier kind (type, val, etc), not token kind.
      %      The phrase identKind is not used.
      %   2) Emitted values are written into a table rather than a file.
      %      The semantic mechanism Patch is able to modify values that have been
      %      previously emitted (i.e. labels).
      %   3) All mechanisms have hardcoded initialization routines which
      %      don't have to be listed here.  For example, stack pointers are
      %      set to 0, the symbol table is initialized with the predefined
      %      names, and so on.
      %   4) The scanner/screener maintains an identifier table, with extra
      %      fields set aside for this processor access via the Ident mechanism.
      %      There is no separate symbol table.
      %   5) Information on the 'last ident read' is valid until another ident
      %      is read.
      %   6) The base counter in the count stack counts semantic operations.
      %   7) When a new identifier is added to the table by the scanner,
      %      it is given a default kind kUnknown.
      %   8) Stack entries that are read by an operation are left there,
      %      unless the operation contains the word 'Pop'.
      %      The emit statement never pops stack entries (i.e. .iConstant
      %      emits the value on the value stack, but does not pop it.)
      %
      
   0: input:
   0:    pIdent
   0:    pIntLit
   0:    pStrLit
   0:    pMinus      '-'
   0:    pEquals     '='
   0:    pColon      ':'
   0:    pSemiColon  ';'
   0:    pComma      ','
   0:    pLParen     '('
   0:    pRParen     ')'
   0:    pReturn     '>>'
   0:    pBreak      '>'
   0:    pLCurly     '{'
   0:    pRCurly     '}'
   0:    pLSquare    '['
   0:    pRSquare    ']'
   0:    pBar        '|'
   0:    pCall       '@'
   0:    pEmit       '.'
   0:    pStar       '*'
   0:    pErr        '#'
   0:    pQuestion   '?'
   0:    pEof
   0:    pInvalid
      
      %  keywords
      
   0:    pTitle
   0:    pInput
   0:    pOutput
   0:    pType
   0:    pError
   0:    pMechanism
   0:    pInclude
   0:    pRules
   0:    pEnd;
      
      
   0: output:
      
      %  codes for SSL machine instructions
      
   0:    iJumpForward
   0:    iJumpBack
   0:    iInput
   0:    iInputAny
   0:    iEmit
   0:    iError
   0:    iInputChoice
   0:    iCall
   0:    iReturn
   0:    iSetResult
   0:    iChoice
   0:    iEndChoice
   0:    iSetParameter
      
      %  other output
      
   0:    iSpace           % emit a dummy value; a value will be patched here later
   0:    iConstant        % emit the value on the value stack
   0:    iIdentVal        % emit the value of the last ident
   0:    iIdentISVal;     % emit the value of the ident on the ident stack
      
   0: error:
   0:    eMissingProgramBlock
   0:    eMissingEnd
   0:    eWrongType
   0:    eNoShortFormHere
   0:    eNotAType
   0:    eNotAVal
   0:    eNotInput
   0:    eNotOutput
   0:    eNotARule
   0:    eNotOpRule
   0:    eUndeclaredIdent
   0:    eBadStatement
   0:    eNotAnErrSig
   0:    eNotInLoop
   0:    eNotChoice     % rule or op
   0:    eChoiceRuleOutOfPlace
   0:    eChoiceOpOutOfPlace;
      
   0: type boolean:
   0:    false    = 0
   0:    true     = 1;
      
   0: type number:
   0:    zero            = 0
   0:    one             = 1
   0:    numberSystemOps = 14;   % # for the first user operation
      
   0: type kind:
   0:    kIllegal        % not an identifier
   0:    kUnknown        % new identifier
   0:    kInput
   0:    kOutput
   0:    kError
   0:    kType
   0:    kVal            % an element of a type
   0:    kMech
   0:    kOp
   0:    kRule;
      
   0: mechanism count:
   0:    oCountPush(number)        % push a new counter, with initial value
   0:    oCountPushIntLit          % push value of integer just read
   0:    oCountPop                 % discard counter
   0:    oCountInc
   0:    oCountDec
   0:    oCountNegate              % negate top counter
   0:    oCountZero >> boolean;    % is the top counter 0?
      
   0: mechanism next_error:                % variable to determine error #
   0:    oNextErrorPushCount               % push variable onto Count stack
   0:    oNextErrorPopCount;               % pop variable off Count stack
      
      
   0: mechanism value:                     % multi-purpose stack
   0:    oValuePushKind(kind)              % push a kind value
   0:    oValuePushVal                     % push value of last ident read
   0:    oValuePushISVal                   % value of ident on ident stack
   0:    oValuePushIdent                   % push ident# of last ident read
   0:    oValuePushType                    % push type of last ident read
   0:    oValueChooseKind >> kind          % kind on top of stack
   0:    oValuePushCount                   % value on top of count stack
   0:    oValueSwap                        % swap top two elements
   0:    oValuePop;
      
      % keep different patch stacks, each with a stack of position markers:
      
   0: type patchStack:
   0:    patchChoiceTableAddr    % addr where pointer to table is stored
   0:    patchChoiceTable        % build up choice table here (value,addr)
   0:    patchChoiceExit         % addrs where jumps at end of each option are
   0:    patchCall               % (addr,ident) where calls to undefined rules are
   0:    patchLoop               % addr of start of a loop
   0:    patchBreak;             % addrs where jumps out of a loop are
      
   0: mechanism patch:
   0:    oPatchMark(patchStack)             % mark current position on a stack
   0:    oPatchAtMark(patchStack) >> boolean     % true if all items since
                                                 %   last mark are popped
                                                 %   (mark is dropped if true)
   0:    oPatchPushHere(patchStack)         % put current address on a patch stack
   0:    oPatchPushIdent(patchStack)        % put last ident on a patch stack
   0:    oPatchPushValue(patchStack)        % push value on value stack
   0:    oPatchAnyEntries(patchStack) >> boolean    % are there any entries?
   0:    oPatchPopFwd(patchStack)           % fix table, storing here-x at x,
                                            %   where x is on top of the stack
   0:    oPatchPopBack(patchStack)          % emit here-x here (advance 'here')
   0:    oPatchPopValue(patchStack)         % emit x here (advance 'here')
   0:    oPatchPopCall(patchStack);         % fix table, storing value of ident i
                                            %   at x, where i is on top of stack
                                            %   and x is under it  (pop both)
   0: mechanism shortForm:   % keep a table of string shortforms for input/output
   0:    oShortFormAdd       % add current StrLit token, with last ident read
   0:    oShortFormLookup;   % look up strLit, push equiv ident on ident stack
      
   0: mechanism ident:
      
         % these work on the last ident read:
      
   0:    oIdentSetDeclared         % declared = true  (err if was already true)
   0:    oIdentSetKind(kind)       % kind = kind specified
   0:    oIdentSetKindVS           % kind = kind on value stack
   0:    oIdentSetType             % type = type on value stack
   0:    oIdentSetValCount         % val = integer on count stack
   0:    oIdentSetValHere          % val = current address
   0:    oIdentSetChoice(boolean)  % choice flag = true/false
   0:    oIdentChooseKind >> kind  % returns the kind of the last ident
   0:    oIdentChooseParam >> boolean
   0:    oIdentChooseChoice >> boolean
   0:    oIdentChooseDeclared >> boolean
   0:    oIdentMatchType >> boolean  % does the type of the last ident equal
                                     %   the type of the ident on the IS stack?
   0:    oIdentMatchParamType >> boolean  % does the type of the last ident equal
                                          %   the param type of the ident on IS?
      
         % these maintain an ident stack (IS) to be used with the ops below:
         %   (and some ops in other mechanisms)
      
   0:    oIdentISPush                  % remember index of last ident read
   0:    oIdentISPushBottom            % push id in bottom of IS to top (kludge to get rule type)
   0:    oIdentISPop                   % drop top stack entry
      
         % these work on the ident whose index is on top of the ident stack:
      
   0:    oIdentSetISParamType          % sets the param type from the value stack
   0:    oIdentSetISParam              % sets the param flag
   0:    oIdentSetISChoice(boolean)    % sets the choice flag
   0:    oIdentSetISType               % sets the rule/op type from the value stack
   0:    oIdentChooseISKind >> kind    % returns the ident's kind
   0:    oIdentChooseISChoice >> boolean
   0:    oIdentChooseISParam >> boolean
   0:    oIdentMatchISType >> boolean; % do the types of the top 2 idents match?
      
   0: mechanism titleMech:
   0:    oTitleSet;          % define title to be strlit just read
      
   0: mechanism doc:         % display documentary info
   0:    oDocNewRule         % print "Rule <token>"
   0:    oDocCheckpoint;     % display current pc value, for debugging
      
   0: mechanism include_mech:
   0:    oInclude;           % include the SSL file whose name is in the
                             % string token just accepted
      
   0: rules
      
   0: ProcessSSL:
      
   0:    oCountPush(zero)                % set variable to track error #
   3:    oNextErrorPopCount
      
   4:    oCountPush(numberSystemOps)     % this counter is used to
                                         %   give code #'s to semantic operations
   7:    {[
   9:       | pTitle :
   9:          ':'
  11:          pStrLit
  13:          oTitleSet
  14:          ';'
  16:       | pInput :
  18:          oValuePushKind(kInput)
  21:          oCountPush(zero)
  24:          @ReadIdList
  26:          oCountPop
  27:          oValuePop
  28:       | pOutput :
  30:          oValuePushKind(kOutput)
  33:          oCountPush(zero)
  36:          @ReadIdList
  38:          oCountPop
  39:          oValuePop
  40:       | pError :
  42:          oValuePushKind(kError)
  45:          oNextErrorPushCount
  46:          @ReadIdList
  48:          oNextErrorPopCount
  49:          oValuePop
  50:       | pType :
  52:          pIdent
  54:          oIdentSetDeclared
  55:          oIdentSetKind(kType)
  58:          oValuePushIdent          % type #
  59:          oIdentSetType            % record it in itself
  60:          oValuePushIdent          % type #, for following values
  61:          oValuePushKind(kVal)
  64:          oCountPush(zero)
  67:          @ReadIdList
  69:          oCountPop
  70:          oValuePop
  71:          oValuePop
  72:       | pInclude :
  74:          pStrLit
  76:          oInclude
  77:       | pMechanism :
  79:          pIdent
  81:          oIdentSetDeclared
  82:          oIdentSetKind(kMech)
  85:          ':'
  87:          {[
  89:             | pIdent :
  89:                @OpDefinition
  91:             | * :
  96:                >
  98:          ]}
 100:          ';'
 102:       | pRules :
 104:          {[
 106:             | pIdent :
 106:                oDocNewRule
 107:                @RuleDefinition
 109:             | pEnd :
 111:                >
 113:          ]}
 123:       | pEof :
 125:          >
      %     | * :
      %        #eMissingProgramBlock
      %        %  ?      % skip token, try again
      %        ';'   % a trick to force error recovery to synchronize
 127:    ]}
 151:    @FixForwardCalls
 153:    oCountPop;
      
 155: ReadIdList:     % initial # to use is on count stack
 155:    ':'
 157:    {[
 159:       | pIdent :
 159:          oIdentSetDeclared
 160:          oIdentSetKindVS            % from kind on value stack
 161:          [ oValueChooseKind
 164:             | kVal :
 164:                 oValueSwap         % type # to top
 165:                 oIdentSetType
 166:                 oValueSwap
 167:             | * :
 172:          ]
 172:          [
 174:             | pStrLit :
 174:                [ oValueChooseKind
 177:                   | kInput, kOutput :
 177:                      oShortFormAdd
 178:                   | * :
 185:                      #eNoShortFormHere
 187:                      ?
 188:                ]
 188:             | * :
 193:          ]
 193:          [
 195:             | '=' :
                     % replace counter with new integer
 195:                [
 197:                    | '-' :
 197:                        pIntLit
 199:                        oCountPop
 200:                        oCountPushIntLit
 201:                        oCountNegate
 202:                    | * :
 207:                        pIntLit
 209:                        oCountPop
 210:                        oCountPushIntLit
 211:                ]
 211:             | * :
 216:          ]
 216:          oIdentSetValCount   % set value from count stack
 217:          oCountInc
 218:       | * :
 223:          >
 225:    ]}
 227:    ';';
      
      
 230: OpDefinition:
 230:    oIdentSetDeclared
 231:    oIdentISPush          % remember ident, to set types
 232:    oIdentSetKind(kOp)
 235:    oIdentSetValCount     % store operation# from counter
 236:    oCountInc
 237:    [
 239:       | '(' :
 239:          pIdent
 241:          [ oIdentChooseKind
 244:             | kType :
 244:                oValuePushIdent
 245:                oIdentSetISParamType
 246:                oValuePop
 247:                oIdentSetISParam
 248:             | * :
 253:                #eNotAType
 255:          ]
 255:          ')'
 257:       | * :
 262:    ]
 262:    [
 264:       | '>>' :
 264:          oIdentSetISChoice(true)
 267:          pIdent
 269:          [ oIdentChooseKind
 272:             | kType :
 272:                oValuePushIdent
 273:                oIdentSetISType
 274:                oValuePop
 275:             | * :
 280:                #eNotAType
 282:          ]
 282:       | * :
 287:          oIdentSetISChoice(false)
 290:    ]
 290:    oIdentISPop;
      
      
 292: RuleDefinition:
 292:    oIdentISPush          % remember rule ident throughout.  IT WILL SIT ON
                               % BOTTOM OF IS STACK (choice rules will push above it)
                               % (access from bottom is a kludge... should use a
                               % separate stack to remember the rule id)
 293:    oIdentSetDeclared
 294:    oIdentSetKind(kRule)
 297:    oIdentSetValHere      % address = here
 298:    [
 300:       | '>>' :
 300:          oIdentSetChoice(true)
 303:          pIdent
 305:          [ oIdentChooseKind
 308:             | kType :
 308:                oValuePushIdent
 309:                oIdentSetISType
 310:                oValuePop
 311:             | * :
 316:                #eNotAType
 318:          ]
 318:       | * :
 323:          oIdentSetChoice(false)
 326:    ]
 326:    ':'
 328:    {[ Statement
 332:        | true :
 332:        | * :    >
 339:    ]}
 341:    ';'
 343:    .iReturn
 345:    oIdentISPop;
      
      
      %  Returns true if statement found
      
 347: Statement >> boolean:
 347:    [
 349:       | pStrLit :
 349:          oShortFormLookup       % push index of equivalent ident
 350:          @InputOrOpPop          % actually, should only be input
 352:       | pIdent :
 354:          oIdentISPush
 355:          @InputOrOpPop
 357:       | pErr :
 359:          pIdent
 361:          [ oIdentChooseKind
 364:             | kError :
 364:                .iError
 366:                .iIdentVal
 368:             | * :
 373:                #eNotAnErrSig
 375:          ]
 375:       | pEmit :
 377:          [
 379:             | pIdent :
 379:                oIdentISPush
 380:             | pStrLit :
 382:                oShortFormLookup   % push ident on IS stack
 383:          ]
 391:          [ oIdentChooseISKind
 394:             | kOutput :
 394:                .iEmit
 396:                .iIdentISVal
 398:             | * :
 403:                #eNotOutput
 405:          ]
 405:          oIdentISPop
 406:       | pCall :
 408:          pIdent
 410:          [ oIdentChooseDeclared
 413:             | true :
 413:                [ oIdentChooseKind
 416:                   | kRule :
 416:                      [ oIdentChooseChoice
 419:                         | false :
 419:                            .iCall
 421:                            .iIdentVal
 423:                         | true :
 425:                            #eChoiceRuleOutOfPlace
 427:                      ]
 435:                   | * :
 440:                      #eNotARule
 442:                ]
 442:             | false :                 % rule used before declared
 444:                oIdentSetKind(kRule)   % don't set declared flag yet
 447:                .iCall
 449:                oPatchPushHere(patchCall)    % fix up at end
 452:                oPatchPushIdent(patchCall)
 455:                .iSpace
 457:          ]
 465:       | pReturn :
 467:          oIdentISPushBottom     % check type of current rule (bottom of IS)
 468:          [ oIdentChooseISChoice
 471:             | true :
 471:                pIdent
 473:                [ oIdentChooseKind
 476:                   | kVal :
 476:                      [ oIdentMatchType
 479:                         | true :
 479:                            .iSetResult
 481:                            .iIdentVal
 483:                         | false :
 485:                            #eWrongType
 487:                      ]
 495:                   | * :
 500:                      #eWrongType
 502:                ]
 502:             | false :
 504:          ]
 512:          oIdentISPop
 513:          .iReturn
 515:       | pLCurly :
 517:          oPatchPushHere(patchLoop)   % remember start of loop
 520:          oPatchMark(patchBreak)
 523:          {[ Statement
 527:              | true :
 527:              | * :    >
 534:          ]}
 536:          '}'
 538:          .iJumpBack
 540:          oPatchPopBack(patchLoop)
 543:          {[ oPatchAtMark(patchBreak)      % fix up break statements
 548:             | false :
 548:                oPatchPopFwd(patchBreak)
 551:             | * :
 556:                >
 558:          ]}
 560:       | pBreak :
 562:          [ oPatchAnyEntries(patchLoop)
 567:             | true :
 567:                .iJumpForward
 569:                oPatchPushHere(patchBreak)
 572:                .iSpace
 574:             | false :
 576:                #eNotInLoop
 578:          ]
 586:       | pLSquare :
 588:          @Choice
 590:       | pQuestion :
 592:          .iInputAny
 594:       | * :
 617:          >> false    % not necessarily an error
 620:    ]
 620:    >> true;
      
 624: InputOrOpPop:        % ident is on ident stack (pop when done)
 624:    [ oIdentChooseISKind
 627:       | kInput :
 627:          .iInput
 629:          .iIdentISVal
 631:       | kOp :
 633:          @CallOp
 635:          [ oIdentChooseISChoice
 638:             | true :
 638:                #eChoiceOpOutOfPlace
 640:             | * :
 645:          ]
 645:       | kUnknown :
 647:          #eUndeclaredIdent
 649:       | * :
 658:          #eNotOpRule
 660:    ]
 660:    oIdentISPop;
      
 662: CallOp:                  % op ident on ident stack
 662:    [ oIdentChooseISParam
 665:       | true :
 665:          '('
 667:          pIdent
 669:          [ oIdentChooseKind
 672:             | kVal :
 672:                [ oIdentMatchParamType
 675:                   | true :
 675:                      .iSetParameter
 677:                      .iIdentVal
 679:                   | false :
 681:                      #eWrongType
 683:                ]
 691:             | * :
 696:                #eWrongType
 698:          ]
 698:          ')'
 700:       | * :
 705:    ]
 705:    .iIdentISVal;     % operation #
      
      
 708: Choice:
 708:    [
 710:       | pIdent :                     % rule/op choice
 710:          oIdentISPush                % remember type of options
 711:          [ oIdentChooseDeclared
 714:             | true :
 714:                [ oIdentChooseKind
 717:                   | kRule :
 717:                      .iCall
 719:                      .iIdentVal
 721:                   | kOp :
 723:                      @CallOp
 725:                   | * :
 732:                      #eNotOpRule
 734:                ]
 734:                [ oIdentChooseISChoice
 737:                   | false :
 737:                      #eNotChoice
 739:                   | * :
 744:                ]
 744:                oValuePushKind(kType)  % flag that IS has option type
 747:             | false :                 % rule used before declared
 749:                oIdentSetKind(kRule)   % don't set declared flag yet
 752:                .iCall
 754:                oPatchPushHere(patchCall)    % fix up call at end
 757:                oPatchPushIdent(patchCall)
 760:                .iSpace
 762:                oValuePushKind(kUnknown)  % flag that option type unknown
 765:          ]
 773:          .iChoice
 775:       | * :
 780:          oValuePushKind(kInput)  % flag that options should be input tokens
 783:          oIdentISPush            % DUMMY: push entry so can pop later
 784:          .iInputChoice           %        regardless of input/rule choice
 786:    ]
 786:    oPatchPushHere(patchChoiceTableAddr)  % addr of table will go here
 789:    .iSpace
 791:    oPatchMark(patchChoiceTable)    % build up choice table in this stack
 794:    oPatchMark(patchChoiceExit)     % remember ends of each option
 797:    oCountPush(zero)                % count the options
 800:    '|'
 802:    {
 802:       [
 804:          | '*' :       % default code (must be last option)
 804:             ':'
 806:             @CopyChoiceTable
 808:             oCountPop
 809:             oValuePop
 810:             oIdentISPop
 811:             {[ Statement
 815:                 | true :
 815:                 | * :    >
 822:             ]}
 824:             ']'
 826:             @FixChoiceExits
 828:             >>
 829:          | * :         % option(s)
 834:             {
 834:                [ oValueChooseKind
 837:                   | kType :           % rule/op choice
 837:                      pIdent
 839:                      [ oIdentChooseKind
 842:                         | kVal :
 842:                            [ oIdentMatchType
 845:                               | false :
 845:                                  #eWrongType
 847:                               | * :
 852:                            ]
 852:                         | * :
 857:                            #eNotAVal
 859:                      ]
 859:                      oValuePushVal    % value# of option
 860:                   | kUnknown :        % rule, not yet defined
 862:                      pIdent
 864:                      [ oIdentChooseKind
 867:                         | kVal :
 867:                            oValuePushType   % now know type of rule
 868:                            oIdentSetISType
 869:                            oValuePop
 870:                            oValuePop        % replace flag
 871:                            oValuePushKind(kType)   % flag that IS has type
 874:                         | * :
 879:                            #eNotAVal
 881:                      ]
 881:                      oValuePushVal    % value# of option
 882:                   | kInput :
 884:                      [
 886:                         | pIdent :
 886:                            oIdentISPush
 887:                         | pStrLit :
 889:                            oShortFormLookup
 890:                      ]
 898:                      [ oIdentChooseISKind
 901:                         | kInput :
 901:                         | * :
 906:                            #eNotInput
 908:                      ]
 908:                      oValuePushISVal  % value# of option
 909:                      oIdentISPop
 910:                ]
                     % value of option is now on value stack
 920:                oPatchPushHere(patchChoiceTable)
 923:                oPatchPushValue(patchChoiceTable)  % build choice table
 926:                oValuePop
 927:                oCountInc
 928:                [
 930:                   | ':' :
 930:                      >
 932:                   | ',' :   % go around and get another
 934:                ]
 942:             }
 944:       ]
      
            % code for option:
      
 944:       {[ Statement
 948:           | true:
 948:           | * : >
 955:       ]}
      
 957:       [
 959:          | ']' :      % end of choice, no default
 959:             .iJumpForward
 961:             oPatchPushHere(patchChoiceExit)
 964:             .iSpace
 966:             @CopyChoiceTable
 968:             oCountPop      % #options
 969:             oValuePop      % flag: input/rule choice
 970:             oIdentISPop    % type of rule choice (dummy if input choice)
 971:             .iEndChoice
 973:             @FixChoiceExits
 975:             >>
 976:          | '|' :      % more options follow
 978:             .iJumpForward
 980:             oPatchPushHere(patchChoiceExit)
 983:             .iSpace
 985:       ]
 993:    };
      
      
      % Install choice table here. #options is in top counter.
      % Note, the order of the options is opposite that in the source file.
      % So, in error recovery in a choice with no otherwise, take the
      % option just before the oEndChoice.
      
 996: CopyChoiceTable:
 996:    oPatchPopFwd(patchChoiceTableAddr)   % fix pointer to table
 999:    oValuePushCount   % #entries
1000:    .iConstant        % emit value
1002:    oValuePop
1003:    {[ oPatchAtMark(patchChoiceTable)
1008:       | false :
1008:          oPatchPopValue(patchChoiceTable)
1011:          oPatchPopBack(patchChoiceTable)
1014:       | * :
1019:          >
1021:    ]};
      
      
1024: FixChoiceExits:
1024:    {[ oPatchAtMark(patchChoiceExit)     % fix jumps from end of each option
1029:       | false :                         %    to end of the choice
1029:          oPatchPopFwd(patchChoiceExit)
1032:       | * :
1037:          >
1039:    ]};
      
1042: FixForwardCalls:
1042:    {[ oPatchAnyEntries(patchCall)
1047:       | true :
1047:          oPatchPopCall(patchCall)
1050:       | * :
1055:          >
1057:    ]};
      
      
1060: end
      
1060: 
