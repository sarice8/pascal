
%
% This schema holds a symbol table for a Pascal program.
% Inspired by what I did in the SSL 1.3.2 processor.
%
% Steve Rice -- Sept 10, 2022
%

Schema Pascal Root nScope Is

% -----------------------------------------------------------------------
% Scope
% -----------------------------------------------------------------------

Object ::= nScope
nScope =>
        qDecls:         List            (nDeclaration)          [Pri,Opt]
        qSize:          Integer4        % space required by declared variables
        qAllocDown:     Boolean1        % allocate from -1 downto -size

Object ::= nDeclaration


% TO DO: not sure why I had both nDeclaration and nIdent
nDeclaration ::= nIdent
nIdent =>
        qIdent:         Integer4
        qType:          Node            (nType)                 [Alt,Opt]  % for var, func, typeDecl (how about const?)
        qValue:         Integer4   % for const: value
                                   % for nGlobalVar: global address
                                   % for nLocalVar: local address (relative to frame ptr)
                                   % for nParam: local address (relative to frame ptr)
        

nIdent ::= nProgram
nProgram =>
        % scope for use by the main routine, for temporaries
        qMainRoutineScope:   Node       (nScope)                [Pri]



% nMethod is a proc or func declaration.
% qValue is the label.  It is allocated when the declaration is first seen
% (including forward declaration).  That lets calls invoke the method
% before the body is seen.
% 
% When the body is seen, qBodyDefined is set to true.
% A forward declaration followed by an actual body declaration will revise
% the existing declaration in the symbol table, rather than create a second one.
%
nIdent ::= nMethod
nMethod =>
        qParams:        Node            (nScope)                [Pri,Opt]
        qChildScope:    Node            (nScope)                [Pri,Opt]
        qBodyDefined:   Boolean1
        qExternal:      Boolean1
        qCdecl:         Boolean1

        % The next two fields are used when a forward declaration is redefined.
        % I don't really need to keep them, but don't have a way to cleanly delete nodes yet.
        qOldParams:     Node            (nScope)                [Pri,Opt]
        qOldType:       Node            (nType)                 [Pri,Opt]


nMethod ::= nProc

% func return type is qType in nIdent.
nMethod ::= nFunc
nFunc =>
        qResultOffset:  Integer4    % offset of VAR param for result



nIdent ::= nConst

nIdent ::= nTypeDecl

nIdent ::= nVar

nVar ::= nGlobalVar

nVar ::= nLocalVar

nVar ::= nRecordField

nVar ::= nParam
nParam =>
        qInOut:         Boolean1      % has VAR keyword


Object ::= nType


% nType objects are all owned by a type table, so child types are [Alt] here.
%
nType =>
        qSize:          Integer4
        qPointerType:   Node            (nType)                 [Alt,Opt]
             % possibly silly optimization: a type that's a pointer to this type

nType ::= nFileType

nType ::= nIntegerType

nType ::= nBooleanType

% nBooleanCFType is an expression type that's represented by control flow rather than a value.
% It's not used in the symbol table.
nType ::= nBooleanCFType

nType ::= nCharType

nType ::= nStringType

nType ::= nPointerType
nPointerType =>
        qBaseType:      Node            (nType)                 [Alt]

nType ::= nArrayType
nArrayType =>
        % The index type is always just for one dimension.
        % A multi-dimension array is recorded as array of array,
        % and may be referenced as such in the user's program.
        qIndexType:     Node            (nSubrangeType)         [Alt]
        qBaseType:      Node            (nType)                 [Alt]

nType ::= nSubrangeType
nSubrangeType =>
        qLow:           Integer4
        qHigh:          Integer4
        qBaseType:      Node            (nType)                 [Alt]

nType ::= nRecordType
nRecordType =>
        % the record field declarations, each with a relative offset
        qScope:         Node            (nScope)                [Pri]


% TO DO: Looks like I didn't support this in SSL yet
nType ::= nEnumType
nEnumType =>
        % the enum value declarations, each as a const with its int value 
        qScope:         Node            (nScope)                [Pri]

% a collection of enum values, like a bit vector
nType ::= nSetType
nSetType =>
        qBaseType:      Node            (nType)                 [Alt]


