
%
% This schema holds a symbol table for a Pascal program.
% Inspired by what I did in the SSL 1.3.2 processor.
%
% Steve Rice -- Sept 10, 2022
%

Schema Pascal Root nScope Is

% -----------------------------------------------------------------------
% Scope
% -----------------------------------------------------------------------

Object ::= nScope
nScope =>
        qDecls:         List            (nDeclaration)          [Pri,Opt]
        qSize:          Integer4        % space required by declared variables
        qAllocDown:     Boolean1        % allocate from -1 downto -size

Object ::= nDeclaration


% TO DO: not sure why I had both nDeclaration and nIdent
nDeclaration ::= nIdent
nIdent =>
        % to do: ditch all the fields, and rely on schema objects instead.
        qIdent:         Integer4
        qKind:          Integer4   % to do: ditch this. rely on object type.
        qType:          Node            (nType)                 [Alt,Opt]  % for var, func, typeDecl (how about const?)
        qParamType:     Node            (nType)                 [Alt,Opt]  % for proc/funcs. I represented params as a type
        qValue:         Integer4   % for const: value  (was short)
                                   % for nGlobalVar: global address
                                   % for nLocalVar: local address (relative to frame ptr)
                                   % for nParam: local address (relative to frame ptr)
        

nIdent ::= nProgram


% nMethod is a proc or func declaration.
% qValue is the method address, unless we've only seen a forward declaration
% in which case qAddrDefined is false.
%
% If there's a forward declaration and the body is subsequently seen,
% we'll update the existing nMethod to contain the final information:
% storing the address in qValue, and updating the qParams (since the names
% might differ), and setting qAddrDefined to true.
%
nIdent ::= nMethod
nMethod =>
        qParams:        Node            (nScope)                [Pri,Opt]
        qChildScope:    Node            (nScope)                [Pri,Opt]
        qAddrDefined:   Boolean1

nMethod ::= nProc

% func return type is qType in nIdent.
nMethod ::= nFunc
nFunc =>
        qResultOffset:  Integer4    % offset of VAR param for result



nIdent ::= nConst

nIdent ::= nTypeDecl

nIdent ::= nVar

nVar ::= nGlobalVar

nVar ::= nLocalVar

nVar ::= nRecordField

nVar ::= nParam
nParam =>
        qInOut:         Boolean1      % has VAR keyword


Object ::= nType


% nType objects are all owned by a type table, so child types are [Alt] here.
%
nType =>
        qSize:          Integer4
        qPointerType:   Node            (nType)                 [Alt,Opt]
             % possibly silly optimization: a type that's a pointer to this type

nType ::= nFileType

nType ::= nIntegerType

nType ::= nBooleanType

nType ::= nCharType

nType ::= nStringType

nType ::= nPointerType
nPointerType =>
        qBaseType:      Node            (nType)                 [Alt]

nType ::= nArrayType
nArrayType =>
        % The index type is always just for one dimension.
        % A multi-dimension array is recorded as array of array,
        % and may be referenced as such in the user's program.
        qIndexType:     Node            (nSubrangeType)         [Alt]
        qBaseType:      Node            (nType)                 [Alt]

nType ::= nSubrangeType
nSubrangeType =>
        qLow:           Integer4
        qHigh:          Integer4
        qBaseType:      Node            (nType)                 [Alt]

nType ::= nRecordType
nRecordType =>
        % the record field declarations, each with a relative offset
        qScope:         Node            (nScope)                [Pri]


% TO DO: Looks like I didn't support this in SSL yet
nType ::= nEnumType
nEnumType =>
        % the enum value declarations, each as a const with its int value 
        qScope:         Node            (nScope)                [Pri]

% a collection of enum values, like a bit vector
nType ::= nSetType
nSetType =>
        qBaseType:      Node            (nType)                 [Alt]


