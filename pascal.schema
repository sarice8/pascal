
%
% This schema holds a symbol table for a Pascal program.
% Inspired by what I did in the SSL 1.3.2 processor.
%
% Steve Rice -- Sept 10, 2022
%

Schema Pascal Root nWorkspace Is


Object ::= nWorkspace
nWorkspace =>
        % all loaded units; not necessarily visible to program or each other
        qUnits:         List            (nUnit)                 [Pri,Opt]
        qProgram:       Node            (nProgram)              [Pri,Opt]
        qGlobalSize:    Integer4
        

Object ::= nModule
nModule =>
        qIdent:         Integer4
        qUsedUnits:     List            (nUnit)                 [Alt,Opt]


nModule ::= nProgram
nProgram =>
        qChildScope:    Node            (nScope)                [Pri]
        % scope for use by the main routine, for temporaries
        qMainRoutineScope:  Node        (nScope)                [Pri]


nModule ::= nUnit
nUnit =>
        qPublicScope:   Node            (nScope)                [Pri]
        qPrivateScope:  Node            (nScope)                [Pri]
        qInitLabel:     Integer4            % initialization method label, or 0 for none
        qFinalLabel:    Integer4            % finalization method label, or 0 for none
        % scope for use by the initialization routine, for temporaries
        qInitRoutineScope:  Node        (nScope)                [Pri]
        % scope for use by the finalization routine, for temporaries
        qFinalRoutineScope:  Node       (nScope)                [Pri]


% -----------------------------------------------------------------------
% Scope
% -----------------------------------------------------------------------

Object ::= nScope
nScope =>
        qLevel:         Integer4        % static scope level (0 = globals)
        qDecls:         List            (nDeclaration)          [Pri,Opt]
        qSize:          Integer4        % space required by declared variables
        qAllocMode:     Boolean1        % how to allocate variables
        qInitCode:      Integer4        % id of code stream to initialize scope's vars

Object ::= nDeclaration
nDeclaration =>
        qParentScope:   Node            (nScope)                [Alt]


% TO DO: not sure why I had both nDeclaration and nIdent
nDeclaration ::= nIdent
nIdent =>
        qIdent:         Integer4
        qType:          Node            (nType)                 [Alt,Opt]  % for var, func, typeDecl (how about const?)
        qValue:         Integer4   % for const: value
                                   % for nGlobalVar: global address
                                   % for nLocalVar: local address (relative to frame ptr)
                                   % for nParam: local address (relative to frame ptr)


% nMethod is a proc or func declaration.
% qValue is the label.  It is allocated when the declaration is first seen
% (including forward declaration).  That lets calls invoke the method
% before the body is seen.  (For an external method, the calling code will
% define the label with .tLabelExtern)
% 
% When the body is seen, qBodyDefined is set to true.
% A forward declaration followed by an actual body declaration will revise
% the existing declaration in the symbol table, rather than create a second one.
%
nIdent ::= nMethod
nMethod =>
        qParams:        Node            (nScope)                [Pri,Opt]
        qChildScope:    Node            (nScope)                [Pri,Opt]
        qBodyDefined:   Boolean1
        qExternal:      Boolean1
        qExternalName:  StringN
        qCdecl:         Boolean1
        qCalled:        Boolean1     % has anybody called this method

        % The next two fields are used when a forward declaration is redefined.
        % I don't really need to keep them, but don't have a way to cleanly delete nodes yet.
        qOldParams:     Node            (nScope)                [Pri,Opt]
        qOldType:       Node            (nType)                 [Pri,Opt]


nMethod ::= nProc

% func return type is qType in nIdent.
nMethod ::= nFunc
nFunc =>
        qResultOffset:  Integer4    % offset of VAR param for result



nIdent ::= nConst

nIdent ::= nTypeDecl

nIdent ::= nVar

nVar ::= nGlobalVar

nVar ::= nLocalVar

nVar ::= nRecordField

nVar ::= nParam
nParam =>
        qInOut:         Boolean1      % has VAR keyword


Object ::= nType


% nType objects are all owned by a type table, so child types are [Alt] here.
%
nType =>
        qSize:          Integer4
        qPointerType:   Node            (nType)                 [Alt,Opt]
             % possibly silly optimization: a type that's a pointer to this type

nType ::= nFileType

nType ::= nIntegerType

nType ::= nBooleanType

% nBooleanCFType is an expression type that's represented by control flow rather than a value.
% It's not used in the symbol table.
nType ::= nBooleanCFType

nType ::= nCharType

nType ::= nStringType

nType ::= nPointerType
nPointerType =>
        qBaseType:      Node            (nType)                 [Alt]

nType ::= nArrayType
nArrayType =>
        % The index type is always just for one dimension.
        % A multi-dimension array is recorded as array of array,
        % and may be referenced as such in the user's program.
        qIndexType:     Node            (nSubrangeType)         [Alt]
        qBaseType:      Node            (nType)                 [Alt]

nType ::= nSubrangeType
nSubrangeType =>
        qLow:           Integer4
        qHigh:          Integer4
        qBaseType:      Node            (nType)                 [Alt]

nType ::= nRecordType
nRecordType =>
        % the record field declarations, each with a relative offset
        qScope:         Node            (nScope)                [Pri]


% TO DO: Looks like I didn't support this in SSL yet
nType ::= nEnumType
nEnumType =>
        % the enum value declarations, each as a const with its int value 
        qScope:         Node            (nScope)                [Pri]

% a collection of enum values, like a bit vector
nType ::= nSetType
nSetType =>
        qBaseType:      Node            (nType)                 [Alt]


