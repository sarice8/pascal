   2: title: 'Pascal Compiler 1.1.5 -- Jan 01 ''90';
         
      %
      %  Pascal.ssl
      %
      %  Pascal Compiler for the Amiga, by Steve Rice.
      %
      %  HISTORY
      %    11Sep89   First version, framework of parser.
      %    18Sep89   Added some semantic mechanisms.
      %    21Sep89   Added simple type references; expressions generate code.
      %    22Sep89   Allocate variable addresses as they're declared.
      %    24Sep89   Added arrays, pointers.
      %    27Sep89   Added for statement.
      %    23Oct89   Fixed for statement, so CYCLE goes to next step.
      %    01Jan90   Added string literals
      %    09Sep22   I have returned.  Migrate symbol table to schema, to ease development.
      %    01Oct22   Language: Switch from cycle/exit (Mac Pascal extension) to continue/break (Borland).
      %
      %  NOTES
      %    -  The 'value' of a var symbol is its allocated address.
      %    -  References to vars of intrinsic types, and pointer types,
      %       pushes the value of the var on the expr stack.  Referenecs to
      %       vars of compound types (arrays, records...) pushes the address
      %       on the expr stack.
      %    -  Just as there is only one type table entry for a given (named) type,
      %       there is only one type table entry for a pointer to a named type.
      %       When a pointer type is declared, a field in the TT entry of the
      %       type pointed to will be set to indicate the TT entry of the pointer
      %       to that type (0 means none defined yet).  When evaluating the
      %       expression @x, the type in that field in the entry for the type of x
      %       will be used (unless it's 0, in which case a new TT entry will be
      %       created).
      %
      %
      %  MISSING
      %
      %    - Consider non-ISO extensions.  e.g. 
      %      Dynamic arrays.  Objects.  But, perhaps stick to my old goal, standard Pascal.
      %
      %  PASCAL DOCS
      %      Here's some handy language material:
      %      https://www.freepascal.org/docs-html/ref/ref.html
      %      https://www.freepascal.org/docs-html/prog/prog.html
      %      https://en.wikipedia.org/wiki/Turbo_Pascal
      %      https://en.wikipedia.org/wiki/Pascal_(programming_language)#Standards
      %      http://www.standardpascaline.org/
      %
      
   2: input:
   2:    pIdent
   2:    pIntLit
   2:    pDoubleLit
   2:    pStrLit
   2:    pCharLit
   2:    pAssign       ':='
   2:    pSemiColon    ';'
   2:    pEqual        '='
   2:    pNotEqual     '<>'
   2:    pLess         '<'
   2:    pGreater      '>'
   2:    pLessEqual    '<='
   2:    pGreaterEqual '>='
   2:    pColon        ':'
   2:    pComma        ','
   2:    pLParen       '('
   2:    pRParen       ')'
   2:    pLSquare      '['
   2:    pRSquare      ']'
   2:    pCarat        '^'
   2:    pAt           '@'
   2:    pDot          '.'
   2:    pDotDot       '..'
   2:    pTimes        '*'
   2:    pDivide       '/'
   2:    pPlus         '+'
   2:    pMinus        '-'
   2:    pEof
   2:    pInvalid
      
      %  keywords  (built-in types 'integer', 'byte', 'char', etc, are not keywords,
      %             type constructors 'array', 'record', 'set' are keywords,
      %             pseudo-procedures 'writeln', 'readln' are keywords)
      %
      %             forward/external/name/cdecl appear in method modifiers, in fpc grammar.
      %             I'm making them keywords to simplify parsing, but could reconsider.
      
   2:    pProgram
   2:    pProcedure
   2:    pFunction
   2:    pConst
   2:    pType
   2:    pVar
   2:    pLabel
   2:    pBegin
   2:    pEnd
   2:    pArray
   2:    pRecord
   2:    pSet
   2:    pOf
   2:    pIf
   2:    pThen
   2:    pElse
   2:    pFor
   2:    pTo
   2:    pDownto
   2:    pDo
   2:    pWhile
   2:    pRepeat
   2:    pUntil
   2:    pContinue
   2:    pBreak
   2:    pCase
   2:    pOtherwise
   2:    pGoto
   2:    pAnd
   2:    pOr
   2:    pNot
   2:    pUses
   2:    pUnit
   2:    pInterface
   2:    pImplementation
   2:    pInitialization
   2:    pFinalization
   2:    pWriteln
   2:    pWrite
   2:    pReadln
   2:    pRead
      
   2:    pForward
   2:    pExternal
   2:    pName
   2:    pCdecl
   2:    ;
      
      
   2: output:
      
      %  Instructions for a stack machine
      
   2:    tPushGlobalI      % <ptr> - push int value read from ptr
   2:    tPushGlobalB      % <ptr> - push byte value read from ptr
   2:    tPushGlobalP      % <ptr> - push ptr value read from ptr
   2:    tPushGlobalD      % <ptr> - push double precision float value read from ptr
   2:    tPushLocalI       % <offset> - push int value read from local var in current scope
   2:    tPushLocalB       % <offset> - push byte value read from local var in current scope
   2:    tPushLocalP       % <offset> - push ptr value read from local var in current scope
   2:    tPushLocalD       % <offset> - push double value read from local var in current scope
   2:    tPushParamI       % <offset> - push int value read from param in current scope
   2:    tPushParamB       % <offset> - push byte value read from param in current scope
   2:    tPushParamP       % <offset> - push ptr value read from param in current scope
   2:    tPushParamD       % <offset> - push double value read from param in current scope
   2:    tPushUpLocalI     % <uplevels> <offset> - push int value read from local var in a parent static scope
   2:    tPushUpLocalB     % <uplevels> <offset> - push byte value read from local var in a parent static scope
   2:    tPushUpLocalP     % <uplevels> <offset> - push ptr value read from local var in a parent static scope
   2:    tPushUpLocalD     % <uplevels> <offset> - push double value read from local var in a parent static scope
   2:    tPushUpParamI     % <uplevels> <offset> - push int value read from param in a parent static scope
   2:    tPushUpParamB     % <uplevels> <offset> - push byte value read from param in a parent static scope
   2:    tPushUpParamP     % <uplevels> <offset> - push ptr value read from param in a parent static scope
   2:    tPushUpParamD     % <uplevels> <offset> - push double value read from param in a parent static scope
   2:    tPushConstI       % <int> - push int value on stack (NOTE, used for BOOLEAN too)
   2:    tPushConstD       % <double> - push double value on stack
   2:    tPushAddrGlobal   % <offset> - push ptr to global var
   2:    tPushAddrLocal    % <offset> - push ptr to local var
   2:    tPushAddrParam    % <offset> - push ptr to formal param (used by method to see its param)
   2:    tPushAddrActual   % <offset> - push ptr to actual param, in actuals space (used by caller)
   2:    tPushAddrUpLocal  % <uplevels> <offset> - push ptr to local var in a parent static scope
   2:    tPushAddrUpParam  % <uplevels> <offset> - push ptr to formal param in a parent static scope
   2:    tSwap             % swap the top two entries on the stack
   2:    tFetchI           % pop ptr from stack, and push int value it points to
   2:    tFetchB           %    "      "      "     "     byte  "   "    "
   2:    tFetchP           %    "      "      "     "     ptr   "   "    "   
   2:    tFetchD           %    "      "      "     "     double "  "    "   
   2:    tAssignI          % assign int value on top of stack to addr under it (pop both)
   2:    tAssignB          %   "    byte   "    "   "  "   "    "    "   "   "
   2:    tAssignP          %   "    ptr    "    "   "  "   "    "    "   "   "
   2:    tAssignD          %   "    double "    "   "  "   "    "    "   "   "
   2:    tCopy             % <#bytes> - copy bytes.  tos=src, 2nd=dest (pop 2)
   2:    tCastBtoI         % zero-extend uint8_t to int32_t
   2:    tCastItoB         % truncate int32_t to uint8_t
   2:    tCastItoD         % convert int32_t to double
   2:    tIncI             % increment int value on top of expr stack
   2:    tDecI             % decrement int value on top of expr stack
   2:    tMultI            % multiply top two integers (replacing with result)
   2:    tDivI
   2:    tAddPI            % add ptr (2nd value) and int (top value), resulting in a ptr
   2:    tAddI
   2:    tSubP
   2:    tSubPI
   2:    tSubI
   2:    tNegI             % top entry *= -1
   2:    tMultD            % operations on double-precision floating point values
   2:    tDivD
   2:    tAddD
   2:    tSubD
   2:    tNegD
   2:    tNot              % negate top boolean
   2:    tEqualB
   2:    tNotEqualB
   2:    tGreaterB         % B is uint8_t, so these are unsigned comparisons
   2:    tLessB
   2:    tGreaterEqualB
   2:    tLessEqualB
   2:    tEqualI           % top two entries equal? (pop 2, push 1) (true=1)
   2:    tNotEqualI        %    NOTE, these all work for booleans too, but I'm moving to tEqualB etc for those
   2:    tGreaterI         % 2nd entry greater than top entry? (pop 2, push answer)
   2:    tLessI  
   2:    tGreaterEqualI
   2:    tLessEqualI
   2:    tEqualP           % two two pointer values equal? (pop 2, push 1) (true=1)
   2:    tNotEqualP
   2:    tGreaterP
   2:    tLessP
   2:    tGreaterEqualP
   2:    tLessEqualP
   2:    tEqualD           % double comparisions
   2:    tNotEqualD
   2:    tGreaterD
   2:    tLessD
   2:    tGreaterEqualD
   2:    tLessEqualD
   2:    tAllocActuals     % <#bytes> - make space on call stack for actual params (adjusting call stack sp)
   2:    tAllocActualsCdecl  % <#bytes> - starting a call to a cdecl method.  tcode still describes my own calling convention.
   2:    tFreeActuals      % <#bytes> - discard space on call stack allocated by tAllocActuals
   2:    tCall             % <label#>
   2:    tCallCdecl        % <label#> - call a method using native (C) calling convention. Only supported for extern labels.
   2:    tReturn
   2:    tEnter            % <#bytes> - start a stack frame on the call stack, reserving #bytes of local variable space
   2:    tJump             % <label#>
   2:    tJumpTrue         % <label#>  (pops top of stack, jumps if true)
   2:    tJumpFalse        % <label#>  (pops top of stack, jumps if false)
   2:    tJumpCaseB        % <label#>  pops uint8_t, jumps to case indicated by table at label (consisting of tCase, tCaseRange, tCaseEnd)
   2:    tJumpCaseI        % <label#>  pops integer, jumps to case indicated by table at label
   2:    tJumpCaseS        % <label#>  pops pointer to ShortString, jumps to case indicated by table at label
   2:    tCase             % <int> <label#>  - case table entry: if match int, goto label.  For tJumpCaseS, int is offset into global data.
   2:    tCaseRange        % <lowint> <highint> <label#>  - case table entry: if lowint <= value <= highint, goto label.  For tJumpCaseS, offsets into global.
   2:    tCaseEnd          % <label#> - end of case table.  Label points to no-match code (otherwise clause or end of statement).
   2:    tLabel            % <label#> - define label# at the current address
   2:    tLabelAlias       % <label#> <aliasToLabel#> - defines label to be an alias of another label
   2:    tLabelExtern      % <label#> <offsetToStrLit> - defines label to mean an extern symbol, whose name is in global data
   2:    tWriteI           % for writeln : write integer on tos, pop
   2:    tWriteBool        %  "     "    : write TRUE/FALSE, pop
   2:    tWriteChar        %  "     "    : write char, pop
   2:    tWriteShortStr    %  "     "    : write ShortString whose addr is on tos, pop
   2:    tWritePChar       %  "     "    : write a null-terminated string whose addr is on tos, pop
   2:    tWriteP           %  "     "    : write ptr var whose addr is on tos, pop
   2:    tWriteEnum        %  "     "    : write enum name.  Name table on tos, value under it, pop both
   2:    tWriteD           %  "     "    : write double-precision floating point value on tos, pop
   2:    tWriteCR          %  "     "    : write cr
   2:    tReadI            % for readln : pointer to integer on tos.  Assign read value to it, and pop
   2:    tReadChar         %  "     "   : pointer to char on tos.  Asign read value to it, and pop
   2:    tReadShortStr     % <capacity>  "     "   : pointer to ShortString on tos, and given max capacity.  Assign read value to it, and pop
   2:    tReadCR           %  "     "   : read the end-of-line.  Will accept any platform's eoln sequence.
   2:    tFile             % <file#> - pascal source file id, for debugging.  I haven't decided yet how I will communicate the corresponding filename.
   2:    tLine             % <line#> - pascal source line number, for debugging
      
      %  Other:
      
   2:    tSpace            % emit a hole, to be patched later
   2:    ;
      
   2: error:
   2:    eBadStatement
   2:    eNotConst
   2:    eNotType
   2:    eNotOrdinalType
   2:    eNotVar
   2:    eNotIntVar
   2:    eNotValue
   2:    eNotInteger
   2:    eNotBoolean
   2:    eNotDouble
   2:    eNotPointer
   2:    eNotArray
   2:    eNotRecord
   2:    eNotRecordField
   2:    eTooManySubscripts
   2:    eTypeMismatch
   2:    eMissingParameter
   2:    eNotImplemented
   2:    eNotAllowed
   2:    eNotInALoop
   2:    eRecordEmpty
   2:    eNotCurrentFunction
   2:    eAlreadyDefined
   2:    eOnlyOneVarCanBeInitialized
   2:    eExternalMethodCannotBeNested
   2:    eExternalMethodMustBeCdecl
   2:    eCantFindUnitFile
   2:    eInternalScopeMismatch
   2:    eEnumValueNotAscending
   2:    eUsedButNotDefined
   2:    eCantUsePredSuccOnEnumWithValueGaps
   2:    eCantDereference
   2:    eSizeMismatch
   2:    eTypeNameNotAllowedHere
   2:    ;
      
   2: include 'pascal_schema.ssl'
      
      % Generated automatically by schema
      
   2: type node_type:
   2: 	nINVALID
   2: 	Object
   2: 	nWorkspace
   2: 	nModule
   2: 	nProgram
   2: 	nUnit
   2: 	nUnitImpl
   2: 	nScope
   2: 	nDeclaration
   2: 	nIdent
   2: 	nUnitRef
   2: 	nMethod
   2: 	nProc
   2: 	nFunc
   2: 	nBuiltInFunc
   2: 	nBuiltInProc
   2: 	nConst
   2: 	nEnumValue
   2: 	nConstStr
   2: 	nConstDouble
   2: 	nTypeDecl
   2: 	nVar
   2: 	nGlobalVar
   2: 	nLocalVar
   2: 	nRecordField
   2: 	nParam
   2: 	nTypedConst
   2: 	nLabel
   2: 	nType
   2: 	nFileType
   2: 	nByteType
   2: 	nIntegerType
   2: 	nSingleType
   2: 	nDoubleType
   2: 	nBooleanType
   2: 	nBooleanFlowType
   2: 	nCharType
   2: 	nPointerType
   2: 	nUniversalPointerType
   2: 	nArrayType
   2: 	nSubrangeType
   2: 	nRecordType
   2: 	nStrLitType
   2: 	nShortStringType
   2: 	nEnumType
   2: 	nSetType
   2: 	;
      
   2: type node_attribute:
   2: 	qINVALID
   2: 	qUnits
   2: 	qProgram
   2: 	qGlobalSize
   2: 	qIdent
   2: 	qUsedUnits
   2: 	qChildScope
   2: 	qMainRoutineScope
   2: 	qImpl
   2: 	qPublicScope
   2: 	qPrivateScope
   2: 	qInitLabel
   2: 	qFinalLabel
   2: 	qInitRoutineScope
   2: 	qLevel
   2: 	qDecls
   2: 	qExtends
   2: 	qSize
   2: 	qAllocMode
   2: 	qInitCode
   2: 	qParentScope
   2: 	qType
   2: 	qValue
   2: 	qParams
   2: 	qBodyDefined
   2: 	qExternal
   2: 	qExternalName
   2: 	qCdecl
   2: 	qUsed
   2: 	qOldParams
   2: 	qOldType
   2: 	qResultOffset
   2: 	qNameOffset
   2: 	qValueStr
   2: 	qValueDouble
   2: 	qInOut
   2: 	qDefined
   2: 	qPointerType
   2: 	qBaseType
   2: 	qIndexType
   2: 	qLow
   2: 	qHigh
   2: 	qScope
   2: 	qCapacity
   2: 	qNameTable
   2: 	qHasGap
   2: 	;
      
      
   2: type Node:     % A pointer to a node in the schema database (symbol database)
   2:    Null = 0
   2:    ;
      
   2: type NodeIter:   % An iterator over nodes in a list, in the schema database
   2:    NullIter = 0
   2:    ;
      
   2: type NodeVec:  % A pointer to a vector of Node.  See mechanism node_vec_mech
   2:    NullVec = 0
   2:    ;
      
   2: type boolean:
   2:    false    = 0
   2:    true     = 1;
      
   2: type double:
   2:    doubleZero = 0
   2:    ;
      
   2: type Label:
   2:    labelNull = 0;
      
      % An output code stream.
   2: type Code:
   2:    codeNull = 0
   2:    codeDefault = 1
   2:    ;
      
      % A string
   2: type String:
   2:    stringNull = 0
   2:    ;
      
      % allocation modes for oScopeBegin
   2: type AllocMode:
   2:    allocGlobal = 0  % allocate from global data
   2:    allocDown        % allocate down the stack
   2:    allocUp          % allocate up the stack
   2:    ;
      
      % Some general schema node operations.
      % node_type and node_attribute are defined in generated file pascal_schema.ssl included above.
      %
   2: mechanism node_mech:
   2:     oNodeNew (node_type) >> Node         % create new node
   2:     oNodeSet (Node, node_attribute, Node)   % set Node attribute of node
   2:     oNodeSetDouble (Node, node_attribute, double)   % set double attribute
   2:     oNodeSetString (Node, node_attribute, String)
   2:     oNodeSetInt (Node, node_attribute, int) % set int attribute of node
   2:     oNodeSetBoolean (Node, node_attribute, boolean)
   2:     oNodeSetLabel( Node, node_attribute, Label )  % set Label attribute of node
   2:     oNodeSetCode( Node, node_attribute, Code )    % set Code attribute of node
   2:     oNodeAddLast( Node, node_attribute, Node value )  % append to a List attribute of node
   2:     oNodeGet (Node, node_attribute) >> Node    % get Node attribute of node
   2:     oNodeGetDouble (Node, node_attribute) >> double
   2:     oNodeGetString (Node, node_attribute) >> String
   2:     oNodeGetInt (Node, node_attribute) >> int  % get int attribute of node
   2:     oNodeGetBoolean (Node, node_attribute) >> boolean  % get int attribute of node
   2:     oNodeGetLabel (Node, node_attribute) >> Label      % get Label attribute of node
   2:     oNodeGetCode (Node, node_attribute) >> Code        % get code stream attribute of node
   2:     oNodeNull (Node) >> boolean          % is node null?
   2:     oNodeFind (Node, node_attribute listAttr, node_attribute valueAttr, int value) >> Node  % find node with value in list
   2:     oNodeGetIter (Node, node_attribute) >> NodeIter   % get an iterator over nodes in a List attribute
   2:     oNodeGetIterLast (Node, node_attribute) >> NodeIter  % get an iterator over nodes in a List, starting at last
   2:     oNodeIterValue (NodeIter) >> Node             % the node that iter is referring to (NodeNull if no more nodes)
   2:     oNodeIterNext (inout NodeIter)                % advance iterator through list
   2:     oNodeIterPrev (inout NodeIter)                % advance iterator backwards through list
   2:     oNodeType (Node) >> node_type        % return node type of node
   2:     oNodeEqual (Node, Node) >> boolean   % compare two nodes for equality
                                               % (i.e. same node, not just same contents)
   2:     ;
      
      
      % Manipulate a temporary vector of Node
      %
   2: mechanism node_vec_mech:
   2:     oNodeVecNew >> NodeVec
   2:     oNodeVecDelete( NodeVec nv )
   2:     oNodeVecAppend( NodeVec nv, Node n )
   2:     oNodeVecSize( NodeVec nv ) >> int                % how many elements
   2:     oNodeVecElement( NodeVec nv, int idx ) >> Node   % element at index idx (0..size-1)
   2:     ;
      
      
      
   2: mechanism emit_mech:
   2:     oEmitInt( int )              % emit int into the generated code
   2:     oEmitDouble( double )        % emit double into the generated code
   2:     oEmitLabel( Label )
   2:     oEmitCode( Code )            % append a code stream to the current code stream
   2:     Here >> int                  % current address in the generated code
                                       %   (only usable in the default code stream)
   2:     oPatch( int addr, int val )  % patch an int into address in the generated code
                                       %   (only usable in the default code stream)
   2:     ;
      
   2: mechanism math:
   2:     inc (inout int)
   2:     dec (inout int)
   2:     negate (int) >> int
   2:     add( int x, int y ) >> int
   2:     subtract( int x, int y ) >> int     % x - y
   2:     multiply( int x, int y ) >> int     % x * y
   2:     equal( int x, int y ) >> boolean
   2:     equal_zero (int) >> boolean
   2:     equal_node( Node, Node ) >> boolean
   2:     equal_string( String, String ) >> boolean
   2:     equal_node_type (node_type, node_type) >> boolean     % Want equal_<type> for every type
   2:     equal_label( Label, Label ) >> boolean
   2:     equal_code( Code, Code ) >> boolean
   2:     greater( int x, int y ) >> boolean
   2:     oMININT >> int    % the minimum 32-bit integer.
   2:     oMAXINT >> int    % the maximum 32-bit integer.
   2:     ;
      
   2: mechanism more_builtins:      % These should be built-in SSL operations
   2:     TOKEN_VALUE >> int        % value of just accepted token, e.g. IntLit token
   2:     TOKEN_VALUE_DOUBLE >> double
   2:     LAST_ID >> int            % id number of last accepted identifier
   2:     ID_STRING( int id ) >> String       % text name of identifier with given id
   2:     CURRENT_STRLIT >> String            % text value of just-accepted string literal
   2:     UNACCEPT_TOKEN            % Unaccept the last accepted token.  The next input, inputchoice will see it again.
   2:     ;
      
   2: mechanism workspace_mech:
   2:     oWorkspaceNew >> Node
   2:     ;
      
   2: mechanism scope_mech:
   2:     oScopeBegin( int level, AllocMode )  % create a new scope. Subsequent declarations will go here.
                                               %  level = static scope depth (0 = globals)
   2:     oScopeEnter( Node scope )            % enter an existing scope.
   2:     oScopeEnd                            % end current scope. Subsequent declarations will go to previous scope.
   2:     oScopeCurrent >> Node                % returns current scope
   2:     oScopeDeclare( Node decl )           % add declaration to current scope.
   2:     oScopeDeclareAlloc( Node decl )      % add declaration to current scope, and allocate space according to its type
   2:     oScopeAllocType( Node theType ) >> int   % allocate space for type in current scope, and return its address
   2:     oScopeAlloc( int size, int align ) >> int % allocate bytes, with given alignment in bytes 
   2:     oScopeFind >> Node                   % find declaration of last accepted identifier.  Returns Null if not found.
   2:     oScopeFindRequire >> Node            % find declaration of last accepted identifier.  Error if not found.
   2:     oScopeFindInCurrentScope >> Node     % find declaration of last accepted identifier, only within the current scope.  Null if not found.
   2:     oScopeFindRequireInScope( Node scope ) >> Node  % find decl of last accepted identifier, only within the given scope.  Error it not found.
   2:     ;
      
   2: mechanism type_mech:
   2:     oTypeAdd( Node node )     % add the given nType to the type table
   2:     ;
      
   2: mechanism type_stack_mech:
   2:     oTypeSPush( Node node )
   2:     oTypeSPop
   2:     oTypeSTop >> Node
   2:     oTypeSNodeType >> node_type          % node_type of the node on top of type stack, skipping subranges
   2:     ;
      
      
   2: mechanism id_mech:
          % gets/adds a predefined id to the scanner's id table, and returns the id code
   2:     oId_mysystem >> int
   2:     oId_ShortStringAppendShortString >> int
   2:     oId_ShortStringAppendChar >> int
   2:     oId_ShortStringCmp >> int
   2:     oId_File >> int
   2:     oId_Integer >> int
   2:     oId_Boolean >> int
   2:     oId_Char >> int
   2:     oId_Byte >> int
   2:     oId_Single >> int
   2:     oId_Double >> int
   2:     oId_Pointer >> int
   2:     oId_ShortString >> int
   2:     oId_True >> int
   2:     oId_False >> int
   2:     oId_Nil >> int
   2:     oId_Ord >> int
   2:     oId_Chr >> int
   2:     oId_Pred >> int
   2:     oId_Succ >> int
   2:     oId_Sizeof >> int
   2:     oChangeIntLitToLabelIdent    % change current token from pIntLit to pIdent "_label_<intlit>"
   2:     ;
      
      
      
   2: mechanism label_mech:
   2:    oLabelNew >> Label
   2:    ;
      
   2: mechanism code_mech:
   2:    oCodeNew >> Code         % create a new empty code stream
   2:    oCodePush( Code )        % change the current output code stream to the given one
   2:    oCodePop                 % restore the current code stream to the previous one
   2:    oCodeDiscard( Code )     % discard the given code stream
   2:    ;
      
   2: mechanism include_mech:
   2:    oIncludeUnitFile( int id ) >> boolean  % search for <unit>.pas and include it.
                                                % returns false if can't find.
   2:    oIncludeEnd              % stop including the current file
   2:    ;
      
      
   2: mechanism count :
   2:    oCountPush(int)          % start a new counter, with initial value
   2:    oCountInc
   2:    oCountDec
   2:    oCountIsZero >> boolean
   2:    oCountPop;
      
      
   2: mechanism value :              % value stack, to calc. const expr's
   2:    oValuePush(int)             % push an explicit int lit
   2:    oValuePushDouble(double)    % push a double onto value stack
   2:    oValuePushString(String)    % push string onto value stack
   2:    oValueTop >> int            % get top value on value stack
   2:    oValueTopDouble >> double
   2:    oValueTopString >> String
   2:    oValueSwap                  % swap top two
   2:    oValuePop
   2:    oValueCharToString          % convert top value from char to string
   2:    oValueIntToDouble
      
   2:    oValueNegate                % negate top numeric value
   2:    oValueEqual
   2:    oValueNotEqual
   2:    oValueLess
   2:    oValueGreater
   2:    oValueLessEqual
   2:    oValueGreaterEqual
      
   2:    oValueNegateD               % operations on double values
   2:    oValueEqualD
   2:    oValueNotEqualD
   2:    oValueLessD
   2:    oValueGreaterD
   2:    oValueLessEqualD
   2:    oValueGreaterEqualD
      
   2:    oValueOr                    % boolean or
   2:    oValueAnd
   2:    oValueNot                   % boolean not
      
   2:    oValueAdd
   2:    oValueSub
   2:    oValueMult
   2:    oValueDiv
      
   2:    oValueAddD
   2:    oValueSubD
   2:    oValueMultD
   2:    oValueDivD
      
   2:    oValueStringCmp             % compare top two strings. replace with negative, 0, or positive
   2:    oValueStringConcat
   2:    ;
      
   2: mechanism string :
   2:    oStringAllocLit( String ) >> int      % alloc global space for strlit, return address
   2:    oStringAllocShortStringLit( String ) >> int  % alloc global space for ShortString, return address
   2:    ;
      
      % track labels for the loop we're in, if any
   2: mechanism loop_mech:
   2:    oLoopPush( Label continueLabel, Label breakLabel )
   2:    oLoopContinueLabel >> Label
   2:    oLoopBreakLabel >> Label
   2:    oLoopPop
   2:    ;
      
      % for hacky debugging
   2: mechanism msg_mech:
   2:    oMsg( int num )             % print message "oMsg <num>"
   2:    oMsgTrace( int num )        % print message "oMsg <num>" followed by ssl traceback
   2:    oMsgNode( Node node )       % print node
   2:    oMsgNodeLong( Node node )   % print node with more detail
   2:    oMsgNodeVec( NodeVec vec )  % print node vec
   2:    ;
      
      
   2: rules
      
      % ----------------------------- Global Variables ----------------------------
      
   2: Node    workspace              % root of database
   2: Node    globalScope            % scope for globals in the current module
   2: Node    initScope              % scope for temporaries global var init,
                                     % and program main stmt / unit initialization stmts
      
   2: int     mysystemId               % id of identifier "mysystem"
      
      % built-in nTypes
   2: Node    FileType
   2: Node    IntegerType
   2: Node    BooleanType
   2: Node    BooleanFlowType
   2: Node    CharType
   2: Node    PCharType
   2: Node    ByteType
   2: Node    SingleType
   2: Node    DoubleType
   2: Node    UniversalPointerType
   2: Node    StrLitType
   2: Node    ShortStringType
      
      % nBuiltInFunc
   2: Node    BuiltIn_Ord
   2: Node    BuiltIn_Chr
   2: Node    BuiltIn_Pred
   2: Node    BuiltIn_Succ
   2: Node    BuiltIn_Sizeof
      
      % Declarations in unit mysystem that the compiler may refer to directly.
      
   2: Node    System_ShortStringAppendShortString
   2: Node    System_ShortStringAppendChar
   2: Node    System_ShortStringCmp
      
      
      % Expr has a corner case flag, needed for sizeof()
   2: boolean flagExprAllowTypeName
      
      
      % -------------------------- Forward Declarations -------------------------
      
   2: Block( node_type varNodeType, Label labelForBody );
   2: BlockDecls( node_type varNodeType );
   2: BlockStmt( Label labelForBody, Node varScope, boolean isMain );
   2: VarDecl( node_type varNodeType );
   2: newType( node_type nt, int size ) >> Node;
   2: newIdent( node_type nt, int id ) >> Node;
   2: EmitValue( Node decl );
   2: TypeRef( out Node theType );
   2: EnumTypeRef( out Node resultType );
   2: PointerTypeTo( Node theType ) >> Node;
   2: OrdinalLow( Node theType ) >> int;
   2: OrdinalHigh( Node theType ) >> int;
   2: AssignStmt( Node decl );
   2: BooleanExprControlFlow( out Label falseLabel );
   2: ExprAllowFlow( out Label falseLabel );
   2: BoolExprAllowFlow( out Label falseLabel );
   2: BoolTermAllowFlow( out Label falseLabel );
   2: BoolFactorAllowFlow( out Label falseLabel );
   2: ArithExprAllowFlow( out Label falseLabel );
   2: TermAllowFlow( out Label falseLabel );
   2: FactorAllowFlow( out Label falseLabel );
   2: PrimaryAllowFlow( out Label falseLabel );
      
   2: VarExpr( Node decl );
   2: LValueFromDecl( Node decl, boolean writeable );
   2: LValueVar( Node decl, boolean writeable );
   2: IncVar( Node decl );
   2: DecVar( Node decl );
      
   2: FlowToVal( inout Label falseLabel );
   2: ValToFlow( out Label falseLabel );
   2: MoveIntoTempShortString >> int;
      
   2: DeclLevel( Node decl ) >> int;
   2: DeclUpLevels( Node decl ) >> int;
      
      % ----------------------------- Start ----------------------------
      
   2: MainRule:
   4:    @Program
   7:    ;
      
   7: include 'pascal_unit.ssl'
      
      %
      %  Pascal Compiler
      %
      
      % ------------------------------ Units -----------------------------
      
      
      % The uses clause is a list of units required by the user program or unit.
      % We will find and compile the named units (unless already loaded).
      % We do not make the unit interface visible to the user, the caller will do so later.
   7: UsesClause( Node user ):
   9:    {
   9:       pIdent
  11:       @Uses( LAST_ID, user )
  20:       [
  20:          | ',' :
  22:          | * :  >
  29:       ]
  29:    }   
  31:    ';'
  34:    ;
      
      
      % Process an implicit "uses mysystem" in every module, except in the mysystem unit itself.
      % (I'm calling the unit mysystem rather than system, so fpc doesn't use it to replace its own system unit.)
      %
  34: UsesMySystem( Node user ):
  36:    [ equal( oNodeGetInt( user, qIdent ), mysystemId )
  53:       | true :  >>
  55:       | * :
  60:    ]
  60:    @Uses( mysystemId, user )
  71:    ;
      
      
      % After processing the mysystem unit interface, grab certain declarations from it
      % that the compiler may want to refer to later.
      %
  71: FindSelectSystemDecls( Node unit ):
  73:    [ equal( oNodeGetInt( unit, qIdent ), mysystemId )
  90:       | true :
  91:          System_ShortStringAppendShortString = oNodeFind( oScopeCurrent, qDecls, qIdent, oId_ShortStringAppendShortString )
 108:          System_ShortStringAppendChar = oNodeFind( oScopeCurrent, qDecls, qIdent, oId_ShortStringAppendChar )
 125:          System_ShortStringCmp = oNodeFind( oScopeCurrent, qDecls, qIdent, oId_ShortStringCmp )
 142:       | * :
 147:    ]
 148:    ;
      
      
      % The given user module uses a unit with the given id,
      % which may or may not have been loaded already.
      %
 148: Uses( int id, Node user ):
 150:    Node unit = @FindOrCompileUnit( id )
 161:    [ equal_node( unit, Null )
 171:       | false :
 172:          oNodeAddLast( user, qUsedUnits, unit )
      
               % Put a declaration in the current scope, naming the unit and pointing to it.
               % This is to allow references to  <unit>.<identifier_in_unit>
 184:          Node unitRef = oNodeNew( nUnitRef )
 194:          oNodeSetInt( unitRef, qIdent, oNodeGetInt( unit, qIdent ) )
 213:          oNodeSet( unitRef, qPublicScope, oNodeGet( unit, qPublicScope ) )
 232:          oScopeDeclare( unitRef )
 238:       | * :
 243:    ];
      
      
      % If the given decl is for an nUnitRef, the program is using syntax <unit>.<identifier>
      % Parse the rest of that to find the intended decl.
      %
 244: ResolveUnitRef( inout Node decl ):
 246:    [ oNodeType( decl )
 253:       | nUnitRef :
 254:          Node scope = oNodeGet( decl, qPublicScope )
 267:          '.'
 269:          pIdent
 271:          decl = oScopeFindRequireInScope( scope )
 281:       | * :
 286:    ];
      
      
 287: EnterUsedUnits( Node user ):
         % Make the used units' public scopes directly visible.
         % This is done after the units are all compiled, so they don't interfere with each other incorrectly.
         % Units later in the list have priority.
 289:    NodeIter unitIt = oNodeGetIter( user, qUsedUnits )
 302:    {
 302:       Node unit = oNodeIterValue( unitIt )
 312:       [ oNodeNull( unit )
 319:          | false :
 320:             oScopeEnter( oNodeGet( unit, qPublicScope ) )
 333:          | * :
 338:             >
 340:       ]
 340:       oNodeIterNext( unitIt )
 346:    }
 349:    ;
      
 349: EndUsedUnits( Node user ):
         % Leave the units' public scopes, so no longer visible.
 351:    NodeIter unitIt = oNodeGetIterLast( user, qUsedUnits )
 364:    {
 364:       Node unit = oNodeIterValue( unitIt )
 374:       [ oNodeNull( unit )
 381:          | false :
                  % Consistency check.  Make sure our scope enter / end have lined up correctly.
 382:             [ oNodeEqual( oScopeCurrent, oNodeGet( unit, qPublicScope ) )
 398:                | true :
 399:                | false :  #eInternalScopeMismatch
 403:             ]
 411:             oScopeEnd
 412:          | * :
 417:             >
 419:       ]
 419:       oNodeIterPrev( unitIt )
 425:    }
 428:    ;
      
      
 428: FindOrCompileUnit( int id ) >> Node:
         % We might have this unit loaded already
 430:    Node unit = oNodeFind( workspace, qUnits, qIdent, id )
 449:    [ equal_node( unit, Null )
 459:       | false :  >> unit
 463:       | * :
 468:    ]
      
         % If not, search for the source file on disk
 468:    boolean ok = oIncludeUnitFile( id )
 478:    [ ok
 481:       | false :  #eCantFindUnitFile  >> Null
 487:       | * :
 492:    ]
      
         % compile it, adding it into the workspace
         % then return it.
 492:    unit = @Unit
      
         % TO DO: ensure we are at pEof
         % end the include
 498:    oIncludeEnd
 499:    >> unit;
      
      
      
 503: Unit >> Node:
 505:    pUnit
 507:    pIdent
 509:    Node unit = oNodeNew( nUnit )
 519:    oNodeSetInt( unit, qIdent, LAST_ID )
 530:    Node unitImpl = oNodeNew( nUnitImpl )
 540:    oNodeSetInt( unitImpl, qIdent, LAST_ID )
 551:    oNodeSet( unit, qImpl, unitImpl )
 563:    ';'
      
         % mandatory sections
      
 565:    pInterface
 567:    @UsesMySystem( unit )
 574:    [
 574:       | pUses :   @UsesClause( unit )
 583:       | * :
 588:    ]
 588:    @EnterUsedUnits( unit )
      
 595:    oScopeBegin( 0, allocGlobal )
 604:    oNodeSet( unit, qPublicScope, oScopeCurrent )
 615:    globalScope = oScopeCurrent
      
         % A scope for temporaries needed by variable initialization
 620:    oScopeBegin( 0, allocDown )
 629:    initScope = oScopeCurrent
 634:    oNodeSet( unit, qInitRoutineScope, initScope )
 646:    oScopeEnd
      
 647:    @UnitInterface( unit )
 654:    oScopeEnd  % interface scope
      
 655:    pImplementation
 657:    @UsesMySystem( unitImpl )
 664:    [
 664:       | pUses :   @UsesClause( unitImpl )
 673:       | * :
 678:    ]
 678:    @EnterUsedUnits( unitImpl )
         % re-enter interface scope after impl's uses.  interface still has priority.
 685:    oScopeEnter( oNodeGet( unit, qPublicScope ) )
         
 698:    oScopeBegin( 0, allocGlobal )
 707:    oNodeSet( unit, qPrivateScope, oScopeCurrent )
 718:    oNodeSet( oScopeCurrent, qExtends, oNodeGet( unit, qPublicScope ) )
 736:    globalScope = oScopeCurrent
 741:    @UnitImplementation( unit )
      
 748:    [
 748:       | pInitialization :  @UnitInitialization( unit, true )   % init routine with statements from init section
 760:       | * :                @UnitInitialization( unit, false )  % implicit init routine
 775:    ]
 775:    [
 775:       | pFinalization :  @UnitFinalization( unit, true )
 787:       | * :              @UnitFinalization( unit, false )   % implicit final routine, may be handy later
 802:    ]
 802:    pEnd  '.'
      
 806:    oScopeEnd  % impl scope
 807:    oScopeEnd  % interface scope
 808:    @EndUsedUnits( unitImpl )  % used units scopes
 815:    @EndUsedUnits( unit )
 822:    oNodeAddLast( workspace, qUnits, unit )
 834:    >> unit;
      
      
 838: UnitInterface( Node unit ):
 840:    {[
 840:       | pConst :     @ConstDecl
 844:       | pType :      @TypeDecl
 848:       | pVar :       @VarDecl( nGlobalVar )
            % label declaration not allowed in interface
      
 857:       | pProcedure :
 859:          Node decl = @ProcHeaderDecl
               % despite syntax diagrams, fpc does allow external clause on methods in unit interface,
               % even though this clause is an alternative for the body statement.
 865:          [
 865:             | pExternal :
 867:                @ExternalDecl( decl )
 874:                ';'
 876:             | * :
 881:          ]
      
 881:       | pFunction :
 883:          Node decl = @FuncHeaderDecl
 889:          [
 889:             | pExternal :
 891:                @ExternalDecl( decl )
 898:                ';'
 900:             | * :
 905:          ]
      
 905:       | * :          >
 920:    ]}
 922:    @FindSelectSystemDecls( unit )
 930:    ;
      
 930: UnitImplementation( Node unit ):
 932:    @BlockDecls( nGlobalVar )
 940:    ;
      
      
 940: UnitInitialization( Node unit, boolean hasStmts ):
 942:    Label label = oLabelNew
 947:    .tLabel  oEmitLabel( label )
 955:    oNodeSetLabel( unit, qInitLabel, label )
      
 967:    int patchLS
 967:    .tEnter  patchLS = Here  .tSpace
      
         % insert any code for initialization of this unit's variables.
         
 976:    Node scope
 976:    Code initCode
      
 976:    scope = oNodeGet( unit, qPublicScope )
 989:    initCode = oNodeGetCode( scope, qInitCode )
1002:    oEmitCode( initCode )
1008:    oNodeSetCode( scope, qInitCode, codeNull )
      
1020:    scope = oNodeGet( unit, qPrivateScope )
1033:    initCode = oNodeGetCode( scope, qInitCode )
1046:    oEmitCode( initCode )
1052:    oNodeSetCode( scope, qInitCode, codeNull )
      
1064:    oScopeEnter( oNodeGet( unit, qInitRoutineScope ) )
      
1077:    [ hasStmts
1080:       | true :     
1081:          @Statement
1083:          {[
1083:             | ';' :  @Statement
1087:             | * :    >
1094:          ]}
1096:       | * :
1101:    ]
      
1101:    .tReturn
      
1103:    int localSpace = oNodeGetInt( oScopeCurrent, qSize )
1115:    oPatch( patchLS, localSpace )
1124:    oScopeEnd   % init routine scope, for temporaries
1126:    ;
      
      
1126: UnitFinalization( Node unit, boolean hasStmts ):
1128:    Label label = oLabelNew
1133:    .tLabel  oEmitLabel( label )
1141:    oNodeSetLabel( unit, qFinalLabel, label )
      
1153:    int patchLS
1153:    .tEnter  patchLS = Here  .tSpace
      
         % final routine scope, for temporaries
1162:    oScopeBegin( 0, allocDown )
      
1171:    [ hasStmts
1174:       | true :     
1175:          @Statement
1177:          {[
1177:             | ';' :  @Statement
1181:             | * :    >
1188:          ]}
1190:       | * :
1195:    ]
      
1195:    .tReturn
      
1197:    int localSpace = oNodeGetInt( oScopeCurrent, qSize )
1209:    oPatch( patchLS, localSpace )
1218:    oScopeEnd   % final routine scope, for temporaries
1220:    ;
      
      
1220: InitializeUnits:
         % call init routine of each loaded unit, in the order they were loaded
         % (used directly or indirectly by the main program).
1222:    NodeIter it = oNodeGetIter( workspace, qUnits )
1235:    {
1235:       Node unit = oNodeIterValue( it )
1245:       [ oNodeNull( unit )
1252:          | true :  >
1255:          | false :
1257:             .tAllocActuals  oEmitInt( 0 )  % not sure I need this. maybe for stack alignment.
1265:             .tCall  oEmitLabel( oNodeGetLabel( unit, qInitLabel ) )
1280:             .tFreeActuals  oEmitInt( 0 )
1288:             oNodeIterNext( it )
1294:       ]
1302:    };
      
      
1305: FinalizeUnits:
1307:    NodeIter it = oNodeGetIterLast( workspace, qUnits )
1320:    {
1320:       Node unit = oNodeIterValue( it )
1330:       [ oNodeNull( unit )
1337:          | true :  >
1340:          | false :
1342:             .tAllocActuals  oEmitInt( 0 )  % not sure I need this. maybe for stack alignment.
1350:             .tCall  oEmitLabel( oNodeGetLabel( unit, qFinalLabel ) )
1365:             .tFreeActuals  oEmitInt( 0 )
1373:             oNodeIterPrev( it )
1379:       ]
1387:    };
      
1390: include 'pascal_decl.ssl'
      %
      % Pascal Compiler
      %
      
      % ----------------------------- Declarations ----------------------------
      
      
      
      % modifers that may appear on a proc/function declaration.
      %
1390: MethodModifiers( Node decl ):
1392:    {[
1392:       | pCdecl :
1394:          oNodeSetBoolean( decl, qCdecl, true )
1406:          ';'
      
1408:       | * : >
1415:    ]}
1418:    ;
      
      
      % external method resides in an external object file
      % (or in my system, the built-in runtime library).
      % The method has a label, as usual, which callers will use.
      % But we define that label with .tLabelExtern rather than .tLabel.
      %
      % Note this is fpc syntax.  I'm not sure about other Pascals.
      %
1418: ExternalDecl( Node decl ):
1420:    [ equal_zero( @DeclLevel( decl ) )
1432:       | false :  #eExternalMethodCannotBeNested
1435:       | * :
1440:    ]
         % For now, only cdecl methods may be declared external
1440:    [ oNodeGetBoolean( decl, qCdecl )
1450:       | false :  #eExternalMethodMustBeCdecl
1453:       | * :
1458:    ]
1458:    oNodeSetBoolean( decl, qExternal, true )
1470:    [
1470:       | pStrLit :
               % that was the optional library name containing the method.
               % TO DO: I'm currently ignoring this.
1472:          [
1472:             | pName :
1474:                pStrLit
                     % that was the optional method name defined in that library,
                     % which might differ from the Pascal name.
1476:                oNodeSetString( decl, qExternalName, CURRENT_STRLIT )
1487:             | * :
1492:          ]
1492:       | * :
1497:    ]
1497:    @DefineExternLabel( decl )
1505:    ;
      
      
1505: ProcHeaderDecl >> Node:
1507:    pIdent
      
         % If we already have a forward declaration, we'll modify that decl
         % instead of creating a second symbol table entry.
         % (Alternatively could delete or hide the old entry.)
1509:    boolean redeclaring = false
1515:    Node decl = oScopeFindInCurrentScope
      
1520:    [ oNodeNull( decl )
1527:       | true :
               % first declaration
1528:          decl = @newIdent( nProc, LAST_ID )
1541:          oNodeSetLabel( decl, qValue, oLabelNew )
      
1552:       | false :
               % we already have a declaration.
               % Keep it, and its label.
1554:          redeclaring = true
1560:          [ oNodeGetBoolean( decl, qBodyDefined )
1570:             | true : #eAlreadyDefined
1573:             | * :
1578:          ]
1578:          [ oNodeGetBoolean( decl, qExternal )
1588:             | true : #eAlreadyDefined
1591:             | * :
1596:          ]
1596:          [ oNodeType( decl )
1603:             | nProc :
1604:             | * : #eAlreadyDefined   % wrong kind
1611:          ]
               % Move the existing param scope aside, so we can check that the
               % new one is consistent.  And, the body will want to see the new one
               % since the names might differ.
               % TO DO: If qOldParams already set, we have multiple forward decls,
               % which I believe is supposed to be an error.
1611:          oNodeSet( decl, qOldParams, oNodeGet( decl, qParams ) )
1630:          oNodeSet( decl, qParams, Null )
1642:    ]
      
1650:    int level = @ScopeLevel
1656:    boolean nested = greater( level, 0 )
1669:    inc( level )
1675:    oScopeBegin( level, allocUp )
1684:    Node paramScope = oScopeCurrent
      
         % A nested method has a hidden first param for the parent static scope.
         % This won't appear in the param decls list, just reserve space for it.
         % It's first so the static chain is always at a fixed offset from the frame pointer.
1689:    [ nested
1692:       | true :
1693:          int offset = oScopeAllocType( @PointerTypeTo( IntegerType ) )   % arbitrary ptr type
1708:       | * :
1713:    ]
      
1713:    @FormalArgDecl
1715:    oNodeSet( decl, qParams, paramScope )
1727:    oScopeEnd
1728:    ';'
      
1730:    [ redeclaring
1733:       | false : oScopeDeclare( decl )
1740:       | true :  % TO DO: check that qParams is consistent with qOldParams
1742:    ]
      
1750:    @MethodModifiers( decl )
1757:    >> decl;
      
      
1761: ProcDecl:
1763:    Node decl = @ProcHeaderDecl
      
         % Body may be a statement, "forward", "external".
         % Note, this syntax is based on FPC, and I'm not sure if other Pascals are similar.
         % FPC says that forward, external, cdecl, name, etc are not reserved words -
         % I think this means the user may declare other things with those names, but if so the
         % original meaning is lost.  I'll make them keywords for simplicity, for now
         % (just not too happy about "name").
      
1769:    [
1769:       | pForward :
               % Nothing to do.  We simply won't set qBodyDefined.
      
1771:       | pExternal : @ExternalDecl( decl )
      
1780:       | * :
               % Body statement
      
               % Enter the params scope again, so params are visible in body.
               % TO DO: Perhaps I could mark the scope read-only at this point.
1787:          Node paramScope = oNodeGet( decl, qParams )
1800:          oScopeEnter( paramScope )
      
               % Start scope for declarations within the proc
1806:          int level = oNodeGetInt( paramScope, qLevel )
1819:          oScopeBegin( level, allocDown )
1828:          oNodeSet( decl, qChildScope, oScopeCurrent )
      
1839:          Label label = oNodeGetLabel( decl, qValue )
1852:          @Block( nLocalVar, label )
1862:          oNodeSetBoolean( decl, qBodyDefined, true )
1874:          oScopeEnd
      
1875:          oScopeEnd  % paramScope
1876:    ]
1876:    ';';
      
      
      
1879: FuncHeaderDecl >> Node:
1881:    pIdent
      
         % If we already have a forward declaration, we'll modify that decl
         % instead of creating a second symbol table entry.
         % (Alternatively could delete or hide the old entry.)
1883:    boolean redeclaring = false
1889:    Node decl = oScopeFindInCurrentScope
      
1894:    [ oNodeNull( decl )
1901:       | true :
               % first declaration
1902:          decl = @newIdent( nFunc, LAST_ID )
1915:          oNodeSetLabel( decl, qValue, oLabelNew )
      
1926:       | false :
               % we already have a declaration.
               % Keep it, and its label.
1928:          redeclaring = true
1934:          [ oNodeGetBoolean( decl, qBodyDefined )
1944:             | true : #eAlreadyDefined
1947:             | * :
1952:          ]
1952:          [ oNodeType( decl )
1959:             | nFunc :
1960:             | * : #eAlreadyDefined   % wrong kind
1967:          ]
               % Move the existing param scope and return value aside,
               % so we can check that the new one is consistent.
               % And, the body will want to see the new one since the names might differ.
               % TO DO: If qOldParams already set, we have multiple forward decls,
               % which I believe is supposed to be an error.
1967:          oNodeSet( decl, qOldParams, oNodeGet( decl, qParams ) )
1986:          oNodeSet( decl, qParams, Null )
1998:          oNodeSet( decl, qOldType, oNodeGet( decl, qType ) )
2017:          oNodeSet( decl, qType, Null )
2029:    ]
      
2037:    int level = @ScopeLevel
2043:    boolean nested = greater( level, 0 )
2056:    inc( level )
2062:    oScopeBegin( level, allocUp )
2071:    Node paramScope = oScopeCurrent
      
         % A nested method has a hidden first param for the parent static scope.
         % This won't appear in the param decls list, just reserve space for it.
         % It's first so the static chain is always at a fixed offset from the frame pointer.
2076:    [ nested
2079:       | true :
2080:          int offset = oScopeAllocType( @PointerTypeTo( IntegerType ) )   % arbitrary ptr type
2095:       | * :
2100:    ]
      
2100:    @FormalArgDecl
2102:    oNodeSet( decl, qParams, paramScope )
      
2114:    ':'
      
2116:    Node theType
2116:    @TypeRef( theType )
2123:    oNodeSet( decl, qType, theType )
      
         % The function's param space gets an additional pointer,
         % which will point to a temporary in the caller's scope.
         % This pointer is essentially a VAR param, but I won't create an nParam for it.
      
2135:    Node ptrType = @PointerTypeTo( theType )
2146:    oNodeSetInt( decl, qResultOffset, oScopeAllocType( ptrType ) )
2162:    oScopeEnd
2163:    ';'
      
2165:    [ redeclaring
2168:       | false : oScopeDeclare( decl )
2175:       | true :  % TO DO: check that qParams is consistent with qOldParams
                      % and qType is consistent with qOldType
2177:    ]
      
2185:    @MethodModifiers( decl )
      
2192:    >> decl;
      
      
2196: FuncDecl:
2198:    Node decl = @FuncHeaderDecl
      
         % Body may be a statement, "forward", "external".
2204:    [
2204:       | pForward :
               % Nothing to do.  We simply won't set qBodyDefined.
      
2206:       | pExternal : @ExternalDecl( decl )
      
2215:       | * :
               % Body statement
      
               % Enter the params scope again, so params are visible in body.
               % TO DO: Perhaps I could mark the scope read-only at this point.
2222:          Node paramScope = oNodeGet( decl, qParams )
2235:          oScopeEnter( paramScope )
      
               % Start scope for declarations within the func
2241:          int level = oNodeGetInt( paramScope, qLevel )
2254:          oScopeBegin( level, allocDown )
2263:          oNodeSet( decl, qChildScope, oScopeCurrent )
      
2274:          Label label = oNodeGetLabel( decl, qValue )
2287:          @Block( nLocalVar, label )
2297:          oNodeSetBoolean( decl, qBodyDefined, true )
2309:          oScopeEnd
      
2310:          oScopeEnd  % paramScope
2311:    ]
2311:    ';';
      
      
2314: FormalArgDecl:
2316:    [
2316:       | '(' :
2318:          {
2318:             NodeVec decls = oNodeVecNew
2323:             Node decl
2323:             boolean isInOut = false
      
2329:             [
2329:                | pVar : isInOut = true
2337:                | * :
2342:             ]
      
2342:             {  pIdent
      
2344:                decl = @newIdent( nParam, LAST_ID )
2357:                oNodeSetBoolean( decl, qInOut, isInOut )
2369:                oNodeVecAppend( decls, decl )
      
2378:                [
2378:                   | ':' : >
2382:                   | ',' :
2384:                ]
2392:             }
      
2394:             Node theType
2394:             @TypeRef( theType )
      
                  % VAR param is declared with its given type, but allocated as a pointer.
2401:             Node allocType
2401:             [ isInOut
2404:                | true :   allocType = @PointerTypeTo( theType )
2416:                | * :      allocType = theType
2427:             ]
      
2427:             int i = 0
2433:             {[ equal( i, oNodeVecSize( decls ) )
2447:                | false :
2448:                   decl = oNodeVecElement( decls, i )
      
2461:                   oNodeSet( decl, qType, theType )
2473:                   oScopeDeclare( decl )
2479:                   oNodeSetInt( decl, qValue, oScopeAllocType( allocType ) )
2495:                   inc( i )
2501:                | * :
2506:                   >
2508:             ]}
      
2510:             oNodeVecDelete( decls )
      
2516:             [
2516:                | ')' : >
2520:                | ';' :
2522:             ]
2530:          }
2532:       | * :
2537:    ];
      
      
2538: ConstDecl:
2540:    {[
2540:       | pIdent :
2542:          [
2542:             | ':' :
2544:                @TypedConstDecl
2546:             | * :
2551:                @TrueConstDecl
2553:          ]
2553:       | * :
2558:          >
2560:    ]};
      
      
      % Parse a true constant declaration (as opposed to a typed const declaration).
      % The "true constant" terminology comes from Delphi docs.  It refers to a const that is
      % evaluated at compile time, rather than at program startup time.
      %
      % We've just accepted the identifier.
      %
2563: TrueConstDecl:
2565:    int id = LAST_ID
2570:    '='
      
2572:    @ConstExpr
      
2574:    Node decl
2574:    [ oTypeSNodeType
2576:       | nBooleanType, nByteType, nCharType, nIntegerType, nEnumType,
2577:         nPointerType, nUniversalPointerType :
2577:          decl = @newIdent( nConst, id )
2591:          oNodeSetInt( decl, qValue, oValueTop )
2602:       | nDoubleType :
2604:          decl = @newIdent( nConstDouble, id )
2618:          oNodeSetDouble( decl, qValueDouble, oValueTopDouble )
2629:       | nStrLitType :
2631:          decl = @newIdent( nConstStr, id )
2645:          oNodeSetString( decl, qValueStr, oValueTopString )
2656:       | * :  #eNotAllowed
2679:    ]
2679:    oValuePop
2680:    oNodeSet( decl, qType, oTypeSTop )
2691:    oTypeSPop
2692:    oScopeDeclare( decl )
2698:    ';'
2701:    ;
      
      
      % Parse a typed const declaration.
      % We've just accepted the identifier and ':'
      %
2701: TypedConstDecl:
2703:    Node decl = @newIdent( nTypedConst, LAST_ID )
      
2716:    Node theType
2716:    @TypeRef( theType )
2723:    oNodeSet( decl, qType, theType )
      
         % Array and record consts are allocated in global memory,
         % with global offset stored as decl value.
         % Scalar consts are not allocated in memory, and their value is
         % stored directly as the decl value, as I do with "true constants".
         %
         % TO DO: I probably should store scalar consts in memory too, in case somebody
         % wants to get a pointer to them.  And anyway, typed constants can't be used in
         % constant expressions, so less need to store value in decl node.
      
         % TO DO: skip subranges, similar to oTypeSNodeType.
2735:    [ oNodeType( theType )
2742:       | nBooleanType, nByteType, nCharType, nIntegerType, nEnumType,
2743:         nPointerType, nUniversalPointerType :
               % Parse expression and store value in decl
2743:          '='
      
2745:          oTypeSPush( theType )
2751:          @ConstExpr
2753:          @ConstCoerceType
      
2755:          oNodeSetInt( decl, qValue, oValueTop )
2766:          oValuePop
2767:          oTypeSPop
2768:          oScopeDeclare( decl )
2774:          ';'
      
2776:       | nShortStringType, nFileType :
2778:          #eNotImplemented
      
2780:       | nArrayType, nRecordType :
               % Allocate global space, store address in decl.
               % Push into global scope init code stream (since we'll be issuing code
               % rather than creating static data, at the moment).
               % Parse expression and store in global memory.
2782:          oScopeEnter( globalScope )
2788:          int addr = oScopeAllocType( theType )
2798:          oScopeEnd
2799:          oCodePush( @GetOrCreateInitCode( globalScope ) )
2810:          oNodeSetInt( decl, qValue, addr )
2822:          '='
2824:          @TypedConstInit( theType, addr )
2834:          oCodePop
2835:          oScopeDeclare( decl )
2841:          ';'
2843:    ]
2870:    ;
      
      
      % Parse the initial value of a constant that's being stored in global memory.
      % (An array or record constant, and recursively all its elements.)
      % Given the type, and the address in global memory for the const value.
      % The caller has already pushed into the global init code stream.
      %
2870: TypedConstInit( Node theType, int addr ):
      
         % TO DO: skip subranges, similar to oTypeSNodeTYpe
2872:    [ oNodeType( theType )
2879:       | nArrayType :
2880:          Node baseType = oNodeGet( theType, qBaseType )
2893:          Node indexType = oNodeGet( theType, qIndexType )
2906:          int low = @OrdinalLow( indexType )
2917:          int high = @OrdinalHigh( indexType )
2928:          int elementSize = oNodeGetInt( baseType, qSize )
      
2941:          '('
               % Loop over elements
2943:          int i = low
2949:          {
2949:             @TypedConstInit( baseType, addr )
2959:             [ equal( i, high )
2969:                | true : >
2972:                | false :
2974:             ]
2982:             ','
2984:             addr = add( addr, elementSize )
2997:             inc( i )
3003:          }
3005:          ')'
      
3007:       | nRecordType :
3009:          '('
3011:          Node fieldScope = oNodeGet( theType, qScope )
               % Loop over zero or more named fields.  It's not necessary to name them all.
               % fpc says the names that are given should be in order, but I'm not requiring that.
               % Since this is global memory, uninitialized fields will be left as 0.
3024:          {
3024:             [
3024:                | pIdent :
3026:                | * :  >
3033:             ]
3033:             Node field = oScopeFindRequireInScope( fieldScope )
3043:             ':'
3045:             Node fieldType = oNodeGet( field, qType )
3058:             int fieldAddr = add( addr, oNodeGetInt( field, qValue ) )
3078:             @TypedConstInit( fieldType, fieldAddr )
3088:             [
3088:                | ';' :
3090:                | * :  >
3097:             ]
3097:          }
3099:          ')'
      
3101:       | nBooleanType, nByteType, nCharType:
3103:          .tPushAddrGlobal  oEmitInt( addr )
3111:          oTypeSPush( theType )
3117:          @ConstExpr
3119:          @ConstCoerceType
3121:          .tPushConstI  oEmitInt( oValueTop )
3128:          oValuePop
3129:          oTypeSPop
3130:          .tAssignB
      
3132:       | nIntegerType, nEnumType:
3134:          .tPushAddrGlobal  oEmitInt( addr )
3142:          oTypeSPush( theType )
3148:          @ConstExpr
3150:          @ConstCoerceType
3152:          .tPushConstI  oEmitInt( oValueTop )
3159:          oValuePop
3160:          oTypeSPop
3161:          .tAssignI
      
3163:       | nDoubleType:
3165:          #eNotImplemented
      
3167:       | nPointerType, nUniversalPointerType :
3169:          .tPushAddrGlobal  oEmitInt( addr )
3177:          oTypeSPush( theType )
3183:          @ConstExpr
3185:          @ConstCoerceType
3187:          .tPushConstI  oEmitInt( oValueTop )   % only allowing ptr constant Nil so don't need tPushConstP or link redirection
3194:          oValuePop
3195:          oTypeSPop
3196:          .tAssignP
      
3198:       | nShortStringType, nFileType :
3200:          #eNotImplemented
3202:    ]
3231:    ;
      
      
3231: TypeDecl:
3233:    {[
3233:       | pIdent :
3235:          Node decl = @newIdent( nTypeDecl, LAST_ID )
3248:          '='
3250:          Node theType
3250:          @TypeRef( theType )
3257:          oNodeSet( decl, qType, theType )
3269:          oScopeDeclare( decl )
3275:          ';'
3277:       | * :
3282:          >
3284:    ]};
      
3287: VarDecl( node_type varNodeType ):
3289:    {[
3289:       | pIdent :
3291:          NodeVec decls = oNodeVecNew
3296:          Node decl
3296:          {
3296:             decl = @newIdent( varNodeType, LAST_ID )
3309:             oNodeVecAppend( decls, decl )
3318:             [
3318:                | ',' :
3320:                   pIdent
3322:                | * :
3327:                   >
3329:             ]
3329:          }
3331:          ':'
3333:          Node theType
3333:          @TypeRef( theType )
      
3340:          int i = 0
3346:          {[ equal( i, oNodeVecSize( decls ) )
3360:             | false :
3361:                decl = oNodeVecElement( decls, i )
3374:                oNodeSet( decl, qType, theType )
3386:                oScopeDeclareAlloc( decl )
3392:                inc( i )
3398:             | * :
3403:               >
3405:          ]}
      
               % optional initialization
3407:          [
3407:             | '=' :
3409:                [ oNodeVecSize( decls )
3416:                   | 1 :
3417:                   | * :  #eOnlyOneVarCanBeInitialized
3424:                ]
      
                     % we need an initCode stream for this scope
3424:                Code initCode = @GetOrCreateInitCode( oScopeCurrent )
3434:                oCodePush( initCode )
      
                     % currently the global level has two scopes:
                     % the one for declarations e.g. vars and methods,
                     % and a second one for temporaries needed by the main block stmt.
                     % During evaluation of the init expr, we need to be in the 2nd scope
                     % in case the expression requires temporaries
                     % (so the temporaries get allocated in the right scope).
                     % TO DO: Maybe I should make the global scope the special case, instead.
3440:                boolean changedScope = false
3446:                [ equal_zero( @ScopeLevel )
3453:                   | true : oScopeEnter( initScope )
3460:                            changedScope = true
3466:                   | * :
3471:                ]
                     % generate assignment in initCode stream
3471:                @LValueVar( decl, true )
3481:                @Expr
3483:                @CoerceType
3485:                @Assign
3487:                [ changedScope
3490:                   | true : oScopeEnd
3492:                   | * :
3497:                ]
3497:                oCodePop
                   
3498:             | * :
3503:          ]
      
3503:          oNodeVecDelete( decls )
3509:          ';'
3511:       | * :
3516:          >
3518:    ]};
      
      
      % Parse a list of label declarations.
      % We'll create a tcode label at declaration time, for each user label.
      % If the user label is an integer, we'll record it as _label_<int> in the decl.
      %
3521: LabelDecl:
3523:    {
3523:       Node decl
3523:       [
3523:          | pIdent :
3525:          | pIntLit :
                  % Replace token with identifier "_label_<intlit>"
3527:             oChangeIntLitToLabelIdent
3528:       ]
3536:       decl = @newIdent( nLabel, LAST_ID )
            % TO DO: ensure not already declared in this scope.
            %        Or maybe that can be part of oScopeDeclare.
3549:       Label label = oLabelNew
3554:       oNodeSetLabel( decl, qValue, label )
3566:       oScopeDeclare( decl )
3572:       [
3572:          | ',' :
3574:          | * :
3579:             >
3581:       ]
3581:    }
3583:    ';'
3586:    ;
3586: include 'pascal_constexpr.ssl'
      %
      % Pascal Compiler
      %
      
      % --------------------------- Const Expressions --------------------------
      
      
      % Constant expressions are evaluated at compile time.
      % They are limited to constant literals, declared constants (not including TypedConstants!)
      % and a small selection of built-in functions. 
      %
      % The value of a constant expression is left on the Value Stack.
      % The type is left on the Type Stack.
      
3586: ConstExpr:
3588:    @ConstBoolExpr
3590:    {[
3590:       | '=' :
3592:          @ConstBoolTerm
3594:          @ConstCoerceTypePair
3596:          [ oTypeSNodeType
3598:             | nStrLitType :   oValueStringCmp  oValuePush( 0 )  oValueEqual
3607:             | nDoubleType :   oValueEqualD
3610:             | * :             oValueEqual
3618:          ]
3618:          oTypeSPop  oTypeSPush( BooleanType )
3625:       | '<>' :
3627:          @ConstBoolExpr
3629:          @ConstCoerceTypePair
3631:          [ oTypeSNodeType
3633:             | nStrLitType :   oValueStringCmp  oValuePush( 0 )  oValueNotEqual
3642:             | nDoubleType :   oValueNotEqualD
3645:             | * :             oValueNotEqual
3653:          ]
3653:          oTypeSPop  oTypeSPush( BooleanType )
3660:       | '<' :
3662:          @ConstBoolExpr
3664:          @ConstCoerceTypePair
3666:          [ oTypeSNodeType
3668:             | nStrLitType :   oValueStringCmp  oValuePush( 0 )  oValueLess
3677:             | nDoubleType :   oValueLessD
3680:             | * :             oValueLess
3688:          ]
3688:          oTypeSPop  oTypeSPush( BooleanType )
3695:       | '>' :
3697:          @ConstBoolExpr
3699:          @ConstCoerceTypePair
3701:          [ oTypeSNodeType
3703:             | nStrLitType :   oValueStringCmp  oValuePush( 0 )  oValueGreater
3712:             | nDoubleType :   oValueGreaterD
3715:             | * :             oValueGreater
3723:          ]
3723:          oTypeSPop  oTypeSPush( BooleanType )
3730:       | '<=' :
3732:          @ConstBoolExpr
3734:          @ConstCoerceTypePair
3736:          [ oTypeSNodeType
3738:             | nStrLitType :   oValueStringCmp  oValuePush( 0 )  oValueLessEqual
3747:             | nDoubleType :   oValueLessEqualD
3750:             | * :             oValueLessEqual
3758:          ]
3758:          oTypeSPop  oTypeSPush( BooleanType )
3765:       | '>=' :
3767:          @ConstBoolExpr
3769:          @ConstCoerceTypePair
3771:          [ oTypeSNodeType
3773:             | nStrLitType :   oValueStringCmp  oValuePush( 0 )  oValueGreaterEqual
3782:             | nDoubleType :   oValueGreaterEqualD
3785:             | * :             oValueGreaterEqual
3793:          ]
3793:          oTypeSPop  oTypeSPush( BooleanType )
3800:       | * :  >
3817:    ]};
      
      
      % Same as ConstExpr, but allow a typename as a primary.
      % This is for use within sizeof().
      % The value produced by that primary is bogus, but doesn't matter.
      %
3820: ConstExprAllowTypeName:
3822:    boolean oldAllowTypeName = flagExprAllowTypeName
3828:    flagExprAllowTypeName = true
3834:    @ConstExpr
3836:    flagExprAllowTypeName = oldAllowTypeName
3843:    ;
      
      
3843: ConstBoolExpr:
3845:    @ConstBoolTerm
3847:    {[
3847:       | pOr :
3849:          @ConstRequireBool
3851:          @ConstBoolTerm
3853:          @ConstRequireBoolPop
3855:          oValueOr
3856:       | * :  >
3863:    ]};
      
      
3866: ConstBoolTerm:
3868:    @ConstBoolFactor
3870:    {[
3870:       | pAnd :
3872:          @ConstRequireBool
3874:          @ConstBoolFactor
3876:          @ConstRequireBoolPop
3878:          oValueAnd
3879:       | * :  >
3886:    ]};
      
      
3889: ConstBoolFactor:
3891:    [
3891:       | pNot :
3893:          @ConstBoolFactor
3895:          @ConstRequireBool
3897:          oValueNot
3898:       | * :
3903:          @ConstArithExpr
3905:    ];
      
      
3906: ConstArithExpr:
3908:    @ConstTerm
3910:    {[
3910:       | '+' :
3912:          @ConstTerm
3914:          @ConstCoerceTypePair
3916:          [ oTypeSNodeType
3918:             | nStrLitType :   oValueStringConcat
3920:             | nDoubleType :   oValueAddD
3923:             | * :             oValueAdd
3931:          ]
3931:       | '-' :
3933:          @ConstTerm
3935:          @ConstCoerceTypePair
3937:          [ oTypeSNodeType
3939:             | nStrLitType :   #eNotAllowed
3942:             | nDoubleType :   oValueSubD
3945:             | * :             oValueSub
3953:          ]
3953:       | * :  >
3962:    ]};
      
      
3965: ConstTerm:
3967:    @ConstFactor
3969:    {[
3969:       | pTimes :
3971:          @ConstFactor
3973:          @ConstCoerceTypePair
3975:          [ oTypeSNodeType
3977:             | nStrLitType :   #eNotAllowed
3980:             | nDoubleType :   oValueMultD
3983:             | * :             oValueMult
3991:          ]
3991:       | pDivide :
3993:          @ConstFactor
3995:          @ConstCoerceTypePair
3997:          [ oTypeSNodeType
3999:             | nStrLitType :   #eNotAllowed
4002:             | nDoubleType :   oValueDivD
4005:             | * :             oValueDiv
4013:          ]
4013:       | * :  >
4022:    ]};
      
      
4025: ConstFactor:
4027:    [
4027:       | pPlus :
4029:          @ConstPrimary
4031:       | pMinus :
4033:          @ConstPrimary
4035:          [ oTypeSNodeType
4037:             | nStrLitType :   #eNotAllowed
4040:             | nDoubleType :   oValueNegateD
4043:             | * :             oValueNegate
4051:          ]
4051:       | * :
4058:          @ConstPrimary
4060:    ];
      
      
4061: ConstPrimary:
4063:    [
4063:       | pIntLit :
4065:          oValuePush( TOKEN_VALUE )
4070:          oTypeSPush( IntegerType )
4076:       | pCharLit :
4078:          oValuePush( TOKEN_VALUE )
4083:          oTypeSPush( CharType )
4089:       | pDoubleLit :
4091:          oValuePushDouble( TOKEN_VALUE_DOUBLE )
4096:          oTypeSPush( DoubleType )
4102:       | pStrLit :
4104:          oValuePushString( CURRENT_STRLIT )
4109:          oTypeSPush( StrLitType )
4115:       | '(' :
4117:          @ConstExpr
4119:          ')'
4121:       | pIdent :
4123:          Node decl = oScopeFindRequire
4128:          @ResolveUnitRef( decl )
4135:          [ oNodeType( decl )
4142:             | nBuiltInFunc :
4143:                @ConstBuiltInFunc( decl )
4150:             | nConst :
4152:                oValuePush( oNodeGetInt( decl, qValue ) )
4165:                oTypeSPush( oNodeGet( decl, qType ) )
4178:             | nConstStr :
4180:                oValuePushString( oNodeGetString( decl, qValueStr ) )
4193:                oTypeSPush( oNodeGet( decl, qType ) )
4206:             | nEnumValue :
4208:                oValuePush( oNodeGetInt( decl, qValue ) )
4221:                oTypeSPush( oNodeGet( decl, qType ) )
4234:             | nTypeDecl :
                     % A type cast, or a typename primary when within sizeof()
4236:                oTypeSPush( oNodeGet( decl, qType ) )
4249:                [
4249:                   | '(' :
                           % Type cast
4251:                      @ConstExpr
4253:                      ')'
4255:                      @ConstCastType
                           % Constexprs are not compound types or dereferenceable pointers (I believe)
                           % so no need to check for additional suffixes here as we do in PrimaryAllowCF
4257:                   | * :
                           % Not a type cast
                           % A raw typename is only allowed in expressions within sizeof
4262:                      [ flagExprAllowTypeName
4265:                         | true :
                                 % The value we produce is bogus.  Only the type stack matters.
4266:                            oValuePush( 0 )
4272:                         | * :   #eTypeNameNotAllowedHere
4279:                      ]
4279:                ]
      
4279:             | * :
4292:                #eNotConst
4294:                oValuePush( 0 )
4300:                oTypeSPush( IntegerType )
4306:          ]
4306:       | '@' :
4308:          #eNotImplemented
4310:          oValuePush( 0 )
4316:          oTypeSPush( UniversalPointerType )
4322:       | * :
4339:          #eNotConst
4341:          oValuePush( 0 )
4347:          oTypeSPush( IntegerType )
4353:    ];
      
4354: ConstRequireBoolPop:
4356:    [ oTypeSNodeType
4358:       | nBooleanType :
4359:       | * :          #eNotBoolean
4366:    ]
4366:    oTypeSPop;
      
      
4368: ConstRequireBool:
4370:    [ oTypeSNodeType
4372:       | nBooleanType :
4373:       | * :          #eNotBoolean
4380:    ];
      
      
      % Require that the top two types on the type stack are matching (ignoring subranges).
      % Pop one of them, leaving only one.
      % The types refer to constant values on the Value Stack,
      % so any implicit conversion would occur there, not in code.
      %
      % Some implicit conversion is allowed for either of the types.
      % See also ConstCoerceType where only the top type may change.
      %
4381: ConstMatchTypes:
4383:    node_type nt = oTypeSNodeType
4388:    oTypeSPop
4389:    [ equal_node_type( nt, oTypeSNodeType )
4398:       | false :
               % Some implicit conversion is allowed even here
4399:          [ oTypeSNodeType
4401:             | nPointerType :
4402:                [ nt
4405:                   | nUniversalPointerType :  >>
4407:                   | * :
4412:                ]
4412:             | nUniversalPointerType :
4414:                [ nt
4417:                   | nPointerType :  >>
4419:                   | * :
4424:                ]
4424:             | nStrLitType :
4426:                [ nt
4429:                   | nCharType :
4430:                      oValueCharToString
4431:                      >>
4432:                   | * :
4437:                ]
4437:             | nCharType :
4439:                [ nt
4442:                   | nStrLitType :
4443:                      oValueSwap
4444:                      oValueCharToString
4445:                      oValueSwap
4446:                      oTypeSPop
4447:                      oTypeSPush( StrLitType )
4453:                      >>
4454:                   | * :
4459:                ]
4459:             | * :
4470:          ]
4470:          #eTypeMismatch
4472:       | * :
4477:    ];
      
      
      % Given a constant value on the value stack, its type on the type stack,
      % and the desired type under it on the type stack.
      % Perform any necessary implicit conversions so the value is the desired type.
      % Pop the top type, leaving only the desired type.
      %
4478: ConstCoerceType:
4480:    node_type nt = oTypeSNodeType
4485:    oTypeSPop
4486:    [ equal_node_type( nt, oTypeSNodeType )
4495:       | false :
               % Can we implicitly convert the value to the desired type?
4496:          [ oTypeSNodeType
4498:             | nIntegerType :
4499:                [ nt
4502:                   | nByteType :  >>
4504:                   | * :
4509:                ]
4509:             | nByteType :
4511:                [ nt
4514:                   | nIntegerType :  >>
4516:                   | * :
4521:                ]
4521:             | nPointerType :
4523:                [ nt
4526:                   | nUniversalPointerType :  >>
4528:                   | * :
4533:                ]
4533:             | nUniversalPointerType :
4535:                [ nt
4538:                   | nPointerType :  >>
4540:                   | * :
4545:                ]
4545:             | nStrLitType :
4547:                [ nt
4550:                   | nCharType :
4551:                      oValueCharToString
4552:                      >>
4553:                   | * :
4558:                ]
4558:             | nShortStringType :
4560:                [ nt
4563:                   | nStrLitType :  >>
4565:                   | nCharType :
4567:                      oValueCharToString
4568:                      >>
4569:                   | * :
4576:                ]
4576:             | * :
4591:          ]
4591:          #eTypeMismatch
4593:       | * :
4598:    ];
      
      
      % The value stack contains two const values, and their two types are on the type stack.
      % Typically these are two arguments of an operator; the key is that botrh types are flexible.
      % Coerce one type to match the other.  Generally the smaller type is coerced to the larger.
      % Leave both values on the value stack, and the single common type on the type stack.
      %
4599: ConstCoerceTypePair:
         % TO DO.  For now, require the types to match
4601:    @ConstMatchTypes
4604:    ;
      
      
      % Given a constant value on the value stack, its type on the type stack,
      % and the desired type under it on the type stack.
      % Perform any necessary conversions so the value is cast to the desired type.
      % Pop the top type, leaving only the desired type.
      %
      % This is stronger than ConstCoerceType, since it isn't limited to implicit conversions.
      % There are still going to be limits on what is allowed though.
      %
4604: ConstCastType:
4606:    node_type nt = oTypeSNodeType
4611:    oTypeSPop
4612:    [ equal_node_type( nt, oTypeSNodeType )
4621:       | false :
               % Can we cast the value to the desired type?
4622:          [ oTypeSNodeType
4624:             | nIntegerType, nEnumType :
4625:                [ nt
4628:                   | nByteType, nCharType, nBooleanType :  >>
4630:                   | nIntegerType, nEnumType :  >>
                        % fpc does not allow explicit cast of double to integer.
                        % User must call trunc() / round().
4633:                   | * :
4646:                ]
4646:             | nByteType, nCharType, nBooleanType :
4648:                [ nt
4651:                   | nByteType, nCharType, nBooleanType :  >>
4653:                   | nIntegerType, nEnumType :  >>
4656:                   | * :
4669:                ]
4669:             | nDoubleType :
4671:                [ nt
4674:                   | nByteType, nCharType, nBooleanType, nIntegerType, nEnumType :
4675:                      oValueIntToDouble
4676:                      >>
4677:                   | nDoubleType :  >>
4680:                   | * :
4695:                ]
4695:             | nPointerType :
4697:                [ nt
4700:                   | nUniversalPointerType :  >>
4702:                   | * :
4707:                ]
4707:             | nUniversalPointerType :
4709:                [ nt
4712:                   | nPointerType :  >>
4714:                   | * :
4719:                ]
4719:             | nStrLitType :
4721:                [ nt
4724:                   | nCharType :
4725:                      oValueCharToString
4726:                      >>
4727:                   | * :
4732:                ]
4732:             | nShortStringType :
4734:                [ nt
4737:                   | nStrLitType :  >>
4739:                   | nCharType :
4741:                      oValueCharToString
4742:                      >>
4743:                   | * :
4750:                ]
4750:             | * :
4773:          ]
4773:          #eTypeMismatch
4775:       | * :
4780:    ];
      
      
      % These are the methods that Pascal allows in a constant expression:
      %   Abs( x: integer_or_real ) : integer_or_real
      %   Round( x: real ) : integer
      %   Trunc( x: real ) : integer
      %   Chr( x: integer ) : char
      %   Ord( x: ordinal ) : integer
      %   Length( s: string ) : integer
      %   Pred( x: ordinal ) : ordinal
      %   Succ( x: ordinal ) : ordinal
      %   SizeOf( var, expr, or typename ) : integer
      %   Odd( x: integer ) : boolean  - true if the argument is odd
      %
4781: ConstBuiltInFunc( Node method ):
      
         % Ord(x)
4783:    [ oNodeEqual( method, BuiltIn_Ord )
4793:       | true :
4794:          '('
4796:          @ConstExpr
4798:          ')'
4800:          [ oTypeSNodeType
4802:             | nIntegerType, nEnumType :
4803:             | nBooleanType, nByteType, nCharType :
4805:             | * :  #eTypeMismatch
4820:          ]
4820:          oTypeSPop
4821:          oTypeSPush( IntegerType )
4827:          ')'
4829:          >>
4830:       | * :
4835:    ]
      
         % Chr(x)
4835:    [ oNodeEqual( method, BuiltIn_Chr )
4845:       | true :
4846:          '('
4848:          @ConstExpr
4850:          ')'
4852:          [ oTypeSNodeType
4854:             | nIntegerType :
4855:             | nByteType :
4857:             | * :  #eTypeMismatch
4866:          ]
4866:          oTypeSPop
4867:          oTypeSPush( CharType )
4873:          ')'
4875:          >>
4876:       | * :
4881:    ]
      
         % Pred(x)
4881:    [ oNodeEqual( method, BuiltIn_Pred )
4891:       | true :
4892:          '('
4894:          @ConstExpr
4896:          [ oTypeSNodeType
4898:             | nEnumType :
4899:                [ oNodeGetBoolean( oTypeSTop, qHasGap )
4908:                   | true :   #eCantUsePredSuccOnEnumWithValueGaps
4911:                   | * :
4916:                ]
4916:             | * :  #eTypeMismatch
4923:          ]
4923:          oValuePush( 1 )  oValueSub
4930:          ')'
4932:          >>
4933:       | * :
4938:    ]
      
         % Succ(x)
4938:    [ oNodeEqual( method, BuiltIn_Succ )
4948:       | true :
4949:          '('
4951:          @ConstExpr
4953:          [ oTypeSNodeType
4955:             | nEnumType :
4956:                [ oNodeGetBoolean( oTypeSTop, qHasGap )
4965:                   | true :   #eCantUsePredSuccOnEnumWithValueGaps
4968:                   | * :
4973:                ]
4973:             | * :  #eTypeMismatch
4980:          ]
4980:          oValuePush( 1 )  oValueAdd
4987:          ')'
4989:          >>
4990:       | * :
4995:    ]
      
         % Sizeof(x)
4995:    [ oNodeEqual( method, BuiltIn_Sizeof )
5005:       | true :
5006:          '('
               % Parse expression but only for its type.
               % And, allow use of typename as a primary in the expression.
5008:          @ConstExprAllowTypeName
5010:          oValuePop
5011:          Node theType = oTypeSTop
5016:          oTypeSPop
5017:          oValuePush( oNodeGetInt( theType, qSize ) )
5030:          oTypeSPush( IntegerType )
5036:          ')'
5038:          >>
5039:       | * :
5044:    ]
      
5044:    #eNotImplemented
5047:    ;
      
      
5047: include 'pascal_expr.ssl'
      %
      % Pascal Compiler
      %
      
      
      % ------------------------------ Expressions -----------------------------
      
      
      % There are two wrappers leading into expression parsing:
      %   Expr()
      %   BooleanExprControlFlow( out Label falseLabel )
      %
      % Expr always produces a value on the runtime expr stack,
      % and pushes its type on the type stack.
      %
      % BooleanExprControlFlow always generates control-flow code.
      % It does not push a value on the runtime expr stack.
      % It does not push a type on the type stack.
      % The control flow code ends up at Here if the expr is true,
      % and jumps to falseLabel if the expr is false.
      % This rule allocates falseLabel, and passes it back.
      % The caller will need to define its location.
      %
      % The internal methods of expr parsing may produce a mix of
      % values and control flow, depending on the operators seen.
      % We don't always do one or the other, hoping to be efficient for
      % cases like   "func_call( bool_var1, bool_var2 )"
      % as well as  "if bool_expr1 or bool_expr2 then ...".
      % If a subexpression rule produces control flow, it will allocate a
      % falseLabel and pass it back up.  And it will push the
      % result type as BooleanFlowType, to distinguish from BooleanType
      % which corresponds with a boolean value on the expr stack.
      % 
      % Note that my expression parsing is broken into more levels than
      % grammars describe for Pascal precedence levels.  This follows my
      % original parser implementation.  I think my rationale was that
      % operators from the levels that I split up couldn't have been
      % mixed anyway, since they require different data types
      % (e.g. boolean vs int/real).  And splitting them up simplified
      % my code.  But, I should revisit this.
      %
      
      
      % Public entry point:
      %
      % Parse an expression, leaving a value on the runtime expr stack
      % and its type on the type stack.
      %
      % This rule does not export control flow (though it may generate
      % control flow internally for subexpressions).
      %
5047: Expr:
5049:    Label falseLabel = labelNull
      
5055:    @ExprAllowFlow( falseLabel )
5062:    @FlowToVal( falseLabel );
      
      
      % Public entry point:
      %
      % Parse an expression, just like Expr,
      % but also allows type names as Primary elements of the expression.
      % This is for use by sizeof().
      % The value produced by that primary is bogus, but this is ok because the
      % caller (sizeof) is going to discard all generated code for the expression.
      % It's only interested in the type produced by the expression.
      %
5070: ExprAllowTypeName:
5072:    boolean oldAllowTypeName = flagExprAllowTypeName
5078:    flagExprAllowTypeName = true
5084:    @Expr
5086:    flagExprAllowTypeName = oldAllowTypeName
5093:    ;
      
      
      % Public entry point:
      %
      % Parse a Boolean expression, producing control flow code rather than a value.
      % Does not leave a value on the runtime expr stack.
      % Does not leave a type on the type stack.
      %
      % If the expression is true, the code will fall through to the end (Here).
      % If the expression is false, the code will jump to the given falseLabel,
      % which this rule will allocate but not define the location for.
      % The caller must do so.
      %
5093: BooleanExprControlFlow( out Label falseLabel ):
5095:    @ExprAllowFlow( falseLabel )
5102:    [ oTypeSNodeType
5104:       | nBooleanFlowType :
5105:       | nBooleanType :
               % convert value to control flow
5107:          falseLabel = oLabelNew
5112:          .tJumpFalse  oEmitLabel( falseLabel )
5120:       | * :
5127:          #eNotBoolean
5129:    ]
5129:    oTypeSPop;
      
      
      % If the current expr result is control flow, convert it to a value.
      % falseLabel is the label that had been used by the control flow.
      % On return it will be set to labelNull.
      %
5131: FlowToVal( inout Label falseLabel ):
5133:    [ oTypeSNodeType
5135:       | nBooleanFlowType :
5136:          Label doneLabel = oLabelNew
5141:          .tPushConstI  oEmitInt( 1 )
5149:          .tJump  oEmitLabel( doneLabel )
5157:          .tLabel  oEmitLabel( falseLabel )
5165:          .tPushConstI  oEmitInt( 0 )
5173:          .tLabel  oEmitLabel( doneLabel )
5181:          oTypeSPop
5182:          oTypeSPush( BooleanType )
5188:          falseLabel = labelNull
5194:       | * :
5199:    ];
      
      
      % If the current expr result is boolean value, convert it to control flow.
      % falseLabel will be allocated by this rule and passed back.
      % The caller must define its location.
      %
5200: ValToFlow( out Label falseLabel ):
5202:    [ oTypeSNodeType
5204:       | nBooleanType :
5205:          falseLabel = oLabelNew
5210:          .tJumpFalse  oEmitLabel( falseLabel )
5218:          oTypeSPop
5219:          oTypeSPush( BooleanFlowType )
5225:       | * :
5230:    ];
      
      
      % Parse an expression.  It may produce a value on the expr stack,
      % or control flow, depending on what's seen in the expression.
      % Leaves the expression type on the type stack.
      %
      % If the expression produces control flow, the expression type will be
      % nBooleanFlowType.  In this case, a true value falls through to Here,
      % and a false value jumps to falseLabel.  This rule will allocate falseLabel
      % and return it, but will not define its location; the caller must do so.
      %
      % If the expression produces a value, the value will be left on the
      % expression stack, and the type will be some type other than nBooleanFlowType.
      % In this case, falseLabel is ignored.
      %
5231: ExprAllowFlow( out Label falseLabel ):
5233:    @BoolExprAllowFlow( falseLabel )
5240:    {[
5240:       | '=' :
5242:          @FlowToVal( falseLabel )
5249:          @PromoteToIntOptional
5251:          @BoolExprAllowFlow( falseLabel )
5258:          @FlowToVal( falseLabel )
5265:          @PromoteToIntOptional
5267:          @CoerceTypePair
5269:          [ oTypeSNodeType
5271:             | nBooleanType, nCharType :     .tEqualB
5274:             | nIntegerType, nEnumType :     .tEqualI
5278:             | nDoubleType :                 .tEqualD
5282:             | nPointerType, nUniversalPointerType :    .tEqualP
5286:             | nShortStringType, nStrLitType :
5288:                @ShortStringCmp  .tPushConstI  oEmitInt( 0 )  .tEqualI
5300:             | * :                           #eNotAllowed
5323:          ]
5323:          oTypeSPop
5324:          oTypeSPush( BooleanType )
      
5330:       | '<>' :
5332:          @FlowToVal( falseLabel )
5339:          @PromoteToIntOptional
5341:          @BoolExprAllowFlow( falseLabel )
5348:          @FlowToVal( falseLabel )
5355:          @PromoteToIntOptional
5357:          @CoerceTypePair
5359:          [ oTypeSNodeType
5361:             | nBooleanType, nCharType :     .tNotEqualB
5364:             | nIntegerType, nEnumType :     .tNotEqualI
5368:             | nDoubleType :                 .tNotEqualD
5372:             | nPointerType, nUniversalPointerType :    .tNotEqualP
5376:             | nShortStringType, nStrLitType :
5378:                @ShortStringCmp  .tPushConstI  oEmitInt( 0 )  .tNotEqualI
5390:             | * :                           #eNotAllowed
5413:          ]
5413:          oTypeSPop
5414:          oTypeSPush( BooleanType )
      
5420:       | '<' :
5422:          @FlowToVal( falseLabel )
5429:          @PromoteToIntOptional
5431:          @BoolExprAllowFlow( falseLabel )
5438:          @FlowToVal( falseLabel )
5445:          @PromoteToIntOptional
5447:          @CoerceTypePair
5449:          [ oTypeSNodeType
5451:             | nBooleanType, nCharType :     .tLessB
5454:             | nIntegerType, nEnumType :     .tLessI
5458:             | nDoubleType :                 .tLessD
5462:             | nPointerType, nUniversalPointerType :   .tLessP
5466:             | nShortStringType, nStrLitType :
5468:                @ShortStringCmp  .tPushConstI  oEmitInt( 0 )  .tLessI
5480:             | * :                           #eNotAllowed
5503:          ]
5503:          oTypeSPop
5504:          oTypeSPush( BooleanType )
      
5510:       | '>' :
5512:          @FlowToVal( falseLabel )
5519:          @PromoteToIntOptional
5521:          @BoolExprAllowFlow( falseLabel )
5528:          @FlowToVal( falseLabel )
5535:          @PromoteToIntOptional
5537:          @CoerceTypePair
5539:          [ oTypeSNodeType
5541:             | nBooleanType, nCharType :     .tGreaterB
5544:             | nIntegerType, nEnumType :     .tGreaterI
5548:             | nDoubleType :                 .tGreaterD
5552:             | nPointerType, nUniversalPointerType :   .tGreaterP
5556:             | nShortStringType, nStrLitType :
5558:                @ShortStringCmp  .tPushConstI  oEmitInt( 0 )  .tGreaterI
5570:             | * :                           #eNotAllowed
5593:          ]
5593:          oTypeSPop
5594:          oTypeSPush( BooleanType )
      
5600:       | '<=' :
5602:          @FlowToVal( falseLabel )
5609:          @PromoteToIntOptional
5611:          @BoolExprAllowFlow( falseLabel )
5618:          @FlowToVal( falseLabel )
5625:          @PromoteToIntOptional
5627:          @CoerceTypePair
5629:          [ oTypeSNodeType
5631:             | nBooleanType, nCharType :     .tLessEqualB
5634:             | nIntegerType, nEnumType :     .tLessEqualI
5638:             | nDoubleType :                 .tLessEqualD
5642:             | nPointerType, nUniversalPointerType :   .tLessEqualP
5646:             | nShortStringType, nStrLitType :
5648:                @ShortStringCmp  .tPushConstI  oEmitInt( 0 )  .tLessEqualI
5660:             | * :                           #eNotAllowed
5683:          ]
5683:          oTypeSPop
5684:          oTypeSPush( BooleanType )
      
5690:       | '>=' :
5692:          @FlowToVal( falseLabel )
5699:          @PromoteToIntOptional
5701:          @BoolExprAllowFlow( falseLabel )
5708:          @FlowToVal( falseLabel )
5715:          @PromoteToIntOptional
5717:          @CoerceTypePair
5719:          [ oTypeSNodeType
5721:             | nBooleanType, nCharType :     .tGreaterEqualB
5724:             | nIntegerType, nEnumType :     .tGreaterEqualI
5728:             | nDoubleType :                 .tGreaterEqualD
5732:             | nPointerType, nUniversalPointerType :   .tGreaterEqualP
5736:             | nShortStringType, nStrLitType :
5738:                @ShortStringCmp  .tPushConstI  oEmitInt( 0 )  .tGreaterEqualI
5750:             | * :                           #eNotAllowed
5773:          ]
5773:          oTypeSPop
5774:          oTypeSPush( BooleanType )
      
5780:       | * :
5795:          >
5797:    ]};
      
      
5800: BoolExprAllowFlow( out Label falseLabel ):
5802:    Label trueLabel = labelNull
      
5808:    @BoolTermAllowFlow( falseLabel )
5815:    {[
5815:       | pOr :
5817:          [ oTypeSNodeType
5819:             | nBooleanFlowType :
                     % We are true here. Jump ahead to done
5820:                [ equal_label( trueLabel, labelNull )
5830:                   | true :  trueLabel = oLabelNew
5836:                   | * :
5841:                ]
5841:                .tJump  oEmitLabel( trueLabel )
5849:             | nBooleanType :
5851:                @ValToFlow( falseLabel )
                     % We are true here. Jump ahead to done
5858:                [ equal_label( trueLabel, labelNull )
5868:                   | true :  trueLabel = oLabelNew
5874:                   | * :
5879:                ]
5879:                .tJump  oEmitLabel( trueLabel )
5887:             | * : #eNotBoolean
5896:          ]
5896:          oTypeSPop
      
               % false in previous term will jump here, to try this alternative term
5897:          .tLabel  oEmitLabel( falseLabel )
      
               % we'll get a new falseLabel for this term
5905:          falseLabel = labelNull
5911:          @BoolTermAllowFlow( falseLabel )
      
5918:          [ oTypeSNodeType
5920:             | nBooleanFlowType :
5921:             | nBooleanType :
5923:                @ValToFlow( falseLabel )
5930:             | * : #eNotBoolean
5939:          ]
      
5939:          oTypeSPop
5940:          oTypeSPush( BooleanFlowType )
      
5946:       | * :
5951:          >
5953:    ]}
      
         % any short-circuit trues jump here to the end
5955:    [ equal_label( trueLabel, labelNull )
5965:       | false :
5966:          .tLabel  oEmitLabel( trueLabel )
5974:       | * :
5979:    ]
5980:    ;
      
      
5980: BoolTermAllowFlow( out Label falseLabel ):
5982:    Label overallFalseLabel = labelNull
      
5988:    @BoolFactorAllowFlow( falseLabel )
5995:    {[
5995:       | pAnd :
5997:          [ oTypeSNodeType
5999:             | nBooleanFlowType :
6000:             | nBooleanType :
6002:                @ValToFlow( falseLabel )
6009:             | * :
6016:                #eNotBoolean
6018:          ]
6018:          oTypeSPop
      
               % We're going to have a different falseLabel for each term,
               % because we let each rule allocate its own (rather than accepting labels passed in).
               % And in this case we want them all to go to the same place,
               % to be determined by the caller.
               %
               % I'll allow for label aliases.  This will be more optimal than generating
               % multiple private false-handling code segments, that the true path would have to
               % jump around.  That would be hard to eliminate afterwards.
      
6019:          [ equal_label( overallFalseLabel, labelNull )
6029:             | true :
6030:                overallFalseLabel = oLabelNew
6035:                .tLabelAlias  oEmitLabel( falseLabel )  oEmitLabel( overallFalseLabel )
6049:                falseLabel = overallFalseLabel
6055:             | * :
6060:          ]
      
6060:          Label factorFalseLabel = labelNull
6066:          @BoolFactorAllowFlow( factorFalseLabel )
      
6073:          [ oTypeSNodeType
6075:             | nBooleanFlowType :
6076:             | nBooleanType :
6078:                @ValToFlow( factorFalseLabel )
6085:             | * : #eNotBoolean
6094:          ]
6094:         .tLabelAlias  oEmitLabel( factorFalseLabel )  oEmitLabel( overallFalseLabel )
      
6108:       | * :
6113:          >
6115:    ]};
      
      
6118: BoolFactorAllowFlow( out Label falseLabel ):
6120:    [
6120:       | pNot :
6122:          Label factorFalseLabel = labelNull
      
6128:          @BoolFactorAllowFlow( factorFalseLabel )
6135:          [ oTypeSNodeType
6137:             | nBooleanFlowType :
                     % We have control flow, and are sitting at the point that has value false.
6138:                falseLabel = oLabelNew
6143:                .tJump  oEmitLabel( falseLabel )
                     % The true path jumps here
6151:                .tLabel  oEmitLabel( factorFalseLabel )
      
6159:             | nBooleanType :
                     % I have a value.  I'll leave it as a value, rather than create control flow.
                     % See how this goes.
6161:                .tNot
      
6163:             | * : #eNotBoolean
6172:          ]
      
6172:       | * :
6177:          @ArithExprAllowFlow( falseLabel )
6184:    ];
      
      
6185: ArithExprAllowFlow( out Label falseLabel ):
6187:    boolean first = true
6193:    int tempStrOffset
      
6193:    @TermAllowFlow( falseLabel )
6200:    {[
6200:       | '+' :
6202:          [ oTypeSNodeType
6204:             | nIntegerType, nByteType :
6205:                @PromoteToIntPop
6207:                @TermAllowFlow( falseLabel )  % actually not allowing CF, will be caught by type check
      
6214:                [ oTypeSNodeType
6216:                   | nPointerType, nUniversalPointerType :
                           % int + ptr
6217:                      .tSwap
                           % leave only the ptr type on the type stack (int was already popped above)
6219:                      @PointerAddition
6221:                   | nDoubleType :
                           % int + double
                           % int type was already popped above; leave double on type stack
6223:                      .tSwap
6225:                      .tCastItoD
6227:                      .tAddD
6229:                   | * :
6238:                      @PromoteToInt
6240:                      .tAddI
6242:                ]
      
6242:             | nDoubleType :
6244:                @TermAllowFlow( falseLabel )
6251:                @PromoteToDoublePop
6253:                .tAddD
      
6255:             | nShortStringType, nStrLitType, nCharType :
                     % String concatenation
6257:                [ first
6260:                   | true :  % move into a temp string, so subsequent term(s) can further modify it.
6261:                             tempStrOffset = @MoveIntoTempShortString
6267:                             first = false
6273:                   | * :
6278:                ]
6278:                @TermAllowFlow( falseLabel )  % actually not allowing CF, will be caught by type check
6285:                [ oTypeSNodeType
6287:                   | nShortStringType, nStrLitType :
6288:                      @ShortStringAppendShortString
                           % Have to re-push the temp string.
                           % If we ever have .tDup then the append method could do it and we wouldn't need this
6290:                      .tPushAddrLocal  oEmitInt( tempStrOffset )
6298:                      oTypeSPush( ShortStringType )
6304:                   | nCharType :
6306:                      @ShortStringAppendChar
                           % Have to re-push the temp string.
                           % If we ever have .tDup then the append method could do it and we wouldn't need this
6308:                      .tPushAddrLocal  oEmitInt( tempStrOffset )
6316:                      oTypeSPush( ShortStringType )
6322:                   | * :
6331:                      #eTypeMismatch
6333:                      oTypeSPop
6334:                ]
      
6334:             | nPointerType, nUniversalPointerType :
6336:                @TermAllowFlow( falseLabel )   % actually not allowing CF
6343:                @PromoteToIntPop
6345:                @PointerAddition
      
6347:             | * :
6366:                #eNotAllowed
6368:          ]
      
6368:       | '-' :
6370:          [ oTypeSNodeType
6372:             | nIntegerType, nByteType :
6373:                @PromoteToIntPop
6375:                @TermAllowFlow( falseLabel )
      
6382:                [ oTypeSNodeType
6384:                   | nDoubleType :
                           % int - double
                           % int type was already popped above; leave double on type stack
6385:                      .tSwap
6387:                      .tCastItoD
6389:                      .tSwap
6391:                      .tSubD
6393:                   | * :
6398:                      @PromoteToInt
6400:                      .tSubI
6402:                ]
      
6402:             | nDoubleType :
6404:                @TermAllowFlow( falseLabel )
6411:                @PromoteToDoublePop
6413:                .tSubD
      
6415:             | nPointerType, nUniversalPointerType :
6417:                @TermAllowFlow( falseLabel )
6424:                [ oTypeSNodeType
6426:                   | nIntegerType, nByteType :
6427:                      @PromoteToIntPop
6429:                      @PointerSubInt
6431:                   | nPointerType, nUniversalPointerType :
6433:                      @MatchTypes
6435:                      @PointerSubPointer
6437:                   | * :
6448:                      #eNotAllowed
6450:                ]
      
6450:             | * :  #eNotAllowed
      
6465:          ]
6465:       | * :
6472:          >
6474:    ]};
      
      
6477: TermAllowFlow( out Label falseLabel ):
6479:    @FactorAllowFlow( falseLabel )
6486:    {[
6486:       | '*' :
6488:          [ oTypeSNodeType
6490:             | nIntegerType, nByteType :
6491:                @PromoteToIntPop
6493:                @FactorAllowFlow( falseLabel )  % actually not allowing CF, will be caught by type check
      
6500:                [ oTypeSNodeType
6502:                   | nDoubleType :
                           % int * double
                           % int type was already popped above; leave double on type stack
6503:                      .tSwap
6505:                      .tCastItoD
6507:                      .tMultD
6509:                   | * :
6514:                      @PromoteToInt
6516:                      .tMultI
6518:                ]
      
6518:             | nDoubleType :
6520:                @FactorAllowFlow( falseLabel )
6527:                @PromoteToDoublePop
6529:                .tMultD
      
6531:             | * :
6540:                #eNotAllowed
6542:          ]
      
6542:       | '/' :
6544:          [ oTypeSNodeType
6546:             | nIntegerType, nByteType :
6547:                @PromoteToIntPop
6549:                @FactorAllowFlow( falseLabel )
6556:                [ oTypeSNodeType
6558:                   | nDoubleType :
                           % int / double
                           % int type was already popped above; leave double on type stack
6559:                      .tSwap
6561:                      .tCastItoD
6563:                      .tSwap
6565:                      .tDivD
6567:                   | * :
6572:                      @PromoteToInt
6574:                      .tDivI
6576:                ]
      
6576:             | nDoubleType :
6578:                @FactorAllowFlow( falseLabel )
6585:                @PromoteToDoublePop
6587:                .tDivD
      
6589:             | * :
6598:                #eNotAllowed
6600:          ]
      
6600:       | * :
6607:          >
6609:    ]};
      
      
6612: FactorAllowFlow( out Label falseLabel ):
6614:    [
6614:       | '+' :
6616:          @PrimaryAllowFlow( falseLabel )  % actually not allowing CF, will be caught by type check
6623:          [ oTypeSNodeType
6625:             | nIntegerType, nByteType :
6626:             | nDoubleType :
6628:             | * :
6637:                #eNotAllowed
6639:          ]
6639:       | '-' :
6641:          @PrimaryAllowFlow( falseLabel )
6648:          [ oTypeSNodeType
6650:             | nIntegerType, nByteType :
                     % It's probably fair to promote byte to int, since byte is unsigned
6651:                @PromoteToInt
6653:                .tNegI
6655:             | nDoubleType :
6657:                .tNegD
6659:             | * :
6668:                #eNotAllowed
6670:          ]
6670:       | * :
6677:          @PrimaryAllowFlow( falseLabel )
6684:    ];
      
      
6685: PrimaryAllowFlow( out Label falseLabel ):
6687:    [
6687:       | pIntLit :
6689:          .tPushConstI  oEmitInt( TOKEN_VALUE )
6696:          oTypeSPush( IntegerType )
      
6702:       | pCharLit :
6704:          .tPushConstI  oEmitInt( TOKEN_VALUE )
6711:          oTypeSPush( CharType )
      
6717:       | pDoubleLit :
6719:          .tPushConstD  oEmitDouble( TOKEN_VALUE_DOUBLE )
6726:          oTypeSPush( DoubleType )
      
6732:       | '(' :
6734:          @ExprAllowFlow( falseLabel )
6741:          ')'
      
6743:       | pStrLit :
6745:          int addr = oStringAllocShortStringLit( CURRENT_STRLIT )     % store in global data
6754:          .tPushAddrGlobal oEmitInt( addr )
               % TO DO: consider defining a ShortString type with the exact capacity used.
               % But, I don't think it should matter here, since nobody should be assigning to this string.
6762:          oTypeSPush( StrLitType )
               % This seems unlikely, but the strlit may be followed by
               % array indexing.  Handle this the same way we would with a variable expression (see VarExpr)
               % First, advance the pointer by index if any
6768:          @LValueIndexes
               % get final value of dereferencing, if any
6770:          @FetchVar
      
6772:       | pIdent :
6774:          Node decl = oScopeFindRequire
6779:          @ResolveUnitRef( decl )
6786:          Node theType
      
6786:          [ oNodeType( decl )
6793:             | nFunc :
6794:                @Call( decl )
      
6801:             | nBuiltInFunc :
6803:                @CallBuiltInFunc( decl )
      
6810:             | nConst, nEnumValue :
6812:                theType = oNodeGet( decl, qType )
6825:                oTypeSPush( theType )
6831:                [ oTypeSNodeType
6833:                   | nIntegerType, nEnumType, nBooleanType, nCharType, nByteType :
6834:                      .tPushConstI @EmitValue( decl )
6843:                   | nPointerType, nUniversalPointerType :
                           % We have one pointer const, Nil.  It's pushed as I.
                           % Sign-extending I to P won't hurt since it's 0.
6845:                      .tPushConstI @EmitValue( decl )
6854:                   | * :
6871:                      #eNotImplemented
6873:                ]
      
6873:             | nConstDouble :
6875:                theType = oNodeGet( decl, qType )
6888:                oTypeSPush( theType )
6894:                [ oTypeSNodeType
6896:                   | nDoubleType :
6897:                      .tPushConstD  oEmitDouble( oNodeGetDouble( decl, qValueDouble ) )
6912:                   | * :
6917:                      #eNotImplemented
6919:                ]
                     
6919:             | nConstStr :
                     % This is a non-typed const defined as a strlit.
                     % So far, the value is held in the compiler's symbol table.
                     % Referencing the constant in the code will work the same as directly giving a strlit.
                     % (See pStrLit above).  We store the strlit in global memory, and set expr type to StrLitType.
      
                     % Storage in global memory only happens the first time the const is referenced.
                     % The global offset is stored in qValue.
6921:                int addr = oNodeGetInt( decl, qValue )
6934:                [ equal_zero( addr )
6941:                   | true :
6942:                      addr = oStringAllocShortStringLit( oNodeGetString( decl, qValueStr ) )
6959:                      oNodeSetInt( decl, qValue, addr )
6971:                   | * :
6976:                ]
6976:                .tPushAddrGlobal oEmitInt( addr )
6984:                oTypeSPush( StrLitType )
                     % This seems unlikely, but the strlit may be followed by
                     % array indexing.  Handle this the same way we would with a variable expression (see VarExpr)
                     % First, advance the pointer by index if any
6990:                @LValueIndexes
                     % get final value of dereferencing, if any
6992:                @FetchVar
      
6994:             | nGlobalVar, nLocalVar, nParam, nTypedConst :
6996:                @VarExpr( decl )
      
7003:             | nTypeDecl :
                     % A type name.
                     % This is normally a type cast.
                     % Or, if Expr is running within sizeof(), we do also allow type names as primaries.
7005:                oTypeSPush( oNodeGet( decl, qType ) )
7018:                [
7018:                   | '(' : 
                           % Type cast
7020:                      @Expr
7022:                      ')'
7024:                      @CastType
      
                           % The expression can be further modified after the typecast.
                           % This is taken from VarExpr.  Try to consolidate.
      
7026:                      [ oTypeSNodeType
7028:                         | nPointerType, nUniversalPointerType :
7029:                            [
7029:                               | '^' :             % dereferenced
7031:                                  oTypeSPop
7032:                                  oTypeSPush( oNodeGet( theType, qBaseType ) )
7045:                                  @LValueIndexes
7047:                                  @FetchVar
7049:                               | '[' :             % dereferencing pointer like an array [0..] of baseType
7051:                                  @PointerArraySubscript
                                       % modify addr for any subsequent subscripts, field references, etc
7053:                                  @LValueIndexes
7055:                                  @FetchVar
7057:                               | * :               % just ptr value alone
7064:                            ]
      
7064:                         | nArrayType, nRecordType, nShortStringType :
                                 % So far we would have the addr of the compound value.
                                 % Modify addr for subscripts, field references, etc
7066:                            @LValueIndexes
                                 % get final value, if no longer compound
7068:                            @FetchVar
      
7070:                         | *:
7083:                      ]
      
7083:                   | * :
                           % Not a type cast
                           % A raw typename is only allowed in expressions within sizeof
7088:                      [ flagExprAllowTypeName
7091:                         | true :
                                 % The value we produce is bogus.  The caller will discard all code.
                                 % Only the type stack matters.
7092:                            .tPushConstI  oEmitInt( 0 )
7100:                         | * :    #eTypeNameNotAllowedHere
7107:                      ]
7107:                ]
      
7107:             | * :
7132:                #eNotValue
7134:                oTypeSPush( IntegerType )
7140:          ]
      
7140:       | '@' :        % @var -- pointer to var
7142:          pIdent
      
7144:          Node decl = oScopeFindRequire
7149:          @ResolveUnitRef( decl )
7156:          Node theType
      
               % writeable is false because we're not on the left hand side of an assignment,
               % or passing into a var parameter.  So it's ok to take the address of a typed const.
7156:          @LValueFromDecl( decl, false )
      
               % The above leaves the pointed-to type on type stack.
               % Replace with ptr-to-<type>.
7166:          theType = oTypeSTop
7171:          oTypeSPop
7172:          Node ptrType = @PointerTypeTo( theType )
7183:          oTypeSPush( ptrType )
      
7189:       | * :
7206:          #eNotValue
7208:          oTypeSPush( IntegerType )
7214:    ];
      
      
      % Parse a variable expression, given the declaration of the
      % just-accepted identifier.
      % Leaves the value on the expression stack, and type on the type stack.
      %
7215: VarExpr( Node decl ):
7217:    Node theType = oNodeGet( decl, qType )
         % how many levels up the static scope? Will ignore for globals.
7230:    int uplevels = @DeclUpLevels( decl )
      
7241:    oTypeSPush( theType )
7247:    [ oTypeSNodeType
7249:       | nIntegerType, nEnumType :
7250:          [ oNodeType( decl )
7257:             | nGlobalVar, nTypedConst :   .tPushGlobalI  @EmitValue( decl )
7267:             | nLocalVar :
7269:                [ equal_zero( uplevels )
7276:                   | true :  .tPushLocalI  @EmitValue( decl )
7286:                   | * :     .tPushUpLocalI  oEmitInt( uplevels )  @EmitValue( decl )
7306:                ]
7306:             | nParam :
7308:                [ oNodeGetBoolean( decl, qInOut )
7318:                   | true :    % VAR param points to the var.  Auto dereference.
7319:                      [ equal_zero( uplevels )
7326:                         | true :  .tPushParamP  @EmitValue( decl )
7336:                         | * :     .tPushUpParamP  oEmitInt( uplevels )  @EmitValue( decl )
7356:                      ]
7356:                      .tFetchI
7358:                   | * :
7363:                      [ equal_zero( uplevels )
7370:                         | true :  .tPushParamI  @EmitValue( decl )
7380:                         | * :     .tPushUpParamI  oEmitInt( uplevels )  @EmitValue( decl )
7400:                      ]
7400:                ]
7400:          ]
      
7412:       | nBooleanType, nByteType, nCharType :
7414:          [ oNodeType( decl )
7421:             | nGlobalVar, nTypedConst :   .tPushGlobalB  @EmitValue( decl )
7431:             | nLocalVar :
7433:                [ equal_zero( uplevels )
7440:                   | true :  .tPushLocalB  @EmitValue( decl )
7450:                   | * :     .tPushUpLocalB  oEmitInt( uplevels )  @EmitValue( decl )
7470:                ]
7470:             | nParam :
7472:                [ oNodeGetBoolean( decl, qInOut )
7482:                   | true :    % VAR param points to the var.  Auto dereference.
7483:                      [ equal_zero( uplevels )
7490:                         | true :  .tPushParamP  @EmitValue( decl )
7500:                         | * :     .tPushUpParamP  oEmitInt( uplevels )  @EmitValue( decl )
7520:                      ]
7520:                      .tFetchB
7522:                   | * :
7527:                      [ equal_zero( uplevels )
7534:                         | true :  .tPushParamB  @EmitValue( decl )
7544:                         | * :     .tPushUpParamB  oEmitInt( uplevels )  @EmitValue( decl )
7564:                      ]
7564:                ]
7564:          ]
      
7576:       | nFileType :
7578:          #eNotImplemented
      
7580:       | nDoubleType :
7582:          [ oNodeType( decl )
7589:             | nGlobalVar, nTypedConst :   .tPushGlobalD  @EmitValue( decl )
7599:             | nLocalVar :
7601:                [ equal_zero( uplevels )
7608:                   | true :  .tPushLocalD  @EmitValue( decl )
7618:                   | * :     .tPushUpLocalD  oEmitInt( uplevels )  @EmitValue( decl )
7638:                ]
7638:             | nParam :
7640:                [ oNodeGetBoolean( decl, qInOut )
7650:                   | true :    % VAR param points to the var.  Auto dereference.
7651:                      [ equal_zero( uplevels )
7658:                         | true :  .tPushParamP  @EmitValue( decl )
7668:                         | * :     .tPushUpParamP  oEmitInt( uplevels )  @EmitValue( decl )
7688:                      ]
7688:                      .tFetchD
7690:                   | * :
7695:                      [ equal_zero( uplevels )
7702:                         | true :  .tPushParamD  @EmitValue( decl )
7712:                         | * :     .tPushUpParamD  oEmitInt( uplevels )  @EmitValue( decl )
7732:                      ]
7732:                ]
7732:          ]
      
7744:       | nPointerType, nUniversalPointerType :
7746:          [ oNodeType( decl )
7753:             | nGlobalVar, nTypedConst :   .tPushGlobalP @EmitValue( decl )
7763:             | nLocalVar :
7765:                [ equal_zero( uplevels )
7772:                   | true :  .tPushLocalP  @EmitValue( decl )
7782:                   | * :     .tPushUpLocalP  oEmitInt( uplevels )  @EmitValue( decl )
7802:                ]
7802:             | nParam :
7804:                [ oNodeGetBoolean( decl, qInOut )
7814:                   | true :    % VAR param points to the var.  Auto dereference.
7815:                      [ equal_zero( uplevels )
7822:                         | true :  .tPushParamP  @EmitValue( decl )
7832:                         | * :     .tPushUpParamP  oEmitInt( uplevels )  @EmitValue( decl )
7852:                      ]
7852:                      .tFetchP
7854:                   | * :
7859:                      [ equal_zero( uplevels )
7866:                         | true :  .tPushParamP  @EmitValue( decl )
7876:                         | * :     .tPushUpParamP  oEmitInt( uplevels )  @EmitValue( decl )
7896:                      ]
7896:                ]               
7896:          ]
7908:          [
7908:             | '^' :             % dereferenced
7910:                oTypeSPop
7911:                oTypeSPush( oNodeGet( theType, qBaseType ) )
7924:                @LValueIndexes
7926:                @FetchVar
7928:             | '[' :             % dereferencing pointer like an array [0..] of baseType
7930:                @PointerArraySubscript
                     % modify addr for any subsequent subscripts, field references, etc
7932:                @LValueIndexes
7934:                @FetchVar
7936:             | * :               % just ptr value alone
7943:          ]
      
7943:       | nArrayType, nRecordType, nShortStringType :
               % compound type
               % first, push addr of start of var
7945:          [ oNodeType( decl )
7952:             | nGlobalVar, nTypedConst :   .tPushAddrGlobal @EmitValue( decl )
7962:             | nLocalVar :
7964:                [ equal_zero( uplevels )
7971:                   | true :  .tPushAddrLocal  @EmitValue( decl )
7981:                   | * :     .tPushAddrUpLocal  oEmitInt( uplevels )  @EmitValue( decl )
8001:                ]
8001:             | nParam :
8003:                [ oNodeGetBoolean( decl, qInOut )
8013:                   | true :    % VAR param points to the var.  Auto dereference.
8014:                      [ equal_zero( uplevels )
8021:                         | true :  .tPushParamP  @EmitValue( decl )
8031:                         | * :     .tPushUpParamP  oEmitInt( uplevels )  @EmitValue( decl )
8051:                      ]
8051:                   | * :
8056:                      [ equal_zero( uplevels )
8063:                         | true :  .tPushAddrParam  @EmitValue( decl )
8073:                         | * :     .tPushAddrUpParam  oEmitInt( uplevels )  @EmitValue( decl )
8093:                      ]
8093:                ]
8093:          ]
               % modify addr for subscripts, field references, etc
8105:          @LValueIndexes
               % get final value
8107:          @FetchVar
8109:    ];
      
      
      % Addr of start of var is on expr stack; type is on type stack.
      % Replace expr stack with value of var.
      % (In the case of compound vars, this remains as the addr of the var).
      
8138: FetchVar:
8140:    [ oTypeSNodeType
8142:       | nIntegerType, nEnumType :  .tFetchI
8145:       | nBooleanType, nByteType, nCharType :  .tFetchB
8149:       | nDoubleType :              .tFetchD
8153:       | nFileType :   #eNotImplemented
8157:       | nPointerType :             .tFetchP
8161:       | nUniversalPointerType :    #eCantDereference
8165:       | nArrayType, nRecordType, nStrLitType, nShortStringType :  % compound type; leave as addr
8167:    ];
      
      
      % Addr of start of var is already on run stack, and type is on type stack.
      % Read subscripts, record fields, etc, to get final addr on run stack, and final type
      % on type stack.
      
8198: LValueIndexes:
8200:    {[
8200:       | '[' :
8202:          [ oTypeSNodeType
8204:             | nArrayType :    @ArraySubscripts
8207:             | nPointerType :  @PointerArraySubscript
8211:             | nStrLitType, nShortStringType :  @ShortStringArraySubscript
8215:             | * :             #eNotArray
8228:          ]
8228:       | '.' :       @RecordFieldRef
8232:       | '^' :       @PointerDeref   % TO DO: I suspect I don't have logic right here
                                          % about precondition and using .tFetchP
                                          % Ideally this should take over for the ^ in VarExpr too.
8236:       | * :         >
8247:    ]};
      
      
8250: ArraySubscripts:
8252:    [ oTypeSNodeType
8254:       | nArrayType :
8255:       | * :       #eNotArray
8262:    ]
8262:    {
8262:       [ oTypeSNodeType
8264:          | nArrayType :
8265:          | * :    #eTooManySubscripts
8272:       ]
      
            % low subscript of this dimension
8272:       int low = @OrdinalLow( oNodeGet( oTypeSTop, qIndexType ) )
      
            % replace type stack with next dimension, or OF type
8289:       Node baseType
8289:       baseType = oNodeGet( oTypeSTop, qBaseType )
8301:       oTypeSPop
8302:       oTypeSPush( baseType )
      
8308:       @Expr
8310:       @RequireIntPop
            % adjust for low subscript
8312:       [ equal_zero( low )
8319:          | false :
8320:             .tPushConstI oEmitInt( low ) .tSubI
8330:          | * :
8335:       ]
      
            % multiply by element size
8335:       int size = oNodeGetInt( baseType, qSize )
8348:       [ equal( size, 1 )
8358:          | false :
8359:             .tPushConstI oEmitInt( size ) .tMultI
8369:          | * :
8374:       ]
      
            % update start address
8374:       .tAddPI
8376:       [
8376:          | ']' :  >
8380:          | ',' :
8382:       ]
8390:    };
      
      
      % pointer[index] - similar to array[index] where index counts from 0.
      % On entry, the pointer value is on the stack, and pointer type is on the type stack.
      % We've already accepted the '['.
      % On exit, the address of the pointed-to element is on the stack,
      % and the element type is on the type stack.
      %
8393: PointerArraySubscript:
8395:    [ oTypeSNodeType
8397:       | nPointerType :
8398:       | * :    #eCantDereference
8405:    ]
         % replace type stack with base type
8405:    Node baseType = oNodeGet( oTypeSTop, qBaseType )
8417:    oTypeSPop
8418:    oTypeSPush( baseType )
         
8424:    @Expr
8426:    @RequireIntPop
         % multiply by element size
8428:    int size = oNodeGetInt( baseType, qSize )
8441:    [ equal( size, 1 )
8451:       | false :
8452:          .tPushConstI  oEmitInt( size )  .tMultI
8462:       | * :
8467:    ]
         % update start address
8467:    .tAddPI
8469:    ']';
      
      
      % Specialization of array indexing for ShortString.
      % We treat the starting index as 0 so that str[1] sees the first string char,
      % past the length byte.
      %
8472: ShortStringArraySubscript:
8474:    [ oTypeSNodeType
8476:       | nStrLitType, nShortStringType :
8477:       | * :    #eCantDereference
8486:    ]
8486:    oTypeSPop
8487:    oTypeSPush( CharType )
8493:    @Expr
8495:    @RequireIntPop
8497:    .tAddPI
8499:    ']';
      
      
8502: RecordFieldRef:
8504:    [ oTypeSNodeType
8506:       | nRecordType :
8507:       | * :    #eNotRecord
8514:    ]
8514:    oScopeEnter( oNodeGet( oTypeSTop, qScope ) )
8526:    pIdent
8528:    Node field = oScopeFindRequire
         % oScopeFind searches all open scopes, so make sure we found nRecordField
         % which could only be seen in the local scope we entered above.
8533:    [ oNodeType( field )
8540:       | nRecordField :
8541:       | * :   #eNotRecordField
8548:    ]
8548:    oScopeEnd
8549:    int offset = oNodeGetInt( field, qValue )
8562:    [ equal_zero( offset )
8569:       | false :
8570:          .tPushConstI oEmitInt( offset ) .tAddPI
8580:       | * :
8585:    ]
      
         % replace the type on the type stack, with the field type
8585:    oTypeSPop
8586:    oTypeSPush( oNodeGet( field, qType ) )
8600:    ;
      
      
      % On entry, expr stack has ptr, and integer index above it.
      % The type stack has just the pointer type.
      % Pop those, and push the ptr advanced to that index
      % (scaled by the pointed-to element size).
      % Leaves the pointer type on the type stack.
      %
8600: PointerAddition:
8602:    Node elementType = oNodeGet( oTypeSTop, qBaseType )
8614:    int elementSize = oNodeGetInt( elementType, qSize )
8627:    [ equal( elementSize, 1 )
8637:       | false :
8638:          .tPushConstI  oEmitInt( elementSize )
8646:          .tMultI
8648:       | * :
8653:    ]
8653:    .tAddPI
8656:    ;
      
      
      % On entry, expr stack has ptr, and integer above it.
      % The type stack has just the pointer type.
      % Pop those, and push the ptr decremented by that integer
      % (scaled by the pointed-to element size).
      % Leaves the pointer type on the type stack.
      %
8656: PointerSubInt:
8658:    Node elementType = oNodeGet( oTypeSTop, qBaseType )
8670:    int elementSize = oNodeGetInt( elementType, qSize )
8683:    [ equal( elementSize, 1 )
8693:       | false :
8694:          .tPushConstI  oEmitInt( elementSize )
8702:          .tMultI
8704:       | * :
8709:    ]
8709:    .tSubPI
8712:    ;
      
      
      % On entry, expr stack has two pointers, P1 and P2 above it.
      % The type stack has the type of P1.  (The type of P2 was already matched to P1.)
      % Replace the pointers on the expression stack with P1 - P2, scaled by the
      % pointed-to element size.  Type stack switched to integer.
      % 
8712: PointerSubPointer:
8714:    .tSubP
8716:    Node elementType = oNodeGet( oTypeSTop, qBaseType )
8728:    int elementSize = oNodeGetInt( elementType, qSize )
8741:    [ equal( elementSize, 1 )
8751:       | false :
8752:          .tPushConstI  oEmitInt( elementSize )
8760:          .tDivI
8762:       | * :
8767:    ]
8767:    oTypeSPop
8768:    oTypeSPush( IntegerType )
8775:    ;
      
      % ptr deref on left side, i.e. BEFORE addr of ptr var is on stack,
      %                              AFTER addr of thing pointed to is on stack
8775: PointerDeref:
8777:    [ oTypeSNodeType
8779:       | nPointerType :
8780:       | nUniversalPointerType :   #eCantDereference
8784:       | * :       #eNotPointer
8793:    ]
8793:    .tFetchP           % now addr on stack is addr of what we're pointing to
      
8795:    Node theType = oTypeSTop
8800:    oTypeSPop
8801:    oTypeSPush( oNodeGet( theType, qBaseType ) )
8815:    ;
      
      
      % The expr stack contains a value whose type is on top of the type stack.
      % Generate code to coerce the value to the type under it in the type stack
      % (pop the type stack, leaving only the desired type).
      % This is used for assignment.
      %
8815: CoerceType:
8817:    node_type nt = oTypeSNodeType
8822:    Node given = oTypeSTop
8827:    oTypeSPop
8828:    [ equal_node_type( nt, oTypeSNodeType )
8837:       | false :
               % Can we implicitly convert the value to the desired type?
8838:          [ oTypeSNodeType
8840:             | nIntegerType :
8841:                [ nt
8844:                   | nByteType :   .tCastBtoI  >>
8848:                   | * :
8853:                ]
8853:             | nByteType :
8855:                [ nt
8858:                   | nIntegerType :   .tCastItoB  >>
8862:                   | * :
8867:                ]
8867:             | nDoubleType :
8869:                [ nt
8872:                   | nIntegerType :   .tCastItoD  >>
8876:                   | * :
8881:                ]
8881:             | nPointerType :
8883:                [ nt
8886:                   | nUniversalPointerType :  >>
8888:                   | nStrLitType :
8890:                      [ equal_node( oTypeSTop, PCharType )
8899:                         | true :
                                 % PChar := 'strlit' i.e. point at strlit[1]
8900:                            .tPushConstI  oEmitInt(1)  .tAddPI  >>
8911:                         | * :
8916:                      ]
8916:                   | * :
8923:                ]
8923:             | nUniversalPointerType :
8925:                [ nt
8928:                   | nPointerType :  >>
8930:                   | * :
8935:                ]
8935:             | nShortStringType :
8937:                [ nt
8940:                   | nStrLitType :  >>
8942:                   | nCharType :
                           % Store char as a temp ShortString.
8944:                      oTypeSPush( CharType )
8950:                      int tempOffset = @MoveIntoTempShortString
8956:                      oTypeSPop
8957:                      >>
8958:                   | * :
8965:                ]
8965:             | * :
8980:          ]
8980:          #eTypeMismatch
8982:       | * :
8987:    ];
      
      
      % The expr stack contains two values, and their two types are on the type stack.
      % Typically these are two arguments of an operator; the key is that both types are flexible
      % (unlike CoerceType, where only the top type is flexible).
      % Coerce one type to match the other.  Generally the smaller type is coerced to the larger.  
      % Leave both values on the expr stack, and the single common type on the type stack. 
      %
8988: CoerceTypePair:
8990:    node_type right_nt = oTypeSNodeType
8995:    Node right = oTypeSTop
9000:    oTypeSPop
9001:    node_type left_nt = oTypeSNodeType
9006:    Node left = oTypeSTop
      
         % Start with assumption that we'll keep left type
9011:    [ equal_node_type( left_nt, right_nt )
9021:       | true :
               % TO DO: BUG: in some cases, need to validate base types match (e.g. enum types, ptr types)
9022:          >>
9023:       | * :
9028:    ]
9028:    [ left_nt
9031:       | nIntegerType :
9032:          [ right_nt
9035:             | nByteType :     .tCastBtoI  >>
9039:             | * :
9044:          ]
9044:       | nDoubleType :
9046:          [ right_nt
9049:             | nByteType :     .tCastBtoI  .tCastItoD  >>
9055:             | nIntegerType :  .tCastItoD  >>
9060:             | * :
9067:          ]
9067:       | nPointerType :
9069:          [ right_nt
9072:             | nUniversalPointerType :   >>
9074:             | * :
9079:          ]
9079:       | nShortStringType :
9081:          [ right_nt
9084:             | nStrLitType :  >>
9086:             | nCharType :
                     % Store char as a temp ShortString
9088:                oTypeSPush( CharType )
9094:                int tempOffset = @MoveIntoTempShortString
9100:                oTypeSPop
9101:                >>
9102:             | * :
9109:          ]
9109:       | * :
9120:    ]  
      
         % See if we can coerce left to right type.
         % If so remember we need to replace the type on the type stack.
9120:    [ right_nt
9123:       | nIntegerType :
9124:          [ left_nt
9127:             | nByteType :
9128:                .tSwap  .tCastBtoI  .tSwap
9134:                oTypeSPop  oTypeSPush( right )
9141:                >>
9142:             | * :
9147:          ]
9147:       | nDoubleType :
9149:          [ left_nt
9152:             | nByteType :
9153:                .tSwap  .tCastBtoI  .tCastItoD  .tSwap
9161:                oTypeSPop  oTypeSPush( right )
9168:                >>
9169:             | nIntegerType :
9171:                .tSwap  .tCastItoD  .tSwap
9177:                oTypeSPop  oTypeSPush( right )
9184:                >>
9185:             | * :
9192:          ]
9192:       | nPointerType :
9194:          [ left_nt
9197:             | nUniversalPointerType :
                     % TO DO: does fpc inherit right type here?
                     %  or stay with left.
9198:                oTypeSPop  oTypeSPush( right )
9205:                >>
9206:             | * :
9211:          ]
9211:       | nShortStringType :
9213:          [ left_nt
9216:             | nStrLitType :
9217:                oTypeSPop  oTypeSPush( right )
9224:                >>
9225:             | nCharType :
9227:                .tSwap
                     % Store char as a temp ShortString
9229:                oTypeSPush( CharType )
9235:                int tempOffset = @MoveIntoTempShortString
9241:                oTypeSPop
9242:                .tSwap
9244:                oTypeSPop  oTypeSPush( right )
9251:                >>
9252:             | * :
9259:          ]
9259:       | * :
9270:    ]
9270:    #eTypeMismatch
9273:    ;
      
      
      % The expr stack contains a value whose type is on top of the type stack.
      % Generate code to cast the value to the type under it in the type stack
      % (pop the type stack, leaving only the desired type).
      %
      % This is stronger than CoerceType, since it isn't limited to implicit conversions.
      % There are still going to be limits on what is allowed though.
      %
9273: CastType:
9275:    node_type nt = oTypeSNodeType
9280:    oTypeSPop
9281:    [ equal_node_type( nt, oTypeSNodeType )
9290:       | false :
               % Can we cast the value to the desired type?
9291:          [ oTypeSNodeType
9293:             | nIntegerType, nEnumType :
9294:                [ nt
9297:                   | nByteType, nCharType, nBooleanType :   .tCastBtoI  >>
9301:                   | nIntegerType, nEnumType :   >>
9304:                   | * :
9317:                ]
9317:             | nByteType, nCharType, nBooleanType :
9319:                [ nt
9322:                   | nByteType, nCharType, nBooleanType :   >>
9324:                   | nIntegerType, nEnumType :   .tCastItoB  >>
9329:                   | * :
9342:                ]
9342:             | nPointerType :
9344:                [ nt
9347:                   | nUniversalPointerType :  >>
9349:                   | nStrLitType :
9351:                      [ equal_node( oTypeSTop, PCharType )
9360:                         | true :
                                 % PChar := 'strlit' i.e. point at strlit[1]
9361:                            .tPushConstI  oEmitInt(1)  .tAddPI  >>
9372:                         | * :
9377:                      ]
9377:                   | * :
9384:                ]
9384:             | nUniversalPointerType :
9386:                [ nt
9389:                   | nPointerType :  >>
9391:                   | * :
9396:                ]
9396:             | nShortStringType :
9398:                [ nt
9401:                   | nStrLitType :  >>
9403:                   | nCharType :
                           % Store char as a temp ShortString.
9405:                      oTypeSPush( CharType )
9411:                      int tempOffset = @MoveIntoTempShortString
9417:                      oTypeSPop
9418:                      >>
9419:                   | * :
9426:                ]
9426:             | * :
9445:          ]
9445:          #eTypeMismatch
9447:       | * :
9452:    ];
      
      
      % Require that the top two types on the type stack are matching (ignoring subranges).
      % Pop one of them, leaving only one.
      %
      % This is used when passing a variable to a VAR parameter, so essentially no coercion
      % can be allowed.  The called method will interact with the actual variable using the
      % formal parameter type, so they must agree.
      %
      % TO DO: BUG: I'm not confirming that enum types are the same type!
      %     Only that they are both enums!
      %     Probably same flaw with record & array types.
      %     Not enough to compare only the node type.
      %
9453: MatchTypes:
9455:    node_type nt = oTypeSNodeType
9460:    oTypeSPop
9461:    [ equal_node_type( nt, oTypeSNodeType )
9470:       | false :
               % Some very minor implicit conversion is allowed even here,
               % but must not affect the value size.
9471:          [ oTypeSNodeType
9473:             | nPointerType :
9474:                [ nt
9477:                   | nUniversalPointerType :  >>
9479:                   | * :
9484:                ]
9484:             | nUniversalPointerType :
9486:                [ nt
9489:                   | nPointerType :  >>
9491:                   | * :
9496:                ]
9496:             | * :
9503:          ]
9503:          #eTypeMismatch
9505:       | * :
9510:    ];
      
      
      % Require that the top type on the type stack is integer (ignoring subranges).
      % Pop it.
      %
9511: RequireIntPop:
9513:    [ oTypeSNodeType
9515:       | nIntegerType :
9516:       | * :          #eNotInteger
9523:    ]
9523:    oTypeSPop;
      
9525: RequireInt:
9527:    [ oTypeSNodeType
9529:       | nIntegerType :
9530:       | * :          #eNotInteger
9537:    ];
      
      
      % Convert the top value to integer (if it isn't already).
      % It must be implicitly convertable to integer.
      % Pop the type stack.
      %
9538: PromoteToIntPop:
9540:    [ oTypeSNodeType
9542:       | nIntegerType :
9543:       | nByteType :        .tCastBtoI
9547:       | * :                #eNotInteger
9556:    ]
9556:    oTypeSPop;
      
      % Convert the top value to integer (if it isn't already).
      % It must be implicitly convertable to integer.
      % Leave integer on the type stack.
      %
9558: PromoteToInt:
9560:    [ oTypeSNodeType
9562:       | nIntegerType :
9563:       | nByteType :        .tCastBtoI
9567:                            oTypeSPop
9568:                            oTypeSPush( IntegerType )
9574:       | * :                #eNotInteger
9583:    ];
      
      
      % If the top value is implicitly convertable to integer, do so.
      % Otherwise leave it as-is.
      %
9584: PromoteToIntOptional:
9586:    [ oTypeSNodeType
9588:       | nByteType :        .tCastBtoI
9591:                            oTypeSPop
9592:                            oTypeSPush( IntegerType )
9598:       | * :
9603:    ];
      
      
      % Convert the top value to double (if it isn't already).
      % It must be implicitly convertable to double.
      % Pop the type stack.
      %
9604: PromoteToDoublePop:
9606:    [ oTypeSNodeType
9608:       | nDoubleType :
9609:       | nIntegerType :     .tCastItoD
9613:                            oTypeSPop
9614:                            oTypeSPush( DoubleType )
9620:       | nByteType :        .tCastBtoI
9624:                            .tCastItoD
9626:                            oTypeSPop
9627:                            oTypeSPush( DoubleType )
9633:       | * :                #eNotDouble
9644:    ]
9644:    oTypeSPop;
      
      
9646: RequireBoolPop:
9648:    [ oTypeSNodeType
9650:       | nBooleanType :
9651:       | * :          #eNotBoolean
9658:    ]
9658:    oTypeSPop;
      
9660: RequireBool:
9662:    [ oTypeSNodeType
9664:       | nBooleanType :
9665:       | * :          #eNotBoolean
9672:    ];
      
      
9673: include 'pascal_stmt.ssl'
      %
      % Pascal Compiler
      %
      
      
      % ------------------------------ Statements -----------------------------
      
9673: Statement:
9675:    [
9675:       | pWriteln :     @WritelnStmt
9679:       | pWrite :       @WriteStmt
9683:       | pReadln :      @ReadlnStmt
9687:       | pRead :        @ReadStmt
9691:       | pIf :          @IfStmt
9695:       | pWhile :       @WhileStmt
9699:       | pFor :         @ForStmt
9703:       | pRepeat :      @RepeatStmt
9707:       | pBreak :       @BreakStmt
9711:       | pContinue :    @ContinueStmt
9715:       | pBegin :       @BeginStmt
9719:       | pIdent :       @LabelOrAssignOrCallStmt
9723:       | pCase :        @CaseStmt
9727:       | pGoto :        @GotoStmt
9731:       | pIntLit :      % should be an integer label
9733:                        oChangeIntLitToLabelIdent
9734:                        @LabelOrAssignOrCallStmt
9736:       | * :            % null statement : don't accept any tokens
9769:    ];
      
      
9770: LabelOrAssignOrCallStmt:
9772:    Node decl = oScopeFindRequire
9777:    @ResolveUnitRef( decl )
9784:    [ oNodeType( decl )
9791:       | nLabel :                          @LabelDefinition( decl )
9799:                                           @Statement
9801:       | nProc :                           @Call( decl )
9810:       | nGlobalVar, nLocalVar, nParam, nTypeDecl :
9812:                                           @AssignStmt( decl )
9819:       | nFunc :                           @AssignResultStmt( decl )
9828:       | * :                               #eBadStatement
9847:    ];
      
      
      % Parse a "label:" prefix in front of a statement.
      %
9848: LabelDefinition( Node decl ):
9850:    [ oNodeGetBoolean( decl, qDefined )
9860:       | true :  #eAlreadyDefined
9863:       | * :
9868:    ]
9868:    .tLabel  oEmitLabel( oNodeGetLabel( decl, qValue ) )
9883:    oNodeSetBoolean( decl, qDefined, true )
9895:    ':'
9898:    ;
      
      
      % Given decl, the just-accepted first identifier on the left hand side.
      %
9898: AssignStmt( Node decl ):
9900:    @LValueFromDecl( decl, true )
9910:    ':=' 
9912:    @Expr
9914:    @CoerceType
9916:    @Assign
9919:    ;
      
      
      % Performs a raw assignment.
      % Given lvalue 2nd on stack, and expr value top of stack (already coerced to the lvalue type),
      % and type of both of these on the type stack,
      % perform the assignment and pop the type off the type stack.
      %
9919: Assign:
9921:    [ oTypeSNodeType
9923:       | nIntegerType, nEnumType :  .tAssignI
9926:       | nBooleanType, nByteType, nCharType :  .tAssignB
9930:       | nDoubleType :  .tAssignD
9934:       | nFileType :   #eNotImplemented
9938:       | nPointerType, nUniversalPointerType :  .tAssignP
            % compound var assigns; addrs of src, dest on stack
9942:       | nArrayType, nRecordType, nShortStringType :
                % TO DO: for ShortString, allow destination to be smaller capacity,
                % and truncate the copied value/length.
9944:           int size = oNodeGetInt( oTypeSTop, qSize )
9956:           .tCopy  oEmitInt( size )    % multi-word copy
9964:    ]
9992:    oTypeSPop
9994:    ;
      
      % Given nFunc for the just-accepted identifier on the left hand side.
      % Parse an assignment that represents assignment of the function result.
      %
9994: AssignResultStmt( Node funcDecl ):
         % Only allowed to assign the result of the immediately enclosing function, I think.
9996:    [ oNodeEqual( oNodeGet( funcDecl, qChildScope ), oScopeCurrent )
10012:       | false :   #eNotCurrentFunction
10015:       | * :
10020:    ]
      
         % Result value is stored in the caller's space, via a hidden VAR parameter.
10020:    .tPushParamP  oEmitInt( oNodeGetInt( funcDecl, qResultOffset ) )
10035:    oTypeSPush( oNodeGet( funcDecl, qType ) )
      
10048:    ':='
10050:    @Expr
10052:    @CoerceType
10054:    [ oTypeSNodeType
10056:       | nIntegerType, nEnumType : .tAssignI
10059:       | nBooleanType, nByteType, nCharType :  .tAssignB
10063:       | nDoubleType :  .tAssignD
10067:       | nFileType :   #eNotImplemented
10071:       | nPointerType, nUniversalPointerType :  .tAssignP
            % compound var assigns; addrs of src, dest on stack
10075:       | nArrayType, nRecordType, nShortStringType :
10077:           int size = oNodeGetInt( oTypeSTop, qSize )
10089:           .tCopy  oEmitInt( size )    % multi-word copy
10097:    ]
10125:    oTypeSPop
10127:    ;
      
      
      
      % Parse an lvalue expression, from scratch.
      % This is an expression that may appear on the left side of an assignment.
      % Leaves the address of the value on the expr stack,
      % and the type of the value at that address on the type stack.
      % If writeable is false, the expression won't be written to, so may access a
      % typed const.
      %
10127: LValueExpr( boolean writeable ):
         % Al lvalue expressions start with a variable name,
         % or a type name (for an lvalue typecast).
10129:    pIdent
10131:    Node decl = oScopeFindRequire
10136:    @ResolveUnitRef( decl )
10143:    @LValueFromDecl( decl, writeable )
10154:    ;
      
      
      % Parse an lvalue expression, starting with the decl of the just accepted identifier.
      % Leaves the address of the value on the expr stack,
      % and the type of the value at that address on the type stack.
      % If writeable is false, the expression won't be written to, so may access a
      % typed const.
      %
10154: LValueFromDecl( Node decl, boolean writeable ):
10156:    [ oNodeType( decl )
10163:       | nGlobalVar, nLocalVar, nParam, nTypedConst :
10164:          @LValueVar( decl, writeable )
      
10174:       | nTypeDecl :
               % lvalue typecast
               % This is only allowed if the provided lvalue we're casting from has the same size.
               % No conversion code occurs, it's just a different interpretation of the same bits.
10176:          oTypeSPush( oNodeGet( decl, qType ) )
10189:          '('
10191:          @LValueExpr( writeable )
10198:          ')'
10200:          @LValueCastType
               % There can be further modifications of the lvalue after the cast.
               % This is taken from LValueVar.  Try to consolidate.
10202:          [ oTypeSNodeType
10204:             | nPointerType :
10205:                [
10205:                   | '[' :
                           % dereference the pointer var first
10207:                      .tFetchP
10209:                      @PointerArraySubscript
10211:                   | * :
10216:                ]
10216:             | * :
10221:          ]
               % additional subscripts, if any
10221:          @LValueIndexes
       
10223:       | * :  #eNotVar
10238:    ]
10239:    ;
      
      
      % An lvalue is on the expression stack.
      % The type of the lvalue is on the type stack.
      % The desired type is under it on the type stack.
      % Perform an lvalue cast to the desired type, leaving just that type.
      %
      % An lvalue cast is allowed only if the data size is the same.
      % No conversion code occurs, it's just a different interpretation of the same bits.
      %
10239: LValueCastType:
10241:    node_type nt = oTypeSNodeType
10246:    oTypeSPop
10247:    [ equal_node_type( nt, oTypeSNodeType )
10256:       | false :
               % Can we cast the value to the desired type?
10257:          [ oTypeSNodeType
10259:             | nIntegerType, nEnumType :
10260:                [ nt
10263:                   | nByteType, nCharType, nBooleanType :  #eSizeMismatch  >>
10267:                   | nIntegerType, nEnumType :   >>
10270:                   | * :
10283:                ]
10283:             | nByteType, nCharType, nBooleanType :
10285:                [ nt
10288:                   | nByteType, nCharType, nBooleanType :   >>
10290:                   | nIntegerType, nEnumType :  #eSizeMismatch  >>
10295:                   | * :
10308:                ]
10308:             | nPointerType :
10310:                [ nt
10313:                   | nUniversalPointerType :  >>
10315:                   | * :
10320:                ]
10320:             | nUniversalPointerType :
10322:                [ nt
10325:                   | nPointerType :  >>
10327:                   | * :
10332:                ]
10332:             | nShortStringType :
10334:                [ nt
10337:                   | nStrLitType :  >>
10339:                   | * :
10344:                ]
10344:             | * :
10363:          ]
10363:          #eTypeMismatch
10365:       | * :
10370:    ];
      
      
      
      % Parse an lvalue expression (e.g. left side of an assign statement)
      % that starts with the just-accepted identifier indicated by the given decl.
      % Leaves the lvalue address on the expression stack,
      % and the type of the value at that address on the type stack.
      %
10371: LValueVar( Node decl, boolean writeable ):
10373:    [ oNodeType( decl )
10380:       | nGlobalVar :   .tPushAddrGlobal @EmitValue( decl )
10390:       | nLocalVar :    .tPushAddrLocal @EmitValue( decl )
10401:       | nParam :
10403:          [ oNodeGetBoolean( decl, qInOut )
10413:             | true :   % VAR param points to variable.  No dereference.
10414:                        .tPushParamP @EmitValue( decl )
10423:             | * :      .tPushAddrParam @EmitValue( decl )
10437:          ]
10437:       | nTypedConst :
10439:          [ writeable
10442:             | false :  .tPushAddrGlobal @EmitValue( decl )                       
10452:             | * :      #eNotVar
10459:          ]
10459:       | * :            #eNotVar
10472:    ]
      
10472:    oTypeSPush( oNodeGet( decl, qType ) )
      
         % handle subscripts, if any.
         % There is one case that I'm not fitting into the pattern nicely, so need to
         % check for specially here:  if lvalue var is a pointer variable, and is
         % followed by [index], we need to dereference the pointer variable before applying
         % the index.  This is different from handling of [index] on an rvalue expression.
         % Right now I have LValueIndexes working for both lvalue and rvalue (composite types)
         % so can't easily add this behavior in there.
         % TO DO: probably I need separate rules LValueIndexes and RValueIndexes.
         %    This might also explain my confusion about handling of deref operator in LValueIndexes vs rvalue expr,
         %    and having separate rules might clear that up better.
      
10485:    [ oTypeSNodeType
10487:       | nPointerType :
10488:          [
10488:             | '[' :
                     % dereference the pointer var first
10490:                .tFetchP
10492:                @PointerArraySubscript
10494:             | * :
10499:          ]
10499:       | * :
10504:    ]
         % additional subscripts, if any
10504:    @LValueIndexes
10507:    ;
      
      
10507: IncVar( Node decl ):
10509:    @LValueVar( decl, true )
10519:    @RequireIntPop
10521:    @VarExpr( decl )
10528:    oTypeSPop
10529:    .tIncI
10531:    .tAssignI;
      
10534: DecVar( Node decl ):
10536:    @LValueVar( decl, true )
10546:    @RequireIntPop
10548:    @VarExpr( decl )
10555:    oTypeSPop
10556:    .tDecI
10558:    .tAssignI;
      
      
10561: IfStmt:
10563:    Label falseLabel = labelNull
      
10569:    @BooleanExprControlFlow( falseLabel )
10576:    pThen
10578:    @Statement
10580:    [
10580:       | pElse :
10582:          Label doneLabel = oLabelNew
      
10587:          .tJump  oEmitLabel( doneLabel )
10595:          .tLabel oEmitLabel( falseLabel )
10603:          @Statement
10605:          .tLabel oEmitLabel( doneLabel )
      
10613:       | * :
10618:          .tLabel oEmitLabel( falseLabel )
10626:    ];
      
      
10627: ForStmt:
10629:    pIdent
      
10631:    Node decl = oScopeFindRequire
         % TO DO: disallow use of a compound variable field.
         %        Could do that by disallowing use of LValueIndexes,
         %        or by double-checking the decl's qType here.
         % TO DO: I think I read somewhere that the variable must be in current scope.
10636:    @LValueVar( decl, true )
10646:    @RequireIntPop
      
10648:    ':='
      
10650:    @Expr
10652:    @RequireIntPop
10654:    .tAssignI
      
10656:    Label breakLabel = oLabelNew
      
10661:    Label checkLabel = oLabelNew
10666:    .tJump  oEmitLabel( checkLabel )
      
10674:    Label continueLabel = oLabelNew
10679:    .tLabel  oEmitLabel( continueLabel )
10687:    [
10687:       | pTo :
10689:          @IncVar( decl )
10696:          .tLabel  oEmitLabel( checkLabel )
10704:          @VarExpr( decl )  oTypeSPop
10712:          @Expr
10714:          @RequireIntPop
10716:          .tGreaterI
10718:          .tJumpTrue  oEmitLabel( breakLabel )
10726:       | pDownto :
10728:          @DecVar( decl )
10735:          .tLabel  oEmitLabel( checkLabel )
10743:          @VarExpr( decl )  oTypeSPop
10751:          @Expr
10753:          @RequireIntPop
10755:          .tLessI
10757:          .tJumpTrue  oEmitLabel( breakLabel )
10765:    ]
10773:    oLoopPush( continueLabel, breakLabel )
10782:    pDo
10784:    @Statement
10786:    .tJump  oEmitLabel( continueLabel )
10794:    .tLabel  oEmitLabel( breakLabel )
10802:    oLoopPop;
      
      
10804: RepeatStmt:
10806:    Label continueLabel = oLabelNew
10811:    .tLabel  oEmitLabel( continueLabel )
      
10819:    Label breakLabel = oLabelNew
      
10824:    oLoopPush( continueLabel, breakLabel )
10833:    @Statement
10835:    {[
10835:       | ';' :
10837:          @Statement
10839:       | pUntil :
10841:          Label falseLabel
10841:          @BooleanExprControlFlow( falseLabel )
10848:          .tLabelAlias  oEmitLabel( falseLabel )  oEmitLabel( continueLabel )
10862:          >
10864:    ]}
10874:    .tLabel  oEmitLabel( breakLabel )
10882:    oLoopPop;
      
      
10884: WhileStmt:
10886:    Label continueLabel = oLabelNew
10891:    .tLabel  oEmitLabel( continueLabel )
      
10899:    Label breakLabel
10899:    @BooleanExprControlFlow( breakLabel )
      
10906:    oLoopPush( continueLabel, breakLabel )
10915:    pDo
10917:    @Statement
10919:    .tJump  oEmitLabel( continueLabel )
10927:    .tLabel  oEmitLabel( breakLabel )
10935:    oLoopPop;
      
      
10937: ContinueStmt:                     % NOTE, for repeat..until, skips test (??)
10939:    [ equal_label( oLoopContinueLabel, labelNull )
10948:       | true :
10949:          #eNotInALoop
10951:       | false :
10953:          .tJump  oEmitLabel( oLoopContinueLabel )
10960:    ];
      
      
10969: BreakStmt:
10971:    [ equal_label( oLoopBreakLabel, labelNull )
10980:       | true :
10981:          #eNotInALoop
10983:       | false :
10985:          .tJump  oEmitLabel( oLoopBreakLabel )
10992:    ];
      
      
11001: CaseStmt:
11003:    Code tableCode = oCodeNew
11008:    Label tableLabel = oLabelNew
11013:    Label doneLabel = oLabelNew
11018:    Label otherwiseLabel = doneLabel
11024:    boolean isString = false
      
11030:    @Expr
         % Leave the expr type on the type stack throughout case statement
11032:    [ oTypeSNodeType
11034:       | nBooleanType, nByteType, nCharType :   .tJumpCaseB  oEmitLabel( tableLabel )
11043:       | nIntegerType, nEnumType :              .tJumpCaseI  oEmitLabel( tableLabel )
11053:       | nShortStringType, nStrLitType :        isString = true
11061:                                                .tJumpCaseS  oEmitLabel( tableLabel )
11069:       | * :     #eNotAllowed
11088:    ]
11088:    pOf
      
11090:    {
11090:       [
11090:          | pOtherwise, pElse :
11092:             otherwiseLabel = oLabelNew
11097:             .tLabel  oEmitLabel( otherwiseLabel )
      
                  % A bit tricky:
                  % The otherwise clause allows multiple statements (unlike other cases).
                  % ';' might be separating statements in the otherwise clause,
                  % or might be an optional trailing ; after the last statement.
                  % I have to watch for End to know when the statements stop.
                  % (Note, the otherwise clause is the last part of the case statement.)
11105:             {[
11105:                | pEnd :  >
11109:                | * :
11114:                   @Statement
11116:                   [
11116:                      | ';' :
11118:                      | * :   pEnd  >
11127:                   ]
11127:             ]}
11129:             >
      
11131:          | pEnd :
                  % Reached end with no otherwise clause
11133:             >
      
11135:          | * :
11144:             Label caseLabel = oLabelNew
11149:             oCodePush( tableCode )
11155:             {
11155:                @ConstExpr
11157:                @ConstCoerceType
11159:                int val
11159:                [ isString
11162:                   | true :    val = oStringAllocShortStringLit( oValueTopString )
11172:                   | false :   val = oValueTop
11179:                ]
11187:                oValuePop
11188:                [
11188:                   | '..' :  @ConstExpr
11192:                             @ConstCoerceType
11194:                             int highval
11194:                             [ isString
11197:                                | true :   highval = oStringAllocShortStringLit( oValueTopString )
11207:                                | false :  highval = oValueTop
11214:                             ]
11222:                             oValuePop
11223:                             .tCaseRange  oEmitInt( val )  oEmitInt( highval )  oEmitLabel( caseLabel )
11243:                   | * :     .tCase  oEmitInt( val )  oEmitLabel( caseLabel )
11262:                ]
11262:                [
11262:                   | ',' :
11264:                   | * :  >
11271:                ]
11271:             }
11273:             oCodePop
11274:             ':'
11276:             .tLabel  oEmitLabel( caseLabel )
11284:             @Statement
11286:             .tJump  oEmitLabel( doneLabel )
                  % Swallow optional trailing ';'
11294:             [
11294:                | ';' :
11296:                | * :
11301:             ]
                  
11301:       ]
         
11301:    }
      
11303:    .tLabel  oEmitLabel( tableLabel )
11311:    oEmitCode( tableCode )
11317:    .tCaseEnd  oEmitLabel( otherwiseLabel )
11325:    .tLabel  oEmitLabel( doneLabel )
11333:    oTypeSPop
11335:    ;
      
      
11335: GotoStmt:
11337:    [
11337:       | pIdent :
11339:       | pIntLit :
               % Replace token with identifier "_label_<intlit>"
11341:          oChangeIntLitToLabelIdent
11342:    ]
      
         % Some pascals have rules about where you can jump (to a sibling statement or
         % higher level statement in the block, but not into a lower lower level statement.)
         % fpc just says "jumping into a nested statement can have strange effects."
         % I'm going to follow that and not prohibit any goto, as long as it's in the same block.
      
         % Label must be declared in the same block (same scope) it is used.
         % Some pascals allow non-local goto, but we do not.
         % That would require more tracking of dynamic scope, to unwind stack.
         % Note: in main program statement, this relies on the temporaries scope extending
         %  the main scope (where a label declaration would occur).
11350:    Node decl = oScopeFindRequireInScope( oScopeCurrent )
11359:    oNodeSetBoolean( decl, qUsed, true )
11371:    .tJump  oEmitLabel( oNodeGetLabel( decl, qValue ) )
11387:    ;
      
      
11387: BeginStmt:
11389:    @Statement
11391:    {[
11391:       | ';' :   @Statement
11395:       | pEnd :  >
11399:    ]};
      
      
11410: WritelnStmt:
11412:    @WriteStmt
11414:    .tWriteCR;
      
      
11417: WriteStmt:
11419:    [
11419:       | '(' :
11421:          {
11421:             @Expr
11423:             [ oTypeSNodeType
11425:                | nIntegerType :             .tWriteI
11428:                | nBooleanType :             .tWriteBool
11432:                | nByteType :                .tCastBtoI  .tWriteI
11438:                | nCharType :                .tWriteChar
11442:                | nDoubleType :              .tWriteD
11446:                | nShortStringType, nStrLitType :   .tWriteShortStr
11450:                | nFileType :                #eNotImplemented
11454:                | nEnumType :
                        % write name via table lookup
11456:                   .tPushAddrGlobal  oEmitInt( oNodeGetInt( oTypeSTop, qNameTable ) )
11470:                   .tWriteEnum
11472:                | nPointerType :
11474:                   [ equal_node( oTypeSTop, PCharType )
11483:                      | true :               .tWritePChar
11486:                      | * :                  .tWriteP
11493:                   ]
11493:                | nUniversalPointerType :    .tWriteP
11497:                | * :                        #eNotAllowed
11524:             ]
11524:             oTypeSPop
11525:             [
11525:                | ')' : >
11529:                | ',' :
11531:             ]
11539:          }
11541:       | * :
11546:    ];
      
      
11547: ReadlnStmt:
11549:    @ReadStmt
11551:    .tReadCR;
      
      
11554: ReadStmt:
11556:    [
11556:       | '(' :
11558:          {
11558:             @LValueExpr( true )
11565:             [ oTypeSNodeType
11567:                | nIntegerType :      .tReadI
11570:                | nCharType :         .tReadChar
11574:                | nShortStringType :  
11576:                    int capacity = subtract( oNodeGetInt( oTypeSTop, qSize ), 1 )
11595:                    .tReadShortStr  oEmitInt( capacity )
11603:                | * :                 #eNotAllowed
11614:             ]
11614:             oTypeSPop
11615:             [
11615:                | ')' : >
11619:                | ',' :
11621:             ]
11629:          }
11631:       | * :
11636:    ];
11637: include 'pascal_str.ssl'
      %
      % Pascal Compiler
      %
      
      % ------------------------------ String Operations -----------------------------
      
      
      % Given a ShortString, StrLit, or Char on the expression stack
      % (and type on the type stack).  Move the value into a new temporary ShortString.
      % Leave that temp string and type on the stacks.
      % Also returns the offset of the temp string.
      %
11637: MoveIntoTempShortString >> int:
11639:    int tempOffset = oScopeAllocType( ShortStringType )
         % copy the value
11649:    [ oTypeSNodeType
11651:       | nShortStringType, nStrLitType :
11652:          .tPushAddrLocal  oEmitInt( tempOffset )
               % put temp addr under value addr
11660:          .tSwap
               % TO DO: we could just copy length + 1, but tCopy takes a fixed #bytes
11662:          .tCopy  oEmitInt( oNodeGetInt( ShortStringType, qSize ) )
11677:       | nCharType :
               % temp[0] = 1
11679:          .tPushAddrLocal  oEmitInt( tempOffset )
11687:          .tPushConstI  oEmitInt( 1 )
11695:          .tAssignB
               % temp[1] = value
11697:          .tPushAddrLocal  oEmitInt( add( tempOffset, 1 ) )
11712:          .tSwap
11714:          .tAssignB
11716:       | * :   #eTypeMismatch
11727:    ]
11727:    oTypeSPop
         % Leave the temp ShortString on the expr stack and type stack
11728:    .tPushAddrLocal  oEmitInt( tempOffset )
11736:    oTypeSPush( ShortStringType )
11742:    >> tempOffset;
      
      
      % Top of expr stack / type stack is ShortString B.
      % Under it is ShortString A.
      % Change A to append the contents of B to it (truncating if necessary).
      % Removes both A and B from the expr stack / type stack.
      %
11746: ShortStringAppendShortString:
         % TO DO: ideally I would do this directly with tcode.  But I think I need some more
         % enhancements for that to work well.   Meanwhile, generate a call to a method.
         % For the moment, I'll implement the method in Pascal, in the mysystem unit.
11748:    .tAllocActuals  oEmitInt( 16 )
11756:    .tPushAddrActual  oEmitInt( 8 )  .tSwap  .tAssignP
11768:    .tPushAddrActual  oEmitInt( 0 )  .tSwap  .tAssignP
11780:    .tCall   @EmitValue( System_ShortStringAppendShortString )
         % TO DO: Ideally I would leave A on the expr stack / type stack.
         %  But I can't really do that without dup, which I hesitate to add.
         %  I'll have the caller push A again themselves.
11789:    .tFreeActuals  oEmitInt( 16 )
11797:    oTypeSPop
11798:    oTypeSPop
11800:    ;
      
      % Top of expr stack / type stack is Char B.
      % Under it is ShortString A.
      % Change A to append char B to it (truncating if necessary).
      % Removes both A and B from the expr stack / type stack.
      %
11800: ShortStringAppendChar:
         % Note at the moment I don't align params
11802:    .tAllocActuals  oEmitInt( 12 )
11810:    .tPushAddrActual  oEmitInt( 8 )  .tSwap  .tAssignB
11822:    .tPushAddrActual  oEmitInt( 0 )  .tSwap  .tAssignP
11834:    .tCall  @EmitValue( System_ShortStringAppendChar )
11843:    .tFreeActuals  oEmitInt( 12 )
11851:    oTypeSPop
11852:    oTypeSPop
11854:    ;
      
      % Expr stack has ShortString A, and ShortString B above it.
      % Type stack has just the type of ShortString A.
      % Replaces the expr stack with the integer value of string comparison:
      % -1 if A < B,  0 if A = B,  1 if A > B
      % Leaves Integer on the type stack.
      %
      % TO DO: kind of annoying that we need to hardcode the fact that the called method is cdecl extern.
      %   It would be nicer if that was noted only in the label.
      %   Alternatively, use a utility method in SSL to generate the appropriate call,
      %   given the method decl.
      %
11854: ShortStringCmp:
11856:    .tAllocActualsCdecl  oEmitInt( 24 )
11864:    .tPushAddrActual  oEmitInt( 8 )  .tSwap  .tAssignP
11876:    .tPushAddrActual  oEmitInt( 0 )  .tSwap  .tAssignP
11888:    int tempOffset = oScopeAllocType( IntegerType )
11898:    .tPushAddrActual  oEmitInt( 16 )  .tPushAddrLocal  oEmitInt( tempOffset )  .tAssignP
11916:    .tCallCdecl  @EmitValue( System_ShortStringCmp )
11925:    .tPushLocalI  oEmitInt( tempOffset )
11933:    .tFreeActuals  oEmitInt( 24 )
11941:    oTypeSPop
11942:    oTypeSPush( IntegerType )
11949:    ;
11949: include 'pascal_call.ssl'
      %
      % Pascal Compiler
      %
      
      % ------------------------------ Method Calls -----------------------------
      
      
      % Parse a call, given an nProc or nFunc for the just-accepted identifier.
      % If a func, this will also generate the code to push the return value on the expr stack,
      % and push the return type on the type stack.
      %
11949: Call( Node method ):
11951:    oNodeSetBoolean( method, qUsed, true )
      
         % If the method has a cdecl modifier, the back end will need to use the native
         % calling convention, instead of my own.  But, the convention varies by platform,
         % so the front end won't assume what it needs.  I'll still generate the normal tcode
         % that copies values into actuals space on the stack.
         % However, to help the back end, I will at least use a different instruction for the
         % allocation of the actuals space, and for the actual call.
         %
         % p.s. I only support cdecl on external methods, because I don't have a way
         % to let my own Pascal methods read params passed in with the cdecl calling convention.
         %
11963:    boolean cdecl = oNodeGetBoolean( method, qCdecl )
      
         % If this is a function, we will allocate a temporary
         % in the current scope, to hold the result value.
         % And pass a pointer to that temporary as an extra parameter.
11976:    Node resultType
11976:    int tempOffset
      
11976:    boolean isFunc = equal_node_type( oNodeType( method ), nFunc )
      
11993:    [ isFunc
11996:       | true :
11997:          resultType = oNodeGet( method, qType )
12010:          tempOffset = oScopeAllocType( resultType )
               % TO DO: we could manage temp allocation, so temp space can be reused
               %        by different code branches.
12020:       | * :
12025:    ]
         
      
12025:    Node paramScope = oNodeGet( method, qParams )
12038:    int actualsSize = oNodeGetInt( paramScope, qSize )
12051:    [ cdecl
12054:       | true : .tAllocActualsCdecl  oEmitInt( actualsSize )
12063:       | false :  .tAllocActuals  oEmitInt( actualsSize )
12073:    ]
      
         % If method is nested, it takes a hidden first parameter:
         % a pointer to the frame of the static scope in which the method is declared.
         % The location of a scope's frame is equivalent to offset 0 in the scope's locals space
         % (since local offsets are relative to the scope's frame pointer).
         %
         % The nested method may be in a higher scope (upLevels > 1),
         % or a sibling of the method we're in (upLevels = 1),
         % or an immediate child of the current method (upLevels = 0).
         %
         % To understand the upLevels computation, remember that a method's declaration
         % and its contents (variables, nested functions, and body statement)
         % are in two different scopes.
      
12081:    [ greater( @DeclLevel( method ), 0 )
12096:       | true :
12097:          .tPushAddrActual  oEmitInt( 0 )    % hidden param is at param offset 0
12105:          .tPushAddrUpLocal  oEmitInt( @DeclUpLevels( method ) )  oEmitInt( 0 )
12124:          .tAssignP
12126:       | * :
12131:    ]
      
      
12131:    NodeIter paramIter = oNodeGetIter( paramScope, qDecls )
12144:    Node param = oNodeIterValue( paramIter )
12154:    [
12154:       | '(' :
            
12156:          {
12156:             [ oNodeNull( param )
12163:                | true : >
12166:                | * :
12171:             ]
      
12171:             int offset = oNodeGetInt( param, qValue )
      
                  % Assign actual value to spot in actuals space
12184:             .tPushAddrActual oEmitInt( offset )
12192:             oTypeSPush( oNodeGet( param, qType ) )
      
12205:             [ oNodeGetBoolean( param, qInOut )
12215:                | true :   % A VAR param.
                                % The actual is a pointer to the value.
                                % The type on the type stack (pushed above) is for the pointed-to value.
      
12216:                           @LValueExpr( true )
                                % Addr of the referenced variable is on the expr stack,
                                % type of the variable is on the type stack.
      
                                % Match types more exactly. It's not sufficient to be assign compatible
                                % since the method will be assigning to the actual using the param type.
                                % Maybe something like type contents must match, incl subrange bounds.
12223:                           @MatchTypes
      
12225:                           .tAssignP
      
12227:                | false :  @Expr
12231:                           @CoerceType
                                
                                % Assign to offset in actuals space
      
12233:                           [ oTypeSNodeType
12235:                              | nIntegerType, nEnumType : .tAssignI
12238:                              | nBooleanType, nByteType, nCharType :  .tAssignB
12242:                              | nDoubleType :  .tAssignD
12246:                              | nFileType :   #eNotImplemented
12250:                              | nPointerType, nUniversalPointerType :  .tAssignP
12254:                              | nArrayType, nRecordType, nShortStringType :
                                       % compound types: copy value into actuals space
12256:                                  int size = oNodeGetInt( oTypeSTop, qSize )
12268:                                  .tCopy  oEmitInt( size )    % multi-word copy
12276:                           ]
12304:             ]
12312:             oTypeSPop
      
12313:             oNodeIterNext( paramIter )
12319:             param = oNodeIterValue( paramIter )
12329:             [ oNodeNull( param )
12336:                | true :  >
12339:                | false :
12341:             ]
      
12349:             ','
12351:          }
      
12353:          ')'
      
12355:       | * :
12360:    ]
      
12360:    [ oNodeNull( param )
12367:       | false :    #eMissingParameter
12370:       | * :
12375:    ]
      
12375:    [ isFunc
12378:       | true :
               % Pass result temp as an additional VAR parameter.
12379:          .tPushAddrActual oEmitInt( oNodeGetInt( method, qResultOffset ) )
12394:          .tPushAddrLocal  oEmitInt( tempOffset )
12402:          .tAssignP
12404:       | * :
12409:    ]
      
12409:    [ cdecl
12412:       | true :
12413:          .tCallCdecl  @EmitValue( method )
12422:       | false :
12424:          .tCall   @EmitValue( method )
12433:    ]
      
12441:    [ isFunc
12444:       | true :
               % push return value from temp
12445:          oTypeSPush( resultType )
      
12451:          [ oTypeSNodeType
12453:             | nIntegerType, nEnumType :   .tPushLocalI  oEmitInt( tempOffset )
12462:             | nBooleanType, nByteType, nCharType :   .tPushLocalB  oEmitInt( tempOffset )
12472:             | nDoubleType :               .tPushLocalD  oEmitInt( tempOffset )
12482:             | nFileType :  #eNotImplemented
12486:             | nPointerType, nUniversalPointerType :   .tPushLocalP  oEmitInt( tempOffset )
12496:             | nArrayType, nRecordType, nShortStringType :   % compound type: push address
12498:                                .tPushAddrLocal  oEmitInt( tempOffset )
12506:          ]
12534:       | * :
12539:    ]
         
12539:    .tFreeActuals  oEmitInt( actualsSize )
12548:    ;
      
      
      
      % Called on first use of an extern method
      %
12548: DefineExternLabel( Node method ):
         % The extern name might be given explicitly, otherwise the pascal method name.
12550:    int strAddr
12550:    String externalName = oNodeGetString( method, qExternalName )
12563:    [ equal_string( externalName, stringNull )
12573:       | true :
12574:          strAddr = oStringAllocLit( ID_STRING( oNodeGetInt( method, qIdent ) ) )
12595:       | false :
12597:          strAddr = oStringAllocLit( externalName )
12607:    ]
12615:    .tLabelExtern  @EmitValue( method )  oEmitInt( strAddr )
12631:    ;
      
      
      
      % Parse a call to a built-in function, identified by the just-accepted identifier.
      % This will also generate the code to push the return value on the expr stack,
      % and push the return type on the type stack.
      %
12631: CallBuiltInFunc( Node method ):
      
         % Ord(x)
12633:    [ oNodeEqual( method, BuiltIn_Ord )
12643:       | true :
               % parameter is any scalar type (including boolean, enum, char)
               % result is integer
12644:          '('
12646:          @Expr
12648:          [ oTypeSNodeType
12650:             | nIntegerType, nEnumType :
12651:             | nBooleanType, nByteType, nCharType :  .tCastBtoI
12655:             | * :  #eTypeMismatch
12670:          ]
12670:          oTypeSPop
12671:          oTypeSPush( IntegerType )
12677:          ')'
12679:          >>
12680:       | * :
12685:    ]
      
         % Chr(x)
12685:    [ oNodeEqual( method, BuiltIn_Chr )
12695:       | true :
               % parameter is integer
               % result is char
12696:          '('
12698:          @Expr
12700:          [ oTypeSNodeType
12702:             | nIntegerType :    .tCastItoB
12705:             | nByteType :
12707:             | * :  #eTypeMismatch
12716:          ]
12716:          oTypeSPop
12717:          oTypeSPush( CharType )
12723:          ')'
12725:          >>
12726:       | * :
12731:    ]
      
         % Pred(x)
12731:    [ oNodeEqual( method, BuiltIn_Pred )
12741:       | true :
               % parameter is any enum type, as long as it has values 0..N-1
               % result is the same enum type
12742:          '('
12744:          @Expr
12746:          [ oTypeSNodeType
12748:             | nEnumType :
                     % TO DO: does this skip past type aliases?
                     % TO DO: what if using pred/succ on a subrange type?
12749:                [ oNodeGetBoolean( oTypeSTop, qHasGap )
12758:                   | true :   #eCantUsePredSuccOnEnumWithValueGaps
12761:                   | * :
12766:                ]
12766:             | * :  #eTypeMismatch
12773:          ]
12773:          .tDecI
12775:          ')'
12777:          >>
12778:       | * :
12783:    ]
      
         % Succ(x)
12783:    [ oNodeEqual( method, BuiltIn_Succ )
12793:       | true :
               % parameter is any enum type, as long as it has values 0..N-1
               % result is the same enum type
12794:          '('
12796:          @Expr
12798:          [ oTypeSNodeType
12800:             | nEnumType :
                     % TO DO: does this skip past type aliases?
                     % TO DO: what if using pred/succ on a subrange type?
12801:                [ oNodeGetBoolean( oTypeSTop, qHasGap )
12810:                   | true :   #eCantUsePredSuccOnEnumWithValueGaps
12813:                   | * :
12818:                ]
12818:             | * :  #eTypeMismatch
12825:          ]
12825:          .tIncI
12827:          ')'
12829:          >>
12830:       | * :
12835:    ]
      
         % Sizeof(x)
12835:    [ oNodeEqual( method, BuiltIn_Sizeof )
12845:       | true :
               % parameter is a type name (cannot be a general type description),
               % or an expression (which is not evaluated).
               %
               % My initial thought was to look at the first token to see if it's a type name,
               % and if not, unaccept it and run @Expr  (with the code stream set to a dummy stream).
               % But that's not completely sufficient.
               % First, the typename might be   unit.name  so unaccepting one token wouldn't be good enough.
               % Also, an expression can start with a typename e.g.  integer(1+2) * 3
               %
               % So, instead of looking for a type name at this level, and going to Expr if not,
               % I'll just go into Expr.  But I'll turn on an option to accept type names in Primary.
               % Since we're discarding the code anyway, I'll have that primary push a bogus value
               % on the expr stack.  The main thing is just to get the type right.
               
12846:          '('
               % Parse expression but don't evaluate its code (so no side effects occur).
               % I'll accomplish that by sending the code to a temp stream that I discard.
12848:          Code dummyCode = oCodeNew
12853:          oCodePush( dummyCode )
12859:          @ExprAllowTypeName
12861:          oCodePop
12862:          oCodeDiscard( dummyCode )
12868:          Node theType = oTypeSTop
12873:          oTypeSPop
12874:          .tPushConstI  oEmitInt( oNodeGetInt( theType, qSize ) )
12889:          oTypeSPush( IntegerType )
12895:          ')'
12897:          >>
      
12898:       | * :
12903:    ]
      
12903:    #eNotImplemented
12906:    ;
      
12906: include 'pascal_type.ssl'
      %
      % Pascal Compiler
      %
      
      % ------------------------------ Types -----------------------------
      
      
      % Create and return a new nType of the given node_type, adding it to the type table.
      %
12906: newType( node_type nt, int size ) >> Node:
12908:   Node node = oNodeNew( nt )
12918:   oNodeSetInt( node, qSize, size )
12930:   oTypeAdd( node )
12936:   >> node
12940:   ;
      
      
      % Parse a type reference, returning the nType.
      % This will add types to the type table, as needed.
      %
      % Style question - at the moment I think callers look clearer if we use
      % an out param here, rather than a return value.
      %
12940: TypeRef( out Node resultType ):
12942:    [
12942:       | pIdent :           % previously named type (including intrinsics)
12944:          Node decl = oScopeFindRequire
12949:          @ResolveUnitRef( decl )
12956:          [ oNodeType( decl )
12963:             | nTypeDecl :
12964:                resultType = oNodeGet( decl, qType )
12977:             | * :
12982:                #eNotType
12984:                resultType = IntegerType
12990:          ]
         
12990:       | pArray :
12992:          '['
      
               % A multi-dimensional array is represented as a chain
               %    array [subrange1] of array [subrange2] of elementType
      
               % First, we build a vector of nArray's, each with one subrange as its index type,
               % but without setting the "of" type or size.
      
12994:          NodeVec dimensions = oNodeVecNew
      
12999:          {
                  % to do: probably should use general subrange parsing, incl minimal size value
                  %   In fact, supposed to parse ordinal_type here.  all ordinal types have a static low, high.
                  %   Not necessary to be a subrange.
      
12999:             Node subrange = oNodeNew( nSubrangeType )
      
13009:             @ConstExpr
13011:             oNodeSetInt( subrange, qLow, oValueTop )
13022:             oValuePop
13023:             '..'
13025:             @ConstExpr
13027:             oNodeSetInt( subrange, qHigh, oValueTop )
13038:             oValuePop
      
13039:             @ConstMatchTypes
13041:             oNodeSet( subrange, qBaseType, oTypeSTop )
13052:             oNodeSetInt( subrange, qSize, oNodeGetInt( oTypeSTop, qSize ) )
13070:             oTypeSPop
13071:             oTypeAdd( subrange )
      
13077:             Node a = oNodeNew( nArrayType )
13087:             oNodeSet( a, qIndexType, subrange )
      
13099:             oNodeVecAppend( dimensions, a )
                  % I'll hold off on adding 'a' to the type table since not fully formed yet
      
13108:             [
13108:                | ']' : >
13112:                | ',' :
13114:             ]
13122:          }
      
13124:          pOf
13126:          Node baseType
13126:          @TypeRef( baseType )
      
               % Work backwards through the dimensions,
               % hooking up the 'of' type and calculating the size.
               % At each iteration, baseType is the 'of' type.
      
13133:          int dim = oNodeVecSize( dimensions )
      
13143:          {
13143:              dec(dim)
      
13149:              Node a = oNodeVecElement( dimensions, dim )
      
13162:              oNodeSet( a, qBaseType, baseType )
13174:              Node subrange = oNodeGet( a, qIndexType )
13187:              int width = subtract( oNodeGetInt( subrange, qHigh ), oNodeGetInt( subrange, qLow ) )
13214:              inc( width )
13220:              oNodeSetInt( a, qSize, multiply( width, oNodeGetInt( baseType, qSize ) ) )
      
13246:              oTypeAdd( a )
13252:              baseType = a
      
13258:              [ equal_zero(dim)
13265:                  | true:  >
13268:                  | *:
13273:              ]
13273:          }
      
13275:          resultType = oNodeVecElement( dimensions, 0 )
13288:          oNodeVecDelete( dimensions )
      
13294:       | '^' :
13296:          Node theType
13296:          @TypeRef( theType )
13303:          resultType = @PointerTypeTo( theType )
      
13314:       | pRecord :
13316:          resultType = oNodeNew( nRecordType )
13326:          oScopeBegin( -1, allocUp )    % level is meaningless here
      
13335:          @VarDecl( nRecordField )
      
13342:          int size = oNodeGetInt( oScopeCurrent, qSize )
               % to do: padding
13354:          [ equal_zero( size )
13361:             | true : #eRecordEmpty
13364:             | * :
13369:          ]
      
13369:          pEnd
      
13371:          oNodeSet( resultType, qScope, oScopeCurrent )
13382:          oNodeSetInt( resultType, qSize, size )
13394:          oScopeEnd
13395:          oTypeAdd( resultType )
      
      
13401:       | '(' :
               % An enum type declaration.
13403:          @EnumTypeRef( resultType )
      
      
            % *** TO DO: following type constructors are not implemented *** 
13410:       | pSet :
13412:          pOf
13414:          Node theType
13414:          @TypeRef( theType )
13421:          #eNotImplemented
13423:       | * :       % this works for cases except where expr starts with an id
13438:          @ConstExpr '..' @ConstExpr
13444:          @ConstMatchTypes
13446:          #eNotImplemented
13448:    ];
      
      
      % Parse an enum type.
      % We've already accepted the '('
      % Returns the new type.
      %
13449: EnumTypeRef( out Node resultType ):
      
13451:    resultType = oNodeNew( nEnumType )
13461:    int value = 0
13467:    int numValues = 0
13473:    boolean first = true
      
         % We'll declare the enum values in two scopes: the current scope, and a scope nested in the enum type.
         % That will let programs use either <val> or <enumType>.<val>
13479:    Node outerScope = oScopeCurrent
13484:    oScopeBegin( -1, allocUp )   % level is meaningless, and we won't use allocate
      
13493:    {
            % TO DO: assert that name not already seen in this scope, i.e. this enum.
            %  And possibly not in the outerScope either, since that probably wouldn't count as shadowing.
            %  It might be in some other higher/used scope.
13493:       pIdent
13495:       Node decl = @newIdent( nEnumValue, LAST_ID )
13508:       Node decl2 = @newIdent( nEnumValue, LAST_ID )
13521:       oNodeSet( decl, qType, resultType )
13533:       oNodeSet( decl2, qType, resultType )
      
            % build up name table, for i/o
13545:       int nameOffset = oStringAllocLit( ID_STRING( LAST_ID ) )
13558:       oNodeSetInt( decl, qNameOffset, nameOffset )
13570:       oNodeSetInt( decl2, qNameOffset, nameOffset )
13582:       [
13582:          | '=', ':=' :
13584:             oTypeSPush( IntegerType )
13590:             @ConstExpr
13592:             @ConstCoerceType
13594:             oTypeSPop
                  % value must be ascending
                  % this obviously doesn't apply to the first value
13595:             [ equal_zero( numValues )
13602:                | false :
13603:                   [ greater( oValueTop, value )
13612:                      | false :   #eEnumValueNotAscending
13615:                      | * :
13620:                   ]
13620:                | * :
13625:             ]
13625:             [ equal( value, oValueTop )
13634:                | false :
                        % The values differ from 0..N-1.  pred/succ may not be used with this type.
13635:                   oNodeSetBoolean( resultType, qHasGap, true )
13647:                | * :
13652:             ]
13652:             value = oValueTop
13657:             oValuePop
13658:          | * :
13665:       ]
13665:       oNodeSetInt( decl, qValue, value )
13677:       oNodeSetInt( decl2, qValue, value )
13689:       oScopeDeclare( decl )
      
13695:       oScopeEnter( outerScope )
13701:       oScopeDeclare( decl2 )
13707:       oScopeEnd
      
13708:       inc( value )
13714:       inc( numValues )
13720:       [
13720:          | ',' :
13722:          | * :    >
13729:       ]
13729:    }
13731:    ')'
      
13733:    oNodeSet( resultType, qScope, oScopeCurrent )
13744:    oNodeSetInt( resultType, qSize, 4 )   % always integer sized
13756:    oScopeEnd
      
         % Finish creation of the name table
         %    struct {
         %      int    value;
         %      int    padding;
         %      char*  name;
         %    } table[ numValues + 1 ];
         %  final entry will have name == nullptr
         %
         % I'll need to generate init code, to store pointers in global data,
         % since I don't have a relocation mechanism for static data at the moment.
13757:    oCodePush( @GetOrCreateInitCode( globalScope ) )
13768:    oScopeEnter( globalScope )
13774:    int size = multiply( add( numValues, 1 ), 16 )
13794:    int addr = oScopeAlloc( size, 8 )
13807:    oScopeEnd
13808:    oNodeSetInt( resultType, qNameTable, addr )
         % loop over enum values
13820:    NodeIter it = oNodeGetIter( oNodeGet( resultType, qScope ), qDecls )
13840:    {
13840:       Node enumValue = oNodeIterValue( it )
13850:       [ oNodeNull( enumValue )
13857:          | true :  >
13860:          | * :
13865:       ]
13865:       .tPushAddrGlobal  oEmitInt( addr )
13873:       .tPushConstI  oEmitInt( oNodeGetInt( enumValue, qValue ) )
13888:       .tAssignI
13890:       addr = add( addr, 8 )
13903:       .tPushAddrGlobal  oEmitInt( addr )
13911:       .tPushAddrGlobal  oEmitInt( oNodeGetInt( enumValue, qNameOffset ) )
13926:       .tAssignP
13928:       addr = add( addr, 8 )
13941:       oNodeIterNext( it )
13947:    }
         % final table entry
13949:    .tPushAddrGlobal  oEmitInt( addr )
13957:    .tPushConstI  oEmitInt( 0 )
13965:    .tAssignI
13967:    addr = add( addr, 8 )
13980:    .tPushAddrGlobal  oEmitInt( addr )
13988:    .tPushConstI  oEmitInt( 0 )
13996:    .tAssignP
13998:    addr = add( addr, 8 )
14011:    oCodePop
      
14012:    oTypeAdd( resultType )
14019:    ;
      
      
      
      % Return an nType representing a pointer to the given type.
      % (Creates a new type if necessary.)
      %
14019: PointerTypeTo( Node theType ) >> Node:
14021:    Node ptrType = oNodeGet( theType, qPointerType )
14034:    [ oNodeNull( ptrType )
14041:       | true :
14042:          ptrType = oNodeNew( nPointerType )
14052:          oNodeSet( ptrType, qBaseType, theType )
14064:          oNodeSetInt( ptrType, qSize, 8 )
14076:          oTypeAdd( ptrType )
14082:          oNodeSet( theType, qPointerType, ptrType )
14094:       | * :
14099:    ]
14099:    >> ptrType;
      
      
      
      % Return the low value of an ordinal type
      %
14103: OrdinalLow( Node theType ) >> int:
14105:    [ oNodeType( theType )
14112:       | nIntegerType :  >> oMININT
14115:       | nBooleanType :  >> 0
14120:       | nCharType :     >> 0
14125:       | nEnumType :
14127:          Node enumScope = oNodeGet( theType, qScope )
14140:          Node first = oNodeIterValue( oNodeGetIter( enumScope, qDecls ) )
14157:          >> oNodeGetInt( first, qValue )
14167:       | nSubrangeType : >> oNodeGetInt( theType, qLow )
14179:       | * :             #eNotOrdinalType
14194:                         >> 0
14197:    ];
      
      
      % Return the high value of an ordinal type
      %
14198: OrdinalHigh( Node theType ) >> int:
14200:    [ oNodeType( theType )
14207:       | nIntegerType :  >> oMAXINT
14210:       | nBooleanType :  >> 1
14215:       | nCharType :     >> 255
14220:       | nEnumType :
14222:          Node enumScope = oNodeGet( theType, qScope )
14235:          Node last = oNodeIterValue( oNodeGetIterLast( enumScope, qDecls ) )
14252:          >> oNodeGetInt( last, qValue )
14262:       | nSubrangeType : >> oNodeGetInt( theType, qHigh )
14274:       | * :             #eNotOrdinalType
14289:                         >> 0
14292:    ];
      
      
      
14293: Program:
14295:    Node t
      
14295:    workspace = oWorkspaceNew
      
         % root scope is used for builtins e.g. Integer,
         % and is a parent to any used units, and the program's own global scope.
14300:    oScopeBegin( 0, allocGlobal )
14309:    Node rootScope = oScopeCurrent
      
14314:    @installBuiltIns
      
         % Start by calling the main program routine.
      
         % This dummy call to main needs to look like a normal method itself,
         % so jit can align the stack properly.  So we need .tEnter,
         % and .tAllocActuals / .tFreeActuals.
14316:    .tEnter  oEmitInt( 0 )
14324:    Label mainLabel = oLabelNew
      
14329:    .tAllocActuals  oEmitInt( 0 )
14337:    .tCall  oEmitLabel( mainLabel )
14345:    .tFreeActuals  oEmitInt( 0 )
14353:    .tReturn
      
14355:    pProgram
14357:    pIdent
      
14359:    Node program = oNodeNew( nProgram )
14369:    oNodeSetInt( program, qIdent, LAST_ID )
14380:    oNodeSet( workspace, qProgram, program )
      
      
14392:    [
14392:       | '(' :
14394:          pIdent      % input, output files
      
14396:          t = @newIdent( nVar, LAST_ID )
14409:          oNodeSet( t, qType, FileType )
14421:          oScopeDeclareAlloc( t )
               % TO DO: I shouldn't declare the files in root scope.
               %        Should save them for program's global scope.
      
14427:          ','
14429:          pIdent
      
14431:          t = @newIdent( nVar, LAST_ID )
14444:          oNodeSet( t, qType, FileType )
14456:          oScopeDeclareAlloc( t )
      
14462:          ')'
14464:       | * :
14469:    ]
14469:    ';'
      
14471:    @UsesMySystem( program )
         % The uses clause may only appear once, immediately after the program declaration.
14478:    [
14478:       | pUses :  @UsesClause( program )
14487:       | * :
14492:    ]
14492:    @EnterUsedUnits( program )
      
         % Global scope for the program, below any used units.
14499:    oScopeBegin( 0, allocGlobal )
14508:    globalScope = oScopeCurrent
      
         % A new scope just for temporaries in the main routine
         % Create it up front, in case it's needed by variable initialization exprs.
         % But we won't stay in it here.
         % Note we say it extends the global scope, so that during main statement evaluation
         % any user labels declared in the global scope are considered to be part of the current scope.
14513:    oScopeBegin( 0, allocDown )
14522:    oNodeSet( oScopeCurrent, qExtends, globalScope )
14533:    initScope = oScopeCurrent
14538:    oNodeSet( program, qMainRoutineScope, initScope )
14550:    oScopeEnd
      
14551:    @BlockDecls( nGlobalVar )
      
      
14558:    oScopeEnter( initScope )
      
         % The block statement includes a stack frame, and enter/return,
         % even for the main routine.
         % That will be necessary for temporaries allocated in the main routine.
      
         % isMain means we'll generate calls to the unit init/final methods in here too.
         % Alternatively we could do that in a higher level method that calls main.
14564:    boolean isMain = true
14570:    @BlockStmt( mainLabel, globalScope, isMain )
      
14583:    oScopeEnd   % main routine scope
      
14584:    '.'
14586:    @CheckForUndefinedLabels
14588:    oScopeEnd   % global scope
14589:    @EndUsedUnits( program )   % used units scopes
14597:    ;
      
      
      
      
14597: Block( node_type varNodeType, Label labelForBody ):
14599:    @BlockDecls( varNodeType )
14606:    @BlockStmt( labelForBody, oScopeCurrent, false )
14618:    @CheckForUndefinedLabels
14621:    ;
      
      
14621: BlockDecls( node_type varNodeType ):
14623:    {[
14623:       | pConst :     @ConstDecl
14627:       | pType :      @TypeDecl
14631:       | pVar :       @VarDecl( varNodeType )
14640:       | pLabel :     @LabelDecl
14644:       | pProcedure : @ProcDecl
14648:       | pFunction :  @FuncDecl
14652:       | * :          >
14669:    ]}
14671:    @CheckForUndefinedMethods
14674:    ;
      
      
      % were there any procedures or functions declared in this scope
      % that were never defined?
14674: CheckForUndefinedMethods:
         % TO DO
         % Note: disregard methods marked external
14677:    ;
      
      % were there any labels declared in the current scope, and used,
      % but never defined (as the prefix of a stement)?
      %
14677: CheckForUndefinedLabels:
14679:    NodeIter it = oNodeGetIter( oScopeCurrent, qDecls )
14691:    {
14691:       Node decl = oNodeIterValue( it )
14701:       [ oNodeNull( decl )
14708:          | false :
14709:          | * :  >
14716:       ]
14716:       [ oNodeType( decl )
14723:          | nLabel :
14724:             [ oNodeGetBoolean( decl, qDefined )
14734:                | false :
14735:                   [ oNodeGetBoolean( decl, qUsed )
14745:                      | true :    #eUsedButNotDefined  % TO DO: give the decl in the message
14748:                      | * :
14753:                   ]
14753:                | * :
14758:             ]
14758:          | * :
14763:       ]
14763:       oNodeIterNext( it )
14769:    }
14772:    ;
      
      
      % Given the scope of vars in this block.
      % Usually it's the current scope, but it's a bit different for the main statement.
      %
14772: BlockStmt( Label labelForBody, Node varScope, boolean isMain ):
14774:    .tLabel  oEmitLabel( labelForBody )
      
         % Proc, func, and main routine all start with tEnter
         % to create a stack frame.  This will be used for temporaries
         % (and local vars in the case of proc, func).
      
14782:    int patchLS
14782:    .tEnter  patchLS = Here  .tSpace
      
         % If we're generating the program main method,
         % add in calls to the loaded units' initialization and finalization.
14791:    [ isMain
14794:       | true :  @InitializeUnits
14797:       | * :
14802:    ]
      
         % insert any code for initialization of this scope's variables
14802:    Code initCode = oNodeGetCode( varScope, qInitCode )
14815:    oEmitCode( initCode )
14821:    oNodeSetCode( varScope, qInitCode, codeNull )
      
14833:    @Statement
      
14835:    [ isMain
14838:       | true :  @FinalizeUnits
14841:       | * :
14846:    ]
      
14846:    .tReturn
      
14848:    int localSpace = oNodeGetInt( oScopeCurrent, qSize )
14860:    oPatch( patchLS, localSpace )
14870:    ;
      
      
      % We need an initCode code stream for the given scope.
      % Create it if not present yet.  Return it.
      % (This will be used for variable initialization.)
      %
14870: GetOrCreateInitCode( Node scope ) >> Code:
14872:    Code initCode = oNodeGetCode( scope, qInitCode )
14885:    [ equal_code( initCode, codeNull )
14895:       | true :
14896:          initCode = oCodeNew
14901:          oNodeSetCode( scope, qInitCode, initCode )
14913:       | * :
14918:    ]
14918:    >> initCode;
      
      
      
      
      
      % -------------------------------- Utilities -------------------------------
      
      % Return the static scope level of the current scope
      %
14922: ScopeLevel >> int:
14924:    >> oNodeGetInt( oScopeCurrent, qLevel );
      
      % Return the static scope level of the given declaration
      %
14934: DeclLevel( Node decl ) >> int:
14936:    >> oNodeGetInt( oNodeGet( decl, qParentScope ), qLevel );
         
      
      % How many levels higher is the given declaration from the current scope?
      %
14954: DeclUpLevels( Node decl ) >> int:
14956:    >> subtract( @ScopeLevel, @DeclLevel( decl ) );
      
      
      
      
      % Create and return a new nIdent of the given node_type, with the given ident id.
      % Does not add it to any scope.
      %
14972: newIdent( node_type nt, int id ) >> Node:
14974:   Node t = oNodeNew( nt )
14984:   oNodeSetInt( t, qIdent, id )
14996:   >> t
15000:   ;
      
      
      % Emit the value in a declaration.
      % For a constant integer, this is the constant value.
      % For a global variable, this is the global address.
      % For a local variable, this is the local address relative to the call stack frame.
      %
15000: EmitValue( Node decl ):
15002:     oEmitInt( oNodeGetInt( decl, qValue ));
      
      
15016: DeclareBuiltInFunc( int id ) >> Node:
15018:    Node decl = @newIdent( nBuiltInFunc, id )
15032:    oScopeDeclare( decl )
15038:    >> decl;
      
      
15042: installBuiltIns:
      
         % initialize some other globals too
15044:    flagExprAllowTypeName = false
      
         % "mysystem" is the name of a unit that will be available everywhere.
         % Add its name to the id table so we can easily spot the name later.
15050:    mysystemId = oId_mysystem
      
         % install built-in types
15055:    FileType = @newType( nFileType, 4 )
15069:    IntegerType = @newType( nIntegerType, 4 )
15083:    BooleanType = @newType( nBooleanType, 1 )
15097:    BooleanFlowType = @newType( nBooleanFlowType, 1 )
15111:    CharType = @newType( nCharType, 1 )
15125:    PCharType = @PointerTypeTo( CharType )
15136:    ByteType = @newType( nByteType, 1 )
15150:    SingleType = @newType( nSingleType, 4 )
15164:    DoubleType = @newType( nDoubleType, 8 )
         % Universal pointer says base type Byte, but this is only for the sake of
         % pointer arithmetic.  It doesn't matter otherwise, because this type cannot be dereferened.
15178:    UniversalPointerType = @newType( nUniversalPointerType, 8 )
15192:    oNodeSet( UniversalPointerType, qBaseType, ByteType )
         % StrLitType is stored with both a length byte and null termination, so it can be assigned to
         % both a ShortString and a PChar.  StrLits longer than 255 characters appear truncated when
         % referenced as a ShortString, but not when referenced as a PChar.
15204:    StrLitType = @newType( nStrLitType, 256 )
         % ShortString is the original Pascal string type: an array of characters, not null-terminated,
         % with the first byte recording the current length.
         % The default ShortString type has capacity for 255 characters.  The user may define
         % additional ShortString types with smaller capacities.
         % The first character can be accessed as myString[1].
15218:    ShortStringType = @newType( nShortStringType, 256 )
15232:    oNodeSetInt( ShortStringType, qCapacity, 255 )
      
         % Declare those type identifiers.
         % SSL doesn't support strings, so need help from operations e.g. oId_File
      
15244:    Node t
      
15244:    t = @newIdent( nTypeDecl, oId_File )
15257:    oNodeSet( t, qType, FileType )
15269:    oScopeDeclare( t )
      
15275:    t = @newIdent( nTypeDecl, oId_Integer )
15288:    oNodeSet( t, qType, IntegerType )
15300:    oScopeDeclare( t )
      
15306:    t = @newIdent( nTypeDecl, oId_Boolean )
15319:    oNodeSet( t, qType, BooleanType )
15331:    oScopeDeclare( t )
      
15337:    t = @newIdent( nTypeDecl, oId_Char )
15350:    oNodeSet( t, qType, CharType )
15362:    oScopeDeclare( t )
      
15368:    t = @newIdent( nTypeDecl, oId_Byte )
15381:    oNodeSet( t, qType, ByteType )
15393:    oScopeDeclare( t )
      
15399:    t = @newIdent( nTypeDecl, oId_Single )
15412:    oNodeSet( t, qType, SingleType )
15424:    oScopeDeclare( t )
      
15430:    t = @newIdent( nTypeDecl, oId_Double )
15443:    oNodeSet( t, qType, DoubleType )
15455:    oScopeDeclare( t )
      
15461:    t = @newIdent( nTypeDecl, oId_Pointer )
15474:    oNodeSet( t, qType, UniversalPointerType )
15486:    oScopeDeclare( t )
      
15492:    t = @newIdent( nTypeDecl, oId_ShortString )
15505:    oNodeSet( t, qType, ShortStringType )
15517:    oScopeDeclare( t )
      
         % Built-in constants
      
15523:    t = @newIdent( nConst, oId_True )
15536:    oNodeSet( t, qType, BooleanType )
15548:    oNodeSetInt( t, qValue, 1 )
15560:    oScopeDeclare( t )
      
15566:    t = @newIdent( nConst, oId_False )
15579:    oNodeSet( t, qType, BooleanType )
15591:    oNodeSetInt( t, qValue, 0 )
15603:    oScopeDeclare( t )
      
15609:    t = @newIdent( nConst, oId_Nil )
15622:    oNodeSet( t, qType, UniversalPointerType )
15634:    oNodeSetInt( t, qValue, 0 )
15646:    oScopeDeclare( t )
      
         % Built-in methods
         % These aren't declared like normal methods, because they may have
         % special rules for parameter types (e.g. any scalar type).
         % Calls to these methods will be handled specially by the compiler.
      
15652:    BuiltIn_Ord = @DeclareBuiltInFunc( oId_Ord )
15662:    BuiltIn_Chr = @DeclareBuiltInFunc( oId_Chr )
15672:    BuiltIn_Pred = @DeclareBuiltInFunc( oId_Pred )
15682:    BuiltIn_Succ = @DeclareBuiltInFunc( oId_Succ )
15692:    BuiltIn_Sizeof = @DeclareBuiltInFunc( oId_Sizeof )
15703:    ;
      
15703: end
      
15703: 

Generated code:

   0: oGlobalSpace 26
   2: oLocalSpace 0
   4: oCall 14293
   6: oReturn
   7: oLocalSpace 0
   9: oInput 0
  11: LAST_ID
  12: oPushResult
  13: oGetParam 1
  15: oPushResult
  16: oCall 148
  18: oPop 2
  20: oInputChoice 24
  22: oJumpForward 29
  24: Choice Lookup Table
          14     22
  27: oJumpForward 31
  29: oJumpBack 9
  31: oInput 6
  33: oReturn
  34: oLocalSpace 0
  36: oGetParam 1
  38: oPushResult
  39: oSetResult 4
  41: oPushResult
  42: oNodeGetInt
  43: oPop 2
  45: oPushResult
  46: oGetGlobal 4
  48: oPushResult
  49: equal
  50: oPop 2
  52: oChoice 57
  54: oReturn
  55: oJumpForward 60
  57: Choice Lookup Table
           1     54
  60: oGetGlobal 4
  62: oPushResult
  63: oGetParam 1
  65: oPushResult
  66: oCall 148
  68: oPop 2
  70: oReturn
  71: oLocalSpace 0
  73: oGetParam 1
  75: oPushResult
  76: oSetResult 4
  78: oPushResult
  79: oNodeGetInt
  80: oPop 2
  82: oPushResult
  83: oGetGlobal 4
  85: oPushResult
  86: equal
  87: oPop 2
  89: oChoice 144
  91: oGetAddrGlobal 22
  93: oPushResult
  94: oScopeCurrent
  95: oPushResult
  96: oSetResult 15
  98: oPushResult
  99: oSetResult 4
 101: oPushResult
 102: oId_ShortStringAppendShortString
 103: oPushResult
 104: oNodeFind
 105: oPop 4
 107: oAssign
 108: oGetAddrGlobal 23
 110: oPushResult
 111: oScopeCurrent
 112: oPushResult
 113: oSetResult 15
 115: oPushResult
 116: oSetResult 4
 118: oPushResult
 119: oId_ShortStringAppendChar
 120: oPushResult
 121: oNodeFind
 122: oPop 4
 124: oAssign
 125: oGetAddrGlobal 24
 127: oPushResult
 128: oScopeCurrent
 129: oPushResult
 130: oSetResult 15
 132: oPushResult
 133: oSetResult 4
 135: oPushResult
 136: oId_ShortStringCmp
 137: oPushResult
 138: oNodeFind
 139: oPop 4
 141: oAssign
 142: oJumpForward 147
 144: Choice Lookup Table
           1     91
 147: oReturn
 148: oLocalSpace 2
 150: oGetAddrLocal 1
 152: oPushResult
 153: oGetParam 2
 155: oPushResult
 156: oCall 428
 158: oPop 1
 160: oAssign
 161: oGetLocal 1
 163: oPushResult
 164: oSetResult 0
 166: oPushResult
 167: equal_node
 168: oPop 2
 170: oChoice 240
 172: oGetParam 1
 174: oPushResult
 175: oSetResult 5
 177: oPushResult
 178: oGetLocal 1
 180: oPushResult
 181: oNodeAddLast
 182: oPop 3
 184: oGetAddrLocal 2
 186: oPushResult
 187: oSetResult 10
 189: oPushResult
 190: oNodeNew
 191: oPop 1
 193: oAssign
 194: oGetLocal 2
 196: oPushResult
 197: oSetResult 4
 199: oPushResult
 200: oGetLocal 1
 202: oPushResult
 203: oSetResult 4
 205: oPushResult
 206: oNodeGetInt
 207: oPop 2
 209: oPushResult
 210: oNodeSetInt
 211: oPop 3
 213: oGetLocal 2
 215: oPushResult
 216: oSetResult 9
 218: oPushResult
 219: oGetLocal 1
 221: oPushResult
 222: oSetResult 9
 224: oPushResult
 225: oNodeGet
 226: oPop 2
 228: oPushResult
 229: oNodeSet
 230: oPop 3
 232: oGetLocal 2
 234: oPushResult
 235: oScopeDeclare
 236: oPop 1
 238: oJumpForward 243
 240: Choice Lookup Table
           0    172
 243: oReturn
 244: oLocalSpace 1
 246: oGetFromParam 1
 248: oPushResult
 249: oNodeType
 250: oPop 1
 252: oChoice 283
 254: oGetAddrLocal 1
 256: oPushResult
 257: oGetFromParam 1
 259: oPushResult
 260: oSetResult 9
 262: oPushResult
 263: oNodeGet
 264: oPop 2
 266: oAssign
 267: oInput 21
 269: oInput 0
 271: oGetParam 1
 273: oPushResult
 274: oGetLocal 1
 276: oPushResult
 277: oScopeFindRequireInScope
 278: oPop 1
 280: oAssign
 281: oJumpForward 286
 283: Choice Lookup Table
          10    254
 286: oReturn
 287: oLocalSpace 2
 289: oGetAddrLocal 1
 291: oPushResult
 292: oGetParam 1
 294: oPushResult
 295: oSetResult 5
 297: oPushResult
 298: oNodeGetIter
 299: oPop 2
 301: oAssign
 302: oGetAddrLocal 2
 304: oPushResult
 305: oGetLocal 1
 307: oPushResult
 308: oNodeIterValue
 309: oPop 1
 311: oAssign
 312: oGetLocal 2
 314: oPushResult
 315: oNodeNull
 316: oPop 1
 318: oChoice 335
 320: oGetLocal 2
 322: oPushResult
 323: oSetResult 9
 325: oPushResult
 326: oNodeGet
 327: oPop 2
 329: oPushResult
 330: oScopeEnter
 331: oPop 1
 333: oJumpForward 340
 335: Choice Lookup Table
           0    320
 338: oJumpForward 348
 340: oGetAddrLocal 1
 342: oPushResult
 343: oNodeIterNext
 344: oPop 1
 346: oJumpBack 302
 348: oReturn
 349: oLocalSpace 2
 351: oGetAddrLocal 1
 353: oPushResult
 354: oGetParam 1
 356: oPushResult
 357: oSetResult 5
 359: oPushResult
 360: oNodeGetIterLast
 361: oPop 2
 363: oAssign
 364: oGetAddrLocal 2
 366: oPushResult
 367: oGetLocal 1
 369: oPushResult
 370: oNodeIterValue
 371: oPop 1
 373: oAssign
 374: oGetLocal 2
 376: oPushResult
 377: oNodeNull
 378: oPop 1
 380: oChoice 414
 382: oScopeCurrent
 383: oPushResult
 384: oGetLocal 2
 386: oPushResult
 387: oSetResult 9
 389: oPushResult
 390: oNodeGet
 391: oPop 2
 393: oPushResult
 394: oNodeEqual
 395: oPop 2
 397: oChoice 405
 399: oJumpForward 411
 401: oError 27
 403: oJumpForward 411
 405: Choice Lookup Table
           0    401
           1    399
 410: oEndChoice
 411: oScopeEnd
 412: oJumpForward 419
 414: Choice Lookup Table
           0    382
 417: oJumpForward 427
 419: oGetAddrLocal 1
 421: oPushResult
 422: oNodeIterPrev
 423: oPop 1
 425: oJumpBack 364
 427: oReturn
 428: oLocalSpace 2
 430: oGetAddrLocal 1
 432: oPushResult
 433: oGetGlobal 1
 435: oPushResult
 436: oSetResult 1
 438: oPushResult
 439: oSetResult 4
 441: oPushResult
 442: oGetParam 1
 444: oPushResult
 445: oNodeFind
 446: oPop 4
 448: oAssign
 449: oGetLocal 1
 451: oPushResult
 452: oSetResult 0
 454: oPushResult
 455: equal_node
 456: oPop 2
 458: oChoice 465
 460: oGetLocal 1
 462: oReturn
 463: oJumpForward 468
 465: Choice Lookup Table
           0    460
 468: oGetAddrLocal 2
 470: oPushResult
 471: oGetParam 1
 473: oPushResult
 474: oIncludeUnitFile
 475: oPop 1
 477: oAssign
 478: oGetLocal 2
 480: oChoice 489
 482: oError 26
 484: oSetResult 0
 486: oReturn
 487: oJumpForward 492
 489: Choice Lookup Table
           0    482
 492: oGetAddrLocal 1
 494: oPushResult
 495: oCall 503
 497: oAssign
 498: oIncludeEnd
 499: oGetLocal 1
 501: oReturn
 502: oReturn
 503: oLocalSpace 2
 505: oInput 61
 507: oInput 0
 509: oGetAddrLocal 1
 511: oPushResult
 512: oSetResult 5
 514: oPushResult
 515: oNodeNew
 516: oPop 1
 518: oAssign
 519: oGetLocal 1
 521: oPushResult
 522: oSetResult 4
 524: oPushResult
 525: LAST_ID
 526: oPushResult
 527: oNodeSetInt
 528: oPop 3
 530: oGetAddrLocal 2
 532: oPushResult
 533: oSetResult 6
 535: oPushResult
 536: oNodeNew
 537: oPop 1
 539: oAssign
 540: oGetLocal 2
 542: oPushResult
 543: oSetResult 4
 545: oPushResult
 546: LAST_ID
 547: oPushResult
 548: oNodeSetInt
 549: oPop 3
 551: oGetLocal 1
 553: oPushResult
 554: oSetResult 8
 556: oPushResult
 557: oGetLocal 2
 559: oPushResult
 560: oNodeSet
 561: oPop 3
 563: oInput 6
 565: oInput 62
 567: oGetLocal 1
 569: oPushResult
 570: oCall 34
 572: oPop 1
 574: oInputChoice 585
 576: oGetLocal 1
 578: oPushResult
 579: oCall 7
 581: oPop 1
 583: oJumpForward 588
 585: Choice Lookup Table
          60    576
 588: oGetLocal 1
 590: oPushResult
 591: oCall 287
 593: oPop 1
 595: oSetResult 0
 597: oPushResult
 598: oSetResult 0
 600: oPushResult
 601: oScopeBegin
 602: oPop 2
 604: oGetLocal 1
 606: oPushResult
 607: oSetResult 9
 609: oPushResult
 610: oScopeCurrent
 611: oPushResult
 612: oNodeSet
 613: oPop 3
 615: oGetAddrGlobal 2
 617: oPushResult
 618: oScopeCurrent
 619: oAssign
 620: oSetResult 0
 622: oPushResult
 623: oSetResult 1
 625: oPushResult
 626: oScopeBegin
 627: oPop 2
 629: oGetAddrGlobal 3
 631: oPushResult
 632: oScopeCurrent
 633: oAssign
 634: oGetLocal 1
 636: oPushResult
 637: oSetResult 13
 639: oPushResult
 640: oGetGlobal 3
 642: oPushResult
 643: oNodeSet
 644: oPop 3
 646: oScopeEnd
 647: oGetLocal 1
 649: oPushResult
 650: oCall 838
 652: oPop 1
 654: oScopeEnd
 655: oInput 63
 657: oGetLocal 2
 659: oPushResult
 660: oCall 34
 662: oPop 1
 664: oInputChoice 675
 666: oGetLocal 2
 668: oPushResult
 669: oCall 7
 671: oPop 1
 673: oJumpForward 678
 675: Choice Lookup Table
          60    666
 678: oGetLocal 2
 680: oPushResult
 681: oCall 287
 683: oPop 1
 685: oGetLocal 1
 687: oPushResult
 688: oSetResult 9
 690: oPushResult
 691: oNodeGet
 692: oPop 2
 694: oPushResult
 695: oScopeEnter
 696: oPop 1
 698: oSetResult 0
 700: oPushResult
 701: oSetResult 0
 703: oPushResult
 704: oScopeBegin
 705: oPop 2
 707: oGetLocal 1
 709: oPushResult
 710: oSetResult 10
 712: oPushResult
 713: oScopeCurrent
 714: oPushResult
 715: oNodeSet
 716: oPop 3
 718: oScopeCurrent
 719: oPushResult
 720: oSetResult 16
 722: oPushResult
 723: oGetLocal 1
 725: oPushResult
 726: oSetResult 9
 728: oPushResult
 729: oNodeGet
 730: oPop 2
 732: oPushResult
 733: oNodeSet
 734: oPop 3
 736: oGetAddrGlobal 2
 738: oPushResult
 739: oScopeCurrent
 740: oAssign
 741: oGetLocal 1
 743: oPushResult
 744: oCall 930
 746: oPop 1
 748: oInputChoice 762
 750: oGetLocal 1
 752: oPushResult
 753: oSetResult 1
 755: oPushResult
 756: oCall 940
 758: oPop 2
 760: oJumpForward 775
 762: Choice Lookup Table
          64    750
 765: oGetLocal 1
 767: oPushResult
 768: oSetResult 0
 770: oPushResult
 771: oCall 940
 773: oPop 2
 775: oInputChoice 789
 777: oGetLocal 1
 779: oPushResult
 780: oSetResult 1
 782: oPushResult
 783: oCall 1126
 785: oPop 2
 787: oJumpForward 802
 789: Choice Lookup Table
          65    777
 792: oGetLocal 1
 794: oPushResult
 795: oSetResult 0
 797: oPushResult
 798: oCall 1126
 800: oPop 2
 802: oInput 37
 804: oInput 21
 806: oScopeEnd
 807: oScopeEnd
 808: oGetLocal 2
 810: oPushResult
 811: oCall 349
 813: oPop 1
 815: oGetLocal 1
 817: oPushResult
 818: oCall 349
 820: oPop 1
 822: oGetGlobal 1
 824: oPushResult
 825: oSetResult 1
 827: oPushResult
 828: oGetLocal 1
 830: oPushResult
 831: oNodeAddLast
 832: oPop 3
 834: oGetLocal 1
 836: oReturn
 837: oReturn
 838: oLocalSpace 2
 840: oInputChoice 907
 842: oCall 2538
 844: oJumpForward 920
 846: oCall 3231
 848: oJumpForward 920
 850: oSetResult 22
 852: oPushResult
 853: oCall 3287
 855: oPop 1
 857: oJumpForward 920
 859: oGetAddrLocal 1
 861: oPushResult
 862: oCall 1505
 864: oAssign
 865: oInputChoice 878
 867: oGetLocal 1
 869: oPushResult
 870: oCall 1418
 872: oPop 1
 874: oInput 6
 876: oJumpForward 881
 878: Choice Lookup Table
          71    867
 881: oJumpForward 920
 883: oGetAddrLocal 2
 885: oPushResult
 886: oCall 1879
 888: oAssign
 889: oInputChoice 902
 891: oGetLocal 2
 893: oPushResult
 894: oCall 1418
 896: oPop 1
 898: oInput 6
 900: oJumpForward 905
 902: Choice Lookup Table
          71    891
 905: oJumpForward 920
 907: Choice Lookup Table
          31    883
          30    859
          34    850
          33    846
          32    842
 918: oJumpForward 922
 920: oJumpBack 840
 922: oGetParam 1
 924: oPushResult
 925: oCall 71
 927: oPop 1
 929: oReturn
 930: oLocalSpace 0
 932: oSetResult 22
 934: oPushResult
 935: oCall 14621
 937: oPop 1
 939: oReturn
 940: oLocalSpace 5
 942: oGetAddrLocal 1
 944: oPushResult
 945: oLabelNew
 946: oAssign
 947: oEmit 97
 949: oGetLocal 1
 951: oPushResult
 952: oEmitLabel
 953: oPop 1
 955: oGetParam 2
 957: oPushResult
 958: oSetResult 11
 960: oPushResult
 961: oGetLocal 1
 963: oPushResult
 964: oNodeSetLabel
 965: oPop 3
 967: oEmit 87
 969: oGetAddrLocal 2
 971: oPushResult
 972: Here
 973: oAssign
 974: oEmit 115
 976: oGetAddrLocal 3
 978: oPushResult
 979: oGetParam 2
 981: oPushResult
 982: oSetResult 9
 984: oPushResult
 985: oNodeGet
 986: oPop 2
 988: oAssign
 989: oGetAddrLocal 4
 991: oPushResult
 992: oGetLocal 3
 994: oPushResult
 995: oSetResult 19
 997: oPushResult
 998: oNodeGetCode
 999: oPop 2
1001: oAssign
1002: oGetLocal 4
1004: oPushResult
1005: oEmitCode
1006: oPop 1
1008: oGetLocal 3
1010: oPushResult
1011: oSetResult 19
1013: oPushResult
1014: oSetResult 0
1016: oPushResult
1017: oNodeSetCode
1018: oPop 3
1020: oGetAddrLocal 3
1022: oPushResult
1023: oGetParam 2
1025: oPushResult
1026: oSetResult 10
1028: oPushResult
1029: oNodeGet
1030: oPop 2
1032: oAssign
1033: oGetAddrLocal 4
1035: oPushResult
1036: oGetLocal 3
1038: oPushResult
1039: oSetResult 19
1041: oPushResult
1042: oNodeGetCode
1043: oPop 2
1045: oAssign
1046: oGetLocal 4
1048: oPushResult
1049: oEmitCode
1050: oPop 1
1052: oGetLocal 3
1054: oPushResult
1055: oSetResult 19
1057: oPushResult
1058: oSetResult 0
1060: oPushResult
1061: oNodeSetCode
1062: oPop 3
1064: oGetParam 2
1066: oPushResult
1067: oSetResult 13
1069: oPushResult
1070: oNodeGet
1071: oPop 2
1073: oPushResult
1074: oScopeEnter
1075: oPop 1
1077: oGetParam 1
1079: oChoice 1098
1081: oCall 9673
1083: oInputChoice 1089
1085: oCall 9673
1087: oJumpForward 1094
1089: Choice Lookup Table
           6   1085
1092: oJumpForward 1096
1094: oJumpBack 1083
1096: oJumpForward 1101
1098: Choice Lookup Table
           1   1081
1101: oEmit 86
1103: oGetAddrLocal 5
1105: oPushResult
1106: oScopeCurrent
1107: oPushResult
1108: oSetResult 17
1110: oPushResult
1111: oNodeGetInt
1112: oPop 2
1114: oAssign
1115: oGetLocal 2
1117: oPushResult
1118: oGetLocal 5
1120: oPushResult
1121: oPatch
1122: oPop 2
1124: oScopeEnd
1125: oReturn
1126: oLocalSpace 3
1128: oGetAddrLocal 1
1130: oPushResult
1131: oLabelNew
1132: oAssign
1133: oEmit 97
1135: oGetLocal 1
1137: oPushResult
1138: oEmitLabel
1139: oPop 1
1141: oGetParam 2
1143: oPushResult
1144: oSetResult 12
1146: oPushResult
1147: oGetLocal 1
1149: oPushResult
1150: oNodeSetLabel
1151: oPop 3
1153: oEmit 87
1155: oGetAddrLocal 2
1157: oPushResult
1158: Here
1159: oAssign
1160: oEmit 115
1162: oSetResult 0
1164: oPushResult
1165: oSetResult 1
1167: oPushResult
1168: oScopeBegin
1169: oPop 2
1171: oGetParam 1
1173: oChoice 1192
1175: oCall 9673
1177: oInputChoice 1183
1179: oCall 9673
1181: oJumpForward 1188
1183: Choice Lookup Table
           6   1179
1186: oJumpForward 1190
1188: oJumpBack 1177
1190: oJumpForward 1195
1192: Choice Lookup Table
           1   1175
1195: oEmit 86
1197: oGetAddrLocal 3
1199: oPushResult
1200: oScopeCurrent
1201: oPushResult
1202: oSetResult 17
1204: oPushResult
1205: oNodeGetInt
1206: oPop 2
1208: oAssign
1209: oGetLocal 2
1211: oPushResult
1212: oGetLocal 3
1214: oPushResult
1215: oPatch
1216: oPop 2
1218: oScopeEnd
1219: oReturn
1220: oLocalSpace 2
1222: oGetAddrLocal 1
1224: oPushResult
1225: oGetGlobal 1
1227: oPushResult
1228: oSetResult 1
1230: oPushResult
1231: oNodeGetIter
1232: oPop 2
1234: oAssign
1235: oGetAddrLocal 2
1237: oPushResult
1238: oGetLocal 1
1240: oPushResult
1241: oNodeIterValue
1242: oPop 1
1244: oAssign
1245: oGetLocal 2
1247: oPushResult
1248: oNodeNull
1249: oPop 1
1251: oChoice 1296
1253: oJumpForward 1304
1255: oJumpForward 1302
1257: oEmit 81
1259: oSetResult 0
1261: oPushResult
1262: oEmitInt
1263: oPop 1
1265: oEmit 84
1267: oGetLocal 2
1269: oPushResult
1270: oSetResult 11
1272: oPushResult
1273: oNodeGetLabel
1274: oPop 2
1276: oPushResult
1277: oEmitLabel
1278: oPop 1
1280: oEmit 83
1282: oSetResult 0
1284: oPushResult
1285: oEmitInt
1286: oPop 1
1288: oGetAddrLocal 1
1290: oPushResult
1291: oNodeIterNext
1292: oPop 1
1294: oJumpForward 1302
1296: Choice Lookup Table
           0   1257
           1   1253
1301: oEndChoice
1302: oJumpBack 1235
1304: oReturn
1305: oLocalSpace 2
1307: oGetAddrLocal 1
1309: oPushResult
1310: oGetGlobal 1
1312: oPushResult
1313: oSetResult 1
1315: oPushResult
1316: oNodeGetIterLast
1317: oPop 2
1319: oAssign
1320: oGetAddrLocal 2
1322: oPushResult
1323: oGetLocal 1
1325: oPushResult
1326: oNodeIterValue
1327: oPop 1
1329: oAssign
1330: oGetLocal 2
1332: oPushResult
1333: oNodeNull
1334: oPop 1
1336: oChoice 1381
1338: oJumpForward 1389
1340: oJumpForward 1387
1342: oEmit 81
1344: oSetResult 0
1346: oPushResult
1347: oEmitInt
1348: oPop 1
1350: oEmit 84
1352: oGetLocal 2
1354: oPushResult
1355: oSetResult 12
1357: oPushResult
1358: oNodeGetLabel
1359: oPop 2
1361: oPushResult
1362: oEmitLabel
1363: oPop 1
1365: oEmit 83
1367: oSetResult 0
1369: oPushResult
1370: oEmitInt
1371: oPop 1
1373: oGetAddrLocal 1
1375: oPushResult
1376: oNodeIterPrev
1377: oPop 1
1379: oJumpForward 1387
1381: Choice Lookup Table
           0   1342
           1   1338
1386: oEndChoice
1387: oJumpBack 1320
1389: oReturn
1390: oLocalSpace 0
1392: oInputChoice 1410
1394: oGetParam 1
1396: oPushResult
1397: oSetResult 27
1399: oPushResult
1400: oSetResult 1
1402: oPushResult
1403: oNodeSetBoolean
1404: oPop 3
1406: oInput 6
1408: oJumpForward 1415
1410: Choice Lookup Table
          73   1394
1413: oJumpForward 1417
1415: oJumpBack 1392
1417: oReturn
1418: oLocalSpace 0
1420: oGetParam 1
1422: oPushResult
1423: oCall 14934
1425: oPop 1
1427: oPushResult
1428: equal_zero
1429: oPop 1
1431: oChoice 1437
1433: oError 24
1435: oJumpForward 1440
1437: Choice Lookup Table
           0   1433
1440: oGetParam 1
1442: oPushResult
1443: oSetResult 27
1445: oPushResult
1446: oNodeGetBoolean
1447: oPop 2
1449: oChoice 1455
1451: oError 25
1453: oJumpForward 1458
1455: Choice Lookup Table
           0   1451
1458: oGetParam 1
1460: oPushResult
1461: oSetResult 25
1463: oPushResult
1464: oSetResult 1
1466: oPushResult
1467: oNodeSetBoolean
1468: oPop 3
1470: oInputChoice 1494
1472: oInputChoice 1489
1474: oInput 3
1476: oGetParam 1
1478: oPushResult
1479: oSetResult 26
1481: oPushResult
1482: CURRENT_STRLIT
1483: oPushResult
1484: oNodeSetString
1485: oPop 3
1487: oJumpForward 1492
1489: Choice Lookup Table
          72   1474
1492: oJumpForward 1497
1494: Choice Lookup Table
           3   1472
1497: oGetParam 1
1499: oPushResult
1500: oCall 12548
1502: oPop 1
1504: oReturn
1505: oLocalSpace 6
1507: oInput 0
1509: oGetAddrLocal 1
1511: oPushResult
1512: oSetResult 0
1514: oAssign
1515: oGetAddrLocal 2
1517: oPushResult
1518: oScopeFindInCurrentScope
1519: oAssign
1520: oGetLocal 2
1522: oPushResult
1523: oNodeNull
1524: oPop 1
1526: oChoice 1644
1528: oGetAddrLocal 2
1530: oPushResult
1531: oSetResult 12
1533: oPushResult
1534: LAST_ID
1535: oPushResult
1536: oCall 14972
1538: oPop 2
1540: oAssign
1541: oGetLocal 2
1543: oPushResult
1544: oSetResult 22
1546: oPushResult
1547: oLabelNew
1548: oPushResult
1549: oNodeSetLabel
1550: oPop 3
1552: oJumpForward 1650
1554: oGetAddrLocal 1
1556: oPushResult
1557: oSetResult 1
1559: oAssign
1560: oGetLocal 2
1562: oPushResult
1563: oSetResult 24
1565: oPushResult
1566: oNodeGetBoolean
1567: oPop 2
1569: oChoice 1575
1571: oError 22
1573: oJumpForward 1578
1575: Choice Lookup Table
           1   1571
1578: oGetLocal 2
1580: oPushResult
1581: oSetResult 25
1583: oPushResult
1584: oNodeGetBoolean
1585: oPop 2
1587: oChoice 1593
1589: oError 22
1591: oJumpForward 1596
1593: Choice Lookup Table
           1   1589
1596: oGetLocal 2
1598: oPushResult
1599: oNodeType
1600: oPop 1
1602: oChoice 1606
1604: oJumpForward 1611
1606: Choice Lookup Table
          12   1604
1609: oError 22
1611: oGetLocal 2
1613: oPushResult
1614: oSetResult 29
1616: oPushResult
1617: oGetLocal 2
1619: oPushResult
1620: oSetResult 23
1622: oPushResult
1623: oNodeGet
1624: oPop 2
1626: oPushResult
1627: oNodeSet
1628: oPop 3
1630: oGetLocal 2
1632: oPushResult
1633: oSetResult 23
1635: oPushResult
1636: oSetResult 0
1638: oPushResult
1639: oNodeSet
1640: oPop 3
1642: oJumpForward 1650
1644: Choice Lookup Table
           0   1554
           1   1528
1649: oEndChoice
1650: oGetAddrLocal 3
1652: oPushResult
1653: oCall 14922
1655: oAssign
1656: oGetAddrLocal 4
1658: oPushResult
1659: oGetLocal 3
1661: oPushResult
1662: oSetResult 0
1664: oPushResult
1665: greater
1666: oPop 2
1668: oAssign
1669: oGetAddrLocal 3
1671: oPushResult
1672: inc
1673: oPop 1
1675: oGetLocal 3
1677: oPushResult
1678: oSetResult 2
1680: oPushResult
1681: oScopeBegin
1682: oPop 2
1684: oGetAddrLocal 5
1686: oPushResult
1687: oScopeCurrent
1688: oAssign
1689: oGetLocal 4
1691: oChoice 1710
1693: oGetAddrLocal 6
1695: oPushResult
1696: oGetGlobal 6
1698: oPushResult
1699: oCall 14019
1701: oPop 1
1703: oPushResult
1704: oScopeAllocType
1705: oPop 1
1707: oAssign
1708: oJumpForward 1713
1710: Choice Lookup Table
           1   1693
1713: oCall 2314
1715: oGetLocal 2
1717: oPushResult
1718: oSetResult 23
1720: oPushResult
1721: oGetLocal 5
1723: oPushResult
1724: oNodeSet
1725: oPop 3
1727: oScopeEnd
1728: oInput 6
1730: oGetLocal 1
1732: oChoice 1744
1734: oGetLocal 2
1736: oPushResult
1737: oScopeDeclare
1738: oPop 1
1740: oJumpForward 1750
1742: oJumpForward 1750
1744: Choice Lookup Table
           1   1742
           0   1734
1749: oEndChoice
1750: oGetLocal 2
1752: oPushResult
1753: oCall 1390
1755: oPop 1
1757: oGetLocal 2
1759: oReturn
1760: oReturn
1761: oLocalSpace 4
1763: oGetAddrLocal 1
1765: oPushResult
1766: oCall 1505
1768: oAssign
1769: oInputChoice 1782
1771: oJumpForward 1876
1773: oGetLocal 1
1775: oPushResult
1776: oCall 1418
1778: oPop 1
1780: oJumpForward 1876
1782: Choice Lookup Table
          71   1773
          70   1771
1787: oGetAddrLocal 2
1789: oPushResult
1790: oGetLocal 1
1792: oPushResult
1793: oSetResult 23
1795: oPushResult
1796: oNodeGet
1797: oPop 2
1799: oAssign
1800: oGetLocal 2
1802: oPushResult
1803: oScopeEnter
1804: oPop 1
1806: oGetAddrLocal 3
1808: oPushResult
1809: oGetLocal 2
1811: oPushResult
1812: oSetResult 14
1814: oPushResult
1815: oNodeGetInt
1816: oPop 2
1818: oAssign
1819: oGetLocal 3
1821: oPushResult
1822: oSetResult 1
1824: oPushResult
1825: oScopeBegin
1826: oPop 2
1828: oGetLocal 1
1830: oPushResult
1831: oSetResult 6
1833: oPushResult
1834: oScopeCurrent
1835: oPushResult
1836: oNodeSet
1837: oPop 3
1839: oGetAddrLocal 4
1841: oPushResult
1842: oGetLocal 1
1844: oPushResult
1845: oSetResult 22
1847: oPushResult
1848: oNodeGetLabel
1849: oPop 2
1851: oAssign
1852: oSetResult 23
1854: oPushResult
1855: oGetLocal 4
1857: oPushResult
1858: oCall 14597
1860: oPop 2
1862: oGetLocal 1
1864: oPushResult
1865: oSetResult 24
1867: oPushResult
1868: oSetResult 1
1870: oPushResult
1871: oNodeSetBoolean
1872: oPop 3
1874: oScopeEnd
1875: oScopeEnd
1876: oInput 6
1878: oReturn
1879: oLocalSpace 8
1881: oInput 0
1883: oGetAddrLocal 1
1885: oPushResult
1886: oSetResult 0
1888: oAssign
1889: oGetAddrLocal 2
1891: oPushResult
1892: oScopeFindInCurrentScope
1893: oAssign
1894: oGetLocal 2
1896: oPushResult
1897: oNodeNull
1898: oPop 1
1900: oChoice 2031
1902: oGetAddrLocal 2
1904: oPushResult
1905: oSetResult 13
1907: oPushResult
1908: LAST_ID
1909: oPushResult
1910: oCall 14972
1912: oPop 2
1914: oAssign
1915: oGetLocal 2
1917: oPushResult
1918: oSetResult 22
1920: oPushResult
1921: oLabelNew
1922: oPushResult
1923: oNodeSetLabel
1924: oPop 3
1926: oJumpForward 2037
1928: oGetAddrLocal 1
1930: oPushResult
1931: oSetResult 1
1933: oAssign
1934: oGetLocal 2
1936: oPushResult
1937: oSetResult 24
1939: oPushResult
1940: oNodeGetBoolean
1941: oPop 2
1943: oChoice 1949
1945: oError 22
1947: oJumpForward 1952
1949: Choice Lookup Table
           1   1945
1952: oGetLocal 2
1954: oPushResult
1955: oNodeType
1956: oPop 1
1958: oChoice 1962
1960: oJumpForward 1967
1962: Choice Lookup Table
          13   1960
1965: oError 22
1967: oGetLocal 2
1969: oPushResult
1970: oSetResult 29
1972: oPushResult
1973: oGetLocal 2
1975: oPushResult
1976: oSetResult 23
1978: oPushResult
1979: oNodeGet
1980: oPop 2
1982: oPushResult
1983: oNodeSet
1984: oPop 3
1986: oGetLocal 2
1988: oPushResult
1989: oSetResult 23
1991: oPushResult
1992: oSetResult 0
1994: oPushResult
1995: oNodeSet
1996: oPop 3
1998: oGetLocal 2
2000: oPushResult
2001: oSetResult 30
2003: oPushResult
2004: oGetLocal 2
2006: oPushResult
2007: oSetResult 21
2009: oPushResult
2010: oNodeGet
2011: oPop 2
2013: oPushResult
2014: oNodeSet
2015: oPop 3
2017: oGetLocal 2
2019: oPushResult
2020: oSetResult 21
2022: oPushResult
2023: oSetResult 0
2025: oPushResult
2026: oNodeSet
2027: oPop 3
2029: oJumpForward 2037
2031: Choice Lookup Table
           0   1928
           1   1902
2036: oEndChoice
2037: oGetAddrLocal 3
2039: oPushResult
2040: oCall 14922
2042: oAssign
2043: oGetAddrLocal 4
2045: oPushResult
2046: oGetLocal 3
2048: oPushResult
2049: oSetResult 0
2051: oPushResult
2052: greater
2053: oPop 2
2055: oAssign
2056: oGetAddrLocal 3
2058: oPushResult
2059: inc
2060: oPop 1
2062: oGetLocal 3
2064: oPushResult
2065: oSetResult 2
2067: oPushResult
2068: oScopeBegin
2069: oPop 2
2071: oGetAddrLocal 5
2073: oPushResult
2074: oScopeCurrent
2075: oAssign
2076: oGetLocal 4
2078: oChoice 2097
2080: oGetAddrLocal 6
2082: oPushResult
2083: oGetGlobal 6
2085: oPushResult
2086: oCall 14019
2088: oPop 1
2090: oPushResult
2091: oScopeAllocType
2092: oPop 1
2094: oAssign
2095: oJumpForward 2100
2097: Choice Lookup Table
           1   2080
2100: oCall 2314
2102: oGetLocal 2
2104: oPushResult
2105: oSetResult 23
2107: oPushResult
2108: oGetLocal 5
2110: oPushResult
2111: oNodeSet
2112: oPop 3
2114: oInput 13
2116: oGetAddrLocal 7
2118: oPushResult
2119: oCall 12940
2121: oPop 1
2123: oGetLocal 2
2125: oPushResult
2126: oSetResult 21
2128: oPushResult
2129: oGetLocal 7
2131: oPushResult
2132: oNodeSet
2133: oPop 3
2135: oGetAddrLocal 8
2137: oPushResult
2138: oGetLocal 7
2140: oPushResult
2141: oCall 14019
2143: oPop 1
2145: oAssign
2146: oGetLocal 2
2148: oPushResult
2149: oSetResult 31
2151: oPushResult
2152: oGetLocal 8
2154: oPushResult
2155: oScopeAllocType
2156: oPop 1
2158: oPushResult
2159: oNodeSetInt
2160: oPop 3
2162: oScopeEnd
2163: oInput 6
2165: oGetLocal 1
2167: oChoice 2179
2169: oGetLocal 2
2171: oPushResult
2172: oScopeDeclare
2173: oPop 1
2175: oJumpForward 2185
2177: oJumpForward 2185
2179: Choice Lookup Table
           1   2177
           0   2169
2184: oEndChoice
2185: oGetLocal 2
2187: oPushResult
2188: oCall 1390
2190: oPop 1
2192: oGetLocal 2
2194: oReturn
2195: oReturn
2196: oLocalSpace 4
2198: oGetAddrLocal 1
2200: oPushResult
2201: oCall 1879
2203: oAssign
2204: oInputChoice 2217
2206: oJumpForward 2311
2208: oGetLocal 1
2210: oPushResult
2211: oCall 1418
2213: oPop 1
2215: oJumpForward 2311
2217: Choice Lookup Table
          71   2208
          70   2206
2222: oGetAddrLocal 2
2224: oPushResult
2225: oGetLocal 1
2227: oPushResult
2228: oSetResult 23
2230: oPushResult
2231: oNodeGet
2232: oPop 2
2234: oAssign
2235: oGetLocal 2
2237: oPushResult
2238: oScopeEnter
2239: oPop 1
2241: oGetAddrLocal 3
2243: oPushResult
2244: oGetLocal 2
2246: oPushResult
2247: oSetResult 14
2249: oPushResult
2250: oNodeGetInt
2251: oPop 2
2253: oAssign
2254: oGetLocal 3
2256: oPushResult
2257: oSetResult 1
2259: oPushResult
2260: oScopeBegin
2261: oPop 2
2263: oGetLocal 1
2265: oPushResult
2266: oSetResult 6
2268: oPushResult
2269: oScopeCurrent
2270: oPushResult
2271: oNodeSet
2272: oPop 3
2274: oGetAddrLocal 4
2276: oPushResult
2277: oGetLocal 1
2279: oPushResult
2280: oSetResult 22
2282: oPushResult
2283: oNodeGetLabel
2284: oPop 2
2286: oAssign
2287: oSetResult 23
2289: oPushResult
2290: oGetLocal 4
2292: oPushResult
2293: oCall 14597
2295: oPop 2
2297: oGetLocal 1
2299: oPushResult
2300: oSetResult 24
2302: oPushResult
2303: oSetResult 1
2305: oPushResult
2306: oNodeSetBoolean
2307: oPop 3
2309: oScopeEnd
2310: oScopeEnd
2311: oInput 6
2313: oReturn
2314: oLocalSpace 6
2316: oInputChoice 2534
2318: oGetAddrLocal 1
2320: oPushResult
2321: oNodeVecNew
2322: oAssign
2323: oGetAddrLocal 3
2325: oPushResult
2326: oSetResult 0
2328: oAssign
2329: oInputChoice 2339
2331: oGetAddrLocal 3
2333: oPushResult
2334: oSetResult 1
2336: oAssign
2337: oJumpForward 2342
2339: Choice Lookup Table
          34   2331
2342: oInput 0
2344: oGetAddrLocal 2
2346: oPushResult
2347: oSetResult 25
2349: oPushResult
2350: LAST_ID
2351: oPushResult
2352: oCall 14972
2354: oPop 2
2356: oAssign
2357: oGetLocal 2
2359: oPushResult
2360: oSetResult 35
2362: oPushResult
2363: oGetLocal 3
2365: oPushResult
2366: oNodeSetBoolean
2367: oPop 3
2369: oGetLocal 1
2371: oPushResult
2372: oGetLocal 2
2374: oPushResult
2375: oNodeVecAppend
2376: oPop 2
2378: oInputChoice 2386
2380: oJumpForward 2394
2382: oJumpForward 2392
2384: oJumpForward 2392
2386: Choice Lookup Table
          14   2384
          13   2380
2391: oEndChoice
2392: oJumpBack 2342
2394: oGetAddrLocal 4
2396: oPushResult
2397: oCall 12940
2399: oPop 1
2401: oGetLocal 3
2403: oChoice 2418
2405: oGetAddrLocal 5
2407: oPushResult
2408: oGetLocal 4
2410: oPushResult
2411: oCall 14019
2413: oPop 1
2415: oAssign
2416: oJumpForward 2427
2418: Choice Lookup Table
           1   2405
2421: oGetAddrLocal 5
2423: oPushResult
2424: oGetLocal 4
2426: oAssign
2427: oGetAddrLocal 6
2429: oPushResult
2430: oSetResult 0
2432: oAssign
2433: oGetLocal 6
2435: oPushResult
2436: oGetLocal 1
2438: oPushResult
2439: oNodeVecSize
2440: oPop 1
2442: oPushResult
2443: equal
2444: oPop 2
2446: oChoice 2503
2448: oGetAddrLocal 2
2450: oPushResult
2451: oGetLocal 1
2453: oPushResult
2454: oGetLocal 6
2456: oPushResult
2457: oNodeVecElement
2458: oPop 2
2460: oAssign
2461: oGetLocal 2
2463: oPushResult
2464: oSetResult 21
2466: oPushResult
2467: oGetLocal 4
2469: oPushResult
2470: oNodeSet
2471: oPop 3
2473: oGetLocal 2
2475: oPushResult
2476: oScopeDeclare
2477: oPop 1
2479: oGetLocal 2
2481: oPushResult
2482: oSetResult 22
2484: oPushResult
2485: oGetLocal 5
2487: oPushResult
2488: oScopeAllocType
2489: oPop 1
2491: oPushResult
2492: oNodeSetInt
2493: oPop 3
2495: oGetAddrLocal 6
2497: oPushResult
2498: inc
2499: oPop 1
2501: oJumpForward 2508
2503: Choice Lookup Table
           0   2448
2506: oJumpForward 2510
2508: oJumpBack 2433
2510: oGetLocal 1
2512: oPushResult
2513: oNodeVecDelete
2514: oPop 1
2516: oInputChoice 2524
2518: oJumpForward 2532
2520: oJumpForward 2530
2522: oJumpForward 2530
2524: Choice Lookup Table
           6   2522
          16   2518
2529: oEndChoice
2530: oJumpBack 2318
2532: oJumpForward 2537
2534: Choice Lookup Table
          15   2318
2537: oReturn
2538: oLocalSpace 0
2540: oInputChoice 2555
2542: oInputChoice 2548
2544: oCall 2701
2546: oJumpForward 2553
2548: Choice Lookup Table
          13   2544
2551: oCall 2563
2553: oJumpForward 2560
2555: Choice Lookup Table
           0   2542
2558: oJumpForward 2562
2560: oJumpBack 2540
2562: oReturn
2563: oLocalSpace 2
2565: oGetAddrLocal 1
2567: oPushResult
2568: LAST_ID
2569: oAssign
2570: oInput 7
2572: oCall 3586
2574: oTypeSNodeType
2575: oChoice 2658
2577: oGetAddrLocal 2
2579: oPushResult
2580: oSetResult 16
2582: oPushResult
2583: oGetLocal 1
2585: oPushResult
2586: oCall 14972
2588: oPop 2
2590: oAssign
2591: oGetLocal 2
2593: oPushResult
2594: oSetResult 22
2596: oPushResult
2597: oValueTop
2598: oPushResult
2599: oNodeSetInt
2600: oPop 3
2602: oJumpForward 2679
2604: oGetAddrLocal 2
2606: oPushResult
2607: oSetResult 19
2609: oPushResult
2610: oGetLocal 1
2612: oPushResult
2613: oCall 14972
2615: oPop 2
2617: oAssign
2618: oGetLocal 2
2620: oPushResult
2621: oSetResult 34
2623: oPushResult
2624: oValueTopDouble
2625: oPushResult
2626: oNodeSetDouble
2627: oPop 3
2629: oJumpForward 2679
2631: oGetAddrLocal 2
2633: oPushResult
2634: oSetResult 18
2636: oPushResult
2637: oGetLocal 1
2639: oPushResult
2640: oCall 14972
2642: oPop 2
2644: oAssign
2645: oGetLocal 2
2647: oPushResult
2648: oSetResult 33
2650: oPushResult
2651: oValueTopString
2652: oPushResult
2653: oNodeSetString
2654: oPop 3
2656: oJumpForward 2679
2658: Choice Lookup Table
          42   2631
          33   2604
          38   2577
          37   2577
          44   2577
          31   2577
          36   2577
          30   2577
          34   2577
2677: oError 18
2679: oValuePop
2680: oGetLocal 2
2682: oPushResult
2683: oSetResult 21
2685: oPushResult
2686: oTypeSTop
2687: oPushResult
2688: oNodeSet
2689: oPop 3
2691: oTypeSPop
2692: oGetLocal 2
2694: oPushResult
2695: oScopeDeclare
2696: oPop 1
2698: oInput 6
2700: oReturn
2701: oLocalSpace 3
2703: oGetAddrLocal 1
2705: oPushResult
2706: oSetResult 26
2708: oPushResult
2709: LAST_ID
2710: oPushResult
2711: oCall 14972
2713: oPop 2
2715: oAssign
2716: oGetAddrLocal 2
2718: oPushResult
2719: oCall 12940
2721: oPop 1
2723: oGetLocal 1
2725: oPushResult
2726: oSetResult 21
2728: oPushResult
2729: oGetLocal 2
2731: oPushResult
2732: oNodeSet
2733: oPop 3
2735: oGetLocal 2
2737: oPushResult
2738: oNodeType
2739: oPop 1
2741: oChoice 2845
2743: oInput 7
2745: oGetLocal 2
2747: oPushResult
2748: oTypeSPush
2749: oPop 1
2751: oCall 3586
2753: oCall 4478
2755: oGetLocal 1
2757: oPushResult
2758: oSetResult 22
2760: oPushResult
2761: oValueTop
2762: oPushResult
2763: oNodeSetInt
2764: oPop 3
2766: oValuePop
2767: oTypeSPop
2768: oGetLocal 1
2770: oPushResult
2771: oScopeDeclare
2772: oPop 1
2774: oInput 6
2776: oJumpForward 2869
2778: oError 17
2780: oJumpForward 2869
2782: oGetGlobal 2
2784: oPushResult
2785: oScopeEnter
2786: oPop 1
2788: oGetAddrLocal 3
2790: oPushResult
2791: oGetLocal 2
2793: oPushResult
2794: oScopeAllocType
2795: oPop 1
2797: oAssign
2798: oScopeEnd
2799: oGetGlobal 2
2801: oPushResult
2802: oCall 14870
2804: oPop 1
2806: oPushResult
2807: oCodePush
2808: oPop 1
2810: oGetLocal 1
2812: oPushResult
2813: oSetResult 22
2815: oPushResult
2816: oGetLocal 3
2818: oPushResult
2819: oNodeSetInt
2820: oPop 3
2822: oInput 7
2824: oGetLocal 2
2826: oPushResult
2827: oGetLocal 3
2829: oPushResult
2830: oCall 2870
2832: oPop 2
2834: oCodePop
2835: oGetLocal 1
2837: oPushResult
2838: oScopeDeclare
2839: oPop 1
2841: oInput 6
2843: oJumpForward 2869
2845: Choice Lookup Table
          41   2782
          39   2782
          29   2778
          43   2778
          38   2743
          37   2743
          44   2743
          31   2743
          36   2743
          30   2743
          34   2743
2868: oEndChoice
2869: oReturn
2870: oLocalSpace 10
2872: oGetParam 2
2874: oPushResult
2875: oNodeType
2876: oPop 1
2878: oChoice 3204
2880: oGetAddrLocal 1
2882: oPushResult
2883: oGetParam 2
2885: oPushResult
2886: oSetResult 38
2888: oPushResult
2889: oNodeGet
2890: oPop 2
2892: oAssign
2893: oGetAddrLocal 2
2895: oPushResult
2896: oGetParam 2
2898: oPushResult
2899: oSetResult 39
2901: oPushResult
2902: oNodeGet
2903: oPop 2
2905: oAssign
2906: oGetAddrLocal 3
2908: oPushResult
2909: oGetLocal 2
2911: oPushResult
2912: oCall 14103
2914: oPop 1
2916: oAssign
2917: oGetAddrLocal 4
2919: oPushResult
2920: oGetLocal 2
2922: oPushResult
2923: oCall 14198
2925: oPop 1
2927: oAssign
2928: oGetAddrLocal 5
2930: oPushResult
2931: oGetLocal 1
2933: oPushResult
2934: oSetResult 17
2936: oPushResult
2937: oNodeGetInt
2938: oPop 2
2940: oAssign
2941: oInput 15
2943: oGetAddrLocal 6
2945: oPushResult
2946: oGetLocal 3
2948: oAssign
2949: oGetLocal 1
2951: oPushResult
2952: oGetParam 1
2954: oPushResult
2955: oCall 2870
2957: oPop 2
2959: oGetLocal 6
2961: oPushResult
2962: oGetLocal 4
2964: oPushResult
2965: equal
2966: oPop 2
2968: oChoice 2976
2970: oJumpForward 3005
2972: oJumpForward 2982
2974: oJumpForward 2982
2976: Choice Lookup Table
           0   2974
           1   2970
2981: oEndChoice
2982: oInput 14
2984: oGetAddrParam 1
2986: oPushResult
2987: oGetParam 1
2989: oPushResult
2990: oGetLocal 5
2992: oPushResult
2993: add
2994: oPop 2
2996: oAssign
2997: oGetAddrLocal 6
2999: oPushResult
3000: inc
3001: oPop 1
3003: oJumpBack 2949
3005: oInput 16
3007: oJumpForward 3230
3009: oInput 15
3011: oGetAddrLocal 7
3013: oPushResult
3014: oGetParam 2
3016: oPushResult
3017: oSetResult 42
3019: oPushResult
3020: oNodeGet
3021: oPop 2
3023: oAssign
3024: oInputChoice 3028
3026: oJumpForward 3033
3028: Choice Lookup Table
           0   3026
3031: oJumpForward 3099
3033: oGetAddrLocal 8
3035: oPushResult
3036: oGetLocal 7
3038: oPushResult
3039: oScopeFindRequireInScope
3040: oPop 1
3042: oAssign
3043: oInput 13
3045: oGetAddrLocal 9
3047: oPushResult
3048: oGetLocal 8
3050: oPushResult
3051: oSetResult 21
3053: oPushResult
3054: oNodeGet
3055: oPop 2
3057: oAssign
3058: oGetAddrLocal 10
3060: oPushResult
3061: oGetParam 1
3063: oPushResult
3064: oGetLocal 8
3066: oPushResult
3067: oSetResult 22
3069: oPushResult
3070: oNodeGetInt
3071: oPop 2
3073: oPushResult
3074: add
3075: oPop 2
3077: oAssign
3078: oGetLocal 9
3080: oPushResult
3081: oGetLocal 10
3083: oPushResult
3084: oCall 2870
3086: oPop 2
3088: oInputChoice 3092
3090: oJumpForward 3097
3092: Choice Lookup Table
           6   3090
3095: oJumpForward 3099
3097: oJumpBack 3024
3099: oInput 16
3101: oJumpForward 3230
3103: oEmit 22
3105: oGetParam 1
3107: oPushResult
3108: oEmitInt
3109: oPop 1
3111: oGetParam 2
3113: oPushResult
3114: oTypeSPush
3115: oPop 1
3117: oCall 3586
3119: oCall 4478
3121: oEmit 20
3123: oValueTop
3124: oPushResult
3125: oEmitInt
3126: oPop 1
3128: oValuePop
3129: oTypeSPop
3130: oEmit 34
3132: oJumpForward 3230
3134: oEmit 22
3136: oGetParam 1
3138: oPushResult
3139: oEmitInt
3140: oPop 1
3142: oGetParam 2
3144: oPushResult
3145: oTypeSPush
3146: oPop 1
3148: oCall 3586
3150: oCall 4478
3152: oEmit 20
3154: oValueTop
3155: oPushResult
3156: oEmitInt
3157: oPop 1
3159: oValuePop
3160: oTypeSPop
3161: oEmit 33
3163: oJumpForward 3230
3165: oError 17
3167: oJumpForward 3230
3169: oEmit 22
3171: oGetParam 1
3173: oPushResult
3174: oEmitInt
3175: oPop 1
3177: oGetParam 2
3179: oPushResult
3180: oTypeSPush
3181: oPop 1
3183: oCall 3586
3185: oCall 4478
3187: oEmit 20
3189: oValueTop
3190: oPushResult
3191: oEmitInt
3192: oPop 1
3194: oValuePop
3195: oTypeSPop
3196: oEmit 35
3198: oJumpForward 3230
3200: oError 17
3202: oJumpForward 3230
3204: Choice Lookup Table
          29   3200
          43   3200
          38   3169
          37   3169
          33   3165
          44   3134
          31   3134
          36   3103
          30   3103
          34   3103
          41   3009
          39   2880
3229: oEndChoice
3230: oReturn
3231: oLocalSpace 2
3233: oInputChoice 3279
3235: oGetAddrLocal 1
3237: oPushResult
3238: oSetResult 20
3240: oPushResult
3241: LAST_ID
3242: oPushResult
3243: oCall 14972
3245: oPop 2
3247: oAssign
3248: oInput 7
3250: oGetAddrLocal 2
3252: oPushResult
3253: oCall 12940
3255: oPop 1
3257: oGetLocal 1
3259: oPushResult
3260: oSetResult 21
3262: oPushResult
3263: oGetLocal 2
3265: oPushResult
3266: oNodeSet
3267: oPop 3
3269: oGetLocal 1
3271: oPushResult
3272: oScopeDeclare
3273: oPop 1
3275: oInput 6
3277: oJumpForward 3284
3279: Choice Lookup Table
           0   3235
3282: oJumpForward 3286
3284: oJumpBack 3233
3286: oReturn
3287: oLocalSpace 6
3289: oInputChoice 3513
3291: oGetAddrLocal 1
3293: oPushResult
3294: oNodeVecNew
3295: oAssign
3296: oGetAddrLocal 2
3298: oPushResult
3299: oGetParam 1
3301: oPushResult
3302: LAST_ID
3303: oPushResult
3304: oCall 14972
3306: oPop 2
3308: oAssign
3309: oGetLocal 1
3311: oPushResult
3312: oGetLocal 2
3314: oPushResult
3315: oNodeVecAppend
3316: oPop 2
3318: oInputChoice 3324
3320: oInput 0
3322: oJumpForward 3329
3324: Choice Lookup Table
          14   3320
3327: oJumpForward 3331
3329: oJumpBack 3296
3331: oInput 13
3333: oGetAddrLocal 3
3335: oPushResult
3336: oCall 12940
3338: oPop 1
3340: oGetAddrLocal 4
3342: oPushResult
3343: oSetResult 0
3345: oAssign
3346: oGetLocal 4
3348: oPushResult
3349: oGetLocal 1
3351: oPushResult
3352: oNodeVecSize
3353: oPop 1
3355: oPushResult
3356: equal
3357: oPop 2
3359: oChoice 3400
3361: oGetAddrLocal 2
3363: oPushResult
3364: oGetLocal 1
3366: oPushResult
3367: oGetLocal 4
3369: oPushResult
3370: oNodeVecElement
3371: oPop 2
3373: oAssign
3374: oGetLocal 2
3376: oPushResult
3377: oSetResult 21
3379: oPushResult
3380: oGetLocal 3
3382: oPushResult
3383: oNodeSet
3384: oPop 3
3386: oGetLocal 2
3388: oPushResult
3389: oScopeDeclareAlloc
3390: oPop 1
3392: oGetAddrLocal 4
3394: oPushResult
3395: inc
3396: oPop 1
3398: oJumpForward 3405
3400: Choice Lookup Table
           0   3361
3403: oJumpForward 3407
3405: oJumpBack 3346
3407: oInputChoice 3500
3409: oGetLocal 1
3411: oPushResult
3412: oNodeVecSize
3413: oPop 1
3415: oChoice 3419
3417: oJumpForward 3424
3419: Choice Lookup Table
           1   3417
3422: oError 23
3424: oGetAddrLocal 5
3426: oPushResult
3427: oScopeCurrent
3428: oPushResult
3429: oCall 14870
3431: oPop 1
3433: oAssign
3434: oGetLocal 5
3436: oPushResult
3437: oCodePush
3438: oPop 1
3440: oGetAddrLocal 6
3442: oPushResult
3443: oSetResult 0
3445: oAssign
3446: oCall 14922
3448: oPushResult
3449: equal_zero
3450: oPop 1
3452: oChoice 3468
3454: oGetGlobal 3
3456: oPushResult
3457: oScopeEnter
3458: oPop 1
3460: oGetAddrLocal 6
3462: oPushResult
3463: oSetResult 1
3465: oAssign
3466: oJumpForward 3471
3468: Choice Lookup Table
           1   3454
3471: oGetLocal 2
3473: oPushResult
3474: oSetResult 1
3476: oPushResult
3477: oCall 10371
3479: oPop 2
3481: oCall 5047
3483: oCall 8815
3485: oCall 9919
3487: oGetLocal 6
3489: oChoice 3494
3491: oScopeEnd
3492: oJumpForward 3497
3494: Choice Lookup Table
           1   3491
3497: oCodePop
3498: oJumpForward 3503
3500: Choice Lookup Table
           7   3409
3503: oGetLocal 1
3505: oPushResult
3506: oNodeVecDelete
3507: oPop 1
3509: oInput 6
3511: oJumpForward 3518
3513: Choice Lookup Table
           0   3291
3516: oJumpForward 3520
3518: oJumpBack 3289
3520: oReturn
3521: oLocalSpace 2
3523: oInputChoice 3530
3525: oJumpForward 3536
3527: oChangeIntLitToLabelIdent
3528: oJumpForward 3536
3530: Choice Lookup Table
           1   3527
           0   3525
3535: oEndChoice
3536: oGetAddrLocal 1
3538: oPushResult
3539: oSetResult 27
3541: oPushResult
3542: LAST_ID
3543: oPushResult
3544: oCall 14972
3546: oPop 2
3548: oAssign
3549: oGetAddrLocal 2
3551: oPushResult
3552: oLabelNew
3553: oAssign
3554: oGetLocal 1
3556: oPushResult
3557: oSetResult 22
3559: oPushResult
3560: oGetLocal 2
3562: oPushResult
3563: oNodeSetLabel
3564: oPop 3
3566: oGetLocal 1
3568: oPushResult
3569: oScopeDeclare
3570: oPop 1
3572: oInputChoice 3576
3574: oJumpForward 3581
3576: Choice Lookup Table
          14   3574
3579: oJumpForward 3583
3581: oJumpBack 3523
3583: oInput 6
3585: oReturn
3586: oLocalSpace 0
3588: oCall 3843
3590: oInputChoice 3802
3592: oCall 3866
3594: oCall 4599
3596: oTypeSNodeType
3597: oChoice 3612
3599: oValueStringCmp
3600: oSetResult 0
3602: oPushResult
3603: oValuePush
3604: oPop 1
3606: oValueEqual
3607: oJumpForward 3618
3609: oValueEqualD
3610: oJumpForward 3618
3612: Choice Lookup Table
          33   3609
          42   3599
3617: oValueEqual
3618: oTypeSPop
3619: oGetGlobal 7
3621: oPushResult
3622: oTypeSPush
3623: oPop 1
3625: oJumpForward 3817
3627: oCall 3843
3629: oCall 4599
3631: oTypeSNodeType
3632: oChoice 3647
3634: oValueStringCmp
3635: oSetResult 0
3637: oPushResult
3638: oValuePush
3639: oPop 1
3641: oValueNotEqual
3642: oJumpForward 3653
3644: oValueNotEqualD
3645: oJumpForward 3653
3647: Choice Lookup Table
          33   3644
          42   3634
3652: oValueNotEqual
3653: oTypeSPop
3654: oGetGlobal 7
3656: oPushResult
3657: oTypeSPush
3658: oPop 1
3660: oJumpForward 3817
3662: oCall 3843
3664: oCall 4599
3666: oTypeSNodeType
3667: oChoice 3682
3669: oValueStringCmp
3670: oSetResult 0
3672: oPushResult
3673: oValuePush
3674: oPop 1
3676: oValueLess
3677: oJumpForward 3688
3679: oValueLessD
3680: oJumpForward 3688
3682: Choice Lookup Table
          33   3679
          42   3669
3687: oValueLess
3688: oTypeSPop
3689: oGetGlobal 7
3691: oPushResult
3692: oTypeSPush
3693: oPop 1
3695: oJumpForward 3817
3697: oCall 3843
3699: oCall 4599
3701: oTypeSNodeType
3702: oChoice 3717
3704: oValueStringCmp
3705: oSetResult 0
3707: oPushResult
3708: oValuePush
3709: oPop 1
3711: oValueGreater
3712: oJumpForward 3723
3714: oValueGreaterD
3715: oJumpForward 3723
3717: Choice Lookup Table
          33   3714
          42   3704
3722: oValueGreater
3723: oTypeSPop
3724: oGetGlobal 7
3726: oPushResult
3727: oTypeSPush
3728: oPop 1
3730: oJumpForward 3817
3732: oCall 3843
3734: oCall 4599
3736: oTypeSNodeType
3737: oChoice 3752
3739: oValueStringCmp
3740: oSetResult 0
3742: oPushResult
3743: oValuePush
3744: oPop 1
3746: oValueLessEqual
3747: oJumpForward 3758
3749: oValueLessEqualD
3750: oJumpForward 3758
3752: Choice Lookup Table
          33   3749
          42   3739
3757: oValueLessEqual
3758: oTypeSPop
3759: oGetGlobal 7
3761: oPushResult
3762: oTypeSPush
3763: oPop 1
3765: oJumpForward 3817
3767: oCall 3843
3769: oCall 4599
3771: oTypeSNodeType
3772: oChoice 3787
3774: oValueStringCmp
3775: oSetResult 0
3777: oPushResult
3778: oValuePush
3779: oPop 1
3781: oValueGreaterEqual
3782: oJumpForward 3793
3784: oValueGreaterEqualD
3785: oJumpForward 3793
3787: Choice Lookup Table
          33   3784
          42   3774
3792: oValueGreaterEqual
3793: oTypeSPop
3794: oGetGlobal 7
3796: oPushResult
3797: oTypeSPush
3798: oPop 1
3800: oJumpForward 3817
3802: Choice Lookup Table
          12   3767
          11   3732
          10   3697
           9   3662
           8   3627
           7   3592
3815: oJumpForward 3819
3817: oJumpBack 3590
3819: oReturn
3820: oLocalSpace 1
3822: oGetAddrLocal 1
3824: oPushResult
3825: oGetGlobal 25
3827: oAssign
3828: oGetAddrGlobal 25
3830: oPushResult
3831: oSetResult 1
3833: oAssign
3834: oCall 3586
3836: oGetAddrGlobal 25
3838: oPushResult
3839: oGetLocal 1
3841: oAssign
3842: oReturn
3843: oLocalSpace 0
3845: oCall 3866
3847: oInputChoice 3858
3849: oCall 4368
3851: oCall 3866
3853: oCall 4354
3855: oValueOr
3856: oJumpForward 3863
3858: Choice Lookup Table
          58   3849
3861: oJumpForward 3865
3863: oJumpBack 3847
3865: oReturn
3866: oLocalSpace 0
3868: oCall 3889
3870: oInputChoice 3881
3872: oCall 4368
3874: oCall 3889
3876: oCall 4354
3878: oValueAnd
3879: oJumpForward 3886
3881: Choice Lookup Table
          57   3872
3884: oJumpForward 3888
3886: oJumpBack 3870
3888: oReturn
3889: oLocalSpace 0
3891: oInputChoice 3900
3893: oCall 3889
3895: oCall 4368
3897: oValueNot
3898: oJumpForward 3905
3900: Choice Lookup Table
          59   3893
3903: oCall 3906
3905: oReturn
3906: oLocalSpace 0
3908: oCall 3965
3910: oInputChoice 3955
3912: oCall 3965
3914: oCall 4599
3916: oTypeSNodeType
3917: oChoice 3925
3919: oValueStringConcat
3920: oJumpForward 3931
3922: oValueAddD
3923: oJumpForward 3931
3925: Choice Lookup Table
          33   3922
          42   3919
3930: oValueAdd
3931: oJumpForward 3962
3933: oCall 3965
3935: oCall 4599
3937: oTypeSNodeType
3938: oChoice 3947
3940: oError 18
3942: oJumpForward 3953
3944: oValueSubD
3945: oJumpForward 3953
3947: Choice Lookup Table
          33   3944
          42   3940
3952: oValueSub
3953: oJumpForward 3962
3955: Choice Lookup Table
          26   3933
          25   3912
3960: oJumpForward 3964
3962: oJumpBack 3910
3964: oReturn
3965: oLocalSpace 0
3967: oCall 4025
3969: oInputChoice 4015
3971: oCall 4025
3973: oCall 4599
3975: oTypeSNodeType
3976: oChoice 3985
3978: oError 18
3980: oJumpForward 3991
3982: oValueMultD
3983: oJumpForward 3991
3985: Choice Lookup Table
          33   3982
          42   3978
3990: oValueMult
3991: oJumpForward 4022
3993: oCall 4025
3995: oCall 4599
3997: oTypeSNodeType
3998: oChoice 4007
4000: oError 18
4002: oJumpForward 4013
4004: oValueDivD
4005: oJumpForward 4013
4007: Choice Lookup Table
          33   4004
          42   4000
4012: oValueDiv
4013: oJumpForward 4022
4015: Choice Lookup Table
          24   3993
          23   3971
4020: oJumpForward 4024
4022: oJumpBack 3969
4024: oReturn
4025: oLocalSpace 0
4027: oInputChoice 4053
4029: oCall 4061
4031: oJumpForward 4060
4033: oCall 4061
4035: oTypeSNodeType
4036: oChoice 4045
4038: oError 18
4040: oJumpForward 4051
4042: oValueNegateD
4043: oJumpForward 4051
4045: Choice Lookup Table
          33   4042
          42   4038
4050: oValueNegate
4051: oJumpForward 4060
4053: Choice Lookup Table
          26   4033
          25   4029
4058: oCall 4061
4060: oReturn
4061: oLocalSpace 1
4063: oInputChoice 4324
4065: TOKEN_VALUE
4066: oPushResult
4067: oValuePush
4068: oPop 1
4070: oGetGlobal 6
4072: oPushResult
4073: oTypeSPush
4074: oPop 1
4076: oJumpForward 4353
4078: TOKEN_VALUE
4079: oPushResult
4080: oValuePush
4081: oPop 1
4083: oGetGlobal 9
4085: oPushResult
4086: oTypeSPush
4087: oPop 1
4089: oJumpForward 4353
4091: TOKEN_VALUE_DOUBLE
4092: oPushResult
4093: oValuePushDouble
4094: oPop 1
4096: oGetGlobal 13
4098: oPushResult
4099: oTypeSPush
4100: oPop 1
4102: oJumpForward 4353
4104: CURRENT_STRLIT
4105: oPushResult
4106: oValuePushString
4107: oPop 1
4109: oGetGlobal 15
4111: oPushResult
4112: oTypeSPush
4113: oPop 1
4115: oJumpForward 4353
4117: oCall 3586
4119: oInput 16
4121: oJumpForward 4353
4123: oGetAddrLocal 1
4125: oPushResult
4126: oScopeFindRequire
4127: oAssign
4128: oGetAddrLocal 1
4130: oPushResult
4131: oCall 244
4133: oPop 1
4135: oGetLocal 1
4137: oPushResult
4138: oNodeType
4139: oPop 1
4141: oChoice 4281
4143: oGetLocal 1
4145: oPushResult
4146: oCall 4781
4148: oPop 1
4150: oJumpForward 4306
4152: oGetLocal 1
4154: oPushResult
4155: oSetResult 22
4157: oPushResult
4158: oNodeGetInt
4159: oPop 2
4161: oPushResult
4162: oValuePush
4163: oPop 1
4165: oGetLocal 1
4167: oPushResult
4168: oSetResult 21
4170: oPushResult
4171: oNodeGet
4172: oPop 2
4174: oPushResult
4175: oTypeSPush
4176: oPop 1
4178: oJumpForward 4306
4180: oGetLocal 1
4182: oPushResult
4183: oSetResult 33
4185: oPushResult
4186: oNodeGetString
4187: oPop 2
4189: oPushResult
4190: oValuePushString
4191: oPop 1
4193: oGetLocal 1
4195: oPushResult
4196: oSetResult 21
4198: oPushResult
4199: oNodeGet
4200: oPop 2
4202: oPushResult
4203: oTypeSPush
4204: oPop 1
4206: oJumpForward 4306
4208: oGetLocal 1
4210: oPushResult
4211: oSetResult 22
4213: oPushResult
4214: oNodeGetInt
4215: oPop 2
4217: oPushResult
4218: oValuePush
4219: oPop 1
4221: oGetLocal 1
4223: oPushResult
4224: oSetResult 21
4226: oPushResult
4227: oNodeGet
4228: oPop 2
4230: oPushResult
4231: oTypeSPush
4232: oPop 1
4234: oJumpForward 4306
4236: oGetLocal 1
4238: oPushResult
4239: oSetResult 21
4241: oPushResult
4242: oNodeGet
4243: oPop 2
4245: oPushResult
4246: oTypeSPush
4247: oPop 1
4249: oInputChoice 4259
4251: oCall 3586
4253: oInput 16
4255: oCall 4604
4257: oJumpForward 4279
4259: Choice Lookup Table
          15   4251
4262: oGetGlobal 25
4264: oChoice 4274
4266: oSetResult 0
4268: oPushResult
4269: oValuePush
4270: oPop 1
4272: oJumpForward 4279
4274: Choice Lookup Table
           1   4266
4277: oError 33
4279: oJumpForward 4306
4281: Choice Lookup Table
          20   4236
          17   4208
          18   4180
          16   4152
          14   4143
4292: oError 1
4294: oSetResult 0
4296: oPushResult
4297: oValuePush
4298: oPop 1
4300: oGetGlobal 6
4302: oPushResult
4303: oTypeSPush
4304: oPop 1
4306: oJumpForward 4353
4308: oError 17
4310: oSetResult 0
4312: oPushResult
4313: oValuePush
4314: oPop 1
4316: oGetGlobal 14
4318: oPushResult
4319: oTypeSPush
4320: oPop 1
4322: oJumpForward 4353
4324: Choice Lookup Table
          20   4308
           0   4123
          15   4117
           3   4104
           2   4091
           4   4078
           1   4065
4339: oError 1
4341: oSetResult 0
4343: oPushResult
4344: oValuePush
4345: oPop 1
4347: oGetGlobal 6
4349: oPushResult
4350: oTypeSPush
4351: oPop 1
4353: oReturn
4354: oLocalSpace 0
4356: oTypeSNodeType
4357: oChoice 4361
4359: oJumpForward 4366
4361: Choice Lookup Table
          34   4359
4364: oError 8
4366: oTypeSPop
4367: oReturn
4368: oLocalSpace 0
4370: oTypeSNodeType
4371: oChoice 4375
4373: oJumpForward 4380
4375: Choice Lookup Table
          34   4373
4378: oError 8
4380: oReturn
4381: oLocalSpace 1
4383: oGetAddrLocal 1
4385: oPushResult
4386: oTypeSNodeType
4387: oAssign
4388: oTypeSPop
4389: oGetLocal 1
4391: oPushResult
4392: oTypeSNodeType
4393: oPushResult
4394: equal_node_type
4395: oPop 2
4397: oChoice 4474
4399: oTypeSNodeType
4400: oChoice 4461
4402: oGetLocal 1
4404: oChoice 4409
4406: oReturn
4407: oJumpForward 4412
4409: Choice Lookup Table
          38   4406
4412: oJumpForward 4470
4414: oGetLocal 1
4416: oChoice 4421
4418: oReturn
4419: oJumpForward 4424
4421: Choice Lookup Table
          37   4418
4424: oJumpForward 4470
4426: oGetLocal 1
4428: oChoice 4434
4430: oValueCharToString
4431: oReturn
4432: oJumpForward 4437
4434: Choice Lookup Table
          36   4430
4437: oJumpForward 4470
4439: oGetLocal 1
4441: oChoice 4456
4443: oValueSwap
4444: oValueCharToString
4445: oValueSwap
4446: oTypeSPop
4447: oGetGlobal 15
4449: oPushResult
4450: oTypeSPush
4451: oPop 1
4453: oReturn
4454: oJumpForward 4459
4456: Choice Lookup Table
          42   4443
4459: oJumpForward 4470
4461: Choice Lookup Table
          36   4439
          42   4426
          38   4414
          37   4402
4470: oError 15
4472: oJumpForward 4477
4474: Choice Lookup Table
           0   4399
4477: oReturn
4478: oLocalSpace 1
4480: oGetAddrLocal 1
4482: oPushResult
4483: oTypeSNodeType
4484: oAssign
4485: oTypeSPop
4486: oGetLocal 1
4488: oPushResult
4489: oTypeSNodeType
4490: oPushResult
4491: equal_node_type
4492: oPop 2
4494: oChoice 4595
4496: oTypeSNodeType
4497: oChoice 4578
4499: oGetLocal 1
4501: oChoice 4506
4503: oReturn
4504: oJumpForward 4509
4506: Choice Lookup Table
          30   4503
4509: oJumpForward 4591
4511: oGetLocal 1
4513: oChoice 4518
4515: oReturn
4516: oJumpForward 4521
4518: Choice Lookup Table
          31   4515
4521: oJumpForward 4591
4523: oGetLocal 1
4525: oChoice 4530
4527: oReturn
4528: oJumpForward 4533
4530: Choice Lookup Table
          38   4527
4533: oJumpForward 4591
4535: oGetLocal 1
4537: oChoice 4542
4539: oReturn
4540: oJumpForward 4545
4542: Choice Lookup Table
          37   4539
4545: oJumpForward 4591
4547: oGetLocal 1
4549: oChoice 4555
4551: oValueCharToString
4552: oReturn
4553: oJumpForward 4558
4555: Choice Lookup Table
          36   4551
4558: oJumpForward 4591
4560: oGetLocal 1
4562: oChoice 4571
4564: oReturn
4565: oJumpForward 4576
4567: oValueCharToString
4568: oReturn
4569: oJumpForward 4576
4571: Choice Lookup Table
          36   4567
          42   4564
4576: oJumpForward 4591
4578: Choice Lookup Table
          43   4560
          42   4547
          38   4535
          37   4523
          30   4511
          31   4499
4591: oError 15
4593: oJumpForward 4598
4595: Choice Lookup Table
           0   4496
4598: oReturn
4599: oLocalSpace 0
4601: oCall 4381
4603: oReturn
4604: oLocalSpace 1
4606: oGetAddrLocal 1
4608: oPushResult
4609: oTypeSNodeType
4610: oAssign
4611: oTypeSPop
4612: oGetLocal 1
4614: oPushResult
4615: oTypeSNodeType
4616: oPushResult
4617: equal_node_type
4618: oPop 2
4620: oChoice 4777
4622: oTypeSNodeType
4623: oChoice 4752
4625: oGetLocal 1
4627: oChoice 4635
4629: oReturn
4630: oJumpForward 4646
4632: oReturn
4633: oJumpForward 4646
4635: Choice Lookup Table
          44   4632
          31   4632
          34   4629
          36   4629
          30   4629
4646: oJumpForward 4773
4648: oGetLocal 1
4650: oChoice 4658
4652: oReturn
4653: oJumpForward 4669
4655: oReturn
4656: oJumpForward 4669
4658: Choice Lookup Table
          44   4655
          31   4655
          34   4652
          36   4652
          30   4652
4669: oJumpForward 4773
4671: oGetLocal 1
4673: oChoice 4682
4675: oValueIntToDouble
4676: oReturn
4677: oJumpForward 4695
4679: oReturn
4680: oJumpForward 4695
4682: Choice Lookup Table
          33   4679
          44   4675
          31   4675
          34   4675
          36   4675
          30   4675
4695: oJumpForward 4773
4697: oGetLocal 1
4699: oChoice 4704
4701: oReturn
4702: oJumpForward 4707
4704: Choice Lookup Table
          38   4701
4707: oJumpForward 4773
4709: oGetLocal 1
4711: oChoice 4716
4713: oReturn
4714: oJumpForward 4719
4716: Choice Lookup Table
          37   4713
4719: oJumpForward 4773
4721: oGetLocal 1
4723: oChoice 4729
4725: oValueCharToString
4726: oReturn
4727: oJumpForward 4732
4729: Choice Lookup Table
          36   4725
4732: oJumpForward 4773
4734: oGetLocal 1
4736: oChoice 4745
4738: oReturn
4739: oJumpForward 4750
4741: oValueCharToString
4742: oReturn
4743: oJumpForward 4750
4745: Choice Lookup Table
          36   4741
          42   4738
4750: oJumpForward 4773
4752: Choice Lookup Table
          43   4734
          42   4721
          38   4709
          37   4697
          33   4671
          34   4648
          36   4648
          30   4648
          44   4625
          31   4625
4773: oError 15
4775: oJumpForward 4780
4777: Choice Lookup Table
           0   4622
4780: oReturn
4781: oLocalSpace 1
4783: oGetParam 1
4785: oPushResult
4786: oGetGlobal 17
4788: oPushResult
4789: oNodeEqual
4790: oPop 2
4792: oChoice 4832
4794: oInput 15
4796: oCall 3586
4798: oInput 16
4800: oTypeSNodeType
4801: oChoice 4807
4803: oJumpForward 4820
4805: oJumpForward 4820
4807: Choice Lookup Table
          36   4805
          30   4805
          34   4805
          44   4803
          31   4803
4818: oError 15
4820: oTypeSPop
4821: oGetGlobal 6
4823: oPushResult
4824: oTypeSPush
4825: oPop 1
4827: oInput 16
4829: oReturn
4830: oJumpForward 4835
4832: Choice Lookup Table
           1   4794
4835: oGetParam 1
4837: oPushResult
4838: oGetGlobal 18
4840: oPushResult
4841: oNodeEqual
4842: oPop 2
4844: oChoice 4878
4846: oInput 15
4848: oCall 3586
4850: oInput 16
4852: oTypeSNodeType
4853: oChoice 4859
4855: oJumpForward 4866
4857: oJumpForward 4866
4859: Choice Lookup Table
          30   4857
          31   4855
4864: oError 15
4866: oTypeSPop
4867: oGetGlobal 9
4869: oPushResult
4870: oTypeSPush
4871: oPop 1
4873: oInput 16
4875: oReturn
4876: oJumpForward 4881
4878: Choice Lookup Table
           1   4846
4881: oGetParam 1
4883: oPushResult
4884: oGetGlobal 19
4886: oPushResult
4887: oNodeEqual
4888: oPop 2
4890: oChoice 4935
4892: oInput 15
4894: oCall 3586
4896: oTypeSNodeType
4897: oChoice 4918
4899: oTypeSTop
4900: oPushResult
4901: oSetResult 45
4903: oPushResult
4904: oNodeGetBoolean
4905: oPop 2
4907: oChoice 4913
4909: oError 30
4911: oJumpForward 4916
4913: Choice Lookup Table
           1   4909
4916: oJumpForward 4923
4918: Choice Lookup Table
          44   4899
4921: oError 15
4923: oSetResult 1
4925: oPushResult
4926: oValuePush
4927: oPop 1
4929: oValueSub
4930: oInput 16
4932: oReturn
4933: oJumpForward 4938
4935: Choice Lookup Table
           1   4892
4938: oGetParam 1
4940: oPushResult
4941: oGetGlobal 20
4943: oPushResult
4944: oNodeEqual
4945: oPop 2
4947: oChoice 4992
4949: oInput 15
4951: oCall 3586
4953: oTypeSNodeType
4954: oChoice 4975
4956: oTypeSTop
4957: oPushResult
4958: oSetResult 45
4960: oPushResult
4961: oNodeGetBoolean
4962: oPop 2
4964: oChoice 4970
4966: oError 30
4968: oJumpForward 4973
4970: Choice Lookup Table
           1   4966
4973: oJumpForward 4980
4975: Choice Lookup Table
          44   4956
4978: oError 15
4980: oSetResult 1
4982: oPushResult
4983: oValuePush
4984: oPop 1
4986: oValueAdd
4987: oInput 16
4989: oReturn
4990: oJumpForward 4995
4992: Choice Lookup Table
           1   4949
4995: oGetParam 1
4997: oPushResult
4998: oGetGlobal 21
5000: oPushResult
5001: oNodeEqual
5002: oPop 2
5004: oChoice 5041
5006: oInput 15
5008: oCall 3820
5010: oValuePop
5011: oGetAddrLocal 1
5013: oPushResult
5014: oTypeSTop
5015: oAssign
5016: oTypeSPop
5017: oGetLocal 1
5019: oPushResult
5020: oSetResult 17
5022: oPushResult
5023: oNodeGetInt
5024: oPop 2
5026: oPushResult
5027: oValuePush
5028: oPop 1
5030: oGetGlobal 6
5032: oPushResult
5033: oTypeSPush
5034: oPop 1
5036: oInput 16
5038: oReturn
5039: oJumpForward 5044
5041: Choice Lookup Table
           1   5006
5044: oError 17
5046: oReturn
5047: oLocalSpace 1
5049: oGetAddrLocal 1
5051: oPushResult
5052: oSetResult 0
5054: oAssign
5055: oGetAddrLocal 1
5057: oPushResult
5058: oCall 5231
5060: oPop 1
5062: oGetAddrLocal 1
5064: oPushResult
5065: oCall 5131
5067: oPop 1
5069: oReturn
5070: oLocalSpace 1
5072: oGetAddrLocal 1
5074: oPushResult
5075: oGetGlobal 25
5077: oAssign
5078: oGetAddrGlobal 25
5080: oPushResult
5081: oSetResult 1
5083: oAssign
5084: oCall 5047
5086: oGetAddrGlobal 25
5088: oPushResult
5089: oGetLocal 1
5091: oAssign
5092: oReturn
5093: oLocalSpace 0
5095: oGetParam 1
5097: oPushResult
5098: oCall 5231
5100: oPop 1
5102: oTypeSNodeType
5103: oChoice 5122
5105: oJumpForward 5129
5107: oGetParam 1
5109: oPushResult
5110: oLabelNew
5111: oAssign
5112: oEmit 90
5114: oGetFromParam 1
5116: oPushResult
5117: oEmitLabel
5118: oPop 1
5120: oJumpForward 5129
5122: Choice Lookup Table
          34   5107
          35   5105
5127: oError 8
5129: oTypeSPop
5130: oReturn
5131: oLocalSpace 1
5133: oTypeSNodeType
5134: oChoice 5196
5136: oGetAddrLocal 1
5138: oPushResult
5139: oLabelNew
5140: oAssign
5141: oEmit 20
5143: oSetResult 1
5145: oPushResult
5146: oEmitInt
5147: oPop 1
5149: oEmit 88
5151: oGetLocal 1
5153: oPushResult
5154: oEmitLabel
5155: oPop 1
5157: oEmit 97
5159: oGetFromParam 1
5161: oPushResult
5162: oEmitLabel
5163: oPop 1
5165: oEmit 20
5167: oSetResult 0
5169: oPushResult
5170: oEmitInt
5171: oPop 1
5173: oEmit 97
5175: oGetLocal 1
5177: oPushResult
5178: oEmitLabel
5179: oPop 1
5181: oTypeSPop
5182: oGetGlobal 7
5184: oPushResult
5185: oTypeSPush
5186: oPop 1
5188: oGetParam 1
5190: oPushResult
5191: oSetResult 0
5193: oAssign
5194: oJumpForward 5199
5196: Choice Lookup Table
          35   5136
5199: oReturn
5200: oLocalSpace 0
5202: oTypeSNodeType
5203: oChoice 5227
5205: oGetParam 1
5207: oPushResult
5208: oLabelNew
5209: oAssign
5210: oEmit 90
5212: oGetFromParam 1
5214: oPushResult
5215: oEmitLabel
5216: oPop 1
5218: oTypeSPop
5219: oGetGlobal 8
5221: oPushResult
5222: oTypeSPush
5223: oPop 1
5225: oJumpForward 5230
5227: Choice Lookup Table
          34   5205
5230: oReturn
5231: oLocalSpace 0
5233: oGetParam 1
5235: oPushResult
5236: oCall 5800
5238: oPop 1
5240: oInputChoice 5782
5242: oGetParam 1
5244: oPushResult
5245: oCall 5131
5247: oPop 1
5249: oCall 9584
5251: oGetParam 1
5253: oPushResult
5254: oCall 5800
5256: oPop 1
5258: oGetParam 1
5260: oPushResult
5261: oCall 5131
5263: oPop 1
5265: oCall 9584
5267: oCall 8988
5269: oTypeSNodeType
5270: oChoice 5302
5272: oEmit 57
5274: oJumpForward 5323
5276: oEmit 63
5278: oJumpForward 5323
5280: oEmit 75
5282: oJumpForward 5323
5284: oEmit 69
5286: oJumpForward 5323
5288: oCall 11854
5290: oEmit 20
5292: oSetResult 0
5294: oPushResult
5295: oEmitInt
5296: oPop 1
5298: oEmit 63
5300: oJumpForward 5323
5302: Choice Lookup Table
          42   5288
          43   5288
          38   5284
          37   5284
          33   5280
          44   5276
          31   5276
          36   5272
          34   5272
5321: oError 18
5323: oTypeSPop
5324: oGetGlobal 7
5326: oPushResult
5327: oTypeSPush
5328: oPop 1
5330: oJumpForward 5797
5332: oGetParam 1
5334: oPushResult
5335: oCall 5131
5337: oPop 1
5339: oCall 9584
5341: oGetParam 1
5343: oPushResult
5344: oCall 5800
5346: oPop 1
5348: oGetParam 1
5350: oPushResult
5351: oCall 5131
5353: oPop 1
5355: oCall 9584
5357: oCall 8988
5359: oTypeSNodeType
5360: oChoice 5392
5362: oEmit 58
5364: oJumpForward 5413
5366: oEmit 64
5368: oJumpForward 5413
5370: oEmit 76
5372: oJumpForward 5413
5374: oEmit 70
5376: oJumpForward 5413
5378: oCall 11854
5380: oEmit 20
5382: oSetResult 0
5384: oPushResult
5385: oEmitInt
5386: oPop 1
5388: oEmit 64
5390: oJumpForward 5413
5392: Choice Lookup Table
          42   5378
          43   5378
          38   5374
          37   5374
          33   5370
          44   5366
          31   5366
          36   5362
          34   5362
5411: oError 18
5413: oTypeSPop
5414: oGetGlobal 7
5416: oPushResult
5417: oTypeSPush
5418: oPop 1
5420: oJumpForward 5797
5422: oGetParam 1
5424: oPushResult
5425: oCall 5131
5427: oPop 1
5429: oCall 9584
5431: oGetParam 1
5433: oPushResult
5434: oCall 5800
5436: oPop 1
5438: oGetParam 1
5440: oPushResult
5441: oCall 5131
5443: oPop 1
5445: oCall 9584
5447: oCall 8988
5449: oTypeSNodeType
5450: oChoice 5482
5452: oEmit 60
5454: oJumpForward 5503
5456: oEmit 66
5458: oJumpForward 5503
5460: oEmit 78
5462: oJumpForward 5503
5464: oEmit 72
5466: oJumpForward 5503
5468: oCall 11854
5470: oEmit 20
5472: oSetResult 0
5474: oPushResult
5475: oEmitInt
5476: oPop 1
5478: oEmit 66
5480: oJumpForward 5503
5482: Choice Lookup Table
          42   5468
          43   5468
          38   5464
          37   5464
          33   5460
          44   5456
          31   5456
          36   5452
          34   5452
5501: oError 18
5503: oTypeSPop
5504: oGetGlobal 7
5506: oPushResult
5507: oTypeSPush
5508: oPop 1
5510: oJumpForward 5797
5512: oGetParam 1
5514: oPushResult
5515: oCall 5131
5517: oPop 1
5519: oCall 9584
5521: oGetParam 1
5523: oPushResult
5524: oCall 5800
5526: oPop 1
5528: oGetParam 1
5530: oPushResult
5531: oCall 5131
5533: oPop 1
5535: oCall 9584
5537: oCall 8988
5539: oTypeSNodeType
5540: oChoice 5572
5542: oEmit 59
5544: oJumpForward 5593
5546: oEmit 65
5548: oJumpForward 5593
5550: oEmit 77
5552: oJumpForward 5593
5554: oEmit 71
5556: oJumpForward 5593
5558: oCall 11854
5560: oEmit 20
5562: oSetResult 0
5564: oPushResult
5565: oEmitInt
5566: oPop 1
5568: oEmit 65
5570: oJumpForward 5593
5572: Choice Lookup Table
          42   5558
          43   5558
          38   5554
          37   5554
          33   5550
          44   5546
          31   5546
          36   5542
          34   5542
5591: oError 18
5593: oTypeSPop
5594: oGetGlobal 7
5596: oPushResult
5597: oTypeSPush
5598: oPop 1
5600: oJumpForward 5797
5602: oGetParam 1
5604: oPushResult
5605: oCall 5131
5607: oPop 1
5609: oCall 9584
5611: oGetParam 1
5613: oPushResult
5614: oCall 5800
5616: oPop 1
5618: oGetParam 1
5620: oPushResult
5621: oCall 5131
5623: oPop 1
5625: oCall 9584
5627: oCall 8988
5629: oTypeSNodeType
5630: oChoice 5662
5632: oEmit 62
5634: oJumpForward 5683
5636: oEmit 68
5638: oJumpForward 5683
5640: oEmit 80
5642: oJumpForward 5683
5644: oEmit 74
5646: oJumpForward 5683
5648: oCall 11854
5650: oEmit 20
5652: oSetResult 0
5654: oPushResult
5655: oEmitInt
5656: oPop 1
5658: oEmit 68
5660: oJumpForward 5683
5662: Choice Lookup Table
          42   5648
          43   5648
          38   5644
          37   5644
          33   5640
          44   5636
          31   5636
          36   5632
          34   5632
5681: oError 18
5683: oTypeSPop
5684: oGetGlobal 7
5686: oPushResult
5687: oTypeSPush
5688: oPop 1
5690: oJumpForward 5797
5692: oGetParam 1
5694: oPushResult
5695: oCall 5131
5697: oPop 1
5699: oCall 9584
5701: oGetParam 1
5703: oPushResult
5704: oCall 5800
5706: oPop 1
5708: oGetParam 1
5710: oPushResult
5711: oCall 5131
5713: oPop 1
5715: oCall 9584
5717: oCall 8988
5719: oTypeSNodeType
5720: oChoice 5752
5722: oEmit 61
5724: oJumpForward 5773
5726: oEmit 67
5728: oJumpForward 5773
5730: oEmit 79
5732: oJumpForward 5773
5734: oEmit 73
5736: oJumpForward 5773
5738: oCall 11854
5740: oEmit 20
5742: oSetResult 0
5744: oPushResult
5745: oEmitInt
5746: oPop 1
5748: oEmit 67
5750: oJumpForward 5773
5752: Choice Lookup Table
          42   5738
          43   5738
          38   5734
          37   5734
          33   5730
          44   5726
          31   5726
          36   5722
          34   5722
5771: oError 18
5773: oTypeSPop
5774: oGetGlobal 7
5776: oPushResult
5777: oTypeSPush
5778: oPop 1
5780: oJumpForward 5797
5782: Choice Lookup Table
          12   5692
          11   5602
          10   5512
           9   5422
           8   5332
           7   5242
5795: oJumpForward 5799
5797: oJumpBack 5240
5799: oReturn
5800: oLocalSpace 1
5802: oGetAddrLocal 1
5804: oPushResult
5805: oSetResult 0
5807: oAssign
5808: oGetParam 1
5810: oPushResult
5811: oCall 5980
5813: oPop 1
5815: oInputChoice 5948
5817: oTypeSNodeType
5818: oChoice 5889
5820: oGetLocal 1
5822: oPushResult
5823: oSetResult 0
5825: oPushResult
5826: equal_label
5827: oPop 2
5829: oChoice 5838
5831: oGetAddrLocal 1
5833: oPushResult
5834: oLabelNew
5835: oAssign
5836: oJumpForward 5841
5838: Choice Lookup Table
           1   5831
5841: oEmit 88
5843: oGetLocal 1
5845: oPushResult
5846: oEmitLabel
5847: oPop 1
5849: oJumpForward 5896
5851: oGetParam 1
5853: oPushResult
5854: oCall 5200
5856: oPop 1
5858: oGetLocal 1
5860: oPushResult
5861: oSetResult 0
5863: oPushResult
5864: equal_label
5865: oPop 2
5867: oChoice 5876
5869: oGetAddrLocal 1
5871: oPushResult
5872: oLabelNew
5873: oAssign
5874: oJumpForward 5879
5876: Choice Lookup Table
           1   5869
5879: oEmit 88
5881: oGetLocal 1
5883: oPushResult
5884: oEmitLabel
5885: oPop 1
5887: oJumpForward 5896
5889: Choice Lookup Table
          34   5851
          35   5820
5894: oError 8
5896: oTypeSPop
5897: oEmit 97
5899: oGetFromParam 1
5901: oPushResult
5902: oEmitLabel
5903: oPop 1
5905: oGetParam 1
5907: oPushResult
5908: oSetResult 0
5910: oAssign
5911: oGetParam 1
5913: oPushResult
5914: oCall 5980
5916: oPop 1
5918: oTypeSNodeType
5919: oChoice 5932
5921: oJumpForward 5939
5923: oGetParam 1
5925: oPushResult
5926: oCall 5200
5928: oPop 1
5930: oJumpForward 5939
5932: Choice Lookup Table
          34   5923
          35   5921
5937: oError 8
5939: oTypeSPop
5940: oGetGlobal 8
5942: oPushResult
5943: oTypeSPush
5944: oPop 1
5946: oJumpForward 5953
5948: Choice Lookup Table
          58   5817
5951: oJumpForward 5955
5953: oJumpBack 5815
5955: oGetLocal 1
5957: oPushResult
5958: oSetResult 0
5960: oPushResult
5961: equal_label
5962: oPop 2
5964: oChoice 5976
5966: oEmit 97
5968: oGetLocal 1
5970: oPushResult
5971: oEmitLabel
5972: oPop 1
5974: oJumpForward 5979
5976: Choice Lookup Table
           0   5966
5979: oReturn
5980: oLocalSpace 2
5982: oGetAddrLocal 1
5984: oPushResult
5985: oSetResult 0
5987: oAssign
5988: oGetParam 1
5990: oPushResult
5991: oCall 6118
5993: oPop 1
5995: oInputChoice 6110
5997: oTypeSNodeType
5998: oChoice 6011
6000: oJumpForward 6018
6002: oGetParam 1
6004: oPushResult
6005: oCall 5200
6007: oPop 1
6009: oJumpForward 6018
6011: Choice Lookup Table
          34   6002
          35   6000
6016: oError 8
6018: oTypeSPop
6019: oGetLocal 1
6021: oPushResult
6022: oSetResult 0
6024: oPushResult
6025: equal_label
6026: oPop 2
6028: oChoice 6057
6030: oGetAddrLocal 1
6032: oPushResult
6033: oLabelNew
6034: oAssign
6035: oEmit 98
6037: oGetFromParam 1
6039: oPushResult
6040: oEmitLabel
6041: oPop 1
6043: oGetLocal 1
6045: oPushResult
6046: oEmitLabel
6047: oPop 1
6049: oGetParam 1
6051: oPushResult
6052: oGetLocal 1
6054: oAssign
6055: oJumpForward 6060
6057: Choice Lookup Table
           1   6030
6060: oGetAddrLocal 2
6062: oPushResult
6063: oSetResult 0
6065: oAssign
6066: oGetAddrLocal 2
6068: oPushResult
6069: oCall 6118
6071: oPop 1
6073: oTypeSNodeType
6074: oChoice 6087
6076: oJumpForward 6094
6078: oGetAddrLocal 2
6080: oPushResult
6081: oCall 5200
6083: oPop 1
6085: oJumpForward 6094
6087: Choice Lookup Table
          34   6078
          35   6076
6092: oError 8
6094: oEmit 98
6096: oGetLocal 2
6098: oPushResult
6099: oEmitLabel
6100: oPop 1
6102: oGetLocal 1
6104: oPushResult
6105: oEmitLabel
6106: oPop 1
6108: oJumpForward 6115
6110: Choice Lookup Table
          57   5997
6113: oJumpForward 6117
6115: oJumpBack 5995
6117: oReturn
6118: oLocalSpace 1
6120: oInputChoice 6174
6122: oGetAddrLocal 1
6124: oPushResult
6125: oSetResult 0
6127: oAssign
6128: oGetAddrLocal 1
6130: oPushResult
6131: oCall 6118
6133: oPop 1
6135: oTypeSNodeType
6136: oChoice 6165
6138: oGetParam 1
6140: oPushResult
6141: oLabelNew
6142: oAssign
6143: oEmit 88
6145: oGetFromParam 1
6147: oPushResult
6148: oEmitLabel
6149: oPop 1
6151: oEmit 97
6153: oGetLocal 1
6155: oPushResult
6156: oEmitLabel
6157: oPop 1
6159: oJumpForward 6172
6161: oEmit 56
6163: oJumpForward 6172
6165: Choice Lookup Table
          34   6161
          35   6138
6170: oError 8
6172: oJumpForward 6184
6174: Choice Lookup Table
          59   6122
6177: oGetParam 1
6179: oPushResult
6180: oCall 6185
6182: oPop 1
6184: oReturn
6185: oLocalSpace 2
6187: oGetAddrLocal 1
6189: oPushResult
6190: oSetResult 1
6192: oAssign
6193: oGetParam 1
6195: oPushResult
6196: oCall 6477
6198: oPop 1
6200: oInputChoice 6467
6202: oTypeSNodeType
6203: oChoice 6349
6205: oCall 9538
6207: oGetParam 1
6209: oPushResult
6210: oCall 6477
6212: oPop 1
6214: oTypeSNodeType
6215: oChoice 6231
6217: oEmit 28
6219: oCall 8600
6221: oJumpForward 6242
6223: oEmit 28
6225: oEmit 40
6227: oEmit 53
6229: oJumpForward 6242
6231: Choice Lookup Table
          33   6223
          38   6217
          37   6217
6238: oCall 9558
6240: oEmit 46
6242: oJumpForward 6368
6244: oGetParam 1
6246: oPushResult
6247: oCall 6477
6249: oPop 1
6251: oCall 9604
6253: oEmit 53
6255: oJumpForward 6368
6257: oGetLocal 1
6259: oChoice 6275
6261: oGetAddrLocal 2
6263: oPushResult
6264: oCall 11637
6266: oAssign
6267: oGetAddrLocal 1
6269: oPushResult
6270: oSetResult 0
6272: oAssign
6273: oJumpForward 6278
6275: Choice Lookup Table
           1   6261
6278: oGetParam 1
6280: oPushResult
6281: oCall 6477
6283: oPop 1
6285: oTypeSNodeType
6286: oChoice 6324
6288: oCall 11746
6290: oEmit 23
6292: oGetLocal 2
6294: oPushResult
6295: oEmitInt
6296: oPop 1
6298: oGetGlobal 16
6300: oPushResult
6301: oTypeSPush
6302: oPop 1
6304: oJumpForward 6334
6306: oCall 11800
6308: oEmit 23
6310: oGetLocal 2
6312: oPushResult
6313: oEmitInt
6314: oPop 1
6316: oGetGlobal 16
6318: oPushResult
6319: oTypeSPush
6320: oPop 1
6322: oJumpForward 6334
6324: Choice Lookup Table
          36   6306
          42   6288
          43   6288
6331: oError 15
6333: oTypeSPop
6334: oJumpForward 6368
6336: oGetParam 1
6338: oPushResult
6339: oCall 6477
6341: oPop 1
6343: oCall 9538
6345: oCall 8600
6347: oJumpForward 6368
6349: Choice Lookup Table
          38   6336
          37   6336
          36   6257
          42   6257
          43   6257
          33   6244
          30   6205
          31   6205
6366: oError 18
6368: oJumpForward 6474
6370: oTypeSNodeType
6371: oChoice 6452
6373: oCall 9538
6375: oGetParam 1
6377: oPushResult
6378: oCall 6477
6380: oPop 1
6382: oTypeSNodeType
6383: oChoice 6395
6385: oEmit 28
6387: oEmit 40
6389: oEmit 28
6391: oEmit 54
6393: oJumpForward 6402
6395: Choice Lookup Table
          33   6385
6398: oCall 9558
6400: oEmit 49
6402: oJumpForward 6465
6404: oGetParam 1
6406: oPushResult
6407: oCall 6477
6409: oPop 1
6411: oCall 9604
6413: oEmit 54
6415: oJumpForward 6465
6417: oGetParam 1
6419: oPushResult
6420: oCall 6477
6422: oPop 1
6424: oTypeSNodeType
6425: oChoice 6439
6427: oCall 9538
6429: oCall 8656
6431: oJumpForward 6450
6433: oCall 9453
6435: oCall 8712
6437: oJumpForward 6450
6439: Choice Lookup Table
          38   6433
          37   6433
          30   6427
          31   6427
6448: oError 18
6450: oJumpForward 6465
6452: Choice Lookup Table
          38   6417
          37   6417
          33   6404
          30   6373
          31   6373
6463: oError 18
6465: oJumpForward 6474
6467: Choice Lookup Table
          26   6370
          25   6202
6472: oJumpForward 6476
6474: oJumpBack 6200
6476: oReturn
6477: oLocalSpace 0
6479: oGetParam 1
6481: oPushResult
6482: oCall 6612
6484: oPop 1
6486: oInputChoice 6602
6488: oTypeSNodeType
6489: oChoice 6533
6491: oCall 9538
6493: oGetParam 1
6495: oPushResult
6496: oCall 6612
6498: oPop 1
6500: oTypeSNodeType
6501: oChoice 6511
6503: oEmit 28
6505: oEmit 40
6507: oEmit 51
6509: oJumpForward 6518
6511: Choice Lookup Table
          33   6503
6514: oCall 9558
6516: oEmit 43
6518: oJumpForward 6542
6520: oGetParam 1
6522: oPushResult
6523: oCall 6612
6525: oPop 1
6527: oCall 9604
6529: oEmit 51
6531: oJumpForward 6542
6533: Choice Lookup Table
          33   6520
          30   6491
          31   6491
6540: oError 18
6542: oJumpForward 6609
6544: oTypeSNodeType
6545: oChoice 6591
6547: oCall 9538
6549: oGetParam 1
6551: oPushResult
6552: oCall 6612
6554: oPop 1
6556: oTypeSNodeType
6557: oChoice 6569
6559: oEmit 28
6561: oEmit 40
6563: oEmit 28
6565: oEmit 52
6567: oJumpForward 6576
6569: Choice Lookup Table
          33   6559
6572: oCall 9558
6574: oEmit 44
6576: oJumpForward 6600
6578: oGetParam 1
6580: oPushResult
6581: oCall 6612
6583: oPop 1
6585: oCall 9604
6587: oEmit 52
6589: oJumpForward 6600
6591: Choice Lookup Table
          33   6578
          30   6547
          31   6547
6598: oError 18
6600: oJumpForward 6609
6602: Choice Lookup Table
          24   6544
          23   6488
6607: oJumpForward 6611
6609: oJumpBack 6486
6611: oReturn
6612: oLocalSpace 0
6614: oInputChoice 6672
6616: oGetParam 1
6618: oPushResult
6619: oCall 6685
6621: oPop 1
6623: oTypeSNodeType
6624: oChoice 6630
6626: oJumpForward 6639
6628: oJumpForward 6639
6630: Choice Lookup Table
          33   6628
          30   6626
          31   6626
6637: oError 18
6639: oJumpForward 6684
6641: oGetParam 1
6643: oPushResult
6644: oCall 6685
6646: oPop 1
6648: oTypeSNodeType
6649: oChoice 6661
6651: oCall 9558
6653: oEmit 50
6655: oJumpForward 6670
6657: oEmit 55
6659: oJumpForward 6670
6661: Choice Lookup Table
          33   6657
          30   6651
          31   6651
6668: oError 18
6670: oJumpForward 6684
6672: Choice Lookup Table
          26   6641
          25   6616
6677: oGetParam 1
6679: oPushResult
6680: oCall 6685
6682: oPop 1
6684: oReturn
6685: oLocalSpace 7
6687: oInputChoice 7191
6689: oEmit 20
6691: TOKEN_VALUE
6692: oPushResult
6693: oEmitInt
6694: oPop 1
6696: oGetGlobal 6
6698: oPushResult
6699: oTypeSPush
6700: oPop 1
6702: oJumpForward 7214
6704: oEmit 20
6706: TOKEN_VALUE
6707: oPushResult
6708: oEmitInt
6709: oPop 1
6711: oGetGlobal 9
6713: oPushResult
6714: oTypeSPush
6715: oPop 1
6717: oJumpForward 7214
6719: oEmit 21
6721: TOKEN_VALUE_DOUBLE
6722: oPushResult
6723: oEmitDouble
6724: oPop 1
6726: oGetGlobal 13
6728: oPushResult
6729: oTypeSPush
6730: oPop 1
6732: oJumpForward 7214
6734: oGetParam 1
6736: oPushResult
6737: oCall 5231
6739: oPop 1
6741: oInput 16
6743: oJumpForward 7214
6745: oGetAddrLocal 1
6747: oPushResult
6748: CURRENT_STRLIT
6749: oPushResult
6750: oStringAllocShortStringLit
6751: oPop 1
6753: oAssign
6754: oEmit 22
6756: oGetLocal 1
6758: oPushResult
6759: oEmitInt
6760: oPop 1
6762: oGetGlobal 15
6764: oPushResult
6765: oTypeSPush
6766: oPop 1
6768: oCall 8198
6770: oCall 8138
6772: oJumpForward 7214
6774: oGetAddrLocal 2
6776: oPushResult
6777: oScopeFindRequire
6778: oAssign
6779: oGetAddrLocal 2
6781: oPushResult
6782: oCall 244
6784: oPop 1
6786: oGetLocal 2
6788: oPushResult
6789: oNodeType
6790: oPop 1
6792: oChoice 7109
6794: oGetLocal 2
6796: oPushResult
6797: oCall 11949
6799: oPop 1
6801: oJumpForward 7140
6803: oGetLocal 2
6805: oPushResult
6806: oCall 12631
6808: oPop 1
6810: oJumpForward 7140
6812: oGetAddrLocal 3
6814: oPushResult
6815: oGetLocal 2
6817: oPushResult
6818: oSetResult 21
6820: oPushResult
6821: oNodeGet
6822: oPop 2
6824: oAssign
6825: oGetLocal 3
6827: oPushResult
6828: oTypeSPush
6829: oPop 1
6831: oTypeSNodeType
6832: oChoice 6856
6834: oEmit 20
6836: oGetLocal 2
6838: oPushResult
6839: oCall 15000
6841: oPop 1
6843: oJumpForward 6873
6845: oEmit 20
6847: oGetLocal 2
6849: oPushResult
6850: oCall 15000
6852: oPop 1
6854: oJumpForward 6873
6856: Choice Lookup Table
          38   6845
          37   6845
          30   6834
          36   6834
          34   6834
          44   6834
          31   6834
6871: oError 17
6873: oJumpForward 7140
6875: oGetAddrLocal 3
6877: oPushResult
6878: oGetLocal 2
6880: oPushResult
6881: oSetResult 21
6883: oPushResult
6884: oNodeGet
6885: oPop 2
6887: oAssign
6888: oGetLocal 3
6890: oPushResult
6891: oTypeSPush
6892: oPop 1
6894: oTypeSNodeType
6895: oChoice 6914
6897: oEmit 21
6899: oGetLocal 2
6901: oPushResult
6902: oSetResult 34
6904: oPushResult
6905: oNodeGetDouble
6906: oPop 2
6908: oPushResult
6909: oEmitDouble
6910: oPop 1
6912: oJumpForward 6919
6914: Choice Lookup Table
          33   6897
6917: oError 17
6919: oJumpForward 7140
6921: oGetAddrLocal 4
6923: oPushResult
6924: oGetLocal 2
6926: oPushResult
6927: oSetResult 22
6929: oPushResult
6930: oNodeGetInt
6931: oPop 2
6933: oAssign
6934: oGetLocal 4
6936: oPushResult
6937: equal_zero
6938: oPop 1
6940: oChoice 6973
6942: oGetAddrLocal 4
6944: oPushResult
6945: oGetLocal 2
6947: oPushResult
6948: oSetResult 33
6950: oPushResult
6951: oNodeGetString
6952: oPop 2
6954: oPushResult
6955: oStringAllocShortStringLit
6956: oPop 1
6958: oAssign
6959: oGetLocal 2
6961: oPushResult
6962: oSetResult 22
6964: oPushResult
6965: oGetLocal 4
6967: oPushResult
6968: oNodeSetInt
6969: oPop 3
6971: oJumpForward 6976
6973: Choice Lookup Table
           1   6942
6976: oEmit 22
6978: oGetLocal 4
6980: oPushResult
6981: oEmitInt
6982: oPop 1
6984: oGetGlobal 15
6986: oPushResult
6987: oTypeSPush
6988: oPop 1
6990: oCall 8198
6992: oCall 8138
6994: oJumpForward 7140
6996: oGetLocal 2
6998: oPushResult
6999: oCall 7215
7001: oPop 1
7003: oJumpForward 7140
7005: oGetLocal 2
7007: oPushResult
7008: oSetResult 21
7010: oPushResult
7011: oNodeGet
7012: oPop 2
7014: oPushResult
7015: oTypeSPush
7016: oPop 1
7018: oInputChoice 7085
7020: oCall 5047
7022: oInput 16
7024: oCall 9273
7026: oTypeSNodeType
7027: oChoice 7072
7029: oInputChoice 7059
7031: oTypeSPop
7032: oGetLocal 3
7034: oPushResult
7035: oSetResult 38
7037: oPushResult
7038: oNodeGet
7039: oPop 2
7041: oPushResult
7042: oTypeSPush
7043: oPop 1
7045: oCall 8198
7047: oCall 8138
7049: oJumpForward 7064
7051: oCall 8393
7053: oCall 8198
7055: oCall 8138
7057: oJumpForward 7064
7059: Choice Lookup Table
          17   7051
          19   7031
7064: oJumpForward 7083
7066: oCall 8198
7068: oCall 8138
7070: oJumpForward 7083
7072: Choice Lookup Table
          43   7066
          41   7066
          39   7066
          38   7029
          37   7029
7083: oJumpForward 7107
7085: Choice Lookup Table
          15   7020
7088: oGetGlobal 25
7090: oChoice 7102
7092: oEmit 20
7094: oSetResult 0
7096: oPushResult
7097: oEmitInt
7098: oPop 1
7100: oJumpForward 7107
7102: Choice Lookup Table
           1   7092
7105: oError 33
7107: oJumpForward 7140
7109: Choice Lookup Table
          20   7005
          26   6996
          25   6996
          23   6996
          22   6996
          18   6921
          19   6875
          17   6812
          16   6812
          14   6803
          13   6794
7132: oError 6
7134: oGetGlobal 6
7136: oPushResult
7137: oTypeSPush
7138: oPop 1
7140: oJumpForward 7214
7142: oInput 0
7144: oGetAddrLocal 5
7146: oPushResult
7147: oScopeFindRequire
7148: oAssign
7149: oGetAddrLocal 5
7151: oPushResult
7152: oCall 244
7154: oPop 1
7156: oGetLocal 5
7158: oPushResult
7159: oSetResult 0
7161: oPushResult
7162: oCall 10154
7164: oPop 2
7166: oGetAddrLocal 6
7168: oPushResult
7169: oTypeSTop
7170: oAssign
7171: oTypeSPop
7172: oGetAddrLocal 7
7174: oPushResult
7175: oGetLocal 6
7177: oPushResult
7178: oCall 14019
7180: oPop 1
7182: oAssign
7183: oGetLocal 7
7185: oPushResult
7186: oTypeSPush
7187: oPop 1
7189: oJumpForward 7214
7191: Choice Lookup Table
          20   7142
           0   6774
           3   6745
          15   6734
           2   6719
           4   6704
           1   6689
7206: oError 6
7208: oGetGlobal 6
7210: oPushResult
7211: oTypeSPush
7212: oPop 1
7214: oReturn
7215: oLocalSpace 2
7217: oGetAddrLocal 1
7219: oPushResult
7220: oGetParam 1
7222: oPushResult
7223: oSetResult 21
7225: oPushResult
7226: oNodeGet
7227: oPop 2
7229: oAssign
7230: oGetAddrLocal 2
7232: oPushResult
7233: oGetParam 1
7235: oPushResult
7236: oCall 14954
7238: oPop 1
7240: oAssign
7241: oGetLocal 1
7243: oPushResult
7244: oTypeSPush
7245: oPop 1
7247: oTypeSNodeType
7248: oChoice 8111
7250: oGetParam 1
7252: oPushResult
7253: oNodeType
7254: oPop 1
7256: oChoice 7402
7258: oEmit 0
7260: oGetParam 1
7262: oPushResult
7263: oCall 15000
7265: oPop 1
7267: oJumpForward 7412
7269: oGetLocal 2
7271: oPushResult
7272: equal_zero
7273: oPop 1
7275: oChoice 7288
7277: oEmit 4
7279: oGetParam 1
7281: oPushResult
7282: oCall 15000
7284: oPop 1
7286: oJumpForward 7306
7288: Choice Lookup Table
           1   7277
7291: oEmit 12
7293: oGetLocal 2
7295: oPushResult
7296: oEmitInt
7297: oPop 1
7299: oGetParam 1
7301: oPushResult
7302: oCall 15000
7304: oPop 1
7306: oJumpForward 7412
7308: oGetParam 1
7310: oPushResult
7311: oSetResult 35
7313: oPushResult
7314: oNodeGetBoolean
7315: oPop 2
7317: oChoice 7360
7319: oGetLocal 2
7321: oPushResult
7322: equal_zero
7323: oPop 1
7325: oChoice 7338
7327: oEmit 10
7329: oGetParam 1
7331: oPushResult
7332: oCall 15000
7334: oPop 1
7336: oJumpForward 7356
7338: Choice Lookup Table
           1   7327
7341: oEmit 18
7343: oGetLocal 2
7345: oPushResult
7346: oEmitInt
7347: oPop 1
7349: oGetParam 1
7351: oPushResult
7352: oCall 15000
7354: oPop 1
7356: oEmit 29
7358: oJumpForward 7400
7360: Choice Lookup Table
           1   7319
7363: oGetLocal 2
7365: oPushResult
7366: equal_zero
7367: oPop 1
7369: oChoice 7382
7371: oEmit 8
7373: oGetParam 1
7375: oPushResult
7376: oCall 15000
7378: oPop 1
7380: oJumpForward 7400
7382: Choice Lookup Table
           1   7371
7385: oEmit 16
7387: oGetLocal 2
7389: oPushResult
7390: oEmitInt
7391: oPop 1
7393: oGetParam 1
7395: oPushResult
7396: oCall 15000
7398: oPop 1
7400: oJumpForward 7412
7402: Choice Lookup Table
          25   7308
          23   7269
          26   7258
          22   7258
7411: oEndChoice
7412: oJumpForward 8137
7414: oGetParam 1
7416: oPushResult
7417: oNodeType
7418: oPop 1
7420: oChoice 7566
7422: oEmit 1
7424: oGetParam 1
7426: oPushResult
7427: oCall 15000
7429: oPop 1
7431: oJumpForward 7576
7433: oGetLocal 2
7435: oPushResult
7436: equal_zero
7437: oPop 1
7439: oChoice 7452
7441: oEmit 5
7443: oGetParam 1
7445: oPushResult
7446: oCall 15000
7448: oPop 1
7450: oJumpForward 7470
7452: Choice Lookup Table
           1   7441
7455: oEmit 13
7457: oGetLocal 2
7459: oPushResult
7460: oEmitInt
7461: oPop 1
7463: oGetParam 1
7465: oPushResult
7466: oCall 15000
7468: oPop 1
7470: oJumpForward 7576
7472: oGetParam 1
7474: oPushResult
7475: oSetResult 35
7477: oPushResult
7478: oNodeGetBoolean
7479: oPop 2
7481: oChoice 7524
7483: oGetLocal 2
7485: oPushResult
7486: equal_zero
7487: oPop 1
7489: oChoice 7502
7491: oEmit 10
7493: oGetParam 1
7495: oPushResult
7496: oCall 15000
7498: oPop 1
7500: oJumpForward 7520
7502: Choice Lookup Table
           1   7491
7505: oEmit 18
7507: oGetLocal 2
7509: oPushResult
7510: oEmitInt
7511: oPop 1
7513: oGetParam 1
7515: oPushResult
7516: oCall 15000
7518: oPop 1
7520: oEmit 30
7522: oJumpForward 7564
7524: Choice Lookup Table
           1   7483
7527: oGetLocal 2
7529: oPushResult
7530: equal_zero
7531: oPop 1
7533: oChoice 7546
7535: oEmit 9
7537: oGetParam 1
7539: oPushResult
7540: oCall 15000
7542: oPop 1
7544: oJumpForward 7564
7546: Choice Lookup Table
           1   7535
7549: oEmit 17
7551: oGetLocal 2
7553: oPushResult
7554: oEmitInt
7555: oPop 1
7557: oGetParam 1
7559: oPushResult
7560: oCall 15000
7562: oPop 1
7564: oJumpForward 7576
7566: Choice Lookup Table
          25   7472
          23   7433
          26   7422
          22   7422
7575: oEndChoice
7576: oJumpForward 8137
7578: oError 17
7580: oJumpForward 8137
7582: oGetParam 1
7584: oPushResult
7585: oNodeType
7586: oPop 1
7588: oChoice 7734
7590: oEmit 3
7592: oGetParam 1
7594: oPushResult
7595: oCall 15000
7597: oPop 1
7599: oJumpForward 7744
7601: oGetLocal 2
7603: oPushResult
7604: equal_zero
7605: oPop 1
7607: oChoice 7620
7609: oEmit 7
7611: oGetParam 1
7613: oPushResult
7614: oCall 15000
7616: oPop 1
7618: oJumpForward 7638
7620: Choice Lookup Table
           1   7609
7623: oEmit 15
7625: oGetLocal 2
7627: oPushResult
7628: oEmitInt
7629: oPop 1
7631: oGetParam 1
7633: oPushResult
7634: oCall 15000
7636: oPop 1
7638: oJumpForward 7744
7640: oGetParam 1
7642: oPushResult
7643: oSetResult 35
7645: oPushResult
7646: oNodeGetBoolean
7647: oPop 2
7649: oChoice 7692
7651: oGetLocal 2
7653: oPushResult
7654: equal_zero
7655: oPop 1
7657: oChoice 7670
7659: oEmit 10
7661: oGetParam 1
7663: oPushResult
7664: oCall 15000
7666: oPop 1
7668: oJumpForward 7688
7670: Choice Lookup Table
           1   7659
7673: oEmit 18
7675: oGetLocal 2
7677: oPushResult
7678: oEmitInt
7679: oPop 1
7681: oGetParam 1
7683: oPushResult
7684: oCall 15000
7686: oPop 1
7688: oEmit 32
7690: oJumpForward 7732
7692: Choice Lookup Table
           1   7651
7695: oGetLocal 2
7697: oPushResult
7698: equal_zero
7699: oPop 1
7701: oChoice 7714
7703: oEmit 11
7705: oGetParam 1
7707: oPushResult
7708: oCall 15000
7710: oPop 1
7712: oJumpForward 7732
7714: Choice Lookup Table
           1   7703
7717: oEmit 19
7719: oGetLocal 2
7721: oPushResult
7722: oEmitInt
7723: oPop 1
7725: oGetParam 1
7727: oPushResult
7728: oCall 15000
7730: oPop 1
7732: oJumpForward 7744
7734: Choice Lookup Table
          25   7640
          23   7601
          26   7590
          22   7590
7743: oEndChoice
7744: oJumpForward 8137
7746: oGetParam 1
7748: oPushResult
7749: oNodeType
7750: oPop 1
7752: oChoice 7898
7754: oEmit 2
7756: oGetParam 1
7758: oPushResult
7759: oCall 15000
7761: oPop 1
7763: oJumpForward 7908
7765: oGetLocal 2
7767: oPushResult
7768: equal_zero
7769: oPop 1
7771: oChoice 7784
7773: oEmit 6
7775: oGetParam 1
7777: oPushResult
7778: oCall 15000
7780: oPop 1
7782: oJumpForward 7802
7784: Choice Lookup Table
           1   7773
7787: oEmit 14
7789: oGetLocal 2
7791: oPushResult
7792: oEmitInt
7793: oPop 1
7795: oGetParam 1
7797: oPushResult
7798: oCall 15000
7800: oPop 1
7802: oJumpForward 7908
7804: oGetParam 1
7806: oPushResult
7807: oSetResult 35
7809: oPushResult
7810: oNodeGetBoolean
7811: oPop 2
7813: oChoice 7856
7815: oGetLocal 2
7817: oPushResult
7818: equal_zero
7819: oPop 1
7821: oChoice 7834
7823: oEmit 10
7825: oGetParam 1
7827: oPushResult
7828: oCall 15000
7830: oPop 1
7832: oJumpForward 7852
7834: Choice Lookup Table
           1   7823
7837: oEmit 18
7839: oGetLocal 2
7841: oPushResult
7842: oEmitInt
7843: oPop 1
7845: oGetParam 1
7847: oPushResult
7848: oCall 15000
7850: oPop 1
7852: oEmit 31
7854: oJumpForward 7896
7856: Choice Lookup Table
           1   7815
7859: oGetLocal 2
7861: oPushResult
7862: equal_zero
7863: oPop 1
7865: oChoice 7878
7867: oEmit 10
7869: oGetParam 1
7871: oPushResult
7872: oCall 15000
7874: oPop 1
7876: oJumpForward 7896
7878: Choice Lookup Table
           1   7867
7881: oEmit 18
7883: oGetLocal 2
7885: oPushResult
7886: oEmitInt
7887: oPop 1
7889: oGetParam 1
7891: oPushResult
7892: oCall 15000
7894: oPop 1
7896: oJumpForward 7908
7898: Choice Lookup Table
          25   7804
          23   7765
          26   7754
          22   7754
7907: oEndChoice
7908: oInputChoice 7938
7910: oTypeSPop
7911: oGetLocal 1
7913: oPushResult
7914: oSetResult 38
7916: oPushResult
7917: oNodeGet
7918: oPop 2
7920: oPushResult
7921: oTypeSPush
7922: oPop 1
7924: oCall 8198
7926: oCall 8138
7928: oJumpForward 7943
7930: oCall 8393
7932: oCall 8198
7934: oCall 8138
7936: oJumpForward 7943
7938: Choice Lookup Table
          17   7930
          19   7910
7943: oJumpForward 8137
7945: oGetParam 1
7947: oPushResult
7948: oNodeType
7949: oPop 1
7951: oChoice 8095
7953: oEmit 22
7955: oGetParam 1
7957: oPushResult
7958: oCall 15000
7960: oPop 1
7962: oJumpForward 8105
7964: oGetLocal 2
7966: oPushResult
7967: equal_zero
7968: oPop 1
7970: oChoice 7983
7972: oEmit 23
7974: oGetParam 1
7976: oPushResult
7977: oCall 15000
7979: oPop 1
7981: oJumpForward 8001
7983: Choice Lookup Table
           1   7972
7986: oEmit 26
7988: oGetLocal 2
7990: oPushResult
7991: oEmitInt
7992: oPop 1
7994: oGetParam 1
7996: oPushResult
7997: oCall 15000
7999: oPop 1
8001: oJumpForward 8105
8003: oGetParam 1
8005: oPushResult
8006: oSetResult 35
8008: oPushResult
8009: oNodeGetBoolean
8010: oPop 2
8012: oChoice 8053
8014: oGetLocal 2
8016: oPushResult
8017: equal_zero
8018: oPop 1
8020: oChoice 8033
8022: oEmit 10
8024: oGetParam 1
8026: oPushResult
8027: oCall 15000
8029: oPop 1
8031: oJumpForward 8051
8033: Choice Lookup Table
           1   8022
8036: oEmit 18
8038: oGetLocal 2
8040: oPushResult
8041: oEmitInt
8042: oPop 1
8044: oGetParam 1
8046: oPushResult
8047: oCall 15000
8049: oPop 1
8051: oJumpForward 8093
8053: Choice Lookup Table
           1   8014
8056: oGetLocal 2
8058: oPushResult
8059: equal_zero
8060: oPop 1
8062: oChoice 8075
8064: oEmit 24
8066: oGetParam 1
8068: oPushResult
8069: oCall 15000
8071: oPop 1
8073: oJumpForward 8093
8075: Choice Lookup Table
           1   8064
8078: oEmit 27
8080: oGetLocal 2
8082: oPushResult
8083: oEmitInt
8084: oPop 1
8086: oGetParam 1
8088: oPushResult
8089: oCall 15000
8091: oPop 1
8093: oJumpForward 8105
8095: Choice Lookup Table
          25   8003
          23   7964
          26   7953
          22   7953
8104: oEndChoice
8105: oCall 8198
8107: oCall 8138
8109: oJumpForward 8137
8111: Choice Lookup Table
          43   7945
          41   7945
          39   7945
          38   7746
          37   7746
          33   7582
          29   7578
          36   7414
          30   7414
          34   7414
          44   7250
          31   7250
8136: oEndChoice
8137: oReturn
8138: oLocalSpace 0
8140: oTypeSNodeType
8141: oChoice 8169
8143: oEmit 29
8145: oJumpForward 8197
8147: oEmit 30
8149: oJumpForward 8197
8151: oEmit 32
8153: oJumpForward 8197
8155: oError 17
8157: oJumpForward 8197
8159: oEmit 31
8161: oJumpForward 8197
8163: oError 31
8165: oJumpForward 8197
8167: oJumpForward 8197
8169: Choice Lookup Table
          43   8167
          42   8167
          41   8167
          39   8167
          38   8163
          37   8159
          29   8155
          33   8151
          36   8147
          30   8147
          34   8147
          44   8143
          31   8143
8196: oEndChoice
8197: oReturn
8198: oLocalSpace 0
8200: oInputChoice 8238
8202: oTypeSNodeType
8203: oChoice 8217
8205: oCall 8250
8207: oJumpForward 8228
8209: oCall 8393
8211: oJumpForward 8228
8213: oCall 8472
8215: oJumpForward 8228
8217: Choice Lookup Table
          43   8213
          42   8213
          37   8209
          39   8205
8226: oError 11
8228: oJumpForward 8247
8230: oCall 8502
8232: oJumpForward 8247
8234: oCall 8775
8236: oJumpForward 8247
8238: Choice Lookup Table
          19   8234
          21   8230
          17   8202
8245: oJumpForward 8249
8247: oJumpBack 8200
8249: oReturn
8250: oLocalSpace 3
8252: oTypeSNodeType
8253: oChoice 8257
8255: oJumpForward 8262
8257: Choice Lookup Table
          39   8255
8260: oError 11
8262: oTypeSNodeType
8263: oChoice 8267
8265: oJumpForward 8272
8267: Choice Lookup Table
          39   8265
8270: oError 14
8272: oGetAddrLocal 1
8274: oPushResult
8275: oTypeSTop
8276: oPushResult
8277: oSetResult 39
8279: oPushResult
8280: oNodeGet
8281: oPop 2
8283: oPushResult
8284: oCall 14103
8286: oPop 1
8288: oAssign
8289: oGetAddrLocal 2
8291: oPushResult
8292: oTypeSTop
8293: oPushResult
8294: oSetResult 38
8296: oPushResult
8297: oNodeGet
8298: oPop 2
8300: oAssign
8301: oTypeSPop
8302: oGetLocal 2
8304: oPushResult
8305: oTypeSPush
8306: oPop 1
8308: oCall 5047
8310: oCall 9511
8312: oGetLocal 1
8314: oPushResult
8315: equal_zero
8316: oPop 1
8318: oChoice 8332
8320: oEmit 20
8322: oGetLocal 1
8324: oPushResult
8325: oEmitInt
8326: oPop 1
8328: oEmit 49
8330: oJumpForward 8335
8332: Choice Lookup Table
           0   8320
8335: oGetAddrLocal 3
8337: oPushResult
8338: oGetLocal 2
8340: oPushResult
8341: oSetResult 17
8343: oPushResult
8344: oNodeGetInt
8345: oPop 2
8347: oAssign
8348: oGetLocal 3
8350: oPushResult
8351: oSetResult 1
8353: oPushResult
8354: equal
8355: oPop 2
8357: oChoice 8371
8359: oEmit 20
8361: oGetLocal 3
8363: oPushResult
8364: oEmitInt
8365: oPop 1
8367: oEmit 43
8369: oJumpForward 8374
8371: Choice Lookup Table
           0   8359
8374: oEmit 45
8376: oInputChoice 8384
8378: oJumpForward 8392
8380: oJumpForward 8390
8382: oJumpForward 8390
8384: Choice Lookup Table
          14   8382
          18   8378
8389: oEndChoice
8390: oJumpBack 8262
8392: oReturn
8393: oLocalSpace 2
8395: oTypeSNodeType
8396: oChoice 8400
8398: oJumpForward 8405
8400: Choice Lookup Table
          37   8398
8403: oError 31
8405: oGetAddrLocal 1
8407: oPushResult
8408: oTypeSTop
8409: oPushResult
8410: oSetResult 38
8412: oPushResult
8413: oNodeGet
8414: oPop 2
8416: oAssign
8417: oTypeSPop
8418: oGetLocal 1
8420: oPushResult
8421: oTypeSPush
8422: oPop 1
8424: oCall 5047
8426: oCall 9511
8428: oGetAddrLocal 2
8430: oPushResult
8431: oGetLocal 1
8433: oPushResult
8434: oSetResult 17
8436: oPushResult
8437: oNodeGetInt
8438: oPop 2
8440: oAssign
8441: oGetLocal 2
8443: oPushResult
8444: oSetResult 1
8446: oPushResult
8447: equal
8448: oPop 2
8450: oChoice 8464
8452: oEmit 20
8454: oGetLocal 2
8456: oPushResult
8457: oEmitInt
8458: oPop 1
8460: oEmit 43
8462: oJumpForward 8467
8464: Choice Lookup Table
           0   8452
8467: oEmit 45
8469: oInput 18
8471: oReturn
8472: oLocalSpace 0
8474: oTypeSNodeType
8475: oChoice 8479
8477: oJumpForward 8486
8479: Choice Lookup Table
          43   8477
          42   8477
8484: oError 31
8486: oTypeSPop
8487: oGetGlobal 9
8489: oPushResult
8490: oTypeSPush
8491: oPop 1
8493: oCall 5047
8495: oCall 9511
8497: oEmit 45
8499: oInput 18
8501: oReturn
8502: oLocalSpace 2
8504: oTypeSNodeType
8505: oChoice 8509
8507: oJumpForward 8514
8509: Choice Lookup Table
          41   8507
8512: oError 12
8514: oTypeSTop
8515: oPushResult
8516: oSetResult 42
8518: oPushResult
8519: oNodeGet
8520: oPop 2
8522: oPushResult
8523: oScopeEnter
8524: oPop 1
8526: oInput 0
8528: oGetAddrLocal 1
8530: oPushResult
8531: oScopeFindRequire
8532: oAssign
8533: oGetLocal 1
8535: oPushResult
8536: oNodeType
8537: oPop 1
8539: oChoice 8543
8541: oJumpForward 8548
8543: Choice Lookup Table
          24   8541
8546: oError 13
8548: oScopeEnd
8549: oGetAddrLocal 2
8551: oPushResult
8552: oGetLocal 1
8554: oPushResult
8555: oSetResult 22
8557: oPushResult
8558: oNodeGetInt
8559: oPop 2
8561: oAssign
8562: oGetLocal 2
8564: oPushResult
8565: equal_zero
8566: oPop 1
8568: oChoice 8582
8570: oEmit 20
8572: oGetLocal 2
8574: oPushResult
8575: oEmitInt
8576: oPop 1
8578: oEmit 45
8580: oJumpForward 8585
8582: Choice Lookup Table
           0   8570
8585: oTypeSPop
8586: oGetLocal 1
8588: oPushResult
8589: oSetResult 21
8591: oPushResult
8592: oNodeGet
8593: oPop 2
8595: oPushResult
8596: oTypeSPush
8597: oPop 1
8599: oReturn
8600: oLocalSpace 2
8602: oGetAddrLocal 1
8604: oPushResult
8605: oTypeSTop
8606: oPushResult
8607: oSetResult 38
8609: oPushResult
8610: oNodeGet
8611: oPop 2
8613: oAssign
8614: oGetAddrLocal 2
8616: oPushResult
8617: oGetLocal 1
8619: oPushResult
8620: oSetResult 17
8622: oPushResult
8623: oNodeGetInt
8624: oPop 2
8626: oAssign
8627: oGetLocal 2
8629: oPushResult
8630: oSetResult 1
8632: oPushResult
8633: equal
8634: oPop 2
8636: oChoice 8650
8638: oEmit 20
8640: oGetLocal 2
8642: oPushResult
8643: oEmitInt
8644: oPop 1
8646: oEmit 43
8648: oJumpForward 8653
8650: Choice Lookup Table
           0   8638
8653: oEmit 45
8655: oReturn
8656: oLocalSpace 2
8658: oGetAddrLocal 1
8660: oPushResult
8661: oTypeSTop
8662: oPushResult
8663: oSetResult 38
8665: oPushResult
8666: oNodeGet
8667: oPop 2
8669: oAssign
8670: oGetAddrLocal 2
8672: oPushResult
8673: oGetLocal 1
8675: oPushResult
8676: oSetResult 17
8678: oPushResult
8679: oNodeGetInt
8680: oPop 2
8682: oAssign
8683: oGetLocal 2
8685: oPushResult
8686: oSetResult 1
8688: oPushResult
8689: equal
8690: oPop 2
8692: oChoice 8706
8694: oEmit 20
8696: oGetLocal 2
8698: oPushResult
8699: oEmitInt
8700: oPop 1
8702: oEmit 43
8704: oJumpForward 8709
8706: Choice Lookup Table
           0   8694
8709: oEmit 48
8711: oReturn
8712: oLocalSpace 2
8714: oEmit 47
8716: oGetAddrLocal 1
8718: oPushResult
8719: oTypeSTop
8720: oPushResult
8721: oSetResult 38
8723: oPushResult
8724: oNodeGet
8725: oPop 2
8727: oAssign
8728: oGetAddrLocal 2
8730: oPushResult
8731: oGetLocal 1
8733: oPushResult
8734: oSetResult 17
8736: oPushResult
8737: oNodeGetInt
8738: oPop 2
8740: oAssign
8741: oGetLocal 2
8743: oPushResult
8744: oSetResult 1
8746: oPushResult
8747: equal
8748: oPop 2
8750: oChoice 8764
8752: oEmit 20
8754: oGetLocal 2
8756: oPushResult
8757: oEmitInt
8758: oPop 1
8760: oEmit 44
8762: oJumpForward 8767
8764: Choice Lookup Table
           0   8752
8767: oTypeSPop
8768: oGetGlobal 6
8770: oPushResult
8771: oTypeSPush
8772: oPop 1
8774: oReturn
8775: oLocalSpace 1
8777: oTypeSNodeType
8778: oChoice 8786
8780: oJumpForward 8793
8782: oError 31
8784: oJumpForward 8793
8786: Choice Lookup Table
          38   8782
          37   8780
8791: oError 10
8793: oEmit 31
8795: oGetAddrLocal 1
8797: oPushResult
8798: oTypeSTop
8799: oAssign
8800: oTypeSPop
8801: oGetLocal 1
8803: oPushResult
8804: oSetResult 38
8806: oPushResult
8807: oNodeGet
8808: oPop 2
8810: oPushResult
8811: oTypeSPush
8812: oPop 1
8814: oReturn
8815: oLocalSpace 3
8817: oGetAddrLocal 1
8819: oPushResult
8820: oTypeSNodeType
8821: oAssign
8822: oGetAddrLocal 2
8824: oPushResult
8825: oTypeSTop
8826: oAssign
8827: oTypeSPop
8828: oGetLocal 1
8830: oPushResult
8831: oTypeSNodeType
8832: oPushResult
8833: equal_node_type
8834: oPop 2
8836: oChoice 8984
8838: oTypeSNodeType
8839: oChoice 8967
8841: oGetLocal 1
8843: oChoice 8850
8845: oEmit 38
8847: oReturn
8848: oJumpForward 8853
8850: Choice Lookup Table
          30   8845
8853: oJumpForward 8980
8855: oGetLocal 1
8857: oChoice 8864
8859: oEmit 39
8861: oReturn
8862: oJumpForward 8867
8864: Choice Lookup Table
          31   8859
8867: oJumpForward 8980
8869: oGetLocal 1
8871: oChoice 8878
8873: oEmit 40
8875: oReturn
8876: oJumpForward 8881
8878: Choice Lookup Table
          31   8873
8881: oJumpForward 8980
8883: oGetLocal 1
8885: oChoice 8918
8887: oReturn
8888: oJumpForward 8923
8890: oTypeSTop
8891: oPushResult
8892: oGetGlobal 10
8894: oPushResult
8895: equal_node
8896: oPop 2
8898: oChoice 8913
8900: oEmit 20
8902: oSetResult 1
8904: oPushResult
8905: oEmitInt
8906: oPop 1
8908: oEmit 45
8910: oReturn
8911: oJumpForward 8916
8913: Choice Lookup Table
           1   8900
8916: oJumpForward 8923
8918: Choice Lookup Table
          42   8890
          38   8887
8923: oJumpForward 8980
8925: oGetLocal 1
8927: oChoice 8932
8929: oReturn
8930: oJumpForward 8935
8932: Choice Lookup Table
          37   8929
8935: oJumpForward 8980
8937: oGetLocal 1
8939: oChoice 8960
8941: oReturn
8942: oJumpForward 8965
8944: oGetGlobal 9
8946: oPushResult
8947: oTypeSPush
8948: oPop 1
8950: oGetAddrLocal 3
8952: oPushResult
8953: oCall 11637
8955: oAssign
8956: oTypeSPop
8957: oReturn
8958: oJumpForward 8965
8960: Choice Lookup Table
          36   8944
          42   8941
8965: oJumpForward 8980
8967: Choice Lookup Table
          43   8937
          38   8925
          37   8883
          33   8869
          30   8855
          31   8841
8980: oError 15
8982: oJumpForward 8987
8984: Choice Lookup Table
           0   8838
8987: oReturn
8988: oLocalSpace 6
8990: oGetAddrLocal 1
8992: oPushResult
8993: oTypeSNodeType
8994: oAssign
8995: oGetAddrLocal 2
8997: oPushResult
8998: oTypeSTop
8999: oAssign
9000: oTypeSPop
9001: oGetAddrLocal 3
9003: oPushResult
9004: oTypeSNodeType
9005: oAssign
9006: oGetAddrLocal 4
9008: oPushResult
9009: oTypeSTop
9010: oAssign
9011: oGetLocal 3
9013: oPushResult
9014: oGetLocal 1
9016: oPushResult
9017: equal_node_type
9018: oPop 2
9020: oChoice 9025
9022: oReturn
9023: oJumpForward 9028
9025: Choice Lookup Table
           1   9022
9028: oGetLocal 3
9030: oChoice 9111
9032: oGetLocal 1
9034: oChoice 9041
9036: oEmit 38
9038: oReturn
9039: oJumpForward 9044
9041: Choice Lookup Table
          30   9036
9044: oJumpForward 9120
9046: oGetLocal 1
9048: oChoice 9062
9050: oEmit 38
9052: oEmit 40
9054: oReturn
9055: oJumpForward 9067
9057: oEmit 40
9059: oReturn
9060: oJumpForward 9067
9062: Choice Lookup Table
          31   9057
          30   9050
9067: oJumpForward 9120
9069: oGetLocal 1
9071: oChoice 9076
9073: oReturn
9074: oJumpForward 9079
9076: Choice Lookup Table
          38   9073
9079: oJumpForward 9120
9081: oGetLocal 1
9083: oChoice 9104
9085: oReturn
9086: oJumpForward 9109
9088: oGetGlobal 9
9090: oPushResult
9091: oTypeSPush
9092: oPop 1
9094: oGetAddrLocal 5
9096: oPushResult
9097: oCall 11637
9099: oAssign
9100: oTypeSPop
9101: oReturn
9102: oJumpForward 9109
9104: Choice Lookup Table
          36   9088
          42   9085
9109: oJumpForward 9120
9111: Choice Lookup Table
          43   9081
          37   9069
          33   9046
          31   9032
9120: oGetLocal 1
9122: oChoice 9261
9124: oGetLocal 3
9126: oChoice 9144
9128: oEmit 28
9130: oEmit 38
9132: oEmit 28
9134: oTypeSPop
9135: oGetLocal 2
9137: oPushResult
9138: oTypeSPush
9139: oPop 1
9141: oReturn
9142: oJumpForward 9147
9144: Choice Lookup Table
          30   9128
9147: oJumpForward 9270
9149: oGetLocal 3
9151: oChoice 9187
9153: oEmit 28
9155: oEmit 38
9157: oEmit 40
9159: oEmit 28
9161: oTypeSPop
9162: oGetLocal 2
9164: oPushResult
9165: oTypeSPush
9166: oPop 1
9168: oReturn
9169: oJumpForward 9192
9171: oEmit 28
9173: oEmit 40
9175: oEmit 28
9177: oTypeSPop
9178: oGetLocal 2
9180: oPushResult
9181: oTypeSPush
9182: oPop 1
9184: oReturn
9185: oJumpForward 9192
9187: Choice Lookup Table
          31   9171
          30   9153
9192: oJumpForward 9270
9194: oGetLocal 3
9196: oChoice 9208
9198: oTypeSPop
9199: oGetLocal 2
9201: oPushResult
9202: oTypeSPush
9203: oPop 1
9205: oReturn
9206: oJumpForward 9211
9208: Choice Lookup Table
          38   9198
9211: oJumpForward 9270
9213: oGetLocal 3
9215: oChoice 9254
9217: oTypeSPop
9218: oGetLocal 2
9220: oPushResult
9221: oTypeSPush
9222: oPop 1
9224: oReturn
9225: oJumpForward 9259
9227: oEmit 28
9229: oGetGlobal 9
9231: oPushResult
9232: oTypeSPush
9233: oPop 1
9235: oGetAddrLocal 6
9237: oPushResult
9238: oCall 11637
9240: oAssign
9241: oTypeSPop
9242: oEmit 28
9244: oTypeSPop
9245: oGetLocal 2
9247: oPushResult
9248: oTypeSPush
9249: oPop 1
9251: oReturn
9252: oJumpForward 9259
9254: Choice Lookup Table
          36   9227
          42   9217
9259: oJumpForward 9270
9261: Choice Lookup Table
          43   9213
          37   9194
          33   9149
          31   9124
9270: oError 15
9272: oReturn
9273: oLocalSpace 2
9275: oGetAddrLocal 1
9277: oPushResult
9278: oTypeSNodeType
9279: oAssign
9280: oTypeSPop
9281: oGetLocal 1
9283: oPushResult
9284: oTypeSNodeType
9285: oPushResult
9286: equal_node_type
9287: oPop 2
9289: oChoice 9449
9291: oTypeSNodeType
9292: oChoice 9428
9294: oGetLocal 1
9296: oChoice 9306
9298: oEmit 38
9300: oReturn
9301: oJumpForward 9317
9303: oReturn
9304: oJumpForward 9317
9306: Choice Lookup Table
          44   9303
          31   9303
          34   9298
          36   9298
          30   9298
9317: oJumpForward 9445
9319: oGetLocal 1
9321: oChoice 9331
9323: oReturn
9324: oJumpForward 9342
9326: oEmit 39
9328: oReturn
9329: oJumpForward 9342
9331: Choice Lookup Table
          44   9326
          31   9326
          34   9323
          36   9323
          30   9323
9342: oJumpForward 9445
9344: oGetLocal 1
9346: oChoice 9379
9348: oReturn
9349: oJumpForward 9384
9351: oTypeSTop
9352: oPushResult
9353: oGetGlobal 10
9355: oPushResult
9356: equal_node
9357: oPop 2
9359: oChoice 9374
9361: oEmit 20
9363: oSetResult 1
9365: oPushResult
9366: oEmitInt
9367: oPop 1
9369: oEmit 45
9371: oReturn
9372: oJumpForward 9377
9374: Choice Lookup Table
           1   9361
9377: oJumpForward 9384
9379: Choice Lookup Table
          42   9351
          38   9348
9384: oJumpForward 9445
9386: oGetLocal 1
9388: oChoice 9393
9390: oReturn
9391: oJumpForward 9396
9393: Choice Lookup Table
          37   9390
9396: oJumpForward 9445
9398: oGetLocal 1
9400: oChoice 9421
9402: oReturn
9403: oJumpForward 9426
9405: oGetGlobal 9
9407: oPushResult
9408: oTypeSPush
9409: oPop 1
9411: oGetAddrLocal 2
9413: oPushResult
9414: oCall 11637
9416: oAssign
9417: oTypeSPop
9418: oReturn
9419: oJumpForward 9426
9421: Choice Lookup Table
          36   9405
          42   9402
9426: oJumpForward 9445
9428: Choice Lookup Table
          43   9398
          38   9386
          37   9344
          34   9319
          36   9319
          30   9319
          44   9294
          31   9294
9445: oError 15
9447: oJumpForward 9452
9449: Choice Lookup Table
           0   9291
9452: oReturn
9453: oLocalSpace 1
9455: oGetAddrLocal 1
9457: oPushResult
9458: oTypeSNodeType
9459: oAssign
9460: oTypeSPop
9461: oGetLocal 1
9463: oPushResult
9464: oTypeSNodeType
9465: oPushResult
9466: equal_node_type
9467: oPop 2
9469: oChoice 9507
9471: oTypeSNodeType
9472: oChoice 9498
9474: oGetLocal 1
9476: oChoice 9481
9478: oReturn
9479: oJumpForward 9484
9481: Choice Lookup Table
          38   9478
9484: oJumpForward 9503
9486: oGetLocal 1
9488: oChoice 9493
9490: oReturn
9491: oJumpForward 9496
9493: Choice Lookup Table
          37   9490
9496: oJumpForward 9503
9498: Choice Lookup Table
          38   9486
          37   9474
9503: oError 15
9505: oJumpForward 9510
9507: Choice Lookup Table
           0   9471
9510: oReturn
9511: oLocalSpace 0
9513: oTypeSNodeType
9514: oChoice 9518
9516: oJumpForward 9523
9518: Choice Lookup Table
          31   9516
9521: oError 7
9523: oTypeSPop
9524: oReturn
9525: oLocalSpace 0
9527: oTypeSNodeType
9528: oChoice 9532
9530: oJumpForward 9537
9532: Choice Lookup Table
          31   9530
9535: oError 7
9537: oReturn
9538: oLocalSpace 0
9540: oTypeSNodeType
9541: oChoice 9549
9543: oJumpForward 9556
9545: oEmit 38
9547: oJumpForward 9556
9549: Choice Lookup Table
          30   9545
          31   9543
9554: oError 7
9556: oTypeSPop
9557: oReturn
9558: oLocalSpace 0
9560: oTypeSNodeType
9561: oChoice 9576
9563: oJumpForward 9583
9565: oEmit 38
9567: oTypeSPop
9568: oGetGlobal 6
9570: oPushResult
9571: oTypeSPush
9572: oPop 1
9574: oJumpForward 9583
9576: Choice Lookup Table
          30   9565
          31   9563
9581: oError 7
9583: oReturn
9584: oLocalSpace 0
9586: oTypeSNodeType
9587: oChoice 9600
9589: oEmit 38
9591: oTypeSPop
9592: oGetGlobal 6
9594: oPushResult
9595: oTypeSPush
9596: oPop 1
9598: oJumpForward 9603
9600: Choice Lookup Table
          30   9589
9603: oReturn
9604: oLocalSpace 0
9606: oTypeSNodeType
9607: oChoice 9635
9609: oJumpForward 9644
9611: oEmit 40
9613: oTypeSPop
9614: oGetGlobal 13
9616: oPushResult
9617: oTypeSPush
9618: oPop 1
9620: oJumpForward 9644
9622: oEmit 38
9624: oEmit 40
9626: oTypeSPop
9627: oGetGlobal 13
9629: oPushResult
9630: oTypeSPush
9631: oPop 1
9633: oJumpForward 9644
9635: Choice Lookup Table
          30   9622
          31   9611
          33   9609
9642: oError 9
9644: oTypeSPop
9645: oReturn
9646: oLocalSpace 0
9648: oTypeSNodeType
9649: oChoice 9653
9651: oJumpForward 9658
9653: Choice Lookup Table
          34   9651
9656: oError 8
9658: oTypeSPop
9659: oReturn
9660: oLocalSpace 0
9662: oTypeSNodeType
9663: oChoice 9667
9665: oJumpForward 9672
9667: Choice Lookup Table
          34   9665
9670: oError 8
9672: oReturn
9673: oLocalSpace 0
9675: oInputChoice 9738
9677: oCall 11410
9679: oJumpForward 9769
9681: oCall 11417
9683: oJumpForward 9769
9685: oCall 11547
9687: oJumpForward 9769
9689: oCall 11554
9691: oJumpForward 9769
9693: oCall 10561
9695: oJumpForward 9769
9697: oCall 10884
9699: oJumpForward 9769
9701: oCall 10627
9703: oJumpForward 9769
9705: oCall 10804
9707: oJumpForward 9769
9709: oCall 10969
9711: oJumpForward 9769
9713: oCall 10937
9715: oJumpForward 9769
9717: oCall 11387
9719: oJumpForward 9769
9721: oCall 9770
9723: oJumpForward 9769
9725: oCall 11001
9727: oJumpForward 9769
9729: oCall 11335
9731: oJumpForward 9769
9733: oChangeIntLitToLabelIdent
9734: oCall 9770
9736: oJumpForward 9769
9738: Choice Lookup Table
           1   9733
          56   9729
          54   9725
           0   9721
          36   9717
          52   9713
          53   9709
          50   9705
          45   9701
          49   9697
          42   9693
          69   9689
          68   9685
          67   9681
          66   9677
9769: oReturn
9770: oLocalSpace 1
9772: oGetAddrLocal 1
9774: oPushResult
9775: oScopeFindRequire
9776: oAssign
9777: oGetAddrLocal 1
9779: oPushResult
9780: oCall 244
9782: oPop 1
9784: oGetLocal 1
9786: oPushResult
9787: oNodeType
9788: oPop 1
9790: oChoice 9830
9792: oGetLocal 1
9794: oPushResult
9795: oCall 9848
9797: oPop 1
9799: oCall 9673
9801: oJumpForward 9847
9803: oGetLocal 1
9805: oPushResult
9806: oCall 11949
9808: oPop 1
9810: oJumpForward 9847
9812: oGetLocal 1
9814: oPushResult
9815: oCall 9898
9817: oPop 1
9819: oJumpForward 9847
9821: oGetLocal 1
9823: oPushResult
9824: oCall 9994
9826: oPop 1
9828: oJumpForward 9847
9830: Choice Lookup Table
          13   9821
          20   9812
          25   9812
          23   9812
          22   9812
          12   9803
          27   9792
9845: oError 0
9847: oReturn
9848: oLocalSpace 0
9850: oGetParam 1
9852: oPushResult
9853: oSetResult 36
9855: oPushResult
9856: oNodeGetBoolean
9857: oPop 2
9859: oChoice 9865
9861: oError 22
9863: oJumpForward 9868
9865: Choice Lookup Table
           1   9861
9868: oEmit 97
9870: oGetParam 1
9872: oPushResult
9873: oSetResult 22
9875: oPushResult
9876: oNodeGetLabel
9877: oPop 2
9879: oPushResult
9880: oEmitLabel
9881: oPop 1
9883: oGetParam 1
9885: oPushResult
9886: oSetResult 36
9888: oPushResult
9889: oSetResult 1
9891: oPushResult
9892: oNodeSetBoolean
9893: oPop 3
9895: oInput 13
9897: oReturn
9898: oLocalSpace 0
9900: oGetParam 1
9902: oPushResult
9903: oSetResult 1
9905: oPushResult
9906: oCall 10154
9908: oPop 2
9910: oInput 5
9912: oCall 5047
9914: oCall 8815
9916: oCall 9919
9918: oReturn
9919: oLocalSpace 1
9921: oTypeSNodeType
9922: oChoice 9966
9924: oEmit 33
9926: oJumpForward 9992
9928: oEmit 34
9930: oJumpForward 9992
9932: oEmit 36
9934: oJumpForward 9992
9936: oError 17
9938: oJumpForward 9992
9940: oEmit 35
9942: oJumpForward 9992
9944: oGetAddrLocal 1
9946: oPushResult
9947: oTypeSTop
9948: oPushResult
9949: oSetResult 17
9951: oPushResult
9952: oNodeGetInt
9953: oPop 2
9955: oAssign
9956: oEmit 37
9958: oGetLocal 1
9960: oPushResult
9961: oEmitInt
9962: oPop 1
9964: oJumpForward 9992
9966: Choice Lookup Table
          43   9944
          41   9944
          39   9944
          38   9940
          37   9940
          29   9936
          33   9932
          36   9928
          30   9928
          34   9928
          44   9924
          31   9924
9991: oEndChoice
9992: oTypeSPop
9993: oReturn
9994: oLocalSpace 1
9996: oGetParam 1
9998: oPushResult
9999: oSetResult 6
10001: oPushResult
10002: oNodeGet
10003: oPop 2
10005: oPushResult
10006: oScopeCurrent
10007: oPushResult
10008: oNodeEqual
10009: oPop 2
10011: oChoice 10017
10013: oError 21
10015: oJumpForward 10020
10017: Choice Lookup Table
           0   10013
10020: oEmit 10
10022: oGetParam 1
10024: oPushResult
10025: oSetResult 31
10027: oPushResult
10028: oNodeGetInt
10029: oPop 2
10031: oPushResult
10032: oEmitInt
10033: oPop 1
10035: oGetParam 1
10037: oPushResult
10038: oSetResult 21
10040: oPushResult
10041: oNodeGet
10042: oPop 2
10044: oPushResult
10045: oTypeSPush
10046: oPop 1
10048: oInput 5
10050: oCall 5047
10052: oCall 8815
10054: oTypeSNodeType
10055: oChoice 10099
10057: oEmit 33
10059: oJumpForward 10125
10061: oEmit 34
10063: oJumpForward 10125
10065: oEmit 36
10067: oJumpForward 10125
10069: oError 17
10071: oJumpForward 10125
10073: oEmit 35
10075: oJumpForward 10125
10077: oGetAddrLocal 1
10079: oPushResult
10080: oTypeSTop
10081: oPushResult
10082: oSetResult 17
10084: oPushResult
10085: oNodeGetInt
10086: oPop 2
10088: oAssign
10089: oEmit 37
10091: oGetLocal 1
10093: oPushResult
10094: oEmitInt
10095: oPop 1
10097: oJumpForward 10125
10099: Choice Lookup Table
          43   10077
          41   10077
          39   10077
          38   10073
          37   10073
          29   10069
          33   10065
          36   10061
          30   10061
          34   10061
          44   10057
          31   10057
10124: oEndChoice
10125: oTypeSPop
10126: oReturn
10127: oLocalSpace 1
10129: oInput 0
10131: oGetAddrLocal 1
10133: oPushResult
10134: oScopeFindRequire
10135: oAssign
10136: oGetAddrLocal 1
10138: oPushResult
10139: oCall 244
10141: oPop 1
10143: oGetLocal 1
10145: oPushResult
10146: oGetParam 1
10148: oPushResult
10149: oCall 10154
10151: oPop 2
10153: oReturn
10154: oLocalSpace 0
10156: oGetParam 2
10158: oPushResult
10159: oNodeType
10160: oPop 1
10162: oChoice 10225
10164: oGetParam 2
10166: oPushResult
10167: oGetParam 1
10169: oPushResult
10170: oCall 10371
10172: oPop 2
10174: oJumpForward 10238
10176: oGetParam 2
10178: oPushResult
10179: oSetResult 21
10181: oPushResult
10182: oNodeGet
10183: oPop 2
10185: oPushResult
10186: oTypeSPush
10187: oPop 1
10189: oInput 15
10191: oGetParam 1
10193: oPushResult
10194: oCall 10127
10196: oPop 1
10198: oInput 16
10200: oCall 10239
10202: oTypeSNodeType
10203: oChoice 10218
10205: oInputChoice 10213
10207: oEmit 31
10209: oCall 8393
10211: oJumpForward 10216
10213: Choice Lookup Table
          17   10207
10216: oJumpForward 10221
10218: Choice Lookup Table
          37   10205
10221: oCall 8198
10223: oJumpForward 10238
10225: Choice Lookup Table
          20   10176
          26   10164
          25   10164
          23   10164
          22   10164
10236: oError 4
10238: oReturn
10239: oLocalSpace 1
10241: oGetAddrLocal 1
10243: oPushResult
10244: oTypeSNodeType
10245: oAssign
10246: oTypeSPop
10247: oGetLocal 1
10249: oPushResult
10250: oTypeSNodeType
10251: oPushResult
10252: equal_node_type
10253: oPop 2
10255: oChoice 10367
10257: oTypeSNodeType
10258: oChoice 10346
10260: oGetLocal 1
10262: oChoice 10272
10264: oError 32
10266: oReturn
10267: oJumpForward 10283
10269: oReturn
10270: oJumpForward 10283
10272: Choice Lookup Table
          44   10269
          31   10269
          34   10264
          36   10264
          30   10264
10283: oJumpForward 10363
10285: oGetLocal 1
10287: oChoice 10297
10289: oReturn
10290: oJumpForward 10308
10292: oError 32
10294: oReturn
10295: oJumpForward 10308
10297: Choice Lookup Table
          44   10292
          31   10292
          34   10289
          36   10289
          30   10289
10308: oJumpForward 10363
10310: oGetLocal 1
10312: oChoice 10317
10314: oReturn
10315: oJumpForward 10320
10317: Choice Lookup Table
          38   10314
10320: oJumpForward 10363
10322: oGetLocal 1
10324: oChoice 10329
10326: oReturn
10327: oJumpForward 10332
10329: Choice Lookup Table
          37   10326
10332: oJumpForward 10363
10334: oGetLocal 1
10336: oChoice 10341
10338: oReturn
10339: oJumpForward 10344
10341: Choice Lookup Table
          42   10338
10344: oJumpForward 10363
10346: Choice Lookup Table
          43   10334
          38   10322
          37   10310
          34   10285
          36   10285
          30   10285
          44   10260
          31   10260
10363: oError 15
10365: oJumpForward 10370
10367: Choice Lookup Table
           0   10257
10370: oReturn
10371: oLocalSpace 0
10373: oGetParam 2
10375: oPushResult
10376: oNodeType
10377: oPop 1
10379: oChoice 10461
10381: oEmit 22
10383: oGetParam 2
10385: oPushResult
10386: oCall 15000
10388: oPop 1
10390: oJumpForward 10472
10392: oEmit 23
10394: oGetParam 2
10396: oPushResult
10397: oCall 15000
10399: oPop 1
10401: oJumpForward 10472
10403: oGetParam 2
10405: oPushResult
10406: oSetResult 35
10408: oPushResult
10409: oNodeGetBoolean
10410: oPop 2
10412: oChoice 10425
10414: oEmit 10
10416: oGetParam 2
10418: oPushResult
10419: oCall 15000
10421: oPop 1
10423: oJumpForward 10437
10425: Choice Lookup Table
           1   10414
10428: oEmit 24
10430: oGetParam 2
10432: oPushResult
10433: oCall 15000
10435: oPop 1
10437: oJumpForward 10472
10439: oGetParam 1
10441: oChoice 10454
10443: oEmit 22
10445: oGetParam 2
10447: oPushResult
10448: oCall 15000
10450: oPop 1
10452: oJumpForward 10459
10454: Choice Lookup Table
           0   10443
10457: oError 4
10459: oJumpForward 10472
10461: Choice Lookup Table
          26   10439
          25   10403
          23   10392
          22   10381
10470: oError 4
10472: oGetParam 2
10474: oPushResult
10475: oSetResult 21
10477: oPushResult
10478: oNodeGet
10479: oPop 2
10481: oPushResult
10482: oTypeSPush
10483: oPop 1
10485: oTypeSNodeType
10486: oChoice 10501
10488: oInputChoice 10496
10490: oEmit 31
10492: oCall 8393
10494: oJumpForward 10499
10496: Choice Lookup Table
          17   10490
10499: oJumpForward 10504
10501: Choice Lookup Table
          37   10488
10504: oCall 8198
10506: oReturn
10507: oLocalSpace 0
10509: oGetParam 1
10511: oPushResult
10512: oSetResult 1
10514: oPushResult
10515: oCall 10371
10517: oPop 2
10519: oCall 9511
10521: oGetParam 1
10523: oPushResult
10524: oCall 7215
10526: oPop 1
10528: oTypeSPop
10529: oEmit 41
10531: oEmit 33
10533: oReturn
10534: oLocalSpace 0
10536: oGetParam 1
10538: oPushResult
10539: oSetResult 1
10541: oPushResult
10542: oCall 10371
10544: oPop 2
10546: oCall 9511
10548: oGetParam 1
10550: oPushResult
10551: oCall 7215
10553: oPop 1
10555: oTypeSPop
10556: oEmit 42
10558: oEmit 33
10560: oReturn
10561: oLocalSpace 2
10563: oGetAddrLocal 1
10565: oPushResult
10566: oSetResult 0
10568: oAssign
10569: oGetAddrLocal 1
10571: oPushResult
10572: oCall 5093
10574: oPop 1
10576: oInput 43
10578: oCall 9673
10580: oInputChoice 10615
10582: oGetAddrLocal 2
10584: oPushResult
10585: oLabelNew
10586: oAssign
10587: oEmit 88
10589: oGetLocal 2
10591: oPushResult
10592: oEmitLabel
10593: oPop 1
10595: oEmit 97
10597: oGetLocal 1
10599: oPushResult
10600: oEmitLabel
10601: oPop 1
10603: oCall 9673
10605: oEmit 97
10607: oGetLocal 2
10609: oPushResult
10610: oEmitLabel
10611: oPop 1
10613: oJumpForward 10626
10615: Choice Lookup Table
          44   10582
10618: oEmit 97
10620: oGetLocal 1
10622: oPushResult
10623: oEmitLabel
10624: oPop 1
10626: oReturn
10627: oLocalSpace 4
10629: oInput 0
10631: oGetAddrLocal 1
10633: oPushResult
10634: oScopeFindRequire
10635: oAssign
10636: oGetLocal 1
10638: oPushResult
10639: oSetResult 1
10641: oPushResult
10642: oCall 10371
10644: oPop 2
10646: oCall 9511
10648: oInput 5
10650: oCall 5047
10652: oCall 9511
10654: oEmit 33
10656: oGetAddrLocal 2
10658: oPushResult
10659: oLabelNew
10660: oAssign
10661: oGetAddrLocal 3
10663: oPushResult
10664: oLabelNew
10665: oAssign
10666: oEmit 88
10668: oGetLocal 3
10670: oPushResult
10671: oEmitLabel
10672: oPop 1
10674: oGetAddrLocal 4
10676: oPushResult
10677: oLabelNew
10678: oAssign
10679: oEmit 97
10681: oGetLocal 4
10683: oPushResult
10684: oEmitLabel
10685: oPop 1
10687: oInputChoice 10767
10689: oGetLocal 1
10691: oPushResult
10692: oCall 10507
10694: oPop 1
10696: oEmit 97
10698: oGetLocal 3
10700: oPushResult
10701: oEmitLabel
10702: oPop 1
10704: oGetLocal 1
10706: oPushResult
10707: oCall 7215
10709: oPop 1
10711: oTypeSPop
10712: oCall 5047
10714: oCall 9511
10716: oEmit 65
10718: oEmit 89
10720: oGetLocal 2
10722: oPushResult
10723: oEmitLabel
10724: oPop 1
10726: oJumpForward 10773
10728: oGetLocal 1
10730: oPushResult
10731: oCall 10534
10733: oPop 1
10735: oEmit 97
10737: oGetLocal 3
10739: oPushResult
10740: oEmitLabel
10741: oPop 1
10743: oGetLocal 1
10745: oPushResult
10746: oCall 7215
10748: oPop 1
10750: oTypeSPop
10751: oCall 5047
10753: oCall 9511
10755: oEmit 66
10757: oEmit 89
10759: oGetLocal 2
10761: oPushResult
10762: oEmitLabel
10763: oPop 1
10765: oJumpForward 10773
10767: Choice Lookup Table
          47   10728
          46   10689
10772: oEndChoice
10773: oGetLocal 4
10775: oPushResult
10776: oGetLocal 2
10778: oPushResult
10779: oLoopPush
10780: oPop 2
10782: oInput 48
10784: oCall 9673
10786: oEmit 88
10788: oGetLocal 4
10790: oPushResult
10791: oEmitLabel
10792: oPop 1
10794: oEmit 97
10796: oGetLocal 2
10798: oPushResult
10799: oEmitLabel
10800: oPop 1
10802: oLoopPop
10803: oReturn
10804: oLocalSpace 3
10806: oGetAddrLocal 1
10808: oPushResult
10809: oLabelNew
10810: oAssign
10811: oEmit 97
10813: oGetLocal 1
10815: oPushResult
10816: oEmitLabel
10817: oPop 1
10819: oGetAddrLocal 2
10821: oPushResult
10822: oLabelNew
10823: oAssign
10824: oGetLocal 1
10826: oPushResult
10827: oGetLocal 2
10829: oPushResult
10830: oLoopPush
10831: oPop 2
10833: oCall 9673
10835: oInputChoice 10866
10837: oCall 9673
10839: oJumpForward 10872
10841: oGetAddrLocal 3
10843: oPushResult
10844: oCall 5093
10846: oPop 1
10848: oEmit 98
10850: oGetLocal 3
10852: oPushResult
10853: oEmitLabel
10854: oPop 1
10856: oGetLocal 1
10858: oPushResult
10859: oEmitLabel
10860: oPop 1
10862: oJumpForward 10874
10864: oJumpForward 10872
10866: Choice Lookup Table
          51   10841
           6   10837
10871: oEndChoice
10872: oJumpBack 10835
10874: oEmit 97
10876: oGetLocal 2
10878: oPushResult
10879: oEmitLabel
10880: oPop 1
10882: oLoopPop
10883: oReturn
10884: oLocalSpace 2
10886: oGetAddrLocal 1
10888: oPushResult
10889: oLabelNew
10890: oAssign
10891: oEmit 97
10893: oGetLocal 1
10895: oPushResult
10896: oEmitLabel
10897: oPop 1
10899: oGetAddrLocal 2
10901: oPushResult
10902: oCall 5093
10904: oPop 1
10906: oGetLocal 1
10908: oPushResult
10909: oGetLocal 2
10911: oPushResult
10912: oLoopPush
10913: oPop 2
10915: oInput 48
10917: oCall 9673
10919: oEmit 88
10921: oGetLocal 1
10923: oPushResult
10924: oEmitLabel
10925: oPop 1
10927: oEmit 97
10929: oGetLocal 2
10931: oPushResult
10932: oEmitLabel
10933: oPop 1
10935: oLoopPop
10936: oReturn
10937: oLocalSpace 0
10939: oLoopContinueLabel
10940: oPushResult
10941: oSetResult 0
10943: oPushResult
10944: equal_label
10945: oPop 2
10947: oChoice 10962
10949: oError 19
10951: oJumpForward 10968
10953: oEmit 88
10955: oLoopContinueLabel
10956: oPushResult
10957: oEmitLabel
10958: oPop 1
10960: oJumpForward 10968
10962: Choice Lookup Table
           0   10953
           1   10949
10967: oEndChoice
10968: oReturn
10969: oLocalSpace 0
10971: oLoopBreakLabel
10972: oPushResult
10973: oSetResult 0
10975: oPushResult
10976: equal_label
10977: oPop 2
10979: oChoice 10994
10981: oError 19
10983: oJumpForward 11000
10985: oEmit 88
10987: oLoopBreakLabel
10988: oPushResult
10989: oEmitLabel
10990: oPop 1
10992: oJumpForward 11000
10994: Choice Lookup Table
           0   10985
           1   10981
10999: oEndChoice
11000: oReturn
11001: oLocalSpace 8
11003: oGetAddrLocal 1
11005: oPushResult
11006: oCodeNew
11007: oAssign
11008: oGetAddrLocal 2
11010: oPushResult
11011: oLabelNew
11012: oAssign
11013: oGetAddrLocal 3
11015: oPushResult
11016: oLabelNew
11017: oAssign
11018: oGetAddrLocal 4
11020: oPushResult
11021: oGetLocal 3
11023: oAssign
11024: oGetAddrLocal 5
11026: oPushResult
11027: oSetResult 0
11029: oAssign
11030: oCall 5047
11032: oTypeSNodeType
11033: oChoice 11071
11035: oEmit 91
11037: oGetLocal 2
11039: oPushResult
11040: oEmitLabel
11041: oPop 1
11043: oJumpForward 11088
11045: oEmit 92
11047: oGetLocal 2
11049: oPushResult
11050: oEmitLabel
11051: oPop 1
11053: oJumpForward 11088
11055: oGetAddrLocal 5
11057: oPushResult
11058: oSetResult 1
11060: oAssign
11061: oEmit 93
11063: oGetLocal 2
11065: oPushResult
11066: oEmitLabel
11067: oPop 1
11069: oJumpForward 11088
11071: Choice Lookup Table
          42   11055
          43   11055
          44   11045
          31   11045
          36   11035
          30   11035
          34   11035
11086: oError 18
11088: oInput 41
11090: oInputChoice 11137
11092: oGetAddrLocal 4
11094: oPushResult
11095: oLabelNew
11096: oAssign
11097: oEmit 97
11099: oGetLocal 4
11101: oPushResult
11102: oEmitLabel
11103: oPop 1
11105: oInputChoice 11111
11107: oJumpForward 11129
11109: oJumpForward 11127
11111: Choice Lookup Table
          37   11107
11114: oCall 9673
11116: oInputChoice 11120
11118: oJumpForward 11127
11120: Choice Lookup Table
           6   11118
11123: oInput 37
11125: oJumpForward 11129
11127: oJumpBack 11105
11129: oJumpForward 11303
11131: oJumpForward 11301
11133: oJumpForward 11303
11135: oJumpForward 11301
11137: Choice Lookup Table
          37   11133
          44   11092
          55   11092
11144: oGetAddrLocal 6
11146: oPushResult
11147: oLabelNew
11148: oAssign
11149: oGetLocal 1
11151: oPushResult
11152: oCodePush
11153: oPop 1
11155: oCall 3586
11157: oCall 4478
11159: oGetLocal 5
11161: oChoice 11181
11163: oGetAddrLocal 7
11165: oPushResult
11166: oValueTopString
11167: oPushResult
11168: oStringAllocShortStringLit
11169: oPop 1
11171: oAssign
11172: oJumpForward 11187
11174: oGetAddrLocal 7
11176: oPushResult
11177: oValueTop
11178: oAssign
11179: oJumpForward 11187
11181: Choice Lookup Table
           0   11174
           1   11163
11186: oEndChoice
11187: oValuePop
11188: oInputChoice 11245
11190: oCall 3586
11192: oCall 4478
11194: oGetLocal 5
11196: oChoice 11216
11198: oGetAddrLocal 8
11200: oPushResult
11201: oValueTopString
11202: oPushResult
11203: oStringAllocShortStringLit
11204: oPop 1
11206: oAssign
11207: oJumpForward 11222
11209: oGetAddrLocal 8
11211: oPushResult
11212: oValueTop
11213: oAssign
11214: oJumpForward 11222
11216: Choice Lookup Table
           0   11209
           1   11198
11221: oEndChoice
11222: oValuePop
11223: oEmit 95
11225: oGetLocal 7
11227: oPushResult
11228: oEmitInt
11229: oPop 1
11231: oGetLocal 8
11233: oPushResult
11234: oEmitInt
11235: oPop 1
11237: oGetLocal 6
11239: oPushResult
11240: oEmitLabel
11241: oPop 1
11243: oJumpForward 11262
11245: Choice Lookup Table
          22   11190
11248: oEmit 94
11250: oGetLocal 7
11252: oPushResult
11253: oEmitInt
11254: oPop 1
11256: oGetLocal 6
11258: oPushResult
11259: oEmitLabel
11260: oPop 1
11262: oInputChoice 11266
11264: oJumpForward 11271
11266: Choice Lookup Table
          14   11264
11269: oJumpForward 11273
11271: oJumpBack 11155
11273: oCodePop
11274: oInput 13
11276: oEmit 97
11278: oGetLocal 6
11280: oPushResult
11281: oEmitLabel
11282: oPop 1
11284: oCall 9673
11286: oEmit 88
11288: oGetLocal 3
11290: oPushResult
11291: oEmitLabel
11292: oPop 1
11294: oInputChoice 11298
11296: oJumpForward 11301
11298: Choice Lookup Table
           6   11296
11301: oJumpBack 11090
11303: oEmit 97
11305: oGetLocal 2
11307: oPushResult
11308: oEmitLabel
11309: oPop 1
11311: oGetLocal 1
11313: oPushResult
11314: oEmitCode
11315: oPop 1
11317: oEmit 96
11319: oGetLocal 4
11321: oPushResult
11322: oEmitLabel
11323: oPop 1
11325: oEmit 97
11327: oGetLocal 3
11329: oPushResult
11330: oEmitLabel
11331: oPop 1
11333: oTypeSPop
11334: oReturn
11335: oLocalSpace 1
11337: oInputChoice 11344
11339: oJumpForward 11350
11341: oChangeIntLitToLabelIdent
11342: oJumpForward 11350
11344: Choice Lookup Table
           1   11341
           0   11339
11349: oEndChoice
11350: oGetAddrLocal 1
11352: oPushResult
11353: oScopeCurrent
11354: oPushResult
11355: oScopeFindRequireInScope
11356: oPop 1
11358: oAssign
11359: oGetLocal 1
11361: oPushResult
11362: oSetResult 28
11364: oPushResult
11365: oSetResult 1
11367: oPushResult
11368: oNodeSetBoolean
11369: oPop 3
11371: oEmit 88
11373: oGetLocal 1
11375: oPushResult
11376: oSetResult 22
11378: oPushResult
11379: oNodeGetLabel
11380: oPop 2
11382: oPushResult
11383: oEmitLabel
11384: oPop 1
11386: oReturn
11387: oLocalSpace 0
11389: oCall 9673
11391: oInputChoice 11401
11393: oCall 9673
11395: oJumpForward 11407
11397: oJumpForward 11409
11399: oJumpForward 11407
11401: Choice Lookup Table
          37   11397
           6   11393
11406: oEndChoice
11407: oJumpBack 11391
11409: oReturn
11410: oLocalSpace 0
11412: oCall 11417
11414: oEmit 108
11416: oReturn
11417: oLocalSpace 0
11419: oInputChoice 11543
11421: oCall 5047
11423: oTypeSNodeType
11424: oChoice 11499
11426: oEmit 100
11428: oJumpForward 11524
11430: oEmit 101
11432: oJumpForward 11524
11434: oEmit 38
11436: oEmit 100
11438: oJumpForward 11524
11440: oEmit 102
11442: oJumpForward 11524
11444: oEmit 107
11446: oJumpForward 11524
11448: oEmit 103
11450: oJumpForward 11524
11452: oError 17
11454: oJumpForward 11524
11456: oEmit 22
11458: oTypeSTop
11459: oPushResult
11460: oSetResult 44
11462: oPushResult
11463: oNodeGetInt
11464: oPop 2
11466: oPushResult
11467: oEmitInt
11468: oPop 1
11470: oEmit 106
11472: oJumpForward 11524
11474: oTypeSTop
11475: oPushResult
11476: oGetGlobal 10
11478: oPushResult
11479: equal_node
11480: oPop 2
11482: oChoice 11488
11484: oEmit 104
11486: oJumpForward 11493
11488: Choice Lookup Table
           1   11484
11491: oEmit 105
11493: oJumpForward 11524
11495: oEmit 105
11497: oJumpForward 11524
11499: Choice Lookup Table
          38   11495
          37   11474
          44   11456
          29   11452
          42   11448
          43   11448
          33   11444
          36   11440
          30   11434
          34   11430
          31   11426
11522: oError 18
11524: oTypeSPop
11525: oInputChoice 11533
11527: oJumpForward 11541
11529: oJumpForward 11539
11531: oJumpForward 11539
11533: Choice Lookup Table
          14   11531
          16   11527
11538: oEndChoice
11539: oJumpBack 11421
11541: oJumpForward 11546
11543: Choice Lookup Table
          15   11421
11546: oReturn
11547: oLocalSpace 0
11549: oCall 11554
11551: oEmit 112
11553: oReturn
11554: oLocalSpace 1
11556: oInputChoice 11633
11558: oSetResult 1
11560: oPushResult
11561: oCall 10127
11563: oPop 1
11565: oTypeSNodeType
11566: oChoice 11605
11568: oEmit 109
11570: oJumpForward 11614
11572: oEmit 110
11574: oJumpForward 11614
11576: oGetAddrLocal 1
11578: oPushResult
11579: oTypeSTop
11580: oPushResult
11581: oSetResult 17
11583: oPushResult
11584: oNodeGetInt
11585: oPop 2
11587: oPushResult
11588: oSetResult 1
11590: oPushResult
11591: subtract
11592: oPop 2
11594: oAssign
11595: oEmit 111
11597: oGetLocal 1
11599: oPushResult
11600: oEmitInt
11601: oPop 1
11603: oJumpForward 11614
11605: Choice Lookup Table
          43   11576
          36   11572
          31   11568
11612: oError 18
11614: oTypeSPop
11615: oInputChoice 11623
11617: oJumpForward 11631
11619: oJumpForward 11629
11621: oJumpForward 11629
11623: Choice Lookup Table
          14   11621
          16   11617
11628: oEndChoice
11629: oJumpBack 11558
11631: oJumpForward 11636
11633: Choice Lookup Table
          15   11558
11636: oReturn
11637: oLocalSpace 1
11639: oGetAddrLocal 1
11641: oPushResult
11642: oGetGlobal 16
11644: oPushResult
11645: oScopeAllocType
11646: oPop 1
11648: oAssign
11649: oTypeSNodeType
11650: oChoice 11718
11652: oEmit 23
11654: oGetLocal 1
11656: oPushResult
11657: oEmitInt
11658: oPop 1
11660: oEmit 28
11662: oEmit 37
11664: oGetGlobal 16
11666: oPushResult
11667: oSetResult 17
11669: oPushResult
11670: oNodeGetInt
11671: oPop 2
11673: oPushResult
11674: oEmitInt
11675: oPop 1
11677: oJumpForward 11727
11679: oEmit 23
11681: oGetLocal 1
11683: oPushResult
11684: oEmitInt
11685: oPop 1
11687: oEmit 20
11689: oSetResult 1
11691: oPushResult
11692: oEmitInt
11693: oPop 1
11695: oEmit 34
11697: oEmit 23
11699: oGetLocal 1
11701: oPushResult
11702: oSetResult 1
11704: oPushResult
11705: add
11706: oPop 2
11708: oPushResult
11709: oEmitInt
11710: oPop 1
11712: oEmit 28
11714: oEmit 34
11716: oJumpForward 11727
11718: Choice Lookup Table
          36   11679
          42   11652
          43   11652
11725: oError 15
11727: oTypeSPop
11728: oEmit 23
11730: oGetLocal 1
11732: oPushResult
11733: oEmitInt
11734: oPop 1
11736: oGetGlobal 16
11738: oPushResult
11739: oTypeSPush
11740: oPop 1
11742: oGetLocal 1
11744: oReturn
11745: oReturn
11746: oLocalSpace 0
11748: oEmit 81
11750: oSetResult 16
11752: oPushResult
11753: oEmitInt
11754: oPop 1
11756: oEmit 25
11758: oSetResult 8
11760: oPushResult
11761: oEmitInt
11762: oPop 1
11764: oEmit 28
11766: oEmit 35
11768: oEmit 25
11770: oSetResult 0
11772: oPushResult
11773: oEmitInt
11774: oPop 1
11776: oEmit 28
11778: oEmit 35
11780: oEmit 84
11782: oGetGlobal 22
11784: oPushResult
11785: oCall 15000
11787: oPop 1
11789: oEmit 83
11791: oSetResult 16
11793: oPushResult
11794: oEmitInt
11795: oPop 1
11797: oTypeSPop
11798: oTypeSPop
11799: oReturn
11800: oLocalSpace 0
11802: oEmit 81
11804: oSetResult 12
11806: oPushResult
11807: oEmitInt
11808: oPop 1
11810: oEmit 25
11812: oSetResult 8
11814: oPushResult
11815: oEmitInt
11816: oPop 1
11818: oEmit 28
11820: oEmit 34
11822: oEmit 25
11824: oSetResult 0
11826: oPushResult
11827: oEmitInt
11828: oPop 1
11830: oEmit 28
11832: oEmit 35
11834: oEmit 84
11836: oGetGlobal 23
11838: oPushResult
11839: oCall 15000
11841: oPop 1
11843: oEmit 83
11845: oSetResult 12
11847: oPushResult
11848: oEmitInt
11849: oPop 1
11851: oTypeSPop
11852: oTypeSPop
11853: oReturn
11854: oLocalSpace 1
11856: oEmit 82
11858: oSetResult 24
11860: oPushResult
11861: oEmitInt
11862: oPop 1
11864: oEmit 25
11866: oSetResult 8
11868: oPushResult
11869: oEmitInt
11870: oPop 1
11872: oEmit 28
11874: oEmit 35
11876: oEmit 25
11878: oSetResult 0
11880: oPushResult
11881: oEmitInt
11882: oPop 1
11884: oEmit 28
11886: oEmit 35
11888: oGetAddrLocal 1
11890: oPushResult
11891: oGetGlobal 6
11893: oPushResult
11894: oScopeAllocType
11895: oPop 1
11897: oAssign
11898: oEmit 25
11900: oSetResult 16
11902: oPushResult
11903: oEmitInt
11904: oPop 1
11906: oEmit 23
11908: oGetLocal 1
11910: oPushResult
11911: oEmitInt
11912: oPop 1
11914: oEmit 35
11916: oEmit 85
11918: oGetGlobal 24
11920: oPushResult
11921: oCall 15000
11923: oPop 1
11925: oEmit 4
11927: oGetLocal 1
11929: oPushResult
11930: oEmitInt
11931: oPop 1
11933: oEmit 83
11935: oSetResult 24
11937: oPushResult
11938: oEmitInt
11939: oPop 1
11941: oTypeSPop
11942: oGetGlobal 6
11944: oPushResult
11945: oTypeSPush
11946: oPop 1
11948: oReturn
11949: oLocalSpace 10
11951: oGetParam 1
11953: oPushResult
11954: oSetResult 28
11956: oPushResult
11957: oSetResult 1
11959: oPushResult
11960: oNodeSetBoolean
11961: oPop 3
11963: oGetAddrLocal 1
11965: oPushResult
11966: oGetParam 1
11968: oPushResult
11969: oSetResult 27
11971: oPushResult
11972: oNodeGetBoolean
11973: oPop 2
11975: oAssign
11976: oGetAddrLocal 4
11978: oPushResult
11979: oGetParam 1
11981: oPushResult
11982: oNodeType
11983: oPop 1
11985: oPushResult
11986: oSetResult 13
11988: oPushResult
11989: equal_node_type
11990: oPop 2
11992: oAssign
11993: oGetLocal 4
11995: oChoice 12022
11997: oGetAddrLocal 2
11999: oPushResult
12000: oGetParam 1
12002: oPushResult
12003: oSetResult 21
12005: oPushResult
12006: oNodeGet
12007: oPop 2
12009: oAssign
12010: oGetAddrLocal 3
12012: oPushResult
12013: oGetLocal 2
12015: oPushResult
12016: oScopeAllocType
12017: oPop 1
12019: oAssign
12020: oJumpForward 12025
12022: Choice Lookup Table
           1   11997
12025: oGetAddrLocal 5
12027: oPushResult
12028: oGetParam 1
12030: oPushResult
12031: oSetResult 23
12033: oPushResult
12034: oNodeGet
12035: oPop 2
12037: oAssign
12038: oGetAddrLocal 6
12040: oPushResult
12041: oGetLocal 5
12043: oPushResult
12044: oSetResult 17
12046: oPushResult
12047: oNodeGetInt
12048: oPop 2
12050: oAssign
12051: oGetLocal 1
12053: oChoice 12075
12055: oEmit 82
12057: oGetLocal 6
12059: oPushResult
12060: oEmitInt
12061: oPop 1
12063: oJumpForward 12081
12065: oEmit 81
12067: oGetLocal 6
12069: oPushResult
12070: oEmitInt
12071: oPop 1
12073: oJumpForward 12081
12075: Choice Lookup Table
           0   12065
           1   12055
12080: oEndChoice
12081: oGetParam 1
12083: oPushResult
12084: oCall 14934
12086: oPop 1
12088: oPushResult
12089: oSetResult 0
12091: oPushResult
12092: greater
12093: oPop 2
12095: oChoice 12128
12097: oEmit 25
12099: oSetResult 0
12101: oPushResult
12102: oEmitInt
12103: oPop 1
12105: oEmit 26
12107: oGetParam 1
12109: oPushResult
12110: oCall 14954
12112: oPop 1
12114: oPushResult
12115: oEmitInt
12116: oPop 1
12118: oSetResult 0
12120: oPushResult
12121: oEmitInt
12122: oPop 1
12124: oEmit 35
12126: oJumpForward 12131
12128: Choice Lookup Table
           1   12097
12131: oGetAddrLocal 7
12133: oPushResult
12134: oGetLocal 5
12136: oPushResult
12137: oSetResult 15
12139: oPushResult
12140: oNodeGetIter
12141: oPop 2
12143: oAssign
12144: oGetAddrLocal 8
12146: oPushResult
12147: oGetLocal 7
12149: oPushResult
12150: oNodeIterValue
12151: oPop 1
12153: oAssign
12154: oInputChoice 12357
12156: oGetLocal 8
12158: oPushResult
12159: oNodeNull
12160: oPop 1
12162: oChoice 12168
12164: oJumpForward 12353
12166: oJumpForward 12171
12168: Choice Lookup Table
           1   12164
12171: oGetAddrLocal 9
12173: oPushResult
12174: oGetLocal 8
12176: oPushResult
12177: oSetResult 22
12179: oPushResult
12180: oNodeGetInt
12181: oPop 2
12183: oAssign
12184: oEmit 25
12186: oGetLocal 9
12188: oPushResult
12189: oEmitInt
12190: oPop 1
12192: oGetLocal 8
12194: oPushResult
12195: oSetResult 21
12197: oPushResult
12198: oNodeGet
12199: oPop 2
12201: oPushResult
12202: oTypeSPush
12203: oPop 1
12205: oGetLocal 8
12207: oPushResult
12208: oSetResult 35
12210: oPushResult
12211: oNodeGetBoolean
12212: oPop 2
12214: oChoice 12306
12216: oSetResult 1
12218: oPushResult
12219: oCall 10127
12221: oPop 1
12223: oCall 9453
12225: oEmit 35
12227: oJumpForward 12312
12229: oCall 5047
12231: oCall 8815
12233: oTypeSNodeType
12234: oChoice 12278
12236: oEmit 33
12238: oJumpForward 12304
12240: oEmit 34
12242: oJumpForward 12304
12244: oEmit 36
12246: oJumpForward 12304
12248: oError 17
12250: oJumpForward 12304
12252: oEmit 35
12254: oJumpForward 12304
12256: oGetAddrLocal 10
12258: oPushResult
12259: oTypeSTop
12260: oPushResult
12261: oSetResult 17
12263: oPushResult
12264: oNodeGetInt
12265: oPop 2
12267: oAssign
12268: oEmit 37
12270: oGetLocal 10
12272: oPushResult
12273: oEmitInt
12274: oPop 1
12276: oJumpForward 12304
12278: Choice Lookup Table
          43   12256
          41   12256
          39   12256
          38   12252
          37   12252
          29   12248
          33   12244
          36   12240
          30   12240
          34   12240
          44   12236
          31   12236
12303: oEndChoice
12304: oJumpForward 12312
12306: Choice Lookup Table
           0   12229
           1   12216
12311: oEndChoice
12312: oTypeSPop
12313: oGetAddrLocal 7
12315: oPushResult
12316: oNodeIterNext
12317: oPop 1
12319: oGetAddrLocal 8
12321: oPushResult
12322: oGetLocal 7
12324: oPushResult
12325: oNodeIterValue
12326: oPop 1
12328: oAssign
12329: oGetLocal 8
12331: oPushResult
12332: oNodeNull
12333: oPop 1
12335: oChoice 12343
12337: oJumpForward 12353
12339: oJumpForward 12349
12341: oJumpForward 12349
12343: Choice Lookup Table
           0   12341
           1   12337
12348: oEndChoice
12349: oInput 14
12351: oJumpBack 12156
12353: oInput 16
12355: oJumpForward 12360
12357: Choice Lookup Table
          15   12156
12360: oGetLocal 8
12362: oPushResult
12363: oNodeNull
12364: oPop 1
12366: oChoice 12372
12368: oError 16
12370: oJumpForward 12375
12372: Choice Lookup Table
           0   12368
12375: oGetLocal 4
12377: oChoice 12406
12379: oEmit 25
12381: oGetParam 1
12383: oPushResult
12384: oSetResult 31
12386: oPushResult
12387: oNodeGetInt
12388: oPop 2
12390: oPushResult
12391: oEmitInt
12392: oPop 1
12394: oEmit 23
12396: oGetLocal 3
12398: oPushResult
12399: oEmitInt
12400: oPop 1
12402: oEmit 35
12404: oJumpForward 12409
12406: Choice Lookup Table
           1   12379
12409: oGetLocal 1
12411: oChoice 12435
12413: oEmit 85
12415: oGetParam 1
12417: oPushResult
12418: oCall 15000
12420: oPop 1
12422: oJumpForward 12441
12424: oEmit 84
12426: oGetParam 1
12428: oPushResult
12429: oCall 15000
12431: oPop 1
12433: oJumpForward 12441
12435: Choice Lookup Table
           0   12424
           1   12413
12440: oEndChoice
12441: oGetLocal 4
12443: oChoice 12536
12445: oGetLocal 2
12447: oPushResult
12448: oTypeSPush
12449: oPop 1
12451: oTypeSNodeType
12452: oChoice 12508
12454: oEmit 4
12456: oGetLocal 3
12458: oPushResult
12459: oEmitInt
12460: oPop 1
12462: oJumpForward 12534
12464: oEmit 5
12466: oGetLocal 3
12468: oPushResult
12469: oEmitInt
12470: oPop 1
12472: oJumpForward 12534
12474: oEmit 7
12476: oGetLocal 3
12478: oPushResult
12479: oEmitInt
12480: oPop 1
12482: oJumpForward 12534
12484: oError 17
12486: oJumpForward 12534
12488: oEmit 6
12490: oGetLocal 3
12492: oPushResult
12493: oEmitInt
12494: oPop 1
12496: oJumpForward 12534
12498: oEmit 23
12500: oGetLocal 3
12502: oPushResult
12503: oEmitInt
12504: oPop 1
12506: oJumpForward 12534
12508: Choice Lookup Table
          43   12498
          41   12498
          39   12498
          38   12488
          37   12488
          29   12484
          33   12474
          36   12464
          30   12464
          34   12464
          44   12454
          31   12454
12533: oEndChoice
12534: oJumpForward 12539
12536: Choice Lookup Table
           1   12445
12539: oEmit 83
12541: oGetLocal 6
12543: oPushResult
12544: oEmitInt
12545: oPop 1
12547: oReturn
12548: oLocalSpace 2
12550: oGetAddrLocal 2
12552: oPushResult
12553: oGetParam 1
12555: oPushResult
12556: oSetResult 26
12558: oPushResult
12559: oNodeGetString
12560: oPop 2
12562: oAssign
12563: oGetLocal 2
12565: oPushResult
12566: oSetResult 0
12568: oPushResult
12569: equal_string
12570: oPop 2
12572: oChoice 12609
12574: oGetAddrLocal 1
12576: oPushResult
12577: oGetParam 1
12579: oPushResult
12580: oSetResult 4
12582: oPushResult
12583: oNodeGetInt
12584: oPop 2
12586: oPushResult
12587: ID_STRING
12588: oPop 1
12590: oPushResult
12591: oStringAllocLit
12592: oPop 1
12594: oAssign
12595: oJumpForward 12615
12597: oGetAddrLocal 1
12599: oPushResult
12600: oGetLocal 2
12602: oPushResult
12603: oStringAllocLit
12604: oPop 1
12606: oAssign
12607: oJumpForward 12615
12609: Choice Lookup Table
           0   12597
           1   12574
12614: oEndChoice
12615: oEmit 99
12617: oGetParam 1
12619: oPushResult
12620: oCall 15000
12622: oPop 1
12624: oGetLocal 1
12626: oPushResult
12627: oEmitInt
12628: oPop 1
12630: oReturn
12631: oLocalSpace 2
12633: oGetParam 1
12635: oPushResult
12636: oGetGlobal 17
12638: oPushResult
12639: oNodeEqual
12640: oPop 2
12642: oChoice 12682
12644: oInput 15
12646: oCall 5047
12648: oTypeSNodeType
12649: oChoice 12657
12651: oJumpForward 12670
12653: oEmit 38
12655: oJumpForward 12670
12657: Choice Lookup Table
          36   12653
          30   12653
          34   12653
          44   12651
          31   12651
12668: oError 15
12670: oTypeSPop
12671: oGetGlobal 6
12673: oPushResult
12674: oTypeSPush
12675: oPop 1
12677: oInput 16
12679: oReturn
12680: oJumpForward 12685
12682: Choice Lookup Table
           1   12644
12685: oGetParam 1
12687: oPushResult
12688: oGetGlobal 18
12690: oPushResult
12691: oNodeEqual
12692: oPop 2
12694: oChoice 12728
12696: oInput 15
12698: oCall 5047
12700: oTypeSNodeType
12701: oChoice 12709
12703: oEmit 39
12705: oJumpForward 12716
12707: oJumpForward 12716
12709: Choice Lookup Table
          30   12707
          31   12703
12714: oError 15
12716: oTypeSPop
12717: oGetGlobal 9
12719: oPushResult
12720: oTypeSPush
12721: oPop 1
12723: oInput 16
12725: oReturn
12726: oJumpForward 12731
12728: Choice Lookup Table
           1   12696
12731: oGetParam 1
12733: oPushResult
12734: oGetGlobal 19
12736: oPushResult
12737: oNodeEqual
12738: oPop 2
12740: oChoice 12780
12742: oInput 15
12744: oCall 5047
12746: oTypeSNodeType
12747: oChoice 12768
12749: oTypeSTop
12750: oPushResult
12751: oSetResult 45
12753: oPushResult
12754: oNodeGetBoolean
12755: oPop 2
12757: oChoice 12763
12759: oError 30
12761: oJumpForward 12766
12763: Choice Lookup Table
           1   12759
12766: oJumpForward 12773
12768: Choice Lookup Table
          44   12749
12771: oError 15
12773: oEmit 42
12775: oInput 16
12777: oReturn
12778: oJumpForward 12783
12780: Choice Lookup Table
           1   12742
12783: oGetParam 1
12785: oPushResult
12786: oGetGlobal 20
12788: oPushResult
12789: oNodeEqual
12790: oPop 2
12792: oChoice 12832
12794: oInput 15
12796: oCall 5047
12798: oTypeSNodeType
12799: oChoice 12820
12801: oTypeSTop
12802: oPushResult
12803: oSetResult 45
12805: oPushResult
12806: oNodeGetBoolean
12807: oPop 2
12809: oChoice 12815
12811: oError 30
12813: oJumpForward 12818
12815: Choice Lookup Table
           1   12811
12818: oJumpForward 12825
12820: Choice Lookup Table
          44   12801
12823: oError 15
12825: oEmit 41
12827: oInput 16
12829: oReturn
12830: oJumpForward 12835
12832: Choice Lookup Table
           1   12794
12835: oGetParam 1
12837: oPushResult
12838: oGetGlobal 21
12840: oPushResult
12841: oNodeEqual
12842: oPop 2
12844: oChoice 12900
12846: oInput 15
12848: oGetAddrLocal 1
12850: oPushResult
12851: oCodeNew
12852: oAssign
12853: oGetLocal 1
12855: oPushResult
12856: oCodePush
12857: oPop 1
12859: oCall 5070
12861: oCodePop
12862: oGetLocal 1
12864: oPushResult
12865: oCodeDiscard
12866: oPop 1
12868: oGetAddrLocal 2
12870: oPushResult
12871: oTypeSTop
12872: oAssign
12873: oTypeSPop
12874: oEmit 20
12876: oGetLocal 2
12878: oPushResult
12879: oSetResult 17
12881: oPushResult
12882: oNodeGetInt
12883: oPop 2
12885: oPushResult
12886: oEmitInt
12887: oPop 1
12889: oGetGlobal 6
12891: oPushResult
12892: oTypeSPush
12893: oPop 1
12895: oInput 16
12897: oReturn
12898: oJumpForward 12903
12900: Choice Lookup Table
           1   12846
12903: oError 17
12905: oReturn
12906: oLocalSpace 1
12908: oGetAddrLocal 1
12910: oPushResult
12911: oGetParam 2
12913: oPushResult
12914: oNodeNew
12915: oPop 1
12917: oAssign
12918: oGetLocal 1
12920: oPushResult
12921: oSetResult 17
12923: oPushResult
12924: oGetParam 1
12926: oPushResult
12927: oNodeSetInt
12928: oPop 3
12930: oGetLocal 1
12932: oPushResult
12933: oTypeAdd
12934: oPop 1
12936: oGetLocal 1
12938: oReturn
12939: oReturn
12940: oLocalSpace 12
12942: oInputChoice 13425
12944: oGetAddrLocal 1
12946: oPushResult
12947: oScopeFindRequire
12948: oAssign
12949: oGetAddrLocal 1
12951: oPushResult
12952: oCall 244
12954: oPop 1
12956: oGetLocal 1
12958: oPushResult
12959: oNodeType
12960: oPop 1
12962: oChoice 12979
12964: oGetParam 1
12966: oPushResult
12967: oGetLocal 1
12969: oPushResult
12970: oSetResult 21
12972: oPushResult
12973: oNodeGet
12974: oPop 2
12976: oAssign
12977: oJumpForward 12990
12979: Choice Lookup Table
          20   12964
12982: oError 2
12984: oGetParam 1
12986: oPushResult
12987: oGetGlobal 6
12989: oAssign
12990: oJumpForward 13448
12992: oInput 17
12994: oGetAddrLocal 2
12996: oPushResult
12997: oNodeVecNew
12998: oAssign
12999: oGetAddrLocal 3
13001: oPushResult
13002: oSetResult 40
13004: oPushResult
13005: oNodeNew
13006: oPop 1
13008: oAssign
13009: oCall 3586
13011: oGetLocal 3
13013: oPushResult
13014: oSetResult 40
13016: oPushResult
13017: oValueTop
13018: oPushResult
13019: oNodeSetInt
13020: oPop 3
13022: oValuePop
13023: oInput 22
13025: oCall 3586
13027: oGetLocal 3
13029: oPushResult
13030: oSetResult 41
13032: oPushResult
13033: oValueTop
13034: oPushResult
13035: oNodeSetInt
13036: oPop 3
13038: oValuePop
13039: oCall 4381
13041: oGetLocal 3
13043: oPushResult
13044: oSetResult 38
13046: oPushResult
13047: oTypeSTop
13048: oPushResult
13049: oNodeSet
13050: oPop 3
13052: oGetLocal 3
13054: oPushResult
13055: oSetResult 17
13057: oPushResult
13058: oTypeSTop
13059: oPushResult
13060: oSetResult 17
13062: oPushResult
13063: oNodeGetInt
13064: oPop 2
13066: oPushResult
13067: oNodeSetInt
13068: oPop 3
13070: oTypeSPop
13071: oGetLocal 3
13073: oPushResult
13074: oTypeAdd
13075: oPop 1
13077: oGetAddrLocal 4
13079: oPushResult
13080: oSetResult 39
13082: oPushResult
13083: oNodeNew
13084: oPop 1
13086: oAssign
13087: oGetLocal 4
13089: oPushResult
13090: oSetResult 39
13092: oPushResult
13093: oGetLocal 3
13095: oPushResult
13096: oNodeSet
13097: oPop 3
13099: oGetLocal 2
13101: oPushResult
13102: oGetLocal 4
13104: oPushResult
13105: oNodeVecAppend
13106: oPop 2
13108: oInputChoice 13116
13110: oJumpForward 13124
13112: oJumpForward 13122
13114: oJumpForward 13122
13116: Choice Lookup Table
          14   13114
          18   13110
13121: oEndChoice
13122: oJumpBack 12999
13124: oInput 41
13126: oGetAddrLocal 5
13128: oPushResult
13129: oCall 12940
13131: oPop 1
13133: oGetAddrLocal 6
13135: oPushResult
13136: oGetLocal 2
13138: oPushResult
13139: oNodeVecSize
13140: oPop 1
13142: oAssign
13143: oGetAddrLocal 6
13145: oPushResult
13146: dec
13147: oPop 1
13149: oGetAddrLocal 7
13151: oPushResult
13152: oGetLocal 2
13154: oPushResult
13155: oGetLocal 6
13157: oPushResult
13158: oNodeVecElement
13159: oPop 2
13161: oAssign
13162: oGetLocal 7
13164: oPushResult
13165: oSetResult 38
13167: oPushResult
13168: oGetLocal 5
13170: oPushResult
13171: oNodeSet
13172: oPop 3
13174: oGetAddrLocal 8
13176: oPushResult
13177: oGetLocal 7
13179: oPushResult
13180: oSetResult 39
13182: oPushResult
13183: oNodeGet
13184: oPop 2
13186: oAssign
13187: oGetAddrLocal 9
13189: oPushResult
13190: oGetLocal 8
13192: oPushResult
13193: oSetResult 41
13195: oPushResult
13196: oNodeGetInt
13197: oPop 2
13199: oPushResult
13200: oGetLocal 8
13202: oPushResult
13203: oSetResult 40
13205: oPushResult
13206: oNodeGetInt
13207: oPop 2
13209: oPushResult
13210: subtract
13211: oPop 2
13213: oAssign
13214: oGetAddrLocal 9
13216: oPushResult
13217: inc
13218: oPop 1
13220: oGetLocal 7
13222: oPushResult
13223: oSetResult 17
13225: oPushResult
13226: oGetLocal 9
13228: oPushResult
13229: oGetLocal 5
13231: oPushResult
13232: oSetResult 17
13234: oPushResult
13235: oNodeGetInt
13236: oPop 2
13238: oPushResult
13239: multiply
13240: oPop 2
13242: oPushResult
13243: oNodeSetInt
13244: oPop 3
13246: oGetLocal 7
13248: oPushResult
13249: oTypeAdd
13250: oPop 1
13252: oGetAddrLocal 5
13254: oPushResult
13255: oGetLocal 7
13257: oAssign
13258: oGetLocal 6
13260: oPushResult
13261: equal_zero
13262: oPop 1
13264: oChoice 13270
13266: oJumpForward 13275
13268: oJumpForward 13273
13270: Choice Lookup Table
           1   13266
13273: oJumpBack 13143
13275: oGetParam 1
13277: oPushResult
13278: oGetLocal 2
13280: oPushResult
13281: oSetResult 0
13283: oPushResult
13284: oNodeVecElement
13285: oPop 2
13287: oAssign
13288: oGetLocal 2
13290: oPushResult
13291: oNodeVecDelete
13292: oPop 1
13294: oJumpForward 13448
13296: oGetAddrLocal 10
13298: oPushResult
13299: oCall 12940
13301: oPop 1
13303: oGetParam 1
13305: oPushResult
13306: oGetLocal 10
13308: oPushResult
13309: oCall 14019
13311: oPop 1
13313: oAssign
13314: oJumpForward 13448
13316: oGetParam 1
13318: oPushResult
13319: oSetResult 41
13321: oPushResult
13322: oNodeNew
13323: oPop 1
13325: oAssign
13326: oSetResult -1
13328: oPushResult
13329: oSetResult 2
13331: oPushResult
13332: oScopeBegin
13333: oPop 2
13335: oSetResult 24
13337: oPushResult
13338: oCall 3287
13340: oPop 1
13342: oGetAddrLocal 11
13344: oPushResult
13345: oScopeCurrent
13346: oPushResult
13347: oSetResult 17
13349: oPushResult
13350: oNodeGetInt
13351: oPop 2
13353: oAssign
13354: oGetLocal 11
13356: oPushResult
13357: equal_zero
13358: oPop 1
13360: oChoice 13366
13362: oError 20
13364: oJumpForward 13369
13366: Choice Lookup Table
           1   13362
13369: oInput 37
13371: oGetFromParam 1
13373: oPushResult
13374: oSetResult 42
13376: oPushResult
13377: oScopeCurrent
13378: oPushResult
13379: oNodeSet
13380: oPop 3
13382: oGetFromParam 1
13384: oPushResult
13385: oSetResult 17
13387: oPushResult
13388: oGetLocal 11
13390: oPushResult
13391: oNodeSetInt
13392: oPop 3
13394: oScopeEnd
13395: oGetFromParam 1
13397: oPushResult
13398: oTypeAdd
13399: oPop 1
13401: oJumpForward 13448
13403: oGetParam 1
13405: oPushResult
13406: oCall 13449
13408: oPop 1
13410: oJumpForward 13448
13412: oInput 41
13414: oGetAddrLocal 12
13416: oPushResult
13417: oCall 12940
13419: oPop 1
13421: oError 17
13423: oJumpForward 13448
13425: Choice Lookup Table
          40   13412
          15   13403
          39   13316
          19   13296
          38   12992
           0   12944
13438: oCall 3586
13440: oInput 22
13442: oCall 3586
13444: oCall 4381
13446: oError 17
13448: oReturn
13449: oLocalSpace 11
13451: oGetParam 1
13453: oPushResult
13454: oSetResult 44
13456: oPushResult
13457: oNodeNew
13458: oPop 1
13460: oAssign
13461: oGetAddrLocal 1
13463: oPushResult
13464: oSetResult 0
13466: oAssign
13467: oGetAddrLocal 2
13469: oPushResult
13470: oSetResult 0
13472: oAssign
13473: oGetAddrLocal 3
13475: oPushResult
13476: oSetResult 1
13478: oAssign
13479: oGetAddrLocal 4
13481: oPushResult
13482: oScopeCurrent
13483: oAssign
13484: oSetResult -1
13486: oPushResult
13487: oSetResult 2
13489: oPushResult
13490: oScopeBegin
13491: oPop 2
13493: oInput 0
13495: oGetAddrLocal 5
13497: oPushResult
13498: oSetResult 17
13500: oPushResult
13501: LAST_ID
13502: oPushResult
13503: oCall 14972
13505: oPop 2
13507: oAssign
13508: oGetAddrLocal 6
13510: oPushResult
13511: oSetResult 17
13513: oPushResult
13514: LAST_ID
13515: oPushResult
13516: oCall 14972
13518: oPop 2
13520: oAssign
13521: oGetLocal 5
13523: oPushResult
13524: oSetResult 21
13526: oPushResult
13527: oGetFromParam 1
13529: oPushResult
13530: oNodeSet
13531: oPop 3
13533: oGetLocal 6
13535: oPushResult
13536: oSetResult 21
13538: oPushResult
13539: oGetFromParam 1
13541: oPushResult
13542: oNodeSet
13543: oPop 3
13545: oGetAddrLocal 7
13547: oPushResult
13548: LAST_ID
13549: oPushResult
13550: ID_STRING
13551: oPop 1
13553: oPushResult
13554: oStringAllocLit
13555: oPop 1
13557: oAssign
13558: oGetLocal 5
13560: oPushResult
13561: oSetResult 32
13563: oPushResult
13564: oGetLocal 7
13566: oPushResult
13567: oNodeSetInt
13568: oPop 3
13570: oGetLocal 6
13572: oPushResult
13573: oSetResult 32
13575: oPushResult
13576: oGetLocal 7
13578: oPushResult
13579: oNodeSetInt
13580: oPop 3
13582: oInputChoice 13660
13584: oGetGlobal 6
13586: oPushResult
13587: oTypeSPush
13588: oPop 1
13590: oCall 3586
13592: oCall 4478
13594: oTypeSPop
13595: oGetLocal 2
13597: oPushResult
13598: equal_zero
13599: oPop 1
13601: oChoice 13622
13603: oValueTop
13604: oPushResult
13605: oGetLocal 1
13607: oPushResult
13608: greater
13609: oPop 2
13611: oChoice 13617
13613: oError 28
13615: oJumpForward 13620
13617: Choice Lookup Table
           0   13613
13620: oJumpForward 13625
13622: Choice Lookup Table
           0   13603
13625: oGetLocal 1
13627: oPushResult
13628: oValueTop
13629: oPushResult
13630: equal
13631: oPop 2
13633: oChoice 13649
13635: oGetFromParam 1
13637: oPushResult
13638: oSetResult 45
13640: oPushResult
13641: oSetResult 1
13643: oPushResult
13644: oNodeSetBoolean
13645: oPop 3
13647: oJumpForward 13652
13649: Choice Lookup Table
           0   13635
13652: oGetAddrLocal 1
13654: oPushResult
13655: oValueTop
13656: oAssign
13657: oValuePop
13658: oJumpForward 13665
13660: Choice Lookup Table
           5   13584
           7   13584
13665: oGetLocal 5
13667: oPushResult
13668: oSetResult 22
13670: oPushResult
13671: oGetLocal 1
13673: oPushResult
13674: oNodeSetInt
13675: oPop 3
13677: oGetLocal 6
13679: oPushResult
13680: oSetResult 22
13682: oPushResult
13683: oGetLocal 1
13685: oPushResult
13686: oNodeSetInt
13687: oPop 3
13689: oGetLocal 5
13691: oPushResult
13692: oScopeDeclare
13693: oPop 1
13695: oGetLocal 4
13697: oPushResult
13698: oScopeEnter
13699: oPop 1
13701: oGetLocal 6
13703: oPushResult
13704: oScopeDeclare
13705: oPop 1
13707: oScopeEnd
13708: oGetAddrLocal 1
13710: oPushResult
13711: inc
13712: oPop 1
13714: oGetAddrLocal 2
13716: oPushResult
13717: inc
13718: oPop 1
13720: oInputChoice 13724
13722: oJumpForward 13729
13724: Choice Lookup Table
          14   13722
13727: oJumpForward 13731
13729: oJumpBack 13493
13731: oInput 16
13733: oGetFromParam 1
13735: oPushResult
13736: oSetResult 42
13738: oPushResult
13739: oScopeCurrent
13740: oPushResult
13741: oNodeSet
13742: oPop 3
13744: oGetFromParam 1
13746: oPushResult
13747: oSetResult 17
13749: oPushResult
13750: oSetResult 4
13752: oPushResult
13753: oNodeSetInt
13754: oPop 3
13756: oScopeEnd
13757: oGetGlobal 2
13759: oPushResult
13760: oCall 14870
13762: oPop 1
13764: oPushResult
13765: oCodePush
13766: oPop 1
13768: oGetGlobal 2
13770: oPushResult
13771: oScopeEnter
13772: oPop 1
13774: oGetAddrLocal 8
13776: oPushResult
13777: oGetLocal 2
13779: oPushResult
13780: oSetResult 1
13782: oPushResult
13783: add
13784: oPop 2
13786: oPushResult
13787: oSetResult 16
13789: oPushResult
13790: multiply
13791: oPop 2
13793: oAssign
13794: oGetAddrLocal 9
13796: oPushResult
13797: oGetLocal 8
13799: oPushResult
13800: oSetResult 8
13802: oPushResult
13803: oScopeAlloc
13804: oPop 2
13806: oAssign
13807: oScopeEnd
13808: oGetFromParam 1
13810: oPushResult
13811: oSetResult 44
13813: oPushResult
13814: oGetLocal 9
13816: oPushResult
13817: oNodeSetInt
13818: oPop 3
13820: oGetAddrLocal 10
13822: oPushResult
13823: oGetFromParam 1
13825: oPushResult
13826: oSetResult 42
13828: oPushResult
13829: oNodeGet
13830: oPop 2
13832: oPushResult
13833: oSetResult 15
13835: oPushResult
13836: oNodeGetIter
13837: oPop 2
13839: oAssign
13840: oGetAddrLocal 11
13842: oPushResult
13843: oGetLocal 10
13845: oPushResult
13846: oNodeIterValue
13847: oPop 1
13849: oAssign
13850: oGetLocal 11
13852: oPushResult
13853: oNodeNull
13854: oPop 1
13856: oChoice 13862
13858: oJumpForward 13949
13860: oJumpForward 13865
13862: Choice Lookup Table
           1   13858
13865: oEmit 22
13867: oGetLocal 9
13869: oPushResult
13870: oEmitInt
13871: oPop 1
13873: oEmit 20
13875: oGetLocal 11
13877: oPushResult
13878: oSetResult 22
13880: oPushResult
13881: oNodeGetInt
13882: oPop 2
13884: oPushResult
13885: oEmitInt
13886: oPop 1
13888: oEmit 33
13890: oGetAddrLocal 9
13892: oPushResult
13893: oGetLocal 9
13895: oPushResult
13896: oSetResult 8
13898: oPushResult
13899: add
13900: oPop 2
13902: oAssign
13903: oEmit 22
13905: oGetLocal 9
13907: oPushResult
13908: oEmitInt
13909: oPop 1
13911: oEmit 22
13913: oGetLocal 11
13915: oPushResult
13916: oSetResult 32
13918: oPushResult
13919: oNodeGetInt
13920: oPop 2
13922: oPushResult
13923: oEmitInt
13924: oPop 1
13926: oEmit 35
13928: oGetAddrLocal 9
13930: oPushResult
13931: oGetLocal 9
13933: oPushResult
13934: oSetResult 8
13936: oPushResult
13937: add
13938: oPop 2
13940: oAssign
13941: oGetAddrLocal 10
13943: oPushResult
13944: oNodeIterNext
13945: oPop 1
13947: oJumpBack 13840
13949: oEmit 22
13951: oGetLocal 9
13953: oPushResult
13954: oEmitInt
13955: oPop 1
13957: oEmit 20
13959: oSetResult 0
13961: oPushResult
13962: oEmitInt
13963: oPop 1
13965: oEmit 33
13967: oGetAddrLocal 9
13969: oPushResult
13970: oGetLocal 9
13972: oPushResult
13973: oSetResult 8
13975: oPushResult
13976: add
13977: oPop 2
13979: oAssign
13980: oEmit 22
13982: oGetLocal 9
13984: oPushResult
13985: oEmitInt
13986: oPop 1
13988: oEmit 20
13990: oSetResult 0
13992: oPushResult
13993: oEmitInt
13994: oPop 1
13996: oEmit 35
13998: oGetAddrLocal 9
14000: oPushResult
14001: oGetLocal 9
14003: oPushResult
14004: oSetResult 8
14006: oPushResult
14007: add
14008: oPop 2
14010: oAssign
14011: oCodePop
14012: oGetFromParam 1
14014: oPushResult
14015: oTypeAdd
14016: oPop 1
14018: oReturn
14019: oLocalSpace 1
14021: oGetAddrLocal 1
14023: oPushResult
14024: oGetParam 1
14026: oPushResult
14027: oSetResult 37
14029: oPushResult
14030: oNodeGet
14031: oPop 2
14033: oAssign
14034: oGetLocal 1
14036: oPushResult
14037: oNodeNull
14038: oPop 1
14040: oChoice 14096
14042: oGetAddrLocal 1
14044: oPushResult
14045: oSetResult 37
14047: oPushResult
14048: oNodeNew
14049: oPop 1
14051: oAssign
14052: oGetLocal 1
14054: oPushResult
14055: oSetResult 38
14057: oPushResult
14058: oGetParam 1
14060: oPushResult
14061: oNodeSet
14062: oPop 3
14064: oGetLocal 1
14066: oPushResult
14067: oSetResult 17
14069: oPushResult
14070: oSetResult 8
14072: oPushResult
14073: oNodeSetInt
14074: oPop 3
14076: oGetLocal 1
14078: oPushResult
14079: oTypeAdd
14080: oPop 1
14082: oGetParam 1
14084: oPushResult
14085: oSetResult 37
14087: oPushResult
14088: oGetLocal 1
14090: oPushResult
14091: oNodeSet
14092: oPop 3
14094: oJumpForward 14099
14096: Choice Lookup Table
           1   14042
14099: oGetLocal 1
14101: oReturn
14102: oReturn
14103: oLocalSpace 2
14105: oGetParam 1
14107: oPushResult
14108: oNodeType
14109: oPop 1
14111: oChoice 14181
14113: oMININT
14114: oReturn
14115: oJumpForward 14197
14117: oSetResult 0
14119: oReturn
14120: oJumpForward 14197
14122: oSetResult 0
14124: oReturn
14125: oJumpForward 14197
14127: oGetAddrLocal 1
14129: oPushResult
14130: oGetParam 1
14132: oPushResult
14133: oSetResult 42
14135: oPushResult
14136: oNodeGet
14137: oPop 2
14139: oAssign
14140: oGetAddrLocal 2
14142: oPushResult
14143: oGetLocal 1
14145: oPushResult
14146: oSetResult 15
14148: oPushResult
14149: oNodeGetIter
14150: oPop 2
14152: oPushResult
14153: oNodeIterValue
14154: oPop 1
14156: oAssign
14157: oGetLocal 2
14159: oPushResult
14160: oSetResult 22
14162: oPushResult
14163: oNodeGetInt
14164: oPop 2
14166: oReturn
14167: oJumpForward 14197
14169: oGetParam 1
14171: oPushResult
14172: oSetResult 40
14174: oPushResult
14175: oNodeGetInt
14176: oPop 2
14178: oReturn
14179: oJumpForward 14197
14181: Choice Lookup Table
          40   14169
          44   14127
          36   14122
          34   14117
          31   14113
14192: oError 3
14194: oSetResult 0
14196: oReturn
14197: oReturn
14198: oLocalSpace 2
14200: oGetParam 1
14202: oPushResult
14203: oNodeType
14204: oPop 1
14206: oChoice 14276
14208: oMAXINT
14209: oReturn
14210: oJumpForward 14292
14212: oSetResult 1
14214: oReturn
14215: oJumpForward 14292
14217: oSetResult 255
14219: oReturn
14220: oJumpForward 14292
14222: oGetAddrLocal 1
14224: oPushResult
14225: oGetParam 1
14227: oPushResult
14228: oSetResult 42
14230: oPushResult
14231: oNodeGet
14232: oPop 2
14234: oAssign
14235: oGetAddrLocal 2
14237: oPushResult
14238: oGetLocal 1
14240: oPushResult
14241: oSetResult 15
14243: oPushResult
14244: oNodeGetIterLast
14245: oPop 2
14247: oPushResult
14248: oNodeIterValue
14249: oPop 1
14251: oAssign
14252: oGetLocal 2
14254: oPushResult
14255: oSetResult 22
14257: oPushResult
14258: oNodeGetInt
14259: oPop 2
14261: oReturn
14262: oJumpForward 14292
14264: oGetParam 1
14266: oPushResult
14267: oSetResult 41
14269: oPushResult
14270: oNodeGetInt
14271: oPop 2
14273: oReturn
14274: oJumpForward 14292
14276: Choice Lookup Table
          40   14264
          44   14222
          36   14217
          34   14212
          31   14208
14287: oError 3
14289: oSetResult 0
14291: oReturn
14292: oReturn
14293: oLocalSpace 5
14295: oGetAddrGlobal 1
14297: oPushResult
14298: oWorkspaceNew
14299: oAssign
14300: oSetResult 0
14302: oPushResult
14303: oSetResult 0
14305: oPushResult
14306: oScopeBegin
14307: oPop 2
14309: oGetAddrLocal 2
14311: oPushResult
14312: oScopeCurrent
14313: oAssign
14314: oCall 15042
14316: oEmit 87
14318: oSetResult 0
14320: oPushResult
14321: oEmitInt
14322: oPop 1
14324: oGetAddrLocal 3
14326: oPushResult
14327: oLabelNew
14328: oAssign
14329: oEmit 81
14331: oSetResult 0
14333: oPushResult
14334: oEmitInt
14335: oPop 1
14337: oEmit 84
14339: oGetLocal 3
14341: oPushResult
14342: oEmitLabel
14343: oPop 1
14345: oEmit 83
14347: oSetResult 0
14349: oPushResult
14350: oEmitInt
14351: oPop 1
14353: oEmit 86
14355: oInput 29
14357: oInput 0
14359: oGetAddrLocal 4
14361: oPushResult
14362: oSetResult 4
14364: oPushResult
14365: oNodeNew
14366: oPop 1
14368: oAssign
14369: oGetLocal 4
14371: oPushResult
14372: oSetResult 4
14374: oPushResult
14375: LAST_ID
14376: oPushResult
14377: oNodeSetInt
14378: oPop 3
14380: oGetGlobal 1
14382: oPushResult
14383: oSetResult 2
14385: oPushResult
14386: oGetLocal 4
14388: oPushResult
14389: oNodeSet
14390: oPop 3
14392: oInputChoice 14466
14394: oInput 0
14396: oGetAddrLocal 1
14398: oPushResult
14399: oSetResult 21
14401: oPushResult
14402: LAST_ID
14403: oPushResult
14404: oCall 14972
14406: oPop 2
14408: oAssign
14409: oGetLocal 1
14411: oPushResult
14412: oSetResult 21
14414: oPushResult
14415: oGetGlobal 5
14417: oPushResult
14418: oNodeSet
14419: oPop 3
14421: oGetLocal 1
14423: oPushResult
14424: oScopeDeclareAlloc
14425: oPop 1
14427: oInput 14
14429: oInput 0
14431: oGetAddrLocal 1
14433: oPushResult
14434: oSetResult 21
14436: oPushResult
14437: LAST_ID
14438: oPushResult
14439: oCall 14972
14441: oPop 2
14443: oAssign
14444: oGetLocal 1
14446: oPushResult
14447: oSetResult 21
14449: oPushResult
14450: oGetGlobal 5
14452: oPushResult
14453: oNodeSet
14454: oPop 3
14456: oGetLocal 1
14458: oPushResult
14459: oScopeDeclareAlloc
14460: oPop 1
14462: oInput 16
14464: oJumpForward 14469
14466: Choice Lookup Table
          15   14394
14469: oInput 6
14471: oGetLocal 4
14473: oPushResult
14474: oCall 34
14476: oPop 1
14478: oInputChoice 14489
14480: oGetLocal 4
14482: oPushResult
14483: oCall 7
14485: oPop 1
14487: oJumpForward 14492
14489: Choice Lookup Table
          60   14480
14492: oGetLocal 4
14494: oPushResult
14495: oCall 287
14497: oPop 1
14499: oSetResult 0
14501: oPushResult
14502: oSetResult 0
14504: oPushResult
14505: oScopeBegin
14506: oPop 2
14508: oGetAddrGlobal 2
14510: oPushResult
14511: oScopeCurrent
14512: oAssign
14513: oSetResult 0
14515: oPushResult
14516: oSetResult 1
14518: oPushResult
14519: oScopeBegin
14520: oPop 2
14522: oScopeCurrent
14523: oPushResult
14524: oSetResult 16
14526: oPushResult
14527: oGetGlobal 2
14529: oPushResult
14530: oNodeSet
14531: oPop 3
14533: oGetAddrGlobal 3
14535: oPushResult
14536: oScopeCurrent
14537: oAssign
14538: oGetLocal 4
14540: oPushResult
14541: oSetResult 7
14543: oPushResult
14544: oGetGlobal 3
14546: oPushResult
14547: oNodeSet
14548: oPop 3
14550: oScopeEnd
14551: oSetResult 22
14553: oPushResult
14554: oCall 14621
14556: oPop 1
14558: oGetGlobal 3
14560: oPushResult
14561: oScopeEnter
14562: oPop 1
14564: oGetAddrLocal 5
14566: oPushResult
14567: oSetResult 1
14569: oAssign
14570: oGetLocal 3
14572: oPushResult
14573: oGetGlobal 2
14575: oPushResult
14576: oGetLocal 5
14578: oPushResult
14579: oCall 14772
14581: oPop 3
14583: oScopeEnd
14584: oInput 21
14586: oCall 14677
14588: oScopeEnd
14589: oGetLocal 4
14591: oPushResult
14592: oCall 349
14594: oPop 1
14596: oReturn
14597: oLocalSpace 0
14599: oGetParam 2
14601: oPushResult
14602: oCall 14621
14604: oPop 1
14606: oGetParam 1
14608: oPushResult
14609: oScopeCurrent
14610: oPushResult
14611: oSetResult 0
14613: oPushResult
14614: oCall 14772
14616: oPop 3
14618: oCall 14677
14620: oReturn
14621: oLocalSpace 0
14623: oInputChoice 14654
14625: oCall 2538
14627: oJumpForward 14669
14629: oCall 3231
14631: oJumpForward 14669
14633: oGetParam 1
14635: oPushResult
14636: oCall 3287
14638: oPop 1
14640: oJumpForward 14669
14642: oCall 3521
14644: oJumpForward 14669
14646: oCall 1761
14648: oJumpForward 14669
14650: oCall 2196
14652: oJumpForward 14669
14654: Choice Lookup Table
          31   14650
          30   14646
          35   14642
          34   14633
          33   14629
          32   14625
14667: oJumpForward 14671
14669: oJumpBack 14623
14671: oCall 14674
14673: oReturn
14674: oLocalSpace 0
14676: oReturn
14677: oLocalSpace 2
14679: oGetAddrLocal 1
14681: oPushResult
14682: oScopeCurrent
14683: oPushResult
14684: oSetResult 15
14686: oPushResult
14687: oNodeGetIter
14688: oPop 2
14690: oAssign
14691: oGetAddrLocal 2
14693: oPushResult
14694: oGetLocal 1
14696: oPushResult
14697: oNodeIterValue
14698: oPop 1
14700: oAssign
14701: oGetLocal 2
14703: oPushResult
14704: oNodeNull
14705: oPop 1
14707: oChoice 14711
14709: oJumpForward 14716
14711: Choice Lookup Table
           0   14709
14714: oJumpForward 14771
14716: oGetLocal 2
14718: oPushResult
14719: oNodeType
14720: oPop 1
14722: oChoice 14760
14724: oGetLocal 2
14726: oPushResult
14727: oSetResult 36
14729: oPushResult
14730: oNodeGetBoolean
14731: oPop 2
14733: oChoice 14755
14735: oGetLocal 2
14737: oPushResult
14738: oSetResult 28
14740: oPushResult
14741: oNodeGetBoolean
14742: oPop 2
14744: oChoice 14750
14746: oError 29
14748: oJumpForward 14753
14750: Choice Lookup Table
           1   14746
14753: oJumpForward 14758
14755: Choice Lookup Table
           0   14735
14758: oJumpForward 14763
14760: Choice Lookup Table
          27   14724
14763: oGetAddrLocal 1
14765: oPushResult
14766: oNodeIterNext
14767: oPop 1
14769: oJumpBack 14691
14771: oReturn
14772: oLocalSpace 3
14774: oEmit 97
14776: oGetParam 3
14778: oPushResult
14779: oEmitLabel
14780: oPop 1
14782: oEmit 87
14784: oGetAddrLocal 1
14786: oPushResult
14787: Here
14788: oAssign
14789: oEmit 115
14791: oGetParam 1
14793: oChoice 14799
14795: oCall 1220
14797: oJumpForward 14802
14799: Choice Lookup Table
           1   14795
14802: oGetAddrLocal 2
14804: oPushResult
14805: oGetParam 2
14807: oPushResult
14808: oSetResult 19
14810: oPushResult
14811: oNodeGetCode
14812: oPop 2
14814: oAssign
14815: oGetLocal 2
14817: oPushResult
14818: oEmitCode
14819: oPop 1
14821: oGetParam 2
14823: oPushResult
14824: oSetResult 19
14826: oPushResult
14827: oSetResult 0
14829: oPushResult
14830: oNodeSetCode
14831: oPop 3
14833: oCall 9673
14835: oGetParam 1
14837: oChoice 14843
14839: oCall 1305
14841: oJumpForward 14846
14843: Choice Lookup Table
           1   14839
14846: oEmit 86
14848: oGetAddrLocal 3
14850: oPushResult
14851: oScopeCurrent
14852: oPushResult
14853: oSetResult 17
14855: oPushResult
14856: oNodeGetInt
14857: oPop 2
14859: oAssign
14860: oGetLocal 1
14862: oPushResult
14863: oGetLocal 3
14865: oPushResult
14866: oPatch
14867: oPop 2
14869: oReturn
14870: oLocalSpace 1
14872: oGetAddrLocal 1
14874: oPushResult
14875: oGetParam 1
14877: oPushResult
14878: oSetResult 19
14880: oPushResult
14881: oNodeGetCode
14882: oPop 2
14884: oAssign
14885: oGetLocal 1
14887: oPushResult
14888: oSetResult 0
14890: oPushResult
14891: equal_code
14892: oPop 2
14894: oChoice 14915
14896: oGetAddrLocal 1
14898: oPushResult
14899: oCodeNew
14900: oAssign
14901: oGetParam 1
14903: oPushResult
14904: oSetResult 19
14906: oPushResult
14907: oGetLocal 1
14909: oPushResult
14910: oNodeSetCode
14911: oPop 3
14913: oJumpForward 14918
14915: Choice Lookup Table
           1   14896
14918: oGetLocal 1
14920: oReturn
14921: oReturn
14922: oLocalSpace 0
14924: oScopeCurrent
14925: oPushResult
14926: oSetResult 14
14928: oPushResult
14929: oNodeGetInt
14930: oPop 2
14932: oReturn
14933: oReturn
14934: oLocalSpace 0
14936: oGetParam 1
14938: oPushResult
14939: oSetResult 20
14941: oPushResult
14942: oNodeGet
14943: oPop 2
14945: oPushResult
14946: oSetResult 14
14948: oPushResult
14949: oNodeGetInt
14950: oPop 2
14952: oReturn
14953: oReturn
14954: oLocalSpace 0
14956: oCall 14922
14958: oPushResult
14959: oGetParam 1
14961: oPushResult
14962: oCall 14934
14964: oPop 1
14966: oPushResult
14967: subtract
14968: oPop 2
14970: oReturn
14971: oReturn
14972: oLocalSpace 1
14974: oGetAddrLocal 1
14976: oPushResult
14977: oGetParam 2
14979: oPushResult
14980: oNodeNew
14981: oPop 1
14983: oAssign
14984: oGetLocal 1
14986: oPushResult
14987: oSetResult 4
14989: oPushResult
14990: oGetParam 1
14992: oPushResult
14993: oNodeSetInt
14994: oPop 3
14996: oGetLocal 1
14998: oReturn
14999: oReturn
15000: oLocalSpace 0
15002: oGetParam 1
15004: oPushResult
15005: oSetResult 22
15007: oPushResult
15008: oNodeGetInt
15009: oPop 2
15011: oPushResult
15012: oEmitInt
15013: oPop 1
15015: oReturn
15016: oLocalSpace 1
15018: oGetAddrLocal 1
15020: oPushResult
15021: oSetResult 14
15023: oPushResult
15024: oGetParam 1
15026: oPushResult
15027: oCall 14972
15029: oPop 2
15031: oAssign
15032: oGetLocal 1
15034: oPushResult
15035: oScopeDeclare
15036: oPop 1
15038: oGetLocal 1
15040: oReturn
15041: oReturn
15042: oLocalSpace 1
15044: oGetAddrGlobal 25
15046: oPushResult
15047: oSetResult 0
15049: oAssign
15050: oGetAddrGlobal 4
15052: oPushResult
15053: oId_mysystem
15054: oAssign
15055: oGetAddrGlobal 5
15057: oPushResult
15058: oSetResult 29
15060: oPushResult
15061: oSetResult 4
15063: oPushResult
15064: oCall 12906
15066: oPop 2
15068: oAssign
15069: oGetAddrGlobal 6
15071: oPushResult
15072: oSetResult 31
15074: oPushResult
15075: oSetResult 4
15077: oPushResult
15078: oCall 12906
15080: oPop 2
15082: oAssign
15083: oGetAddrGlobal 7
15085: oPushResult
15086: oSetResult 34
15088: oPushResult
15089: oSetResult 1
15091: oPushResult
15092: oCall 12906
15094: oPop 2
15096: oAssign
15097: oGetAddrGlobal 8
15099: oPushResult
15100: oSetResult 35
15102: oPushResult
15103: oSetResult 1
15105: oPushResult
15106: oCall 12906
15108: oPop 2
15110: oAssign
15111: oGetAddrGlobal 9
15113: oPushResult
15114: oSetResult 36
15116: oPushResult
15117: oSetResult 1
15119: oPushResult
15120: oCall 12906
15122: oPop 2
15124: oAssign
15125: oGetAddrGlobal 10
15127: oPushResult
15128: oGetGlobal 9
15130: oPushResult
15131: oCall 14019
15133: oPop 1
15135: oAssign
15136: oGetAddrGlobal 11
15138: oPushResult
15139: oSetResult 30
15141: oPushResult
15142: oSetResult 1
15144: oPushResult
15145: oCall 12906
15147: oPop 2
15149: oAssign
15150: oGetAddrGlobal 12
15152: oPushResult
15153: oSetResult 32
15155: oPushResult
15156: oSetResult 4
15158: oPushResult
15159: oCall 12906
15161: oPop 2
15163: oAssign
15164: oGetAddrGlobal 13
15166: oPushResult
15167: oSetResult 33
15169: oPushResult
15170: oSetResult 8
15172: oPushResult
15173: oCall 12906
15175: oPop 2
15177: oAssign
15178: oGetAddrGlobal 14
15180: oPushResult
15181: oSetResult 38
15183: oPushResult
15184: oSetResult 8
15186: oPushResult
15187: oCall 12906
15189: oPop 2
15191: oAssign
15192: oGetGlobal 14
15194: oPushResult
15195: oSetResult 38
15197: oPushResult
15198: oGetGlobal 11
15200: oPushResult
15201: oNodeSet
15202: oPop 3
15204: oGetAddrGlobal 15
15206: oPushResult
15207: oSetResult 42
15209: oPushResult
15210: oSetResult 256
15212: oPushResult
15213: oCall 12906
15215: oPop 2
15217: oAssign
15218: oGetAddrGlobal 16
15220: oPushResult
15221: oSetResult 43
15223: oPushResult
15224: oSetResult 256
15226: oPushResult
15227: oCall 12906
15229: oPop 2
15231: oAssign
15232: oGetGlobal 16
15234: oPushResult
15235: oSetResult 43
15237: oPushResult
15238: oSetResult 255
15240: oPushResult
15241: oNodeSetInt
15242: oPop 3
15244: oGetAddrLocal 1
15246: oPushResult
15247: oSetResult 20
15249: oPushResult
15250: oId_File
15251: oPushResult
15252: oCall 14972
15254: oPop 2
15256: oAssign
15257: oGetLocal 1
15259: oPushResult
15260: oSetResult 21
15262: oPushResult
15263: oGetGlobal 5
15265: oPushResult
15266: oNodeSet
15267: oPop 3
15269: oGetLocal 1
15271: oPushResult
15272: oScopeDeclare
15273: oPop 1
15275: oGetAddrLocal 1
15277: oPushResult
15278: oSetResult 20
15280: oPushResult
15281: oId_Integer
15282: oPushResult
15283: oCall 14972
15285: oPop 2
15287: oAssign
15288: oGetLocal 1
15290: oPushResult
15291: oSetResult 21
15293: oPushResult
15294: oGetGlobal 6
15296: oPushResult
15297: oNodeSet
15298: oPop 3
15300: oGetLocal 1
15302: oPushResult
15303: oScopeDeclare
15304: oPop 1
15306: oGetAddrLocal 1
15308: oPushResult
15309: oSetResult 20
15311: oPushResult
15312: oId_Boolean
15313: oPushResult
15314: oCall 14972
15316: oPop 2
15318: oAssign
15319: oGetLocal 1
15321: oPushResult
15322: oSetResult 21
15324: oPushResult
15325: oGetGlobal 7
15327: oPushResult
15328: oNodeSet
15329: oPop 3
15331: oGetLocal 1
15333: oPushResult
15334: oScopeDeclare
15335: oPop 1
15337: oGetAddrLocal 1
15339: oPushResult
15340: oSetResult 20
15342: oPushResult
15343: oId_Char
15344: oPushResult
15345: oCall 14972
15347: oPop 2
15349: oAssign
15350: oGetLocal 1
15352: oPushResult
15353: oSetResult 21
15355: oPushResult
15356: oGetGlobal 9
15358: oPushResult
15359: oNodeSet
15360: oPop 3
15362: oGetLocal 1
15364: oPushResult
15365: oScopeDeclare
15366: oPop 1
15368: oGetAddrLocal 1
15370: oPushResult
15371: oSetResult 20
15373: oPushResult
15374: oId_Byte
15375: oPushResult
15376: oCall 14972
15378: oPop 2
15380: oAssign
15381: oGetLocal 1
15383: oPushResult
15384: oSetResult 21
15386: oPushResult
15387: oGetGlobal 11
15389: oPushResult
15390: oNodeSet
15391: oPop 3
15393: oGetLocal 1
15395: oPushResult
15396: oScopeDeclare
15397: oPop 1
15399: oGetAddrLocal 1
15401: oPushResult
15402: oSetResult 20
15404: oPushResult
15405: oId_Single
15406: oPushResult
15407: oCall 14972
15409: oPop 2
15411: oAssign
15412: oGetLocal 1
15414: oPushResult
15415: oSetResult 21
15417: oPushResult
15418: oGetGlobal 12
15420: oPushResult
15421: oNodeSet
15422: oPop 3
15424: oGetLocal 1
15426: oPushResult
15427: oScopeDeclare
15428: oPop 1
15430: oGetAddrLocal 1
15432: oPushResult
15433: oSetResult 20
15435: oPushResult
15436: oId_Double
15437: oPushResult
15438: oCall 14972
15440: oPop 2
15442: oAssign
15443: oGetLocal 1
15445: oPushResult
15446: oSetResult 21
15448: oPushResult
15449: oGetGlobal 13
15451: oPushResult
15452: oNodeSet
15453: oPop 3
15455: oGetLocal 1
15457: oPushResult
15458: oScopeDeclare
15459: oPop 1
15461: oGetAddrLocal 1
15463: oPushResult
15464: oSetResult 20
15466: oPushResult
15467: oId_Pointer
15468: oPushResult
15469: oCall 14972
15471: oPop 2
15473: oAssign
15474: oGetLocal 1
15476: oPushResult
15477: oSetResult 21
15479: oPushResult
15480: oGetGlobal 14
15482: oPushResult
15483: oNodeSet
15484: oPop 3
15486: oGetLocal 1
15488: oPushResult
15489: oScopeDeclare
15490: oPop 1
15492: oGetAddrLocal 1
15494: oPushResult
15495: oSetResult 20
15497: oPushResult
15498: oId_ShortString
15499: oPushResult
15500: oCall 14972
15502: oPop 2
15504: oAssign
15505: oGetLocal 1
15507: oPushResult
15508: oSetResult 21
15510: oPushResult
15511: oGetGlobal 16
15513: oPushResult
15514: oNodeSet
15515: oPop 3
15517: oGetLocal 1
15519: oPushResult
15520: oScopeDeclare
15521: oPop 1
15523: oGetAddrLocal 1
15525: oPushResult
15526: oSetResult 16
15528: oPushResult
15529: oId_True
15530: oPushResult
15531: oCall 14972
15533: oPop 2
15535: oAssign
15536: oGetLocal 1
15538: oPushResult
15539: oSetResult 21
15541: oPushResult
15542: oGetGlobal 7
15544: oPushResult
15545: oNodeSet
15546: oPop 3
15548: oGetLocal 1
15550: oPushResult
15551: oSetResult 22
15553: oPushResult
15554: oSetResult 1
15556: oPushResult
15557: oNodeSetInt
15558: oPop 3
15560: oGetLocal 1
15562: oPushResult
15563: oScopeDeclare
15564: oPop 1
15566: oGetAddrLocal 1
15568: oPushResult
15569: oSetResult 16
15571: oPushResult
15572: oId_False
15573: oPushResult
15574: oCall 14972
15576: oPop 2
15578: oAssign
15579: oGetLocal 1
15581: oPushResult
15582: oSetResult 21
15584: oPushResult
15585: oGetGlobal 7
15587: oPushResult
15588: oNodeSet
15589: oPop 3
15591: oGetLocal 1
15593: oPushResult
15594: oSetResult 22
15596: oPushResult
15597: oSetResult 0
15599: oPushResult
15600: oNodeSetInt
15601: oPop 3
15603: oGetLocal 1
15605: oPushResult
15606: oScopeDeclare
15607: oPop 1
15609: oGetAddrLocal 1
15611: oPushResult
15612: oSetResult 16
15614: oPushResult
15615: oId_Nil
15616: oPushResult
15617: oCall 14972
15619: oPop 2
15621: oAssign
15622: oGetLocal 1
15624: oPushResult
15625: oSetResult 21
15627: oPushResult
15628: oGetGlobal 14
15630: oPushResult
15631: oNodeSet
15632: oPop 3
15634: oGetLocal 1
15636: oPushResult
15637: oSetResult 22
15639: oPushResult
15640: oSetResult 0
15642: oPushResult
15643: oNodeSetInt
15644: oPop 3
15646: oGetLocal 1
15648: oPushResult
15649: oScopeDeclare
15650: oPop 1
15652: oGetAddrGlobal 17
15654: oPushResult
15655: oId_Ord
15656: oPushResult
15657: oCall 15016
15659: oPop 1
15661: oAssign
15662: oGetAddrGlobal 18
15664: oPushResult
15665: oId_Chr
15666: oPushResult
15667: oCall 15016
15669: oPop 1
15671: oAssign
15672: oGetAddrGlobal 19
15674: oPushResult
15675: oId_Pred
15676: oPushResult
15677: oCall 15016
15679: oPop 1
15681: oAssign
15682: oGetAddrGlobal 20
15684: oPushResult
15685: oId_Succ
15686: oPushResult
15687: oCall 15016
15689: oPop 1
15691: oAssign
15692: oGetAddrGlobal 21
15694: oPushResult
15695: oId_Sizeof
15696: oPushResult
15697: oCall 15016
15699: oPop 1
15701: oAssign
15702: oReturn
